"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.PREDEFINED_PACKAGE_VERSION = exports.PREDEFINED_PACKAGE_NAME = void 0;
exports.getPredefinedResourcePaths = getPredefinedResourcePaths;
exports.loadPredefinedResources = loadPredefinedResources;
const fs_extra_1 = __importDefault(require("fs-extra"));
const path_1 = __importDefault(require("path"));
const fhir_package_loader_1 = require("fhir-package-loader");
const utils_1 = require("../utils");
exports.PREDEFINED_PACKAGE_NAME = 'sushi-local';
exports.PREDEFINED_PACKAGE_VERSION = 'LOCAL';
/**
 * Gets the local resource directory paths corresponding to the typical locations in an IG
 * as well as those configured in the IG parameter path-resource. Only those directories
 * that exist will be returned.
 * @param {string} resourceDir - The path to the directory containing the resource subdirs
 * @param {string} projectDir - User's specified project directory
 * @param {ImplementationGuideDefinitionParameter[]} configParameters - optional, an array of
 *    config parameters in which to  determine if there are additional resource paths for
 *    predefined resource
 * @returns string[] list of paths to search for predefined resources
 */
function getPredefinedResourcePaths(resourceDir, projectDir = null, configParameters = null) {
    const pathEnds = [
        'capabilities',
        'extensions',
        'models',
        'operations',
        'profiles',
        'resources',
        'vocabulary',
        'examples'
    ];
    const predefinedResourcePaths = new Set(pathEnds.map(pathEnd => path_1.default.join(resourceDir, pathEnd)).filter(p => fs_extra_1.default.existsSync(p)));
    if (configParameters && projectDir) {
        const pathResources = configParameters
            .filter(parameter => parameter.value && parameter.code === 'path-resource')
            .map(parameter => parameter.value);
        pathResources.forEach(pathResource => {
            const fullPath = path_1.default.join(projectDir, ...pathResource.replace(/\/\*$/, '').split('/'));
            if (fs_extra_1.default.existsSync(fullPath)) {
                predefinedResourcePaths.add(fullPath);
                // path-resource paths ending with /* should recursively include subfolders
                if (pathResource.endsWith('/*')) {
                    // Note: Do not use readdirSync w/ {recursive: true} since it was only added in Node 18.17.
                    const addRecursiveChildFolders = (folderPath) => {
                        const stat = fs_extra_1.default.statSync(folderPath);
                        if (stat.isDirectory()) {
                            fs_extra_1.default.readdirSync(folderPath, { withFileTypes: true }).forEach(entry => {
                                if (entry.isDirectory()) {
                                    const childFolder = path_1.default.resolve(folderPath, entry.name);
                                    predefinedResourcePaths.add(childFolder);
                                    addRecursiveChildFolders(childFolder);
                                }
                            });
                        }
                    };
                    addRecursiveChildFolders(fullPath);
                }
            }
        });
    }
    return Array.from(predefinedResourcePaths);
}
/**
 * Loads predefined resources from the typical locations in an IG as well as those configured
 * in the IG parameter path-resource.
 * @param {string} resourceDir - The path to the directory containing the resource subdirs
 * @param {string} projectDir - User's specified project directory
 * @param {ImplementationGuideDefinitionParameter[]} configParameters - optional, an array of
 *    config parameters in which to  determine if there are additional resource paths for
 *    predefined resource
 * @returns Promise<LoadStatus> the load status ('LOADED' or 'FAILED')
 */
async function loadPredefinedResources(defs, resourceDir, projectDir = null, configParameters = null) {
    const localResourcePaths = getPredefinedResourcePaths(resourceDir, projectDir, configParameters);
    const status = await defs.loadVirtualPackage(new fhir_package_loader_1.DiskBasedVirtualPackage({ name: exports.PREDEFINED_PACKAGE_NAME, version: exports.PREDEFINED_PACKAGE_VERSION }, localResourcePaths, {
        log: utils_1.logMessage,
        allowNonResources: true, // support for logical instances
        recursive: true
    }));
    return status;
}
//# sourceMappingURL=predefinedResources.js.map