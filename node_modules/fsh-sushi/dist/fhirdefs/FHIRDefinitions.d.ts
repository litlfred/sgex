import { BasePackageLoader, BasePackageLoaderOptions, CurrentBuildClient, PackageCache, PackageDB, RegistryClient } from 'fhir-package-loader';
import { Type, Metadata, Fishable } from '../utils';
export declare class FHIRDefinitions extends BasePackageLoader implements Fishable {
    readonly isSupplementalFHIRDefinitions: boolean;
    private supplementalFHIRDefinitionsFactory?;
    private fplLogInterceptor;
    private fplPackageDB;
    private supplementalFHIRDefinitions;
    constructor(isSupplementalFHIRDefinitions?: boolean, supplementalFHIRDefinitionsFactory?: () => Promise<FHIRDefinitions>, override?: {
        packageDB?: PackageDB;
        packageCache?: PackageCache;
        registryClient?: RegistryClient;
        currentBuildClient?: CurrentBuildClient;
        options?: BasePackageLoaderOptions;
    });
    get supplementalFHIRPackages(): string[];
    initialize(): Promise<void>;
    /**
     * An interceptor that can suppress FPL log messages based on level or message. This is
     * primarily used to suppress error logs when loading automatic dependencies.
     * @param interceptor an interceptor method that receives log information and returns true to
     *     continue logging or false to suppress that log statement
     */
    setFHIRPackageLoaderLogInterceptor(interceptor?: (level: string, message: string) => boolean): void;
    addSupplementalFHIRDefinitions(fhirPackage: string, definitions: FHIRDefinitions): void;
    getSupplementalFHIRDefinitions(fhirPackage: string): FHIRDefinitions;
    /**
     * Loads a "supplemental" FHIR package other than the primary FHIR version being used. This is
     * needed to support extensions for converting between versions (e.g., "implied" extensions).
     * The definitions from the supplemental FHIR package are not loaded into the main set of
     * definitions, but rather, are loaded into their own private FHIRDefinitions.
     * @param fhirPackage - the FHIR package to load in the format {packageId}#{version}
     * @returns Promise<void> promise that always resolves successfully (even if there is an error)
     */
    loadSupplementalFHIRPackage(fhirPackage: string): Promise<void>;
    allPredefinedResources(): any[];
    fishForPredefinedResource(item: string, ...types: Type[]): any | undefined;
    fishForPredefinedResourceMetadata(item: string, ...types: Type[]): Metadata | undefined;
    fishForPredefinedResourceMetadatas(item: string, ...types: Type[]): Metadata[];
    fishForFHIR(item: string, ...types: Type[]): any | undefined;
    fishForMetadata(item: string, ...types: Type[]): Metadata | undefined;
    fishForMetadatas(item: string, ...types: Type[]): Metadata[];
}
export declare function createFHIRDefinitions(isSupplementalFHIRDefinitions?: boolean, supplementalFHIRDefinitionsFactory?: () => Promise<FHIRDefinitions>, override?: {
    packageDB?: PackageDB;
    packageCache?: PackageCache;
    registryClient?: RegistryClient;
    currentBuildClient?: CurrentBuildClient;
    options?: BasePackageLoaderOptions;
}): Promise<FHIRDefinitions>;
