"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.FHIRDefinitions = void 0;
exports.createFHIRDefinitions = createFHIRDefinitions;
const path_1 = __importDefault(require("path"));
const os_1 = __importDefault(require("os"));
const lodash_1 = require("lodash");
const fhir_package_loader_1 = require("fhir-package-loader");
const ig_1 = require("../ig");
const utils_1 = require("../utils");
const impliedExtensions_1 = require("./impliedExtensions");
const FISHING_ORDER = [
    utils_1.Type.Resource,
    utils_1.Type.Logical,
    utils_1.Type.Type,
    utils_1.Type.Profile,
    utils_1.Type.Extension,
    utils_1.Type.ValueSet,
    utils_1.Type.CodeSystem
];
const DEFAULT_SORT = [(0, fhir_package_loader_1.byType)(...FISHING_ORDER), (0, fhir_package_loader_1.byLoadOrder)(false)];
class FHIRDefinitions extends fhir_package_loader_1.BasePackageLoader {
    constructor(isSupplementalFHIRDefinitions = false, supplementalFHIRDefinitionsFactory, 
    // override is mainly intended to be used in unit tests
    override) {
        var _a, _b, _c, _d;
        let options = {
            // Analysis of 500 projects shows most only need a cache of 100. Double it for the others.
            resourceCacheSize: 200,
            // Cloning every resource is slow, but we need some safety from unintentional modification.
            safeMode: fhir_package_loader_1.SafeMode.FREEZE,
            // Use the same logger as SUSHI uses
            log: (level, message) => {
                // if there is an interceptor, invoke it and suppress the log if appropriate
                if (this.fplLogInterceptor) {
                    const continueToLog = this.fplLogInterceptor(level, message);
                    if (!continueToLog) {
                        return;
                    }
                }
                utils_1.logger.log(level, message);
            }
        };
        if (override === null || override === void 0 ? void 0 : override.options) {
            options = Object.assign(options, override.options);
        }
        const packageDB = (_a = override === null || override === void 0 ? void 0 : override.packageDB) !== null && _a !== void 0 ? _a : new fhir_package_loader_1.SQLJSPackageDB();
        const fhirCache = path_1.default.join(os_1.default.homedir(), '.fhir', 'packages');
        const packageCache = (_b = override === null || override === void 0 ? void 0 : override.packageCache) !== null && _b !== void 0 ? _b : new fhir_package_loader_1.DiskBasedPackageCache(fhirCache, options);
        const registryClient = (_c = override === null || override === void 0 ? void 0 : override.registryClient) !== null && _c !== void 0 ? _c : new fhir_package_loader_1.DefaultRegistryClient(options);
        const buildClient = (_d = override === null || override === void 0 ? void 0 : override.currentBuildClient) !== null && _d !== void 0 ? _d : new fhir_package_loader_1.BuildDotFhirDotOrgClient(options);
        super(packageDB, packageCache, registryClient, buildClient, options);
        this.isSupplementalFHIRDefinitions = isSupplementalFHIRDefinitions;
        this.supplementalFHIRDefinitionsFactory = supplementalFHIRDefinitionsFactory;
        this.fplPackageDB = packageDB;
        this.supplementalFHIRDefinitions = new Map();
        if (!supplementalFHIRDefinitionsFactory) {
            this.supplementalFHIRDefinitionsFactory = async () => {
                const fhirDefs = new FHIRDefinitions(true);
                await fhirDefs.initialize();
                return fhirDefs;
            };
        }
    }
    // This getter is only used in tests to verify what supplemental packages are loaded
    get supplementalFHIRPackages() {
        return (0, lodash_1.flatten)(Array.from(this.supplementalFHIRDefinitions.keys()));
    }
    async initialize() {
        if (this.fplPackageDB instanceof fhir_package_loader_1.SQLJSPackageDB) {
            await this.fplPackageDB.initialize();
        }
    }
    /**
     * An interceptor that can suppress FPL log messages based on level or message. This is
     * primarily used to suppress error logs when loading automatic dependencies.
     * @param interceptor an interceptor method that receives log information and returns true to
     *     continue logging or false to suppress that log statement
     */
    setFHIRPackageLoaderLogInterceptor(interceptor) {
        this.fplLogInterceptor = interceptor;
    }
    addSupplementalFHIRDefinitions(fhirPackage, definitions) {
        this.supplementalFHIRDefinitions.set(fhirPackage, definitions);
    }
    getSupplementalFHIRDefinitions(fhirPackage) {
        return this.supplementalFHIRDefinitions.get(fhirPackage);
    }
    /**
     * Loads a "supplemental" FHIR package other than the primary FHIR version being used. This is
     * needed to support extensions for converting between versions (e.g., "implied" extensions).
     * The definitions from the supplemental FHIR package are not loaded into the main set of
     * definitions, but rather, are loaded into their own private FHIRDefinitions.
     * @param fhirPackage - the FHIR package to load in the format {packageId}#{version}
     * @returns Promise<void> promise that always resolves successfully (even if there is an error)
     */
    async loadSupplementalFHIRPackage(fhirPackage) {
        const supplementalDefs = await this.supplementalFHIRDefinitionsFactory();
        const [fhirPackageId, fhirPackageVersion] = fhirPackage.split('#');
        await supplementalDefs
            .loadPackage(fhirPackageId, fhirPackageVersion)
            .then(status => {
            if (status == 'LOADED') {
                this.addSupplementalFHIRDefinitions(fhirPackage, supplementalDefs);
            }
        })
            .catch(e => {
            utils_1.logger.error(`Failed to load supplemental FHIR package ${fhirPackage}: ${e.message}`);
            if (e.stack) {
                utils_1.logger.debug(e.stack);
            }
        });
    }
    allPredefinedResources() {
        var _a;
        // Return in FIFO order to match previous SUSHI behavior
        const options = {
            scope: ig_1.PREDEFINED_PACKAGE_NAME,
            sort: [(0, fhir_package_loader_1.byLoadOrder)(true)]
        };
        return (_a = this.findResourceJSONs('*', options)) !== null && _a !== void 0 ? _a : [];
    }
    fishForPredefinedResource(item, ...types) {
        return this.findResourceJSON(item, {
            type: normalizeTypes(types),
            scope: ig_1.PREDEFINED_PACKAGE_NAME,
            sort: DEFAULT_SORT
        });
    }
    fishForPredefinedResourceMetadata(item, ...types) {
        const info = this.findResourceInfo(item, {
            type: normalizeTypes(types),
            scope: ig_1.PREDEFINED_PACKAGE_NAME,
            sort: DEFAULT_SORT
        });
        return convertInfoToMetadata(info);
    }
    fishForPredefinedResourceMetadatas(item, ...types) {
        const infos = this.findResourceInfos(item, {
            type: normalizeTypes(types),
            scope: ig_1.PREDEFINED_PACKAGE_NAME,
            sort: DEFAULT_SORT
        });
        return infos.map(info => convertInfoToMetadata(info));
    }
    fishForFHIR(item, ...types) {
        const def = this.findResourceJSON(item, {
            type: normalizeTypes(types),
            sort: DEFAULT_SORT
        });
        if (def) {
            return def;
        }
        // If it's an "implied extension", try to materialize it. See:http://hl7.org/fhir/versions.html#extensions
        if (impliedExtensions_1.IMPLIED_EXTENSION_REGEX.test(item) && types.some(t => t === utils_1.Type.Extension)) {
            return (0, impliedExtensions_1.materializeImpliedExtension)(item, this);
        }
    }
    fishForMetadata(item, ...types) {
        const info = this.findResourceInfo(item, {
            type: normalizeTypes(types),
            sort: DEFAULT_SORT
        });
        if (info) {
            return convertInfoToMetadata(info);
        }
        // If it's an "implied extension", try to materialize it. See:http://hl7.org/fhir/versions.html#extensions
        if (impliedExtensions_1.IMPLIED_EXTENSION_REGEX.test(item) && types.some(t => t === utils_1.Type.Extension)) {
            return (0, impliedExtensions_1.materializeImpliedExtensionMetadata)(item, this);
        }
    }
    fishForMetadatas(item, ...types) {
        const infos = this.findResourceInfos(item, {
            type: normalizeTypes(types),
            sort: DEFAULT_SORT
        });
        if (infos.length) {
            return infos.map(info => convertInfoToMetadata(info));
        }
        // If it's an "implied extension", try to materialize it. See:http://hl7.org/fhir/versions.html#extensions
        if (impliedExtensions_1.IMPLIED_EXTENSION_REGEX.test(item) && types.some(t => t === utils_1.Type.Extension)) {
            const info = (0, impliedExtensions_1.materializeImpliedExtensionMetadata)(item, this);
            if (info) {
                return [info];
            }
        }
        return [];
    }
}
exports.FHIRDefinitions = FHIRDefinitions;
async function createFHIRDefinitions(isSupplementalFHIRDefinitions = false, supplementalFHIRDefinitionsFactory, 
// override is mainly intended to be used in unit tests
override) {
    const fhirDefinitions = new FHIRDefinitions(isSupplementalFHIRDefinitions, supplementalFHIRDefinitionsFactory, override);
    await fhirDefinitions.initialize();
    return fhirDefinitions;
}
function normalizeTypes(types) {
    // Instance is like a wildcard, allowing anything -- so treat it like no types are passed in at all
    return (types === null || types === void 0 ? void 0 : types.some(t => t === utils_1.Type.Instance)) ? undefined : types;
}
function convertInfoToMetadata(info) {
    if (info) {
        // Note: explicitly return undefined instead of null to keep tests happy
        return {
            id: info.id || undefined,
            name: info.name || undefined,
            sdType: info.sdType || undefined,
            url: info.url || undefined,
            parent: info.sdBaseDefinition || undefined,
            imposeProfiles: info.sdImposeProfiles || undefined,
            abstract: info.sdAbstract != null ? info.sdAbstract : undefined,
            version: info.version || undefined,
            resourceType: info.resourceType || undefined,
            canBeTarget: logicalCharacteristic(info, 'can-be-target'),
            canBind: logicalCharacteristic(info, 'can-bind'),
            resourcePath: info.resourcePath || undefined
        };
    }
}
function logicalCharacteristic(info, characteristic) {
    var _a, _b;
    // return true or false for logicals, otherwise leave it undefined
    if (info.sdKind === 'logical') {
        return (_b = (_a = info.sdCharacteristics) === null || _a === void 0 ? void 0 : _a.some(c => c === characteristic)) !== null && _b !== void 0 ? _b : false;
    }
}
//# sourceMappingURL=FHIRDefinitions.js.map