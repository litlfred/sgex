"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.SQLJSPackageDB = void 0;
exports.createSQLJSPackageDB = createSQLJSPackageDB;
const sql_js_1 = __importDefault(require("sql.js"));
const CREATE_PACKAGE_TABLE = `CREATE TABLE package (
  rowid INTEGER PRIMARY KEY,
  name CHAR,
  version CHAR,
  packagePath CHAR,
  packageJSONPath CHAR
);`;
const CREATE_PACKAGE_TABLE_INDICES = [
    'CREATE INDEX idx_package_rowid ON package (rowid);',
    'CREATE INDEX idx_package_name_version ON package (name, version);'
].join(' ');
const INSERT_PACKAGE = `INSERT INTO package
  (
    name,
    version,
    packagePath,
    packageJSONPath
  ) VALUES (
    :name,
    :version,
    :packagePath,
    :packageJSONPath
  )`;
const FIND_ALL_PACKAGES = 'SELECT * FROM package';
const FIND_PACKAGES = 'SELECT * FROM package WHERE name = :name';
const FIND_PACKAGE = 'SELECT * FROM package WHERE name = :name and version = :version LIMIT 1';
const CREATE_RESOURCE_TABLE = `CREATE TABLE resource (
  rowid INTEGER PRIMARY KEY,
  resourceType CHAR,
  id CHAR,
  url CHAR,
  name CHAR,
  version CHAR,
  sdKind CHAR,
  sdDerivation CHAR,
  sdType CHAR,
  sdBaseDefinition CHAR,
  sdAbstract BOOL,
  sdImposeProfiles CHAR,
  sdCharacteristics CHAR,
  sdFlavor CHAR,
  packageName CHAR,
  packageVersion CHAR,
  resourcePath CHAR
);`;
const CREATE_RESOURCE_TABLE_INDICES = [
    'CREATE INDEX idx_resource_rowid ON resource (rowid);',
    'CREATE INDEX idx_resource_id_resourceType_sdFlavor ON resource (id, resourceType, sdFlavor);',
    'CREATE INDEX idx_resource_url_resourceType_sdFlavor ON resource (url, resourceType, sdFlavor);',
    'CREATE INDEX idx_resource_name_resourceType_sdFlavor ON resource (name, resourceType, sdFlavor);',
    'CREATE INDEX idx_resource_sdFlavor ON resource (sdFlavor);',
    'CREATE INDEX idx_resource_resourceType ON resource (resourceType);',
    'CREATE INDEX idx_resource_packageName_packageVersion ON resource (packageName, packageVersion);'
].join(' ');
const INSERT_RESOURCE = `INSERT INTO resource
  (
    resourceType,
    id,
    url,
    name,
    version,
    sdKind,
    sdDerivation,
    sdType,
    sdBaseDefinition,
    sdAbstract,
    sdImposeProfiles,
    sdCharacteristics,
    sdFlavor,
    packageName,
    packageVersion,
    resourcePath
  ) VALUES (
    :resourceType,
    :id,
    :url,
    :name,
    :version,
    :sdKind,
    :sdDerivation,
    :sdType,
    :sdBaseDefinition,
    :sdAbstract,
    :sdImposeProfiles,
    :sdCharacteristics,
    :sdFlavor,
    :packageName,
    :packageVersion,
    :resourcePath
  );`;
const SD_FLAVORS = ['Extension', 'Logical', 'Profile', 'Resource', 'Type'];
class SQLJSPackageDB {
    constructor() {
        this.initialized = false;
    }
    initialize() {
        return __awaiter(this, arguments, void 0, function* (options = {}) {
            if (!this.initialized) {
                const SQL = yield (0, sql_js_1.default)(Object.assign({}, (options.locateFile && { locateFile: options.locateFile })));
                // check initialization state once more since initSqlJs call was async (possible race condition)
                if (!this.initialized) {
                    this.db = new SQL.Database();
                    this.db.run([
                        CREATE_PACKAGE_TABLE,
                        CREATE_PACKAGE_TABLE_INDICES,
                        CREATE_RESOURCE_TABLE,
                        CREATE_RESOURCE_TABLE_INDICES
                    ].join(';'));
                    this.insertPackageStmt = this.db.prepare(INSERT_PACKAGE);
                    this.insertResourceStmt = this.db.prepare(INSERT_RESOURCE);
                    this.findAllPackagesStmt = this.db.prepare(FIND_ALL_PACKAGES);
                    this.findPackagesStmt = this.db.prepare(FIND_PACKAGES);
                    this.findPackageStmt = this.db.prepare(FIND_PACKAGE);
                    this.initialized = true;
                    this.optimized = false;
                }
            }
        });
    }
    isInitialized() {
        return this.initialized;
    }
    clear() {
        if (this.db) {
            this.db.exec('DELETE FROM package');
            this.db.exec('DELETE FROM resource');
            this.db.exec('VACUUM');
            this.optimized = false;
        }
    }
    optimize() {
        if (this.db) {
            if (!this.optimized) {
                this.db.exec('PRAGMA optimize=0x10002');
                this.optimized = true;
            }
            else {
                this.db.exec('PRAGMA optimize');
            }
        }
    }
    savePackageInfo(info) {
        if (!this.db) {
            throw new Error('SQLJSPackageDB not initialized. Please call the initialize() function before using this class.');
        }
        const binding = {
            ':name': info.name,
            ':version': info.version
        };
        if (info.packagePath) {
            binding[':packagePath'] = info.packagePath;
        }
        if (info.packageJSONPath) {
            binding[':packageJSONPath'] = info.packageJSONPath;
        }
        this.insertPackageStmt.run(binding);
    }
    saveResourceInfo(info) {
        var _a, _b;
        if (!this.db) {
            throw new Error('SQLJSPackageDB not initialized. Please call the initialize() function before using this class.');
        }
        const binding = {
            ':resourceType': info.resourceType
        };
        if (info.id) {
            binding[':id'] = info.id;
        }
        if (info.url) {
            binding[':url'] = info.url;
        }
        if (info.name) {
            binding[':name'] = info.name;
        }
        if (info.version) {
            binding[':version'] = info.version;
        }
        if (info.resourceType === 'StructureDefinition') {
            if (info.sdKind) {
                binding[':sdKind'] = info.sdKind;
            }
            if (info.sdDerivation) {
                binding[':sdDerivation'] = info.sdDerivation;
            }
            if (info.sdType) {
                binding[':sdType'] = info.sdType;
            }
            if (info.sdBaseDefinition) {
                binding[':sdBaseDefinition'] = info.sdBaseDefinition;
            }
            if (info.sdAbstract != null) {
                binding[':sdAbstract'] = info.sdAbstract;
            }
            if ((_a = info.sdImposeProfiles) === null || _a === void 0 ? void 0 : _a.length) {
                // Technically we could do this w/ join tables, but that makes
                // more complex, so let's try this simpler solution first.
                binding[':sdImposeProfiles'] = JSON.stringify(info.sdImposeProfiles);
            }
            if ((_b = info.sdCharacteristics) === null || _b === void 0 ? void 0 : _b.length) {
                // Technically we could do this w/ join tables, but that makes
                // more complex, so let's try this simpler solution first.
                binding[':sdCharacteristics'] = JSON.stringify(info.sdCharacteristics);
            }
            if (info.sdFlavor) {
                binding[':sdFlavor'] = info.sdFlavor;
            }
        }
        if (info.packageName) {
            binding[':packageName'] = info.packageName;
        }
        if (info.packageVersion) {
            binding[':packageVersion'] = info.packageVersion;
        }
        if (info.resourcePath) {
            binding[':resourcePath'] = info.resourcePath;
        }
        this.insertResourceStmt.run(binding);
    }
    findPackageInfos(name) {
        if (!this.db) {
            throw new Error('SQLJSPackageDB not initialized. Please call the initialize() function before using this class.');
        }
        const results = [];
        const findStmt = name === '*' ? this.findAllPackagesStmt : this.findPackagesStmt;
        try {
            if (name !== '*') {
                findStmt.bind({ ':name': name });
            }
            while (findStmt.step()) {
                results.push(findStmt.getAsObject());
            }
        }
        finally {
            findStmt.reset();
        }
        return results;
    }
    findPackageInfo(name, version) {
        if (!this.db) {
            throw new Error('SQLJSPackageDB not initialized. Please call the initialize() function before using this class.');
        }
        try {
            this.findPackageStmt.bind({ ':name': name, ':version': version });
            if (this.findPackageStmt.step()) {
                return this.findPackageStmt.getAsObject();
            }
        }
        finally {
            this.findPackageStmt.reset();
        }
    }
    findResourceInfos(key, options = {}) {
        var _a, _b;
        if (!this.db) {
            throw new Error('SQLJSPackageDB not initialized. Please call the initialize() function before using this class.');
        }
        // In case a key wasn't supplied, just use empty string. Later we might have it return ALL.
        if (key == null) {
            key = '';
        }
        const [keyText, ...keyVersion] = key.split('|');
        const bindStmt = {};
        const conditions = [];
        let findStmt = 'SELECT * FROM resource';
        if (keyText !== '*') {
            // special case for selecting all
            bindStmt[':key'] = keyText;
            conditions.push('(id = :key OR name = :key OR url = :key)');
        }
        if (keyVersion.length) {
            bindStmt[':version'] = keyVersion.join('|');
            conditions.push('version = :version');
        }
        if ((_a = options.type) === null || _a === void 0 ? void 0 : _a.length) {
            // build condition to take advantage of indices w/ resourceType and sdFlavor
            const sdFlavors = [];
            const resourceTypes = [];
            options.type.forEach((t, i) => {
                bindStmt[`:type${i}`] = t;
                (SD_FLAVORS.includes(t) ? sdFlavors : resourceTypes).push(`:type${i}`);
            });
            let rtStatement;
            if (resourceTypes.length === 1) {
                rtStatement = `resourceType = ${resourceTypes[0]}`;
            }
            else if (resourceTypes.length > 1) {
                rtStatement = `resourceType in (${resourceTypes.join(', ')})`;
            }
            let sdfStatement;
            if (sdFlavors.length === 1) {
                sdfStatement = `sdFlavor = ${sdFlavors[0]}`;
            }
            else if (sdFlavors.length > 1) {
                sdfStatement = `sdFlavor in (${sdFlavors.join(', ')})`;
            }
            if (resourceTypes.length) {
                if (sdFlavors.length) {
                    conditions.push(`(${rtStatement} OR ${sdfStatement})`);
                }
                else {
                    conditions.push(rtStatement);
                }
            }
            else {
                conditions.push(`resourceType = "StructureDefinition" AND ${sdfStatement}`);
            }
        }
        if ((_b = options.scope) === null || _b === void 0 ? void 0 : _b.length) {
            const [packageName, ...packageVersion] = options.scope.split('|');
            bindStmt[':packageName'] = packageName;
            conditions.push('packageName = :packageName');
            if (packageVersion.length) {
                bindStmt[':packageVersion'] = packageVersion.join('|');
                conditions.push('packageVersion = :packageVersion');
            }
        }
        if (conditions.length) {
            findStmt += ` WHERE ${conditions.join(' AND ')}`;
        }
        if (options.sort) {
            const sortExpressions = [];
            options.sort.forEach(s => {
                switch (s.sortBy) {
                    case 'LoadOrder':
                        sortExpressions.push(`rowid ${s.ascending ? 'ASC' : 'DESC'}`);
                        break;
                    case 'Type':
                        s.types.forEach((t, i) => {
                            bindStmt[`:sortType${i}`] = t;
                            const field = SD_FLAVORS.includes(t) ? 'sdFlavor' : 'resourceType';
                            // This sort expression is weird, but... it's the only way it works as expected!
                            sortExpressions.push(`(${field} = :sortType${i} OR NULL) DESC`);
                        });
                        break;
                }
            });
            findStmt += ` ORDER BY ${sortExpressions.join(', ')}`;
        }
        else {
            findStmt += ' ORDER BY rowid ASC';
        }
        if (options.limit) {
            bindStmt[':limit'] = String(options.limit);
            findStmt += ' LIMIT :limit';
        }
        const stmt = this.db.prepare(findStmt);
        stmt.bind(bindStmt);
        const results = [];
        while (stmt.step()) {
            const result = stmt.getAsObject();
            if (result.sdImposeProfiles) {
                result.sdImposeProfiles = JSON.parse(result.sdImposeProfiles);
            }
            if (result.sdCharacteristics) {
                result.sdCharacteristics = JSON.parse(result.sdCharacteristics);
            }
            if (result.sdAbstract != null) {
                result.sdAbstract = result.sdAbstract ? true : false;
            }
            results.push(result);
        }
        stmt.free();
        return results;
    }
    findResourceInfo(key, options = {}) {
        if (!this.db) {
            throw new Error('SQLJSPackageDB not initialized. Please call the initialize() function before using this class.');
        }
        // TODO: Make this more sophisticated if/when it makes sense
        const results = this.findResourceInfos(key, Object.assign(Object.assign({}, options), { limit: 1 }));
        if (results.length > 0) {
            return results[0];
        }
    }
    getPackageStats(name, version) {
        if (!this.db) {
            throw new Error('SQLJSPackageDB not initialized. Please call the initialize() function before using this class.');
        }
        const pkg = this.findPackageInfo(name, version);
        if (pkg == null) {
            return;
        }
        const count = this.db.exec('SELECT COUNT(*) from resource where packageName = :name and packageVersion = :version', { ':name': name, ':version': version })[0].values[0][0];
        return {
            name,
            version,
            resourceCount: count
        };
    }
    exportDB() {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.db) {
                return Promise.reject(new Error('SQLJSPackageDB not initialized. Please call the initialize() function before using this class.'));
            }
            const data = this.db.export();
            return Promise.resolve({ mimeType: 'application/x-sqlite3', data: Buffer.from(data) });
        });
    }
}
exports.SQLJSPackageDB = SQLJSPackageDB;
function createSQLJSPackageDB() {
    return __awaiter(this, void 0, void 0, function* () {
        const packageDB = new SQLJSPackageDB();
        yield packageDB.initialize();
        return packageDB;
    });
}
//# sourceMappingURL=SQLJSPackageDB.js.map