"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.BasePackageLoader = exports.SafeMode = void 0;
const path_1 = __importDefault(require("path"));
const lodash_1 = require("lodash");
const mnemonist_1 = require("mnemonist");
const errors_1 = require("../errors");
const PackageLoader_1 = require("./PackageLoader");
const DEFAULT_RESOURCE_CACHE_SIZE = 200;
var SafeMode;
(function (SafeMode) {
    SafeMode["OFF"] = "OFF";
    SafeMode["FREEZE"] = "FREEZE";
    SafeMode["CLONE"] = "CLONE";
})(SafeMode || (exports.SafeMode = SafeMode = {}));
const CERTIFICATE_MESSAGE = '\n\nSometimes this error occurs in corporate or educational environments that use proxies and/or SSL ' +
    'inspection.\nTroubleshooting tips:\n' +
    '  1. If a non-proxied network is available, consider connecting to that network instead.\n' +
    '  2. Set NODE_EXTRA_CA_CERTS as described at https://bit.ly/3ghJqJZ (RECOMMENDED).\n' +
    '  3. Disable certificate validation as described at https://bit.ly/3syjzm7 (NOT RECOMMENDED).\n';
class BasePackageLoader {
    constructor(packageDB, packageCache, registryClient, currentBuildClient, options = {}) {
        var _a, _b, _c;
        this.packageDB = packageDB;
        this.packageCache = packageCache;
        this.registryClient = registryClient;
        this.currentBuildClient = currentBuildClient;
        this.log = (_a = options.log) !== null && _a !== void 0 ? _a : (() => { });
        this.virtualPackages = new Map();
        const resourceCacheSize = (_b = options.resourceCacheSize) !== null && _b !== void 0 ? _b : DEFAULT_RESOURCE_CACHE_SIZE;
        if (resourceCacheSize > 0) {
            this.resourceCache = new mnemonist_1.LRUCache(resourceCacheSize);
        }
        this.safeMode = (_c = options.safeMode) !== null && _c !== void 0 ? _c : SafeMode.OFF;
    }
    loadPackage(name, version) {
        return __awaiter(this, void 0, void 0, function* () {
            let packageLabel = `${name}#${version}`;
            const originalVersion = version;
            version = yield this.registryClient.resolveVersion(name, version);
            if (version !== originalVersion) {
                this.log('info', `Resolved ${packageLabel} to concrete version ${version}`);
                packageLabel = `${name}#${version}`;
            }
            // If it's already loaded, then there's nothing to do
            if (this.getPackageLoadStatus(name, version) === PackageLoader_1.LoadStatus.LOADED) {
                this.log('info', `${packageLabel} already loaded`);
                return PackageLoader_1.LoadStatus.LOADED;
            }
            // If it's a "dev" version, but it wasn't found in the cache, fall back to using the current version
            if (version === 'dev' && !this.packageCache.isPackageInCache(name, version)) {
                this.log('info', `Falling back to ${name}#current since ${packageLabel} is not locally cached. To avoid this, add ${packageLabel} to your local FHIR cache by building it locally with the HL7 FHIR IG Publisher.`);
                version = 'current';
                packageLabel = `${name}#${version}`;
            }
            let downloadErrorMessage;
            // If it's a "current" version, download the latest version from the build server (if applicable)
            if (isCurrentVersion(version)) {
                const branch = version.indexOf('$') !== -1 ? version.split('$')[1] : undefined;
                if (yield this.isCurrentVersionMissingOrStale(name, branch)) {
                    try {
                        const tarballStream = yield this.currentBuildClient.downloadCurrentBuild(name, branch);
                        yield this.packageCache.cachePackageTarball(name, version, tarballStream);
                    }
                    catch (e) {
                        downloadErrorMessage = `Failed to download most recent ${packageLabel} from current builds`;
                        if (/certificate/.test(e === null || e === void 0 ? void 0 : e.message)) {
                            downloadErrorMessage += CERTIFICATE_MESSAGE;
                        }
                    }
                }
            }
            // Else if it isn't "current" and isn't in the cache, download it from the registry
            else if (!this.packageCache.isPackageInCache(name, version)) {
                try {
                    const tarballStream = yield this.registryClient.download(name, version);
                    yield this.packageCache.cachePackageTarball(name, version, tarballStream);
                }
                catch (e) {
                    downloadErrorMessage = `Failed to download ${packageLabel} from the registry`;
                    if (/certificate/.test(e === null || e === void 0 ? void 0 : e.message)) {
                        downloadErrorMessage += CERTIFICATE_MESSAGE;
                    }
                }
            }
            // Finally attempt to load it from the cache
            let stats;
            try {
                stats = this.loadPackageFromCache(name, version);
            }
            catch (_a) {
                this.log('error', `Failed to load ${packageLabel}${downloadErrorMessage ? `: ${downloadErrorMessage}` : ''}`);
                return PackageLoader_1.LoadStatus.FAILED;
            }
            if (downloadErrorMessage) {
                // Loading succeeded despite a download error. This might happen if a current build is stale,
                // but the download fails, in which case the stale build will be loaded instead.
                this.log('warn', `${downloadErrorMessage}. Using most recent cached package instead.`);
            }
            this.log('info', `Loaded ${stats.name}#${stats.version} with ${stats.resourceCount} resources`);
            return PackageLoader_1.LoadStatus.LOADED;
        });
    }
    loadVirtualPackage(pkg) {
        return __awaiter(this, void 0, void 0, function* () {
            var _a, _b;
            // Ensure package.json has at least the name and version
            const packageJSON = pkg.getPackageJSON();
            if ((packageJSON === null || packageJSON === void 0 ? void 0 : packageJSON.name) == null ||
                packageJSON.name.trim() === '' ||
                packageJSON.version == null ||
                packageJSON.version.trim() == '') {
                this.log('error', `Failed to load virtual package ${(_a = packageJSON === null || packageJSON === void 0 ? void 0 : packageJSON.name) !== null && _a !== void 0 ? _a : '<unknown>'}#${(_b = packageJSON === null || packageJSON === void 0 ? void 0 : packageJSON.version) !== null && _b !== void 0 ? _b : '<unknown>'} because the provided packageJSON did not have a valid name and/or version`);
                return PackageLoader_1.LoadStatus.FAILED;
            }
            // If it's already loaded, then there's nothing to do
            if (this.getPackageLoadStatus(packageJSON.name, packageJSON.version) === PackageLoader_1.LoadStatus.LOADED) {
                this.log('info', `Virtual package ${packageJSON.name}#${packageJSON.version} already loaded`);
                return PackageLoader_1.LoadStatus.LOADED;
            }
            // Store the virtual package by its name#version key
            const packageKey = `${packageJSON.name}#${packageJSON.version}`;
            this.virtualPackages.set(packageKey, pkg);
            // Save the package info
            const info = {
                name: packageJSON.name,
                version: packageJSON.version,
                packagePath: `virtual:${packageKey}`,
                packageJSONPath: `virtual:${packageKey}:package.json`
            };
            this.packageDB.savePackageInfo(info);
            // Register the resources
            try {
                yield pkg.registerResources((key, resource, allowNonResources) => {
                    this.loadResource(`virtual:${packageKey}:${key}`, resource, packageJSON.name, packageJSON.version, allowNonResources);
                });
            }
            catch (e) {
                this.log('error', `Virtual package ${packageKey} threw an exception while registering resources, so it was only partially loaded.`);
                if (e.stack) {
                    this.log('debug', e.stack);
                }
                return PackageLoader_1.LoadStatus.FAILED;
            }
            const stats = this.packageDB.getPackageStats(packageJSON.name, packageJSON.version);
            this.log('info', `Loaded virtual package ${packageKey} with ${stats.resourceCount} resources`);
            return PackageLoader_1.LoadStatus.LOADED;
        });
    }
    loadPackageFromCache(name, version) {
        // Ensure the package is cached
        if (!this.packageCache.isPackageInCache(name, version)) {
            throw new Error(`${name}#${version} cannot be loaded from the package cache`);
        }
        // Get the cached package path and package.json path
        const packagePath = this.packageCache.getPackagePath(name, version);
        // Register the package information
        const info = {
            name,
            version
        };
        const packageJSONPath = this.packageCache.getPackageJSONPath(name, version);
        info.packagePath = path_1.default.resolve(packagePath);
        info.packageJSONPath = path_1.default.resolve(packageJSONPath);
        this.packageDB.savePackageInfo(info);
        // Load the resources within the package
        this.loadResourcesFromCache(name, version);
        return this.packageDB.getPackageStats(name, version);
    }
    loadResourcesFromCache(packageName, packageVersion) {
        this.packageCache
            .getPotentialResourcePaths(packageName, packageVersion)
            .forEach(resourcePath => {
            try {
                this.loadResourceFromCache(resourcePath, packageName, packageVersion);
            }
            catch (_a) {
                // swallow this error because some JSON files will not be resources
                // and don't log it if it is package.json (since every package should have one)
                if (path_1.default.basename(resourcePath) !== 'package.json') {
                    this.log('debug', `JSON file at path ${resourcePath} was not FHIR resource`);
                }
            }
        });
    }
    loadResourceFromCache(resourcePath, packageName, packageVersion) {
        const resourceJSON = this.packageCache.getResourceAtPath(resourcePath);
        this.loadResource(resourcePath, resourceJSON, packageName, packageVersion);
    }
    loadResource(resourcePath, resourceJSON, packageName, packageVersion, allowNonResources = false) {
        var _a;
        // We require at least a resourceType in order to know it is FHIR
        let resourceType = resourceJSON.resourceType;
        if (typeof resourceType !== 'string' || resourceType === '') {
            if (allowNonResources) {
                // SUSHI needs to support registering instances of logical models, but some code expects resourceType
                resourceType = 'Unknown';
            }
            else {
                throw new errors_1.InvalidResourceError(resourcePath, 'resource does not specify its resourceType');
            }
        }
        const info = { resourceType };
        if (typeof resourceJSON.id === 'string') {
            info.id = resourceJSON.id;
        }
        if (typeof resourceJSON.url === 'string') {
            info.url = resourceJSON.url;
        }
        if (typeof resourceJSON.name === 'string') {
            info.name = resourceJSON.name;
        }
        if (typeof resourceJSON.version === 'string') {
            info.version = resourceJSON.version;
        }
        if (resourceType === 'StructureDefinition') {
            if (typeof resourceJSON.kind === 'string') {
                info.sdKind = resourceJSON.kind;
            }
            // In R4, some things don't have derivation (e.g. Resource) so default to specialization
            if (typeof resourceJSON.derivation === 'string') {
                info.sdDerivation = resourceJSON.derivation;
            }
            else {
                info.sdDerivation = 'specialization';
            }
            if (typeof resourceJSON.type === 'string') {
                info.sdType = resourceJSON.type;
            }
            if (typeof resourceJSON.baseDefinition === 'string') {
                info.sdBaseDefinition = resourceJSON.baseDefinition;
            }
            info.sdAbstract = resourceJSON.abstract === true;
            const imposeProfiles = [];
            const characteristics = [];
            (_a = resourceJSON.extension) === null || _a === void 0 ? void 0 : _a.forEach((ext) => {
                if ((ext === null || ext === void 0 ? void 0 : ext.url) === 'http://hl7.org/fhir/StructureDefinition/structuredefinition-imposeProfile') {
                    imposeProfiles.push(ext.valueCanonical);
                }
                else if ((ext === null || ext === void 0 ? void 0 : ext.url) ===
                    'http://hl7.org/fhir/StructureDefinition/structuredefinition-type-characteristics') {
                    characteristics.push(ext.valueCode);
                }
                else if (
                // logical-target is a temporary alternate representation for can-be-target because
                // FHIR missed can-be-target in early versions of its characteristics value set
                (ext === null || ext === void 0 ? void 0 : ext.url) === 'http://hl7.org/fhir/tools/StructureDefinition/logical-target' &&
                    ext.valueBoolean) {
                    characteristics.push('can-be-target');
                }
            });
            if (imposeProfiles.length) {
                info.sdImposeProfiles = imposeProfiles;
            }
            if (characteristics.length) {
                info.sdCharacteristics = characteristics;
            }
            info.sdFlavor = getSDFlavor(resourceJSON);
        }
        if (packageName) {
            info.packageName = packageName;
        }
        if (packageVersion) {
            info.packageVersion = packageVersion;
        }
        info.resourcePath = resourcePath;
        this.packageDB.saveResourceInfo(info);
    }
    isCurrentVersionMissingOrStale(name, branch) {
        return __awaiter(this, void 0, void 0, function* () {
            let isStale = true;
            const version = branch ? `current$${branch}` : 'current';
            const packageJSONPath = this.packageCache.getPackageJSONPath(name, version);
            if (packageJSONPath) {
                try {
                    const packageJSON = this.packageCache.getResourceAtPath(packageJSONPath);
                    const cachedPackageDate = packageJSON.date;
                    if (cachedPackageDate) {
                        const packageLabel = `${name}#${version}`;
                        const latestBuildDate = yield this.currentBuildClient.getCurrentBuildDate(name, branch);
                        isStale = cachedPackageDate !== latestBuildDate;
                        if (isStale) {
                            this.log('debug', `Cached package date for ${packageLabel} (${formatDate(cachedPackageDate)}) does not match last build date (${formatDate(latestBuildDate)})`);
                            this.log('info', `Cached package ${packageLabel} is out of date and will be replaced by the most recent current build.`);
                        }
                        else {
                            this.log('debug', `Cached package date for ${packageLabel} (${formatDate(cachedPackageDate)}) matches last build date (${formatDate(latestBuildDate)}), so the cached package will be used`);
                        }
                    }
                }
                catch (_a) {
                    // do nothing -- will fall back to stale if we couldn't determine staleness
                }
            }
            return isStale;
        });
    }
    getResourceAtPath(resourcePath) {
        var _a, _b;
        let resource = (_a = this.resourceCache) === null || _a === void 0 ? void 0 : _a.get(resourcePath);
        if (!resource) {
            if (/^virtual:/.test(resourcePath)) {
                const [, packageKey, resourceKey] = resourcePath.match(/^virtual:([^:]+):(.*)$/);
                if (packageKey && resourceKey) {
                    const pkg = this.virtualPackages.get(packageKey);
                    resource =
                        resourceKey === 'package.json'
                            ? pkg === null || pkg === void 0 ? void 0 : pkg.getPackageJSON()
                            : pkg === null || pkg === void 0 ? void 0 : pkg.getResourceByKey(resourceKey);
                }
            }
            else {
                resource = this.packageCache.getResourceAtPath(resourcePath);
            }
            if (this.safeMode === SafeMode.FREEZE) {
                resource = deepFreeze(resource);
            }
            (_b = this.resourceCache) === null || _b === void 0 ? void 0 : _b.set(resourcePath, resource);
        }
        return this.safeMode === SafeMode.CLONE ? (0, lodash_1.cloneDeep)(resource) : resource;
    }
    getPackageLoadStatus(name, version) {
        const pkg = this.packageDB.findPackageInfo(name, version);
        if (pkg) {
            return PackageLoader_1.LoadStatus.LOADED;
        }
        return PackageLoader_1.LoadStatus.NOT_LOADED;
    }
    findPackageInfos(name) {
        return this.packageDB.findPackageInfos(name);
    }
    findPackageInfo(name, version) {
        return this.packageDB.findPackageInfo(name, version);
    }
    findPackageJSONs(name) {
        return this.findPackageInfos(name)
            .filter(info => info.packageJSONPath)
            .map(info => {
            return this.getResourceAtPath(info.packageJSONPath);
        });
    }
    findPackageJSON(name, version) {
        const info = this.findPackageInfo(name, version);
        if (info === null || info === void 0 ? void 0 : info.packageJSONPath) {
            return this.getResourceAtPath(info.packageJSONPath);
        }
    }
    findResourceInfos(key, options) {
        return this.packageDB.findResourceInfos(key, options);
    }
    findResourceInfo(key, options) {
        return this.packageDB.findResourceInfo(key, options);
    }
    findResourceJSONs(key, options) {
        return this.findResourceInfos(key, options)
            .filter(info => info.resourcePath)
            .map(info => {
            return this.getResourceAtPath(info.resourcePath);
        });
    }
    findResourceJSON(key, options) {
        const info = this.findResourceInfo(key, options);
        if (info === null || info === void 0 ? void 0 : info.resourcePath) {
            return this.getResourceAtPath(info.resourcePath);
        }
    }
    exportDB() {
        return this.packageDB.exportDB();
    }
    optimize() {
        this.packageDB.optimize();
    }
    clear() {
        this.packageDB.clear();
    }
}
exports.BasePackageLoader = BasePackageLoader;
function isCurrentVersion(version) {
    return /^current(\$.+)?$/.test(version);
}
/**
 * Takes a date in format YYYYMMDDHHmmss and converts to YYYY-MM-DDTHH:mm:ss
 * @param {string} date - The date to format
 * @returns {string} the formatted date
 */
function formatDate(date) {
    return date
        ? date.replace(/(\d{4})(\d{2})(\d{2})(\d{2})(\d{2})(\d{2})/, '$1-$2-$3T$4:$5:$6')
        : '';
}
function getSDFlavor(resourceJSON) {
    if (resourceJSON.resourceType === 'StructureDefinition') {
        if (resourceJSON.type === 'Extension' &&
            resourceJSON.baseDefinition !== 'http://hl7.org/fhir/StructureDefinition/Element') {
            return 'Extension';
        }
        else if (resourceJSON.derivation === 'constraint') {
            return 'Profile';
        }
        else if (/type/.test(resourceJSON.kind)) {
            return 'Type';
        }
        else if (resourceJSON.kind === 'resource') {
            return 'Resource';
        }
        else if (resourceJSON.kind === 'logical') {
            return 'Logical';
        }
    }
}
// See: https://www.geeksforgeeks.org/how-to-deep-freeze-an-object-in-javascript/
function deepFreeze(obj) {
    Object.keys(obj).forEach(property => {
        if (typeof obj[property] === 'object' &&
            obj[property] !== null &&
            !Object.isFrozen(obj[property])) {
            deepFreeze(obj[property]);
        }
    });
    return Object.freeze(obj);
}
//# sourceMappingURL=BasePackageLoader.js.map