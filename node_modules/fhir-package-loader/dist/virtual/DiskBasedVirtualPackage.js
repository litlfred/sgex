"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.DiskBasedVirtualPackage = void 0;
const path_1 = __importDefault(require("path"));
const fhir_1 = require("fhir/fhir");
const fs_extra_1 = __importDefault(require("fs-extra"));
class DiskBasedVirtualPackage {
    constructor(packageJSON, paths = [], options = {}) {
        var _a, _b, _c;
        this.packageJSON = packageJSON;
        this.paths = paths;
        this.log = (_a = options.log) !== null && _a !== void 0 ? _a : (() => { });
        this.allowNonResources = (_b = options.allowNonResources) !== null && _b !== void 0 ? _b : false;
        this.recursive = (_c = options.recursive) !== null && _c !== void 0 ? _c : false;
        this.fhirConverter = new fhir_1.Fhir();
        this.registeredKeys = new Set();
    }
    registerResources(register) {
        return __awaiter(this, void 0, void 0, function* () {
            var _a, _b, _c;
            const spreadSheetCounts = new Map();
            const invalidFileCounts = new Map();
            // Since every OS may load paths in a different order, ensure consistency by sorting the paths
            const filePaths = getFilePaths(this.paths, this.recursive).sort();
            for (const filePath of filePaths) {
                try {
                    const name = path_1.default.basename(filePath);
                    const parent = path_1.default.dirname(filePath);
                    // Is it a potential resource?
                    if (/\.json$/i.test(name)) {
                        register(filePath, this.getResourceAtPath(filePath), this.allowNonResources);
                        this.registeredKeys.add(filePath);
                    }
                    else if (/-spreadsheet\.xml$/i.test(name)) {
                        spreadSheetCounts.set(parent, ((_a = spreadSheetCounts.get(parent)) !== null && _a !== void 0 ? _a : 0) + 1);
                        this.log('debug', `Skipped spreadsheet XML file: ${filePath}`);
                    }
                    else if (/\.xml$/i.test(name)) {
                        const xml = fs_extra_1.default.readFileSync(filePath).toString();
                        if (/<\?mso-application progid="Excel\.Sheet"\?>/m.test(xml)) {
                            spreadSheetCounts.set(parent, ((_b = spreadSheetCounts.get(parent)) !== null && _b !== void 0 ? _b : 0) + 1);
                            this.log('debug', `Skipped spreadsheet XML file: ${filePath}`);
                        }
                        register(filePath, this.getResourceAtPath(filePath), this.allowNonResources);
                        this.registeredKeys.add(filePath);
                    }
                    else {
                        invalidFileCounts.set(parent, ((_c = invalidFileCounts.get(parent)) !== null && _c !== void 0 ? _c : 0) + 1);
                        this.log('debug', `Skipped non-JSON / non-XML file: ${filePath}`);
                    }
                }
                catch (e) {
                    if (/convert XML .* Unknown resource type/.test(e.message)) {
                        // Skip unknown FHIR resource types. When we have instances of Logical Models,
                        // the resourceType will not be recognized as a known FHIR resourceType, but that's okay.
                    }
                    else {
                        this.log('error', `Failed to register resource at path: ${filePath}`);
                        if (e.stack) {
                            this.log('debug', e.stack);
                        }
                    }
                }
            }
            spreadSheetCounts.forEach((count, folder) => {
                if (count) {
                    this.log('info', `Found ${count} spreadsheet(s) in directory: ${folder}. Spreadsheets are not supported, so any resources in the spreadsheets will be ignored. To see the skipped files in the logs, use debug logging.`);
                }
            });
            invalidFileCounts.forEach((count, folder) => {
                if (count) {
                    this.log('info', `Found ${count} non-JSON / non-XML file(s) in directory: ${folder}. Only resource files with JSON or XML extensions are supported. To see the skipped files in the logs, use debug logging.`);
                }
            });
        });
    }
    getPackageJSON() {
        return this.packageJSON;
    }
    getResourceByKey(key) {
        if (this.registeredKeys.has(key)) {
            return this.getResourceAtPath(key);
        }
        throw new Error(`Unregistered resource key: ${key}`);
    }
    getResourceAtPath(key) {
        let resource;
        if (/.xml$/i.test(key)) {
            let xml;
            try {
                xml = fs_extra_1.default.readFileSync(key).toString();
            }
            catch (_a) {
                throw new Error(`Failed to get XML resource at path ${key}`);
            }
            try {
                // TODO: Support other versions of FHIR during conversion
                resource = this.fhirConverter.xmlToObj(xml);
            }
            catch (e) {
                throw new Error(`Failed to convert XML resource at path ${key}: ${e.message}`);
            }
        }
        else if (/.json$/i.test(key)) {
            try {
                resource = fs_extra_1.default.readJSONSync(key);
            }
            catch (_b) {
                throw new Error(`Failed to get JSON resource at path ${key}`);
            }
        }
        else {
            throw new Error(`Failed to find XML or JSON file at path ${key}`);
        }
        return resource;
    }
}
exports.DiskBasedVirtualPackage = DiskBasedVirtualPackage;
function getFilePaths(paths, recursive) {
    const filePaths = new Set();
    paths.forEach(p => {
        const stat = fs_extra_1.default.statSync(p);
        if (stat.isFile()) {
            filePaths.add(path_1.default.resolve(p));
        }
        else if (stat.isDirectory()) {
            fs_extra_1.default.readdirSync(p, { withFileTypes: true }).forEach(entry => {
                if (entry.isFile()) {
                    filePaths.add(path_1.default.resolve(p, entry.name));
                }
                else if (recursive && entry.isDirectory()) {
                    getFilePaths([path_1.default.resolve(p, entry.name)], recursive).forEach(fp => filePaths.add(fp));
                }
            });
        }
    });
    return Array.from(filePaths);
}
//# sourceMappingURL=DiskBasedVirtualPackage.js.map