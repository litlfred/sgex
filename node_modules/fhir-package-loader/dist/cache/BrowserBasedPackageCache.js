"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.BrowserBasedPackageCache = void 0;
const zlib_1 = __importDefault(require("zlib"));
const tar_stream_1 = __importDefault(require("tar-stream"));
class BrowserBasedPackageCache {
    constructor(databaseName, options = {}) {
        var _a;
        this.databaseName = databaseName;
        this.log = (_a = options.log) !== null && _a !== void 0 ? _a : (() => { });
        this.localResourceMap = new Map();
    }
    // NOTE: need to call this after construction whenever using this PackageCache
    initialize(dependencies) {
        return __awaiter(this, void 0, void 0, function* () {
            const packageLabels = dependencies.map(d => `${d.name}#${d.version}`);
            return new Promise(resolve => {
                const openRequest = indexedDB.open(this.databaseName);
                openRequest.onsuccess = event => {
                    const database = event.target.result;
                    const initializePromises = packageLabels.map(packageLabel => initializeResourcesInLocalMap(database, packageLabel));
                    Promise.allSettled(initializePromises)
                        .then(results => results
                        .filter(result => result.status === 'fulfilled')
                        .forEach(result => {
                        const [packageLabel, resources] = result.value;
                        this.localResourceMap.set(packageLabel, resources);
                    }))
                        .then(() => {
                        database.close();
                        resolve();
                    });
                };
            });
        });
    }
    cachePackageTarball(name, version, data) {
        return __awaiter(this, void 0, void 0, function* () {
            const packageLabel = `${name}#${version}`;
            if (version === 'current' || version === 'dev') {
                // not currently supported in browsers
                throw Error('"current" or "dev" package versions are not yet supported.');
            }
            return new Promise(resolve => {
                const resources = [];
                // Extract the package
                const extract = tar_stream_1.default.extract();
                extract.on('entry', (header, stream, next) => {
                    let resourceData = '';
                    stream.on('data', chunk => {
                        resourceData += chunk.toString();
                    });
                    stream.on('end', () => {
                        try {
                            // Only add:
                            // - files that are directly in 'package' and not in nested folders to align with DiskBasedPackageCache, which reads directories non-recursively
                            // - files at the root-level to align with cleanCachedPackage in DiskBasedPackageCache
                            const fileParts = header.name.split('/');
                            const isInCleanedPackage = (fileParts.length === 2 && fileParts[0] === 'package') || fileParts.length === 1;
                            if (isInCleanedPackage) {
                                const resource = JSON.parse(resourceData);
                                if (resource.resourceType && resource.id) {
                                    resources.push(resource);
                                }
                                else if (header.name.endsWith('/package.json') || header.name === 'package.json') {
                                    // Add a placeholder resourceType and id so we can uniquely store and retrieve package.json
                                    resource.resourceType = 'packagejson';
                                    resource.id = name; // This should be the same as resource.name
                                    resources.push(resource);
                                }
                            }
                        }
                        catch (_a) {
                            // Right now, if the JSON doesn't parse, we just ignore it.
                        }
                        next();
                    });
                    stream.resume();
                });
                extract.on('finish', () => __awaiter(this, void 0, void 0, function* () {
                    this.log('info', `Downloaded ${packageLabel}`);
                    // Add the package in IndexedDB (replacement of local FHIR cache for the browser)
                    const savedResources = yield addToIndexedDB(this.databaseName, packageLabel, resources);
                    // Add the package and resources to the localResourceMap to be used to avoid async calls later
                    const allResources = new Map(savedResources.map(r => [`${r.resourceType}-${r.id}`, r]));
                    this.localResourceMap.set(packageLabel, allResources);
                    this.log('info', `Cached ${packageLabel} to browser IndexedDB`);
                    resolve(`${packageLabel}`);
                }));
                data.pipe(zlib_1.default.createGunzip()).pipe(extract);
            });
        });
    }
    // Use the localResourceMap to avoid needing an async call to IndexedDB
    isPackageInCache(name, version) {
        const packageLabel = `${name}#${version}`;
        return this.localResourceMap.has(packageLabel);
    }
    getPackagePath(name, version) {
        if (this.isPackageInCache(name, version)) {
            return `${name}#${version}`;
        }
    }
    getPackageJSONPath(name, version) {
        if (this.isPackageInCache(name, version) &&
            this.localResourceMap.get(`${name}#${version}`).has(`packagejson-${name}`)) {
            return `${name}#${version}#packagejson-${name}`;
        }
    }
    // Use the localResourceMap to avoid needing an async call to IndexedDB
    getPotentialResourcePaths(name, version) {
        if (!this.isPackageInCache(name, version)) {
            return [];
        }
        const packageLabel = `${name}#${version}`;
        const packageMap = this.localResourceMap.get(packageLabel);
        const packagesResources = Array.from(packageMap.keys());
        // Ensure consistency by sorting the final paths (also aligns with DiskBasedPackageCache)
        return packagesResources.map(resourceLabel => `${packageLabel}#${resourceLabel}`).sort();
    }
    // Use the localResourceMap to avoid needing an async call to IndexedDB
    getResourceAtPath(resourcePath) {
        const [name, version, resourceLabel] = resourcePath.split('#');
        const packageMap = this.localResourceMap.get(`${name}#${version}`);
        if (packageMap == null) {
            throw new Error(`Failed to get resource from package ${name}#${version}`);
        }
        const resource = packageMap.get(resourceLabel);
        if (resource == null) {
            throw new Error(`Failed to get resource at path ${resourcePath}`);
        }
        return resource;
    }
}
exports.BrowserBasedPackageCache = BrowserBasedPackageCache;
function addToIndexedDB(databaseName, packageLabel, resources) {
    return __awaiter(this, void 0, void 0, function* () {
        const databaseVersion = yield getNextDatabaseVersion(databaseName);
        return addResourcesToDatabase(databaseName, databaseVersion, packageLabel, resources);
    });
}
function getNextDatabaseVersion(databaseName) {
    return __awaiter(this, void 0, void 0, function* () {
        return new Promise((resolve, reject) => {
            const openRequest = indexedDB.open(databaseName);
            openRequest.onsuccess = event => {
                const database = event.target.result;
                const nextVersion = database.version + 1;
                database.close();
                resolve(nextVersion);
            };
            openRequest.onerror = error => reject(error);
        });
    });
}
function addResourcesToDatabase(databaseName, databaseVersion, packageLabel, resources) {
    return __awaiter(this, void 0, void 0, function* () {
        const savedResources = [];
        return new Promise((resolve, reject) => {
            const openRequest = indexedDB.open(databaseName, databaseVersion);
            openRequest.onupgradeneeded = event => {
                const database = event.target.result;
                database.createObjectStore(packageLabel, { keyPath: ['resourceType', 'id'] });
            };
            openRequest.onsuccess = event => {
                const database = event.target.result;
                const transaction = database.transaction([packageLabel], 'readwrite');
                const objectStore = transaction.objectStore(packageLabel);
                resources.forEach(resource => {
                    if (resource.id && resource.resourceType) {
                        objectStore.put(resource);
                        savedResources.push(resource);
                    }
                });
                transaction.oncomplete = () => {
                    database.close();
                    resolve(savedResources);
                };
                transaction.onerror = () => {
                    database.close();
                    reject('Unexpected error adding package to cache');
                };
            };
            openRequest.onerror = () => {
                reject('Unexpected error saving package to cache');
            };
        });
    });
}
function initializeResourcesInLocalMap(database, packageLabel) {
    return new Promise((resolve, reject) => {
        const transaction = database.transaction([packageLabel]);
        const objectStore = transaction.objectStore(packageLabel);
        const request = objectStore.getAll();
        request.onerror = () => {
            reject('Unexpected error trying to initialize');
        };
        request.onsuccess = (event) => {
            const resourceMap = new Map(event.target.result.map((r) => [`${r.resourceType}-${r.id}`, r]));
            resolve([packageLabel, resourceMap]);
        };
    });
}
//# sourceMappingURL=BrowserBasedPackageCache.js.map