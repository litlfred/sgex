{"ast":null,"code":"import inherits from 'inherits-browser';\nimport { assign } from 'min-dash';\nimport BaseLayouter from 'diagram-js/lib/layout/BaseLayouter';\nimport { repairConnection, withoutRedundantPoints } from 'diagram-js/lib/layout/ManhattanLayout';\nimport { getMid, getOrientation } from 'diagram-js/lib/layout/LayoutUtil';\nimport { isExpanded } from '../../util/DiUtil';\nimport { is } from '../../util/ModelUtil';\nimport { isDirectionHorizontal } from './util/ModelingUtil';\n\n/**\n * @typedef {import('diagram-js/lib/core/ElementRegistry').default} ElementRegistry\n *\n * @typedef {import('diagram-js/lib/util/Types').Point} Point\n *\n * @typedef {import('../../model/Types').Connection} Connection\n * @typedef {import('../../model/Types').Element} Element\n *\n * @typedef {import('diagram-js/lib/layout/BaseLayouter').LayoutConnectionHints} LayoutConnectionHints\n *\n * @typedef { {\n *   source?: Element;\n *   target?: Element;\n *   waypoints?: Point[];\n *   connectionStart?: Point;\n *   connectionEnd?: Point;\n * } & LayoutConnectionHints } BpmnLayoutConnectionHints\n */\n\nvar ATTACH_ORIENTATION_PADDING = -10,\n  BOUNDARY_TO_HOST_THRESHOLD = 40;\n\n// layout all connection between flow elements h:h, except for\n// (1) outgoing of boundary events -> layout based on attach orientation and target orientation\n// (2) incoming/outgoing of gateways -> v:h for outgoing, h:v for incoming\n// (3) loops connect sides clockwise\nvar PREFERRED_LAYOUTS_HORIZONTAL = {\n  default: ['h:h'],\n  fromGateway: ['v:h'],\n  toGateway: ['h:v'],\n  loop: {\n    fromTop: ['t:r'],\n    fromRight: ['r:b'],\n    fromLeft: ['l:t'],\n    fromBottom: ['b:l']\n  },\n  boundaryLoop: {\n    alternateHorizontalSide: 'b',\n    alternateVerticalSide: 'l',\n    default: 'v'\n  },\n  messageFlow: ['straight', 'v:v'],\n  subProcess: ['straight', 'h:h'],\n  isHorizontal: true\n};\n\n// for vertical layouts, switch h and v and loop counter-clockwise\nvar PREFERRED_LAYOUTS_VERTICAL = {\n  default: ['v:v'],\n  fromGateway: ['h:v'],\n  toGateway: ['v:h'],\n  loop: {\n    fromTop: ['t:l'],\n    fromRight: ['r:t'],\n    fromLeft: ['l:b'],\n    fromBottom: ['b:r']\n  },\n  boundaryLoop: {\n    alternateHorizontalSide: 't',\n    alternateVerticalSide: 'r',\n    default: 'h'\n  },\n  messageFlow: ['straight', 'h:h'],\n  subProcess: ['straight', 'v:v'],\n  isHorizontal: false\n};\nvar oppositeOrientationMapping = {\n  'top': 'bottom',\n  'top-right': 'bottom-left',\n  'top-left': 'bottom-right',\n  'right': 'left',\n  'bottom': 'top',\n  'bottom-right': 'top-left',\n  'bottom-left': 'top-right',\n  'left': 'right'\n};\nvar orientationDirectionMapping = {\n  top: 't',\n  right: 'r',\n  bottom: 'b',\n  left: 'l'\n};\nexport default function BpmnLayouter(elementRegistry) {\n  this._elementRegistry = elementRegistry;\n}\ninherits(BpmnLayouter, BaseLayouter);\n\n/**\n * Returns waypoints of laid out connection.\n *\n * @param {Connection} connection\n * @param {BpmnLayoutConnectionHints} [hints]\n *\n * @return {Point[]}\n */\nBpmnLayouter.prototype.layoutConnection = function (connection, hints) {\n  if (!hints) {\n    hints = {};\n  }\n  var source = hints.source || connection.source,\n    target = hints.target || connection.target,\n    waypoints = hints.waypoints || connection.waypoints,\n    connectionStart = hints.connectionStart,\n    connectionEnd = hints.connectionEnd,\n    elementRegistry = this._elementRegistry;\n  var manhattanOptions, updatedWaypoints;\n  if (!connectionStart) {\n    connectionStart = getConnectionDocking(waypoints && waypoints[0], source);\n  }\n  if (!connectionEnd) {\n    connectionEnd = getConnectionDocking(waypoints && waypoints[waypoints.length - 1], target);\n  }\n  if (is(connection, 'bpmn:Association') || is(connection, 'bpmn:DataAssociation')) {\n    if (waypoints && !isCompensationAssociation(source, target)) {\n      return [].concat([connectionStart], waypoints.slice(1, -1), [connectionEnd]);\n    }\n  }\n  var layout = isDirectionHorizontal(source, elementRegistry) ? PREFERRED_LAYOUTS_HORIZONTAL : PREFERRED_LAYOUTS_VERTICAL;\n  if (is(connection, 'bpmn:MessageFlow')) {\n    manhattanOptions = getMessageFlowManhattanOptions(source, target, layout);\n  } else if (is(connection, 'bpmn:SequenceFlow') || isCompensationAssociation(source, target)) {\n    if (source === target) {\n      manhattanOptions = {\n        preferredLayouts: getLoopPreferredLayout(source, connection, layout)\n      };\n    } else if (is(source, 'bpmn:BoundaryEvent')) {\n      manhattanOptions = {\n        preferredLayouts: getBoundaryEventPreferredLayouts(source, target, connectionEnd, layout)\n      };\n    } else if (isExpandedSubProcess(source) || isExpandedSubProcess(target)) {\n      manhattanOptions = {\n        preferredLayouts: layout.subProcess,\n        preserveDocking: getSubProcessPreserveDocking(source)\n      };\n    } else if (is(source, 'bpmn:Gateway')) {\n      manhattanOptions = {\n        preferredLayouts: layout.fromGateway\n      };\n    } else if (is(target, 'bpmn:Gateway')) {\n      manhattanOptions = {\n        preferredLayouts: layout.toGateway\n      };\n    } else {\n      manhattanOptions = {\n        preferredLayouts: layout.default\n      };\n    }\n  }\n  if (manhattanOptions) {\n    manhattanOptions = assign(manhattanOptions, hints);\n    updatedWaypoints = withoutRedundantPoints(repairConnection(source, target, connectionStart, connectionEnd, waypoints, manhattanOptions));\n  }\n  return updatedWaypoints || [connectionStart, connectionEnd];\n};\n\n// helpers //////////\n\nfunction getAttachOrientation(attachedElement) {\n  var hostElement = attachedElement.host;\n  return getOrientation(getMid(attachedElement), hostElement, ATTACH_ORIENTATION_PADDING);\n}\nfunction getMessageFlowManhattanOptions(source, target, layout) {\n  return {\n    preferredLayouts: layout.messageFlow,\n    preserveDocking: getMessageFlowPreserveDocking(source, target)\n  };\n}\nfunction getMessageFlowPreserveDocking(source, target) {\n  // (1) docking element connected to participant has precedence\n  if (is(target, 'bpmn:Participant')) {\n    return 'source';\n  }\n  if (is(source, 'bpmn:Participant')) {\n    return 'target';\n  }\n\n  // (2) docking element connected to expanded sub-process has precedence\n  if (isExpandedSubProcess(target)) {\n    return 'source';\n  }\n  if (isExpandedSubProcess(source)) {\n    return 'target';\n  }\n\n  // (3) docking event has precedence\n  if (is(target, 'bpmn:Event')) {\n    return 'target';\n  }\n  if (is(source, 'bpmn:Event')) {\n    return 'source';\n  }\n  return null;\n}\nfunction getSubProcessPreserveDocking(source) {\n  return isExpandedSubProcess(source) ? 'target' : 'source';\n}\nfunction getConnectionDocking(point, shape) {\n  return point ? point.original || point : getMid(shape);\n}\nfunction isCompensationAssociation(source, target) {\n  return is(target, 'bpmn:Activity') && is(source, 'bpmn:BoundaryEvent') && target.businessObject.isForCompensation;\n}\nfunction isExpandedSubProcess(element) {\n  return is(element, 'bpmn:SubProcess') && isExpanded(element);\n}\nfunction isSame(a, b) {\n  return a === b;\n}\nfunction isAnyOrientation(orientation, orientations) {\n  return orientations.indexOf(orientation) !== -1;\n}\nfunction getHorizontalOrientation(orientation) {\n  var matches = /right|left/.exec(orientation);\n  return matches && matches[0];\n}\nfunction getVerticalOrientation(orientation) {\n  var matches = /top|bottom/.exec(orientation);\n  return matches && matches[0];\n}\nfunction isOppositeOrientation(a, b) {\n  return oppositeOrientationMapping[a] === b;\n}\nfunction isOppositeHorizontalOrientation(a, b) {\n  var horizontalOrientation = getHorizontalOrientation(a);\n  var oppositeHorizontalOrientation = oppositeOrientationMapping[horizontalOrientation];\n  return b.indexOf(oppositeHorizontalOrientation) !== -1;\n}\nfunction isOppositeVerticalOrientation(a, b) {\n  var verticalOrientation = getVerticalOrientation(a);\n  var oppositeVerticalOrientation = oppositeOrientationMapping[verticalOrientation];\n  return b.indexOf(oppositeVerticalOrientation) !== -1;\n}\nfunction isHorizontalOrientation(orientation) {\n  return orientation === 'right' || orientation === 'left';\n}\nfunction getLoopPreferredLayout(source, connection, layout) {\n  var waypoints = connection.waypoints;\n  var orientation = waypoints && waypoints.length && getOrientation(waypoints[0], source);\n  if (orientation === 'top') {\n    return layout.loop.fromTop;\n  } else if (orientation === 'right') {\n    return layout.loop.fromRight;\n  } else if (orientation === 'left') {\n    return layout.loop.fromLeft;\n  }\n  return layout.loop.fromBottom;\n}\nfunction getBoundaryEventPreferredLayouts(source, target, end, layout) {\n  var sourceMid = getMid(source),\n    targetMid = getMid(target),\n    attachOrientation = getAttachOrientation(source),\n    sourceLayout,\n    targetLayout;\n  var isLoop = isSame(source.host, target);\n  var attachedToSide = isAnyOrientation(attachOrientation, ['top', 'right', 'bottom', 'left']);\n  var targetOrientation = getOrientation(targetMid, sourceMid, {\n    x: source.width / 2 + target.width / 2,\n    y: source.height / 2 + target.height / 2\n  });\n  if (isLoop) {\n    return getBoundaryEventLoopLayout(attachOrientation, attachedToSide, source, target, end, layout);\n  }\n\n  // source layout\n  sourceLayout = getBoundaryEventSourceLayout(attachOrientation, targetOrientation, attachedToSide, layout.isHorizontal);\n\n  // target layout\n  targetLayout = getBoundaryEventTargetLayout(attachOrientation, targetOrientation, attachedToSide, layout.isHorizontal);\n  return [sourceLayout + ':' + targetLayout];\n}\nfunction getBoundaryEventLoopLayout(attachOrientation, attachedToSide, source, target, end, layout) {\n  var orientation = attachedToSide ? attachOrientation : layout.isHorizontal ? getVerticalOrientation(attachOrientation) : getHorizontalOrientation(attachOrientation),\n    sourceLayout = orientationDirectionMapping[orientation],\n    targetLayout;\n  if (attachedToSide) {\n    if (isHorizontalOrientation(attachOrientation)) {\n      targetLayout = shouldConnectToSameSide('y', source, target, end) ? 'h' : layout.boundaryLoop.alternateHorizontalSide;\n    } else {\n      targetLayout = shouldConnectToSameSide('x', source, target, end) ? 'v' : layout.boundaryLoop.alternateVerticalSide;\n    }\n  } else {\n    targetLayout = layout.boundaryLoop.default;\n  }\n  return [sourceLayout + ':' + targetLayout];\n}\nfunction shouldConnectToSameSide(axis, source, target, end) {\n  var threshold = BOUNDARY_TO_HOST_THRESHOLD;\n  return !(areCloseOnAxis(axis, end, target, threshold) || areCloseOnAxis(axis, end, {\n    x: target.x + target.width,\n    y: target.y + target.height\n  }, threshold) || areCloseOnAxis(axis, end, getMid(source), threshold));\n}\nfunction areCloseOnAxis(axis, a, b, threshold) {\n  return Math.abs(a[axis] - b[axis]) < threshold;\n}\nfunction getBoundaryEventSourceLayout(attachOrientation, targetOrientation, attachedToSide, isHorizontal) {\n  // attached to either top, right, bottom or left side\n  if (attachedToSide) {\n    return orientationDirectionMapping[attachOrientation];\n  }\n\n  // attached to either top-right, top-left, bottom-right or bottom-left corner\n\n  var verticalAttachOrientation = getVerticalOrientation(attachOrientation),\n    horizontalAttachOrientation = getHorizontalOrientation(attachOrientation),\n    verticalTargetOrientation = getVerticalOrientation(targetOrientation),\n    horizontalTargetOrientation = getHorizontalOrientation(targetOrientation);\n  if (isHorizontal) {\n    // same vertical or opposite horizontal orientation\n    if (isSame(verticalAttachOrientation, verticalTargetOrientation) || isOppositeOrientation(horizontalAttachOrientation, horizontalTargetOrientation)) {\n      return orientationDirectionMapping[verticalAttachOrientation];\n    }\n  } else {\n    // same horizontal or opposite vertical orientation\n    if (isSame(horizontalAttachOrientation, horizontalTargetOrientation) || isOppositeOrientation(verticalAttachOrientation, verticalTargetOrientation)) {\n      return orientationDirectionMapping[horizontalAttachOrientation];\n    }\n  }\n\n  // fallback\n  return orientationDirectionMapping[isHorizontal ? horizontalAttachOrientation : verticalAttachOrientation];\n}\nfunction getBoundaryEventTargetLayout(attachOrientation, targetOrientation, attachedToSide, isHorizontal) {\n  // attached to either top, right, bottom or left side\n  if (attachedToSide) {\n    if (isHorizontalOrientation(attachOrientation)) {\n      // orientation is right or left\n\n      // opposite horizontal orientation or same orientation\n      if (isOppositeHorizontalOrientation(attachOrientation, targetOrientation) || isSame(attachOrientation, targetOrientation)) {\n        return 'h';\n      }\n\n      // fallback\n      return 'v';\n    } else {\n      // orientation is top or bottom\n\n      // opposite vertical orientation or same orientation\n      if (isOppositeVerticalOrientation(attachOrientation, targetOrientation) || isSame(attachOrientation, targetOrientation)) {\n        return 'v';\n      }\n\n      // fallback\n      return 'h';\n    }\n  }\n\n  // attached to either top-right, top-left, bottom-right or bottom-left corner\n  // and orientation is same on the counter-axis\n\n  if (isHorizontal) {\n    if (isSame(getVerticalOrientation(attachOrientation), getVerticalOrientation(targetOrientation))) {\n      return 'h';\n    } else {\n      return 'v';\n    }\n  } else {\n    if (isSame(getHorizontalOrientation(attachOrientation), getHorizontalOrientation(targetOrientation))) {\n      return 'v';\n    } else {\n      return 'h';\n    }\n  }\n}\nBpmnLayouter.$inject = ['elementRegistry'];","map":{"version":3,"names":["inherits","assign","BaseLayouter","repairConnection","withoutRedundantPoints","getMid","getOrientation","isExpanded","is","isDirectionHorizontal","ATTACH_ORIENTATION_PADDING","BOUNDARY_TO_HOST_THRESHOLD","PREFERRED_LAYOUTS_HORIZONTAL","default","fromGateway","toGateway","loop","fromTop","fromRight","fromLeft","fromBottom","boundaryLoop","alternateHorizontalSide","alternateVerticalSide","messageFlow","subProcess","isHorizontal","PREFERRED_LAYOUTS_VERTICAL","oppositeOrientationMapping","orientationDirectionMapping","top","right","bottom","left","BpmnLayouter","elementRegistry","_elementRegistry","prototype","layoutConnection","connection","hints","source","target","waypoints","connectionStart","connectionEnd","manhattanOptions","updatedWaypoints","getConnectionDocking","length","isCompensationAssociation","concat","slice","layout","getMessageFlowManhattanOptions","preferredLayouts","getLoopPreferredLayout","getBoundaryEventPreferredLayouts","isExpandedSubProcess","preserveDocking","getSubProcessPreserveDocking","getAttachOrientation","attachedElement","hostElement","host","getMessageFlowPreserveDocking","point","shape","original","businessObject","isForCompensation","element","isSame","a","b","isAnyOrientation","orientation","orientations","indexOf","getHorizontalOrientation","matches","exec","getVerticalOrientation","isOppositeOrientation","isOppositeHorizontalOrientation","horizontalOrientation","oppositeHorizontalOrientation","isOppositeVerticalOrientation","verticalOrientation","oppositeVerticalOrientation","isHorizontalOrientation","end","sourceMid","targetMid","attachOrientation","sourceLayout","targetLayout","isLoop","attachedToSide","targetOrientation","x","width","y","height","getBoundaryEventLoopLayout","getBoundaryEventSourceLayout","getBoundaryEventTargetLayout","shouldConnectToSameSide","axis","threshold","areCloseOnAxis","Math","abs","verticalAttachOrientation","horizontalAttachOrientation","verticalTargetOrientation","horizontalTargetOrientation","$inject"],"sources":["/home/runner/work/sgex/sgex/node_modules/bpmn-js/lib/features/modeling/BpmnLayouter.js"],"sourcesContent":["import inherits from 'inherits-browser';\n\nimport {\n  assign\n} from 'min-dash';\n\nimport BaseLayouter from 'diagram-js/lib/layout/BaseLayouter';\n\nimport {\n  repairConnection,\n  withoutRedundantPoints\n} from 'diagram-js/lib/layout/ManhattanLayout';\n\nimport {\n  getMid,\n  getOrientation\n} from 'diagram-js/lib/layout/LayoutUtil';\n\nimport {\n  isExpanded\n} from '../../util/DiUtil';\n\nimport { is } from '../../util/ModelUtil';\n\nimport { isDirectionHorizontal } from './util/ModelingUtil';\n\n/**\n * @typedef {import('diagram-js/lib/core/ElementRegistry').default} ElementRegistry\n *\n * @typedef {import('diagram-js/lib/util/Types').Point} Point\n *\n * @typedef {import('../../model/Types').Connection} Connection\n * @typedef {import('../../model/Types').Element} Element\n *\n * @typedef {import('diagram-js/lib/layout/BaseLayouter').LayoutConnectionHints} LayoutConnectionHints\n *\n * @typedef { {\n *   source?: Element;\n *   target?: Element;\n *   waypoints?: Point[];\n *   connectionStart?: Point;\n *   connectionEnd?: Point;\n * } & LayoutConnectionHints } BpmnLayoutConnectionHints\n */\n\nvar ATTACH_ORIENTATION_PADDING = -10,\n    BOUNDARY_TO_HOST_THRESHOLD = 40;\n\n// layout all connection between flow elements h:h, except for\n// (1) outgoing of boundary events -> layout based on attach orientation and target orientation\n// (2) incoming/outgoing of gateways -> v:h for outgoing, h:v for incoming\n// (3) loops connect sides clockwise\nvar PREFERRED_LAYOUTS_HORIZONTAL = {\n  default: [ 'h:h' ],\n  fromGateway: [ 'v:h' ],\n  toGateway: [ 'h:v' ],\n  loop: {\n    fromTop: [ 't:r' ],\n    fromRight: [ 'r:b' ],\n    fromLeft: [ 'l:t' ],\n    fromBottom: [ 'b:l' ]\n  },\n  boundaryLoop: {\n    alternateHorizontalSide: 'b',\n    alternateVerticalSide: 'l',\n    default: 'v'\n  },\n  messageFlow: [ 'straight', 'v:v' ],\n  subProcess: [ 'straight', 'h:h' ],\n  isHorizontal: true\n};\n\n// for vertical layouts, switch h and v and loop counter-clockwise\nvar PREFERRED_LAYOUTS_VERTICAL = {\n  default: [ 'v:v' ],\n  fromGateway: [ 'h:v' ],\n  toGateway: [ 'v:h' ],\n  loop: {\n    fromTop: [ 't:l' ],\n    fromRight: [ 'r:t' ],\n    fromLeft: [ 'l:b' ],\n    fromBottom: [ 'b:r' ]\n  },\n  boundaryLoop: {\n    alternateHorizontalSide: 't',\n    alternateVerticalSide: 'r',\n    default: 'h'\n  },\n  messageFlow: [ 'straight', 'h:h' ],\n  subProcess: [ 'straight', 'v:v' ],\n  isHorizontal: false\n};\n\nvar oppositeOrientationMapping = {\n  'top': 'bottom',\n  'top-right': 'bottom-left',\n  'top-left': 'bottom-right',\n  'right': 'left',\n  'bottom': 'top',\n  'bottom-right': 'top-left',\n  'bottom-left': 'top-right',\n  'left': 'right'\n};\n\nvar orientationDirectionMapping = {\n  top: 't',\n  right: 'r',\n  bottom: 'b',\n  left: 'l'\n};\n\nexport default function BpmnLayouter(elementRegistry) {\n  this._elementRegistry = elementRegistry;\n}\n\ninherits(BpmnLayouter, BaseLayouter);\n\n/**\n * Returns waypoints of laid out connection.\n *\n * @param {Connection} connection\n * @param {BpmnLayoutConnectionHints} [hints]\n *\n * @return {Point[]}\n */\nBpmnLayouter.prototype.layoutConnection = function(connection, hints) {\n  if (!hints) {\n    hints = {};\n  }\n\n  var source = hints.source || connection.source,\n      target = hints.target || connection.target,\n      waypoints = hints.waypoints || connection.waypoints,\n      connectionStart = hints.connectionStart,\n      connectionEnd = hints.connectionEnd,\n      elementRegistry = this._elementRegistry;\n\n  var manhattanOptions,\n      updatedWaypoints;\n\n  if (!connectionStart) {\n    connectionStart = getConnectionDocking(waypoints && waypoints[ 0 ], source);\n  }\n\n  if (!connectionEnd) {\n    connectionEnd = getConnectionDocking(waypoints && waypoints[ waypoints.length - 1 ], target);\n  }\n\n  if (is(connection, 'bpmn:Association') ||\n      is(connection, 'bpmn:DataAssociation')) {\n\n    if (waypoints && !isCompensationAssociation(source, target)) {\n      return [].concat([ connectionStart ], waypoints.slice(1, -1), [ connectionEnd ]);\n    }\n  }\n\n  var layout = isDirectionHorizontal(source, elementRegistry) ? PREFERRED_LAYOUTS_HORIZONTAL : PREFERRED_LAYOUTS_VERTICAL;\n\n  if (is(connection, 'bpmn:MessageFlow')) {\n    manhattanOptions = getMessageFlowManhattanOptions(source, target, layout);\n  } else if (is(connection, 'bpmn:SequenceFlow') || isCompensationAssociation(source, target)) {\n\n    if (source === target) {\n      manhattanOptions = {\n        preferredLayouts: getLoopPreferredLayout(source, connection, layout)\n      };\n    } else if (is(source, 'bpmn:BoundaryEvent')) {\n      manhattanOptions = {\n        preferredLayouts: getBoundaryEventPreferredLayouts(source, target, connectionEnd, layout)\n      };\n    } else if (isExpandedSubProcess(source) || isExpandedSubProcess(target)) {\n      manhattanOptions = {\n        preferredLayouts: layout.subProcess,\n        preserveDocking: getSubProcessPreserveDocking(source)\n      };\n    } else if (is(source, 'bpmn:Gateway')) {\n      manhattanOptions = {\n        preferredLayouts: layout.fromGateway\n      };\n    } else if (is(target, 'bpmn:Gateway')) {\n      manhattanOptions = {\n        preferredLayouts: layout.toGateway\n      };\n    } else {\n      manhattanOptions = {\n        preferredLayouts: layout.default\n      };\n    }\n  }\n\n  if (manhattanOptions) {\n    manhattanOptions = assign(manhattanOptions, hints);\n\n    updatedWaypoints = withoutRedundantPoints(repairConnection(\n      source,\n      target,\n      connectionStart,\n      connectionEnd,\n      waypoints,\n      manhattanOptions\n    ));\n  }\n\n  return updatedWaypoints || [ connectionStart, connectionEnd ];\n};\n\n\n// helpers //////////\n\nfunction getAttachOrientation(attachedElement) {\n  var hostElement = attachedElement.host;\n\n  return getOrientation(getMid(attachedElement), hostElement, ATTACH_ORIENTATION_PADDING);\n}\n\nfunction getMessageFlowManhattanOptions(source, target, layout) {\n  return {\n    preferredLayouts: layout.messageFlow,\n    preserveDocking: getMessageFlowPreserveDocking(source, target)\n  };\n}\n\nfunction getMessageFlowPreserveDocking(source, target) {\n\n  // (1) docking element connected to participant has precedence\n  if (is(target, 'bpmn:Participant')) {\n    return 'source';\n  }\n\n  if (is(source, 'bpmn:Participant')) {\n    return 'target';\n  }\n\n  // (2) docking element connected to expanded sub-process has precedence\n  if (isExpandedSubProcess(target)) {\n    return 'source';\n  }\n\n  if (isExpandedSubProcess(source)) {\n    return 'target';\n  }\n\n  // (3) docking event has precedence\n  if (is(target, 'bpmn:Event')) {\n    return 'target';\n  }\n\n  if (is(source, 'bpmn:Event')) {\n    return 'source';\n  }\n\n  return null;\n}\n\nfunction getSubProcessPreserveDocking(source) {\n  return isExpandedSubProcess(source) ? 'target' : 'source';\n}\n\nfunction getConnectionDocking(point, shape) {\n  return point ? (point.original || point) : getMid(shape);\n}\n\nfunction isCompensationAssociation(source, target) {\n  return is(target, 'bpmn:Activity') &&\n    is(source, 'bpmn:BoundaryEvent') &&\n    target.businessObject.isForCompensation;\n}\n\nfunction isExpandedSubProcess(element) {\n  return is(element, 'bpmn:SubProcess') && isExpanded(element);\n}\n\nfunction isSame(a, b) {\n  return a === b;\n}\n\nfunction isAnyOrientation(orientation, orientations) {\n  return orientations.indexOf(orientation) !== -1;\n}\n\nfunction getHorizontalOrientation(orientation) {\n  var matches = /right|left/.exec(orientation);\n\n  return matches && matches[0];\n}\n\nfunction getVerticalOrientation(orientation) {\n  var matches = /top|bottom/.exec(orientation);\n\n  return matches && matches[0];\n}\n\nfunction isOppositeOrientation(a, b) {\n  return oppositeOrientationMapping[a] === b;\n}\n\nfunction isOppositeHorizontalOrientation(a, b) {\n  var horizontalOrientation = getHorizontalOrientation(a);\n\n  var oppositeHorizontalOrientation = oppositeOrientationMapping[horizontalOrientation];\n\n  return b.indexOf(oppositeHorizontalOrientation) !== -1;\n}\n\nfunction isOppositeVerticalOrientation(a, b) {\n  var verticalOrientation = getVerticalOrientation(a);\n\n  var oppositeVerticalOrientation = oppositeOrientationMapping[verticalOrientation];\n\n  return b.indexOf(oppositeVerticalOrientation) !== -1;\n}\n\nfunction isHorizontalOrientation(orientation) {\n  return orientation === 'right' || orientation === 'left';\n}\n\nfunction getLoopPreferredLayout(source, connection, layout) {\n  var waypoints = connection.waypoints;\n\n  var orientation = waypoints && waypoints.length && getOrientation(waypoints[0], source);\n\n  if (orientation === 'top') {\n    return layout.loop.fromTop;\n  } else if (orientation === 'right') {\n    return layout.loop.fromRight;\n  } else if (orientation === 'left') {\n    return layout.loop.fromLeft;\n  }\n\n  return layout.loop.fromBottom;\n}\n\nfunction getBoundaryEventPreferredLayouts(source, target, end, layout) {\n  var sourceMid = getMid(source),\n      targetMid = getMid(target),\n      attachOrientation = getAttachOrientation(source),\n      sourceLayout,\n      targetLayout;\n\n  var isLoop = isSame(source.host, target);\n\n  var attachedToSide = isAnyOrientation(attachOrientation, [ 'top', 'right', 'bottom', 'left' ]);\n\n  var targetOrientation = getOrientation(targetMid, sourceMid, {\n    x: source.width / 2 + target.width / 2,\n    y: source.height / 2 + target.height / 2\n  });\n\n  if (isLoop) {\n    return getBoundaryEventLoopLayout(attachOrientation, attachedToSide, source, target, end, layout);\n  }\n\n  // source layout\n  sourceLayout = getBoundaryEventSourceLayout(attachOrientation, targetOrientation, attachedToSide, layout.isHorizontal);\n\n  // target layout\n  targetLayout = getBoundaryEventTargetLayout(attachOrientation, targetOrientation, attachedToSide, layout.isHorizontal);\n\n  return [ sourceLayout + ':' + targetLayout ];\n}\n\nfunction getBoundaryEventLoopLayout(attachOrientation, attachedToSide, source, target, end, layout) {\n  var orientation = attachedToSide ? attachOrientation : layout.isHorizontal ? getVerticalOrientation(attachOrientation) : getHorizontalOrientation(attachOrientation),\n      sourceLayout = orientationDirectionMapping[ orientation ],\n      targetLayout;\n\n  if (attachedToSide) {\n    if (isHorizontalOrientation(attachOrientation)) {\n      targetLayout = shouldConnectToSameSide('y', source, target, end) ? 'h' : layout.boundaryLoop.alternateHorizontalSide;\n    } else {\n      targetLayout = shouldConnectToSameSide('x', source, target, end) ? 'v' : layout.boundaryLoop.alternateVerticalSide;\n    }\n  } else {\n    targetLayout = layout.boundaryLoop.default;\n  }\n\n  return [ sourceLayout + ':' + targetLayout ];\n}\n\nfunction shouldConnectToSameSide(axis, source, target, end) {\n  var threshold = BOUNDARY_TO_HOST_THRESHOLD;\n\n  return !(\n    areCloseOnAxis(axis, end, target, threshold) ||\n    areCloseOnAxis(axis, end, {\n      x: target.x + target.width,\n      y: target.y + target.height\n    }, threshold) ||\n    areCloseOnAxis(axis, end, getMid(source), threshold)\n  );\n}\n\nfunction areCloseOnAxis(axis, a, b, threshold) {\n  return Math.abs(a[ axis ] - b[ axis ]) < threshold;\n}\n\nfunction getBoundaryEventSourceLayout(attachOrientation, targetOrientation, attachedToSide, isHorizontal) {\n\n  // attached to either top, right, bottom or left side\n  if (attachedToSide) {\n    return orientationDirectionMapping[ attachOrientation ];\n  }\n\n  // attached to either top-right, top-left, bottom-right or bottom-left corner\n\n  var verticalAttachOrientation = getVerticalOrientation(attachOrientation),\n      horizontalAttachOrientation = getHorizontalOrientation(attachOrientation),\n      verticalTargetOrientation = getVerticalOrientation(targetOrientation),\n      horizontalTargetOrientation = getHorizontalOrientation(targetOrientation);\n\n  if (isHorizontal) {\n\n    // same vertical or opposite horizontal orientation\n    if (\n      isSame(verticalAttachOrientation, verticalTargetOrientation) ||\n      isOppositeOrientation(horizontalAttachOrientation, horizontalTargetOrientation)\n    ) {\n      return orientationDirectionMapping[ verticalAttachOrientation ];\n    }\n  } else {\n\n    // same horizontal or opposite vertical orientation\n    if (\n      isSame(horizontalAttachOrientation, horizontalTargetOrientation) ||\n      isOppositeOrientation(verticalAttachOrientation, verticalTargetOrientation)\n    ) {\n      return orientationDirectionMapping[ horizontalAttachOrientation ];\n    }\n  }\n\n  // fallback\n  return orientationDirectionMapping[ isHorizontal ? horizontalAttachOrientation : verticalAttachOrientation ];\n}\n\nfunction getBoundaryEventTargetLayout(attachOrientation, targetOrientation, attachedToSide, isHorizontal) {\n\n  // attached to either top, right, bottom or left side\n  if (attachedToSide) {\n    if (isHorizontalOrientation(attachOrientation)) {\n\n      // orientation is right or left\n\n      // opposite horizontal orientation or same orientation\n      if (\n        isOppositeHorizontalOrientation(attachOrientation, targetOrientation) ||\n        isSame(attachOrientation, targetOrientation)\n      ) {\n        return 'h';\n      }\n\n      // fallback\n      return 'v';\n    } else {\n\n      // orientation is top or bottom\n\n      // opposite vertical orientation or same orientation\n      if (\n        isOppositeVerticalOrientation(attachOrientation, targetOrientation) ||\n        isSame(attachOrientation, targetOrientation)\n      ) {\n        return 'v';\n      }\n\n      // fallback\n      return 'h';\n    }\n  }\n\n  // attached to either top-right, top-left, bottom-right or bottom-left corner\n  // and orientation is same on the counter-axis\n\n  if (isHorizontal) {\n    if (isSame(getVerticalOrientation(attachOrientation), getVerticalOrientation(targetOrientation))) {\n      return 'h';\n    } else {\n      return 'v';\n    }\n  } else {\n    if (isSame(getHorizontalOrientation(attachOrientation), getHorizontalOrientation(targetOrientation))) {\n      return 'v';\n    } else {\n      return 'h';\n    }\n  }\n}\n\nBpmnLayouter.$inject = [ 'elementRegistry' ];\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}