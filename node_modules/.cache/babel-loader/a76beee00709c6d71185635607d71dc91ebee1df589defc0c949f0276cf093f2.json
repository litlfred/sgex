{"ast":null,"code":"\"use strict\";\n\nvar _taggedTemplateLiteral = require(\"/home/runner/work/sgex/sgex/node_modules/@babel/runtime/helpers/taggedTemplateLiteral.js\").default;\nvar _templateObject, _templateObject2, _templateObject3;\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nconst codegen_1 = require(\"../../compile/codegen\");\nconst util_1 = require(\"../../compile/util\");\nconst error = {\n  message: \"must match exactly one schema in oneOf\",\n  params: _ref => {\n    let {\n      params\n    } = _ref;\n    return (0, codegen_1._)(_templateObject || (_templateObject = _taggedTemplateLiteral([\"{passingSchemas: \", \"}\"])), params.passing);\n  }\n};\nconst def = {\n  keyword: \"oneOf\",\n  schemaType: \"array\",\n  trackErrors: true,\n  error,\n  code(cxt) {\n    const {\n      gen,\n      schema,\n      parentSchema,\n      it\n    } = cxt;\n    /* istanbul ignore if */\n    if (!Array.isArray(schema)) throw new Error(\"ajv implementation error\");\n    if (it.opts.discriminator && parentSchema.discriminator) return;\n    const schArr = schema;\n    const valid = gen.let(\"valid\", false);\n    const passing = gen.let(\"passing\", null);\n    const schValid = gen.name(\"_valid\");\n    cxt.setParams({\n      passing\n    });\n    // TODO possibly fail straight away (with warning or exception) if there are two empty always valid schemas\n    gen.block(validateOneOf);\n    cxt.result(valid, () => cxt.reset(), () => cxt.error(true));\n    function validateOneOf() {\n      schArr.forEach((sch, i) => {\n        let schCxt;\n        if ((0, util_1.alwaysValidSchema)(it, sch)) {\n          gen.var(schValid, true);\n        } else {\n          schCxt = cxt.subschema({\n            keyword: \"oneOf\",\n            schemaProp: i,\n            compositeRule: true\n          }, schValid);\n        }\n        if (i > 0) {\n          gen.if((0, codegen_1._)(_templateObject2 || (_templateObject2 = _taggedTemplateLiteral([\"\", \" && \", \"\"])), schValid, valid)).assign(valid, false).assign(passing, (0, codegen_1._)(_templateObject3 || (_templateObject3 = _taggedTemplateLiteral([\"[\", \", \", \"]\"])), passing, i)).else();\n        }\n        gen.if(schValid, () => {\n          gen.assign(valid, true);\n          gen.assign(passing, i);\n          if (schCxt) cxt.mergeEvaluated(schCxt, codegen_1.Name);\n        });\n      });\n    }\n  }\n};\nexports.default = def;","map":{"version":3,"names":["codegen_1","require","util_1","error","message","params","_ref","_","_templateObject","_taggedTemplateLiteral","passing","def","keyword","schemaType","trackErrors","code","cxt","gen","schema","parentSchema","it","Array","isArray","Error","opts","discriminator","schArr","valid","let","schValid","name","setParams","block","validateOneOf","result","reset","forEach","sch","i","schCxt","alwaysValidSchema","var","subschema","schemaProp","compositeRule","if","_templateObject2","assign","_templateObject3","else","mergeEvaluated","Name","exports","default"],"sources":["/home/runner/work/sgex/sgex/node_modules/ajv/lib/vocabularies/applicator/oneOf.ts"],"sourcesContent":["import type {\n  CodeKeywordDefinition,\n  ErrorObject,\n  KeywordErrorDefinition,\n  AnySchema,\n} from \"../../types\"\nimport type {KeywordCxt} from \"../../compile/validate\"\nimport {_, Name} from \"../../compile/codegen\"\nimport {alwaysValidSchema} from \"../../compile/util\"\nimport {SchemaCxt} from \"../../compile\"\n\nexport type OneOfError = ErrorObject<\n  \"oneOf\",\n  {passingSchemas: [number, number] | null},\n  AnySchema[]\n>\n\nconst error: KeywordErrorDefinition = {\n  message: \"must match exactly one schema in oneOf\",\n  params: ({params}) => _`{passingSchemas: ${params.passing}}`,\n}\n\nconst def: CodeKeywordDefinition = {\n  keyword: \"oneOf\",\n  schemaType: \"array\",\n  trackErrors: true,\n  error,\n  code(cxt: KeywordCxt) {\n    const {gen, schema, parentSchema, it} = cxt\n    /* istanbul ignore if */\n    if (!Array.isArray(schema)) throw new Error(\"ajv implementation error\")\n    if (it.opts.discriminator && parentSchema.discriminator) return\n    const schArr: AnySchema[] = schema\n    const valid = gen.let(\"valid\", false)\n    const passing = gen.let(\"passing\", null)\n    const schValid = gen.name(\"_valid\")\n    cxt.setParams({passing})\n    // TODO possibly fail straight away (with warning or exception) if there are two empty always valid schemas\n\n    gen.block(validateOneOf)\n\n    cxt.result(\n      valid,\n      () => cxt.reset(),\n      () => cxt.error(true)\n    )\n\n    function validateOneOf(): void {\n      schArr.forEach((sch: AnySchema, i: number) => {\n        let schCxt: SchemaCxt | undefined\n        if (alwaysValidSchema(it, sch)) {\n          gen.var(schValid, true)\n        } else {\n          schCxt = cxt.subschema(\n            {\n              keyword: \"oneOf\",\n              schemaProp: i,\n              compositeRule: true,\n            },\n            schValid\n          )\n        }\n\n        if (i > 0) {\n          gen\n            .if(_`${schValid} && ${valid}`)\n            .assign(valid, false)\n            .assign(passing, _`[${passing}, ${i}]`)\n            .else()\n        }\n\n        gen.if(schValid, () => {\n          gen.assign(valid, true)\n          gen.assign(passing, i)\n          if (schCxt) cxt.mergeEvaluated(schCxt, Name)\n        })\n      })\n    }\n  },\n}\n\nexport default def\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}