{"ast":null,"code":"\"use strict\";\n\nvar _taggedTemplateLiteral = require(\"/home/runner/work/sgex/sgex/node_modules/@babel/runtime/helpers/taggedTemplateLiteral.js\").default;\nvar _templateObject, _templateObject2, _templateObject3, _templateObject4, _templateObject5, _templateObject6, _templateObject7, _templateObject8, _templateObject9;\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.callRef = exports.getValidate = void 0;\nconst ref_error_1 = require(\"../../compile/ref_error\");\nconst code_1 = require(\"../code\");\nconst codegen_1 = require(\"../../compile/codegen\");\nconst names_1 = require(\"../../compile/names\");\nconst compile_1 = require(\"../../compile\");\nconst util_1 = require(\"../../compile/util\");\nconst def = {\n  keyword: \"$ref\",\n  schemaType: \"string\",\n  code(cxt) {\n    const {\n      gen,\n      schema: $ref,\n      it\n    } = cxt;\n    const {\n      baseId,\n      schemaEnv: env,\n      validateName,\n      opts,\n      self\n    } = it;\n    const {\n      root\n    } = env;\n    if (($ref === \"#\" || $ref === \"#/\") && baseId === root.baseId) return callRootRef();\n    const schOrEnv = compile_1.resolveRef.call(self, root, baseId, $ref);\n    if (schOrEnv === undefined) throw new ref_error_1.default(it.opts.uriResolver, baseId, $ref);\n    if (schOrEnv instanceof compile_1.SchemaEnv) return callValidate(schOrEnv);\n    return inlineRefSchema(schOrEnv);\n    function callRootRef() {\n      if (env === root) return callRef(cxt, validateName, env, env.$async);\n      const rootName = gen.scopeValue(\"root\", {\n        ref: root\n      });\n      return callRef(cxt, (0, codegen_1._)(_templateObject || (_templateObject = _taggedTemplateLiteral([\"\", \".validate\"])), rootName), root, root.$async);\n    }\n    function callValidate(sch) {\n      const v = getValidate(cxt, sch);\n      callRef(cxt, v, sch, sch.$async);\n    }\n    function inlineRefSchema(sch) {\n      const schName = gen.scopeValue(\"schema\", opts.code.source === true ? {\n        ref: sch,\n        code: (0, codegen_1.stringify)(sch)\n      } : {\n        ref: sch\n      });\n      const valid = gen.name(\"valid\");\n      const schCxt = cxt.subschema({\n        schema: sch,\n        dataTypes: [],\n        schemaPath: codegen_1.nil,\n        topSchemaRef: schName,\n        errSchemaPath: $ref\n      }, valid);\n      cxt.mergeEvaluated(schCxt);\n      cxt.ok(valid);\n    }\n  }\n};\nfunction getValidate(cxt, sch) {\n  const {\n    gen\n  } = cxt;\n  return sch.validate ? gen.scopeValue(\"validate\", {\n    ref: sch.validate\n  }) : (0, codegen_1._)(_templateObject2 || (_templateObject2 = _taggedTemplateLiteral([\"\", \".validate\"])), gen.scopeValue(\"wrapper\", {\n    ref: sch\n  }));\n}\nexports.getValidate = getValidate;\nfunction callRef(cxt, v, sch, $async) {\n  const {\n    gen,\n    it\n  } = cxt;\n  const {\n    allErrors,\n    schemaEnv: env,\n    opts\n  } = it;\n  const passCxt = opts.passContext ? names_1.default.this : codegen_1.nil;\n  if ($async) callAsyncRef();else callSyncRef();\n  function callAsyncRef() {\n    if (!env.$async) throw new Error(\"async schema referenced by sync schema\");\n    const valid = gen.let(\"valid\");\n    gen.try(() => {\n      gen.code((0, codegen_1._)(_templateObject3 || (_templateObject3 = _taggedTemplateLiteral([\"await \", \"\"])), (0, code_1.callValidateCode)(cxt, v, passCxt)));\n      addEvaluatedFrom(v); // TODO will not work with async, it has to be returned with the result\n      if (!allErrors) gen.assign(valid, true);\n    }, e => {\n      gen.if((0, codegen_1._)(_templateObject4 || (_templateObject4 = _taggedTemplateLiteral([\"!(\", \" instanceof \", \")\"])), e, it.ValidationError), () => gen.throw(e));\n      addErrorsFrom(e);\n      if (!allErrors) gen.assign(valid, false);\n    });\n    cxt.ok(valid);\n  }\n  function callSyncRef() {\n    cxt.result((0, code_1.callValidateCode)(cxt, v, passCxt), () => addEvaluatedFrom(v), () => addErrorsFrom(v));\n  }\n  function addErrorsFrom(source) {\n    const errs = (0, codegen_1._)(_templateObject5 || (_templateObject5 = _taggedTemplateLiteral([\"\", \".errors\"])), source);\n    gen.assign(names_1.default.vErrors, (0, codegen_1._)(_templateObject6 || (_templateObject6 = _taggedTemplateLiteral([\"\", \" === null ? \", \" : \", \".concat(\", \")\"])), names_1.default.vErrors, errs, names_1.default.vErrors, errs)); // TODO tagged\n    gen.assign(names_1.default.errors, (0, codegen_1._)(_templateObject7 || (_templateObject7 = _taggedTemplateLiteral([\"\", \".length\"])), names_1.default.vErrors));\n  }\n  function addEvaluatedFrom(source) {\n    var _a;\n    if (!it.opts.unevaluated) return;\n    const schEvaluated = (_a = sch === null || sch === void 0 ? void 0 : sch.validate) === null || _a === void 0 ? void 0 : _a.evaluated;\n    // TODO refactor\n    if (it.props !== true) {\n      if (schEvaluated && !schEvaluated.dynamicProps) {\n        if (schEvaluated.props !== undefined) {\n          it.props = util_1.mergeEvaluated.props(gen, schEvaluated.props, it.props);\n        }\n      } else {\n        const props = gen.var(\"props\", (0, codegen_1._)(_templateObject8 || (_templateObject8 = _taggedTemplateLiteral([\"\", \".evaluated.props\"])), source));\n        it.props = util_1.mergeEvaluated.props(gen, props, it.props, codegen_1.Name);\n      }\n    }\n    if (it.items !== true) {\n      if (schEvaluated && !schEvaluated.dynamicItems) {\n        if (schEvaluated.items !== undefined) {\n          it.items = util_1.mergeEvaluated.items(gen, schEvaluated.items, it.items);\n        }\n      } else {\n        const items = gen.var(\"items\", (0, codegen_1._)(_templateObject9 || (_templateObject9 = _taggedTemplateLiteral([\"\", \".evaluated.items\"])), source));\n        it.items = util_1.mergeEvaluated.items(gen, items, it.items, codegen_1.Name);\n      }\n    }\n  }\n}\nexports.callRef = callRef;\nexports.default = def;","map":{"version":3,"names":["ref_error_1","require","code_1","codegen_1","names_1","compile_1","util_1","def","keyword","schemaType","code","cxt","gen","schema","$ref","it","baseId","schemaEnv","env","validateName","opts","self","root","callRootRef","schOrEnv","resolveRef","call","undefined","default","uriResolver","SchemaEnv","callValidate","inlineRefSchema","callRef","$async","rootName","scopeValue","ref","_","_templateObject","_taggedTemplateLiteral","sch","v","getValidate","schName","source","stringify","valid","name","schCxt","subschema","dataTypes","schemaPath","nil","topSchemaRef","errSchemaPath","mergeEvaluated","ok","validate","_templateObject2","exports","allErrors","passCxt","passContext","this","callAsyncRef","callSyncRef","Error","let","try","_templateObject3","callValidateCode","addEvaluatedFrom","assign","e","if","_templateObject4","ValidationError","throw","addErrorsFrom","result","errs","_templateObject5","vErrors","_templateObject6","errors","_templateObject7","unevaluated","schEvaluated","_a","evaluated","props","dynamicProps","var","_templateObject8","Name","items","dynamicItems","_templateObject9"],"sources":["/home/runner/work/sgex/sgex/node_modules/ajv/lib/vocabularies/core/ref.ts"],"sourcesContent":["import type {CodeKeywordDefinition, AnySchema} from \"../../types\"\nimport type {KeywordCxt} from \"../../compile/validate\"\nimport MissingRefError from \"../../compile/ref_error\"\nimport {callValidateCode} from \"../code\"\nimport {_, nil, stringify, Code, Name} from \"../../compile/codegen\"\nimport N from \"../../compile/names\"\nimport {SchemaEnv, resolveRef} from \"../../compile\"\nimport {mergeEvaluated} from \"../../compile/util\"\n\nconst def: CodeKeywordDefinition = {\n  keyword: \"$ref\",\n  schemaType: \"string\",\n  code(cxt: KeywordCxt): void {\n    const {gen, schema: $ref, it} = cxt\n    const {baseId, schemaEnv: env, validateName, opts, self} = it\n    const {root} = env\n    if (($ref === \"#\" || $ref === \"#/\") && baseId === root.baseId) return callRootRef()\n    const schOrEnv = resolveRef.call(self, root, baseId, $ref)\n    if (schOrEnv === undefined) throw new MissingRefError(it.opts.uriResolver, baseId, $ref)\n    if (schOrEnv instanceof SchemaEnv) return callValidate(schOrEnv)\n    return inlineRefSchema(schOrEnv)\n\n    function callRootRef(): void {\n      if (env === root) return callRef(cxt, validateName, env, env.$async)\n      const rootName = gen.scopeValue(\"root\", {ref: root})\n      return callRef(cxt, _`${rootName}.validate`, root, root.$async)\n    }\n\n    function callValidate(sch: SchemaEnv): void {\n      const v = getValidate(cxt, sch)\n      callRef(cxt, v, sch, sch.$async)\n    }\n\n    function inlineRefSchema(sch: AnySchema): void {\n      const schName = gen.scopeValue(\n        \"schema\",\n        opts.code.source === true ? {ref: sch, code: stringify(sch)} : {ref: sch}\n      )\n      const valid = gen.name(\"valid\")\n      const schCxt = cxt.subschema(\n        {\n          schema: sch,\n          dataTypes: [],\n          schemaPath: nil,\n          topSchemaRef: schName,\n          errSchemaPath: $ref,\n        },\n        valid\n      )\n      cxt.mergeEvaluated(schCxt)\n      cxt.ok(valid)\n    }\n  },\n}\n\nexport function getValidate(cxt: KeywordCxt, sch: SchemaEnv): Code {\n  const {gen} = cxt\n  return sch.validate\n    ? gen.scopeValue(\"validate\", {ref: sch.validate})\n    : _`${gen.scopeValue(\"wrapper\", {ref: sch})}.validate`\n}\n\nexport function callRef(cxt: KeywordCxt, v: Code, sch?: SchemaEnv, $async?: boolean): void {\n  const {gen, it} = cxt\n  const {allErrors, schemaEnv: env, opts} = it\n  const passCxt = opts.passContext ? N.this : nil\n  if ($async) callAsyncRef()\n  else callSyncRef()\n\n  function callAsyncRef(): void {\n    if (!env.$async) throw new Error(\"async schema referenced by sync schema\")\n    const valid = gen.let(\"valid\")\n    gen.try(\n      () => {\n        gen.code(_`await ${callValidateCode(cxt, v, passCxt)}`)\n        addEvaluatedFrom(v) // TODO will not work with async, it has to be returned with the result\n        if (!allErrors) gen.assign(valid, true)\n      },\n      (e) => {\n        gen.if(_`!(${e} instanceof ${it.ValidationError as Name})`, () => gen.throw(e))\n        addErrorsFrom(e)\n        if (!allErrors) gen.assign(valid, false)\n      }\n    )\n    cxt.ok(valid)\n  }\n\n  function callSyncRef(): void {\n    cxt.result(\n      callValidateCode(cxt, v, passCxt),\n      () => addEvaluatedFrom(v),\n      () => addErrorsFrom(v)\n    )\n  }\n\n  function addErrorsFrom(source: Code): void {\n    const errs = _`${source}.errors`\n    gen.assign(N.vErrors, _`${N.vErrors} === null ? ${errs} : ${N.vErrors}.concat(${errs})`) // TODO tagged\n    gen.assign(N.errors, _`${N.vErrors}.length`)\n  }\n\n  function addEvaluatedFrom(source: Code): void {\n    if (!it.opts.unevaluated) return\n    const schEvaluated = sch?.validate?.evaluated\n    // TODO refactor\n    if (it.props !== true) {\n      if (schEvaluated && !schEvaluated.dynamicProps) {\n        if (schEvaluated.props !== undefined) {\n          it.props = mergeEvaluated.props(gen, schEvaluated.props, it.props)\n        }\n      } else {\n        const props = gen.var(\"props\", _`${source}.evaluated.props`)\n        it.props = mergeEvaluated.props(gen, props, it.props, Name)\n      }\n    }\n    if (it.items !== true) {\n      if (schEvaluated && !schEvaluated.dynamicItems) {\n        if (schEvaluated.items !== undefined) {\n          it.items = mergeEvaluated.items(gen, schEvaluated.items, it.items)\n        }\n      } else {\n        const items = gen.var(\"items\", _`${source}.evaluated.items`)\n        it.items = mergeEvaluated.items(gen, items, it.items, Name)\n      }\n    }\n  }\n}\n\nexport default def\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}