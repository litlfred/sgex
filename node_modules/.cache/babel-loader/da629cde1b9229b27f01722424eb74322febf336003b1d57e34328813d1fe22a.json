{"ast":null,"code":"import { find, forEach, map } from 'min-dash';\nimport BpmnTreeWalker from './BpmnTreeWalker';\nimport { is } from '../util/ModelUtil';\n\n/**\n * @typedef {import('../model/Types').ModdleElement} ModdleElement\n *\n * @typedef { {\n *   warnings: string[];\n * } } ImportBPMNDiagramResult\n *\n * @typedef {ImportBPMNDiagramResult & Error} ImportBPMNDiagramError\n */\n\n/**\n * Import the definitions into a diagram.\n *\n * Errors and warnings are reported through the specified callback.\n *\n * @param {ModdleElement} diagram\n * @param {ModdleElement} definitions\n * @param {ModdleElement} [bpmnDiagram] The diagram to be rendered (if not\n * provided, the first one will be rendered).\n *\n * @return {Promise<ImportBPMNDiagramResult>}\n */\nexport function importBpmnDiagram(diagram, definitions, bpmnDiagram) {\n  var importer, eventBus, canvas;\n  var error,\n    warnings = [];\n\n  /**\n   * Walk the diagram semantically, importing (=drawing)\n   * all elements you encounter.\n   *\n   * @param {ModdleElement} definitions\n   * @param {ModdleElement} bpmnDiagram\n   */\n  function render(definitions, bpmnDiagram) {\n    var visitor = {\n      root: function (element, di) {\n        return importer.add(element, di);\n      },\n      element: function (element, di, parentShape) {\n        return importer.add(element, di, parentShape);\n      },\n      error: function (message, context) {\n        warnings.push({\n          message: message,\n          context: context\n        });\n      }\n    };\n    var walker = new BpmnTreeWalker(visitor);\n    bpmnDiagram = bpmnDiagram || definitions.diagrams && definitions.diagrams[0];\n    var diagramsToImport = getDiagramsToImport(definitions, bpmnDiagram);\n    if (!diagramsToImport) {\n      throw new Error('no diagram to display');\n    }\n\n    // traverse BPMN 2.0 document model,\n    // starting at definitions\n    forEach(diagramsToImport, function (diagram) {\n      walker.handleDefinitions(definitions, diagram);\n    });\n    var rootId = bpmnDiagram.plane.bpmnElement.id;\n\n    // we do need to account for different ways we create root elements\n    // each nested imported <root> do have the `_plane` suffix, while\n    // the root <root> is found under the business object ID\n    canvas.setRootElement(canvas.findRoot(rootId + '_plane') || canvas.findRoot(rootId));\n  }\n  return new Promise(function (resolve, reject) {\n    try {\n      importer = diagram.get('bpmnImporter');\n      eventBus = diagram.get('eventBus');\n      canvas = diagram.get('canvas');\n      eventBus.fire('import.render.start', {\n        definitions: definitions\n      });\n      render(definitions, bpmnDiagram);\n      eventBus.fire('import.render.complete', {\n        error: error,\n        warnings: warnings\n      });\n      return resolve({\n        warnings: warnings\n      });\n    } catch (e) {\n      e.warnings = warnings;\n      return reject(e);\n    }\n  });\n}\n\n/**\n * Returns all diagrams in the same hierarchy as the requested diagram.\n * Includes all parent and sub process diagrams.\n *\n * @param {ModdleElement} definitions\n * @param {ModdleElement} bpmnDiagram\n *\n * @return {ModdleElement[]}\n */\nfunction getDiagramsToImport(definitions, bpmnDiagram) {\n  if (!bpmnDiagram || !bpmnDiagram.plane) {\n    return;\n  }\n  var bpmnElement = bpmnDiagram.plane.bpmnElement,\n    rootElement = bpmnElement;\n  if (!is(bpmnElement, 'bpmn:Process') && !is(bpmnElement, 'bpmn:Collaboration')) {\n    rootElement = findRootProcess(bpmnElement);\n  }\n\n  // in case the process is part of a collaboration, the plane references the\n  // collaboration, not the process\n  var collaboration;\n  if (is(rootElement, 'bpmn:Collaboration')) {\n    collaboration = rootElement;\n  } else {\n    collaboration = find(definitions.rootElements, function (element) {\n      if (!is(element, 'bpmn:Collaboration')) {\n        return;\n      }\n      return find(element.participants, function (participant) {\n        return participant.processRef === rootElement;\n      });\n    });\n  }\n  var rootElements = [rootElement];\n\n  // all collaboration processes can contain sub-diagrams\n  if (collaboration) {\n    rootElements = map(collaboration.participants, function (participant) {\n      return participant.processRef;\n    });\n    rootElements.push(collaboration);\n  }\n  var allChildren = selfAndAllFlowElements(rootElements);\n\n  // if we have multiple diagrams referencing the same element, we\n  // use the first in the file\n  var diagramsToImport = [bpmnDiagram];\n  var handledElements = [bpmnElement];\n  forEach(definitions.diagrams, function (diagram) {\n    if (!diagram.plane) {\n      return;\n    }\n    var businessObject = diagram.plane.bpmnElement;\n    if (allChildren.indexOf(businessObject) !== -1 && handledElements.indexOf(businessObject) === -1) {\n      diagramsToImport.push(diagram);\n      handledElements.push(businessObject);\n    }\n  });\n  return diagramsToImport;\n}\nfunction selfAndAllFlowElements(elements) {\n  var result = [];\n  forEach(elements, function (element) {\n    if (!element) {\n      return;\n    }\n    result.push(element);\n    result = result.concat(selfAndAllFlowElements(element.flowElements));\n  });\n  return result;\n}\nfunction findRootProcess(element) {\n  var parent = element;\n  while (parent) {\n    if (is(parent, 'bpmn:Process')) {\n      return parent;\n    }\n    parent = parent.$parent;\n  }\n}","map":{"version":3,"names":["find","forEach","map","BpmnTreeWalker","is","importBpmnDiagram","diagram","definitions","bpmnDiagram","importer","eventBus","canvas","error","warnings","render","visitor","root","element","di","add","parentShape","message","context","push","walker","diagrams","diagramsToImport","getDiagramsToImport","Error","handleDefinitions","rootId","plane","bpmnElement","id","setRootElement","findRoot","Promise","resolve","reject","get","fire","e","rootElement","findRootProcess","collaboration","rootElements","participants","participant","processRef","allChildren","selfAndAllFlowElements","handledElements","businessObject","indexOf","elements","result","concat","flowElements","parent","$parent"],"sources":["/home/runner/work/sgex/sgex/node_modules/bpmn-js/lib/import/Importer.js"],"sourcesContent":["import {\n  find,\n  forEach,\n  map\n} from 'min-dash';\n\nimport BpmnTreeWalker from './BpmnTreeWalker';\n\nimport { is } from '../util/ModelUtil';\n\n\n/**\n * @typedef {import('../model/Types').ModdleElement} ModdleElement\n *\n * @typedef { {\n *   warnings: string[];\n * } } ImportBPMNDiagramResult\n *\n * @typedef {ImportBPMNDiagramResult & Error} ImportBPMNDiagramError\n */\n\n/**\n * Import the definitions into a diagram.\n *\n * Errors and warnings are reported through the specified callback.\n *\n * @param {ModdleElement} diagram\n * @param {ModdleElement} definitions\n * @param {ModdleElement} [bpmnDiagram] The diagram to be rendered (if not\n * provided, the first one will be rendered).\n *\n * @return {Promise<ImportBPMNDiagramResult>}\n */\nexport function importBpmnDiagram(diagram, definitions, bpmnDiagram) {\n\n  var importer,\n      eventBus,\n      canvas;\n\n  var error,\n      warnings = [];\n\n  /**\n   * Walk the diagram semantically, importing (=drawing)\n   * all elements you encounter.\n   *\n   * @param {ModdleElement} definitions\n   * @param {ModdleElement} bpmnDiagram\n   */\n  function render(definitions, bpmnDiagram) {\n\n    var visitor = {\n\n      root: function(element, di) {\n        return importer.add(element, di);\n      },\n\n      element: function(element, di, parentShape) {\n        return importer.add(element, di, parentShape);\n      },\n\n      error: function(message, context) {\n        warnings.push({ message: message, context: context });\n      }\n    };\n\n    var walker = new BpmnTreeWalker(visitor);\n\n\n    bpmnDiagram = bpmnDiagram || (definitions.diagrams && definitions.diagrams[0]);\n\n    var diagramsToImport = getDiagramsToImport(definitions, bpmnDiagram);\n\n    if (!diagramsToImport) {\n      throw new Error('no diagram to display');\n    }\n\n    // traverse BPMN 2.0 document model,\n    // starting at definitions\n    forEach(diagramsToImport, function(diagram) {\n      walker.handleDefinitions(definitions, diagram);\n    });\n\n    var rootId = bpmnDiagram.plane.bpmnElement.id;\n\n    // we do need to account for different ways we create root elements\n    // each nested imported <root> do have the `_plane` suffix, while\n    // the root <root> is found under the business object ID\n    canvas.setRootElement(\n      canvas.findRoot(rootId + '_plane') || canvas.findRoot(rootId)\n    );\n  }\n\n  return new Promise(function(resolve, reject) {\n    try {\n      importer = diagram.get('bpmnImporter');\n      eventBus = diagram.get('eventBus');\n      canvas = diagram.get('canvas');\n\n      eventBus.fire('import.render.start', { definitions: definitions });\n\n      render(definitions, bpmnDiagram);\n\n      eventBus.fire('import.render.complete', {\n        error: error,\n        warnings: warnings\n      });\n\n      return resolve({ warnings: warnings });\n    } catch (e) {\n\n      e.warnings = warnings;\n      return reject(e);\n    }\n  });\n}\n\n/**\n * Returns all diagrams in the same hierarchy as the requested diagram.\n * Includes all parent and sub process diagrams.\n *\n * @param {ModdleElement} definitions\n * @param {ModdleElement} bpmnDiagram\n *\n * @return {ModdleElement[]}\n */\nfunction getDiagramsToImport(definitions, bpmnDiagram) {\n  if (!bpmnDiagram || !bpmnDiagram.plane) {\n    return;\n  }\n\n  var bpmnElement = bpmnDiagram.plane.bpmnElement,\n      rootElement = bpmnElement;\n\n  if (!is(bpmnElement, 'bpmn:Process') && !is(bpmnElement, 'bpmn:Collaboration')) {\n    rootElement = findRootProcess(bpmnElement);\n  }\n\n  // in case the process is part of a collaboration, the plane references the\n  // collaboration, not the process\n  var collaboration;\n\n  if (is(rootElement, 'bpmn:Collaboration')) {\n    collaboration = rootElement;\n  } else {\n    collaboration = find(definitions.rootElements, function(element) {\n      if (!is(element, 'bpmn:Collaboration')) {\n        return;\n      }\n\n      return find(element.participants, function(participant) {\n        return participant.processRef === rootElement;\n      });\n    });\n  }\n\n  var rootElements = [ rootElement ];\n\n  // all collaboration processes can contain sub-diagrams\n  if (collaboration) {\n    rootElements = map(collaboration.participants, function(participant) {\n      return participant.processRef;\n    });\n\n    rootElements.push(collaboration);\n  }\n\n  var allChildren = selfAndAllFlowElements(rootElements);\n\n  // if we have multiple diagrams referencing the same element, we\n  // use the first in the file\n  var diagramsToImport = [ bpmnDiagram ];\n  var handledElements = [ bpmnElement ];\n\n  forEach(definitions.diagrams, function(diagram) {\n\n    if (!diagram.plane) {\n      return;\n    }\n\n    var businessObject = diagram.plane.bpmnElement;\n\n    if (\n      allChildren.indexOf(businessObject) !== -1 &&\n      handledElements.indexOf(businessObject) === -1\n    ) {\n      diagramsToImport.push(diagram);\n      handledElements.push(businessObject);\n    }\n  });\n\n\n  return diagramsToImport;\n}\n\nfunction selfAndAllFlowElements(elements) {\n  var result = [];\n\n  forEach(elements, function(element) {\n    if (!element) {\n      return;\n    }\n\n    result.push(element);\n\n    result = result.concat(selfAndAllFlowElements(element.flowElements));\n  });\n\n  return result;\n}\n\nfunction findRootProcess(element) {\n  var parent = element;\n\n  while (parent) {\n    if (is(parent, 'bpmn:Process')) {\n      return parent;\n    }\n\n    parent = parent.$parent;\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}