{"ast":null,"code":"import { asTRBL, getOrientation, roundPoint } from '../layout/LayoutUtil';\nimport { center, delta } from './PositionUtil';\n\n/**\n * @typedef {import('../model/Types').Shape} Shape\n *\n * @typedef {import('../util/Types').Point} Point\n * @typedef {import('../util/Types').Rect} Rect\n */\n\n/**\n * Calculates the absolute point relative to the new element's position.\n *\n * @param {Point} point [absolute]\n * @param {Rect} oldBounds\n * @param {Rect} newBounds\n *\n * @return {Point} point [absolute]\n */\nexport function getNewAttachPoint(point, oldBounds, newBounds) {\n  var oldCenter = center(oldBounds),\n    newCenter = center(newBounds),\n    oldDelta = delta(point, oldCenter);\n  var newDelta = {\n    x: oldDelta.x * (newBounds.width / oldBounds.width),\n    y: oldDelta.y * (newBounds.height / oldBounds.height)\n  };\n  return roundPoint({\n    x: newCenter.x + newDelta.x,\n    y: newCenter.y + newDelta.y\n  });\n}\n\n/**\n * Calculates the shape's delta relative to a new position\n * of a certain element's bounds.\n *\n * @param {Shape} shape\n * @param {Rect} oldBounds\n * @param {Rect} newBounds\n *\n * @return {Point} delta\n */\nexport function getNewAttachShapeDelta(shape, oldBounds, newBounds) {\n  var shapeCenter = center(shape),\n    oldCenter = center(oldBounds),\n    newCenter = center(newBounds),\n    shapeDelta = delta(shape, shapeCenter),\n    oldCenterDelta = delta(shapeCenter, oldCenter),\n    stickyPositionDelta = getStickyPositionDelta(shapeCenter, oldBounds, newBounds);\n  if (stickyPositionDelta) {\n    return stickyPositionDelta;\n  }\n  var newCenterDelta = {\n    x: oldCenterDelta.x * (newBounds.width / oldBounds.width),\n    y: oldCenterDelta.y * (newBounds.height / oldBounds.height)\n  };\n  var newShapeCenter = {\n    x: newCenter.x + newCenterDelta.x,\n    y: newCenter.y + newCenterDelta.y\n  };\n  return roundPoint({\n    x: newShapeCenter.x + shapeDelta.x - shape.x,\n    y: newShapeCenter.y + shapeDelta.y - shape.y\n  });\n}\nfunction getStickyPositionDelta(oldShapeCenter, oldBounds, newBounds) {\n  var oldTRBL = asTRBL(oldBounds),\n    newTRBL = asTRBL(newBounds);\n  if (isMoved(oldTRBL, newTRBL)) {\n    return null;\n  }\n  var oldOrientation = getOrientation(oldBounds, oldShapeCenter),\n    stickyPositionDelta,\n    newShapeCenter,\n    newOrientation;\n  if (oldOrientation === 'top') {\n    stickyPositionDelta = {\n      x: 0,\n      y: newTRBL.bottom - oldTRBL.bottom\n    };\n  } else if (oldOrientation === 'bottom') {\n    stickyPositionDelta = {\n      x: 0,\n      y: newTRBL.top - oldTRBL.top\n    };\n  } else if (oldOrientation === 'right') {\n    stickyPositionDelta = {\n      x: newTRBL.left - oldTRBL.left,\n      y: 0\n    };\n  } else if (oldOrientation === 'left') {\n    stickyPositionDelta = {\n      x: newTRBL.right - oldTRBL.right,\n      y: 0\n    };\n  } else {\n    // fallback to proportional movement for corner-placed attachments\n    return null;\n  }\n  newShapeCenter = {\n    x: oldShapeCenter.x + stickyPositionDelta.x,\n    y: oldShapeCenter.y + stickyPositionDelta.y\n  };\n  newOrientation = getOrientation(newBounds, newShapeCenter);\n  if (newOrientation !== oldOrientation) {\n    // fallback to proportional movement if orientation would otherwise change\n    return null;\n  }\n  return stickyPositionDelta;\n}\nfunction isMoved(oldTRBL, newTRBL) {\n  return isHorizontallyMoved(oldTRBL, newTRBL) || isVerticallyMoved(oldTRBL, newTRBL);\n}\nfunction isHorizontallyMoved(oldTRBL, newTRBL) {\n  return oldTRBL.right !== newTRBL.right && oldTRBL.left !== newTRBL.left;\n}\nfunction isVerticallyMoved(oldTRBL, newTRBL) {\n  return oldTRBL.top !== newTRBL.top && oldTRBL.bottom !== newTRBL.bottom;\n}","map":{"version":3,"names":["asTRBL","getOrientation","roundPoint","center","delta","getNewAttachPoint","point","oldBounds","newBounds","oldCenter","newCenter","oldDelta","newDelta","x","width","y","height","getNewAttachShapeDelta","shape","shapeCenter","shapeDelta","oldCenterDelta","stickyPositionDelta","getStickyPositionDelta","newCenterDelta","newShapeCenter","oldShapeCenter","oldTRBL","newTRBL","isMoved","oldOrientation","newOrientation","bottom","top","left","right","isHorizontallyMoved","isVerticallyMoved"],"sources":["/home/runner/work/sgex/sgex/node_modules/diagram-js/lib/util/AttachUtil.js"],"sourcesContent":["import {\n  asTRBL,\n  getOrientation,\n  roundPoint\n} from '../layout/LayoutUtil';\n\nimport {\n  center,\n  delta\n} from './PositionUtil';\n\n/**\n * @typedef {import('../model/Types').Shape} Shape\n *\n * @typedef {import('../util/Types').Point} Point\n * @typedef {import('../util/Types').Rect} Rect\n */\n\n/**\n * Calculates the absolute point relative to the new element's position.\n *\n * @param {Point} point [absolute]\n * @param {Rect} oldBounds\n * @param {Rect} newBounds\n *\n * @return {Point} point [absolute]\n */\nexport function getNewAttachPoint(point, oldBounds, newBounds) {\n  var oldCenter = center(oldBounds),\n      newCenter = center(newBounds),\n      oldDelta = delta(point, oldCenter);\n\n  var newDelta = {\n    x: oldDelta.x * (newBounds.width / oldBounds.width),\n    y: oldDelta.y * (newBounds.height / oldBounds.height)\n  };\n\n  return roundPoint({\n    x: newCenter.x + newDelta.x,\n    y: newCenter.y + newDelta.y\n  });\n}\n\n\n/**\n * Calculates the shape's delta relative to a new position\n * of a certain element's bounds.\n *\n * @param {Shape} shape\n * @param {Rect} oldBounds\n * @param {Rect} newBounds\n *\n * @return {Point} delta\n */\nexport function getNewAttachShapeDelta(shape, oldBounds, newBounds) {\n  var shapeCenter = center(shape),\n      oldCenter = center(oldBounds),\n      newCenter = center(newBounds),\n      shapeDelta = delta(shape, shapeCenter),\n      oldCenterDelta = delta(shapeCenter, oldCenter),\n      stickyPositionDelta = getStickyPositionDelta(shapeCenter, oldBounds, newBounds);\n\n  if (stickyPositionDelta) {\n    return stickyPositionDelta;\n  }\n\n  var newCenterDelta = {\n    x: oldCenterDelta.x * (newBounds.width / oldBounds.width),\n    y: oldCenterDelta.y * (newBounds.height / oldBounds.height)\n  };\n\n  var newShapeCenter = {\n    x: newCenter.x + newCenterDelta.x,\n    y: newCenter.y + newCenterDelta.y\n  };\n\n  return roundPoint({\n    x: newShapeCenter.x + shapeDelta.x - shape.x,\n    y: newShapeCenter.y + shapeDelta.y - shape.y\n  });\n}\n\nfunction getStickyPositionDelta(oldShapeCenter, oldBounds, newBounds) {\n  var oldTRBL = asTRBL(oldBounds),\n      newTRBL = asTRBL(newBounds);\n\n  if (isMoved(oldTRBL, newTRBL)) {\n    return null;\n  }\n\n  var oldOrientation = getOrientation(oldBounds, oldShapeCenter),\n      stickyPositionDelta,\n      newShapeCenter,\n      newOrientation;\n\n  if (oldOrientation === 'top') {\n    stickyPositionDelta = {\n      x: 0,\n      y: newTRBL.bottom - oldTRBL.bottom\n    };\n  } else if (oldOrientation === 'bottom') {\n    stickyPositionDelta = {\n      x: 0,\n      y: newTRBL.top - oldTRBL.top\n    };\n  } else if (oldOrientation === 'right') {\n    stickyPositionDelta = {\n      x: newTRBL.left - oldTRBL.left,\n      y: 0\n    };\n  } else if (oldOrientation === 'left') {\n    stickyPositionDelta = {\n      x: newTRBL.right - oldTRBL.right,\n      y: 0\n    };\n  } else {\n\n    // fallback to proportional movement for corner-placed attachments\n    return null;\n  }\n\n  newShapeCenter = {\n    x: oldShapeCenter.x + stickyPositionDelta.x,\n    y: oldShapeCenter.y + stickyPositionDelta.y\n  };\n\n  newOrientation = getOrientation(newBounds, newShapeCenter);\n\n  if (newOrientation !== oldOrientation) {\n\n    // fallback to proportional movement if orientation would otherwise change\n    return null;\n  }\n\n  return stickyPositionDelta;\n}\n\nfunction isMoved(oldTRBL, newTRBL) {\n  return isHorizontallyMoved(oldTRBL, newTRBL) || isVerticallyMoved(oldTRBL, newTRBL);\n}\n\nfunction isHorizontallyMoved(oldTRBL, newTRBL) {\n  return oldTRBL.right !== newTRBL.right && oldTRBL.left !== newTRBL.left;\n}\n\nfunction isVerticallyMoved(oldTRBL, newTRBL) {\n  return oldTRBL.top !== newTRBL.top && oldTRBL.bottom !== newTRBL.bottom;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}