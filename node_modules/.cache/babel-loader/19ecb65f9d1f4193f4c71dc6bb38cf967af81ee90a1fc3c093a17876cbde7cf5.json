{"ast":null,"code":"import inherits from 'inherits-browser';\nimport CreateMoveSnapping from 'diagram-js/lib/features/snapping/CreateMoveSnapping';\nimport { isSnapped, setSnapped, topLeft, bottomRight } from 'diagram-js/lib/features/snapping/SnapUtil';\nimport { isExpanded } from '../../util/DiUtil';\nimport { is } from '../../util/ModelUtil';\nimport { asTRBL, getMid } from 'diagram-js/lib/layout/LayoutUtil';\nimport { getBoundaryAttachment } from './BpmnSnappingUtil';\nimport { forEach } from 'min-dash';\n\n/**\n * @typedef {import('diagram-js/lib/core/EventBus').default} EventBus\n * @typedef {import('didi').Injector} Injector\n *\n * @typedef {import('diagram-js/lib/features/snapping/SnapContext').default} SnapContext\n * @typedef {import('diagram-js/lib/features/snapping/SnapContext').SnapPoints} SnapPoints\n *\n * @typedef {import('diagram-js/lib/core/EventBus').Event} Event\n *\n * @typedef {import('../../model/Types').Element} Element\n * @typedef {import('../../model/Types').Shape} Shape\n */\n\nvar HIGH_PRIORITY = 1500;\n\n/**\n * Snap during create and move.\n *\n * @param {EventBus} eventBus\n * @param {Injector} injector\n */\nexport default function BpmnCreateMoveSnapping(eventBus, injector) {\n  injector.invoke(CreateMoveSnapping, this);\n\n  // creating first participant\n  eventBus.on(['create.move', 'create.end'], HIGH_PRIORITY, setSnappedIfConstrained);\n\n  // snap boundary events\n  eventBus.on(['create.move', 'create.end', 'shape.move.move', 'shape.move.end'], HIGH_PRIORITY, function (event) {\n    var context = event.context,\n      canExecute = context.canExecute,\n      target = context.target;\n    var canAttach = canExecute && (canExecute === 'attach' || canExecute.attach);\n    if (canAttach && !isSnapped(event)) {\n      snapBoundaryEvent(event, target);\n    }\n  });\n}\ninherits(BpmnCreateMoveSnapping, CreateMoveSnapping);\nBpmnCreateMoveSnapping.$inject = ['eventBus', 'injector'];\n\n/**\n * @param {Event} event\n *\n * @return {SnapContext}\n */\nBpmnCreateMoveSnapping.prototype.initSnap = function (event) {\n  var snapContext = CreateMoveSnapping.prototype.initSnap.call(this, event);\n  var shape = event.shape;\n  var isMove = !!this._elementRegistry.get(shape.id);\n\n  // snap to docking points\n  forEach(shape.outgoing, function (connection) {\n    var docking = connection.waypoints[0];\n    docking = docking.original || docking;\n    snapContext.setSnapOrigin(connection.id + '-docking', getDockingSnapOrigin(docking, isMove, event));\n  });\n  forEach(shape.incoming, function (connection) {\n    var docking = connection.waypoints[connection.waypoints.length - 1];\n    docking = docking.original || docking;\n    snapContext.setSnapOrigin(connection.id + '-docking', getDockingSnapOrigin(docking, isMove, event));\n  });\n  if (is(shape, 'bpmn:Participant')) {\n    // snap to borders with higher priority\n    snapContext.setSnapLocations(['top-left', 'bottom-right', 'mid']);\n  }\n  return snapContext;\n};\n\n/**\n * @param {SnapPoints} snapPoints\n * @param {Shape} shape\n * @param {Shape} target\n *\n * @return {SnapPoints}\n */\nBpmnCreateMoveSnapping.prototype.addSnapTargetPoints = function (snapPoints, shape, target) {\n  CreateMoveSnapping.prototype.addSnapTargetPoints.call(this, snapPoints, shape, target);\n  var snapTargets = this.getSnapTargets(shape, target);\n  forEach(snapTargets, function (snapTarget) {\n    // handle TRBL alignment\n    //\n    // * with container elements\n    // * with text annotations\n    if (isContainer(snapTarget) || areAll([shape, snapTarget], 'bpmn:TextAnnotation')) {\n      snapPoints.add('top-left', topLeft(snapTarget));\n      snapPoints.add('bottom-right', bottomRight(snapTarget));\n    }\n  });\n  var elementRegistry = this._elementRegistry;\n\n  // snap to docking points if not create mode\n  forEach(shape.incoming, function (connection) {\n    if (elementRegistry.get(shape.id)) {\n      if (!includes(snapTargets, connection.source)) {\n        snapPoints.add('mid', getMid(connection.source));\n      }\n      var docking = connection.waypoints[0];\n      snapPoints.add(connection.id + '-docking', docking.original || docking);\n    }\n  });\n  forEach(shape.outgoing, function (connection) {\n    if (elementRegistry.get(shape.id)) {\n      if (!includes(snapTargets, connection.target)) {\n        snapPoints.add('mid', getMid(connection.target));\n      }\n      var docking = connection.waypoints[connection.waypoints.length - 1];\n      snapPoints.add(connection.id + '-docking', docking.original || docking);\n    }\n  });\n\n  // add sequence flow parents as snap targets\n  if (is(target, 'bpmn:SequenceFlow')) {\n    snapPoints = this.addSnapTargetPoints(snapPoints, shape, target.parent);\n  }\n  return snapPoints;\n};\n\n/**\n * @param {Shape} shape\n * @param {Shape} target\n *\n * @return {Shape[]}\n */\nBpmnCreateMoveSnapping.prototype.getSnapTargets = function (shape, target) {\n  return CreateMoveSnapping.prototype.getSnapTargets.call(this, shape, target).filter(function (snapTarget) {\n    // do not snap to lanes\n    return !is(snapTarget, 'bpmn:Lane');\n  });\n};\n\n// helpers //////////\n\n/**\n * @param {Shape} event\n * @param {Shape} target\n */\nfunction snapBoundaryEvent(event, target) {\n  var targetTRBL = asTRBL(target);\n  var direction = getBoundaryAttachment(event, target);\n  var context = event.context,\n    shape = context.shape;\n  var offset;\n  if (shape.parent) {\n    offset = {\n      x: 0,\n      y: 0\n    };\n  } else {\n    offset = getMid(shape);\n  }\n  if (/top/.test(direction)) {\n    setSnapped(event, 'y', targetTRBL.top - offset.y);\n  } else if (/bottom/.test(direction)) {\n    setSnapped(event, 'y', targetTRBL.bottom - offset.y);\n  }\n  if (/left/.test(direction)) {\n    setSnapped(event, 'x', targetTRBL.left - offset.x);\n  } else if (/right/.test(direction)) {\n    setSnapped(event, 'x', targetTRBL.right - offset.x);\n  }\n}\n\n/**\n * @param {Element[]} elements\n * @param {string} type\n *\n * @return {boolean}\n */\nfunction areAll(elements, type) {\n  return elements.every(function (el) {\n    return is(el, type);\n  });\n}\n\n/**\n * @param {Element} element\n */\nfunction isContainer(element) {\n  if (is(element, 'bpmn:SubProcess') && isExpanded(element)) {\n    return true;\n  }\n  return is(element, 'bpmn:Participant');\n}\n\n/**\n * @param {Event} event\n */\nfunction setSnappedIfConstrained(event) {\n  var context = event.context,\n    createConstraints = context.createConstraints;\n  if (!createConstraints) {\n    return;\n  }\n  var top = createConstraints.top,\n    right = createConstraints.right,\n    bottom = createConstraints.bottom,\n    left = createConstraints.left;\n  if (left && left >= event.x || right && right <= event.x) {\n    setSnapped(event, 'x', event.x);\n  }\n  if (top && top >= event.y || bottom && bottom <= event.y) {\n    setSnapped(event, 'y', event.y);\n  }\n}\nfunction includes(array, value) {\n  return array.indexOf(value) !== -1;\n}\nfunction getDockingSnapOrigin(docking, isMove, event) {\n  return isMove ? {\n    x: docking.x - event.x,\n    y: docking.y - event.y\n  } : {\n    x: docking.x,\n    y: docking.y\n  };\n}","map":{"version":3,"names":["inherits","CreateMoveSnapping","isSnapped","setSnapped","topLeft","bottomRight","isExpanded","is","asTRBL","getMid","getBoundaryAttachment","forEach","HIGH_PRIORITY","BpmnCreateMoveSnapping","eventBus","injector","invoke","on","setSnappedIfConstrained","event","context","canExecute","target","canAttach","attach","snapBoundaryEvent","$inject","prototype","initSnap","snapContext","call","shape","isMove","_elementRegistry","get","id","outgoing","connection","docking","waypoints","original","setSnapOrigin","getDockingSnapOrigin","incoming","length","setSnapLocations","addSnapTargetPoints","snapPoints","snapTargets","getSnapTargets","snapTarget","isContainer","areAll","add","elementRegistry","includes","source","parent","filter","targetTRBL","direction","offset","x","y","test","top","bottom","left","right","elements","type","every","el","element","createConstraints","array","value","indexOf"],"sources":["/home/runner/work/sgex/sgex/node_modules/bpmn-js/lib/features/snapping/BpmnCreateMoveSnapping.js"],"sourcesContent":["import inherits from 'inherits-browser';\n\nimport CreateMoveSnapping from 'diagram-js/lib/features/snapping/CreateMoveSnapping';\n\nimport {\n  isSnapped,\n  setSnapped,\n  topLeft,\n  bottomRight\n} from 'diagram-js/lib/features/snapping/SnapUtil';\n\nimport { isExpanded } from '../../util/DiUtil';\n\nimport { is } from '../../util/ModelUtil';\n\nimport {\n  asTRBL,\n  getMid\n} from 'diagram-js/lib/layout/LayoutUtil';\n\nimport { getBoundaryAttachment } from './BpmnSnappingUtil';\n\nimport { forEach } from 'min-dash';\n\n/**\n * @typedef {import('diagram-js/lib/core/EventBus').default} EventBus\n * @typedef {import('didi').Injector} Injector\n *\n * @typedef {import('diagram-js/lib/features/snapping/SnapContext').default} SnapContext\n * @typedef {import('diagram-js/lib/features/snapping/SnapContext').SnapPoints} SnapPoints\n *\n * @typedef {import('diagram-js/lib/core/EventBus').Event} Event\n *\n * @typedef {import('../../model/Types').Element} Element\n * @typedef {import('../../model/Types').Shape} Shape\n */\n\nvar HIGH_PRIORITY = 1500;\n\n\n/**\n * Snap during create and move.\n *\n * @param {EventBus} eventBus\n * @param {Injector} injector\n */\nexport default function BpmnCreateMoveSnapping(eventBus, injector) {\n  injector.invoke(CreateMoveSnapping, this);\n\n  // creating first participant\n  eventBus.on([ 'create.move', 'create.end' ], HIGH_PRIORITY, setSnappedIfConstrained);\n\n  // snap boundary events\n  eventBus.on([\n    'create.move',\n    'create.end',\n    'shape.move.move',\n    'shape.move.end'\n  ], HIGH_PRIORITY, function(event) {\n    var context = event.context,\n        canExecute = context.canExecute,\n        target = context.target;\n\n    var canAttach = canExecute && (canExecute === 'attach' || canExecute.attach);\n\n    if (canAttach && !isSnapped(event)) {\n      snapBoundaryEvent(event, target);\n    }\n  });\n}\n\ninherits(BpmnCreateMoveSnapping, CreateMoveSnapping);\n\nBpmnCreateMoveSnapping.$inject = [\n  'eventBus',\n  'injector'\n];\n\n/**\n * @param {Event} event\n *\n * @return {SnapContext}\n */\nBpmnCreateMoveSnapping.prototype.initSnap = function(event) {\n  var snapContext = CreateMoveSnapping.prototype.initSnap.call(this, event);\n\n  var shape = event.shape;\n\n  var isMove = !!this._elementRegistry.get(shape.id);\n\n  // snap to docking points\n  forEach(shape.outgoing, function(connection) {\n    var docking = connection.waypoints[0];\n\n    docking = docking.original || docking;\n\n    snapContext.setSnapOrigin(connection.id + '-docking', getDockingSnapOrigin(docking, isMove, event));\n  });\n\n  forEach(shape.incoming, function(connection) {\n    var docking = connection.waypoints[connection.waypoints.length - 1];\n\n    docking = docking.original || docking;\n\n    snapContext.setSnapOrigin(connection.id + '-docking', getDockingSnapOrigin(docking, isMove, event));\n  });\n\n  if (is(shape, 'bpmn:Participant')) {\n\n    // snap to borders with higher priority\n    snapContext.setSnapLocations([ 'top-left', 'bottom-right', 'mid' ]);\n  }\n\n  return snapContext;\n};\n\n/**\n * @param {SnapPoints} snapPoints\n * @param {Shape} shape\n * @param {Shape} target\n *\n * @return {SnapPoints}\n */\nBpmnCreateMoveSnapping.prototype.addSnapTargetPoints = function(snapPoints, shape, target) {\n  CreateMoveSnapping.prototype.addSnapTargetPoints.call(this, snapPoints, shape, target);\n\n  var snapTargets = this.getSnapTargets(shape, target);\n\n  forEach(snapTargets, function(snapTarget) {\n\n    // handle TRBL alignment\n    //\n    // * with container elements\n    // * with text annotations\n    if (isContainer(snapTarget) || areAll([ shape, snapTarget ], 'bpmn:TextAnnotation')) {\n      snapPoints.add('top-left', topLeft(snapTarget));\n      snapPoints.add('bottom-right', bottomRight(snapTarget));\n    }\n  });\n\n  var elementRegistry = this._elementRegistry;\n\n  // snap to docking points if not create mode\n  forEach(shape.incoming, function(connection) {\n    if (elementRegistry.get(shape.id)) {\n\n      if (!includes(snapTargets, connection.source)) {\n        snapPoints.add('mid', getMid(connection.source));\n      }\n\n      var docking = connection.waypoints[0];\n      snapPoints.add(connection.id + '-docking', docking.original || docking);\n    }\n  });\n\n  forEach(shape.outgoing, function(connection) {\n    if (elementRegistry.get(shape.id)) {\n\n      if (!includes(snapTargets, connection.target)) {\n        snapPoints.add('mid', getMid(connection.target));\n      }\n\n      var docking = connection.waypoints[ connection.waypoints.length - 1 ];\n\n      snapPoints.add(connection.id + '-docking', docking.original || docking);\n    }\n  });\n\n  // add sequence flow parents as snap targets\n  if (is(target, 'bpmn:SequenceFlow')) {\n    snapPoints = this.addSnapTargetPoints(snapPoints, shape, target.parent);\n  }\n\n  return snapPoints;\n};\n\n/**\n * @param {Shape} shape\n * @param {Shape} target\n *\n * @return {Shape[]}\n */\nBpmnCreateMoveSnapping.prototype.getSnapTargets = function(shape, target) {\n  return CreateMoveSnapping.prototype.getSnapTargets.call(this, shape, target)\n    .filter(function(snapTarget) {\n\n      // do not snap to lanes\n      return !is(snapTarget, 'bpmn:Lane');\n    });\n};\n\n// helpers //////////\n\n/**\n * @param {Shape} event\n * @param {Shape} target\n */\nfunction snapBoundaryEvent(event, target) {\n  var targetTRBL = asTRBL(target);\n\n  var direction = getBoundaryAttachment(event, target);\n\n  var context = event.context,\n      shape = context.shape;\n\n  var offset;\n\n  if (shape.parent) {\n    offset = { x: 0, y: 0 };\n  } else {\n    offset = getMid(shape);\n  }\n\n  if (/top/.test(direction)) {\n    setSnapped(event, 'y', targetTRBL.top - offset.y);\n  } else if (/bottom/.test(direction)) {\n    setSnapped(event, 'y', targetTRBL.bottom - offset.y);\n  }\n\n  if (/left/.test(direction)) {\n    setSnapped(event, 'x', targetTRBL.left - offset.x);\n  } else if (/right/.test(direction)) {\n    setSnapped(event, 'x', targetTRBL.right - offset.x);\n  }\n}\n\n/**\n * @param {Element[]} elements\n * @param {string} type\n *\n * @return {boolean}\n */\nfunction areAll(elements, type) {\n  return elements.every(function(el) {\n    return is(el, type);\n  });\n}\n\n/**\n * @param {Element} element\n */\nfunction isContainer(element) {\n  if (is(element, 'bpmn:SubProcess') && isExpanded(element)) {\n    return true;\n  }\n\n  return is(element, 'bpmn:Participant');\n}\n\n/**\n * @param {Event} event\n */\nfunction setSnappedIfConstrained(event) {\n  var context = event.context,\n      createConstraints = context.createConstraints;\n\n  if (!createConstraints) {\n    return;\n  }\n\n  var top = createConstraints.top,\n      right = createConstraints.right,\n      bottom = createConstraints.bottom,\n      left = createConstraints.left;\n\n  if ((left && left >= event.x) || (right && right <= event.x)) {\n    setSnapped(event, 'x', event.x);\n  }\n\n  if ((top && top >= event.y) || (bottom && bottom <= event.y)) {\n    setSnapped(event, 'y', event.y);\n  }\n}\n\nfunction includes(array, value) {\n  return array.indexOf(value) !== -1;\n}\n\nfunction getDockingSnapOrigin(docking, isMove, event) {\n  return isMove ? (\n    {\n      x: docking.x - event.x,\n      y: docking.y - event.y\n    }\n  ) : {\n    x: docking.x,\n    y: docking.y\n  };\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}