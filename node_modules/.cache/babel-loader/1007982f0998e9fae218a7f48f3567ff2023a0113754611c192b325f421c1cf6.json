{"ast":null,"code":"\"use strict\";\n\nvar _taggedTemplateLiteral = require(\"/home/runner/work/sgex/sgex/node_modules/@babel/runtime/helpers/taggedTemplateLiteral.js\").default;\nvar _templateObject, _templateObject2, _templateObject3, _templateObject4, _templateObject5, _templateObject6, _templateObject7, _templateObject8;\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.formatLimitDefinition = void 0;\nconst ajv_1 = require(\"ajv\");\nconst codegen_1 = require(\"ajv/dist/compile/codegen\");\nconst ops = codegen_1.operators;\nconst KWDs = {\n  formatMaximum: {\n    okStr: \"<=\",\n    ok: ops.LTE,\n    fail: ops.GT\n  },\n  formatMinimum: {\n    okStr: \">=\",\n    ok: ops.GTE,\n    fail: ops.LT\n  },\n  formatExclusiveMaximum: {\n    okStr: \"<\",\n    ok: ops.LT,\n    fail: ops.GTE\n  },\n  formatExclusiveMinimum: {\n    okStr: \">\",\n    ok: ops.GT,\n    fail: ops.LTE\n  }\n};\nconst error = {\n  message: _ref => {\n    let {\n      keyword,\n      schemaCode\n    } = _ref;\n    return (0, codegen_1.str)(_templateObject || (_templateObject = _taggedTemplateLiteral([\"should be \", \" \", \"\"])), KWDs[keyword].okStr, schemaCode);\n  },\n  params: _ref2 => {\n    let {\n      keyword,\n      schemaCode\n    } = _ref2;\n    return (0, codegen_1._)(_templateObject2 || (_templateObject2 = _taggedTemplateLiteral([\"{comparison: \", \", limit: \", \"}\"])), KWDs[keyword].okStr, schemaCode);\n  }\n};\nexports.formatLimitDefinition = {\n  keyword: Object.keys(KWDs),\n  type: \"string\",\n  schemaType: \"string\",\n  $data: true,\n  error,\n  code(cxt) {\n    const {\n      gen,\n      data,\n      schemaCode,\n      keyword,\n      it\n    } = cxt;\n    const {\n      opts,\n      self\n    } = it;\n    if (!opts.validateFormats) return;\n    const fCxt = new ajv_1.KeywordCxt(it, self.RULES.all.format.definition, \"format\");\n    if (fCxt.$data) validate$DataFormat();else validateFormat();\n    function validate$DataFormat() {\n      const fmts = gen.scopeValue(\"formats\", {\n        ref: self.formats,\n        code: opts.code.formats\n      });\n      const fmt = gen.const(\"fmt\", (0, codegen_1._)(_templateObject3 || (_templateObject3 = _taggedTemplateLiteral([\"\", \"[\", \"]\"])), fmts, fCxt.schemaCode));\n      cxt.fail$data((0, codegen_1.or)((0, codegen_1._)(_templateObject4 || (_templateObject4 = _taggedTemplateLiteral([\"typeof \", \" != \\\"object\\\"\"])), fmt), (0, codegen_1._)(_templateObject5 || (_templateObject5 = _taggedTemplateLiteral([\"\", \" instanceof RegExp\"])), fmt), (0, codegen_1._)(_templateObject6 || (_templateObject6 = _taggedTemplateLiteral([\"typeof \", \".compare != \\\"function\\\"\"])), fmt), compareCode(fmt)));\n    }\n    function validateFormat() {\n      const format = fCxt.schema;\n      const fmtDef = self.formats[format];\n      if (!fmtDef || fmtDef === true) return;\n      if (typeof fmtDef != \"object\" || fmtDef instanceof RegExp || typeof fmtDef.compare != \"function\") {\n        throw new Error(\"\\\"\".concat(keyword, \"\\\": format \\\"\").concat(format, \"\\\" does not define \\\"compare\\\" function\"));\n      }\n      const fmt = gen.scopeValue(\"formats\", {\n        key: format,\n        ref: fmtDef,\n        code: opts.code.formats ? (0, codegen_1._)(_templateObject7 || (_templateObject7 = _taggedTemplateLiteral([\"\", \"\", \"\"])), opts.code.formats, (0, codegen_1.getProperty)(format)) : undefined\n      });\n      cxt.fail$data(compareCode(fmt));\n    }\n    function compareCode(fmt) {\n      return (0, codegen_1._)(_templateObject8 || (_templateObject8 = _taggedTemplateLiteral([\"\", \".compare(\", \", \", \") \", \" 0\"])), fmt, data, schemaCode, KWDs[keyword].fail);\n    }\n  },\n  dependencies: [\"format\"]\n};\nconst formatLimitPlugin = ajv => {\n  ajv.addKeyword(exports.formatLimitDefinition);\n  return ajv;\n};\nexports.default = formatLimitPlugin;","map":{"version":3,"names":["ajv_1","require","codegen_1","ops","operators","KWDs","formatMaximum","okStr","ok","LTE","fail","GT","formatMinimum","GTE","LT","formatExclusiveMaximum","formatExclusiveMinimum","error","message","_ref","keyword","schemaCode","str","_templateObject","_taggedTemplateLiteral","params","_ref2","_","_templateObject2","exports","formatLimitDefinition","Object","keys","type","schemaType","$data","code","cxt","gen","data","it","opts","self","validateFormats","fCxt","KeywordCxt","RULES","all","format","definition","validate$DataFormat","validateFormat","fmts","scopeValue","ref","formats","fmt","const","_templateObject3","fail$data","or","_templateObject4","_templateObject5","_templateObject6","compareCode","schema","fmtDef","RegExp","compare","Error","concat","key","_templateObject7","getProperty","undefined","_templateObject8","dependencies","formatLimitPlugin","ajv","addKeyword","default"],"sources":["/home/runner/work/sgex/sgex/node_modules/ajv-formats/src/limit.ts"],"sourcesContent":["import type Ajv from \"ajv\"\nimport type {\n  Plugin,\n  CodeKeywordDefinition,\n  KeywordErrorDefinition,\n  Code,\n  Name,\n  ErrorObject,\n} from \"ajv\"\nimport type {AddedFormat} from \"ajv/dist/types\"\nimport type {Rule} from \"ajv/dist/compile/rules\"\nimport {KeywordCxt} from \"ajv\"\nimport {_, str, or, getProperty, operators} from \"ajv/dist/compile/codegen\"\n\ntype Kwd = \"formatMaximum\" | \"formatMinimum\" | \"formatExclusiveMaximum\" | \"formatExclusiveMinimum\"\n\ntype Comparison = \"<=\" | \">=\" | \"<\" | \">\"\n\nconst ops = operators\n\nconst KWDs: {[K in Kwd]: {okStr: Comparison; ok: Code; fail: Code}} = {\n  formatMaximum: {okStr: \"<=\", ok: ops.LTE, fail: ops.GT},\n  formatMinimum: {okStr: \">=\", ok: ops.GTE, fail: ops.LT},\n  formatExclusiveMaximum: {okStr: \"<\", ok: ops.LT, fail: ops.GTE},\n  formatExclusiveMinimum: {okStr: \">\", ok: ops.GT, fail: ops.LTE},\n}\n\nexport type LimitFormatError = ErrorObject<Kwd, {limit: string; comparison: Comparison}>\n\nconst error: KeywordErrorDefinition = {\n  message: ({keyword, schemaCode}) => str`should be ${KWDs[keyword as Kwd].okStr} ${schemaCode}`,\n  params: ({keyword, schemaCode}) =>\n    _`{comparison: ${KWDs[keyword as Kwd].okStr}, limit: ${schemaCode}}`,\n}\n\nexport const formatLimitDefinition: CodeKeywordDefinition = {\n  keyword: Object.keys(KWDs),\n  type: \"string\",\n  schemaType: \"string\",\n  $data: true,\n  error,\n  code(cxt) {\n    const {gen, data, schemaCode, keyword, it} = cxt\n    const {opts, self} = it\n    if (!opts.validateFormats) return\n\n    const fCxt = new KeywordCxt(it, (self.RULES.all.format as Rule).definition, \"format\")\n    if (fCxt.$data) validate$DataFormat()\n    else validateFormat()\n\n    function validate$DataFormat(): void {\n      const fmts = gen.scopeValue(\"formats\", {\n        ref: self.formats,\n        code: opts.code.formats,\n      })\n      const fmt = gen.const(\"fmt\", _`${fmts}[${fCxt.schemaCode}]`)\n      cxt.fail$data(\n        or(\n          _`typeof ${fmt} != \"object\"`,\n          _`${fmt} instanceof RegExp`,\n          _`typeof ${fmt}.compare != \"function\"`,\n          compareCode(fmt)\n        )\n      )\n    }\n\n    function validateFormat(): void {\n      const format = fCxt.schema as string\n      const fmtDef: AddedFormat | undefined = self.formats[format]\n      if (!fmtDef || fmtDef === true) return\n      if (\n        typeof fmtDef != \"object\" ||\n        fmtDef instanceof RegExp ||\n        typeof fmtDef.compare != \"function\"\n      ) {\n        throw new Error(`\"${keyword}\": format \"${format}\" does not define \"compare\" function`)\n      }\n      const fmt = gen.scopeValue(\"formats\", {\n        key: format,\n        ref: fmtDef,\n        code: opts.code.formats ? _`${opts.code.formats}${getProperty(format)}` : undefined,\n      })\n\n      cxt.fail$data(compareCode(fmt))\n    }\n\n    function compareCode(fmt: Name): Code {\n      return _`${fmt}.compare(${data}, ${schemaCode}) ${KWDs[keyword as Kwd].fail} 0`\n    }\n  },\n  dependencies: [\"format\"],\n}\n\nconst formatLimitPlugin: Plugin<undefined> = (ajv: Ajv): Ajv => {\n  ajv.addKeyword(formatLimitDefinition)\n  return ajv\n}\n\nexport default formatLimitPlugin\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}