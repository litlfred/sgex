{"ast":null,"code":"import { filter, isNumber } from 'min-dash';\nvar max = Math.max,\n  min = Math.min;\nvar DEFAULT_CHILD_BOX_PADDING = 20;\nimport { getBBox } from '../../util/Elements';\nimport { asTRBL, asBounds } from '../../layout/LayoutUtil';\n\n/**\n * @typedef {import('../../core/Types').ElementLike} Element\n * @typedef {import('../../core/Types').ShapeLike} Shape\n *\n * @typedef {import('../../util/Types').Direction} Direction\n * @typedef {import('../../util/Types').Point} Point\n * @typedef {import('../../util/Types').Rect} Rect\n * @typedef {import('../../util/Types').RectTRBL} RectTRBL\n */\n\n/**\n * Substract a TRBL from another\n *\n * @param {RectTRBL} trblA\n * @param {RectTRBL} trblB\n *\n * @return {RectTRBL}\n */\nexport function substractTRBL(trblA, trblB) {\n  return {\n    top: trblA.top - trblB.top,\n    right: trblA.right - trblB.right,\n    bottom: trblA.bottom - trblB.bottom,\n    left: trblA.left - trblB.left\n  };\n}\n\n/**\n * Resize the given bounds by the specified delta from a given anchor point.\n *\n * @param {Rect} bounds the bounding box that should be resized\n * @param {Direction} direction in which the element is resized (nw, ne, se, sw)\n * @param {Point} delta of the resize operation\n *\n * @return {Rect} resized bounding box\n */\nexport function resizeBounds(bounds, direction, delta) {\n  var dx = delta.x,\n    dy = delta.y;\n  var newBounds = {\n    x: bounds.x,\n    y: bounds.y,\n    width: bounds.width,\n    height: bounds.height\n  };\n  if (direction.indexOf('n') !== -1) {\n    newBounds.y = bounds.y + dy;\n    newBounds.height = bounds.height - dy;\n  } else if (direction.indexOf('s') !== -1) {\n    newBounds.height = bounds.height + dy;\n  }\n  if (direction.indexOf('e') !== -1) {\n    newBounds.width = bounds.width + dx;\n  } else if (direction.indexOf('w') !== -1) {\n    newBounds.x = bounds.x + dx;\n    newBounds.width = bounds.width - dx;\n  }\n  return newBounds;\n}\n\n/**\n * Resize the given bounds by applying the passed\n * { top, right, bottom, left } delta.\n *\n * @param {Rect} bounds\n * @param {RectTRBL} resize\n *\n * @return {Rect}\n */\nexport function resizeTRBL(bounds, resize) {\n  return {\n    x: bounds.x + (resize.left || 0),\n    y: bounds.y + (resize.top || 0),\n    width: bounds.width - (resize.left || 0) + (resize.right || 0),\n    height: bounds.height - (resize.top || 0) + (resize.bottom || 0)\n  };\n}\nexport function reattachPoint(bounds, newBounds, point) {\n  var sx = bounds.width / newBounds.width,\n    sy = bounds.height / newBounds.height;\n  return {\n    x: Math.round(newBounds.x + newBounds.width / 2) - Math.floor((bounds.x + bounds.width / 2 - point.x) / sx),\n    y: Math.round(newBounds.y + newBounds.height / 2) - Math.floor((bounds.y + bounds.height / 2 - point.y) / sy)\n  };\n}\nfunction applyConstraints(attr, trbl, resizeConstraints) {\n  var value = trbl[attr],\n    minValue = resizeConstraints.min && resizeConstraints.min[attr],\n    maxValue = resizeConstraints.max && resizeConstraints.max[attr];\n  if (isNumber(minValue)) {\n    value = (/top|left/.test(attr) ? min : max)(value, minValue);\n  }\n  if (isNumber(maxValue)) {\n    value = (/top|left/.test(attr) ? max : min)(value, maxValue);\n  }\n  return value;\n}\nexport function ensureConstraints(currentBounds, resizeConstraints) {\n  if (!resizeConstraints) {\n    return currentBounds;\n  }\n  var currentTrbl = asTRBL(currentBounds);\n  return asBounds({\n    top: applyConstraints('top', currentTrbl, resizeConstraints),\n    right: applyConstraints('right', currentTrbl, resizeConstraints),\n    bottom: applyConstraints('bottom', currentTrbl, resizeConstraints),\n    left: applyConstraints('left', currentTrbl, resizeConstraints)\n  });\n}\nexport function getMinResizeBounds(direction, currentBounds, minDimensions, childrenBounds) {\n  var currentBox = asTRBL(currentBounds);\n  var minBox = {\n    top: /n/.test(direction) ? currentBox.bottom - minDimensions.height : currentBox.top,\n    left: /w/.test(direction) ? currentBox.right - minDimensions.width : currentBox.left,\n    bottom: /s/.test(direction) ? currentBox.top + minDimensions.height : currentBox.bottom,\n    right: /e/.test(direction) ? currentBox.left + minDimensions.width : currentBox.right\n  };\n  var childrenBox = childrenBounds ? asTRBL(childrenBounds) : minBox;\n  var combinedBox = {\n    top: min(minBox.top, childrenBox.top),\n    left: min(minBox.left, childrenBox.left),\n    bottom: max(minBox.bottom, childrenBox.bottom),\n    right: max(minBox.right, childrenBox.right)\n  };\n  return asBounds(combinedBox);\n}\nfunction asPadding(mayBePadding, defaultValue) {\n  if (typeof mayBePadding !== 'undefined') {\n    return mayBePadding;\n  } else {\n    return DEFAULT_CHILD_BOX_PADDING;\n  }\n}\nexport function addPadding(bbox, padding) {\n  var left, right, top, bottom;\n  if (typeof padding === 'object') {\n    left = asPadding(padding.left);\n    right = asPadding(padding.right);\n    top = asPadding(padding.top);\n    bottom = asPadding(padding.bottom);\n  } else {\n    left = right = top = bottom = asPadding(padding);\n  }\n  return {\n    x: bbox.x - left,\n    y: bbox.y - top,\n    width: bbox.width + left + right,\n    height: bbox.height + top + bottom\n  };\n}\n\n/**\n * Is the given element part of the resize\n * targets min boundary box?\n *\n * This is the default implementation which excludes\n * connections and labels.\n *\n * @param {Element} element\n */\nfunction isBBoxChild(element) {\n  // exclude connections\n  if (element.waypoints) {\n    return false;\n  }\n\n  // exclude labels\n  if (element.type === 'label') {\n    return false;\n  }\n  return true;\n}\n\n/**\n * Return children bounding computed from a shapes children\n * or a list of prefiltered children.\n *\n * @param {Shape|Shape[]} shapeOrChildren\n * @param {RectTRBL|number} padding\n *\n * @return {Rect}\n */\nexport function computeChildrenBBox(shapeOrChildren, padding) {\n  var elements;\n\n  // compute based on shape\n  if (shapeOrChildren.length === undefined) {\n    // grab all the children that are part of the\n    // parents children box\n    elements = filter(shapeOrChildren.children, isBBoxChild);\n  } else {\n    elements = shapeOrChildren;\n  }\n  if (elements.length) {\n    return addPadding(getBBox(elements), padding);\n  }\n}","map":{"version":3,"names":["filter","isNumber","max","Math","min","DEFAULT_CHILD_BOX_PADDING","getBBox","asTRBL","asBounds","substractTRBL","trblA","trblB","top","right","bottom","left","resizeBounds","bounds","direction","delta","dx","x","dy","y","newBounds","width","height","indexOf","resizeTRBL","resize","reattachPoint","point","sx","sy","round","floor","applyConstraints","attr","trbl","resizeConstraints","value","minValue","maxValue","test","ensureConstraints","currentBounds","currentTrbl","getMinResizeBounds","minDimensions","childrenBounds","currentBox","minBox","childrenBox","combinedBox","asPadding","mayBePadding","defaultValue","addPadding","bbox","padding","isBBoxChild","element","waypoints","type","computeChildrenBBox","shapeOrChildren","elements","length","undefined","children"],"sources":["/home/runner/work/sgex/sgex/node_modules/diagram-js/lib/features/resize/ResizeUtil.js"],"sourcesContent":["import {\n  filter,\n  isNumber\n} from 'min-dash';\n\nvar max = Math.max,\n    min = Math.min;\n\nvar DEFAULT_CHILD_BOX_PADDING = 20;\n\nimport {\n  getBBox\n} from '../../util/Elements';\n\nimport {\n  asTRBL,\n  asBounds\n} from '../../layout/LayoutUtil';\n\n/**\n * @typedef {import('../../core/Types').ElementLike} Element\n * @typedef {import('../../core/Types').ShapeLike} Shape\n *\n * @typedef {import('../../util/Types').Direction} Direction\n * @typedef {import('../../util/Types').Point} Point\n * @typedef {import('../../util/Types').Rect} Rect\n * @typedef {import('../../util/Types').RectTRBL} RectTRBL\n */\n\n/**\n * Substract a TRBL from another\n *\n * @param {RectTRBL} trblA\n * @param {RectTRBL} trblB\n *\n * @return {RectTRBL}\n */\nexport function substractTRBL(trblA, trblB) {\n  return {\n    top: trblA.top - trblB.top,\n    right: trblA.right - trblB.right,\n    bottom: trblA.bottom - trblB.bottom,\n    left: trblA.left - trblB.left\n  };\n}\n\n/**\n * Resize the given bounds by the specified delta from a given anchor point.\n *\n * @param {Rect} bounds the bounding box that should be resized\n * @param {Direction} direction in which the element is resized (nw, ne, se, sw)\n * @param {Point} delta of the resize operation\n *\n * @return {Rect} resized bounding box\n */\nexport function resizeBounds(bounds, direction, delta) {\n  var dx = delta.x,\n      dy = delta.y;\n\n  var newBounds = {\n    x: bounds.x,\n    y: bounds.y,\n    width: bounds.width,\n    height: bounds.height\n  };\n\n  if (direction.indexOf('n') !== -1) {\n    newBounds.y = bounds.y + dy;\n    newBounds.height = bounds.height - dy;\n  } else if (direction.indexOf('s') !== -1) {\n    newBounds.height = bounds.height + dy;\n  }\n\n  if (direction.indexOf('e') !== -1) {\n    newBounds.width = bounds.width + dx;\n  } else if (direction.indexOf('w') !== -1) {\n    newBounds.x = bounds.x + dx;\n    newBounds.width = bounds.width - dx;\n  }\n\n  return newBounds;\n}\n\n\n/**\n * Resize the given bounds by applying the passed\n * { top, right, bottom, left } delta.\n *\n * @param {Rect} bounds\n * @param {RectTRBL} resize\n *\n * @return {Rect}\n */\nexport function resizeTRBL(bounds, resize) {\n  return {\n    x: bounds.x + (resize.left || 0),\n    y: bounds.y + (resize.top || 0),\n    width: bounds.width - (resize.left || 0) + (resize.right || 0),\n    height: bounds.height - (resize.top || 0) + (resize.bottom || 0)\n  };\n}\n\n\nexport function reattachPoint(bounds, newBounds, point) {\n\n  var sx = bounds.width / newBounds.width,\n      sy = bounds.height / newBounds.height;\n\n  return {\n    x: Math.round((newBounds.x + newBounds.width / 2)) - Math.floor(((bounds.x + bounds.width / 2) - point.x) / sx),\n    y: Math.round((newBounds.y + newBounds.height / 2)) - Math.floor(((bounds.y + bounds.height / 2) - point.y) / sy)\n  };\n}\n\n\nfunction applyConstraints(attr, trbl, resizeConstraints) {\n\n  var value = trbl[attr],\n      minValue = resizeConstraints.min && resizeConstraints.min[attr],\n      maxValue = resizeConstraints.max && resizeConstraints.max[attr];\n\n  if (isNumber(minValue)) {\n    value = (/top|left/.test(attr) ? min : max)(value, minValue);\n  }\n\n  if (isNumber(maxValue)) {\n    value = (/top|left/.test(attr) ? max : min)(value, maxValue);\n  }\n\n  return value;\n}\n\nexport function ensureConstraints(currentBounds, resizeConstraints) {\n\n  if (!resizeConstraints) {\n    return currentBounds;\n  }\n\n  var currentTrbl = asTRBL(currentBounds);\n\n  return asBounds({\n    top: applyConstraints('top', currentTrbl, resizeConstraints),\n    right: applyConstraints('right', currentTrbl, resizeConstraints),\n    bottom: applyConstraints('bottom', currentTrbl, resizeConstraints),\n    left: applyConstraints('left', currentTrbl, resizeConstraints)\n  });\n}\n\n\nexport function getMinResizeBounds(direction, currentBounds, minDimensions, childrenBounds) {\n\n  var currentBox = asTRBL(currentBounds);\n\n  var minBox = {\n    top: /n/.test(direction) ? currentBox.bottom - minDimensions.height : currentBox.top,\n    left: /w/.test(direction) ? currentBox.right - minDimensions.width : currentBox.left,\n    bottom: /s/.test(direction) ? currentBox.top + minDimensions.height : currentBox.bottom,\n    right: /e/.test(direction) ? currentBox.left + minDimensions.width : currentBox.right\n  };\n\n  var childrenBox = childrenBounds ? asTRBL(childrenBounds) : minBox;\n\n  var combinedBox = {\n    top: min(minBox.top, childrenBox.top),\n    left: min(minBox.left, childrenBox.left),\n    bottom: max(minBox.bottom, childrenBox.bottom),\n    right: max(minBox.right, childrenBox.right)\n  };\n\n  return asBounds(combinedBox);\n}\n\nfunction asPadding(mayBePadding, defaultValue) {\n  if (typeof mayBePadding !== 'undefined') {\n    return mayBePadding;\n  } else {\n    return DEFAULT_CHILD_BOX_PADDING;\n  }\n}\n\nexport function addPadding(bbox, padding) {\n  var left, right, top, bottom;\n\n  if (typeof padding === 'object') {\n    left = asPadding(padding.left);\n    right = asPadding(padding.right);\n    top = asPadding(padding.top);\n    bottom = asPadding(padding.bottom);\n  } else {\n    left = right = top = bottom = asPadding(padding);\n  }\n\n  return {\n    x: bbox.x - left,\n    y: bbox.y - top,\n    width: bbox.width + left + right,\n    height: bbox.height + top + bottom\n  };\n}\n\n\n/**\n * Is the given element part of the resize\n * targets min boundary box?\n *\n * This is the default implementation which excludes\n * connections and labels.\n *\n * @param {Element} element\n */\nfunction isBBoxChild(element) {\n\n  // exclude connections\n  if (element.waypoints) {\n    return false;\n  }\n\n  // exclude labels\n  if (element.type === 'label') {\n    return false;\n  }\n\n  return true;\n}\n\n/**\n * Return children bounding computed from a shapes children\n * or a list of prefiltered children.\n *\n * @param {Shape|Shape[]} shapeOrChildren\n * @param {RectTRBL|number} padding\n *\n * @return {Rect}\n */\nexport function computeChildrenBBox(shapeOrChildren, padding) {\n\n  var elements;\n\n  // compute based on shape\n  if (shapeOrChildren.length === undefined) {\n\n    // grab all the children that are part of the\n    // parents children box\n    elements = filter(shapeOrChildren.children, isBBoxChild);\n\n  } else {\n    elements = shapeOrChildren;\n  }\n\n  if (elements.length) {\n    return addPadding(getBBox(elements), padding);\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}