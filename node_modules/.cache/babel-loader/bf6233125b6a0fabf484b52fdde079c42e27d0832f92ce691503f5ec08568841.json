{"ast":null,"code":"import { bind, debounce, forEach, isNumber, isObject } from 'min-dash';\nimport { isSnapped, setSnapped } from './SnapUtil';\nimport { append as svgAppend, attr as svgAttr, classes as svgClasses, create as svgCreate } from 'tiny-svg';\n\n/**\n * @typedef {import('../../core/Canvas').default} Canvas\n *\n * @typedef {import('../../core/EventBus').Event} Event\n *\n * @typedef {import('./SnapContext').SnapPoints} SnapPoints\n */\n\nvar SNAP_TOLERANCE = 7;\nexport var SNAP_LINE_HIDE_DELAY = 1000;\n\n/**\n * Generic snapping feature.\n *\n * @param {Canvas} canvas\n */\nexport default function Snapping(canvas) {\n  this._canvas = canvas;\n\n  // delay hide by 1000 seconds since last snap\n  this._asyncHide = debounce(bind(this.hide, this), SNAP_LINE_HIDE_DELAY);\n}\nSnapping.$inject = ['canvas'];\n\n/**\n * Snap an event to given snap points.\n *\n * @param {Event} event\n * @param {SnapPoints} snapPoints\n */\nSnapping.prototype.snap = function (event, snapPoints) {\n  var context = event.context,\n    snapContext = context.snapContext,\n    snapLocations = snapContext.getSnapLocations();\n  var snapping = {\n    x: isSnapped(event, 'x'),\n    y: isSnapped(event, 'y')\n  };\n  forEach(snapLocations, function (location) {\n    var snapOrigin = snapContext.getSnapOrigin(location);\n    var snapCurrent = {\n      x: event.x + snapOrigin.x,\n      y: event.y + snapOrigin.y\n    };\n\n    // snap both axis if not snapped already\n    forEach(['x', 'y'], function (axis) {\n      var locationSnapping;\n      if (!snapping[axis]) {\n        locationSnapping = snapPoints.snap(snapCurrent, location, axis, SNAP_TOLERANCE);\n        if (locationSnapping !== undefined) {\n          snapping[axis] = {\n            value: locationSnapping,\n            originValue: locationSnapping - snapOrigin[axis]\n          };\n        }\n      }\n    });\n\n    // no need to continue snapping\n    if (snapping.x && snapping.y) {\n      return false;\n    }\n  });\n\n  // show snap lines\n  this.showSnapLine('vertical', snapping.x && snapping.x.value);\n  this.showSnapLine('horizontal', snapping.y && snapping.y.value);\n\n  // snap event\n  forEach(['x', 'y'], function (axis) {\n    var axisSnapping = snapping[axis];\n    if (isObject(axisSnapping)) {\n      setSnapped(event, axis, axisSnapping.originValue);\n    }\n  });\n};\nSnapping.prototype._createLine = function (orientation) {\n  var root = this._canvas.getLayer('snap');\n  var line = svgCreate('path');\n  svgAttr(line, {\n    d: 'M0,0 L0,0'\n  });\n  svgClasses(line).add('djs-snap-line');\n  svgAppend(root, line);\n  return {\n    update: function (position) {\n      if (!isNumber(position)) {\n        svgAttr(line, {\n          display: 'none'\n        });\n      } else {\n        if (orientation === 'horizontal') {\n          svgAttr(line, {\n            d: 'M-100000,' + position + ' L+100000,' + position,\n            display: ''\n          });\n        } else {\n          svgAttr(line, {\n            d: 'M ' + position + ',-100000 L ' + position + ', +100000',\n            display: ''\n          });\n        }\n      }\n    }\n  };\n};\nSnapping.prototype._createSnapLines = function () {\n  this._snapLines = {\n    horizontal: this._createLine('horizontal'),\n    vertical: this._createLine('vertical')\n  };\n};\nSnapping.prototype.showSnapLine = function (orientation, position) {\n  var line = this.getSnapLine(orientation);\n  if (line) {\n    line.update(position);\n  }\n  this._asyncHide();\n};\nSnapping.prototype.getSnapLine = function (orientation) {\n  if (!this._snapLines) {\n    this._createSnapLines();\n  }\n  return this._snapLines[orientation];\n};\nSnapping.prototype.hide = function () {\n  forEach(this._snapLines, function (snapLine) {\n    snapLine.update();\n  });\n};","map":{"version":3,"names":["bind","debounce","forEach","isNumber","isObject","isSnapped","setSnapped","append","svgAppend","attr","svgAttr","classes","svgClasses","create","svgCreate","SNAP_TOLERANCE","SNAP_LINE_HIDE_DELAY","Snapping","canvas","_canvas","_asyncHide","hide","$inject","prototype","snap","event","snapPoints","context","snapContext","snapLocations","getSnapLocations","snapping","x","y","location","snapOrigin","getSnapOrigin","snapCurrent","axis","locationSnapping","undefined","value","originValue","showSnapLine","axisSnapping","_createLine","orientation","root","getLayer","line","d","add","update","position","display","_createSnapLines","_snapLines","horizontal","vertical","getSnapLine","snapLine"],"sources":["/home/runner/work/sgex/sgex/node_modules/diagram-js/lib/features/snapping/Snapping.js"],"sourcesContent":["import {\n  bind,\n  debounce,\n  forEach,\n  isNumber,\n  isObject\n} from 'min-dash';\n\nimport {\n  isSnapped,\n  setSnapped\n} from './SnapUtil';\n\nimport {\n  append as svgAppend,\n  attr as svgAttr,\n  classes as svgClasses,\n  create as svgCreate\n} from 'tiny-svg';\n\n/**\n * @typedef {import('../../core/Canvas').default} Canvas\n *\n * @typedef {import('../../core/EventBus').Event} Event\n *\n * @typedef {import('./SnapContext').SnapPoints} SnapPoints\n */\n\nvar SNAP_TOLERANCE = 7;\n\nexport var SNAP_LINE_HIDE_DELAY = 1000;\n\n\n/**\n * Generic snapping feature.\n *\n * @param {Canvas} canvas\n */\nexport default function Snapping(canvas) {\n  this._canvas = canvas;\n\n  // delay hide by 1000 seconds since last snap\n  this._asyncHide = debounce(bind(this.hide, this), SNAP_LINE_HIDE_DELAY);\n}\n\nSnapping.$inject = [ 'canvas' ];\n\n/**\n * Snap an event to given snap points.\n *\n * @param {Event} event\n * @param {SnapPoints} snapPoints\n */\nSnapping.prototype.snap = function(event, snapPoints) {\n  var context = event.context,\n      snapContext = context.snapContext,\n      snapLocations = snapContext.getSnapLocations();\n\n  var snapping = {\n    x: isSnapped(event, 'x'),\n    y: isSnapped(event, 'y')\n  };\n\n  forEach(snapLocations, function(location) {\n    var snapOrigin = snapContext.getSnapOrigin(location);\n\n    var snapCurrent = {\n      x: event.x + snapOrigin.x,\n      y: event.y + snapOrigin.y\n    };\n\n    // snap both axis if not snapped already\n    forEach([ 'x', 'y' ], function(axis) {\n      var locationSnapping;\n\n      if (!snapping[axis]) {\n        locationSnapping = snapPoints.snap(snapCurrent, location, axis, SNAP_TOLERANCE);\n\n        if (locationSnapping !== undefined) {\n          snapping[axis] = {\n            value: locationSnapping,\n            originValue: locationSnapping - snapOrigin[axis]\n          };\n        }\n      }\n    });\n\n    // no need to continue snapping\n    if (snapping.x && snapping.y) {\n      return false;\n    }\n  });\n\n  // show snap lines\n  this.showSnapLine('vertical', snapping.x && snapping.x.value);\n  this.showSnapLine('horizontal', snapping.y && snapping.y.value);\n\n  // snap event\n  forEach([ 'x', 'y' ], function(axis) {\n    var axisSnapping = snapping[axis];\n\n    if (isObject(axisSnapping)) {\n      setSnapped(event, axis, axisSnapping.originValue);\n    }\n  });\n};\n\nSnapping.prototype._createLine = function(orientation) {\n  var root = this._canvas.getLayer('snap');\n\n  var line = svgCreate('path');\n\n  svgAttr(line, { d: 'M0,0 L0,0' });\n\n  svgClasses(line).add('djs-snap-line');\n\n  svgAppend(root, line);\n\n  return {\n    update: function(position) {\n\n      if (!isNumber(position)) {\n        svgAttr(line, { display: 'none' });\n      } else {\n        if (orientation === 'horizontal') {\n          svgAttr(line, {\n            d: 'M-100000,' + position + ' L+100000,' + position,\n            display: ''\n          });\n        } else {\n          svgAttr(line, {\n            d: 'M ' + position + ',-100000 L ' + position + ', +100000',\n            display: ''\n          });\n        }\n      }\n    }\n  };\n};\n\nSnapping.prototype._createSnapLines = function() {\n  this._snapLines = {\n    horizontal: this._createLine('horizontal'),\n    vertical: this._createLine('vertical')\n  };\n};\n\nSnapping.prototype.showSnapLine = function(orientation, position) {\n\n  var line = this.getSnapLine(orientation);\n\n  if (line) {\n    line.update(position);\n  }\n\n  this._asyncHide();\n};\n\nSnapping.prototype.getSnapLine = function(orientation) {\n  if (!this._snapLines) {\n    this._createSnapLines();\n  }\n\n  return this._snapLines[orientation];\n};\n\nSnapping.prototype.hide = function() {\n  forEach(this._snapLines, function(snapLine) {\n    snapLine.update();\n  });\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}