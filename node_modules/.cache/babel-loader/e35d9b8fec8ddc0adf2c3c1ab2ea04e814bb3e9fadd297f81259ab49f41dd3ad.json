{"ast":null,"code":"import { assign } from 'min-dash';\nimport { toPoint } from '../../util/Event';\n\n/**\n * @typedef {import('../../util/Types').Point} Point\n *\n * @typedef {import('../../core/EventBus').default} EventBus\n * @typedef {import('../../core/Canvas').default} Canvas\n */\n\n/**\n * Initiates canvas scrolling if current cursor point is close to a border.\n * Cancelled when current point moves back inside the scrolling borders\n * or cancelled manually.\n *\n * Default options :\n *   scrollThresholdIn: [ 20, 20, 20, 20 ],\n *   scrollThresholdOut: [ 0, 0, 0, 0 ],\n *   scrollRepeatTimeout: 15,\n *   scrollStep: 10\n *\n * Threshold order:\n *   [ left, top, right, bottom ]\n *\n * @param {Object} config\n * @param {EventBus} eventBus\n * @param {Canvas} canvas\n */\nexport default function AutoScroll(config, eventBus, canvas) {\n  this._canvas = canvas;\n  this._opts = assign({\n    scrollThresholdIn: [20, 20, 20, 20],\n    scrollThresholdOut: [0, 0, 0, 0],\n    scrollRepeatTimeout: 15,\n    scrollStep: 10\n  }, config);\n  var self = this;\n  eventBus.on('drag.move', function (e) {\n    var point = self._toBorderPoint(e);\n    self.startScroll(point);\n  });\n  eventBus.on(['drag.cleanup'], function () {\n    self.stopScroll();\n  });\n}\nAutoScroll.$inject = ['config.autoScroll', 'eventBus', 'canvas'];\n\n/**\n * Starts scrolling loop.\n * Point is given in global scale in canvas container box plane.\n *\n * @param {Point} point\n */\nAutoScroll.prototype.startScroll = function (point) {\n  var canvas = this._canvas;\n  var opts = this._opts;\n  var self = this;\n  var clientRect = canvas.getContainer().getBoundingClientRect();\n  var diff = [point.x, point.y, clientRect.width - point.x, clientRect.height - point.y];\n  this.stopScroll();\n  var dx = 0,\n    dy = 0;\n  for (var i = 0; i < 4; i++) {\n    if (between(diff[i], opts.scrollThresholdOut[i], opts.scrollThresholdIn[i])) {\n      if (i === 0) {\n        dx = opts.scrollStep;\n      } else if (i == 1) {\n        dy = opts.scrollStep;\n      } else if (i == 2) {\n        dx = -opts.scrollStep;\n      } else if (i == 3) {\n        dy = -opts.scrollStep;\n      }\n    }\n  }\n  if (dx !== 0 || dy !== 0) {\n    canvas.scroll({\n      dx: dx,\n      dy: dy\n    });\n    this._scrolling = setTimeout(function () {\n      self.startScroll(point);\n    }, opts.scrollRepeatTimeout);\n  }\n};\nfunction between(val, start, end) {\n  if (start < val && val < end) {\n    return true;\n  }\n  return false;\n}\n\n/**\n * Stops scrolling loop.\n */\nAutoScroll.prototype.stopScroll = function () {\n  clearTimeout(this._scrolling);\n};\n\n/**\n * Overrides defaults options.\n *\n * @param {Object} options\n */\nAutoScroll.prototype.setOptions = function (options) {\n  this._opts = assign({}, this._opts, options);\n};\n\n/**\n * Converts event to a point in canvas container plane in global scale.\n *\n * @param {Event} event\n * @return {Point}\n */\nAutoScroll.prototype._toBorderPoint = function (event) {\n  var clientRect = this._canvas._container.getBoundingClientRect();\n  var globalPosition = toPoint(event.originalEvent);\n  return {\n    x: globalPosition.x - clientRect.left,\n    y: globalPosition.y - clientRect.top\n  };\n};","map":{"version":3,"names":["assign","toPoint","AutoScroll","config","eventBus","canvas","_canvas","_opts","scrollThresholdIn","scrollThresholdOut","scrollRepeatTimeout","scrollStep","self","on","e","point","_toBorderPoint","startScroll","stopScroll","$inject","prototype","opts","clientRect","getContainer","getBoundingClientRect","diff","x","y","width","height","dx","dy","i","between","scroll","_scrolling","setTimeout","val","start","end","clearTimeout","setOptions","options","event","_container","globalPosition","originalEvent","left","top"],"sources":["/home/runner/work/sgex/sgex/node_modules/diagram-js/lib/features/auto-scroll/AutoScroll.js"],"sourcesContent":["import { assign } from 'min-dash';\n\nimport {\n  toPoint\n} from '../../util/Event';\n\n/**\n * @typedef {import('../../util/Types').Point} Point\n *\n * @typedef {import('../../core/EventBus').default} EventBus\n * @typedef {import('../../core/Canvas').default} Canvas\n */\n\n/**\n * Initiates canvas scrolling if current cursor point is close to a border.\n * Cancelled when current point moves back inside the scrolling borders\n * or cancelled manually.\n *\n * Default options :\n *   scrollThresholdIn: [ 20, 20, 20, 20 ],\n *   scrollThresholdOut: [ 0, 0, 0, 0 ],\n *   scrollRepeatTimeout: 15,\n *   scrollStep: 10\n *\n * Threshold order:\n *   [ left, top, right, bottom ]\n *\n * @param {Object} config\n * @param {EventBus} eventBus\n * @param {Canvas} canvas\n */\nexport default function AutoScroll(config, eventBus, canvas) {\n\n  this._canvas = canvas;\n\n  this._opts = assign({\n    scrollThresholdIn: [ 20, 20, 20, 20 ],\n    scrollThresholdOut: [ 0, 0, 0, 0 ],\n    scrollRepeatTimeout: 15,\n    scrollStep: 10\n  }, config);\n\n  var self = this;\n\n  eventBus.on('drag.move', function(e) {\n    var point = self._toBorderPoint(e);\n\n    self.startScroll(point);\n  });\n\n  eventBus.on([ 'drag.cleanup' ], function() {\n    self.stopScroll();\n  });\n}\n\nAutoScroll.$inject = [\n  'config.autoScroll',\n  'eventBus',\n  'canvas'\n];\n\n\n/**\n * Starts scrolling loop.\n * Point is given in global scale in canvas container box plane.\n *\n * @param {Point} point\n */\nAutoScroll.prototype.startScroll = function(point) {\n\n  var canvas = this._canvas;\n  var opts = this._opts;\n  var self = this;\n\n  var clientRect = canvas.getContainer().getBoundingClientRect();\n\n  var diff = [\n    point.x,\n    point.y,\n    clientRect.width - point.x,\n    clientRect.height - point.y\n  ];\n\n  this.stopScroll();\n\n  var dx = 0,\n      dy = 0;\n\n  for (var i = 0; i < 4; i++) {\n    if (between(diff[i], opts.scrollThresholdOut[i], opts.scrollThresholdIn[i])) {\n      if (i === 0) {\n        dx = opts.scrollStep;\n      } else if (i == 1) {\n        dy = opts.scrollStep;\n      } else if (i == 2) {\n        dx = -opts.scrollStep;\n      } else if (i == 3) {\n        dy = -opts.scrollStep;\n      }\n    }\n  }\n\n  if (dx !== 0 || dy !== 0) {\n    canvas.scroll({ dx: dx, dy: dy });\n\n    this._scrolling = setTimeout(function() {\n      self.startScroll(point);\n    }, opts.scrollRepeatTimeout);\n  }\n};\n\nfunction between(val, start, end) {\n  if (start < val && val < end) {\n    return true;\n  }\n\n  return false;\n}\n\n\n/**\n * Stops scrolling loop.\n */\nAutoScroll.prototype.stopScroll = function() {\n  clearTimeout(this._scrolling);\n};\n\n\n/**\n * Overrides defaults options.\n *\n * @param {Object} options\n */\nAutoScroll.prototype.setOptions = function(options) {\n  this._opts = assign({}, this._opts, options);\n};\n\n\n/**\n * Converts event to a point in canvas container plane in global scale.\n *\n * @param {Event} event\n * @return {Point}\n */\nAutoScroll.prototype._toBorderPoint = function(event) {\n  var clientRect = this._canvas._container.getBoundingClientRect();\n\n  var globalPosition = toPoint(event.originalEvent);\n\n  return {\n    x: globalPosition.x - clientRect.left,\n    y: globalPosition.y - clientRect.top\n  };\n};"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}