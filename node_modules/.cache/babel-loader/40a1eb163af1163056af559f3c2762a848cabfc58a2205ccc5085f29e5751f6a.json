{"ast":null,"code":"import { forEach } from 'min-dash';\nimport { event as domEvent, query as domQuery, queryAll as domQueryAll } from 'min-dom';\nimport { BENDPOINT_CLS, SEGMENT_DRAGGER_CLS, addBendpoint, addSegmentDragger, calculateSegmentMoveRegion, getConnectionIntersection } from './BendpointUtil';\nimport { escapeCSS } from '../../util/EscapeUtil';\nimport { pointsAligned, getMidPoint } from '../../util/Geometry';\nimport { isPrimaryButton } from '../../util/Mouse';\nimport { append as svgAppend, attr as svgAttr, classes as svgClasses, create as svgCreate, remove as svgRemove } from 'tiny-svg';\nimport { translate } from '../../util/SvgTransformUtil';\n\n/**\n * @typedef {import('../bendpoints/BendpointMove').default} BendpointMove\n * @typedef {import('../../core/Canvas').default} Canvas\n * @typedef {import('../bendpoints/ConnectionSegmentMove').default} ConnectionSegmentMove\n * @typedef {import('../../core/EventBus').default} EventBus\n * @typedef {import('../interaction-events/InteractionEvents').default} InteractionEvents\n */\n\n/**\n * A service that adds editable bendpoints to connections.\n *\n * @param {EventBus} eventBus\n * @param {Canvas} canvas\n * @param {InteractionEvents} interactionEvents\n * @param {BendpointMove} bendpointMove\n * @param {ConnectionSegmentMove} connectionSegmentMove\n */\nexport default function Bendpoints(eventBus, canvas, interactionEvents, bendpointMove, connectionSegmentMove) {\n  /**\n   * Returns true if intersection point is inside middle region of segment, adjusted by\n   * optional threshold\n   */\n  function isIntersectionMiddle(intersection, waypoints, treshold) {\n    var idx = intersection.index,\n      p = intersection.point,\n      p0,\n      p1,\n      mid,\n      aligned,\n      xDelta,\n      yDelta;\n    if (idx <= 0 || intersection.bendpoint) {\n      return false;\n    }\n    p0 = waypoints[idx - 1];\n    p1 = waypoints[idx];\n    mid = getMidPoint(p0, p1), aligned = pointsAligned(p0, p1);\n    xDelta = Math.abs(p.x - mid.x);\n    yDelta = Math.abs(p.y - mid.y);\n    return aligned && xDelta <= treshold && yDelta <= treshold;\n  }\n\n  /**\n   * Calculates the threshold from a connection's middle which fits the two-third-region\n   */\n  function calculateIntersectionThreshold(connection, intersection) {\n    var waypoints = connection.waypoints,\n      relevantSegment,\n      alignment,\n      segmentLength,\n      threshold;\n    if (intersection.index <= 0 || intersection.bendpoint) {\n      return null;\n    }\n\n    // segment relative to connection intersection\n    relevantSegment = {\n      start: waypoints[intersection.index - 1],\n      end: waypoints[intersection.index]\n    };\n    alignment = pointsAligned(relevantSegment.start, relevantSegment.end);\n    if (!alignment) {\n      return null;\n    }\n    if (alignment === 'h') {\n      segmentLength = relevantSegment.end.x - relevantSegment.start.x;\n    } else {\n      segmentLength = relevantSegment.end.y - relevantSegment.start.y;\n    }\n\n    // calculate threshold relative to 2/3 of segment length\n    threshold = calculateSegmentMoveRegion(segmentLength) / 2;\n    return threshold;\n  }\n  function activateBendpointMove(event, connection) {\n    var waypoints = connection.waypoints,\n      intersection = getConnectionIntersection(canvas, waypoints, event),\n      threshold;\n    if (!intersection) {\n      return;\n    }\n    threshold = calculateIntersectionThreshold(connection, intersection);\n    if (isIntersectionMiddle(intersection, waypoints, threshold)) {\n      connectionSegmentMove.start(event, connection, intersection.index);\n    } else {\n      bendpointMove.start(event, connection, intersection.index, !intersection.bendpoint);\n    }\n\n    // we've handled the event\n    return true;\n  }\n  function bindInteractionEvents(node, eventName, element) {\n    domEvent.bind(node, eventName, function (event) {\n      interactionEvents.triggerMouseEvent(eventName, event, element);\n      event.stopPropagation();\n    });\n  }\n  function getBendpointsContainer(element, create) {\n    var layer = canvas.getLayer('overlays'),\n      gfx = domQuery('.djs-bendpoints[data-element-id=\"' + escapeCSS(element.id) + '\"]', layer);\n    if (!gfx && create) {\n      gfx = svgCreate('g');\n      svgAttr(gfx, {\n        'data-element-id': element.id\n      });\n      svgClasses(gfx).add('djs-bendpoints');\n      svgAppend(layer, gfx);\n      bindInteractionEvents(gfx, 'mousedown', element);\n      bindInteractionEvents(gfx, 'click', element);\n      bindInteractionEvents(gfx, 'dblclick', element);\n    }\n    return gfx;\n  }\n  function getSegmentDragger(idx, parentGfx) {\n    return domQuery('.djs-segment-dragger[data-segment-idx=\"' + idx + '\"]', parentGfx);\n  }\n  function createBendpoints(gfx, connection) {\n    connection.waypoints.forEach(function (p, idx) {\n      var bendpoint = addBendpoint(gfx);\n      svgAppend(gfx, bendpoint);\n      translate(bendpoint, p.x, p.y);\n    });\n\n    // add floating bendpoint\n    addBendpoint(gfx, 'floating');\n  }\n  function createSegmentDraggers(gfx, connection) {\n    var waypoints = connection.waypoints;\n    var segmentStart, segmentEnd, segmentDraggerGfx;\n    for (var i = 1; i < waypoints.length; i++) {\n      segmentStart = waypoints[i - 1];\n      segmentEnd = waypoints[i];\n      if (pointsAligned(segmentStart, segmentEnd)) {\n        segmentDraggerGfx = addSegmentDragger(gfx, segmentStart, segmentEnd);\n        svgAttr(segmentDraggerGfx, {\n          'data-segment-idx': i\n        });\n        bindInteractionEvents(segmentDraggerGfx, 'mousemove', connection);\n      }\n    }\n  }\n  function clearBendpoints(gfx) {\n    forEach(domQueryAll('.' + BENDPOINT_CLS, gfx), function (node) {\n      svgRemove(node);\n    });\n  }\n  function clearSegmentDraggers(gfx) {\n    forEach(domQueryAll('.' + SEGMENT_DRAGGER_CLS, gfx), function (node) {\n      svgRemove(node);\n    });\n  }\n  function addHandles(connection) {\n    var gfx = getBendpointsContainer(connection);\n    if (!gfx) {\n      gfx = getBendpointsContainer(connection, true);\n      createBendpoints(gfx, connection);\n      createSegmentDraggers(gfx, connection);\n    }\n    return gfx;\n  }\n  function updateHandles(connection) {\n    var gfx = getBendpointsContainer(connection);\n    if (gfx) {\n      clearSegmentDraggers(gfx);\n      clearBendpoints(gfx);\n      createSegmentDraggers(gfx, connection);\n      createBendpoints(gfx, connection);\n    }\n  }\n  function updateFloatingBendpointPosition(parentGfx, intersection) {\n    var floating = domQuery('.floating', parentGfx),\n      point = intersection.point;\n    if (!floating) {\n      return;\n    }\n    translate(floating, point.x, point.y);\n  }\n  function updateSegmentDraggerPosition(parentGfx, intersection, waypoints) {\n    var draggerGfx = getSegmentDragger(intersection.index, parentGfx),\n      segmentStart = waypoints[intersection.index - 1],\n      segmentEnd = waypoints[intersection.index],\n      point = intersection.point,\n      mid = getMidPoint(segmentStart, segmentEnd),\n      alignment = pointsAligned(segmentStart, segmentEnd),\n      draggerVisual,\n      relativePosition;\n    if (!draggerGfx) {\n      return;\n    }\n    draggerVisual = getDraggerVisual(draggerGfx);\n    relativePosition = {\n      x: point.x - mid.x,\n      y: point.y - mid.y\n    };\n    if (alignment === 'v') {\n      // rotate position\n      relativePosition = {\n        x: relativePosition.y,\n        y: relativePosition.x\n      };\n    }\n    translate(draggerVisual, relativePosition.x, relativePosition.y);\n  }\n  eventBus.on('connection.changed', function (event) {\n    updateHandles(event.element);\n  });\n  eventBus.on('connection.remove', function (event) {\n    var gfx = getBendpointsContainer(event.element);\n    if (gfx) {\n      svgRemove(gfx);\n    }\n  });\n  eventBus.on('element.marker.update', function (event) {\n    var element = event.element,\n      bendpointsGfx;\n    if (!element.waypoints) {\n      return;\n    }\n    bendpointsGfx = addHandles(element);\n    if (event.add) {\n      svgClasses(bendpointsGfx).add(event.marker);\n    } else {\n      svgClasses(bendpointsGfx).remove(event.marker);\n    }\n  });\n  eventBus.on('element.mousemove', function (event) {\n    var element = event.element,\n      waypoints = element.waypoints,\n      bendpointsGfx,\n      intersection;\n    if (waypoints) {\n      bendpointsGfx = getBendpointsContainer(element, true);\n      intersection = getConnectionIntersection(canvas, waypoints, event.originalEvent);\n      if (!intersection) {\n        return;\n      }\n      updateFloatingBendpointPosition(bendpointsGfx, intersection);\n      if (!intersection.bendpoint) {\n        updateSegmentDraggerPosition(bendpointsGfx, intersection, waypoints);\n      }\n    }\n  });\n  eventBus.on('element.mousedown', function (event) {\n    if (!isPrimaryButton(event)) {\n      return;\n    }\n    var originalEvent = event.originalEvent,\n      element = event.element;\n    if (!element.waypoints) {\n      return;\n    }\n    return activateBendpointMove(originalEvent, element);\n  });\n  eventBus.on('selection.changed', function (event) {\n    var newSelection = event.newSelection,\n      primary = newSelection[0];\n    if (primary && primary.waypoints) {\n      addHandles(primary);\n    }\n  });\n  eventBus.on('element.hover', function (event) {\n    var element = event.element;\n    if (element.waypoints) {\n      addHandles(element);\n      interactionEvents.registerEvent(event.gfx, 'mousemove', 'element.mousemove');\n    }\n  });\n  eventBus.on('element.out', function (event) {\n    interactionEvents.unregisterEvent(event.gfx, 'mousemove', 'element.mousemove');\n  });\n\n  // update bendpoint container data attribute on element ID change\n  eventBus.on('element.updateId', function (context) {\n    var element = context.element,\n      newId = context.newId;\n    if (element.waypoints) {\n      var bendpointContainer = getBendpointsContainer(element);\n      if (bendpointContainer) {\n        svgAttr(bendpointContainer, {\n          'data-element-id': newId\n        });\n      }\n    }\n  });\n\n  // API\n\n  this.addHandles = addHandles;\n  this.updateHandles = updateHandles;\n  this.getBendpointsContainer = getBendpointsContainer;\n  this.getSegmentDragger = getSegmentDragger;\n}\nBendpoints.$inject = ['eventBus', 'canvas', 'interactionEvents', 'bendpointMove', 'connectionSegmentMove'];\n\n// helper /////////////\n\nfunction getDraggerVisual(draggerGfx) {\n  return domQuery('.djs-visual', draggerGfx);\n}","map":{"version":3,"names":["forEach","event","domEvent","query","domQuery","queryAll","domQueryAll","BENDPOINT_CLS","SEGMENT_DRAGGER_CLS","addBendpoint","addSegmentDragger","calculateSegmentMoveRegion","getConnectionIntersection","escapeCSS","pointsAligned","getMidPoint","isPrimaryButton","append","svgAppend","attr","svgAttr","classes","svgClasses","create","svgCreate","remove","svgRemove","translate","Bendpoints","eventBus","canvas","interactionEvents","bendpointMove","connectionSegmentMove","isIntersectionMiddle","intersection","waypoints","treshold","idx","index","p","point","p0","p1","mid","aligned","xDelta","yDelta","bendpoint","Math","abs","x","y","calculateIntersectionThreshold","connection","relevantSegment","alignment","segmentLength","threshold","start","end","activateBendpointMove","bindInteractionEvents","node","eventName","element","bind","triggerMouseEvent","stopPropagation","getBendpointsContainer","layer","getLayer","gfx","id","add","getSegmentDragger","parentGfx","createBendpoints","createSegmentDraggers","segmentStart","segmentEnd","segmentDraggerGfx","i","length","clearBendpoints","clearSegmentDraggers","addHandles","updateHandles","updateFloatingBendpointPosition","floating","updateSegmentDraggerPosition","draggerGfx","draggerVisual","relativePosition","getDraggerVisual","on","bendpointsGfx","marker","originalEvent","newSelection","primary","registerEvent","unregisterEvent","context","newId","bendpointContainer","$inject"],"sources":["/home/runner/work/sgex/sgex/node_modules/diagram-js/lib/features/bendpoints/Bendpoints.js"],"sourcesContent":["import { forEach } from 'min-dash';\n\nimport {\n  event as domEvent,\n  query as domQuery,\n  queryAll as domQueryAll\n} from 'min-dom';\n\nimport {\n  BENDPOINT_CLS,\n  SEGMENT_DRAGGER_CLS,\n  addBendpoint,\n  addSegmentDragger,\n  calculateSegmentMoveRegion,\n  getConnectionIntersection\n} from './BendpointUtil';\n\nimport {\n  escapeCSS\n} from '../../util/EscapeUtil';\n\nimport {\n  pointsAligned,\n  getMidPoint\n} from '../../util/Geometry';\n\nimport {\n  isPrimaryButton\n} from '../../util/Mouse';\n\nimport {\n  append as svgAppend,\n  attr as svgAttr,\n  classes as svgClasses,\n  create as svgCreate,\n  remove as svgRemove\n} from 'tiny-svg';\n\nimport {\n  translate\n} from '../../util/SvgTransformUtil';\n\n/**\n * @typedef {import('../bendpoints/BendpointMove').default} BendpointMove\n * @typedef {import('../../core/Canvas').default} Canvas\n * @typedef {import('../bendpoints/ConnectionSegmentMove').default} ConnectionSegmentMove\n * @typedef {import('../../core/EventBus').default} EventBus\n * @typedef {import('../interaction-events/InteractionEvents').default} InteractionEvents\n */\n\n/**\n * A service that adds editable bendpoints to connections.\n *\n * @param {EventBus} eventBus\n * @param {Canvas} canvas\n * @param {InteractionEvents} interactionEvents\n * @param {BendpointMove} bendpointMove\n * @param {ConnectionSegmentMove} connectionSegmentMove\n */\nexport default function Bendpoints(\n    eventBus, canvas, interactionEvents,\n    bendpointMove, connectionSegmentMove) {\n\n  /**\n   * Returns true if intersection point is inside middle region of segment, adjusted by\n   * optional threshold\n   */\n  function isIntersectionMiddle(intersection, waypoints, treshold) {\n    var idx = intersection.index,\n        p = intersection.point,\n        p0, p1, mid, aligned, xDelta, yDelta;\n\n    if (idx <= 0 || intersection.bendpoint) {\n      return false;\n    }\n\n    p0 = waypoints[idx - 1];\n    p1 = waypoints[idx];\n    mid = getMidPoint(p0, p1),\n    aligned = pointsAligned(p0, p1);\n    xDelta = Math.abs(p.x - mid.x);\n    yDelta = Math.abs(p.y - mid.y);\n\n    return aligned && xDelta <= treshold && yDelta <= treshold;\n  }\n\n  /**\n   * Calculates the threshold from a connection's middle which fits the two-third-region\n   */\n  function calculateIntersectionThreshold(connection, intersection) {\n    var waypoints = connection.waypoints,\n        relevantSegment, alignment, segmentLength, threshold;\n\n    if (intersection.index <= 0 || intersection.bendpoint) {\n      return null;\n    }\n\n    // segment relative to connection intersection\n    relevantSegment = {\n      start: waypoints[intersection.index - 1],\n      end: waypoints[intersection.index]\n    };\n\n    alignment = pointsAligned(relevantSegment.start, relevantSegment.end);\n\n    if (!alignment) {\n      return null;\n    }\n\n    if (alignment === 'h') {\n      segmentLength = relevantSegment.end.x - relevantSegment.start.x;\n    } else {\n      segmentLength = relevantSegment.end.y - relevantSegment.start.y;\n    }\n\n    // calculate threshold relative to 2/3 of segment length\n    threshold = calculateSegmentMoveRegion(segmentLength) / 2;\n\n    return threshold;\n  }\n\n  function activateBendpointMove(event, connection) {\n    var waypoints = connection.waypoints,\n        intersection = getConnectionIntersection(canvas, waypoints, event),\n        threshold;\n\n    if (!intersection) {\n      return;\n    }\n\n    threshold = calculateIntersectionThreshold(connection, intersection);\n\n    if (isIntersectionMiddle(intersection, waypoints, threshold)) {\n      connectionSegmentMove.start(event, connection, intersection.index);\n    } else {\n      bendpointMove.start(event, connection, intersection.index, !intersection.bendpoint);\n    }\n\n    // we've handled the event\n    return true;\n  }\n\n  function bindInteractionEvents(node, eventName, element) {\n\n    domEvent.bind(node, eventName, function(event) {\n      interactionEvents.triggerMouseEvent(eventName, event, element);\n      event.stopPropagation();\n    });\n  }\n\n  function getBendpointsContainer(element, create) {\n\n    var layer = canvas.getLayer('overlays'),\n        gfx = domQuery('.djs-bendpoints[data-element-id=\"' + escapeCSS(element.id) + '\"]', layer);\n\n    if (!gfx && create) {\n      gfx = svgCreate('g');\n      svgAttr(gfx, { 'data-element-id': element.id });\n      svgClasses(gfx).add('djs-bendpoints');\n\n      svgAppend(layer, gfx);\n\n      bindInteractionEvents(gfx, 'mousedown', element);\n      bindInteractionEvents(gfx, 'click', element);\n      bindInteractionEvents(gfx, 'dblclick', element);\n    }\n\n    return gfx;\n  }\n\n  function getSegmentDragger(idx, parentGfx) {\n    return domQuery(\n      '.djs-segment-dragger[data-segment-idx=\"' + idx + '\"]',\n      parentGfx\n    );\n  }\n\n  function createBendpoints(gfx, connection) {\n    connection.waypoints.forEach(function(p, idx) {\n      var bendpoint = addBendpoint(gfx);\n\n      svgAppend(gfx, bendpoint);\n\n      translate(bendpoint, p.x, p.y);\n    });\n\n    // add floating bendpoint\n    addBendpoint(gfx, 'floating');\n  }\n\n  function createSegmentDraggers(gfx, connection) {\n\n    var waypoints = connection.waypoints;\n\n    var segmentStart,\n        segmentEnd,\n        segmentDraggerGfx;\n\n    for (var i = 1; i < waypoints.length; i++) {\n\n      segmentStart = waypoints[i - 1];\n      segmentEnd = waypoints[i];\n\n      if (pointsAligned(segmentStart, segmentEnd)) {\n        segmentDraggerGfx = addSegmentDragger(gfx, segmentStart, segmentEnd);\n\n        svgAttr(segmentDraggerGfx, { 'data-segment-idx': i });\n\n        bindInteractionEvents(segmentDraggerGfx, 'mousemove', connection);\n      }\n    }\n  }\n\n  function clearBendpoints(gfx) {\n    forEach(domQueryAll('.' + BENDPOINT_CLS, gfx), function(node) {\n      svgRemove(node);\n    });\n  }\n\n  function clearSegmentDraggers(gfx) {\n    forEach(domQueryAll('.' + SEGMENT_DRAGGER_CLS, gfx), function(node) {\n      svgRemove(node);\n    });\n  }\n\n  function addHandles(connection) {\n\n    var gfx = getBendpointsContainer(connection);\n\n    if (!gfx) {\n      gfx = getBendpointsContainer(connection, true);\n\n      createBendpoints(gfx, connection);\n      createSegmentDraggers(gfx, connection);\n    }\n\n    return gfx;\n  }\n\n  function updateHandles(connection) {\n\n    var gfx = getBendpointsContainer(connection);\n\n    if (gfx) {\n      clearSegmentDraggers(gfx);\n      clearBendpoints(gfx);\n      createSegmentDraggers(gfx, connection);\n      createBendpoints(gfx, connection);\n    }\n  }\n\n  function updateFloatingBendpointPosition(parentGfx, intersection) {\n    var floating = domQuery('.floating', parentGfx),\n        point = intersection.point;\n\n    if (!floating) {\n      return;\n    }\n\n    translate(floating, point.x, point.y);\n\n  }\n\n  function updateSegmentDraggerPosition(parentGfx, intersection, waypoints) {\n\n    var draggerGfx = getSegmentDragger(intersection.index, parentGfx),\n        segmentStart = waypoints[intersection.index - 1],\n        segmentEnd = waypoints[intersection.index],\n        point = intersection.point,\n        mid = getMidPoint(segmentStart, segmentEnd),\n        alignment = pointsAligned(segmentStart, segmentEnd),\n        draggerVisual, relativePosition;\n\n    if (!draggerGfx) {\n      return;\n    }\n\n    draggerVisual = getDraggerVisual(draggerGfx);\n\n    relativePosition = {\n      x: point.x - mid.x,\n      y: point.y - mid.y\n    };\n\n    if (alignment === 'v') {\n\n      // rotate position\n      relativePosition = {\n        x: relativePosition.y,\n        y: relativePosition.x\n      };\n    }\n\n    translate(draggerVisual, relativePosition.x, relativePosition.y);\n  }\n\n  eventBus.on('connection.changed', function(event) {\n    updateHandles(event.element);\n  });\n\n  eventBus.on('connection.remove', function(event) {\n    var gfx = getBendpointsContainer(event.element);\n\n    if (gfx) {\n      svgRemove(gfx);\n    }\n  });\n\n  eventBus.on('element.marker.update', function(event) {\n\n    var element = event.element,\n        bendpointsGfx;\n\n    if (!element.waypoints) {\n      return;\n    }\n\n    bendpointsGfx = addHandles(element);\n\n    if (event.add) {\n      svgClasses(bendpointsGfx).add(event.marker);\n    } else {\n      svgClasses(bendpointsGfx).remove(event.marker);\n    }\n  });\n\n  eventBus.on('element.mousemove', function(event) {\n\n    var element = event.element,\n        waypoints = element.waypoints,\n        bendpointsGfx,\n        intersection;\n\n    if (waypoints) {\n      bendpointsGfx = getBendpointsContainer(element, true);\n\n      intersection = getConnectionIntersection(canvas, waypoints, event.originalEvent);\n\n      if (!intersection) {\n        return;\n      }\n\n      updateFloatingBendpointPosition(bendpointsGfx, intersection);\n\n      if (!intersection.bendpoint) {\n        updateSegmentDraggerPosition(bendpointsGfx, intersection, waypoints);\n      }\n\n    }\n  });\n\n  eventBus.on('element.mousedown', function(event) {\n\n    if (!isPrimaryButton(event)) {\n      return;\n    }\n\n    var originalEvent = event.originalEvent,\n        element = event.element;\n\n    if (!element.waypoints) {\n      return;\n    }\n\n    return activateBendpointMove(originalEvent, element);\n  });\n\n  eventBus.on('selection.changed', function(event) {\n    var newSelection = event.newSelection,\n        primary = newSelection[0];\n\n    if (primary && primary.waypoints) {\n      addHandles(primary);\n    }\n  });\n\n  eventBus.on('element.hover', function(event) {\n    var element = event.element;\n\n    if (element.waypoints) {\n      addHandles(element);\n      interactionEvents.registerEvent(event.gfx, 'mousemove', 'element.mousemove');\n    }\n  });\n\n  eventBus.on('element.out', function(event) {\n    interactionEvents.unregisterEvent(event.gfx, 'mousemove', 'element.mousemove');\n  });\n\n  // update bendpoint container data attribute on element ID change\n  eventBus.on('element.updateId', function(context) {\n    var element = context.element,\n        newId = context.newId;\n\n    if (element.waypoints) {\n      var bendpointContainer = getBendpointsContainer(element);\n\n      if (bendpointContainer) {\n        svgAttr(bendpointContainer, { 'data-element-id': newId });\n      }\n    }\n  });\n\n  // API\n\n  this.addHandles = addHandles;\n  this.updateHandles = updateHandles;\n  this.getBendpointsContainer = getBendpointsContainer;\n  this.getSegmentDragger = getSegmentDragger;\n}\n\nBendpoints.$inject = [\n  'eventBus',\n  'canvas',\n  'interactionEvents',\n  'bendpointMove',\n  'connectionSegmentMove'\n];\n\n\n\n// helper /////////////\n\nfunction getDraggerVisual(draggerGfx) {\n  return domQuery('.djs-visual', draggerGfx);\n}"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}