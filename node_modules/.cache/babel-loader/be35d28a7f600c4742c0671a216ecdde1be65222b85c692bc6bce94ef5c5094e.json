{"ast":null,"code":"\"use strict\";\n\nvar _taggedTemplateLiteral = require(\"/home/runner/work/sgex/sgex/node_modules/@babel/runtime/helpers/taggedTemplateLiteral.js\").default;\nvar _templateObject, _templateObject2, _templateObject3, _templateObject4, _templateObject5, _templateObject6, _templateObject7, _templateObject8, _templateObject9, _templateObject0, _templateObject1, _templateObject10, _templateObject11, _templateObject12, _templateObject13;\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.validateUnion = exports.validateArray = exports.usePattern = exports.callValidateCode = exports.schemaProperties = exports.allSchemaProperties = exports.noPropertyInData = exports.propertyInData = exports.isOwnProperty = exports.hasPropFunc = exports.reportMissingProp = exports.checkMissingProp = exports.checkReportMissingProp = void 0;\nconst codegen_1 = require(\"../compile/codegen\");\nconst util_1 = require(\"../compile/util\");\nconst names_1 = require(\"../compile/names\");\nconst util_2 = require(\"../compile/util\");\nfunction checkReportMissingProp(cxt, prop) {\n  const {\n    gen,\n    data,\n    it\n  } = cxt;\n  gen.if(noPropertyInData(gen, data, prop, it.opts.ownProperties), () => {\n    cxt.setParams({\n      missingProperty: (0, codegen_1._)(_templateObject || (_templateObject = _taggedTemplateLiteral([\"\", \"\"])), prop)\n    }, true);\n    cxt.error();\n  });\n}\nexports.checkReportMissingProp = checkReportMissingProp;\nfunction checkMissingProp(_ref, properties, missing) {\n  let {\n    gen,\n    data,\n    it: {\n      opts\n    }\n  } = _ref;\n  return (0, codegen_1.or)(...properties.map(prop => (0, codegen_1.and)(noPropertyInData(gen, data, prop, opts.ownProperties), (0, codegen_1._)(_templateObject2 || (_templateObject2 = _taggedTemplateLiteral([\"\", \" = \", \"\"])), missing, prop))));\n}\nexports.checkMissingProp = checkMissingProp;\nfunction reportMissingProp(cxt, missing) {\n  cxt.setParams({\n    missingProperty: missing\n  }, true);\n  cxt.error();\n}\nexports.reportMissingProp = reportMissingProp;\nfunction hasPropFunc(gen) {\n  return gen.scopeValue(\"func\", {\n    // eslint-disable-next-line @typescript-eslint/unbound-method\n    ref: Object.prototype.hasOwnProperty,\n    code: (0, codegen_1._)(_templateObject3 || (_templateObject3 = _taggedTemplateLiteral([\"Object.prototype.hasOwnProperty\"])))\n  });\n}\nexports.hasPropFunc = hasPropFunc;\nfunction isOwnProperty(gen, data, property) {\n  return (0, codegen_1._)(_templateObject4 || (_templateObject4 = _taggedTemplateLiteral([\"\", \".call(\", \", \", \")\"])), hasPropFunc(gen), data, property);\n}\nexports.isOwnProperty = isOwnProperty;\nfunction propertyInData(gen, data, property, ownProperties) {\n  const cond = (0, codegen_1._)(_templateObject5 || (_templateObject5 = _taggedTemplateLiteral([\"\", \"\", \" !== undefined\"])), data, (0, codegen_1.getProperty)(property));\n  return ownProperties ? (0, codegen_1._)(_templateObject6 || (_templateObject6 = _taggedTemplateLiteral([\"\", \" && \", \"\"])), cond, isOwnProperty(gen, data, property)) : cond;\n}\nexports.propertyInData = propertyInData;\nfunction noPropertyInData(gen, data, property, ownProperties) {\n  const cond = (0, codegen_1._)(_templateObject7 || (_templateObject7 = _taggedTemplateLiteral([\"\", \"\", \" === undefined\"])), data, (0, codegen_1.getProperty)(property));\n  return ownProperties ? (0, codegen_1.or)(cond, (0, codegen_1.not)(isOwnProperty(gen, data, property))) : cond;\n}\nexports.noPropertyInData = noPropertyInData;\nfunction allSchemaProperties(schemaMap) {\n  return schemaMap ? Object.keys(schemaMap).filter(p => p !== \"__proto__\") : [];\n}\nexports.allSchemaProperties = allSchemaProperties;\nfunction schemaProperties(it, schemaMap) {\n  return allSchemaProperties(schemaMap).filter(p => !(0, util_1.alwaysValidSchema)(it, schemaMap[p]));\n}\nexports.schemaProperties = schemaProperties;\nfunction callValidateCode(_ref2, func, context, passSchema) {\n  let {\n    schemaCode,\n    data,\n    it: {\n      gen,\n      topSchemaRef,\n      schemaPath,\n      errorPath\n    },\n    it\n  } = _ref2;\n  const dataAndSchema = passSchema ? (0, codegen_1._)(_templateObject8 || (_templateObject8 = _taggedTemplateLiteral([\"\", \", \", \", \", \"\", \"\"])), schemaCode, data, topSchemaRef, schemaPath) : data;\n  const valCxt = [[names_1.default.instancePath, (0, codegen_1.strConcat)(names_1.default.instancePath, errorPath)], [names_1.default.parentData, it.parentData], [names_1.default.parentDataProperty, it.parentDataProperty], [names_1.default.rootData, names_1.default.rootData]];\n  if (it.opts.dynamicRef) valCxt.push([names_1.default.dynamicAnchors, names_1.default.dynamicAnchors]);\n  const args = (0, codegen_1._)(_templateObject9 || (_templateObject9 = _taggedTemplateLiteral([\"\", \", \", \"\"])), dataAndSchema, gen.object(...valCxt));\n  return context !== codegen_1.nil ? (0, codegen_1._)(_templateObject0 || (_templateObject0 = _taggedTemplateLiteral([\"\", \".call(\", \", \", \")\"])), func, context, args) : (0, codegen_1._)(_templateObject1 || (_templateObject1 = _taggedTemplateLiteral([\"\", \"(\", \")\"])), func, args);\n}\nexports.callValidateCode = callValidateCode;\nconst newRegExp = (0, codegen_1._)(_templateObject10 || (_templateObject10 = _taggedTemplateLiteral([\"new RegExp\"])));\nfunction usePattern(_ref3, pattern) {\n  let {\n    gen,\n    it: {\n      opts\n    }\n  } = _ref3;\n  const u = opts.unicodeRegExp ? \"u\" : \"\";\n  const {\n    regExp\n  } = opts.code;\n  const rx = regExp(pattern, u);\n  return gen.scopeValue(\"pattern\", {\n    key: rx.toString(),\n    ref: rx,\n    code: (0, codegen_1._)(_templateObject11 || (_templateObject11 = _taggedTemplateLiteral([\"\", \"(\", \", \", \")\"])), regExp.code === \"new RegExp\" ? newRegExp : (0, util_2.useFunc)(gen, regExp), pattern, u)\n  });\n}\nexports.usePattern = usePattern;\nfunction validateArray(cxt) {\n  const {\n    gen,\n    data,\n    keyword,\n    it\n  } = cxt;\n  const valid = gen.name(\"valid\");\n  if (it.allErrors) {\n    const validArr = gen.let(\"valid\", true);\n    validateItems(() => gen.assign(validArr, false));\n    return validArr;\n  }\n  gen.var(valid, true);\n  validateItems(() => gen.break());\n  return valid;\n  function validateItems(notValid) {\n    const len = gen.const(\"len\", (0, codegen_1._)(_templateObject12 || (_templateObject12 = _taggedTemplateLiteral([\"\", \".length\"])), data));\n    gen.forRange(\"i\", 0, len, i => {\n      cxt.subschema({\n        keyword,\n        dataProp: i,\n        dataPropType: util_1.Type.Num\n      }, valid);\n      gen.if((0, codegen_1.not)(valid), notValid);\n    });\n  }\n}\nexports.validateArray = validateArray;\nfunction validateUnion(cxt) {\n  const {\n    gen,\n    schema,\n    keyword,\n    it\n  } = cxt;\n  /* istanbul ignore if */\n  if (!Array.isArray(schema)) throw new Error(\"ajv implementation error\");\n  const alwaysValid = schema.some(sch => (0, util_1.alwaysValidSchema)(it, sch));\n  if (alwaysValid && !it.opts.unevaluated) return;\n  const valid = gen.let(\"valid\", false);\n  const schValid = gen.name(\"_valid\");\n  gen.block(() => schema.forEach((_sch, i) => {\n    const schCxt = cxt.subschema({\n      keyword,\n      schemaProp: i,\n      compositeRule: true\n    }, schValid);\n    gen.assign(valid, (0, codegen_1._)(_templateObject13 || (_templateObject13 = _taggedTemplateLiteral([\"\", \" || \", \"\"])), valid, schValid));\n    const merged = cxt.mergeValidEvaluated(schCxt, schValid);\n    // can short-circuit if `unevaluatedProperties/Items` not supported (opts.unevaluated !== true)\n    // or if all properties and items were evaluated (it.props === true && it.items === true)\n    if (!merged) gen.if((0, codegen_1.not)(valid));\n  }));\n  cxt.result(valid, () => cxt.reset(), () => cxt.error(true));\n}\nexports.validateUnion = validateUnion;","map":{"version":3,"names":["codegen_1","require","util_1","names_1","util_2","checkReportMissingProp","cxt","prop","gen","data","it","if","noPropertyInData","opts","ownProperties","setParams","missingProperty","_","_templateObject","_taggedTemplateLiteral","error","exports","checkMissingProp","_ref","properties","missing","or","map","and","_templateObject2","reportMissingProp","hasPropFunc","scopeValue","ref","Object","prototype","hasOwnProperty","code","_templateObject3","isOwnProperty","property","_templateObject4","propertyInData","cond","_templateObject5","getProperty","_templateObject6","_templateObject7","not","allSchemaProperties","schemaMap","keys","filter","p","schemaProperties","alwaysValidSchema","callValidateCode","_ref2","func","context","passSchema","schemaCode","topSchemaRef","schemaPath","errorPath","dataAndSchema","_templateObject8","valCxt","default","instancePath","strConcat","parentData","parentDataProperty","rootData","dynamicRef","push","dynamicAnchors","args","_templateObject9","object","nil","_templateObject0","_templateObject1","newRegExp","_templateObject10","usePattern","_ref3","pattern","u","unicodeRegExp","regExp","rx","key","toString","_templateObject11","useFunc","validateArray","keyword","valid","name","allErrors","validArr","let","validateItems","assign","var","break","notValid","len","const","_templateObject12","forRange","i","subschema","dataProp","dataPropType","Type","Num","validateUnion","schema","Array","isArray","Error","alwaysValid","some","sch","unevaluated","schValid","block","forEach","_sch","schCxt","schemaProp","compositeRule","_templateObject13","merged","mergeValidEvaluated","result","reset"],"sources":["/home/runner/work/sgex/sgex/node_modules/ajv/lib/vocabularies/code.ts"],"sourcesContent":["import type {AnySchema, SchemaMap} from \"../types\"\nimport type {SchemaCxt} from \"../compile\"\nimport type {KeywordCxt} from \"../compile/validate\"\nimport {CodeGen, _, and, or, not, nil, strConcat, getProperty, Code, Name} from \"../compile/codegen\"\nimport {alwaysValidSchema, Type} from \"../compile/util\"\nimport N from \"../compile/names\"\nimport {useFunc} from \"../compile/util\"\nexport function checkReportMissingProp(cxt: KeywordCxt, prop: string): void {\n  const {gen, data, it} = cxt\n  gen.if(noPropertyInData(gen, data, prop, it.opts.ownProperties), () => {\n    cxt.setParams({missingProperty: _`${prop}`}, true)\n    cxt.error()\n  })\n}\n\nexport function checkMissingProp(\n  {gen, data, it: {opts}}: KeywordCxt,\n  properties: string[],\n  missing: Name\n): Code {\n  return or(\n    ...properties.map((prop) =>\n      and(noPropertyInData(gen, data, prop, opts.ownProperties), _`${missing} = ${prop}`)\n    )\n  )\n}\n\nexport function reportMissingProp(cxt: KeywordCxt, missing: Name): void {\n  cxt.setParams({missingProperty: missing}, true)\n  cxt.error()\n}\n\nexport function hasPropFunc(gen: CodeGen): Name {\n  return gen.scopeValue(\"func\", {\n    // eslint-disable-next-line @typescript-eslint/unbound-method\n    ref: Object.prototype.hasOwnProperty,\n    code: _`Object.prototype.hasOwnProperty`,\n  })\n}\n\nexport function isOwnProperty(gen: CodeGen, data: Name, property: Name | string): Code {\n  return _`${hasPropFunc(gen)}.call(${data}, ${property})`\n}\n\nexport function propertyInData(\n  gen: CodeGen,\n  data: Name,\n  property: Name | string,\n  ownProperties?: boolean\n): Code {\n  const cond = _`${data}${getProperty(property)} !== undefined`\n  return ownProperties ? _`${cond} && ${isOwnProperty(gen, data, property)}` : cond\n}\n\nexport function noPropertyInData(\n  gen: CodeGen,\n  data: Name,\n  property: Name | string,\n  ownProperties?: boolean\n): Code {\n  const cond = _`${data}${getProperty(property)} === undefined`\n  return ownProperties ? or(cond, not(isOwnProperty(gen, data, property))) : cond\n}\n\nexport function allSchemaProperties(schemaMap?: SchemaMap): string[] {\n  return schemaMap ? Object.keys(schemaMap).filter((p) => p !== \"__proto__\") : []\n}\n\nexport function schemaProperties(it: SchemaCxt, schemaMap: SchemaMap): string[] {\n  return allSchemaProperties(schemaMap).filter(\n    (p) => !alwaysValidSchema(it, schemaMap[p] as AnySchema)\n  )\n}\n\nexport function callValidateCode(\n  {schemaCode, data, it: {gen, topSchemaRef, schemaPath, errorPath}, it}: KeywordCxt,\n  func: Code,\n  context: Code,\n  passSchema?: boolean\n): Code {\n  const dataAndSchema = passSchema ? _`${schemaCode}, ${data}, ${topSchemaRef}${schemaPath}` : data\n  const valCxt: [Name, Code | number][] = [\n    [N.instancePath, strConcat(N.instancePath, errorPath)],\n    [N.parentData, it.parentData],\n    [N.parentDataProperty, it.parentDataProperty],\n    [N.rootData, N.rootData],\n  ]\n  if (it.opts.dynamicRef) valCxt.push([N.dynamicAnchors, N.dynamicAnchors])\n  const args = _`${dataAndSchema}, ${gen.object(...valCxt)}`\n  return context !== nil ? _`${func}.call(${context}, ${args})` : _`${func}(${args})`\n}\n\nconst newRegExp = _`new RegExp`\n\nexport function usePattern({gen, it: {opts}}: KeywordCxt, pattern: string): Name {\n  const u = opts.unicodeRegExp ? \"u\" : \"\"\n  const {regExp} = opts.code\n  const rx = regExp(pattern, u)\n\n  return gen.scopeValue(\"pattern\", {\n    key: rx.toString(),\n    ref: rx,\n    code: _`${regExp.code === \"new RegExp\" ? newRegExp : useFunc(gen, regExp)}(${pattern}, ${u})`,\n  })\n}\n\nexport function validateArray(cxt: KeywordCxt): Name {\n  const {gen, data, keyword, it} = cxt\n  const valid = gen.name(\"valid\")\n  if (it.allErrors) {\n    const validArr = gen.let(\"valid\", true)\n    validateItems(() => gen.assign(validArr, false))\n    return validArr\n  }\n  gen.var(valid, true)\n  validateItems(() => gen.break())\n  return valid\n\n  function validateItems(notValid: () => void): void {\n    const len = gen.const(\"len\", _`${data}.length`)\n    gen.forRange(\"i\", 0, len, (i) => {\n      cxt.subschema(\n        {\n          keyword,\n          dataProp: i,\n          dataPropType: Type.Num,\n        },\n        valid\n      )\n      gen.if(not(valid), notValid)\n    })\n  }\n}\n\nexport function validateUnion(cxt: KeywordCxt): void {\n  const {gen, schema, keyword, it} = cxt\n  /* istanbul ignore if */\n  if (!Array.isArray(schema)) throw new Error(\"ajv implementation error\")\n  const alwaysValid = schema.some((sch: AnySchema) => alwaysValidSchema(it, sch))\n  if (alwaysValid && !it.opts.unevaluated) return\n\n  const valid = gen.let(\"valid\", false)\n  const schValid = gen.name(\"_valid\")\n\n  gen.block(() =>\n    schema.forEach((_sch: AnySchema, i: number) => {\n      const schCxt = cxt.subschema(\n        {\n          keyword,\n          schemaProp: i,\n          compositeRule: true,\n        },\n        schValid\n      )\n      gen.assign(valid, _`${valid} || ${schValid}`)\n      const merged = cxt.mergeValidEvaluated(schCxt, schValid)\n      // can short-circuit if `unevaluatedProperties/Items` not supported (opts.unevaluated !== true)\n      // or if all properties and items were evaluated (it.props === true && it.items === true)\n      if (!merged) gen.if(not(valid))\n    })\n  )\n\n  cxt.result(\n    valid,\n    () => cxt.reset(),\n    () => cxt.error(true)\n  )\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}