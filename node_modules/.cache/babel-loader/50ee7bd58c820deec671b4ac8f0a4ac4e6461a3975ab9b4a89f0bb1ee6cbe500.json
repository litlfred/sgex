{"ast":null,"code":"const CLASS_PATTERN = /^class[ {]/;\n\n/**\n * @param {function} fn\n *\n * @return {boolean}\n */\nfunction isClass(fn) {\n  return CLASS_PATTERN.test(fn.toString());\n}\n\n/**\n * @param {any} obj\n *\n * @return {boolean}\n */\nfunction isArray(obj) {\n  return Array.isArray(obj);\n}\n\n/**\n * @param {any} obj\n * @param {string} prop\n *\n * @return {boolean}\n */\nfunction hasOwnProp(obj, prop) {\n  return Object.prototype.hasOwnProperty.call(obj, prop);\n}\n\n/**\n * @typedef {import('./index.js').InjectAnnotated } InjectAnnotated\n */\n\n/**\n * @template T\n *\n * @params {[...string[], T] | ...string[], T} args\n *\n * @return {T & InjectAnnotated}\n */\nfunction annotate() {\n  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n    args[_key] = arguments[_key];\n  }\n  if (args.length === 1 && isArray(args[0])) {\n    args = args[0];\n  }\n  args = [...args];\n  const fn = args.pop();\n  fn.$inject = args;\n  return fn;\n}\n\n// Current limitations:\n// - can't put into \"function arg\" comments\n// function /* (no parenthesis like this) */ (){}\n// function abc( /* xx (no parenthesis like this) */ a, b) {}\n//\n// Just put the comment before function or inside:\n// /* (((this is fine))) */ function(a, b) {}\n// function abc(a) { /* (((this is fine))) */}\n//\n// - can't reliably auto-annotate constructor; we'll match the\n// first constructor(...) pattern found which may be the one\n// of a nested class, too.\n\nconst CONSTRUCTOR_ARGS = /constructor\\s*[^(]*\\(\\s*([^)]*)\\)/m;\nconst FN_ARGS = /^(?:async\\s+)?(?:function\\s*[^(]*)?(?:\\(\\s*([^)]*)\\)|(\\w+))/m;\nconst FN_ARG = /\\/\\*([^*]*)\\*\\//m;\n\n/**\n * @param {unknown} fn\n *\n * @return {string[]}\n */\nfunction parseAnnotations(fn) {\n  if (typeof fn !== 'function') {\n    throw new Error(`Cannot annotate \"${fn}\". Expected a function!`);\n  }\n  const match = fn.toString().match(isClass(fn) ? CONSTRUCTOR_ARGS : FN_ARGS);\n\n  // may parse class without constructor\n  if (!match) {\n    return [];\n  }\n  const args = match[1] || match[2];\n  return args && args.split(',').map(arg => {\n    const argMatch = arg.match(FN_ARG);\n    return (argMatch && argMatch[1] || arg).trim();\n  }) || [];\n}\n\n/**\n * @typedef { import('./index.js').ModuleDeclaration } ModuleDeclaration\n * @typedef { import('./index.js').ModuleDefinition } ModuleDefinition\n * @typedef { import('./index.js').InjectorContext } InjectorContext\n *\n * @typedef { import('./index.js').TypedDeclaration<any, any> } TypedDeclaration\n */\n\n/**\n * Create a new injector with the given modules.\n *\n * @param {ModuleDefinition[]} modules\n * @param {InjectorContext} [_parent]\n */\nfunction Injector(modules, _parent) {\n  const parent = _parent || (/** @type InjectorContext */{\n    get: function (name, strict) {\n      currentlyResolving.push(name);\n      if (strict === false) {\n        return null;\n      } else {\n        throw error(`No provider for \"${name}\"!`);\n      }\n    }\n  });\n  const currentlyResolving = [];\n  const providers = this._providers = Object.create(parent._providers || null);\n  const instances = this._instances = Object.create(null);\n  const self = instances.injector = this;\n  const error = function (msg) {\n    const stack = currentlyResolving.join(' -> ');\n    currentlyResolving.length = 0;\n    return new Error(stack ? `${msg} (Resolving: ${stack})` : msg);\n  };\n\n  /**\n   * Return a named service.\n   *\n   * @param {string} name\n   * @param {boolean} [strict=true] if false, resolve missing services to null\n   *\n   * @return {any}\n   */\n  function get(name, strict) {\n    if (!providers[name] && name.includes('.')) {\n      const parts = name.split('.');\n      let pivot = get(/** @type { string } */parts.shift());\n      while (parts.length) {\n        pivot = pivot[(/** @type { string } */parts.shift())];\n      }\n      return pivot;\n    }\n    if (hasOwnProp(instances, name)) {\n      return instances[name];\n    }\n    if (hasOwnProp(providers, name)) {\n      if (currentlyResolving.indexOf(name) !== -1) {\n        currentlyResolving.push(name);\n        throw error('Cannot resolve circular dependency!');\n      }\n      currentlyResolving.push(name);\n      instances[name] = providers[name][0](providers[name][1]);\n      currentlyResolving.pop();\n      return instances[name];\n    }\n    return parent.get(name, strict);\n  }\n  function fnDef(fn, locals) {\n    if (typeof locals === 'undefined') {\n      locals = {};\n    }\n    if (typeof fn !== 'function') {\n      if (isArray(fn)) {\n        fn = annotate(fn.slice());\n      } else {\n        throw error(`Cannot invoke \"${fn}\". Expected a function!`);\n      }\n    }\n\n    /**\n     * @type {string[]}\n     */\n    const inject = fn.$inject || parseAnnotations(fn);\n    const dependencies = inject.map(dep => {\n      if (hasOwnProp(locals, dep)) {\n        return locals[dep];\n      } else {\n        return get(dep);\n      }\n    });\n    return {\n      fn: fn,\n      dependencies\n    };\n  }\n\n  /**\n   * Instantiate the given type, injecting dependencies.\n   *\n   * @template T\n   *\n   * @param { Function | [...string[], Function ]} type\n   *\n   * @return T\n   */\n  function instantiate(type) {\n    const {\n      fn,\n      dependencies\n    } = fnDef(type);\n\n    // instantiate var args constructor\n    const Constructor = Function.prototype.bind.call(fn, null, ...dependencies);\n    return new Constructor();\n  }\n\n  /**\n   * Invoke the given function, injecting dependencies. Return the result.\n   *\n   * @template T\n   *\n   * @param { Function | [...string[], Function ]} func\n   * @param { Object } [context]\n   * @param { Object } [locals]\n   *\n   * @return {T} invocation result\n   */\n  function invoke(func, context, locals) {\n    const {\n      fn,\n      dependencies\n    } = fnDef(func, locals);\n    return fn.apply(context, dependencies);\n  }\n\n  /**\n   * @param {Injector} childInjector\n   *\n   * @return {Function}\n   */\n  function createPrivateInjectorFactory(childInjector) {\n    return annotate(key => childInjector.get(key));\n  }\n\n  /**\n   * @param {ModuleDefinition[]} modules\n   * @param {string[]} [forceNewInstances]\n   *\n   * @return {Injector}\n   */\n  function createChild(modules, forceNewInstances) {\n    if (forceNewInstances && forceNewInstances.length) {\n      const fromParentModule = Object.create(null);\n      const matchedScopes = Object.create(null);\n      const privateInjectorsCache = [];\n      const privateChildInjectors = [];\n      const privateChildFactories = [];\n      let provider;\n      let cacheIdx;\n      let privateChildInjector;\n      let privateChildInjectorFactory;\n      for (let name in providers) {\n        provider = providers[name];\n        if (forceNewInstances.indexOf(name) !== -1) {\n          if (provider[2] === 'private') {\n            cacheIdx = privateInjectorsCache.indexOf(provider[3]);\n            if (cacheIdx === -1) {\n              privateChildInjector = provider[3].createChild([], forceNewInstances);\n              privateChildInjectorFactory = createPrivateInjectorFactory(privateChildInjector);\n              privateInjectorsCache.push(provider[3]);\n              privateChildInjectors.push(privateChildInjector);\n              privateChildFactories.push(privateChildInjectorFactory);\n              fromParentModule[name] = [privateChildInjectorFactory, name, 'private', privateChildInjector];\n            } else {\n              fromParentModule[name] = [privateChildFactories[cacheIdx], name, 'private', privateChildInjectors[cacheIdx]];\n            }\n          } else {\n            fromParentModule[name] = [provider[2], provider[1]];\n          }\n          matchedScopes[name] = true;\n        }\n        if ((provider[2] === 'factory' || provider[2] === 'type') && provider[1].$scope) {\n          /* jshint -W083 */\n          forceNewInstances.forEach(scope => {\n            if (provider[1].$scope.indexOf(scope) !== -1) {\n              fromParentModule[name] = [provider[2], provider[1]];\n              matchedScopes[scope] = true;\n            }\n          });\n        }\n      }\n      forceNewInstances.forEach(scope => {\n        if (!matchedScopes[scope]) {\n          throw new Error('No provider for \"' + scope + '\". Cannot use provider from the parent!');\n        }\n      });\n      modules.unshift(fromParentModule);\n    }\n    return new Injector(modules, self);\n  }\n  const factoryMap = {\n    factory: invoke,\n    type: instantiate,\n    value: function (value) {\n      return value;\n    }\n  };\n\n  /**\n   * @param {ModuleDefinition} moduleDefinition\n   * @param {Injector} injector\n   */\n  function createInitializer(moduleDefinition, injector) {\n    const initializers = moduleDefinition.__init__ || [];\n    return function () {\n      initializers.forEach(initializer => {\n        // eagerly resolve component (fn or string)\n        if (typeof initializer === 'string') {\n          injector.get(initializer);\n        } else {\n          injector.invoke(initializer);\n        }\n      });\n    };\n  }\n\n  /**\n   * @param {ModuleDefinition} moduleDefinition\n   */\n  function loadModule(moduleDefinition) {\n    const moduleExports = moduleDefinition.__exports__;\n\n    // private module\n    if (moduleExports) {\n      const nestedModules = moduleDefinition.__modules__;\n      const clonedModule = Object.keys(moduleDefinition).reduce((clonedModule, key) => {\n        if (key !== '__exports__' && key !== '__modules__' && key !== '__init__' && key !== '__depends__') {\n          clonedModule[key] = moduleDefinition[key];\n        }\n        return clonedModule;\n      }, Object.create(null));\n      const childModules = (nestedModules || []).concat(clonedModule);\n      const privateInjector = createChild(childModules);\n      const getFromPrivateInjector = annotate(function (key) {\n        return privateInjector.get(key);\n      });\n      moduleExports.forEach(function (key) {\n        providers[key] = [getFromPrivateInjector, key, 'private', privateInjector];\n      });\n\n      // ensure child injector initializes\n      const initializers = (moduleDefinition.__init__ || []).slice();\n      initializers.unshift(function () {\n        privateInjector.init();\n      });\n      moduleDefinition = Object.assign({}, moduleDefinition, {\n        __init__: initializers\n      });\n      return createInitializer(moduleDefinition, privateInjector);\n    }\n\n    // normal module\n    Object.keys(moduleDefinition).forEach(function (key) {\n      if (key === '__init__' || key === '__depends__') {\n        return;\n      }\n      const typeDeclaration = /** @type { TypedDeclaration } */\n      moduleDefinition[key];\n      if (typeDeclaration[2] === 'private') {\n        providers[key] = typeDeclaration;\n        return;\n      }\n      const type = typeDeclaration[0];\n      const value = typeDeclaration[1];\n      providers[key] = [factoryMap[type], arrayUnwrap(type, value), type];\n    });\n    return createInitializer(moduleDefinition, self);\n  }\n\n  /**\n   * @param {ModuleDefinition[]} moduleDefinitions\n   * @param {ModuleDefinition} moduleDefinition\n   *\n   * @return {ModuleDefinition[]}\n   */\n  function resolveDependencies(moduleDefinitions, moduleDefinition) {\n    if (moduleDefinitions.indexOf(moduleDefinition) !== -1) {\n      return moduleDefinitions;\n    }\n    moduleDefinitions = (moduleDefinition.__depends__ || []).reduce(resolveDependencies, moduleDefinitions);\n    if (moduleDefinitions.indexOf(moduleDefinition) !== -1) {\n      return moduleDefinitions;\n    }\n    return moduleDefinitions.concat(moduleDefinition);\n  }\n\n  /**\n   * @param {ModuleDefinition[]} moduleDefinitions\n   *\n   * @return { () => void } initializerFn\n   */\n  function bootstrap(moduleDefinitions) {\n    const initializers = moduleDefinitions.reduce(resolveDependencies, []).map(loadModule);\n    let initialized = false;\n    return function () {\n      if (initialized) {\n        return;\n      }\n      initialized = true;\n      initializers.forEach(initializer => initializer());\n    };\n  }\n\n  // public API\n  this.get = get;\n  this.invoke = invoke;\n  this.instantiate = instantiate;\n  this.createChild = createChild;\n\n  // setup\n  this.init = bootstrap(modules);\n}\n\n// helpers ///////////////\n\nfunction arrayUnwrap(type, value) {\n  if (type !== 'value' && isArray(value)) {\n    value = annotate(value.slice());\n  }\n  return value;\n}\nexport { Injector, annotate, parseAnnotations };","map":{"version":3,"names":["CLASS_PATTERN","isClass","fn","test","toString","isArray","obj","Array","hasOwnProp","prop","Object","prototype","hasOwnProperty","call","annotate","_len","arguments","length","args","_key","pop","$inject","CONSTRUCTOR_ARGS","FN_ARGS","FN_ARG","parseAnnotations","Error","match","split","map","arg","argMatch","trim","Injector","modules","_parent","parent","get","name","strict","currentlyResolving","push","error","providers","_providers","create","instances","_instances","self","injector","msg","stack","join","includes","parts","pivot","shift","indexOf","fnDef","locals","slice","inject","dependencies","dep","instantiate","type","Constructor","Function","bind","invoke","func","context","apply","createPrivateInjectorFactory","childInjector","key","createChild","forceNewInstances","fromParentModule","matchedScopes","privateInjectorsCache","privateChildInjectors","privateChildFactories","provider","cacheIdx","privateChildInjector","privateChildInjectorFactory","$scope","forEach","scope","unshift","factoryMap","factory","value","createInitializer","moduleDefinition","initializers","__init__","initializer","loadModule","moduleExports","__exports__","nestedModules","__modules__","clonedModule","keys","reduce","childModules","concat","privateInjector","getFromPrivateInjector","init","assign","typeDeclaration","arrayUnwrap","resolveDependencies","moduleDefinitions","__depends__","bootstrap","initialized"],"sources":["/home/runner/work/sgex/sgex/node_modules/didi/lib/util.js","/home/runner/work/sgex/sgex/node_modules/didi/lib/annotation.js","/home/runner/work/sgex/sgex/node_modules/didi/lib/injector.js"],"sourcesContent":["const CLASS_PATTERN = /^class[ {]/;\n\n\n/**\n * @param {function} fn\n *\n * @return {boolean}\n */\nexport function isClass(fn) {\n  return CLASS_PATTERN.test(fn.toString());\n}\n\n/**\n * @param {any} obj\n *\n * @return {boolean}\n */\nexport function isArray(obj) {\n  return Array.isArray(obj);\n}\n\n/**\n * @param {any} obj\n * @param {string} prop\n *\n * @return {boolean}\n */\nexport function hasOwnProp(obj, prop) {\n  return Object.prototype.hasOwnProperty.call(obj, prop);\n}","import {\n  isArray,\n  isClass\n} from './util.js';\n\n/**\n * @typedef {import('./index.js').InjectAnnotated } InjectAnnotated\n */\n\n/**\n * @template T\n *\n * @params {[...string[], T] | ...string[], T} args\n *\n * @return {T & InjectAnnotated}\n */\nexport function annotate(...args) {\n\n  if (args.length === 1 && isArray(args[0])) {\n    args = args[0];\n  }\n\n  args = [ ...args ];\n\n  const fn = args.pop();\n\n  fn.$inject = args;\n\n  return fn;\n}\n\n\n// Current limitations:\n// - can't put into \"function arg\" comments\n// function /* (no parenthesis like this) */ (){}\n// function abc( /* xx (no parenthesis like this) */ a, b) {}\n//\n// Just put the comment before function or inside:\n// /* (((this is fine))) */ function(a, b) {}\n// function abc(a) { /* (((this is fine))) */}\n//\n// - can't reliably auto-annotate constructor; we'll match the\n// first constructor(...) pattern found which may be the one\n// of a nested class, too.\n\nconst CONSTRUCTOR_ARGS = /constructor\\s*[^(]*\\(\\s*([^)]*)\\)/m;\nconst FN_ARGS = /^(?:async\\s+)?(?:function\\s*[^(]*)?(?:\\(\\s*([^)]*)\\)|(\\w+))/m;\nconst FN_ARG = /\\/\\*([^*]*)\\*\\//m;\n\n/**\n * @param {unknown} fn\n *\n * @return {string[]}\n */\nexport function parseAnnotations(fn) {\n\n  if (typeof fn !== 'function') {\n    throw new Error(`Cannot annotate \"${fn}\". Expected a function!`);\n  }\n\n  const match = fn.toString().match(isClass(fn) ? CONSTRUCTOR_ARGS : FN_ARGS);\n\n  // may parse class without constructor\n  if (!match) {\n    return [];\n  }\n\n  const args = match[1] || match[2];\n\n  return args && args.split(',').map(arg => {\n    const argMatch = arg.match(FN_ARG);\n    return (argMatch && argMatch[1] || arg).trim();\n  }) || [];\n}","import {\n  parseAnnotations,\n  annotate\n} from './annotation.js';\n\nimport {\n  isArray,\n  hasOwnProp\n} from './util.js';\n\n/**\n * @typedef { import('./index.js').ModuleDeclaration } ModuleDeclaration\n * @typedef { import('./index.js').ModuleDefinition } ModuleDefinition\n * @typedef { import('./index.js').InjectorContext } InjectorContext\n *\n * @typedef { import('./index.js').TypedDeclaration<any, any> } TypedDeclaration\n */\n\n/**\n * Create a new injector with the given modules.\n *\n * @param {ModuleDefinition[]} modules\n * @param {InjectorContext} [_parent]\n */\nexport default function Injector(modules, _parent) {\n\n  const parent = _parent || /** @type InjectorContext */ ({\n    get: function(name, strict) {\n      currentlyResolving.push(name);\n\n      if (strict === false) {\n        return null;\n      } else {\n        throw error(`No provider for \"${ name }\"!`);\n      }\n    }\n  });\n\n  const currentlyResolving = [];\n  const providers = this._providers = Object.create(parent._providers || null);\n  const instances = this._instances = Object.create(null);\n\n  const self = instances.injector = this;\n\n  const error = function(msg) {\n    const stack = currentlyResolving.join(' -> ');\n    currentlyResolving.length = 0;\n    return new Error(stack ? `${ msg } (Resolving: ${ stack })` : msg);\n  };\n\n  /**\n   * Return a named service.\n   *\n   * @param {string} name\n   * @param {boolean} [strict=true] if false, resolve missing services to null\n   *\n   * @return {any}\n   */\n  function get(name, strict) {\n    if (!providers[name] && name.includes('.')) {\n\n      const parts = name.split('.');\n      let pivot = get(/** @type { string } */ (parts.shift()));\n\n      while (parts.length) {\n        pivot = pivot[/** @type { string } */ (parts.shift())];\n      }\n\n      return pivot;\n    }\n\n    if (hasOwnProp(instances, name)) {\n      return instances[name];\n    }\n\n    if (hasOwnProp(providers, name)) {\n      if (currentlyResolving.indexOf(name) !== -1) {\n        currentlyResolving.push(name);\n        throw error('Cannot resolve circular dependency!');\n      }\n\n      currentlyResolving.push(name);\n      instances[name] = providers[name][0](providers[name][1]);\n      currentlyResolving.pop();\n\n      return instances[name];\n    }\n\n    return parent.get(name, strict);\n  }\n\n  function fnDef(fn, locals) {\n\n    if (typeof locals === 'undefined') {\n      locals = {};\n    }\n\n    if (typeof fn !== 'function') {\n      if (isArray(fn)) {\n        fn = annotate(fn.slice());\n      } else {\n        throw error(`Cannot invoke \"${ fn }\". Expected a function!`);\n      }\n    }\n\n    /**\n     * @type {string[]}\n     */\n    const inject = fn.$inject || parseAnnotations(fn);\n    const dependencies = inject.map(dep => {\n      if (hasOwnProp(locals, dep)) {\n        return locals[dep];\n      } else {\n        return get(dep);\n      }\n    });\n\n    return {\n      fn: fn,\n      dependencies\n    };\n  }\n\n  /**\n   * Instantiate the given type, injecting dependencies.\n   *\n   * @template T\n   *\n   * @param { Function | [...string[], Function ]} type\n   *\n   * @return T\n   */\n  function instantiate(type) {\n    const {\n      fn,\n      dependencies\n    } = fnDef(type);\n\n    // instantiate var args constructor\n    const Constructor = Function.prototype.bind.call(fn, null, ...dependencies);\n\n    return new Constructor();\n  }\n\n  /**\n   * Invoke the given function, injecting dependencies. Return the result.\n   *\n   * @template T\n   *\n   * @param { Function | [...string[], Function ]} func\n   * @param { Object } [context]\n   * @param { Object } [locals]\n   *\n   * @return {T} invocation result\n   */\n  function invoke(func, context, locals) {\n    const {\n      fn,\n      dependencies\n    } = fnDef(func, locals);\n\n    return fn.apply(context, dependencies);\n  }\n\n  /**\n   * @param {Injector} childInjector\n   *\n   * @return {Function}\n   */\n  function createPrivateInjectorFactory(childInjector) {\n    return annotate(key => childInjector.get(key));\n  }\n\n  /**\n   * @param {ModuleDefinition[]} modules\n   * @param {string[]} [forceNewInstances]\n   *\n   * @return {Injector}\n   */\n  function createChild(modules, forceNewInstances) {\n    if (forceNewInstances && forceNewInstances.length) {\n      const fromParentModule = Object.create(null);\n      const matchedScopes = Object.create(null);\n\n      const privateInjectorsCache = [];\n      const privateChildInjectors = [];\n      const privateChildFactories = [];\n\n      let provider;\n      let cacheIdx;\n      let privateChildInjector;\n      let privateChildInjectorFactory;\n\n      for (let name in providers) {\n        provider = providers[name];\n\n        if (forceNewInstances.indexOf(name) !== -1) {\n          if (provider[2] === 'private') {\n            cacheIdx = privateInjectorsCache.indexOf(provider[3]);\n            if (cacheIdx === -1) {\n              privateChildInjector = provider[3].createChild([], forceNewInstances);\n              privateChildInjectorFactory = createPrivateInjectorFactory(privateChildInjector);\n              privateInjectorsCache.push(provider[3]);\n              privateChildInjectors.push(privateChildInjector);\n              privateChildFactories.push(privateChildInjectorFactory);\n              fromParentModule[name] = [ privateChildInjectorFactory, name, 'private', privateChildInjector ];\n            } else {\n              fromParentModule[name] = [ privateChildFactories[cacheIdx], name, 'private', privateChildInjectors[cacheIdx] ];\n            }\n          } else {\n            fromParentModule[name] = [ provider[2], provider[1] ];\n          }\n          matchedScopes[name] = true;\n        }\n\n        if ((provider[2] === 'factory' || provider[2] === 'type') && provider[1].$scope) {\n          /* jshint -W083 */\n          forceNewInstances.forEach(scope => {\n            if (provider[1].$scope.indexOf(scope) !== -1) {\n              fromParentModule[name] = [ provider[2], provider[1] ];\n              matchedScopes[scope] = true;\n            }\n          });\n        }\n      }\n\n      forceNewInstances.forEach(scope => {\n        if (!matchedScopes[scope]) {\n          throw new Error('No provider for \"' + scope + '\". Cannot use provider from the parent!');\n        }\n      });\n\n      modules.unshift(fromParentModule);\n    }\n\n    return new Injector(modules, self);\n  }\n\n  const factoryMap = {\n    factory: invoke,\n    type: instantiate,\n    value: function(value) {\n      return value;\n    }\n  };\n\n  /**\n   * @param {ModuleDefinition} moduleDefinition\n   * @param {Injector} injector\n   */\n  function createInitializer(moduleDefinition, injector) {\n\n    const initializers = moduleDefinition.__init__ || [];\n\n    return function() {\n      initializers.forEach(initializer => {\n\n        // eagerly resolve component (fn or string)\n        if (typeof initializer === 'string') {\n          injector.get(initializer);\n        } else {\n          injector.invoke(initializer);\n        }\n      });\n    };\n  }\n\n  /**\n   * @param {ModuleDefinition} moduleDefinition\n   */\n  function loadModule(moduleDefinition) {\n\n    const moduleExports = moduleDefinition.__exports__;\n\n    // private module\n    if (moduleExports) {\n      const nestedModules = moduleDefinition.__modules__;\n\n      const clonedModule = Object.keys(moduleDefinition).reduce((clonedModule, key) => {\n\n        if (key !== '__exports__' && key !== '__modules__' && key !== '__init__' && key !== '__depends__') {\n          clonedModule[key] = moduleDefinition[key];\n        }\n\n        return clonedModule;\n      }, Object.create(null));\n\n      const childModules = (nestedModules || []).concat(clonedModule);\n\n      const privateInjector = createChild(childModules);\n      const getFromPrivateInjector = annotate(function(key) {\n        return privateInjector.get(key);\n      });\n\n      moduleExports.forEach(function(key) {\n        providers[key] = [ getFromPrivateInjector, key, 'private', privateInjector ];\n      });\n\n      // ensure child injector initializes\n      const initializers = (moduleDefinition.__init__ || []).slice();\n\n      initializers.unshift(function() {\n        privateInjector.init();\n      });\n\n      moduleDefinition = Object.assign({}, moduleDefinition, {\n        __init__: initializers\n      });\n\n      return createInitializer(moduleDefinition, privateInjector);\n    }\n\n    // normal module\n    Object.keys(moduleDefinition).forEach(function(key) {\n\n      if (key === '__init__' || key === '__depends__') {\n        return;\n      }\n\n      const typeDeclaration = /** @type { TypedDeclaration } */ (\n        moduleDefinition[key]\n      );\n\n      if (typeDeclaration[2] === 'private') {\n        providers[key] = typeDeclaration;\n        return;\n      }\n\n      const type = typeDeclaration[0];\n      const value = typeDeclaration[1];\n\n      providers[key] = [ factoryMap[type], arrayUnwrap(type, value), type ];\n    });\n\n    return createInitializer(moduleDefinition, self);\n  }\n\n  /**\n   * @param {ModuleDefinition[]} moduleDefinitions\n   * @param {ModuleDefinition} moduleDefinition\n   *\n   * @return {ModuleDefinition[]}\n   */\n  function resolveDependencies(moduleDefinitions, moduleDefinition) {\n\n    if (moduleDefinitions.indexOf(moduleDefinition) !== -1) {\n      return moduleDefinitions;\n    }\n\n    moduleDefinitions = (moduleDefinition.__depends__ || []).reduce(resolveDependencies, moduleDefinitions);\n\n    if (moduleDefinitions.indexOf(moduleDefinition) !== -1) {\n      return moduleDefinitions;\n    }\n\n    return moduleDefinitions.concat(moduleDefinition);\n  }\n\n  /**\n   * @param {ModuleDefinition[]} moduleDefinitions\n   *\n   * @return { () => void } initializerFn\n   */\n  function bootstrap(moduleDefinitions) {\n\n    const initializers = moduleDefinitions\n      .reduce(resolveDependencies, [])\n      .map(loadModule);\n\n    let initialized = false;\n\n    return function() {\n\n      if (initialized) {\n        return;\n      }\n\n      initialized = true;\n\n      initializers.forEach(initializer => initializer());\n    };\n  }\n\n  // public API\n  this.get = get;\n  this.invoke = invoke;\n  this.instantiate = instantiate;\n  this.createChild = createChild;\n\n  // setup\n  this.init = bootstrap(modules);\n}\n\n\n// helpers ///////////////\n\nfunction arrayUnwrap(type, value) {\n  if (type !== 'value' && isArray(value)) {\n    value = annotate(value.slice());\n  }\n\n  return value;\n}"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}