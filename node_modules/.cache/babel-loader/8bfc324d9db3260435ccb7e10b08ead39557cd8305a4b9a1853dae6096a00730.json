{"ast":null,"code":"import _objectSpread from\"/home/runner/work/sgex/sgex/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";/**\n * Bookmark Service - Manages user bookmarks in localStorage\n * \n * Provides functionality to bookmark pages with context-aware titles:\n * - DAK: {user}/{repo} for DAK pages\n * - DAK: {user}/{repo}/{branch} for DAK pages with specific branch  \n * - {asset} in DAK: {user}/{repo}/{branch} for asset pages\n */class BookmarkService{constructor(){this.storageKey='sgex-bookmarks';}/**\n   * Get all bookmarks from localStorage\n   * @returns {Array} Array of bookmark objects\n   */getBookmarks(){try{const stored=localStorage.getItem(this.storageKey);return stored?JSON.parse(stored):[];}catch(error){console.warn('Error reading bookmarks from localStorage:',error);return[];}}/**\n   * Save bookmarks to localStorage\n   * @param {Array} bookmarks - Array of bookmark objects\n   */saveBookmarks(bookmarks){try{localStorage.setItem(this.storageKey,JSON.stringify(bookmarks));}catch(error){console.error('Error saving bookmarks to localStorage:',error);throw error;}}/**\n   * Generate bookmark title based on page context\n   * @param {string} pageName - Name of the page\n   * @param {Object} context - Page context (user, repo, branch, asset)\n   * @returns {string} Generated bookmark title\n   */generateBookmarkTitle(pageName,context){const{user,repository,branch,asset}=context;// Asset pages: {asset} in DAK: {user}/{repo}/{branch}\nif(asset&&user&&repository){const repoName=repository.name||repository;const branchName=branch||'main';return\"\".concat(asset,\" in DAK: \").concat(user,\"/\").concat(repoName,\"/\").concat(branchName);}// DAK pages with branch: DAK: {user}/{repo}/{branch}\nif(user&&repository&&branch){const repoName=repository.name||repository;return\"DAK: \".concat(user,\"/\").concat(repoName,\"/\").concat(branch);}// DAK pages without specific branch: DAK: {user}/{repo}\nif(user&&repository){const repoName=repository.name||repository;return\"DAK: \".concat(user,\"/\").concat(repoName);}// User pages: {pageName}: {user}\nif(user){return\"\".concat(pageName,\": \").concat(user);}// Top-level pages: just use page name\nreturn pageName;}/**\n   * Add a bookmark\n   * @param {string} pageName - Name of the page\n   * @param {string} url - URL of the page\n   * @param {Object} context - Page context for generating title\n   * @returns {Object} The created bookmark\n   */addBookmark(pageName,url){let context=arguments.length>2&&arguments[2]!==undefined?arguments[2]:{};const bookmarks=this.getBookmarks();// Check if bookmark already exists\nconst existingIndex=bookmarks.findIndex(b=>b.url===url);if(existingIndex!==-1){// Update existing bookmark\nbookmarks[existingIndex]=_objectSpread(_objectSpread({},bookmarks[existingIndex]),{},{title:this.generateBookmarkTitle(pageName,context),pageName,context,lastUpdated:new Date().toISOString()});}else{// Create new bookmark\nconst bookmark={id:Date.now().toString(),title:this.generateBookmarkTitle(pageName,context),url,pageName,context,createdAt:new Date().toISOString(),lastUpdated:new Date().toISOString()};bookmarks.push(bookmark);}this.saveBookmarks(bookmarks);return bookmarks[existingIndex]||bookmarks[bookmarks.length-1];}/**\n   * Remove a bookmark by ID\n   * @param {string} bookmarkId - ID of the bookmark to remove\n   * @returns {boolean} Success status\n   */removeBookmark(bookmarkId){try{const bookmarks=this.getBookmarks();const filteredBookmarks=bookmarks.filter(b=>b.id!==bookmarkId);if(filteredBookmarks.length!==bookmarks.length){this.saveBookmarks(filteredBookmarks);return true;}return false;}catch(error){console.error('Error removing bookmark:',error);return false;}}/**\n   * Check if current page is bookmarked\n   * @param {string} url - URL to check\n   * @returns {boolean} Whether the page is bookmarked\n   */isBookmarked(url){const bookmarks=this.getBookmarks();return bookmarks.some(b=>b.url===url);}/**\n   * Get bookmark for a specific URL\n   * @param {string} url - URL to find\n   * @returns {Object|null} Bookmark object or null if not found\n   */getBookmarkByUrl(url){const bookmarks=this.getBookmarks();return bookmarks.find(b=>b.url===url)||null;}/**\n   * Get bookmarks organized by page name (alphabetically)\n   * @returns {Object} Bookmarks grouped by page name\n   */getBookmarksGroupedByPage(){const bookmarks=this.getBookmarks();const grouped={};bookmarks.forEach(bookmark=>{const pageName=bookmark.pageName||'Other';if(!grouped[pageName]){grouped[pageName]=[];}grouped[pageName].push(bookmark);});// Sort each group by title\nObject.keys(grouped).forEach(pageName=>{grouped[pageName].sort((a,b)=>a.title.localeCompare(b.title));});// Return as sorted array of objects\nconst sortedPages=Object.keys(grouped).sort();return sortedPages.map(pageName=>({pageName,bookmarks:grouped[pageName]}));}/**\n   * Clear all bookmarks\n   */clearBookmarks(){try{localStorage.removeItem(this.storageKey);}catch(error){console.error('Error clearing bookmarks:',error);}}/**\n   * Export bookmarks as JSON\n   * @returns {string} JSON string of bookmarks\n   */exportBookmarks(){const bookmarks=this.getBookmarks();return JSON.stringify(bookmarks,null,2);}/**\n   * Import bookmarks from JSON\n   * @param {string} jsonString - JSON string of bookmarks\n   * @param {boolean} merge - Whether to merge with existing bookmarks\n   * @returns {boolean} Success status\n   */importBookmarks(jsonString){let merge=arguments.length>1&&arguments[1]!==undefined?arguments[1]:false;try{const importedBookmarks=JSON.parse(jsonString);if(!Array.isArray(importedBookmarks)){throw new Error('Invalid bookmark format');}if(merge){const existingBookmarks=this.getBookmarks();const mergedBookmarks=[...existingBookmarks];importedBookmarks.forEach(imported=>{const existingIndex=mergedBookmarks.findIndex(b=>b.url===imported.url);if(existingIndex!==-1){mergedBookmarks[existingIndex]=imported;}else{mergedBookmarks.push(imported);}});this.saveBookmarks(mergedBookmarks);}else{this.saveBookmarks(importedBookmarks);}return true;}catch(error){console.error('Error importing bookmarks:',error);return false;}}}// Create and export singleton instance\nconst bookmarkService=new BookmarkService();export default bookmarkService;","map":{"version":3,"names":["BookmarkService","constructor","storageKey","getBookmarks","stored","localStorage","getItem","JSON","parse","error","console","warn","saveBookmarks","bookmarks","setItem","stringify","generateBookmarkTitle","pageName","context","user","repository","branch","asset","repoName","name","branchName","concat","addBookmark","url","arguments","length","undefined","existingIndex","findIndex","b","_objectSpread","title","lastUpdated","Date","toISOString","bookmark","id","now","toString","createdAt","push","removeBookmark","bookmarkId","filteredBookmarks","filter","isBookmarked","some","getBookmarkByUrl","find","getBookmarksGroupedByPage","grouped","forEach","Object","keys","sort","a","localeCompare","sortedPages","map","clearBookmarks","removeItem","exportBookmarks","importBookmarks","jsonString","merge","importedBookmarks","Array","isArray","Error","existingBookmarks","mergedBookmarks","imported","bookmarkService"],"sources":["/home/runner/work/sgex/sgex/src/services/bookmarkService.js"],"sourcesContent":["/**\n * Bookmark Service - Manages user bookmarks in localStorage\n * \n * Provides functionality to bookmark pages with context-aware titles:\n * - DAK: {user}/{repo} for DAK pages\n * - DAK: {user}/{repo}/{branch} for DAK pages with specific branch  \n * - {asset} in DAK: {user}/{repo}/{branch} for asset pages\n */\nclass BookmarkService {\n  constructor() {\n    this.storageKey = 'sgex-bookmarks';\n  }\n\n  /**\n   * Get all bookmarks from localStorage\n   * @returns {Array} Array of bookmark objects\n   */\n  getBookmarks() {\n    try {\n      const stored = localStorage.getItem(this.storageKey);\n      return stored ? JSON.parse(stored) : [];\n    } catch (error) {\n      console.warn('Error reading bookmarks from localStorage:', error);\n      return [];\n    }\n  }\n\n  /**\n   * Save bookmarks to localStorage\n   * @param {Array} bookmarks - Array of bookmark objects\n   */\n  saveBookmarks(bookmarks) {\n    try {\n      localStorage.setItem(this.storageKey, JSON.stringify(bookmarks));\n    } catch (error) {\n      console.error('Error saving bookmarks to localStorage:', error);\n      throw error;\n    }\n  }\n\n  /**\n   * Generate bookmark title based on page context\n   * @param {string} pageName - Name of the page\n   * @param {Object} context - Page context (user, repo, branch, asset)\n   * @returns {string} Generated bookmark title\n   */\n  generateBookmarkTitle(pageName, context) {\n    const { user, repository, branch, asset } = context;\n\n    // Asset pages: {asset} in DAK: {user}/{repo}/{branch}\n    if (asset && user && repository) {\n      const repoName = repository.name || repository;\n      const branchName = branch || 'main';\n      return `${asset} in DAK: ${user}/${repoName}/${branchName}`;\n    }\n\n    // DAK pages with branch: DAK: {user}/{repo}/{branch}\n    if (user && repository && branch) {\n      const repoName = repository.name || repository;\n      return `DAK: ${user}/${repoName}/${branch}`;\n    }\n\n    // DAK pages without specific branch: DAK: {user}/{repo}\n    if (user && repository) {\n      const repoName = repository.name || repository;\n      return `DAK: ${user}/${repoName}`;\n    }\n\n    // User pages: {pageName}: {user}\n    if (user) {\n      return `${pageName}: ${user}`;\n    }\n\n    // Top-level pages: just use page name\n    return pageName;\n  }\n\n  /**\n   * Add a bookmark\n   * @param {string} pageName - Name of the page\n   * @param {string} url - URL of the page\n   * @param {Object} context - Page context for generating title\n   * @returns {Object} The created bookmark\n   */\n  addBookmark(pageName, url, context = {}) {\n    const bookmarks = this.getBookmarks();\n    \n    // Check if bookmark already exists\n    const existingIndex = bookmarks.findIndex(b => b.url === url);\n    if (existingIndex !== -1) {\n      // Update existing bookmark\n      bookmarks[existingIndex] = {\n        ...bookmarks[existingIndex],\n        title: this.generateBookmarkTitle(pageName, context),\n        pageName,\n        context,\n        lastUpdated: new Date().toISOString()\n      };\n    } else {\n      // Create new bookmark\n      const bookmark = {\n        id: Date.now().toString(),\n        title: this.generateBookmarkTitle(pageName, context),\n        url,\n        pageName,\n        context,\n        createdAt: new Date().toISOString(),\n        lastUpdated: new Date().toISOString()\n      };\n      bookmarks.push(bookmark);\n    }\n\n    this.saveBookmarks(bookmarks);\n    return bookmarks[existingIndex] || bookmarks[bookmarks.length - 1];\n  }\n\n  /**\n   * Remove a bookmark by ID\n   * @param {string} bookmarkId - ID of the bookmark to remove\n   * @returns {boolean} Success status\n   */\n  removeBookmark(bookmarkId) {\n    try {\n      const bookmarks = this.getBookmarks();\n      const filteredBookmarks = bookmarks.filter(b => b.id !== bookmarkId);\n      \n      if (filteredBookmarks.length !== bookmarks.length) {\n        this.saveBookmarks(filteredBookmarks);\n        return true;\n      }\n      return false;\n    } catch (error) {\n      console.error('Error removing bookmark:', error);\n      return false;\n    }\n  }\n\n  /**\n   * Check if current page is bookmarked\n   * @param {string} url - URL to check\n   * @returns {boolean} Whether the page is bookmarked\n   */\n  isBookmarked(url) {\n    const bookmarks = this.getBookmarks();\n    return bookmarks.some(b => b.url === url);\n  }\n\n  /**\n   * Get bookmark for a specific URL\n   * @param {string} url - URL to find\n   * @returns {Object|null} Bookmark object or null if not found\n   */\n  getBookmarkByUrl(url) {\n    const bookmarks = this.getBookmarks();\n    return bookmarks.find(b => b.url === url) || null;\n  }\n\n  /**\n   * Get bookmarks organized by page name (alphabetically)\n   * @returns {Object} Bookmarks grouped by page name\n   */\n  getBookmarksGroupedByPage() {\n    const bookmarks = this.getBookmarks();\n    const grouped = {};\n\n    bookmarks.forEach(bookmark => {\n      const pageName = bookmark.pageName || 'Other';\n      if (!grouped[pageName]) {\n        grouped[pageName] = [];\n      }\n      grouped[pageName].push(bookmark);\n    });\n\n    // Sort each group by title\n    Object.keys(grouped).forEach(pageName => {\n      grouped[pageName].sort((a, b) => a.title.localeCompare(b.title));\n    });\n\n    // Return as sorted array of objects\n    const sortedPages = Object.keys(grouped).sort();\n    return sortedPages.map(pageName => ({\n      pageName,\n      bookmarks: grouped[pageName]\n    }));\n  }\n\n  /**\n   * Clear all bookmarks\n   */\n  clearBookmarks() {\n    try {\n      localStorage.removeItem(this.storageKey);\n    } catch (error) {\n      console.error('Error clearing bookmarks:', error);\n    }\n  }\n\n  /**\n   * Export bookmarks as JSON\n   * @returns {string} JSON string of bookmarks\n   */\n  exportBookmarks() {\n    const bookmarks = this.getBookmarks();\n    return JSON.stringify(bookmarks, null, 2);\n  }\n\n  /**\n   * Import bookmarks from JSON\n   * @param {string} jsonString - JSON string of bookmarks\n   * @param {boolean} merge - Whether to merge with existing bookmarks\n   * @returns {boolean} Success status\n   */\n  importBookmarks(jsonString, merge = false) {\n    try {\n      const importedBookmarks = JSON.parse(jsonString);\n      \n      if (!Array.isArray(importedBookmarks)) {\n        throw new Error('Invalid bookmark format');\n      }\n\n      if (merge) {\n        const existingBookmarks = this.getBookmarks();\n        const mergedBookmarks = [...existingBookmarks];\n        \n        importedBookmarks.forEach(imported => {\n          const existingIndex = mergedBookmarks.findIndex(b => b.url === imported.url);\n          if (existingIndex !== -1) {\n            mergedBookmarks[existingIndex] = imported;\n          } else {\n            mergedBookmarks.push(imported);\n          }\n        });\n        \n        this.saveBookmarks(mergedBookmarks);\n      } else {\n        this.saveBookmarks(importedBookmarks);\n      }\n      \n      return true;\n    } catch (error) {\n      console.error('Error importing bookmarks:', error);\n      return false;\n    }\n  }\n}\n\n// Create and export singleton instance\nconst bookmarkService = new BookmarkService();\nexport default bookmarkService;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}