{"ast":null,"code":"\"use strict\";\n\nvar _taggedTemplateLiteral = require(\"/home/runner/work/sgex/sgex/node_modules/@babel/runtime/helpers/taggedTemplateLiteral.js\").default;\nvar _templateObject, _templateObject2, _templateObject3, _templateObject4, _templateObject5, _templateObject6, _templateObject7, _templateObject8, _templateObject9, _templateObject0, _templateObject1, _templateObject10, _templateObject11, _templateObject12, _templateObject13, _templateObject14, _templateObject15;\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nconst codegen_1 = require(\"../../compile/codegen\");\nconst error = {\n  message: _ref => {\n    let {\n      schemaCode\n    } = _ref;\n    return (0, codegen_1.str)(_templateObject || (_templateObject = _taggedTemplateLiteral([\"must match format \\\"\", \"\\\"\"])), schemaCode);\n  },\n  params: _ref2 => {\n    let {\n      schemaCode\n    } = _ref2;\n    return (0, codegen_1._)(_templateObject2 || (_templateObject2 = _taggedTemplateLiteral([\"{format: \", \"}\"])), schemaCode);\n  }\n};\nconst def = {\n  keyword: \"format\",\n  type: [\"number\", \"string\"],\n  schemaType: \"string\",\n  $data: true,\n  error,\n  code(cxt, ruleType) {\n    const {\n      gen,\n      data,\n      $data,\n      schema,\n      schemaCode,\n      it\n    } = cxt;\n    const {\n      opts,\n      errSchemaPath,\n      schemaEnv,\n      self\n    } = it;\n    if (!opts.validateFormats) return;\n    if ($data) validate$DataFormat();else validateFormat();\n    function validate$DataFormat() {\n      const fmts = gen.scopeValue(\"formats\", {\n        ref: self.formats,\n        code: opts.code.formats\n      });\n      const fDef = gen.const(\"fDef\", (0, codegen_1._)(_templateObject3 || (_templateObject3 = _taggedTemplateLiteral([\"\", \"[\", \"]\"])), fmts, schemaCode));\n      const fType = gen.let(\"fType\");\n      const format = gen.let(\"format\");\n      // TODO simplify\n      gen.if((0, codegen_1._)(_templateObject4 || (_templateObject4 = _taggedTemplateLiteral([\"typeof \", \" == \\\"object\\\" && !(\", \" instanceof RegExp)\"])), fDef, fDef), () => gen.assign(fType, (0, codegen_1._)(_templateObject5 || (_templateObject5 = _taggedTemplateLiteral([\"\", \".type || \\\"string\\\"\"])), fDef)).assign(format, (0, codegen_1._)(_templateObject6 || (_templateObject6 = _taggedTemplateLiteral([\"\", \".validate\"])), fDef)), () => gen.assign(fType, (0, codegen_1._)(_templateObject7 || (_templateObject7 = _taggedTemplateLiteral([\"\\\"string\\\"\"])))).assign(format, fDef));\n      cxt.fail$data((0, codegen_1.or)(unknownFmt(), invalidFmt()));\n      function unknownFmt() {\n        if (opts.strictSchema === false) return codegen_1.nil;\n        return (0, codegen_1._)(_templateObject8 || (_templateObject8 = _taggedTemplateLiteral([\"\", \" && !\", \"\"])), schemaCode, format);\n      }\n      function invalidFmt() {\n        const callFormat = schemaEnv.$async ? (0, codegen_1._)(_templateObject9 || (_templateObject9 = _taggedTemplateLiteral([\"(\", \".async ? await \", \"(\", \") : \", \"(\", \"))\"])), fDef, format, data, format, data) : (0, codegen_1._)(_templateObject0 || (_templateObject0 = _taggedTemplateLiteral([\"\", \"(\", \")\"])), format, data);\n        const validData = (0, codegen_1._)(_templateObject1 || (_templateObject1 = _taggedTemplateLiteral([\"(typeof \", \" == \\\"function\\\" ? \", \" : \", \".test(\", \"))\"])), format, callFormat, format, data);\n        return (0, codegen_1._)(_templateObject10 || (_templateObject10 = _taggedTemplateLiteral([\"\", \" && \", \" !== true && \", \" === \", \" && !\", \"\"])), format, format, fType, ruleType, validData);\n      }\n    }\n    function validateFormat() {\n      const formatDef = self.formats[schema];\n      if (!formatDef) {\n        unknownFormat();\n        return;\n      }\n      if (formatDef === true) return;\n      const [fmtType, format, fmtRef] = getFormat(formatDef);\n      if (fmtType === ruleType) cxt.pass(validCondition());\n      function unknownFormat() {\n        if (opts.strictSchema === false) {\n          self.logger.warn(unknownMsg());\n          return;\n        }\n        throw new Error(unknownMsg());\n        function unknownMsg() {\n          return \"unknown format \\\"\".concat(schema, \"\\\" ignored in schema at path \\\"\").concat(errSchemaPath, \"\\\"\");\n        }\n      }\n      function getFormat(fmtDef) {\n        const code = fmtDef instanceof RegExp ? (0, codegen_1.regexpCode)(fmtDef) : opts.code.formats ? (0, codegen_1._)(_templateObject11 || (_templateObject11 = _taggedTemplateLiteral([\"\", \"\", \"\"])), opts.code.formats, (0, codegen_1.getProperty)(schema)) : undefined;\n        const fmt = gen.scopeValue(\"formats\", {\n          key: schema,\n          ref: fmtDef,\n          code\n        });\n        if (typeof fmtDef == \"object\" && !(fmtDef instanceof RegExp)) {\n          return [fmtDef.type || \"string\", fmtDef.validate, (0, codegen_1._)(_templateObject12 || (_templateObject12 = _taggedTemplateLiteral([\"\", \".validate\"])), fmt)];\n        }\n        return [\"string\", fmtDef, fmt];\n      }\n      function validCondition() {\n        if (typeof formatDef == \"object\" && !(formatDef instanceof RegExp) && formatDef.async) {\n          if (!schemaEnv.$async) throw new Error(\"async format in sync schema\");\n          return (0, codegen_1._)(_templateObject13 || (_templateObject13 = _taggedTemplateLiteral([\"await \", \"(\", \")\"])), fmtRef, data);\n        }\n        return typeof format == \"function\" ? (0, codegen_1._)(_templateObject14 || (_templateObject14 = _taggedTemplateLiteral([\"\", \"(\", \")\"])), fmtRef, data) : (0, codegen_1._)(_templateObject15 || (_templateObject15 = _taggedTemplateLiteral([\"\", \".test(\", \")\"])), fmtRef, data);\n      }\n    }\n  }\n};\nexports.default = def;","map":{"version":3,"names":["codegen_1","require","error","message","_ref","schemaCode","str","_templateObject","_taggedTemplateLiteral","params","_ref2","_","_templateObject2","def","keyword","type","schemaType","$data","code","cxt","ruleType","gen","data","schema","it","opts","errSchemaPath","schemaEnv","self","validateFormats","validate$DataFormat","validateFormat","fmts","scopeValue","ref","formats","fDef","const","_templateObject3","fType","let","format","if","_templateObject4","assign","_templateObject5","_templateObject6","_templateObject7","fail$data","or","unknownFmt","invalidFmt","strictSchema","nil","_templateObject8","callFormat","$async","_templateObject9","_templateObject0","validData","_templateObject1","_templateObject10","formatDef","unknownFormat","fmtType","fmtRef","getFormat","pass","validCondition","logger","warn","unknownMsg","Error","concat","fmtDef","RegExp","regexpCode","_templateObject11","getProperty","undefined","fmt","key","validate","_templateObject12","async","_templateObject13","_templateObject14","_templateObject15","exports","default"],"sources":["/home/runner/work/sgex/sgex/node_modules/ajv/lib/vocabularies/format/format.ts"],"sourcesContent":["import type {\n  AddedFormat,\n  FormatValidator,\n  AsyncFormatValidator,\n  CodeKeywordDefinition,\n  KeywordErrorDefinition,\n  ErrorObject,\n} from \"../../types\"\nimport type {KeywordCxt} from \"../../compile/validate\"\nimport {_, str, nil, or, Code, getProperty, regexpCode} from \"../../compile/codegen\"\n\ntype FormatValidate =\n  | FormatValidator<string>\n  | FormatValidator<number>\n  | AsyncFormatValidator<string>\n  | AsyncFormatValidator<number>\n  | RegExp\n  | string\n  | true\n\nexport type FormatError = ErrorObject<\"format\", {format: string}, string | {$data: string}>\n\nconst error: KeywordErrorDefinition = {\n  message: ({schemaCode}) => str`must match format \"${schemaCode}\"`,\n  params: ({schemaCode}) => _`{format: ${schemaCode}}`,\n}\n\nconst def: CodeKeywordDefinition = {\n  keyword: \"format\",\n  type: [\"number\", \"string\"],\n  schemaType: \"string\",\n  $data: true,\n  error,\n  code(cxt: KeywordCxt, ruleType?: string) {\n    const {gen, data, $data, schema, schemaCode, it} = cxt\n    const {opts, errSchemaPath, schemaEnv, self} = it\n    if (!opts.validateFormats) return\n\n    if ($data) validate$DataFormat()\n    else validateFormat()\n\n    function validate$DataFormat(): void {\n      const fmts = gen.scopeValue(\"formats\", {\n        ref: self.formats,\n        code: opts.code.formats,\n      })\n      const fDef = gen.const(\"fDef\", _`${fmts}[${schemaCode}]`)\n      const fType = gen.let(\"fType\")\n      const format = gen.let(\"format\")\n      // TODO simplify\n      gen.if(\n        _`typeof ${fDef} == \"object\" && !(${fDef} instanceof RegExp)`,\n        () => gen.assign(fType, _`${fDef}.type || \"string\"`).assign(format, _`${fDef}.validate`),\n        () => gen.assign(fType, _`\"string\"`).assign(format, fDef)\n      )\n      cxt.fail$data(or(unknownFmt(), invalidFmt()))\n\n      function unknownFmt(): Code {\n        if (opts.strictSchema === false) return nil\n        return _`${schemaCode} && !${format}`\n      }\n\n      function invalidFmt(): Code {\n        const callFormat = schemaEnv.$async\n          ? _`(${fDef}.async ? await ${format}(${data}) : ${format}(${data}))`\n          : _`${format}(${data})`\n        const validData = _`(typeof ${format} == \"function\" ? ${callFormat} : ${format}.test(${data}))`\n        return _`${format} && ${format} !== true && ${fType} === ${ruleType} && !${validData}`\n      }\n    }\n\n    function validateFormat(): void {\n      const formatDef: AddedFormat | undefined = self.formats[schema]\n      if (!formatDef) {\n        unknownFormat()\n        return\n      }\n      if (formatDef === true) return\n      const [fmtType, format, fmtRef] = getFormat(formatDef)\n      if (fmtType === ruleType) cxt.pass(validCondition())\n\n      function unknownFormat(): void {\n        if (opts.strictSchema === false) {\n          self.logger.warn(unknownMsg())\n          return\n        }\n        throw new Error(unknownMsg())\n\n        function unknownMsg(): string {\n          return `unknown format \"${schema as string}\" ignored in schema at path \"${errSchemaPath}\"`\n        }\n      }\n\n      function getFormat(fmtDef: AddedFormat): [string, FormatValidate, Code] {\n        const code =\n          fmtDef instanceof RegExp\n            ? regexpCode(fmtDef)\n            : opts.code.formats\n            ? _`${opts.code.formats}${getProperty(schema)}`\n            : undefined\n        const fmt = gen.scopeValue(\"formats\", {key: schema, ref: fmtDef, code})\n        if (typeof fmtDef == \"object\" && !(fmtDef instanceof RegExp)) {\n          return [fmtDef.type || \"string\", fmtDef.validate, _`${fmt}.validate`]\n        }\n\n        return [\"string\", fmtDef, fmt]\n      }\n\n      function validCondition(): Code {\n        if (typeof formatDef == \"object\" && !(formatDef instanceof RegExp) && formatDef.async) {\n          if (!schemaEnv.$async) throw new Error(\"async format in sync schema\")\n          return _`await ${fmtRef}(${data})`\n        }\n        return typeof format == \"function\" ? _`${fmtRef}(${data})` : _`${fmtRef}.test(${data})`\n      }\n    }\n  },\n}\n\nexport default def\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}