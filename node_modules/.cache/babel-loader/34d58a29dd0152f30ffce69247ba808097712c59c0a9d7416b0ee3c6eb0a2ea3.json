{"ast":null,"code":"import { pointsAligned, pointsOnLine } from '../../util/Geometry';\nimport { addSegmentDragger, getConnectionIntersection } from './BendpointUtil';\nimport { getMid, getOrientation } from '../../layout/LayoutUtil';\nvar MARKER_CONNECT_HOVER = 'connect-hover',\n  MARKER_CONNECT_UPDATING = 'djs-updating';\nimport { classes as svgClasses, remove as svgRemove } from 'tiny-svg';\nimport { translate } from '../../util/SvgTransformUtil';\n\n/**\n * @typedef {import('../../model/Types').Shape} Shape\n *\n * @typedef {import('../../util/Types').Axis} Axis\n * @typedef {import('../../util/Types').Point} Point\n *\n * @typedef {import('didi').Injector} Injector\n *\n * @typedef {import('../../core/Canvas').default} Canvas\n * @typedef {import('../dragging/Dragging').default} Dragging\n * @typedef {import('../../core/EventBus').default} EventBus\n * @typedef {import('../../core/GraphicsFactory').default} GraphicsFactory\n * @typedef {import('../modeling/Modeling').default} Modeling\n */\n\nfunction axisAdd(point, axis, delta) {\n  return axisSet(point, axis, point[axis] + delta);\n}\nfunction axisSet(point, axis, value) {\n  return {\n    x: axis === 'x' ? value : point.x,\n    y: axis === 'y' ? value : point.y\n  };\n}\nfunction axisFenced(position, segmentStart, segmentEnd, axis) {\n  var maxValue = Math.max(segmentStart[axis], segmentEnd[axis]),\n    minValue = Math.min(segmentStart[axis], segmentEnd[axis]);\n  var padding = 20;\n  var fencedValue = Math.min(Math.max(minValue + padding, position[axis]), maxValue - padding);\n  return axisSet(segmentStart, axis, fencedValue);\n}\nfunction flipAxis(axis) {\n  return axis === 'x' ? 'y' : 'x';\n}\n\n/**\n * Get the docking point on the given element.\n *\n * Compute a reasonable docking, if non exists.\n *\n * @param {Point} point\n * @param {Shape} referenceElement\n * @param {Axis} moveAxis\n *\n * @return {Point}\n */\nfunction getDocking(point, referenceElement, moveAxis) {\n  var referenceMid, inverseAxis;\n  if (point.original) {\n    return point.original;\n  } else {\n    referenceMid = getMid(referenceElement);\n    inverseAxis = flipAxis(moveAxis);\n    return axisSet(point, inverseAxis, referenceMid[inverseAxis]);\n  }\n}\n\n/**\n * A component that implements moving of bendpoints.\n *\n * @param {Injector} injector\n * @param {EventBus} eventBus\n * @param {Canvas} canvas\n * @param {Canvas} dragging\n * @param {GraphicsFactory} graphicsFactory\n * @param {Modeling} modeling\n */\nexport default function ConnectionSegmentMove(injector, eventBus, canvas, dragging, graphicsFactory, modeling) {\n  // optional connection docking integration\n  var connectionDocking = injector.get('connectionDocking', false);\n\n  // API\n\n  this.start = function (event, connection, idx) {\n    var context,\n      gfx = canvas.getGraphics(connection),\n      segmentStartIndex = idx - 1,\n      segmentEndIndex = idx,\n      waypoints = connection.waypoints,\n      segmentStart = waypoints[segmentStartIndex],\n      segmentEnd = waypoints[segmentEndIndex],\n      intersection = getConnectionIntersection(canvas, waypoints, event),\n      direction,\n      axis,\n      dragPosition;\n    direction = pointsAligned(segmentStart, segmentEnd);\n\n    // do not move diagonal connection\n    if (!direction) {\n      return;\n    }\n\n    // the axis where we are going to move things\n    axis = direction === 'v' ? 'x' : 'y';\n    if (segmentStartIndex === 0) {\n      segmentStart = getDocking(segmentStart, connection.source, axis);\n    }\n    if (segmentEndIndex === waypoints.length - 1) {\n      segmentEnd = getDocking(segmentEnd, connection.target, axis);\n    }\n    if (intersection) {\n      dragPosition = intersection.point;\n    } else {\n      // set to segment center as default\n      dragPosition = {\n        x: (segmentStart.x + segmentEnd.x) / 2,\n        y: (segmentStart.y + segmentEnd.y) / 2\n      };\n    }\n    context = {\n      connection: connection,\n      segmentStartIndex: segmentStartIndex,\n      segmentEndIndex: segmentEndIndex,\n      segmentStart: segmentStart,\n      segmentEnd: segmentEnd,\n      axis: axis,\n      dragPosition: dragPosition\n    };\n    dragging.init(event, dragPosition, 'connectionSegment.move', {\n      cursor: axis === 'x' ? 'resize-ew' : 'resize-ns',\n      data: {\n        connection: connection,\n        connectionGfx: gfx,\n        context: context\n      }\n    });\n  };\n\n  /**\n   * Crop connection if connection cropping is provided.\n   *\n   * @param {Connection} connection\n   * @param {Point[]} newWaypoints\n   *\n   * @return {Point[]} cropped connection waypoints\n   */\n  function cropConnection(connection, newWaypoints) {\n    // crop connection, if docking service is provided only\n    if (!connectionDocking) {\n      return newWaypoints;\n    }\n    var oldWaypoints = connection.waypoints,\n      croppedWaypoints;\n\n    // temporary set new waypoints\n    connection.waypoints = newWaypoints;\n    croppedWaypoints = connectionDocking.getCroppedWaypoints(connection);\n\n    // restore old waypoints\n    connection.waypoints = oldWaypoints;\n    return croppedWaypoints;\n  }\n\n  // DRAGGING IMPLEMENTATION\n\n  function redrawConnection(data) {\n    graphicsFactory.update('connection', data.connection, data.connectionGfx);\n  }\n  function updateDragger(context, segmentOffset, event) {\n    var newWaypoints = context.newWaypoints,\n      segmentStartIndex = context.segmentStartIndex + segmentOffset,\n      segmentStart = newWaypoints[segmentStartIndex],\n      segmentEndIndex = context.segmentEndIndex + segmentOffset,\n      segmentEnd = newWaypoints[segmentEndIndex],\n      axis = flipAxis(context.axis);\n\n    // make sure the dragger does not move\n    // outside the connection\n    var draggerPosition = axisFenced(event, segmentStart, segmentEnd, axis);\n\n    // update dragger\n    translate(context.draggerGfx, draggerPosition.x, draggerPosition.y);\n  }\n\n  /**\n   * Filter waypoints for redundant ones (i.e. on the same axis).\n   * Returns the filtered waypoints and the offset related to the segment move.\n   *\n   * @param {Point[]} waypoints\n   * @param {Integer} segmentStartIndex of moved segment start\n   *\n   * @return {Object} { filteredWaypoints, segmentOffset }\n   */\n  function filterRedundantWaypoints(waypoints, segmentStartIndex) {\n    var segmentOffset = 0;\n    var filteredWaypoints = waypoints.filter(function (r, idx) {\n      if (pointsOnLine(waypoints[idx - 1], waypoints[idx + 1], r)) {\n        // remove point and increment offset\n        segmentOffset = idx <= segmentStartIndex ? segmentOffset - 1 : segmentOffset;\n        return false;\n      }\n\n      // dont remove point\n      return true;\n    });\n    return {\n      waypoints: filteredWaypoints,\n      segmentOffset: segmentOffset\n    };\n  }\n  eventBus.on('connectionSegment.move.start', function (event) {\n    var context = event.context,\n      connection = event.connection,\n      layer = canvas.getLayer('overlays');\n    context.originalWaypoints = connection.waypoints.slice();\n\n    // add dragger gfx\n    context.draggerGfx = addSegmentDragger(layer, context.segmentStart, context.segmentEnd);\n    svgClasses(context.draggerGfx).add('djs-dragging');\n    canvas.addMarker(connection, MARKER_CONNECT_UPDATING);\n  });\n  eventBus.on('connectionSegment.move.move', function (event) {\n    var context = event.context,\n      connection = context.connection,\n      segmentStartIndex = context.segmentStartIndex,\n      segmentEndIndex = context.segmentEndIndex,\n      segmentStart = context.segmentStart,\n      segmentEnd = context.segmentEnd,\n      axis = context.axis;\n    var newWaypoints = context.originalWaypoints.slice(),\n      newSegmentStart = axisAdd(segmentStart, axis, event['d' + axis]),\n      newSegmentEnd = axisAdd(segmentEnd, axis, event['d' + axis]);\n\n    // original waypoint count and added / removed\n    // from start waypoint delta. We use the later\n    // to retrieve the updated segmentStartIndex / segmentEndIndex\n    var waypointCount = newWaypoints.length,\n      segmentOffset = 0;\n\n    // move segment start / end by axis delta\n    newWaypoints[segmentStartIndex] = newSegmentStart;\n    newWaypoints[segmentEndIndex] = newSegmentEnd;\n    var sourceToSegmentOrientation, targetToSegmentOrientation;\n\n    // handle first segment\n    if (segmentStartIndex < 2) {\n      sourceToSegmentOrientation = getOrientation(connection.source, newSegmentStart);\n\n      // first bendpoint, remove first segment if intersecting\n      if (segmentStartIndex === 1) {\n        if (sourceToSegmentOrientation === 'intersect') {\n          newWaypoints.shift();\n          newWaypoints[0] = newSegmentStart;\n          segmentOffset--;\n        }\n      }\n\n      // docking point, add segment if not intersecting anymore\n      else {\n        if (sourceToSegmentOrientation !== 'intersect') {\n          newWaypoints.unshift(segmentStart);\n          segmentOffset++;\n        }\n      }\n    }\n\n    // handle last segment\n    if (segmentEndIndex > waypointCount - 3) {\n      targetToSegmentOrientation = getOrientation(connection.target, newSegmentEnd);\n\n      // last bendpoint, remove last segment if intersecting\n      if (segmentEndIndex === waypointCount - 2) {\n        if (targetToSegmentOrientation === 'intersect') {\n          newWaypoints.pop();\n          newWaypoints[newWaypoints.length - 1] = newSegmentEnd;\n        }\n      }\n\n      // last bendpoint, remove last segment if intersecting\n      else {\n        if (targetToSegmentOrientation !== 'intersect') {\n          newWaypoints.push(segmentEnd);\n        }\n      }\n    }\n\n    // update connection waypoints\n    context.newWaypoints = connection.waypoints = cropConnection(connection, newWaypoints);\n\n    // update dragger position\n    updateDragger(context, segmentOffset, event);\n\n    // save segmentOffset in context\n    context.newSegmentStartIndex = segmentStartIndex + segmentOffset;\n\n    // redraw connection\n    redrawConnection(event);\n  });\n  eventBus.on('connectionSegment.move.hover', function (event) {\n    event.context.hover = event.hover;\n    canvas.addMarker(event.hover, MARKER_CONNECT_HOVER);\n  });\n  eventBus.on(['connectionSegment.move.out', 'connectionSegment.move.cleanup'], function (event) {\n    // remove connect marker\n    // if it was added\n    var hover = event.context.hover;\n    if (hover) {\n      canvas.removeMarker(hover, MARKER_CONNECT_HOVER);\n    }\n  });\n  eventBus.on('connectionSegment.move.cleanup', function (event) {\n    var context = event.context,\n      connection = context.connection;\n\n    // remove dragger gfx\n    if (context.draggerGfx) {\n      svgRemove(context.draggerGfx);\n    }\n    canvas.removeMarker(connection, MARKER_CONNECT_UPDATING);\n  });\n  eventBus.on(['connectionSegment.move.cancel', 'connectionSegment.move.end'], function (event) {\n    var context = event.context,\n      connection = context.connection;\n    connection.waypoints = context.originalWaypoints;\n    redrawConnection(event);\n  });\n  eventBus.on('connectionSegment.move.end', function (event) {\n    var context = event.context,\n      connection = context.connection,\n      newWaypoints = context.newWaypoints,\n      newSegmentStartIndex = context.newSegmentStartIndex;\n\n    // ensure we have actual pixel values bendpoint\n    // coordinates (important when zoom level was > 1 during move)\n    newWaypoints = newWaypoints.map(function (p) {\n      return {\n        original: p.original,\n        x: Math.round(p.x),\n        y: Math.round(p.y)\n      };\n    });\n\n    // apply filter redunant waypoints\n    var filtered = filterRedundantWaypoints(newWaypoints, newSegmentStartIndex);\n\n    // get filtered waypoints\n    var filteredWaypoints = filtered.waypoints,\n      croppedWaypoints = cropConnection(connection, filteredWaypoints),\n      segmentOffset = filtered.segmentOffset;\n    var hints = {\n      segmentMove: {\n        segmentStartIndex: context.segmentStartIndex,\n        newSegmentStartIndex: newSegmentStartIndex + segmentOffset\n      }\n    };\n    modeling.updateWaypoints(connection, croppedWaypoints, hints);\n  });\n}\nConnectionSegmentMove.$inject = ['injector', 'eventBus', 'canvas', 'dragging', 'graphicsFactory', 'modeling'];","map":{"version":3,"names":["pointsAligned","pointsOnLine","addSegmentDragger","getConnectionIntersection","getMid","getOrientation","MARKER_CONNECT_HOVER","MARKER_CONNECT_UPDATING","classes","svgClasses","remove","svgRemove","translate","axisAdd","point","axis","delta","axisSet","value","x","y","axisFenced","position","segmentStart","segmentEnd","maxValue","Math","max","minValue","min","padding","fencedValue","flipAxis","getDocking","referenceElement","moveAxis","referenceMid","inverseAxis","original","ConnectionSegmentMove","injector","eventBus","canvas","dragging","graphicsFactory","modeling","connectionDocking","get","start","event","connection","idx","context","gfx","getGraphics","segmentStartIndex","segmentEndIndex","waypoints","intersection","direction","dragPosition","source","length","target","init","cursor","data","connectionGfx","cropConnection","newWaypoints","oldWaypoints","croppedWaypoints","getCroppedWaypoints","redrawConnection","update","updateDragger","segmentOffset","draggerPosition","draggerGfx","filterRedundantWaypoints","filteredWaypoints","filter","r","on","layer","getLayer","originalWaypoints","slice","add","addMarker","newSegmentStart","newSegmentEnd","waypointCount","sourceToSegmentOrientation","targetToSegmentOrientation","shift","unshift","pop","push","newSegmentStartIndex","hover","removeMarker","map","p","round","filtered","hints","segmentMove","updateWaypoints","$inject"],"sources":["/home/runner/work/sgex/sgex/node_modules/diagram-js/lib/features/bendpoints/ConnectionSegmentMove.js"],"sourcesContent":["import {\n  pointsAligned,\n  pointsOnLine\n} from '../../util/Geometry';\n\nimport {\n  addSegmentDragger,\n  getConnectionIntersection\n} from './BendpointUtil';\n\nimport {\n  getMid,\n  getOrientation\n} from '../../layout/LayoutUtil';\n\nvar MARKER_CONNECT_HOVER = 'connect-hover',\n    MARKER_CONNECT_UPDATING = 'djs-updating';\n\nimport {\n  classes as svgClasses,\n  remove as svgRemove\n} from 'tiny-svg';\n\nimport {\n  translate\n} from '../../util/SvgTransformUtil';\n\n/**\n * @typedef {import('../../model/Types').Shape} Shape\n *\n * @typedef {import('../../util/Types').Axis} Axis\n * @typedef {import('../../util/Types').Point} Point\n *\n * @typedef {import('didi').Injector} Injector\n *\n * @typedef {import('../../core/Canvas').default} Canvas\n * @typedef {import('../dragging/Dragging').default} Dragging\n * @typedef {import('../../core/EventBus').default} EventBus\n * @typedef {import('../../core/GraphicsFactory').default} GraphicsFactory\n * @typedef {import('../modeling/Modeling').default} Modeling\n */\n\nfunction axisAdd(point, axis, delta) {\n  return axisSet(point, axis, point[axis] + delta);\n}\n\nfunction axisSet(point, axis, value) {\n  return {\n    x: (axis === 'x' ? value : point.x),\n    y: (axis === 'y' ? value : point.y)\n  };\n}\n\nfunction axisFenced(position, segmentStart, segmentEnd, axis) {\n\n  var maxValue = Math.max(segmentStart[axis], segmentEnd[axis]),\n      minValue = Math.min(segmentStart[axis], segmentEnd[axis]);\n\n  var padding = 20;\n\n  var fencedValue = Math.min(Math.max(minValue + padding, position[axis]), maxValue - padding);\n\n  return axisSet(segmentStart, axis, fencedValue);\n}\n\nfunction flipAxis(axis) {\n  return axis === 'x' ? 'y' : 'x';\n}\n\n/**\n * Get the docking point on the given element.\n *\n * Compute a reasonable docking, if non exists.\n *\n * @param {Point} point\n * @param {Shape} referenceElement\n * @param {Axis} moveAxis\n *\n * @return {Point}\n */\nfunction getDocking(point, referenceElement, moveAxis) {\n\n  var referenceMid,\n      inverseAxis;\n\n  if (point.original) {\n    return point.original;\n  } else {\n    referenceMid = getMid(referenceElement);\n    inverseAxis = flipAxis(moveAxis);\n\n    return axisSet(point, inverseAxis, referenceMid[inverseAxis]);\n  }\n}\n\n/**\n * A component that implements moving of bendpoints.\n *\n * @param {Injector} injector\n * @param {EventBus} eventBus\n * @param {Canvas} canvas\n * @param {Canvas} dragging\n * @param {GraphicsFactory} graphicsFactory\n * @param {Modeling} modeling\n */\nexport default function ConnectionSegmentMove(\n    injector, eventBus, canvas,\n    dragging, graphicsFactory, modeling) {\n\n  // optional connection docking integration\n  var connectionDocking = injector.get('connectionDocking', false);\n\n\n  // API\n\n  this.start = function(event, connection, idx) {\n\n    var context,\n        gfx = canvas.getGraphics(connection),\n        segmentStartIndex = idx - 1,\n        segmentEndIndex = idx,\n        waypoints = connection.waypoints,\n        segmentStart = waypoints[segmentStartIndex],\n        segmentEnd = waypoints[segmentEndIndex],\n        intersection = getConnectionIntersection(canvas, waypoints, event),\n        direction, axis, dragPosition;\n\n    direction = pointsAligned(segmentStart, segmentEnd);\n\n    // do not move diagonal connection\n    if (!direction) {\n      return;\n    }\n\n    // the axis where we are going to move things\n    axis = direction === 'v' ? 'x' : 'y';\n\n    if (segmentStartIndex === 0) {\n      segmentStart = getDocking(segmentStart, connection.source, axis);\n    }\n\n    if (segmentEndIndex === waypoints.length - 1) {\n      segmentEnd = getDocking(segmentEnd, connection.target, axis);\n    }\n\n    if (intersection) {\n      dragPosition = intersection.point;\n    } else {\n\n      // set to segment center as default\n      dragPosition = {\n        x: (segmentStart.x + segmentEnd.x) / 2,\n        y: (segmentStart.y + segmentEnd.y) / 2\n      };\n    }\n\n    context = {\n      connection: connection,\n      segmentStartIndex: segmentStartIndex,\n      segmentEndIndex: segmentEndIndex,\n      segmentStart: segmentStart,\n      segmentEnd: segmentEnd,\n      axis: axis,\n      dragPosition: dragPosition\n    };\n\n    dragging.init(event, dragPosition, 'connectionSegment.move', {\n      cursor: axis === 'x' ? 'resize-ew' : 'resize-ns',\n      data: {\n        connection: connection,\n        connectionGfx: gfx,\n        context: context\n      }\n    });\n  };\n\n  /**\n   * Crop connection if connection cropping is provided.\n   *\n   * @param {Connection} connection\n   * @param {Point[]} newWaypoints\n   *\n   * @return {Point[]} cropped connection waypoints\n   */\n  function cropConnection(connection, newWaypoints) {\n\n    // crop connection, if docking service is provided only\n    if (!connectionDocking) {\n      return newWaypoints;\n    }\n\n    var oldWaypoints = connection.waypoints,\n        croppedWaypoints;\n\n    // temporary set new waypoints\n    connection.waypoints = newWaypoints;\n\n    croppedWaypoints = connectionDocking.getCroppedWaypoints(connection);\n\n    // restore old waypoints\n    connection.waypoints = oldWaypoints;\n\n    return croppedWaypoints;\n  }\n\n  // DRAGGING IMPLEMENTATION\n\n  function redrawConnection(data) {\n    graphicsFactory.update('connection', data.connection, data.connectionGfx);\n  }\n\n  function updateDragger(context, segmentOffset, event) {\n\n    var newWaypoints = context.newWaypoints,\n        segmentStartIndex = context.segmentStartIndex + segmentOffset,\n        segmentStart = newWaypoints[segmentStartIndex],\n        segmentEndIndex = context.segmentEndIndex + segmentOffset,\n        segmentEnd = newWaypoints[segmentEndIndex],\n        axis = flipAxis(context.axis);\n\n    // make sure the dragger does not move\n    // outside the connection\n    var draggerPosition = axisFenced(event, segmentStart, segmentEnd, axis);\n\n    // update dragger\n    translate(context.draggerGfx, draggerPosition.x, draggerPosition.y);\n  }\n\n  /**\n   * Filter waypoints for redundant ones (i.e. on the same axis).\n   * Returns the filtered waypoints and the offset related to the segment move.\n   *\n   * @param {Point[]} waypoints\n   * @param {Integer} segmentStartIndex of moved segment start\n   *\n   * @return {Object} { filteredWaypoints, segmentOffset }\n   */\n  function filterRedundantWaypoints(waypoints, segmentStartIndex) {\n\n    var segmentOffset = 0;\n\n    var filteredWaypoints = waypoints.filter(function(r, idx) {\n      if (pointsOnLine(waypoints[idx - 1], waypoints[idx + 1], r)) {\n\n        // remove point and increment offset\n        segmentOffset = idx <= segmentStartIndex ? segmentOffset - 1 : segmentOffset;\n        return false;\n      }\n\n      // dont remove point\n      return true;\n    });\n\n    return {\n      waypoints: filteredWaypoints,\n      segmentOffset: segmentOffset\n    };\n  }\n\n  eventBus.on('connectionSegment.move.start', function(event) {\n\n    var context = event.context,\n        connection = event.connection,\n        layer = canvas.getLayer('overlays');\n\n    context.originalWaypoints = connection.waypoints.slice();\n\n    // add dragger gfx\n    context.draggerGfx = addSegmentDragger(layer, context.segmentStart, context.segmentEnd);\n    svgClasses(context.draggerGfx).add('djs-dragging');\n\n    canvas.addMarker(connection, MARKER_CONNECT_UPDATING);\n  });\n\n  eventBus.on('connectionSegment.move.move', function(event) {\n\n    var context = event.context,\n        connection = context.connection,\n        segmentStartIndex = context.segmentStartIndex,\n        segmentEndIndex = context.segmentEndIndex,\n        segmentStart = context.segmentStart,\n        segmentEnd = context.segmentEnd,\n        axis = context.axis;\n\n    var newWaypoints = context.originalWaypoints.slice(),\n        newSegmentStart = axisAdd(segmentStart, axis, event['d' + axis]),\n        newSegmentEnd = axisAdd(segmentEnd, axis, event['d' + axis]);\n\n    // original waypoint count and added / removed\n    // from start waypoint delta. We use the later\n    // to retrieve the updated segmentStartIndex / segmentEndIndex\n    var waypointCount = newWaypoints.length,\n        segmentOffset = 0;\n\n    // move segment start / end by axis delta\n    newWaypoints[segmentStartIndex] = newSegmentStart;\n    newWaypoints[segmentEndIndex] = newSegmentEnd;\n\n    var sourceToSegmentOrientation,\n        targetToSegmentOrientation;\n\n    // handle first segment\n    if (segmentStartIndex < 2) {\n      sourceToSegmentOrientation = getOrientation(connection.source, newSegmentStart);\n\n      // first bendpoint, remove first segment if intersecting\n      if (segmentStartIndex === 1) {\n\n        if (sourceToSegmentOrientation === 'intersect') {\n          newWaypoints.shift();\n          newWaypoints[0] = newSegmentStart;\n          segmentOffset--;\n        }\n      }\n\n      // docking point, add segment if not intersecting anymore\n      else {\n        if (sourceToSegmentOrientation !== 'intersect') {\n          newWaypoints.unshift(segmentStart);\n          segmentOffset++;\n        }\n      }\n    }\n\n    // handle last segment\n    if (segmentEndIndex > waypointCount - 3) {\n      targetToSegmentOrientation = getOrientation(connection.target, newSegmentEnd);\n\n      // last bendpoint, remove last segment if intersecting\n      if (segmentEndIndex === waypointCount - 2) {\n\n        if (targetToSegmentOrientation === 'intersect') {\n          newWaypoints.pop();\n          newWaypoints[newWaypoints.length - 1] = newSegmentEnd;\n        }\n      }\n\n      // last bendpoint, remove last segment if intersecting\n      else {\n        if (targetToSegmentOrientation !== 'intersect') {\n          newWaypoints.push(segmentEnd);\n        }\n      }\n    }\n\n    // update connection waypoints\n    context.newWaypoints = connection.waypoints = cropConnection(connection, newWaypoints);\n\n    // update dragger position\n    updateDragger(context, segmentOffset, event);\n\n    // save segmentOffset in context\n    context.newSegmentStartIndex = segmentStartIndex + segmentOffset;\n\n    // redraw connection\n    redrawConnection(event);\n  });\n\n  eventBus.on('connectionSegment.move.hover', function(event) {\n\n    event.context.hover = event.hover;\n    canvas.addMarker(event.hover, MARKER_CONNECT_HOVER);\n  });\n\n  eventBus.on([\n    'connectionSegment.move.out',\n    'connectionSegment.move.cleanup'\n  ], function(event) {\n\n    // remove connect marker\n    // if it was added\n    var hover = event.context.hover;\n\n    if (hover) {\n      canvas.removeMarker(hover, MARKER_CONNECT_HOVER);\n    }\n  });\n\n  eventBus.on('connectionSegment.move.cleanup', function(event) {\n\n    var context = event.context,\n        connection = context.connection;\n\n    // remove dragger gfx\n    if (context.draggerGfx) {\n      svgRemove(context.draggerGfx);\n    }\n\n    canvas.removeMarker(connection, MARKER_CONNECT_UPDATING);\n  });\n\n  eventBus.on([\n    'connectionSegment.move.cancel',\n    'connectionSegment.move.end'\n  ], function(event) {\n    var context = event.context,\n        connection = context.connection;\n\n    connection.waypoints = context.originalWaypoints;\n\n    redrawConnection(event);\n  });\n\n  eventBus.on('connectionSegment.move.end', function(event) {\n\n    var context = event.context,\n        connection = context.connection,\n        newWaypoints = context.newWaypoints,\n        newSegmentStartIndex = context.newSegmentStartIndex;\n\n    // ensure we have actual pixel values bendpoint\n    // coordinates (important when zoom level was > 1 during move)\n    newWaypoints = newWaypoints.map(function(p) {\n      return {\n        original: p.original,\n        x: Math.round(p.x),\n        y: Math.round(p.y)\n      };\n    });\n\n    // apply filter redunant waypoints\n    var filtered = filterRedundantWaypoints(newWaypoints, newSegmentStartIndex);\n\n    // get filtered waypoints\n    var filteredWaypoints = filtered.waypoints,\n        croppedWaypoints = cropConnection(connection, filteredWaypoints),\n        segmentOffset = filtered.segmentOffset;\n\n    var hints = {\n      segmentMove: {\n        segmentStartIndex: context.segmentStartIndex,\n        newSegmentStartIndex: newSegmentStartIndex + segmentOffset\n      }\n    };\n\n    modeling.updateWaypoints(connection, croppedWaypoints, hints);\n  });\n}\n\nConnectionSegmentMove.$inject = [\n  'injector',\n  'eventBus',\n  'canvas',\n  'dragging',\n  'graphicsFactory',\n  'modeling'\n];\n"],"mappings":"AAAA,SACEA,aAAa,EACbC,YAAY,QACP,qBAAqB;AAE5B,SACEC,iBAAiB,EACjBC,yBAAyB,QACpB,iBAAiB;AAExB,SACEC,MAAM,EACNC,cAAc,QACT,yBAAyB;AAEhC,IAAIC,oBAAoB,GAAG,eAAe;EACtCC,uBAAuB,GAAG,cAAc;AAE5C,SACEC,OAAO,IAAIC,UAAU,EACrBC,MAAM,IAAIC,SAAS,QACd,UAAU;AAEjB,SACEC,SAAS,QACJ,6BAA6B;;AAEpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,SAASC,OAAOA,CAACC,KAAK,EAAEC,IAAI,EAAEC,KAAK,EAAE;EACnC,OAAOC,OAAO,CAACH,KAAK,EAAEC,IAAI,EAAED,KAAK,CAACC,IAAI,CAAC,GAAGC,KAAK,CAAC;AAClD;AAEA,SAASC,OAAOA,CAACH,KAAK,EAAEC,IAAI,EAAEG,KAAK,EAAE;EACnC,OAAO;IACLC,CAAC,EAAGJ,IAAI,KAAK,GAAG,GAAGG,KAAK,GAAGJ,KAAK,CAACK,CAAE;IACnCC,CAAC,EAAGL,IAAI,KAAK,GAAG,GAAGG,KAAK,GAAGJ,KAAK,CAACM;EACnC,CAAC;AACH;AAEA,SAASC,UAAUA,CAACC,QAAQ,EAAEC,YAAY,EAAEC,UAAU,EAAET,IAAI,EAAE;EAE5D,IAAIU,QAAQ,GAAGC,IAAI,CAACC,GAAG,CAACJ,YAAY,CAACR,IAAI,CAAC,EAAES,UAAU,CAACT,IAAI,CAAC,CAAC;IACzDa,QAAQ,GAAGF,IAAI,CAACG,GAAG,CAACN,YAAY,CAACR,IAAI,CAAC,EAAES,UAAU,CAACT,IAAI,CAAC,CAAC;EAE7D,IAAIe,OAAO,GAAG,EAAE;EAEhB,IAAIC,WAAW,GAAGL,IAAI,CAACG,GAAG,CAACH,IAAI,CAACC,GAAG,CAACC,QAAQ,GAAGE,OAAO,EAAER,QAAQ,CAACP,IAAI,CAAC,CAAC,EAAEU,QAAQ,GAAGK,OAAO,CAAC;EAE5F,OAAOb,OAAO,CAACM,YAAY,EAAER,IAAI,EAAEgB,WAAW,CAAC;AACjD;AAEA,SAASC,QAAQA,CAACjB,IAAI,EAAE;EACtB,OAAOA,IAAI,KAAK,GAAG,GAAG,GAAG,GAAG,GAAG;AACjC;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASkB,UAAUA,CAACnB,KAAK,EAAEoB,gBAAgB,EAAEC,QAAQ,EAAE;EAErD,IAAIC,YAAY,EACZC,WAAW;EAEf,IAAIvB,KAAK,CAACwB,QAAQ,EAAE;IAClB,OAAOxB,KAAK,CAACwB,QAAQ;EACvB,CAAC,MAAM;IACLF,YAAY,GAAGhC,MAAM,CAAC8B,gBAAgB,CAAC;IACvCG,WAAW,GAAGL,QAAQ,CAACG,QAAQ,CAAC;IAEhC,OAAOlB,OAAO,CAACH,KAAK,EAAEuB,WAAW,EAAED,YAAY,CAACC,WAAW,CAAC,CAAC;EAC/D;AACF;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,SAASE,qBAAqBA,CACzCC,QAAQ,EAAEC,QAAQ,EAAEC,MAAM,EAC1BC,QAAQ,EAAEC,eAAe,EAAEC,QAAQ,EAAE;EAEvC;EACA,IAAIC,iBAAiB,GAAGN,QAAQ,CAACO,GAAG,CAAC,mBAAmB,EAAE,KAAK,CAAC;;EAGhE;;EAEA,IAAI,CAACC,KAAK,GAAG,UAASC,KAAK,EAAEC,UAAU,EAAEC,GAAG,EAAE;IAE5C,IAAIC,OAAO;MACPC,GAAG,GAAGX,MAAM,CAACY,WAAW,CAACJ,UAAU,CAAC;MACpCK,iBAAiB,GAAGJ,GAAG,GAAG,CAAC;MAC3BK,eAAe,GAAGL,GAAG;MACrBM,SAAS,GAAGP,UAAU,CAACO,SAAS;MAChClC,YAAY,GAAGkC,SAAS,CAACF,iBAAiB,CAAC;MAC3C/B,UAAU,GAAGiC,SAAS,CAACD,eAAe,CAAC;MACvCE,YAAY,GAAGvD,yBAAyB,CAACuC,MAAM,EAAEe,SAAS,EAAER,KAAK,CAAC;MAClEU,SAAS;MAAE5C,IAAI;MAAE6C,YAAY;IAEjCD,SAAS,GAAG3D,aAAa,CAACuB,YAAY,EAAEC,UAAU,CAAC;;IAEnD;IACA,IAAI,CAACmC,SAAS,EAAE;MACd;IACF;;IAEA;IACA5C,IAAI,GAAG4C,SAAS,KAAK,GAAG,GAAG,GAAG,GAAG,GAAG;IAEpC,IAAIJ,iBAAiB,KAAK,CAAC,EAAE;MAC3BhC,YAAY,GAAGU,UAAU,CAACV,YAAY,EAAE2B,UAAU,CAACW,MAAM,EAAE9C,IAAI,CAAC;IAClE;IAEA,IAAIyC,eAAe,KAAKC,SAAS,CAACK,MAAM,GAAG,CAAC,EAAE;MAC5CtC,UAAU,GAAGS,UAAU,CAACT,UAAU,EAAE0B,UAAU,CAACa,MAAM,EAAEhD,IAAI,CAAC;IAC9D;IAEA,IAAI2C,YAAY,EAAE;MAChBE,YAAY,GAAGF,YAAY,CAAC5C,KAAK;IACnC,CAAC,MAAM;MAEL;MACA8C,YAAY,GAAG;QACbzC,CAAC,EAAE,CAACI,YAAY,CAACJ,CAAC,GAAGK,UAAU,CAACL,CAAC,IAAI,CAAC;QACtCC,CAAC,EAAE,CAACG,YAAY,CAACH,CAAC,GAAGI,UAAU,CAACJ,CAAC,IAAI;MACvC,CAAC;IACH;IAEAgC,OAAO,GAAG;MACRF,UAAU,EAAEA,UAAU;MACtBK,iBAAiB,EAAEA,iBAAiB;MACpCC,eAAe,EAAEA,eAAe;MAChCjC,YAAY,EAAEA,YAAY;MAC1BC,UAAU,EAAEA,UAAU;MACtBT,IAAI,EAAEA,IAAI;MACV6C,YAAY,EAAEA;IAChB,CAAC;IAEDjB,QAAQ,CAACqB,IAAI,CAACf,KAAK,EAAEW,YAAY,EAAE,wBAAwB,EAAE;MAC3DK,MAAM,EAAElD,IAAI,KAAK,GAAG,GAAG,WAAW,GAAG,WAAW;MAChDmD,IAAI,EAAE;QACJhB,UAAU,EAAEA,UAAU;QACtBiB,aAAa,EAAEd,GAAG;QAClBD,OAAO,EAAEA;MACX;IACF,CAAC,CAAC;EACJ,CAAC;;EAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;EACE,SAASgB,cAAcA,CAAClB,UAAU,EAAEmB,YAAY,EAAE;IAEhD;IACA,IAAI,CAACvB,iBAAiB,EAAE;MACtB,OAAOuB,YAAY;IACrB;IAEA,IAAIC,YAAY,GAAGpB,UAAU,CAACO,SAAS;MACnCc,gBAAgB;;IAEpB;IACArB,UAAU,CAACO,SAAS,GAAGY,YAAY;IAEnCE,gBAAgB,GAAGzB,iBAAiB,CAAC0B,mBAAmB,CAACtB,UAAU,CAAC;;IAEpE;IACAA,UAAU,CAACO,SAAS,GAAGa,YAAY;IAEnC,OAAOC,gBAAgB;EACzB;;EAEA;;EAEA,SAASE,gBAAgBA,CAACP,IAAI,EAAE;IAC9BtB,eAAe,CAAC8B,MAAM,CAAC,YAAY,EAAER,IAAI,CAAChB,UAAU,EAAEgB,IAAI,CAACC,aAAa,CAAC;EAC3E;EAEA,SAASQ,aAAaA,CAACvB,OAAO,EAAEwB,aAAa,EAAE3B,KAAK,EAAE;IAEpD,IAAIoB,YAAY,GAAGjB,OAAO,CAACiB,YAAY;MACnCd,iBAAiB,GAAGH,OAAO,CAACG,iBAAiB,GAAGqB,aAAa;MAC7DrD,YAAY,GAAG8C,YAAY,CAACd,iBAAiB,CAAC;MAC9CC,eAAe,GAAGJ,OAAO,CAACI,eAAe,GAAGoB,aAAa;MACzDpD,UAAU,GAAG6C,YAAY,CAACb,eAAe,CAAC;MAC1CzC,IAAI,GAAGiB,QAAQ,CAACoB,OAAO,CAACrC,IAAI,CAAC;;IAEjC;IACA;IACA,IAAI8D,eAAe,GAAGxD,UAAU,CAAC4B,KAAK,EAAE1B,YAAY,EAAEC,UAAU,EAAET,IAAI,CAAC;;IAEvE;IACAH,SAAS,CAACwC,OAAO,CAAC0B,UAAU,EAAED,eAAe,CAAC1D,CAAC,EAAE0D,eAAe,CAACzD,CAAC,CAAC;EACrE;;EAEA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACE,SAAS2D,wBAAwBA,CAACtB,SAAS,EAAEF,iBAAiB,EAAE;IAE9D,IAAIqB,aAAa,GAAG,CAAC;IAErB,IAAII,iBAAiB,GAAGvB,SAAS,CAACwB,MAAM,CAAC,UAASC,CAAC,EAAE/B,GAAG,EAAE;MACxD,IAAIlD,YAAY,CAACwD,SAAS,CAACN,GAAG,GAAG,CAAC,CAAC,EAAEM,SAAS,CAACN,GAAG,GAAG,CAAC,CAAC,EAAE+B,CAAC,CAAC,EAAE;QAE3D;QACAN,aAAa,GAAGzB,GAAG,IAAII,iBAAiB,GAAGqB,aAAa,GAAG,CAAC,GAAGA,aAAa;QAC5E,OAAO,KAAK;MACd;;MAEA;MACA,OAAO,IAAI;IACb,CAAC,CAAC;IAEF,OAAO;MACLnB,SAAS,EAAEuB,iBAAiB;MAC5BJ,aAAa,EAAEA;IACjB,CAAC;EACH;EAEAnC,QAAQ,CAAC0C,EAAE,CAAC,8BAA8B,EAAE,UAASlC,KAAK,EAAE;IAE1D,IAAIG,OAAO,GAAGH,KAAK,CAACG,OAAO;MACvBF,UAAU,GAAGD,KAAK,CAACC,UAAU;MAC7BkC,KAAK,GAAG1C,MAAM,CAAC2C,QAAQ,CAAC,UAAU,CAAC;IAEvCjC,OAAO,CAACkC,iBAAiB,GAAGpC,UAAU,CAACO,SAAS,CAAC8B,KAAK,CAAC,CAAC;;IAExD;IACAnC,OAAO,CAAC0B,UAAU,GAAG5E,iBAAiB,CAACkF,KAAK,EAAEhC,OAAO,CAAC7B,YAAY,EAAE6B,OAAO,CAAC5B,UAAU,CAAC;IACvFf,UAAU,CAAC2C,OAAO,CAAC0B,UAAU,CAAC,CAACU,GAAG,CAAC,cAAc,CAAC;IAElD9C,MAAM,CAAC+C,SAAS,CAACvC,UAAU,EAAE3C,uBAAuB,CAAC;EACvD,CAAC,CAAC;EAEFkC,QAAQ,CAAC0C,EAAE,CAAC,6BAA6B,EAAE,UAASlC,KAAK,EAAE;IAEzD,IAAIG,OAAO,GAAGH,KAAK,CAACG,OAAO;MACvBF,UAAU,GAAGE,OAAO,CAACF,UAAU;MAC/BK,iBAAiB,GAAGH,OAAO,CAACG,iBAAiB;MAC7CC,eAAe,GAAGJ,OAAO,CAACI,eAAe;MACzCjC,YAAY,GAAG6B,OAAO,CAAC7B,YAAY;MACnCC,UAAU,GAAG4B,OAAO,CAAC5B,UAAU;MAC/BT,IAAI,GAAGqC,OAAO,CAACrC,IAAI;IAEvB,IAAIsD,YAAY,GAAGjB,OAAO,CAACkC,iBAAiB,CAACC,KAAK,CAAC,CAAC;MAChDG,eAAe,GAAG7E,OAAO,CAACU,YAAY,EAAER,IAAI,EAAEkC,KAAK,CAAC,GAAG,GAAGlC,IAAI,CAAC,CAAC;MAChE4E,aAAa,GAAG9E,OAAO,CAACW,UAAU,EAAET,IAAI,EAAEkC,KAAK,CAAC,GAAG,GAAGlC,IAAI,CAAC,CAAC;;IAEhE;IACA;IACA;IACA,IAAI6E,aAAa,GAAGvB,YAAY,CAACP,MAAM;MACnCc,aAAa,GAAG,CAAC;;IAErB;IACAP,YAAY,CAACd,iBAAiB,CAAC,GAAGmC,eAAe;IACjDrB,YAAY,CAACb,eAAe,CAAC,GAAGmC,aAAa;IAE7C,IAAIE,0BAA0B,EAC1BC,0BAA0B;;IAE9B;IACA,IAAIvC,iBAAiB,GAAG,CAAC,EAAE;MACzBsC,0BAA0B,GAAGxF,cAAc,CAAC6C,UAAU,CAACW,MAAM,EAAE6B,eAAe,CAAC;;MAE/E;MACA,IAAInC,iBAAiB,KAAK,CAAC,EAAE;QAE3B,IAAIsC,0BAA0B,KAAK,WAAW,EAAE;UAC9CxB,YAAY,CAAC0B,KAAK,CAAC,CAAC;UACpB1B,YAAY,CAAC,CAAC,CAAC,GAAGqB,eAAe;UACjCd,aAAa,EAAE;QACjB;MACF;;MAEA;MAAA,KACK;QACH,IAAIiB,0BAA0B,KAAK,WAAW,EAAE;UAC9CxB,YAAY,CAAC2B,OAAO,CAACzE,YAAY,CAAC;UAClCqD,aAAa,EAAE;QACjB;MACF;IACF;;IAEA;IACA,IAAIpB,eAAe,GAAGoC,aAAa,GAAG,CAAC,EAAE;MACvCE,0BAA0B,GAAGzF,cAAc,CAAC6C,UAAU,CAACa,MAAM,EAAE4B,aAAa,CAAC;;MAE7E;MACA,IAAInC,eAAe,KAAKoC,aAAa,GAAG,CAAC,EAAE;QAEzC,IAAIE,0BAA0B,KAAK,WAAW,EAAE;UAC9CzB,YAAY,CAAC4B,GAAG,CAAC,CAAC;UAClB5B,YAAY,CAACA,YAAY,CAACP,MAAM,GAAG,CAAC,CAAC,GAAG6B,aAAa;QACvD;MACF;;MAEA;MAAA,KACK;QACH,IAAIG,0BAA0B,KAAK,WAAW,EAAE;UAC9CzB,YAAY,CAAC6B,IAAI,CAAC1E,UAAU,CAAC;QAC/B;MACF;IACF;;IAEA;IACA4B,OAAO,CAACiB,YAAY,GAAGnB,UAAU,CAACO,SAAS,GAAGW,cAAc,CAAClB,UAAU,EAAEmB,YAAY,CAAC;;IAEtF;IACAM,aAAa,CAACvB,OAAO,EAAEwB,aAAa,EAAE3B,KAAK,CAAC;;IAE5C;IACAG,OAAO,CAAC+C,oBAAoB,GAAG5C,iBAAiB,GAAGqB,aAAa;;IAEhE;IACAH,gBAAgB,CAACxB,KAAK,CAAC;EACzB,CAAC,CAAC;EAEFR,QAAQ,CAAC0C,EAAE,CAAC,8BAA8B,EAAE,UAASlC,KAAK,EAAE;IAE1DA,KAAK,CAACG,OAAO,CAACgD,KAAK,GAAGnD,KAAK,CAACmD,KAAK;IACjC1D,MAAM,CAAC+C,SAAS,CAACxC,KAAK,CAACmD,KAAK,EAAE9F,oBAAoB,CAAC;EACrD,CAAC,CAAC;EAEFmC,QAAQ,CAAC0C,EAAE,CAAC,CACV,4BAA4B,EAC5B,gCAAgC,CACjC,EAAE,UAASlC,KAAK,EAAE;IAEjB;IACA;IACA,IAAImD,KAAK,GAAGnD,KAAK,CAACG,OAAO,CAACgD,KAAK;IAE/B,IAAIA,KAAK,EAAE;MACT1D,MAAM,CAAC2D,YAAY,CAACD,KAAK,EAAE9F,oBAAoB,CAAC;IAClD;EACF,CAAC,CAAC;EAEFmC,QAAQ,CAAC0C,EAAE,CAAC,gCAAgC,EAAE,UAASlC,KAAK,EAAE;IAE5D,IAAIG,OAAO,GAAGH,KAAK,CAACG,OAAO;MACvBF,UAAU,GAAGE,OAAO,CAACF,UAAU;;IAEnC;IACA,IAAIE,OAAO,CAAC0B,UAAU,EAAE;MACtBnE,SAAS,CAACyC,OAAO,CAAC0B,UAAU,CAAC;IAC/B;IAEApC,MAAM,CAAC2D,YAAY,CAACnD,UAAU,EAAE3C,uBAAuB,CAAC;EAC1D,CAAC,CAAC;EAEFkC,QAAQ,CAAC0C,EAAE,CAAC,CACV,+BAA+B,EAC/B,4BAA4B,CAC7B,EAAE,UAASlC,KAAK,EAAE;IACjB,IAAIG,OAAO,GAAGH,KAAK,CAACG,OAAO;MACvBF,UAAU,GAAGE,OAAO,CAACF,UAAU;IAEnCA,UAAU,CAACO,SAAS,GAAGL,OAAO,CAACkC,iBAAiB;IAEhDb,gBAAgB,CAACxB,KAAK,CAAC;EACzB,CAAC,CAAC;EAEFR,QAAQ,CAAC0C,EAAE,CAAC,4BAA4B,EAAE,UAASlC,KAAK,EAAE;IAExD,IAAIG,OAAO,GAAGH,KAAK,CAACG,OAAO;MACvBF,UAAU,GAAGE,OAAO,CAACF,UAAU;MAC/BmB,YAAY,GAAGjB,OAAO,CAACiB,YAAY;MACnC8B,oBAAoB,GAAG/C,OAAO,CAAC+C,oBAAoB;;IAEvD;IACA;IACA9B,YAAY,GAAGA,YAAY,CAACiC,GAAG,CAAC,UAASC,CAAC,EAAE;MAC1C,OAAO;QACLjE,QAAQ,EAAEiE,CAAC,CAACjE,QAAQ;QACpBnB,CAAC,EAAEO,IAAI,CAAC8E,KAAK,CAACD,CAAC,CAACpF,CAAC,CAAC;QAClBC,CAAC,EAAEM,IAAI,CAAC8E,KAAK,CAACD,CAAC,CAACnF,CAAC;MACnB,CAAC;IACH,CAAC,CAAC;;IAEF;IACA,IAAIqF,QAAQ,GAAG1B,wBAAwB,CAACV,YAAY,EAAE8B,oBAAoB,CAAC;;IAE3E;IACA,IAAInB,iBAAiB,GAAGyB,QAAQ,CAAChD,SAAS;MACtCc,gBAAgB,GAAGH,cAAc,CAAClB,UAAU,EAAE8B,iBAAiB,CAAC;MAChEJ,aAAa,GAAG6B,QAAQ,CAAC7B,aAAa;IAE1C,IAAI8B,KAAK,GAAG;MACVC,WAAW,EAAE;QACXpD,iBAAiB,EAAEH,OAAO,CAACG,iBAAiB;QAC5C4C,oBAAoB,EAAEA,oBAAoB,GAAGvB;MAC/C;IACF,CAAC;IAED/B,QAAQ,CAAC+D,eAAe,CAAC1D,UAAU,EAAEqB,gBAAgB,EAAEmC,KAAK,CAAC;EAC/D,CAAC,CAAC;AACJ;AAEAnE,qBAAqB,CAACsE,OAAO,GAAG,CAC9B,UAAU,EACV,UAAU,EACV,QAAQ,EACR,UAAU,EACV,iBAAiB,EACjB,UAAU,CACX","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}