{"ast":null,"code":"\"use strict\";\n\nvar _taggedTemplateLiteral = require(\"/home/runner/work/sgex/sgex/node_modules/@babel/runtime/helpers/taggedTemplateLiteral.js\").default;\nvar _templateObject, _templateObject2, _templateObject3;\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.validateSchemaDeps = exports.validatePropertyDeps = exports.error = void 0;\nconst codegen_1 = require(\"../../compile/codegen\");\nconst util_1 = require(\"../../compile/util\");\nconst code_1 = require(\"../code\");\nexports.error = {\n  message: _ref => {\n    let {\n      params: {\n        property,\n        depsCount,\n        deps\n      }\n    } = _ref;\n    const property_ies = depsCount === 1 ? \"property\" : \"properties\";\n    return (0, codegen_1.str)(_templateObject || (_templateObject = _taggedTemplateLiteral([\"must have \", \" \", \" when property \", \" is present\"])), property_ies, deps, property);\n  },\n  params: _ref2 => {\n    let {\n      params: {\n        property,\n        depsCount,\n        deps,\n        missingProperty\n      }\n    } = _ref2;\n    return (0, codegen_1._)(_templateObject2 || (_templateObject2 = _taggedTemplateLiteral([\"{property: \", \",\\n    missingProperty: \", \",\\n    depsCount: \", \",\\n    deps: \", \"}\"])), property, missingProperty, depsCount, deps);\n  } // TODO change to reference\n};\nconst def = {\n  keyword: \"dependencies\",\n  type: \"object\",\n  schemaType: \"object\",\n  error: exports.error,\n  code(cxt) {\n    const [propDeps, schDeps] = splitDependencies(cxt);\n    validatePropertyDeps(cxt, propDeps);\n    validateSchemaDeps(cxt, schDeps);\n  }\n};\nfunction splitDependencies(_ref3) {\n  let {\n    schema\n  } = _ref3;\n  const propertyDeps = {};\n  const schemaDeps = {};\n  for (const key in schema) {\n    if (key === \"__proto__\") continue;\n    const deps = Array.isArray(schema[key]) ? propertyDeps : schemaDeps;\n    deps[key] = schema[key];\n  }\n  return [propertyDeps, schemaDeps];\n}\nfunction validatePropertyDeps(cxt) {\n  let propertyDeps = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : cxt.schema;\n  const {\n    gen,\n    data,\n    it\n  } = cxt;\n  if (Object.keys(propertyDeps).length === 0) return;\n  const missing = gen.let(\"missing\");\n  for (const prop in propertyDeps) {\n    const deps = propertyDeps[prop];\n    if (deps.length === 0) continue;\n    const hasProperty = (0, code_1.propertyInData)(gen, data, prop, it.opts.ownProperties);\n    cxt.setParams({\n      property: prop,\n      depsCount: deps.length,\n      deps: deps.join(\", \")\n    });\n    if (it.allErrors) {\n      gen.if(hasProperty, () => {\n        for (const depProp of deps) {\n          (0, code_1.checkReportMissingProp)(cxt, depProp);\n        }\n      });\n    } else {\n      gen.if((0, codegen_1._)(_templateObject3 || (_templateObject3 = _taggedTemplateLiteral([\"\", \" && (\", \")\"])), hasProperty, (0, code_1.checkMissingProp)(cxt, deps, missing)));\n      (0, code_1.reportMissingProp)(cxt, missing);\n      gen.else();\n    }\n  }\n}\nexports.validatePropertyDeps = validatePropertyDeps;\nfunction validateSchemaDeps(cxt) {\n  let schemaDeps = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : cxt.schema;\n  const {\n    gen,\n    data,\n    keyword,\n    it\n  } = cxt;\n  const valid = gen.name(\"valid\");\n  for (const prop in schemaDeps) {\n    if ((0, util_1.alwaysValidSchema)(it, schemaDeps[prop])) continue;\n    gen.if((0, code_1.propertyInData)(gen, data, prop, it.opts.ownProperties), () => {\n      const schCxt = cxt.subschema({\n        keyword,\n        schemaProp: prop\n      }, valid);\n      cxt.mergeValidEvaluated(schCxt, valid);\n    }, () => gen.var(valid, true) // TODO var\n    );\n    cxt.ok(valid);\n  }\n}\nexports.validateSchemaDeps = validateSchemaDeps;\nexports.default = def;","map":{"version":3,"names":["codegen_1","require","util_1","code_1","exports","error","message","_ref","params","property","depsCount","deps","property_ies","str","_templateObject","_taggedTemplateLiteral","_ref2","missingProperty","_","_templateObject2","def","keyword","type","schemaType","code","cxt","propDeps","schDeps","splitDependencies","validatePropertyDeps","validateSchemaDeps","_ref3","schema","propertyDeps","schemaDeps","key","Array","isArray","arguments","length","undefined","gen","data","it","Object","keys","missing","let","prop","hasProperty","propertyInData","opts","ownProperties","setParams","join","allErrors","if","depProp","checkReportMissingProp","_templateObject3","checkMissingProp","reportMissingProp","else","valid","name","alwaysValidSchema","schCxt","subschema","schemaProp","mergeValidEvaluated","var","ok","default"],"sources":["/home/runner/work/sgex/sgex/node_modules/ajv/lib/vocabularies/applicator/dependencies.ts"],"sourcesContent":["import type {\n  CodeKeywordDefinition,\n  ErrorObject,\n  KeywordErrorDefinition,\n  SchemaMap,\n  AnySchema,\n} from \"../../types\"\nimport type {KeywordCxt} from \"../../compile/validate\"\nimport {_, str} from \"../../compile/codegen\"\nimport {alwaysValidSchema} from \"../../compile/util\"\nimport {checkReportMissingProp, checkMissingProp, reportMissingProp, propertyInData} from \"../code\"\n\nexport type PropertyDependencies = {[K in string]?: string[]}\n\nexport interface DependenciesErrorParams {\n  property: string\n  missingProperty: string\n  depsCount: number\n  deps: string // TODO change to string[]\n}\n\ntype SchemaDependencies = SchemaMap\n\nexport type DependenciesError = ErrorObject<\n  \"dependencies\",\n  DependenciesErrorParams,\n  {[K in string]?: string[] | AnySchema}\n>\n\nexport const error: KeywordErrorDefinition = {\n  message: ({params: {property, depsCount, deps}}) => {\n    const property_ies = depsCount === 1 ? \"property\" : \"properties\"\n    return str`must have ${property_ies} ${deps} when property ${property} is present`\n  },\n  params: ({params: {property, depsCount, deps, missingProperty}}) =>\n    _`{property: ${property},\n    missingProperty: ${missingProperty},\n    depsCount: ${depsCount},\n    deps: ${deps}}`, // TODO change to reference\n}\n\nconst def: CodeKeywordDefinition = {\n  keyword: \"dependencies\",\n  type: \"object\",\n  schemaType: \"object\",\n  error,\n  code(cxt: KeywordCxt) {\n    const [propDeps, schDeps] = splitDependencies(cxt)\n    validatePropertyDeps(cxt, propDeps)\n    validateSchemaDeps(cxt, schDeps)\n  },\n}\n\nfunction splitDependencies({schema}: KeywordCxt): [PropertyDependencies, SchemaDependencies] {\n  const propertyDeps: PropertyDependencies = {}\n  const schemaDeps: SchemaDependencies = {}\n  for (const key in schema) {\n    if (key === \"__proto__\") continue\n    const deps = Array.isArray(schema[key]) ? propertyDeps : schemaDeps\n    deps[key] = schema[key]\n  }\n  return [propertyDeps, schemaDeps]\n}\n\nexport function validatePropertyDeps(\n  cxt: KeywordCxt,\n  propertyDeps: {[K in string]?: string[]} = cxt.schema\n): void {\n  const {gen, data, it} = cxt\n  if (Object.keys(propertyDeps).length === 0) return\n  const missing = gen.let(\"missing\")\n  for (const prop in propertyDeps) {\n    const deps = propertyDeps[prop] as string[]\n    if (deps.length === 0) continue\n    const hasProperty = propertyInData(gen, data, prop, it.opts.ownProperties)\n    cxt.setParams({\n      property: prop,\n      depsCount: deps.length,\n      deps: deps.join(\", \"),\n    })\n    if (it.allErrors) {\n      gen.if(hasProperty, () => {\n        for (const depProp of deps) {\n          checkReportMissingProp(cxt, depProp)\n        }\n      })\n    } else {\n      gen.if(_`${hasProperty} && (${checkMissingProp(cxt, deps, missing)})`)\n      reportMissingProp(cxt, missing)\n      gen.else()\n    }\n  }\n}\n\nexport function validateSchemaDeps(cxt: KeywordCxt, schemaDeps: SchemaMap = cxt.schema): void {\n  const {gen, data, keyword, it} = cxt\n  const valid = gen.name(\"valid\")\n  for (const prop in schemaDeps) {\n    if (alwaysValidSchema(it, schemaDeps[prop] as AnySchema)) continue\n    gen.if(\n      propertyInData(gen, data, prop, it.opts.ownProperties),\n      () => {\n        const schCxt = cxt.subschema({keyword, schemaProp: prop}, valid)\n        cxt.mergeValidEvaluated(schCxt, valid)\n      },\n      () => gen.var(valid, true) // TODO var\n    )\n    cxt.ok(valid)\n  }\n}\n\nexport default def\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}