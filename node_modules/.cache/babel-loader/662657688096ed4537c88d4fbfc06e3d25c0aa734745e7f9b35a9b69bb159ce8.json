{"ast":null,"code":"import { filter, find, forEach } from 'min-dash';\nimport { elementToString } from './Util';\nimport { ensureCompatDiRef } from '../util/CompatibilityUtil';\n\n/**\n * @typedef {import('../model/Types').ModdleElement} ModdleElement\n */\n\n/**\n * Returns true if an element is of the given meta-model type.\n *\n * @param {ModdleElement} element\n * @param {string} type\n *\n * @return {boolean}\n */\nfunction is(element, type) {\n  return element.$instanceOf(type);\n}\n\n/**\n * Find a suitable display candidate for definitions where the DI does not\n * correctly specify one.\n *\n * @param {ModdleElement} definitions\n *\n * @return {ModdleElement}\n */\nfunction findDisplayCandidate(definitions) {\n  return find(definitions.rootElements, function (e) {\n    return is(e, 'bpmn:Process') || is(e, 'bpmn:Collaboration');\n  });\n}\n\n/**\n * @param {Record<'element' | 'root' | 'error', Function>} handler\n */\nexport default function BpmnTreeWalker(handler) {\n  // list of containers already walked\n  var handledElements = {};\n\n  // list of elements to handle deferred to ensure\n  // prerequisites are drawn\n  var deferred = [];\n  var diMap = {};\n\n  // Helpers //////////////////////\n\n  function contextual(fn, ctx) {\n    return function (e) {\n      fn(e, ctx);\n    };\n  }\n  function handled(element) {\n    handledElements[element.id] = element;\n  }\n  function isHandled(element) {\n    return handledElements[element.id];\n  }\n  function visit(element, ctx) {\n    var gfx = element.gfx;\n\n    // avoid multiple rendering of elements\n    if (gfx) {\n      throw new Error(`already rendered ${elementToString(element)}`);\n    }\n\n    // call handler\n    return handler.element(element, diMap[element.id], ctx);\n  }\n  function visitRoot(element, diagram) {\n    return handler.root(element, diMap[element.id], diagram);\n  }\n  function visitIfDi(element, ctx) {\n    try {\n      var gfx = diMap[element.id] && visit(element, ctx);\n      handled(element);\n      return gfx;\n    } catch (error) {\n      logError(error.message, {\n        element,\n        error\n      });\n      console.error(`failed to import ${elementToString(element)}`, error);\n    }\n  }\n  function logError(message, context) {\n    handler.error(message, context);\n  }\n\n  // DI handling //////////////////////\n\n  var registerDi = this.registerDi = function registerDi(di) {\n    var bpmnElement = di.bpmnElement;\n    if (bpmnElement) {\n      if (diMap[bpmnElement.id]) {\n        logError(`multiple DI elements defined for ${elementToString(bpmnElement)}`, {\n          element: bpmnElement\n        });\n      } else {\n        diMap[bpmnElement.id] = di;\n        ensureCompatDiRef(bpmnElement);\n      }\n    } else {\n      logError(`no bpmnElement referenced in ${elementToString(di)}`, {\n        element: di\n      });\n    }\n  };\n  function handleDiagram(diagram) {\n    handlePlane(diagram.plane);\n  }\n  function handlePlane(plane) {\n    registerDi(plane);\n    forEach(plane.planeElement, handlePlaneElement);\n  }\n  function handlePlaneElement(planeElement) {\n    registerDi(planeElement);\n  }\n\n  // Semantic handling //////////////////////\n\n  /**\n   * Handle definitions and return the rendered diagram (if any).\n   *\n   * @param {ModdleElement} definitions to walk and import\n   * @param {ModdleElement} [diagram] specific diagram to import and display\n   *\n   * @throws {Error} if no diagram to display could be found\n   */\n  this.handleDefinitions = function handleDefinitions(definitions, diagram) {\n    // make sure we walk the correct bpmnElement\n\n    var diagrams = definitions.diagrams;\n    if (diagram && diagrams.indexOf(diagram) === -1) {\n      throw new Error('diagram not part of <bpmn:Definitions />');\n    }\n    if (!diagram && diagrams && diagrams.length) {\n      diagram = diagrams[0];\n    }\n\n    // no diagram -> nothing to import\n    if (!diagram) {\n      throw new Error('no diagram to display');\n    }\n\n    // load DI from selected diagram only\n    diMap = {};\n    handleDiagram(diagram);\n    var plane = diagram.plane;\n    if (!plane) {\n      throw new Error(`no plane for ${elementToString(diagram)}`);\n    }\n    var rootElement = plane.bpmnElement;\n\n    // ensure we default to a suitable display candidate (process or collaboration),\n    // even if non is specified in DI\n    if (!rootElement) {\n      rootElement = findDisplayCandidate(definitions);\n      if (!rootElement) {\n        throw new Error('no process or collaboration to display');\n      } else {\n        logError(`correcting missing bpmnElement on ${elementToString(plane)} to ${elementToString(rootElement)}`);\n\n        // correct DI on the fly\n        plane.bpmnElement = rootElement;\n        registerDi(plane);\n      }\n    }\n    var ctx = visitRoot(rootElement, plane);\n    if (is(rootElement, 'bpmn:Process') || is(rootElement, 'bpmn:SubProcess')) {\n      handleProcess(rootElement, ctx);\n    } else if (is(rootElement, 'bpmn:Collaboration')) {\n      handleCollaboration(rootElement, ctx);\n\n      // force drawing of everything not yet drawn that is part of the target DI\n      handleUnhandledProcesses(definitions.rootElements, ctx);\n    } else {\n      throw new Error(`unsupported bpmnElement for ${elementToString(plane)}: ${elementToString(rootElement)}`);\n    }\n\n    // handle all deferred elements\n    handleDeferred(deferred);\n  };\n  var handleDeferred = this.handleDeferred = function handleDeferred() {\n    var fn;\n\n    // drain deferred until empty\n    while (deferred.length) {\n      fn = deferred.shift();\n      fn();\n    }\n  };\n  function handleProcess(process, context) {\n    handleFlowElementsContainer(process, context);\n    handleIoSpecification(process.ioSpecification, context);\n    handleArtifacts(process.artifacts, context);\n\n    // log process handled\n    handled(process);\n  }\n  function handleUnhandledProcesses(rootElements, ctx) {\n    // walk through all processes that have not yet been drawn and draw them\n    // if they contain lanes with DI information.\n    // we do this to pass the free-floating lane test cases in the MIWG test suite\n    var processes = filter(rootElements, function (e) {\n      return !isHandled(e) && is(e, 'bpmn:Process') && e.laneSets;\n    });\n    processes.forEach(contextual(handleProcess, ctx));\n  }\n  function handleMessageFlow(messageFlow, context) {\n    visitIfDi(messageFlow, context);\n  }\n  function handleMessageFlows(messageFlows, context) {\n    forEach(messageFlows, contextual(handleMessageFlow, context));\n  }\n  function handleDataAssociation(association, context) {\n    visitIfDi(association, context);\n  }\n  function handleDataInput(dataInput, context) {\n    visitIfDi(dataInput, context);\n  }\n  function handleDataOutput(dataOutput, context) {\n    visitIfDi(dataOutput, context);\n  }\n  function handleArtifact(artifact, context) {\n    // bpmn:TextAnnotation\n    // bpmn:Group\n    // bpmn:Association\n\n    visitIfDi(artifact, context);\n  }\n  function handleArtifacts(artifacts, context) {\n    forEach(artifacts, function (e) {\n      if (is(e, 'bpmn:Association')) {\n        deferred.push(function () {\n          handleArtifact(e, context);\n        });\n      } else {\n        handleArtifact(e, context);\n      }\n    });\n  }\n  function handleIoSpecification(ioSpecification, context) {\n    if (!ioSpecification) {\n      return;\n    }\n    forEach(ioSpecification.dataInputs, contextual(handleDataInput, context));\n    forEach(ioSpecification.dataOutputs, contextual(handleDataOutput, context));\n  }\n  var handleSubProcess = this.handleSubProcess = function handleSubProcess(subProcess, context) {\n    handleFlowElementsContainer(subProcess, context);\n    handleArtifacts(subProcess.artifacts, context);\n  };\n  function handleFlowNode(flowNode, context) {\n    var childCtx = visitIfDi(flowNode, context);\n    if (is(flowNode, 'bpmn:SubProcess')) {\n      handleSubProcess(flowNode, childCtx || context);\n    }\n    if (is(flowNode, 'bpmn:Activity')) {\n      handleIoSpecification(flowNode.ioSpecification, context);\n    }\n\n    // defer handling of associations\n    // affected types:\n    //\n    //   * bpmn:Activity\n    //   * bpmn:ThrowEvent\n    //   * bpmn:CatchEvent\n    //\n    deferred.push(function () {\n      forEach(flowNode.dataInputAssociations, contextual(handleDataAssociation, context));\n      forEach(flowNode.dataOutputAssociations, contextual(handleDataAssociation, context));\n    });\n  }\n  function handleSequenceFlow(sequenceFlow, context) {\n    visitIfDi(sequenceFlow, context);\n  }\n  function handleDataElement(dataObject, context) {\n    visitIfDi(dataObject, context);\n  }\n  function handleLane(lane, context) {\n    deferred.push(function () {\n      var newContext = visitIfDi(lane, context);\n      if (lane.childLaneSet) {\n        handleLaneSet(lane.childLaneSet, newContext || context);\n      }\n      wireFlowNodeRefs(lane);\n    });\n  }\n  function handleLaneSet(laneSet, context) {\n    forEach(laneSet.lanes, contextual(handleLane, context));\n  }\n  function handleLaneSets(laneSets, context) {\n    forEach(laneSets, contextual(handleLaneSet, context));\n  }\n  function handleFlowElementsContainer(container, context) {\n    handleFlowElements(container.flowElements, context);\n    if (container.laneSets) {\n      handleLaneSets(container.laneSets, context);\n    }\n  }\n  function handleFlowElements(flowElements, context) {\n    forEach(flowElements, function (flowElement) {\n      if (is(flowElement, 'bpmn:SequenceFlow')) {\n        deferred.push(function () {\n          handleSequenceFlow(flowElement, context);\n        });\n      } else if (is(flowElement, 'bpmn:BoundaryEvent')) {\n        deferred.unshift(function () {\n          handleFlowNode(flowElement, context);\n        });\n      } else if (is(flowElement, 'bpmn:FlowNode')) {\n        handleFlowNode(flowElement, context);\n      } else if (is(flowElement, 'bpmn:DataObject')) {\n\n        // SKIP (assume correct referencing via DataObjectReference)\n      } else if (is(flowElement, 'bpmn:DataStoreReference')) {\n        handleDataElement(flowElement, context);\n      } else if (is(flowElement, 'bpmn:DataObjectReference')) {\n        handleDataElement(flowElement, context);\n      } else {\n        logError(`unrecognized flowElement ${elementToString(flowElement)} in context ${elementToString(context && context.businessObject)}`, {\n          element: flowElement,\n          context\n        });\n      }\n    });\n  }\n  function handleParticipant(participant, context) {\n    var newCtx = visitIfDi(participant, context);\n    var process = participant.processRef;\n    if (process) {\n      handleProcess(process, newCtx || context);\n    }\n  }\n  function handleCollaboration(collaboration, context) {\n    forEach(collaboration.participants, contextual(handleParticipant, context));\n    deferred.push(function () {\n      handleMessageFlows(collaboration.messageFlows, context);\n    });\n    handleArtifacts(collaboration.artifacts, context);\n  }\n  function wireFlowNodeRefs(lane) {\n    // wire the virtual flowNodeRefs <-> relationship\n    forEach(lane.flowNodeRef, function (flowNode) {\n      var lanes = flowNode.get('lanes');\n      if (lanes) {\n        lanes.push(lane);\n      }\n    });\n  }\n}","map":{"version":3,"names":["filter","find","forEach","elementToString","ensureCompatDiRef","is","element","type","$instanceOf","findDisplayCandidate","definitions","rootElements","e","BpmnTreeWalker","handler","handledElements","deferred","diMap","contextual","fn","ctx","handled","id","isHandled","visit","gfx","Error","visitRoot","diagram","root","visitIfDi","error","logError","message","console","context","registerDi","di","bpmnElement","handleDiagram","handlePlane","plane","planeElement","handlePlaneElement","handleDefinitions","diagrams","indexOf","length","rootElement","handleProcess","handleCollaboration","handleUnhandledProcesses","handleDeferred","shift","process","handleFlowElementsContainer","handleIoSpecification","ioSpecification","handleArtifacts","artifacts","processes","laneSets","handleMessageFlow","messageFlow","handleMessageFlows","messageFlows","handleDataAssociation","association","handleDataInput","dataInput","handleDataOutput","dataOutput","handleArtifact","artifact","push","dataInputs","dataOutputs","handleSubProcess","subProcess","handleFlowNode","flowNode","childCtx","dataInputAssociations","dataOutputAssociations","handleSequenceFlow","sequenceFlow","handleDataElement","dataObject","handleLane","lane","newContext","childLaneSet","handleLaneSet","wireFlowNodeRefs","laneSet","lanes","handleLaneSets","container","handleFlowElements","flowElements","flowElement","unshift","businessObject","handleParticipant","participant","newCtx","processRef","collaboration","participants","flowNodeRef","get"],"sources":["/home/runner/work/sgex/sgex/node_modules/bpmn-js/lib/import/BpmnTreeWalker.js"],"sourcesContent":["import {\n  filter,\n  find,\n  forEach\n} from 'min-dash';\n\nimport {\n  elementToString\n} from './Util';\n\nimport {\n  ensureCompatDiRef\n} from '../util/CompatibilityUtil';\n\n/**\n * @typedef {import('../model/Types').ModdleElement} ModdleElement\n */\n\n/**\n * Returns true if an element is of the given meta-model type.\n *\n * @param {ModdleElement} element\n * @param {string} type\n *\n * @return {boolean}\n */\nfunction is(element, type) {\n  return element.$instanceOf(type);\n}\n\n\n/**\n * Find a suitable display candidate for definitions where the DI does not\n * correctly specify one.\n *\n * @param {ModdleElement} definitions\n *\n * @return {ModdleElement}\n */\nfunction findDisplayCandidate(definitions) {\n  return find(definitions.rootElements, function(e) {\n    return is(e, 'bpmn:Process') || is(e, 'bpmn:Collaboration');\n  });\n}\n\n/**\n * @param {Record<'element' | 'root' | 'error', Function>} handler\n */\nexport default function BpmnTreeWalker(handler) {\n\n  // list of containers already walked\n  var handledElements = {};\n\n  // list of elements to handle deferred to ensure\n  // prerequisites are drawn\n  var deferred = [];\n\n  var diMap = {};\n\n  // Helpers //////////////////////\n\n  function contextual(fn, ctx) {\n    return function(e) {\n      fn(e, ctx);\n    };\n  }\n\n  function handled(element) {\n    handledElements[element.id] = element;\n  }\n\n  function isHandled(element) {\n    return handledElements[element.id];\n  }\n\n  function visit(element, ctx) {\n\n    var gfx = element.gfx;\n\n    // avoid multiple rendering of elements\n    if (gfx) {\n      throw new Error(\n        `already rendered ${ elementToString(element) }`\n      );\n    }\n\n    // call handler\n    return handler.element(element, diMap[element.id], ctx);\n  }\n\n  function visitRoot(element, diagram) {\n    return handler.root(element, diMap[element.id], diagram);\n  }\n\n  function visitIfDi(element, ctx) {\n\n    try {\n      var gfx = diMap[element.id] && visit(element, ctx);\n\n      handled(element);\n\n      return gfx;\n    } catch (error) {\n      logError(error.message, { element, error });\n\n      console.error(`failed to import ${ elementToString(element) }`, error);\n    }\n  }\n\n  function logError(message, context) {\n    handler.error(message, context);\n  }\n\n  // DI handling //////////////////////\n\n  var registerDi = this.registerDi = function registerDi(di) {\n    var bpmnElement = di.bpmnElement;\n\n    if (bpmnElement) {\n      if (diMap[bpmnElement.id]) {\n        logError(\n          `multiple DI elements defined for ${ elementToString(bpmnElement) }`,\n          { element: bpmnElement }\n        );\n      } else {\n        diMap[bpmnElement.id] = di;\n\n        ensureCompatDiRef(bpmnElement);\n      }\n    } else {\n      logError(\n        `no bpmnElement referenced in ${ elementToString(di) }`,\n        { element: di }\n      );\n    }\n  };\n\n  function handleDiagram(diagram) {\n    handlePlane(diagram.plane);\n  }\n\n  function handlePlane(plane) {\n    registerDi(plane);\n\n    forEach(plane.planeElement, handlePlaneElement);\n  }\n\n  function handlePlaneElement(planeElement) {\n    registerDi(planeElement);\n  }\n\n\n  // Semantic handling //////////////////////\n\n  /**\n   * Handle definitions and return the rendered diagram (if any).\n   *\n   * @param {ModdleElement} definitions to walk and import\n   * @param {ModdleElement} [diagram] specific diagram to import and display\n   *\n   * @throws {Error} if no diagram to display could be found\n   */\n  this.handleDefinitions = function handleDefinitions(definitions, diagram) {\n\n    // make sure we walk the correct bpmnElement\n\n    var diagrams = definitions.diagrams;\n\n    if (diagram && diagrams.indexOf(diagram) === -1) {\n      throw new Error('diagram not part of <bpmn:Definitions />');\n    }\n\n    if (!diagram && diagrams && diagrams.length) {\n      diagram = diagrams[0];\n    }\n\n    // no diagram -> nothing to import\n    if (!diagram) {\n      throw new Error('no diagram to display');\n    }\n\n    // load DI from selected diagram only\n    diMap = {};\n    handleDiagram(diagram);\n\n\n    var plane = diagram.plane;\n\n    if (!plane) {\n      throw new Error(\n        `no plane for ${ elementToString(diagram) }`\n      );\n    }\n\n    var rootElement = plane.bpmnElement;\n\n    // ensure we default to a suitable display candidate (process or collaboration),\n    // even if non is specified in DI\n    if (!rootElement) {\n      rootElement = findDisplayCandidate(definitions);\n\n      if (!rootElement) {\n        throw new Error('no process or collaboration to display');\n      } else {\n\n        logError(\n          `correcting missing bpmnElement on ${ elementToString(plane) } to ${ elementToString(rootElement) }`\n        );\n\n        // correct DI on the fly\n        plane.bpmnElement = rootElement;\n        registerDi(plane);\n      }\n    }\n\n\n    var ctx = visitRoot(rootElement, plane);\n\n    if (is(rootElement, 'bpmn:Process') || is(rootElement, 'bpmn:SubProcess')) {\n      handleProcess(rootElement, ctx);\n    } else if (is(rootElement, 'bpmn:Collaboration')) {\n      handleCollaboration(rootElement, ctx);\n\n      // force drawing of everything not yet drawn that is part of the target DI\n      handleUnhandledProcesses(definitions.rootElements, ctx);\n    } else {\n      throw new Error(\n        `unsupported bpmnElement for ${ elementToString(plane) }: ${ elementToString(rootElement) }`\n      );\n    }\n\n    // handle all deferred elements\n    handleDeferred(deferred);\n  };\n\n  var handleDeferred = this.handleDeferred = function handleDeferred() {\n\n    var fn;\n\n    // drain deferred until empty\n    while (deferred.length) {\n      fn = deferred.shift();\n\n      fn();\n    }\n  };\n\n  function handleProcess(process, context) {\n    handleFlowElementsContainer(process, context);\n    handleIoSpecification(process.ioSpecification, context);\n\n    handleArtifacts(process.artifacts, context);\n\n    // log process handled\n    handled(process);\n  }\n\n  function handleUnhandledProcesses(rootElements, ctx) {\n\n    // walk through all processes that have not yet been drawn and draw them\n    // if they contain lanes with DI information.\n    // we do this to pass the free-floating lane test cases in the MIWG test suite\n    var processes = filter(rootElements, function(e) {\n      return !isHandled(e) && is(e, 'bpmn:Process') && e.laneSets;\n    });\n\n    processes.forEach(contextual(handleProcess, ctx));\n  }\n\n  function handleMessageFlow(messageFlow, context) {\n    visitIfDi(messageFlow, context);\n  }\n\n  function handleMessageFlows(messageFlows, context) {\n    forEach(messageFlows, contextual(handleMessageFlow, context));\n  }\n\n  function handleDataAssociation(association, context) {\n    visitIfDi(association, context);\n  }\n\n  function handleDataInput(dataInput, context) {\n    visitIfDi(dataInput, context);\n  }\n\n  function handleDataOutput(dataOutput, context) {\n    visitIfDi(dataOutput, context);\n  }\n\n  function handleArtifact(artifact, context) {\n\n    // bpmn:TextAnnotation\n    // bpmn:Group\n    // bpmn:Association\n\n    visitIfDi(artifact, context);\n  }\n\n  function handleArtifacts(artifacts, context) {\n\n    forEach(artifacts, function(e) {\n      if (is(e, 'bpmn:Association')) {\n        deferred.push(function() {\n          handleArtifact(e, context);\n        });\n      } else {\n        handleArtifact(e, context);\n      }\n    });\n  }\n\n  function handleIoSpecification(ioSpecification, context) {\n\n    if (!ioSpecification) {\n      return;\n    }\n\n    forEach(ioSpecification.dataInputs, contextual(handleDataInput, context));\n    forEach(ioSpecification.dataOutputs, contextual(handleDataOutput, context));\n  }\n\n  var handleSubProcess = this.handleSubProcess = function handleSubProcess(subProcess, context) {\n    handleFlowElementsContainer(subProcess, context);\n    handleArtifacts(subProcess.artifacts, context);\n  };\n\n  function handleFlowNode(flowNode, context) {\n    var childCtx = visitIfDi(flowNode, context);\n\n    if (is(flowNode, 'bpmn:SubProcess')) {\n      handleSubProcess(flowNode, childCtx || context);\n    }\n\n    if (is(flowNode, 'bpmn:Activity')) {\n      handleIoSpecification(flowNode.ioSpecification, context);\n    }\n\n    // defer handling of associations\n    // affected types:\n    //\n    //   * bpmn:Activity\n    //   * bpmn:ThrowEvent\n    //   * bpmn:CatchEvent\n    //\n    deferred.push(function() {\n      forEach(flowNode.dataInputAssociations, contextual(handleDataAssociation, context));\n      forEach(flowNode.dataOutputAssociations, contextual(handleDataAssociation, context));\n    });\n  }\n\n  function handleSequenceFlow(sequenceFlow, context) {\n    visitIfDi(sequenceFlow, context);\n  }\n\n  function handleDataElement(dataObject, context) {\n    visitIfDi(dataObject, context);\n  }\n\n  function handleLane(lane, context) {\n\n    deferred.push(function() {\n\n      var newContext = visitIfDi(lane, context);\n\n      if (lane.childLaneSet) {\n        handleLaneSet(lane.childLaneSet, newContext || context);\n      }\n\n      wireFlowNodeRefs(lane);\n    });\n  }\n\n  function handleLaneSet(laneSet, context) {\n    forEach(laneSet.lanes, contextual(handleLane, context));\n  }\n\n  function handleLaneSets(laneSets, context) {\n    forEach(laneSets, contextual(handleLaneSet, context));\n  }\n\n  function handleFlowElementsContainer(container, context) {\n    handleFlowElements(container.flowElements, context);\n\n    if (container.laneSets) {\n      handleLaneSets(container.laneSets, context);\n    }\n  }\n\n  function handleFlowElements(flowElements, context) {\n    forEach(flowElements, function(flowElement) {\n      if (is(flowElement, 'bpmn:SequenceFlow')) {\n        deferred.push(function() {\n          handleSequenceFlow(flowElement, context);\n        });\n      } else if (is(flowElement, 'bpmn:BoundaryEvent')) {\n        deferred.unshift(function() {\n          handleFlowNode(flowElement, context);\n        });\n      } else if (is(flowElement, 'bpmn:FlowNode')) {\n        handleFlowNode(flowElement, context);\n      } else if (is(flowElement, 'bpmn:DataObject')) {\n\n        // SKIP (assume correct referencing via DataObjectReference)\n      } else if (is(flowElement, 'bpmn:DataStoreReference')) {\n        handleDataElement(flowElement, context);\n      } else if (is(flowElement, 'bpmn:DataObjectReference')) {\n        handleDataElement(flowElement, context);\n      } else {\n        logError(\n          `unrecognized flowElement ${ elementToString(flowElement) } in context ${ elementToString(context && context.businessObject) }`,\n          {\n            element: flowElement,\n            context\n          }\n        );\n      }\n    });\n  }\n\n  function handleParticipant(participant, context) {\n    var newCtx = visitIfDi(participant, context);\n\n    var process = participant.processRef;\n    if (process) {\n      handleProcess(process, newCtx || context);\n    }\n  }\n\n  function handleCollaboration(collaboration, context) {\n\n    forEach(collaboration.participants, contextual(handleParticipant, context));\n\n    deferred.push(function() {\n      handleMessageFlows(collaboration.messageFlows, context);\n    });\n\n    handleArtifacts(collaboration.artifacts, context);\n  }\n\n\n  function wireFlowNodeRefs(lane) {\n\n    // wire the virtual flowNodeRefs <-> relationship\n    forEach(lane.flowNodeRef, function(flowNode) {\n      var lanes = flowNode.get('lanes');\n\n      if (lanes) {\n        lanes.push(lane);\n      }\n    });\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}