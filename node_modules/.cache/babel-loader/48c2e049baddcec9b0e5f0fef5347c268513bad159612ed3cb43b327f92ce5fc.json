{"ast":null,"code":"import { closest as domClosest } from 'min-dom';\nimport { toPoint } from '../../util/Event';\n\n/**\n * @typedef {import('didi').Injector} Injector\n *\n * @typedef {import('../../core/ElementRegistry').default} ElementRegistry\n * @typedef {import('../../core/EventBus').default} EventBus\n */\n\nvar HIGH_PRIORITY = 1500;\n\n/**\n * Browsers may swallow certain events (hover, out ...) if users are to\n * fast with the mouse.\n *\n * @see http://stackoverflow.com/questions/7448468/why-cant-i-reliably-capture-a-mouseout-event\n *\n * The fix implemented in this component ensure that we\n *\n * 1) have a hover state after a successful drag.move event\n * 2) have an out event when dragging leaves an element\n *\n * @param {ElementRegistry} elementRegistry\n * @param {EventBus} eventBus\n * @param {Injector} injector\n */\nexport default function HoverFix(elementRegistry, eventBus, injector) {\n  var self = this;\n  var dragging = injector.get('dragging', false);\n\n  /**\n   * Make sure we are god damn hovering!\n   *\n   * @param {Event} dragging event\n   */\n  function ensureHover(event) {\n    if (event.hover) {\n      return;\n    }\n    var originalEvent = event.originalEvent;\n    var gfx = self._findTargetGfx(originalEvent);\n    var element = gfx && elementRegistry.get(gfx);\n    if (gfx && element) {\n      // 1) cancel current mousemove\n      event.stopPropagation();\n\n      // 2) emit fake hover for new target\n      dragging.hover({\n        element: element,\n        gfx: gfx\n      });\n\n      // 3) re-trigger move event\n      dragging.move(originalEvent);\n    }\n  }\n  if (dragging) {\n    /**\n     * We wait for a specific sequence of events before\n     * emitting a fake drag.hover event.\n     *\n     * Event Sequence:\n     *\n     * drag.start\n     * drag.move >> ensure we are hovering\n     */\n    eventBus.on('drag.start', function (event) {\n      eventBus.once('drag.move', HIGH_PRIORITY, function (event) {\n        ensureHover(event);\n      });\n    });\n  }\n\n  /**\n   * We make sure that element.out is always fired, even if the\n   * browser swallows an element.out event.\n   *\n   * Event sequence:\n   *\n   * element.hover\n   * (element.out >> sometimes swallowed)\n   * element.hover >> ensure we fired element.out\n   */\n  (function () {\n    var hoverGfx;\n    var hover;\n    eventBus.on('element.hover', function (event) {\n      // (1) remember current hover element\n      hoverGfx = event.gfx;\n      hover = event.element;\n    });\n    eventBus.on('element.hover', HIGH_PRIORITY, function (event) {\n      // (3) am I on an element still?\n      if (hover) {\n        // (4) that is a problem, gotta \"simulate the out\"\n        eventBus.fire('element.out', {\n          element: hover,\n          gfx: hoverGfx\n        });\n      }\n    });\n    eventBus.on('element.out', function () {\n      // (2) unset hover state if we correctly outed us *GG*\n      hoverGfx = null;\n      hover = null;\n    });\n  })();\n  this._findTargetGfx = function (event) {\n    var position, target;\n    if (!(event instanceof MouseEvent)) {\n      return;\n    }\n    position = toPoint(event);\n\n    // damn expensive operation, ouch!\n    target = document.elementFromPoint(position.x, position.y);\n    return getGfx(target);\n  };\n}\nHoverFix.$inject = ['elementRegistry', 'eventBus', 'injector'];\n\n// helpers /////////////////////\n\nfunction getGfx(target) {\n  return domClosest(target, 'svg, .djs-element', true);\n}","map":{"version":3,"names":["closest","domClosest","toPoint","HIGH_PRIORITY","HoverFix","elementRegistry","eventBus","injector","self","dragging","get","ensureHover","event","hover","originalEvent","gfx","_findTargetGfx","element","stopPropagation","move","on","once","hoverGfx","fire","position","target","MouseEvent","document","elementFromPoint","x","y","getGfx","$inject"],"sources":["/home/runner/work/sgex/sgex/node_modules/diagram-js/lib/features/hover-fix/HoverFix.js"],"sourcesContent":["import {\n  closest as domClosest\n} from 'min-dom';\n\nimport {\n  toPoint\n} from '../../util/Event';\n\n/**\n * @typedef {import('didi').Injector} Injector\n *\n * @typedef {import('../../core/ElementRegistry').default} ElementRegistry\n * @typedef {import('../../core/EventBus').default} EventBus\n */\n\nvar HIGH_PRIORITY = 1500;\n\n\n/**\n * Browsers may swallow certain events (hover, out ...) if users are to\n * fast with the mouse.\n *\n * @see http://stackoverflow.com/questions/7448468/why-cant-i-reliably-capture-a-mouseout-event\n *\n * The fix implemented in this component ensure that we\n *\n * 1) have a hover state after a successful drag.move event\n * 2) have an out event when dragging leaves an element\n *\n * @param {ElementRegistry} elementRegistry\n * @param {EventBus} eventBus\n * @param {Injector} injector\n */\nexport default function HoverFix(elementRegistry, eventBus, injector) {\n\n  var self = this;\n\n  var dragging = injector.get('dragging', false);\n\n  /**\n   * Make sure we are god damn hovering!\n   *\n   * @param {Event} dragging event\n   */\n  function ensureHover(event) {\n\n    if (event.hover) {\n      return;\n    }\n\n    var originalEvent = event.originalEvent;\n\n    var gfx = self._findTargetGfx(originalEvent);\n\n    var element = gfx && elementRegistry.get(gfx);\n\n    if (gfx && element) {\n\n      // 1) cancel current mousemove\n      event.stopPropagation();\n\n      // 2) emit fake hover for new target\n      dragging.hover({ element: element, gfx: gfx });\n\n      // 3) re-trigger move event\n      dragging.move(originalEvent);\n    }\n  }\n\n\n  if (dragging) {\n\n    /**\n     * We wait for a specific sequence of events before\n     * emitting a fake drag.hover event.\n     *\n     * Event Sequence:\n     *\n     * drag.start\n     * drag.move >> ensure we are hovering\n     */\n    eventBus.on('drag.start', function(event) {\n\n      eventBus.once('drag.move', HIGH_PRIORITY, function(event) {\n\n        ensureHover(event);\n\n      });\n\n    });\n  }\n\n\n  /**\n   * We make sure that element.out is always fired, even if the\n   * browser swallows an element.out event.\n   *\n   * Event sequence:\n   *\n   * element.hover\n   * (element.out >> sometimes swallowed)\n   * element.hover >> ensure we fired element.out\n   */\n  (function() {\n    var hoverGfx;\n    var hover;\n\n    eventBus.on('element.hover', function(event) {\n\n      // (1) remember current hover element\n      hoverGfx = event.gfx;\n      hover = event.element;\n    });\n\n    eventBus.on('element.hover', HIGH_PRIORITY, function(event) {\n\n      // (3) am I on an element still?\n      if (hover) {\n\n        // (4) that is a problem, gotta \"simulate the out\"\n        eventBus.fire('element.out', {\n          element: hover,\n          gfx: hoverGfx\n        });\n      }\n\n    });\n\n    eventBus.on('element.out', function() {\n\n      // (2) unset hover state if we correctly outed us *GG*\n      hoverGfx = null;\n      hover = null;\n    });\n\n  })();\n\n  this._findTargetGfx = function(event) {\n    var position,\n        target;\n\n    if (!(event instanceof MouseEvent)) {\n      return;\n    }\n\n    position = toPoint(event);\n\n    // damn expensive operation, ouch!\n    target = document.elementFromPoint(position.x, position.y);\n\n    return getGfx(target);\n  };\n\n}\n\nHoverFix.$inject = [\n  'elementRegistry',\n  'eventBus',\n  'injector'\n];\n\n\n// helpers /////////////////////\n\nfunction getGfx(target) {\n  return domClosest(target, 'svg, .djs-element', true);\n}"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}