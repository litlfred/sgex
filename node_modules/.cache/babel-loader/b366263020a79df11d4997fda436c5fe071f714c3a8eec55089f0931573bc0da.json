{"ast":null,"code":"import { getNewAttachPoint } from '../../../../util/AttachUtil';\nimport { getOrientation } from '../../../../layout/LayoutUtil';\nimport { filter, map } from 'min-dash';\n\n/**\n * @typedef {import('../../../../core/Types').ConnectionLike} Connection\n * @typedef {import('../../../../core/Types').ShapeLike} Shape\n *\n * @typedef {import('../../../../util/Types').Point} Point\n * @typedef {import('../../../../util/Types').Rect} Rect\n */\n\n/**\n * @param {Connection} connection\n * @param {Shape} shape\n * @param {Rect} oldBounds\n * @return {Point}\n */\nexport function getResizedSourceAnchor(connection, shape, oldBounds) {\n  var waypoints = safeGetWaypoints(connection),\n    waypointsInsideNewBounds = getWaypointsInsideBounds(waypoints, shape),\n    oldAnchor = waypoints[0];\n\n  // new anchor is the last waypoint enclosed be resized source\n  if (waypointsInsideNewBounds.length) {\n    return waypointsInsideNewBounds[waypointsInsideNewBounds.length - 1];\n  }\n  return getNewAttachPoint(oldAnchor.original || oldAnchor, oldBounds, shape);\n}\nexport function getResizedTargetAnchor(connection, shape, oldBounds) {\n  var waypoints = safeGetWaypoints(connection),\n    waypointsInsideNewBounds = getWaypointsInsideBounds(waypoints, shape),\n    oldAnchor = waypoints[waypoints.length - 1];\n\n  // new anchor is the first waypoint enclosed be resized target\n  if (waypointsInsideNewBounds.length) {\n    return waypointsInsideNewBounds[0];\n  }\n  return getNewAttachPoint(oldAnchor.original || oldAnchor, oldBounds, shape);\n}\nexport function getMovedSourceAnchor(connection, source, moveDelta) {\n  var waypoints = safeGetWaypoints(connection),\n    oldBounds = subtract(source, moveDelta),\n    oldAnchor = waypoints[0];\n  return getNewAttachPoint(oldAnchor.original || oldAnchor, oldBounds, source);\n}\nexport function getMovedTargetAnchor(connection, target, moveDelta) {\n  var waypoints = safeGetWaypoints(connection),\n    oldBounds = subtract(target, moveDelta),\n    oldAnchor = waypoints[waypoints.length - 1];\n  return getNewAttachPoint(oldAnchor.original || oldAnchor, oldBounds, target);\n}\n\n// helpers //////////////////////\n\nfunction subtract(bounds, delta) {\n  return {\n    x: bounds.x - delta.x,\n    y: bounds.y - delta.y,\n    width: bounds.width,\n    height: bounds.height\n  };\n}\n\n/**\n * Return waypoints of given connection; throw if non exists (should not happen!!).\n *\n * @param {Connection} connection\n *\n * @return {Point[]}\n */\nfunction safeGetWaypoints(connection) {\n  var waypoints = connection.waypoints;\n  if (!waypoints.length) {\n    throw new Error('connection#' + connection.id + ': no waypoints');\n  }\n  return waypoints;\n}\nfunction getWaypointsInsideBounds(waypoints, bounds) {\n  var originalWaypoints = map(waypoints, getOriginal);\n  return filter(originalWaypoints, function (waypoint) {\n    return isInsideBounds(waypoint, bounds);\n  });\n}\n\n/**\n * Checks if point is inside bounds, incl. edges.\n *\n * @param {Point} point\n * @param {Rect} bounds\n */\nfunction isInsideBounds(point, bounds) {\n  return getOrientation(bounds, point, 1) === 'intersect';\n}\nfunction getOriginal(point) {\n  return point.original || point;\n}","map":{"version":3,"names":["getNewAttachPoint","getOrientation","filter","map","getResizedSourceAnchor","connection","shape","oldBounds","waypoints","safeGetWaypoints","waypointsInsideNewBounds","getWaypointsInsideBounds","oldAnchor","length","original","getResizedTargetAnchor","getMovedSourceAnchor","source","moveDelta","subtract","getMovedTargetAnchor","target","bounds","delta","x","y","width","height","Error","id","originalWaypoints","getOriginal","waypoint","isInsideBounds","point"],"sources":["/home/runner/work/sgex/sgex/node_modules/diagram-js/lib/features/modeling/cmd/helper/AnchorsHelper.js"],"sourcesContent":["import {\n  getNewAttachPoint\n} from '../../../../util/AttachUtil';\n\nimport {\n  getOrientation\n} from '../../../../layout/LayoutUtil';\n\nimport {\n  filter,\n  map\n} from 'min-dash';\n\n/**\n * @typedef {import('../../../../core/Types').ConnectionLike} Connection\n * @typedef {import('../../../../core/Types').ShapeLike} Shape\n *\n * @typedef {import('../../../../util/Types').Point} Point\n * @typedef {import('../../../../util/Types').Rect} Rect\n */\n\n/**\n * @param {Connection} connection\n * @param {Shape} shape\n * @param {Rect} oldBounds\n * @return {Point}\n */\nexport function getResizedSourceAnchor(connection, shape, oldBounds) {\n\n  var waypoints = safeGetWaypoints(connection),\n      waypointsInsideNewBounds = getWaypointsInsideBounds(waypoints, shape),\n      oldAnchor = waypoints[0];\n\n  // new anchor is the last waypoint enclosed be resized source\n  if (waypointsInsideNewBounds.length) {\n    return waypointsInsideNewBounds[ waypointsInsideNewBounds.length - 1 ];\n  }\n\n  return getNewAttachPoint(oldAnchor.original || oldAnchor, oldBounds, shape);\n}\n\n\nexport function getResizedTargetAnchor(connection, shape, oldBounds) {\n\n  var waypoints = safeGetWaypoints(connection),\n      waypointsInsideNewBounds = getWaypointsInsideBounds(waypoints, shape),\n      oldAnchor = waypoints[waypoints.length - 1];\n\n  // new anchor is the first waypoint enclosed be resized target\n  if (waypointsInsideNewBounds.length) {\n    return waypointsInsideNewBounds[ 0 ];\n  }\n\n  return getNewAttachPoint(oldAnchor.original || oldAnchor, oldBounds, shape);\n}\n\n\nexport function getMovedSourceAnchor(connection, source, moveDelta) {\n\n  var waypoints = safeGetWaypoints(connection),\n      oldBounds = subtract(source, moveDelta),\n      oldAnchor = waypoints[ 0 ];\n\n  return getNewAttachPoint(oldAnchor.original || oldAnchor, oldBounds, source);\n}\n\n\nexport function getMovedTargetAnchor(connection, target, moveDelta) {\n\n  var waypoints = safeGetWaypoints(connection),\n      oldBounds = subtract(target, moveDelta),\n      oldAnchor = waypoints[ waypoints.length - 1 ];\n\n  return getNewAttachPoint(oldAnchor.original || oldAnchor, oldBounds, target);\n}\n\n\n// helpers //////////////////////\n\nfunction subtract(bounds, delta) {\n  return {\n    x: bounds.x - delta.x,\n    y: bounds.y - delta.y,\n    width: bounds.width,\n    height: bounds.height\n  };\n}\n\n\n/**\n * Return waypoints of given connection; throw if non exists (should not happen!!).\n *\n * @param {Connection} connection\n *\n * @return {Point[]}\n */\nfunction safeGetWaypoints(connection) {\n\n  var waypoints = connection.waypoints;\n\n  if (!waypoints.length) {\n    throw new Error('connection#' + connection.id + ': no waypoints');\n  }\n\n  return waypoints;\n}\n\nfunction getWaypointsInsideBounds(waypoints, bounds) {\n  var originalWaypoints = map(waypoints, getOriginal);\n\n  return filter(originalWaypoints, function(waypoint) {\n    return isInsideBounds(waypoint, bounds);\n  });\n}\n\n/**\n * Checks if point is inside bounds, incl. edges.\n *\n * @param {Point} point\n * @param {Rect} bounds\n */\nfunction isInsideBounds(point, bounds) {\n  return getOrientation(bounds, point, 1) === 'intersect';\n}\n\nfunction getOriginal(point) {\n  return point.original || point;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}