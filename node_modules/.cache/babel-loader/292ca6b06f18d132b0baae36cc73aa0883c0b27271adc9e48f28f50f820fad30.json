{"ast":null,"code":"import { isObject, sortBy } from 'min-dash';\nimport { pointDistance, pointsOnLine } from '../util/Geometry';\nimport intersectPaths from 'path-intersection';\nimport { isConnection } from '../util/ModelUtil';\n\n/**\n * @typedef {import('../core/Types').ElementLike} Element\n * @typedef {import('../core/Types').ConnectionLike} Connection\n *\n * @typedef {import('../util/Types').DirectionTRBL} DirectionTRBL\n * @typedef {import('../util/Types').Intersection} Intersection\n * @typedef {import('../util/Types').Point} Point\n * @typedef {import('../util/Types').Rect} Rect\n * @typedef {import('../util/Types').RectTRBL} RectTRBL\n */\n\n/**\n * @param {Rect} bounds\n *\n * @returns {Rect}\n */\nexport function roundBounds(bounds) {\n  return {\n    x: Math.round(bounds.x),\n    y: Math.round(bounds.y),\n    width: Math.round(bounds.width),\n    height: Math.round(bounds.height)\n  };\n}\n\n/**\n * @param {Point} point\n *\n * @returns {Point}\n */\nexport function roundPoint(point) {\n  return {\n    x: Math.round(point.x),\n    y: Math.round(point.y)\n  };\n}\n\n/**\n * Convert the given bounds to a { top, left, bottom, right } descriptor.\n *\n * @param {Point|Rect} bounds\n *\n * @return {RectTRBL}\n */\nexport function asTRBL(bounds) {\n  return {\n    top: bounds.y,\n    right: bounds.x + (bounds.width || 0),\n    bottom: bounds.y + (bounds.height || 0),\n    left: bounds.x\n  };\n}\n\n/**\n * Convert a { top, left, bottom, right } to an objects bounds.\n *\n * @param {RectTRBL} trbl\n *\n * @return {Rect}\n */\nexport function asBounds(trbl) {\n  return {\n    x: trbl.left,\n    y: trbl.top,\n    width: trbl.right - trbl.left,\n    height: trbl.bottom - trbl.top\n  };\n}\n\n/**\n * Get the mid of the given bounds or point.\n *\n * @param {Point|Rect} bounds\n *\n * @return {Point}\n */\nexport function getBoundsMid(bounds) {\n  return roundPoint({\n    x: bounds.x + (bounds.width || 0) / 2,\n    y: bounds.y + (bounds.height || 0) / 2\n  });\n}\n\n/**\n * Get the mid of the given Connection.\n *\n * @param {Connection} connection\n *\n * @return {Point}\n */\nexport function getConnectionMid(connection) {\n  var waypoints = connection.waypoints;\n\n  // calculate total length and length of each segment\n  var parts = waypoints.reduce(function (parts, point, index) {\n    var lastPoint = waypoints[index - 1];\n    if (lastPoint) {\n      var lastPart = parts[parts.length - 1];\n      var startLength = lastPart && lastPart.endLength || 0;\n      var length = distance(lastPoint, point);\n      parts.push({\n        start: lastPoint,\n        end: point,\n        startLength: startLength,\n        endLength: startLength + length,\n        length: length\n      });\n    }\n    return parts;\n  }, []);\n  var totalLength = parts.reduce(function (length, part) {\n    return length + part.length;\n  }, 0);\n\n  // find which segement contains middle point\n  var midLength = totalLength / 2;\n  var i = 0;\n  var midSegment = parts[i];\n  while (midSegment.endLength < midLength) {\n    midSegment = parts[++i];\n  }\n\n  // calculate relative position on mid segment\n  var segmentProgress = (midLength - midSegment.startLength) / midSegment.length;\n  var midPoint = {\n    x: midSegment.start.x + (midSegment.end.x - midSegment.start.x) * segmentProgress,\n    y: midSegment.start.y + (midSegment.end.y - midSegment.start.y) * segmentProgress\n  };\n  return midPoint;\n}\n\n/**\n * Get the mid of the given Element.\n *\n * @param {Element} element\n *\n * @return {Point}\n */\nexport function getMid(element) {\n  if (isConnection(element)) {\n    return getConnectionMid(element);\n  }\n  return getBoundsMid(element);\n}\n\n// orientation utils //////////////////////\n\n/**\n * Get orientation of the given rectangle with respect to\n * the reference rectangle.\n *\n * A padding (positive or negative) may be passed to influence\n * horizontal / vertical orientation and intersection.\n *\n * @param {Rect} rect\n * @param {Rect} reference\n * @param {Point|number} padding\n *\n * @return {DirectionTRBL|Intersection} the orientation; one of top, top-left, left, ..., bottom, right or intersect.\n */\nexport function getOrientation(rect, reference, padding) {\n  padding = padding || 0;\n\n  // make sure we can use an object, too\n  // for individual { x, y } padding\n  if (!isObject(padding)) {\n    padding = {\n      x: padding,\n      y: padding\n    };\n  }\n  var rectOrientation = asTRBL(rect),\n    referenceOrientation = asTRBL(reference);\n  var top = rectOrientation.bottom + padding.y <= referenceOrientation.top,\n    right = rectOrientation.left - padding.x >= referenceOrientation.right,\n    bottom = rectOrientation.top - padding.y >= referenceOrientation.bottom,\n    left = rectOrientation.right + padding.x <= referenceOrientation.left;\n  var vertical = top ? 'top' : bottom ? 'bottom' : null,\n    horizontal = left ? 'left' : right ? 'right' : null;\n  if (horizontal && vertical) {\n    return vertical + '-' + horizontal;\n  } else {\n    return horizontal || vertical || 'intersect';\n  }\n}\n\n// intersection utils //////////////////////\n\n/**\n * Get intersection between an element and a line path.\n *\n * @param {string} elementPath\n * @param {string} linePath\n * @param {boolean} cropStart Whether to crop start or end.\n *\n * @return {Point}\n */\nexport function getElementLineIntersection(elementPath, linePath, cropStart) {\n  var intersections = getIntersections(elementPath, linePath);\n\n  // recognize intersections\n  // only one -> choose\n  // two close together -> choose first\n  // two or more distinct -> pull out appropriate one\n  // none -> ok (fallback to point itself)\n  if (intersections.length === 1) {\n    return roundPoint(intersections[0]);\n  } else if (intersections.length === 2 && pointDistance(intersections[0], intersections[1]) < 1) {\n    return roundPoint(intersections[0]);\n  } else if (intersections.length > 1) {\n    // sort by intersections based on connection segment +\n    // distance from start\n    intersections = sortBy(intersections, function (i) {\n      var distance = Math.floor(i.t2 * 100) || 1;\n      distance = 100 - distance;\n      distance = (distance < 10 ? '0' : '') + distance;\n\n      // create a sort string that makes sure we sort\n      // line segment ASC + line segment position DESC (for cropStart)\n      // line segment ASC + line segment position ASC (for cropEnd)\n      return i.segment2 + '#' + distance;\n    });\n    return roundPoint(intersections[cropStart ? 0 : intersections.length - 1]);\n  }\n  return null;\n}\nexport function getIntersections(a, b) {\n  return intersectPaths(a, b);\n}\nexport function filterRedundantWaypoints(waypoints) {\n  // alter copy of waypoints, not original\n  waypoints = waypoints.slice();\n  var idx = 0,\n    point,\n    previousPoint,\n    nextPoint;\n  while (waypoints[idx]) {\n    point = waypoints[idx];\n    previousPoint = waypoints[idx - 1];\n    nextPoint = waypoints[idx + 1];\n    if (pointDistance(point, nextPoint) === 0 || pointsOnLine(previousPoint, nextPoint, point)) {\n      // remove point, if overlapping with {nextPoint}\n      // or on line with {previousPoint} -> {point} -> {nextPoint}\n      waypoints.splice(idx, 1);\n    } else {\n      idx++;\n    }\n  }\n  return waypoints;\n}\n\n// helpers //////////////////////\n\nfunction distance(a, b) {\n  return Math.sqrt(Math.pow(a.x - b.x, 2) + Math.pow(a.y - b.y, 2));\n}","map":{"version":3,"names":["isObject","sortBy","pointDistance","pointsOnLine","intersectPaths","isConnection","roundBounds","bounds","x","Math","round","y","width","height","roundPoint","point","asTRBL","top","right","bottom","left","asBounds","trbl","getBoundsMid","getConnectionMid","connection","waypoints","parts","reduce","index","lastPoint","lastPart","length","startLength","endLength","distance","push","start","end","totalLength","part","midLength","i","midSegment","segmentProgress","midPoint","getMid","element","getOrientation","rect","reference","padding","rectOrientation","referenceOrientation","vertical","horizontal","getElementLineIntersection","elementPath","linePath","cropStart","intersections","getIntersections","floor","t2","segment2","a","b","filterRedundantWaypoints","slice","idx","previousPoint","nextPoint","splice","sqrt","pow"],"sources":["/home/runner/work/sgex/sgex/node_modules/diagram-js/lib/layout/LayoutUtil.js"],"sourcesContent":["import {\n  isObject,\n  sortBy\n} from 'min-dash';\n\nimport {\n  pointDistance,\n  pointsOnLine\n} from '../util/Geometry';\n\nimport intersectPaths from 'path-intersection';\n\nimport { isConnection } from '../util/ModelUtil';\n\n/**\n * @typedef {import('../core/Types').ElementLike} Element\n * @typedef {import('../core/Types').ConnectionLike} Connection\n *\n * @typedef {import('../util/Types').DirectionTRBL} DirectionTRBL\n * @typedef {import('../util/Types').Intersection} Intersection\n * @typedef {import('../util/Types').Point} Point\n * @typedef {import('../util/Types').Rect} Rect\n * @typedef {import('../util/Types').RectTRBL} RectTRBL\n */\n\n/**\n * @param {Rect} bounds\n *\n * @returns {Rect}\n */\nexport function roundBounds(bounds) {\n  return {\n    x: Math.round(bounds.x),\n    y: Math.round(bounds.y),\n    width: Math.round(bounds.width),\n    height: Math.round(bounds.height)\n  };\n}\n\n/**\n * @param {Point} point\n *\n * @returns {Point}\n */\nexport function roundPoint(point) {\n\n  return {\n    x: Math.round(point.x),\n    y: Math.round(point.y)\n  };\n}\n\n\n/**\n * Convert the given bounds to a { top, left, bottom, right } descriptor.\n *\n * @param {Point|Rect} bounds\n *\n * @return {RectTRBL}\n */\nexport function asTRBL(bounds) {\n  return {\n    top: bounds.y,\n    right: bounds.x + (bounds.width || 0),\n    bottom: bounds.y + (bounds.height || 0),\n    left: bounds.x\n  };\n}\n\n\n/**\n * Convert a { top, left, bottom, right } to an objects bounds.\n *\n * @param {RectTRBL} trbl\n *\n * @return {Rect}\n */\nexport function asBounds(trbl) {\n  return {\n    x: trbl.left,\n    y: trbl.top,\n    width: trbl.right - trbl.left,\n    height: trbl.bottom - trbl.top\n  };\n}\n\n\n/**\n * Get the mid of the given bounds or point.\n *\n * @param {Point|Rect} bounds\n *\n * @return {Point}\n */\nexport function getBoundsMid(bounds) {\n  return roundPoint({\n    x: bounds.x + (bounds.width || 0) / 2,\n    y: bounds.y + (bounds.height || 0) / 2\n  });\n}\n\n\n/**\n * Get the mid of the given Connection.\n *\n * @param {Connection} connection\n *\n * @return {Point}\n */\nexport function getConnectionMid(connection) {\n  var waypoints = connection.waypoints;\n\n  // calculate total length and length of each segment\n  var parts = waypoints.reduce(function(parts, point, index) {\n\n    var lastPoint = waypoints[index - 1];\n\n    if (lastPoint) {\n      var lastPart = parts[parts.length - 1];\n\n      var startLength = lastPart && lastPart.endLength || 0;\n      var length = distance(lastPoint, point);\n\n      parts.push({\n        start: lastPoint,\n        end: point,\n        startLength: startLength,\n        endLength: startLength + length,\n        length: length\n      });\n    }\n\n    return parts;\n  }, []);\n\n  var totalLength = parts.reduce(function(length, part) {\n    return length + part.length;\n  }, 0);\n\n  // find which segement contains middle point\n  var midLength = totalLength / 2;\n\n  var i = 0;\n  var midSegment = parts[i];\n\n  while (midSegment.endLength < midLength) {\n    midSegment = parts[++i];\n  }\n\n  // calculate relative position on mid segment\n  var segmentProgress = (midLength - midSegment.startLength) / midSegment.length;\n\n  var midPoint = {\n    x: midSegment.start.x + (midSegment.end.x - midSegment.start.x) * segmentProgress,\n    y: midSegment.start.y + (midSegment.end.y - midSegment.start.y) * segmentProgress\n  };\n\n  return midPoint;\n}\n\n\n/**\n * Get the mid of the given Element.\n *\n * @param {Element} element\n *\n * @return {Point}\n */\nexport function getMid(element) {\n  if (isConnection(element)) {\n    return getConnectionMid(element);\n  }\n\n  return getBoundsMid(element);\n}\n\n// orientation utils //////////////////////\n\n/**\n * Get orientation of the given rectangle with respect to\n * the reference rectangle.\n *\n * A padding (positive or negative) may be passed to influence\n * horizontal / vertical orientation and intersection.\n *\n * @param {Rect} rect\n * @param {Rect} reference\n * @param {Point|number} padding\n *\n * @return {DirectionTRBL|Intersection} the orientation; one of top, top-left, left, ..., bottom, right or intersect.\n */\nexport function getOrientation(rect, reference, padding) {\n\n  padding = padding || 0;\n\n  // make sure we can use an object, too\n  // for individual { x, y } padding\n  if (!isObject(padding)) {\n    padding = { x: padding, y: padding };\n  }\n\n\n  var rectOrientation = asTRBL(rect),\n      referenceOrientation = asTRBL(reference);\n\n  var top = rectOrientation.bottom + padding.y <= referenceOrientation.top,\n      right = rectOrientation.left - padding.x >= referenceOrientation.right,\n      bottom = rectOrientation.top - padding.y >= referenceOrientation.bottom,\n      left = rectOrientation.right + padding.x <= referenceOrientation.left;\n\n  var vertical = top ? 'top' : (bottom ? 'bottom' : null),\n      horizontal = left ? 'left' : (right ? 'right' : null);\n\n  if (horizontal && vertical) {\n    return vertical + '-' + horizontal;\n  } else {\n    return horizontal || vertical || 'intersect';\n  }\n}\n\n\n// intersection utils //////////////////////\n\n/**\n * Get intersection between an element and a line path.\n *\n * @param {string} elementPath\n * @param {string} linePath\n * @param {boolean} cropStart Whether to crop start or end.\n *\n * @return {Point}\n */\nexport function getElementLineIntersection(elementPath, linePath, cropStart) {\n\n  var intersections = getIntersections(elementPath, linePath);\n\n  // recognize intersections\n  // only one -> choose\n  // two close together -> choose first\n  // two or more distinct -> pull out appropriate one\n  // none -> ok (fallback to point itself)\n  if (intersections.length === 1) {\n    return roundPoint(intersections[0]);\n  } else if (intersections.length === 2 && pointDistance(intersections[0], intersections[1]) < 1) {\n    return roundPoint(intersections[0]);\n  } else if (intersections.length > 1) {\n\n    // sort by intersections based on connection segment +\n    // distance from start\n    intersections = sortBy(intersections, function(i) {\n      var distance = Math.floor(i.t2 * 100) || 1;\n\n      distance = 100 - distance;\n\n      distance = (distance < 10 ? '0' : '') + distance;\n\n      // create a sort string that makes sure we sort\n      // line segment ASC + line segment position DESC (for cropStart)\n      // line segment ASC + line segment position ASC (for cropEnd)\n      return i.segment2 + '#' + distance;\n    });\n\n    return roundPoint(intersections[cropStart ? 0 : intersections.length - 1]);\n  }\n\n  return null;\n}\n\n\nexport function getIntersections(a, b) {\n  return intersectPaths(a, b);\n}\n\n\nexport function filterRedundantWaypoints(waypoints) {\n\n  // alter copy of waypoints, not original\n  waypoints = waypoints.slice();\n\n  var idx = 0,\n      point,\n      previousPoint,\n      nextPoint;\n\n  while (waypoints[idx]) {\n    point = waypoints[idx];\n    previousPoint = waypoints[idx - 1];\n    nextPoint = waypoints[idx + 1];\n\n    if (pointDistance(point, nextPoint) === 0 ||\n        pointsOnLine(previousPoint, nextPoint, point)) {\n\n      // remove point, if overlapping with {nextPoint}\n      // or on line with {previousPoint} -> {point} -> {nextPoint}\n      waypoints.splice(idx, 1);\n    } else {\n      idx++;\n    }\n  }\n\n  return waypoints;\n}\n\n// helpers //////////////////////\n\nfunction distance(a, b) {\n  return Math.sqrt(Math.pow(a.x - b.x, 2) + Math.pow(a.y - b.y, 2));\n}"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}