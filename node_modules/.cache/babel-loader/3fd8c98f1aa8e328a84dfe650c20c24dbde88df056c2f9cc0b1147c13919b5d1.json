{"ast":null,"code":"import { forEach, find, matchPattern } from 'min-dash';\nimport inherits from 'inherits-browser';\nimport CommandInterceptor from 'diagram-js/lib/command/CommandInterceptor';\nimport { is } from '../../../util/ModelUtil';\n\n/**\n * @typedef {import('diagram-js/lib/core/EventBus').default} EventBus\n * @typedef {import('../Modeling').default} Modeling\n * @typedef {import('../../rules/BpmnRules').default} BpmnRules\n * @typedef {import('didi').Injector} Injector\n */\n\n/**\n * @param {EventBus} eventBus\n * @param {Modeling} modeling\n * @param {BpmnRules} bpmnRules\n * @param {Injector} injector\n */\nexport default function ReplaceConnectionBehavior(eventBus, modeling, bpmnRules, injector) {\n  CommandInterceptor.call(this, eventBus);\n  var dragging = injector.get('dragging', false);\n  function fixConnection(connection) {\n    var source = connection.source,\n      target = connection.target,\n      parent = connection.parent;\n\n    // do not do anything if connection\n    // is already deleted (may happen due to other\n    // behaviors plugged-in before)\n    if (!parent) {\n      return;\n    }\n    var replacementType, remove;\n\n    /**\n     * Check if incoming or outgoing connections\n     * can stay or could be substituted with an\n     * appropriate replacement.\n     *\n     * This holds true for SequenceFlow <> MessageFlow.\n     */\n\n    if (is(connection, 'bpmn:SequenceFlow')) {\n      if (!bpmnRules.canConnectSequenceFlow(source, target)) {\n        remove = true;\n      }\n      if (bpmnRules.canConnectMessageFlow(source, target)) {\n        replacementType = 'bpmn:MessageFlow';\n      }\n    }\n\n    // transform message flows into sequence flows, if possible\n\n    if (is(connection, 'bpmn:MessageFlow')) {\n      if (!bpmnRules.canConnectMessageFlow(source, target)) {\n        remove = true;\n      }\n      if (bpmnRules.canConnectSequenceFlow(source, target)) {\n        replacementType = 'bpmn:SequenceFlow';\n      }\n    }\n\n    // remove invalid connection,\n    // unless it has been removed already\n    if (remove) {\n      modeling.removeConnection(connection);\n    }\n\n    // replace SequenceFlow <> MessageFlow\n\n    if (replacementType) {\n      modeling.connect(source, target, {\n        type: replacementType,\n        waypoints: connection.waypoints.slice()\n      });\n    }\n  }\n  function replaceReconnectedConnection(event) {\n    var context = event.context,\n      connection = context.connection,\n      source = context.newSource || connection.source,\n      target = context.newTarget || connection.target,\n      allowed,\n      replacement;\n    allowed = bpmnRules.canConnect(source, target);\n    if (!allowed || allowed.type === connection.type) {\n      return;\n    }\n    replacement = modeling.connect(source, target, {\n      type: allowed.type,\n      associationDirection: allowed.associationDirection,\n      waypoints: connection.waypoints.slice()\n    });\n\n    // remove old connection unless it's already removed\n    if (connection.parent) {\n      modeling.removeConnection(connection);\n    }\n\n    // replace connection in context to reconnect end/start\n    context.connection = replacement;\n    if (dragging) {\n      cleanDraggingSelection(connection, replacement);\n    }\n  }\n\n  // monkey-patch selection saved in dragging in order to re-select it when operation is finished\n  function cleanDraggingSelection(oldConnection, newConnection) {\n    var context = dragging.context(),\n      previousSelection = context && context.payload.previousSelection,\n      index;\n\n    // do nothing if not dragging or no selection was present\n    if (!previousSelection || !previousSelection.length) {\n      return;\n    }\n    index = previousSelection.indexOf(oldConnection);\n    if (index === -1) {\n      return;\n    }\n    previousSelection.splice(index, 1, newConnection);\n  }\n\n  // lifecycle hooks\n\n  this.postExecuted('elements.move', function (context) {\n    var closure = context.closure,\n      allConnections = closure.allConnections;\n    forEach(allConnections, fixConnection);\n  }, true);\n  this.preExecute('connection.reconnect', replaceReconnectedConnection);\n  this.postExecuted('element.updateProperties', function (event) {\n    var context = event.context,\n      properties = context.properties,\n      element = context.element,\n      businessObject = element.businessObject,\n      connection;\n\n    // remove condition on change to default\n    if (properties.default) {\n      connection = find(element.outgoing, matchPattern({\n        id: element.businessObject.default.id\n      }));\n      if (connection) {\n        modeling.updateProperties(connection, {\n          conditionExpression: undefined\n        });\n      }\n    }\n\n    // remove default from source on change to conditional\n    if (properties.conditionExpression && businessObject.sourceRef.default === businessObject) {\n      modeling.updateProperties(element.source, {\n        default: undefined\n      });\n    }\n  });\n}\ninherits(ReplaceConnectionBehavior, CommandInterceptor);\nReplaceConnectionBehavior.$inject = ['eventBus', 'modeling', 'bpmnRules', 'injector'];","map":{"version":3,"names":["forEach","find","matchPattern","inherits","CommandInterceptor","is","ReplaceConnectionBehavior","eventBus","modeling","bpmnRules","injector","call","dragging","get","fixConnection","connection","source","target","parent","replacementType","remove","canConnectSequenceFlow","canConnectMessageFlow","removeConnection","connect","type","waypoints","slice","replaceReconnectedConnection","event","context","newSource","newTarget","allowed","replacement","canConnect","associationDirection","cleanDraggingSelection","oldConnection","newConnection","previousSelection","payload","index","length","indexOf","splice","postExecuted","closure","allConnections","preExecute","properties","element","businessObject","default","outgoing","id","updateProperties","conditionExpression","undefined","sourceRef","$inject"],"sources":["/home/runner/work/sgex/sgex/node_modules/bpmn-js/lib/features/modeling/behavior/ReplaceConnectionBehavior.js"],"sourcesContent":["import {\n  forEach,\n  find,\n  matchPattern\n} from 'min-dash';\n\nimport inherits from 'inherits-browser';\n\nimport CommandInterceptor from 'diagram-js/lib/command/CommandInterceptor';\n\nimport { is } from '../../../util/ModelUtil';\n\n/**\n * @typedef {import('diagram-js/lib/core/EventBus').default} EventBus\n * @typedef {import('../Modeling').default} Modeling\n * @typedef {import('../../rules/BpmnRules').default} BpmnRules\n * @typedef {import('didi').Injector} Injector\n */\n\n/**\n * @param {EventBus} eventBus\n * @param {Modeling} modeling\n * @param {BpmnRules} bpmnRules\n * @param {Injector} injector\n */\nexport default function ReplaceConnectionBehavior(eventBus, modeling, bpmnRules, injector) {\n\n  CommandInterceptor.call(this, eventBus);\n\n  var dragging = injector.get('dragging', false);\n\n  function fixConnection(connection) {\n\n    var source = connection.source,\n        target = connection.target,\n        parent = connection.parent;\n\n    // do not do anything if connection\n    // is already deleted (may happen due to other\n    // behaviors plugged-in before)\n    if (!parent) {\n      return;\n    }\n\n    var replacementType,\n        remove;\n\n    /**\n     * Check if incoming or outgoing connections\n     * can stay or could be substituted with an\n     * appropriate replacement.\n     *\n     * This holds true for SequenceFlow <> MessageFlow.\n     */\n\n    if (is(connection, 'bpmn:SequenceFlow')) {\n      if (!bpmnRules.canConnectSequenceFlow(source, target)) {\n        remove = true;\n      }\n\n      if (bpmnRules.canConnectMessageFlow(source, target)) {\n        replacementType = 'bpmn:MessageFlow';\n      }\n    }\n\n    // transform message flows into sequence flows, if possible\n\n    if (is(connection, 'bpmn:MessageFlow')) {\n\n      if (!bpmnRules.canConnectMessageFlow(source, target)) {\n        remove = true;\n      }\n\n      if (bpmnRules.canConnectSequenceFlow(source, target)) {\n        replacementType = 'bpmn:SequenceFlow';\n      }\n    }\n\n    // remove invalid connection,\n    // unless it has been removed already\n    if (remove) {\n      modeling.removeConnection(connection);\n    }\n\n    // replace SequenceFlow <> MessageFlow\n\n    if (replacementType) {\n      modeling.connect(source, target, {\n        type: replacementType,\n        waypoints: connection.waypoints.slice()\n      });\n    }\n  }\n\n  function replaceReconnectedConnection(event) {\n\n    var context = event.context,\n        connection = context.connection,\n        source = context.newSource || connection.source,\n        target = context.newTarget || connection.target,\n        allowed,\n        replacement;\n\n    allowed = bpmnRules.canConnect(source, target);\n\n    if (!allowed || allowed.type === connection.type) {\n      return;\n    }\n\n    replacement = modeling.connect(source, target, {\n      type: allowed.type,\n      associationDirection: allowed.associationDirection,\n      waypoints: connection.waypoints.slice()\n    });\n\n    // remove old connection unless it's already removed\n    if (connection.parent) {\n      modeling.removeConnection(connection);\n    }\n\n    // replace connection in context to reconnect end/start\n    context.connection = replacement;\n\n    if (dragging) {\n      cleanDraggingSelection(connection, replacement);\n    }\n  }\n\n  // monkey-patch selection saved in dragging in order to re-select it when operation is finished\n  function cleanDraggingSelection(oldConnection, newConnection) {\n    var context = dragging.context(),\n        previousSelection = context && context.payload.previousSelection,\n        index;\n\n    // do nothing if not dragging or no selection was present\n    if (!previousSelection || !previousSelection.length) {\n      return;\n    }\n\n    index = previousSelection.indexOf(oldConnection);\n\n    if (index === -1) {\n      return;\n    }\n\n    previousSelection.splice(index, 1, newConnection);\n  }\n\n  // lifecycle hooks\n\n  this.postExecuted('elements.move', function(context) {\n\n    var closure = context.closure,\n        allConnections = closure.allConnections;\n\n    forEach(allConnections, fixConnection);\n  }, true);\n\n  this.preExecute('connection.reconnect', replaceReconnectedConnection);\n\n  this.postExecuted('element.updateProperties', function(event) {\n    var context = event.context,\n        properties = context.properties,\n        element = context.element,\n        businessObject = element.businessObject,\n        connection;\n\n    // remove condition on change to default\n    if (properties.default) {\n      connection = find(\n        element.outgoing,\n        matchPattern({ id: element.businessObject.default.id })\n      );\n\n      if (connection) {\n        modeling.updateProperties(connection, { conditionExpression: undefined });\n      }\n    }\n\n    // remove default from source on change to conditional\n    if (properties.conditionExpression && businessObject.sourceRef.default === businessObject) {\n      modeling.updateProperties(element.source, { default: undefined });\n    }\n  });\n}\n\ninherits(ReplaceConnectionBehavior, CommandInterceptor);\n\nReplaceConnectionBehavior.$inject = [\n  'eventBus',\n  'modeling',\n  'bpmnRules',\n  'injector'\n];\n"],"mappings":"AAAA,SACEA,OAAO,EACPC,IAAI,EACJC,YAAY,QACP,UAAU;AAEjB,OAAOC,QAAQ,MAAM,kBAAkB;AAEvC,OAAOC,kBAAkB,MAAM,2CAA2C;AAE1E,SAASC,EAAE,QAAQ,yBAAyB;;AAE5C;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,SAASC,yBAAyBA,CAACC,QAAQ,EAAEC,QAAQ,EAAEC,SAAS,EAAEC,QAAQ,EAAE;EAEzFN,kBAAkB,CAACO,IAAI,CAAC,IAAI,EAAEJ,QAAQ,CAAC;EAEvC,IAAIK,QAAQ,GAAGF,QAAQ,CAACG,GAAG,CAAC,UAAU,EAAE,KAAK,CAAC;EAE9C,SAASC,aAAaA,CAACC,UAAU,EAAE;IAEjC,IAAIC,MAAM,GAAGD,UAAU,CAACC,MAAM;MAC1BC,MAAM,GAAGF,UAAU,CAACE,MAAM;MAC1BC,MAAM,GAAGH,UAAU,CAACG,MAAM;;IAE9B;IACA;IACA;IACA,IAAI,CAACA,MAAM,EAAE;MACX;IACF;IAEA,IAAIC,eAAe,EACfC,MAAM;;IAEV;AACJ;AACA;AACA;AACA;AACA;AACA;;IAEI,IAAIf,EAAE,CAACU,UAAU,EAAE,mBAAmB,CAAC,EAAE;MACvC,IAAI,CAACN,SAAS,CAACY,sBAAsB,CAACL,MAAM,EAAEC,MAAM,CAAC,EAAE;QACrDG,MAAM,GAAG,IAAI;MACf;MAEA,IAAIX,SAAS,CAACa,qBAAqB,CAACN,MAAM,EAAEC,MAAM,CAAC,EAAE;QACnDE,eAAe,GAAG,kBAAkB;MACtC;IACF;;IAEA;;IAEA,IAAId,EAAE,CAACU,UAAU,EAAE,kBAAkB,CAAC,EAAE;MAEtC,IAAI,CAACN,SAAS,CAACa,qBAAqB,CAACN,MAAM,EAAEC,MAAM,CAAC,EAAE;QACpDG,MAAM,GAAG,IAAI;MACf;MAEA,IAAIX,SAAS,CAACY,sBAAsB,CAACL,MAAM,EAAEC,MAAM,CAAC,EAAE;QACpDE,eAAe,GAAG,mBAAmB;MACvC;IACF;;IAEA;IACA;IACA,IAAIC,MAAM,EAAE;MACVZ,QAAQ,CAACe,gBAAgB,CAACR,UAAU,CAAC;IACvC;;IAEA;;IAEA,IAAII,eAAe,EAAE;MACnBX,QAAQ,CAACgB,OAAO,CAACR,MAAM,EAAEC,MAAM,EAAE;QAC/BQ,IAAI,EAAEN,eAAe;QACrBO,SAAS,EAAEX,UAAU,CAACW,SAAS,CAACC,KAAK,CAAC;MACxC,CAAC,CAAC;IACJ;EACF;EAEA,SAASC,4BAA4BA,CAACC,KAAK,EAAE;IAE3C,IAAIC,OAAO,GAAGD,KAAK,CAACC,OAAO;MACvBf,UAAU,GAAGe,OAAO,CAACf,UAAU;MAC/BC,MAAM,GAAGc,OAAO,CAACC,SAAS,IAAIhB,UAAU,CAACC,MAAM;MAC/CC,MAAM,GAAGa,OAAO,CAACE,SAAS,IAAIjB,UAAU,CAACE,MAAM;MAC/CgB,OAAO;MACPC,WAAW;IAEfD,OAAO,GAAGxB,SAAS,CAAC0B,UAAU,CAACnB,MAAM,EAAEC,MAAM,CAAC;IAE9C,IAAI,CAACgB,OAAO,IAAIA,OAAO,CAACR,IAAI,KAAKV,UAAU,CAACU,IAAI,EAAE;MAChD;IACF;IAEAS,WAAW,GAAG1B,QAAQ,CAACgB,OAAO,CAACR,MAAM,EAAEC,MAAM,EAAE;MAC7CQ,IAAI,EAAEQ,OAAO,CAACR,IAAI;MAClBW,oBAAoB,EAAEH,OAAO,CAACG,oBAAoB;MAClDV,SAAS,EAAEX,UAAU,CAACW,SAAS,CAACC,KAAK,CAAC;IACxC,CAAC,CAAC;;IAEF;IACA,IAAIZ,UAAU,CAACG,MAAM,EAAE;MACrBV,QAAQ,CAACe,gBAAgB,CAACR,UAAU,CAAC;IACvC;;IAEA;IACAe,OAAO,CAACf,UAAU,GAAGmB,WAAW;IAEhC,IAAItB,QAAQ,EAAE;MACZyB,sBAAsB,CAACtB,UAAU,EAAEmB,WAAW,CAAC;IACjD;EACF;;EAEA;EACA,SAASG,sBAAsBA,CAACC,aAAa,EAAEC,aAAa,EAAE;IAC5D,IAAIT,OAAO,GAAGlB,QAAQ,CAACkB,OAAO,CAAC,CAAC;MAC5BU,iBAAiB,GAAGV,OAAO,IAAIA,OAAO,CAACW,OAAO,CAACD,iBAAiB;MAChEE,KAAK;;IAET;IACA,IAAI,CAACF,iBAAiB,IAAI,CAACA,iBAAiB,CAACG,MAAM,EAAE;MACnD;IACF;IAEAD,KAAK,GAAGF,iBAAiB,CAACI,OAAO,CAACN,aAAa,CAAC;IAEhD,IAAII,KAAK,KAAK,CAAC,CAAC,EAAE;MAChB;IACF;IAEAF,iBAAiB,CAACK,MAAM,CAACH,KAAK,EAAE,CAAC,EAAEH,aAAa,CAAC;EACnD;;EAEA;;EAEA,IAAI,CAACO,YAAY,CAAC,eAAe,EAAE,UAAShB,OAAO,EAAE;IAEnD,IAAIiB,OAAO,GAAGjB,OAAO,CAACiB,OAAO;MACzBC,cAAc,GAAGD,OAAO,CAACC,cAAc;IAE3ChD,OAAO,CAACgD,cAAc,EAAElC,aAAa,CAAC;EACxC,CAAC,EAAE,IAAI,CAAC;EAER,IAAI,CAACmC,UAAU,CAAC,sBAAsB,EAAErB,4BAA4B,CAAC;EAErE,IAAI,CAACkB,YAAY,CAAC,0BAA0B,EAAE,UAASjB,KAAK,EAAE;IAC5D,IAAIC,OAAO,GAAGD,KAAK,CAACC,OAAO;MACvBoB,UAAU,GAAGpB,OAAO,CAACoB,UAAU;MAC/BC,OAAO,GAAGrB,OAAO,CAACqB,OAAO;MACzBC,cAAc,GAAGD,OAAO,CAACC,cAAc;MACvCrC,UAAU;;IAEd;IACA,IAAImC,UAAU,CAACG,OAAO,EAAE;MACtBtC,UAAU,GAAGd,IAAI,CACfkD,OAAO,CAACG,QAAQ,EAChBpD,YAAY,CAAC;QAAEqD,EAAE,EAAEJ,OAAO,CAACC,cAAc,CAACC,OAAO,CAACE;MAAG,CAAC,CACxD,CAAC;MAED,IAAIxC,UAAU,EAAE;QACdP,QAAQ,CAACgD,gBAAgB,CAACzC,UAAU,EAAE;UAAE0C,mBAAmB,EAAEC;QAAU,CAAC,CAAC;MAC3E;IACF;;IAEA;IACA,IAAIR,UAAU,CAACO,mBAAmB,IAAIL,cAAc,CAACO,SAAS,CAACN,OAAO,KAAKD,cAAc,EAAE;MACzF5C,QAAQ,CAACgD,gBAAgB,CAACL,OAAO,CAACnC,MAAM,EAAE;QAAEqC,OAAO,EAAEK;MAAU,CAAC,CAAC;IACnE;EACF,CAAC,CAAC;AACJ;AAEAvD,QAAQ,CAACG,yBAAyB,EAAEF,kBAAkB,CAAC;AAEvDE,yBAAyB,CAACsD,OAAO,GAAG,CAClC,UAAU,EACV,UAAU,EACV,WAAW,EACX,UAAU,CACX","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}