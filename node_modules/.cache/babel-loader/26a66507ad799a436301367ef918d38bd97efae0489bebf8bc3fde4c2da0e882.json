{"ast":null,"code":"import inherits from 'inherits-browser';\nimport { assign, filter, find, isNumber } from 'min-dash';\nimport { getMid } from 'diagram-js/lib/layout/LayoutUtil';\nimport CommandInterceptor from 'diagram-js/lib/command/CommandInterceptor';\nimport { getApproxIntersection } from 'diagram-js/lib/util/LineIntersection';\n\n/**\n * @typedef {import('diagram-js/lib/core/EventBus').default} EventBus\n * @typedef {import('../../rules/BpmnRules').default} BpmnRules\n * @typedef {import('../../modeling/Modeling').default} Modeling\n */\n\n/**\n * @param {EventBus} eventBus\n * @param {BpmnRules} bpmnRules\n * @param {Modeling} modeling\n */\nexport default function DropOnFlowBehavior(eventBus, bpmnRules, modeling) {\n  CommandInterceptor.call(this, eventBus);\n\n  /**\n   * Reconnect start / end of a connection after\n   * dropping an element on a flow.\n   */\n\n  function insertShape(shape, targetFlow, positionOrBounds) {\n    var waypoints = targetFlow.waypoints,\n      waypointsBefore,\n      waypointsAfter,\n      dockingPoint,\n      source,\n      target,\n      incomingConnection,\n      outgoingConnection,\n      oldOutgoing = shape.outgoing.slice(),\n      oldIncoming = shape.incoming.slice();\n    var mid;\n    if (isNumber(positionOrBounds.width)) {\n      mid = getMid(positionOrBounds);\n    } else {\n      mid = positionOrBounds;\n    }\n    var intersection = getApproxIntersection(waypoints, mid);\n    if (intersection) {\n      waypointsBefore = waypoints.slice(0, intersection.index);\n      waypointsAfter = waypoints.slice(intersection.index + (intersection.bendpoint ? 1 : 0));\n\n      // due to inaccuracy intersection might have been found\n      if (!waypointsBefore.length || !waypointsAfter.length) {\n        return;\n      }\n      dockingPoint = intersection.bendpoint ? waypoints[intersection.index] : mid;\n\n      // if last waypointBefore is inside shape's bounds, ignore docking point\n      if (waypointsBefore.length === 1 || !isPointInsideBBox(shape, waypointsBefore[waypointsBefore.length - 1])) {\n        waypointsBefore.push(copy(dockingPoint));\n      }\n\n      // if first waypointAfter is inside shape's bounds, ignore docking point\n      if (waypointsAfter.length === 1 || !isPointInsideBBox(shape, waypointsAfter[0])) {\n        waypointsAfter.unshift(copy(dockingPoint));\n      }\n    }\n    source = targetFlow.source;\n    target = targetFlow.target;\n    if (bpmnRules.canConnect(source, shape, targetFlow)) {\n      // reconnect source -> inserted shape\n      modeling.reconnectEnd(targetFlow, shape, waypointsBefore || mid);\n      incomingConnection = targetFlow;\n    }\n    if (bpmnRules.canConnect(shape, target, targetFlow)) {\n      if (!incomingConnection) {\n        // reconnect inserted shape -> end\n        modeling.reconnectStart(targetFlow, shape, waypointsAfter || mid);\n        outgoingConnection = targetFlow;\n      } else {\n        outgoingConnection = modeling.connect(shape, target, {\n          type: targetFlow.type,\n          waypoints: waypointsAfter\n        });\n      }\n    }\n    var duplicateConnections = [].concat(incomingConnection && filter(oldIncoming, function (connection) {\n      return connection.source === incomingConnection.source;\n    }) || [], outgoingConnection && filter(oldOutgoing, function (connection) {\n      return connection.target === outgoingConnection.target;\n    }) || []);\n    if (duplicateConnections.length) {\n      modeling.removeElements(duplicateConnections);\n    }\n  }\n  this.preExecute('elements.move', function (context) {\n    var newParent = context.newParent,\n      shapes = context.shapes,\n      delta = context.delta,\n      shape = shapes[0];\n    if (!shape || !newParent) {\n      return;\n    }\n\n    // if the new parent is a connection,\n    // change it to the new parent's parent\n    if (newParent && newParent.waypoints) {\n      context.newParent = newParent = newParent.parent;\n    }\n    var shapeMid = getMid(shape);\n    var newShapeMid = {\n      x: shapeMid.x + delta.x,\n      y: shapeMid.y + delta.y\n    };\n\n    // find a connection which intersects with the\n    // element's mid point\n    var connection = find(newParent.children, function (element) {\n      var canInsert = bpmnRules.canInsert(shapes, element);\n      return canInsert && getApproxIntersection(element.waypoints, newShapeMid);\n    });\n    if (connection) {\n      context.targetFlow = connection;\n      context.position = newShapeMid;\n    }\n  }, true);\n  this.postExecuted('elements.move', function (context) {\n    var shapes = context.shapes,\n      targetFlow = context.targetFlow,\n      position = context.position;\n    if (targetFlow) {\n      insertShape(shapes[0], targetFlow, position);\n    }\n  }, true);\n  this.preExecute('shape.create', function (context) {\n    var parent = context.parent,\n      shape = context.shape;\n    if (bpmnRules.canInsert(shape, parent)) {\n      context.targetFlow = parent;\n      context.parent = parent.parent;\n    }\n  }, true);\n  this.postExecuted('shape.create', function (context) {\n    var shape = context.shape,\n      targetFlow = context.targetFlow,\n      positionOrBounds = context.position;\n    if (targetFlow) {\n      insertShape(shape, targetFlow, positionOrBounds);\n    }\n  }, true);\n}\ninherits(DropOnFlowBehavior, CommandInterceptor);\nDropOnFlowBehavior.$inject = ['eventBus', 'bpmnRules', 'modeling'];\n\n// helpers /////////////////////\n\nfunction isPointInsideBBox(bbox, point) {\n  var x = point.x,\n    y = point.y;\n  return x >= bbox.x && x <= bbox.x + bbox.width && y >= bbox.y && y <= bbox.y + bbox.height;\n}\nfunction copy(obj) {\n  return assign({}, obj);\n}","map":{"version":3,"names":["inherits","assign","filter","find","isNumber","getMid","CommandInterceptor","getApproxIntersection","DropOnFlowBehavior","eventBus","bpmnRules","modeling","call","insertShape","shape","targetFlow","positionOrBounds","waypoints","waypointsBefore","waypointsAfter","dockingPoint","source","target","incomingConnection","outgoingConnection","oldOutgoing","outgoing","slice","oldIncoming","incoming","mid","width","intersection","index","bendpoint","length","isPointInsideBBox","push","copy","unshift","canConnect","reconnectEnd","reconnectStart","connect","type","duplicateConnections","concat","connection","removeElements","preExecute","context","newParent","shapes","delta","parent","shapeMid","newShapeMid","x","y","children","element","canInsert","position","postExecuted","$inject","bbox","point","height","obj"],"sources":["/home/runner/work/sgex/sgex/node_modules/bpmn-js/lib/features/modeling/behavior/DropOnFlowBehavior.js"],"sourcesContent":["import inherits from 'inherits-browser';\n\nimport {\n  assign,\n  filter,\n  find,\n  isNumber\n} from 'min-dash';\n\nimport { getMid } from 'diagram-js/lib/layout/LayoutUtil';\n\nimport CommandInterceptor from 'diagram-js/lib/command/CommandInterceptor';\n\nimport {\n  getApproxIntersection\n} from 'diagram-js/lib/util/LineIntersection';\n\n/**\n * @typedef {import('diagram-js/lib/core/EventBus').default} EventBus\n * @typedef {import('../../rules/BpmnRules').default} BpmnRules\n * @typedef {import('../../modeling/Modeling').default} Modeling\n */\n\n/**\n * @param {EventBus} eventBus\n * @param {BpmnRules} bpmnRules\n * @param {Modeling} modeling\n */\nexport default function DropOnFlowBehavior(eventBus, bpmnRules, modeling) {\n\n  CommandInterceptor.call(this, eventBus);\n\n  /**\n   * Reconnect start / end of a connection after\n   * dropping an element on a flow.\n   */\n\n  function insertShape(shape, targetFlow, positionOrBounds) {\n    var waypoints = targetFlow.waypoints,\n        waypointsBefore,\n        waypointsAfter,\n        dockingPoint,\n        source,\n        target,\n        incomingConnection,\n        outgoingConnection,\n        oldOutgoing = shape.outgoing.slice(),\n        oldIncoming = shape.incoming.slice();\n\n    var mid;\n\n    if (isNumber(positionOrBounds.width)) {\n      mid = getMid(positionOrBounds);\n    } else {\n      mid = positionOrBounds;\n    }\n\n    var intersection = getApproxIntersection(waypoints, mid);\n\n    if (intersection) {\n      waypointsBefore = waypoints.slice(0, intersection.index);\n      waypointsAfter = waypoints.slice(intersection.index + (intersection.bendpoint ? 1 : 0));\n\n      // due to inaccuracy intersection might have been found\n      if (!waypointsBefore.length || !waypointsAfter.length) {\n        return;\n      }\n\n      dockingPoint = intersection.bendpoint ? waypoints[intersection.index] : mid;\n\n      // if last waypointBefore is inside shape's bounds, ignore docking point\n      if (waypointsBefore.length === 1 || !isPointInsideBBox(shape, waypointsBefore[waypointsBefore.length - 1])) {\n        waypointsBefore.push(copy(dockingPoint));\n      }\n\n      // if first waypointAfter is inside shape's bounds, ignore docking point\n      if (waypointsAfter.length === 1 || !isPointInsideBBox(shape, waypointsAfter[0])) {\n        waypointsAfter.unshift(copy(dockingPoint));\n      }\n    }\n\n    source = targetFlow.source;\n    target = targetFlow.target;\n\n    if (bpmnRules.canConnect(source, shape, targetFlow)) {\n\n      // reconnect source -> inserted shape\n      modeling.reconnectEnd(targetFlow, shape, waypointsBefore || mid);\n\n      incomingConnection = targetFlow;\n    }\n\n    if (bpmnRules.canConnect(shape, target, targetFlow)) {\n\n      if (!incomingConnection) {\n\n        // reconnect inserted shape -> end\n        modeling.reconnectStart(targetFlow, shape, waypointsAfter || mid);\n\n        outgoingConnection = targetFlow;\n      } else {\n        outgoingConnection = modeling.connect(\n          shape, target, { type: targetFlow.type, waypoints: waypointsAfter }\n        );\n      }\n    }\n\n    var duplicateConnections = [].concat(\n\n      incomingConnection && filter(oldIncoming, function(connection) {\n        return connection.source === incomingConnection.source;\n      }) || [],\n\n      outgoingConnection && filter(oldOutgoing, function(connection) {\n        return connection.target === outgoingConnection.target;\n      }) || []\n    );\n\n    if (duplicateConnections.length) {\n      modeling.removeElements(duplicateConnections);\n    }\n  }\n\n  this.preExecute('elements.move', function(context) {\n\n    var newParent = context.newParent,\n        shapes = context.shapes,\n        delta = context.delta,\n        shape = shapes[0];\n\n    if (!shape || !newParent) {\n      return;\n    }\n\n    // if the new parent is a connection,\n    // change it to the new parent's parent\n    if (newParent && newParent.waypoints) {\n      context.newParent = newParent = newParent.parent;\n    }\n\n    var shapeMid = getMid(shape);\n    var newShapeMid = {\n      x: shapeMid.x + delta.x,\n      y: shapeMid.y + delta.y\n    };\n\n    // find a connection which intersects with the\n    // element's mid point\n    var connection = find(newParent.children, function(element) {\n      var canInsert = bpmnRules.canInsert(shapes, element);\n\n      return canInsert && getApproxIntersection(element.waypoints, newShapeMid);\n    });\n\n    if (connection) {\n      context.targetFlow = connection;\n      context.position = newShapeMid;\n    }\n\n  }, true);\n\n  this.postExecuted('elements.move', function(context) {\n\n    var shapes = context.shapes,\n        targetFlow = context.targetFlow,\n        position = context.position;\n\n    if (targetFlow) {\n      insertShape(shapes[0], targetFlow, position);\n    }\n\n  }, true);\n\n  this.preExecute('shape.create', function(context) {\n\n    var parent = context.parent,\n        shape = context.shape;\n\n    if (bpmnRules.canInsert(shape, parent)) {\n      context.targetFlow = parent;\n      context.parent = parent.parent;\n    }\n  }, true);\n\n  this.postExecuted('shape.create', function(context) {\n\n    var shape = context.shape,\n        targetFlow = context.targetFlow,\n        positionOrBounds = context.position;\n\n    if (targetFlow) {\n      insertShape(shape, targetFlow, positionOrBounds);\n    }\n  }, true);\n}\n\ninherits(DropOnFlowBehavior, CommandInterceptor);\n\nDropOnFlowBehavior.$inject = [\n  'eventBus',\n  'bpmnRules',\n  'modeling'\n];\n\n\n// helpers /////////////////////\n\nfunction isPointInsideBBox(bbox, point) {\n  var x = point.x,\n      y = point.y;\n\n  return x >= bbox.x &&\n    x <= bbox.x + bbox.width &&\n    y >= bbox.y &&\n    y <= bbox.y + bbox.height;\n}\n\nfunction copy(obj) {\n  return assign({}, obj);\n}\n\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}