{"ast":null,"code":"import { isArray } from 'min-dash';\n\n/**\n * @typedef { {\n *   index: number;\n *   match: boolean;\n *   value: string;\n * } } Token\n *\n * @typedef {Token[]} Tokens\n */\n\n/**\n * @template R\n *\n * @typedef { {\n *   item: R,\n *   tokens: Record<string, Tokens>\n * } } SearchResult\n */\n\n/**\n * @typedef {Record<string, string | string[]>} SearchItem\n */\n\n/**\n * Search items by query.\n *\n * @template {SearchItem} T\n *\n * @param {T[]} items elements to search in\n * @param {string} pattern pattern to search for\n * @param { {\n *   keys: string[];\n * } } options\n *\n * @returns {SearchResult<T>[]}\n */\nexport default function search(items, pattern, options) {\n  const {\n    keys\n  } = options;\n  pattern = pattern.trim().toLowerCase();\n  if (!pattern) {\n    throw new Error('<pattern> must not be empty');\n  }\n  const words = pattern.trim().toLowerCase().split(/\\s+/);\n  return items.flatMap(item => {\n    const tokens = matchItem(item, words, keys);\n    if (!tokens) {\n      return [];\n    }\n    return {\n      item,\n      tokens\n    };\n  }).sort(createResultSorter(keys));\n}\n\n/**\n * Match an item and return tokens in case of a match.\n *\n * @param {SearchItem} item element to be matched\n * @param {string[]} words words from search pattern to find\n * @param {string[]} keys keys to search in the item\n *\n * @returns {Record<string, Tokens>}\n */\nfunction matchItem(item, words, keys) {\n  const {\n    matchedWords,\n    tokens\n  } = keys.reduce((result, key) => {\n    const itemValue = item[key];\n    const {\n      tokens,\n      matchedWords\n    } = isArray(itemValue) ? itemValue.reduce((result, itemString) => {\n      const {\n        tokens,\n        matchedWords\n      } = matchString(itemString, words);\n      return {\n        tokens: [...result.tokens, tokens],\n        matchedWords: {\n          ...result.matchedWords,\n          ...matchedWords\n        }\n      };\n    }, {\n      matchedWords: {},\n      tokens: []\n    }) : matchString(itemValue, words);\n    return {\n      tokens: {\n        ...result.tokens,\n        [key]: tokens\n      },\n      matchedWords: {\n        ...result.matchedWords,\n        ...matchedWords\n      }\n    };\n  }, {\n    matchedWords: {},\n    tokens: {}\n  });\n\n  // only return result if every word got matched\n  if (Object.keys(matchedWords).length !== words.length) {\n    return null;\n  }\n  return tokens;\n}\n\n/**\n * Creates a compare function that can be used in Array.sort() based on a custom scoring function\n *\n * @param {string[]} keys\n *\n * @returns { (resultA: SearchResult, resultB: SearchResult) => number}\n */\nfunction createResultSorter(keys) {\n  /**\n   * @param {SearchResult} resultA\n   * @param {SearchResult} resultB\n   */\n  return (resultA, resultB) => {\n    let comparison = 0;\n\n    // used to assign some priority to earlier keys\n    let modifier = 1;\n    for (const key of keys) {\n      const tokenComparison = compareTokens(resultA.tokens[key], resultB.tokens[key]);\n      if (tokenComparison !== 0) {\n        comparison += tokenComparison * modifier;\n        modifier *= 0.9;\n        continue;\n      }\n      const stringComparison = compareStrings(resultA.item[key], resultB.item[key]);\n      if (stringComparison !== 0) {\n        comparison += stringComparison * modifier;\n        modifier *= 0.9;\n        continue;\n      }\n    }\n    return comparison;\n  };\n}\n\n/**\n * Compares two token arrays.\n *\n * @param {Token[]} [tokensA]\n * @param {Token[]} [tokensB]\n *\n * @returns {number}\n */\nfunction compareTokens(tokensA, tokensB) {\n  return scoreTokens(tokensB) - scoreTokens(tokensA);\n}\n\n/**\n * @param { Token[] } tokens\n * @returns { number }\n */\nfunction scoreTokens(tokens) {\n  return tokens.reduce((sum, token) => sum + scoreToken(token), 0);\n}\n\n/**\n * Score a token based on its characteristics\n * and the length of the matched content.\n *\n * @param { Token } token\n *\n * @returns { number }\n */\nfunction scoreToken(token) {\n  if (isArray(token)) {\n    return Math.max(...token.map(scoreToken));\n  }\n  const modifier = Math.log(token.value.length);\n  if (!token.match) {\n    return -0.07 * modifier;\n  }\n  return (token.start ? token.end ? 131.9 : 7.87 : token.wordStart ? 2.19 : 1) * modifier;\n}\n\n/**\n * @param {string|string[]} [str='']\n *\n * @return {string}\n */\nfunction stringJoin() {\n  let str = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';\n  return isArray(str) ? str.join(', ') : str;\n}\n\n/**\n * Compares two strings. also supports string arrays, which will be joined\n *\n * @param {string|string[]} [a]\n * @param {string|string[]} [b]\n *\n * @returns {number}\n */\nfunction compareStrings(a, b) {\n  return stringJoin(a).localeCompare(stringJoin(b));\n}\n\n/**\n * Match a given string against a set of words,\n * and return the result.\n *\n * @param {string} string\n * @param {string[]} words\n *\n * @return { {\n *   tokens: Token[],\n *   matchedWords: Record<string, boolean>\n * } }\n */\nfunction matchString(string, words) {\n  if (!string) {\n    return {\n      tokens: [],\n      matchedWords: {}\n    };\n  }\n  const tokens = [];\n  const matchedWords = {};\n  const wordsEscaped = words.map(escapeRegexp);\n  const regexpString = [`(?<all>${wordsEscaped.join('\\\\s+')})`, ...wordsEscaped].join('|');\n  const regexp = new RegExp(regexpString, 'ig');\n  let match;\n  let lastIndex = 0;\n  while (match = regexp.exec(string)) {\n    const [value] = match;\n    const startIndex = match.index;\n    const endIndex = match.index + value.length;\n    const start = startIndex === 0;\n    const end = endIndex === string.length;\n    const all = !!match.groups.all;\n    const wordStart = start || /\\s/.test(string.charAt(startIndex - 1));\n    const wordEnd = end || /\\s/.test(string.charAt(endIndex));\n    if (match.index > lastIndex) {\n      // add previous token (NO match)\n      tokens.push({\n        value: string.slice(lastIndex, match.index),\n        index: lastIndex\n      });\n    }\n\n    // add current token (match)\n    tokens.push({\n      value,\n      index: match.index,\n      match: true,\n      wordStart,\n      wordEnd,\n      start,\n      end,\n      all\n    });\n    const newMatchedWords = all ? words : [value];\n    for (const word of newMatchedWords) {\n      matchedWords[word.toLowerCase()] = true;\n    }\n    lastIndex = match.index + value.length;\n  }\n\n  // add after token (NO match)\n  if (lastIndex < string.length) {\n    tokens.push({\n      value: string.slice(lastIndex),\n      index: lastIndex\n    });\n  }\n  return {\n    tokens,\n    matchedWords\n  };\n}\nfunction escapeRegexp(string) {\n  return string.replace(/[/\\-\\\\^$*+?.()|[\\]{}]/g, '\\\\$&');\n}","map":{"version":3,"names":["isArray","search","items","pattern","options","keys","trim","toLowerCase","Error","words","split","flatMap","item","tokens","matchItem","sort","createResultSorter","matchedWords","reduce","result","key","itemValue","itemString","matchString","Object","length","resultA","resultB","comparison","modifier","tokenComparison","compareTokens","stringComparison","compareStrings","tokensA","tokensB","scoreTokens","sum","token","scoreToken","Math","max","map","log","value","match","start","end","wordStart","stringJoin","str","arguments","undefined","join","a","b","localeCompare","string","wordsEscaped","escapeRegexp","regexpString","regexp","RegExp","lastIndex","exec","startIndex","index","endIndex","all","groups","test","charAt","wordEnd","push","slice","newMatchedWords","word","replace"],"sources":["/home/runner/work/sgex/sgex/node_modules/diagram-js/lib/features/search/search.js"],"sourcesContent":["import { isArray } from 'min-dash';\n\n/**\n * @typedef { {\n *   index: number;\n *   match: boolean;\n *   value: string;\n * } } Token\n *\n * @typedef {Token[]} Tokens\n */\n\n/**\n * @template R\n *\n * @typedef { {\n *   item: R,\n *   tokens: Record<string, Tokens>\n * } } SearchResult\n */\n\n/**\n * @typedef {Record<string, string | string[]>} SearchItem\n */\n\n/**\n * Search items by query.\n *\n * @template {SearchItem} T\n *\n * @param {T[]} items elements to search in\n * @param {string} pattern pattern to search for\n * @param { {\n *   keys: string[];\n * } } options\n *\n * @returns {SearchResult<T>[]}\n */\nexport default function search(items, pattern, options) {\n\n  const {\n    keys\n  } = options;\n\n  pattern = pattern.trim().toLowerCase();\n\n  if (!pattern) {\n    throw new Error('<pattern> must not be empty');\n  }\n\n  const words = pattern.trim().toLowerCase().split(/\\s+/);\n\n  return items.flatMap((item) => {\n    const tokens = matchItem(item, words, keys);\n\n    if (!tokens) {\n      return [];\n    }\n\n    return {\n      item,\n      tokens\n    };\n  }).sort(createResultSorter(keys));\n}\n\n/**\n * Match an item and return tokens in case of a match.\n *\n * @param {SearchItem} item element to be matched\n * @param {string[]} words words from search pattern to find\n * @param {string[]} keys keys to search in the item\n *\n * @returns {Record<string, Tokens>}\n */\nfunction matchItem(item, words, keys) {\n\n  const {\n    matchedWords,\n    tokens\n  } = keys.reduce((result, key) => {\n    const itemValue = item[ key ];\n\n    const {\n      tokens,\n      matchedWords\n    } = isArray(itemValue) ? (\n      itemValue.reduce(\n        (result, itemString) => {\n          const { tokens, matchedWords } = matchString(itemString, words);\n\n          return {\n            tokens: [ ...result.tokens, tokens ],\n            matchedWords: {\n              ...result.matchedWords,\n              ...matchedWords\n            }\n          };\n        },\n        {\n          matchedWords: {},\n          tokens: []\n        }\n      )\n    ) : (\n      matchString(itemValue, words)\n    );\n\n    return {\n      tokens: {\n        ...result.tokens,\n        [ key ]: tokens,\n      },\n      matchedWords: {\n        ...result.matchedWords,\n        ...matchedWords\n      }\n    };\n  }, {\n    matchedWords: {},\n    tokens: {}\n  });\n\n  // only return result if every word got matched\n  if (Object.keys(matchedWords).length !== words.length) {\n    return null;\n  }\n\n  return tokens;\n}\n\n/**\n * Creates a compare function that can be used in Array.sort() based on a custom scoring function\n *\n * @param {string[]} keys\n *\n * @returns { (resultA: SearchResult, resultB: SearchResult) => number}\n */\nfunction createResultSorter(keys) {\n\n  /**\n   * @param {SearchResult} resultA\n   * @param {SearchResult} resultB\n   */\n  return (resultA, resultB) => {\n    let comparison = 0;\n\n    // used to assign some priority to earlier keys\n    let modifier = 1;\n\n    for (const key of keys) {\n\n      const tokenComparison = compareTokens(\n        resultA.tokens[key],\n        resultB.tokens[key]\n      );\n\n      if (tokenComparison !== 0) {\n        comparison += tokenComparison * modifier;\n        modifier *= 0.9;\n        continue;\n      }\n\n      const stringComparison = compareStrings(\n        resultA.item[ key ],\n        resultB.item[ key ]\n      );\n\n      if (stringComparison !== 0) {\n        comparison += stringComparison * modifier;\n        modifier *= 0.9;\n        continue;\n      }\n    }\n\n    return comparison;\n  };\n\n}\n\n/**\n * Compares two token arrays.\n *\n * @param {Token[]} [tokensA]\n * @param {Token[]} [tokensB]\n *\n * @returns {number}\n */\nfunction compareTokens(tokensA, tokensB) {\n  return scoreTokens(tokensB) - scoreTokens(tokensA);\n}\n\n/**\n * @param { Token[] } tokens\n * @returns { number }\n */\nfunction scoreTokens(tokens) {\n  return tokens.reduce((sum, token) => sum + scoreToken(token), 0);\n}\n\n/**\n * Score a token based on its characteristics\n * and the length of the matched content.\n *\n * @param { Token } token\n *\n * @returns { number }\n */\nfunction scoreToken(token) {\n  if (isArray(token)) {\n    return Math.max(...token.map(scoreToken));\n  }\n\n  const modifier = Math.log(token.value.length);\n\n  if (!token.match) {\n    return -0.07 * modifier;\n  }\n\n  return (\n    token.start\n      ? (\n        token.end\n          ? 131.9\n          : 7.87\n      )\n      : (\n        token.wordStart\n          ? 2.19\n          : 1\n      )\n  ) * modifier;\n}\n\n/**\n * @param {string|string[]} [str='']\n *\n * @return {string}\n */\nfunction stringJoin(str = '') {\n  return isArray(str) ? str.join(', ') : str;\n}\n\n/**\n * Compares two strings. also supports string arrays, which will be joined\n *\n * @param {string|string[]} [a]\n * @param {string|string[]} [b]\n *\n * @returns {number}\n */\nfunction compareStrings(a, b) {\n  return stringJoin(a).localeCompare(stringJoin(b));\n}\n\n/**\n * Match a given string against a set of words,\n * and return the result.\n *\n * @param {string} string\n * @param {string[]} words\n *\n * @return { {\n *   tokens: Token[],\n *   matchedWords: Record<string, boolean>\n * } }\n */\nfunction matchString(string, words) {\n\n  if (!string) {\n    return {\n      tokens: [],\n      matchedWords: {}\n    };\n  }\n\n  const tokens = [];\n  const matchedWords = {};\n\n  const wordsEscaped = words.map(escapeRegexp);\n\n  const regexpString = [\n    `(?<all>${wordsEscaped.join('\\\\s+')})`,\n    ...wordsEscaped\n  ].join('|');\n\n  const regexp = new RegExp(regexpString, 'ig');\n\n  let match;\n  let lastIndex = 0;\n\n  while ((match = regexp.exec(string))) {\n\n    const [ value ] = match;\n\n    const startIndex = match.index;\n    const endIndex = match.index + value.length;\n\n    const start = startIndex === 0;\n    const end = endIndex === string.length;\n\n    const all = !!match.groups.all;\n\n    const wordStart = start || /\\s/.test(string.charAt(startIndex - 1));\n    const wordEnd = end || /\\s/.test(string.charAt(endIndex));\n\n    if (match.index > lastIndex) {\n\n      // add previous token (NO match)\n      tokens.push({\n        value: string.slice(lastIndex, match.index),\n        index: lastIndex\n      });\n    }\n\n    // add current token (match)\n    tokens.push({\n      value,\n      index: match.index,\n      match: true,\n      wordStart,\n      wordEnd,\n      start,\n      end,\n      all\n    });\n\n    const newMatchedWords = all ? words : [ value ];\n\n    for (const word of newMatchedWords) {\n      matchedWords[word.toLowerCase()] = true;\n    }\n\n    lastIndex = match.index + value.length;\n  }\n\n  // add after token (NO match)\n  if (lastIndex < string.length) {\n    tokens.push({\n      value: string.slice(lastIndex),\n      index: lastIndex\n    });\n  }\n\n  return {\n    tokens,\n    matchedWords\n  };\n}\n\nfunction escapeRegexp(string) {\n  return string.replace(/[/\\-\\\\^$*+?.()|[\\]{}]/g, '\\\\$&');\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}