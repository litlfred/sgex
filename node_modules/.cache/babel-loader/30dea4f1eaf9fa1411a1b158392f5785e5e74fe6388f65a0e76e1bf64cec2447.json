{"ast":null,"code":"\"use strict\";\n\nvar _taggedTemplateLiteral = require(\"/home/runner/work/sgex/sgex/node_modules/@babel/runtime/helpers/taggedTemplateLiteral.js\").default;\nvar _objectSpread = require(\"/home/runner/work/sgex/sgex/node_modules/@babel/runtime/helpers/objectSpread2.js\").default;\nvar _templateObject, _templateObject2, _templateObject3, _templateObject4, _templateObject5, _templateObject6;\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.or = exports.and = exports.not = exports.CodeGen = exports.operators = exports.varKinds = exports.ValueScopeName = exports.ValueScope = exports.Scope = exports.Name = exports.regexpCode = exports.stringify = exports.getProperty = exports.nil = exports.strConcat = exports.str = exports._ = void 0;\nconst code_1 = require(\"./code\");\nconst scope_1 = require(\"./scope\");\nvar code_2 = require(\"./code\");\nObject.defineProperty(exports, \"_\", {\n  enumerable: true,\n  get: function () {\n    return code_2._;\n  }\n});\nObject.defineProperty(exports, \"str\", {\n  enumerable: true,\n  get: function () {\n    return code_2.str;\n  }\n});\nObject.defineProperty(exports, \"strConcat\", {\n  enumerable: true,\n  get: function () {\n    return code_2.strConcat;\n  }\n});\nObject.defineProperty(exports, \"nil\", {\n  enumerable: true,\n  get: function () {\n    return code_2.nil;\n  }\n});\nObject.defineProperty(exports, \"getProperty\", {\n  enumerable: true,\n  get: function () {\n    return code_2.getProperty;\n  }\n});\nObject.defineProperty(exports, \"stringify\", {\n  enumerable: true,\n  get: function () {\n    return code_2.stringify;\n  }\n});\nObject.defineProperty(exports, \"regexpCode\", {\n  enumerable: true,\n  get: function () {\n    return code_2.regexpCode;\n  }\n});\nObject.defineProperty(exports, \"Name\", {\n  enumerable: true,\n  get: function () {\n    return code_2.Name;\n  }\n});\nvar scope_2 = require(\"./scope\");\nObject.defineProperty(exports, \"Scope\", {\n  enumerable: true,\n  get: function () {\n    return scope_2.Scope;\n  }\n});\nObject.defineProperty(exports, \"ValueScope\", {\n  enumerable: true,\n  get: function () {\n    return scope_2.ValueScope;\n  }\n});\nObject.defineProperty(exports, \"ValueScopeName\", {\n  enumerable: true,\n  get: function () {\n    return scope_2.ValueScopeName;\n  }\n});\nObject.defineProperty(exports, \"varKinds\", {\n  enumerable: true,\n  get: function () {\n    return scope_2.varKinds;\n  }\n});\nexports.operators = {\n  GT: new code_1._Code(\">\"),\n  GTE: new code_1._Code(\">=\"),\n  LT: new code_1._Code(\"<\"),\n  LTE: new code_1._Code(\"<=\"),\n  EQ: new code_1._Code(\"===\"),\n  NEQ: new code_1._Code(\"!==\"),\n  NOT: new code_1._Code(\"!\"),\n  OR: new code_1._Code(\"||\"),\n  AND: new code_1._Code(\"&&\"),\n  ADD: new code_1._Code(\"+\")\n};\nclass Node {\n  optimizeNodes() {\n    return this;\n  }\n  optimizeNames(_names, _constants) {\n    return this;\n  }\n}\nclass Def extends Node {\n  constructor(varKind, name, rhs) {\n    super();\n    this.varKind = varKind;\n    this.name = name;\n    this.rhs = rhs;\n  }\n  render(_ref) {\n    let {\n      es5,\n      _n\n    } = _ref;\n    const varKind = es5 ? scope_1.varKinds.var : this.varKind;\n    const rhs = this.rhs === undefined ? \"\" : \" = \".concat(this.rhs);\n    return \"\".concat(varKind, \" \").concat(this.name).concat(rhs, \";\") + _n;\n  }\n  optimizeNames(names, constants) {\n    if (!names[this.name.str]) return;\n    if (this.rhs) this.rhs = optimizeExpr(this.rhs, names, constants);\n    return this;\n  }\n  get names() {\n    return this.rhs instanceof code_1._CodeOrName ? this.rhs.names : {};\n  }\n}\nclass Assign extends Node {\n  constructor(lhs, rhs, sideEffects) {\n    super();\n    this.lhs = lhs;\n    this.rhs = rhs;\n    this.sideEffects = sideEffects;\n  }\n  render(_ref2) {\n    let {\n      _n\n    } = _ref2;\n    return \"\".concat(this.lhs, \" = \").concat(this.rhs, \";\") + _n;\n  }\n  optimizeNames(names, constants) {\n    if (this.lhs instanceof code_1.Name && !names[this.lhs.str] && !this.sideEffects) return;\n    this.rhs = optimizeExpr(this.rhs, names, constants);\n    return this;\n  }\n  get names() {\n    const names = this.lhs instanceof code_1.Name ? {} : _objectSpread({}, this.lhs.names);\n    return addExprNames(names, this.rhs);\n  }\n}\nclass AssignOp extends Assign {\n  constructor(lhs, op, rhs, sideEffects) {\n    super(lhs, rhs, sideEffects);\n    this.op = op;\n  }\n  render(_ref3) {\n    let {\n      _n\n    } = _ref3;\n    return \"\".concat(this.lhs, \" \").concat(this.op, \"= \").concat(this.rhs, \";\") + _n;\n  }\n}\nclass Label extends Node {\n  constructor(label) {\n    super();\n    this.label = label;\n    this.names = {};\n  }\n  render(_ref4) {\n    let {\n      _n\n    } = _ref4;\n    return \"\".concat(this.label, \":\") + _n;\n  }\n}\nclass Break extends Node {\n  constructor(label) {\n    super();\n    this.label = label;\n    this.names = {};\n  }\n  render(_ref5) {\n    let {\n      _n\n    } = _ref5;\n    const label = this.label ? \" \".concat(this.label) : \"\";\n    return \"break\".concat(label, \";\") + _n;\n  }\n}\nclass Throw extends Node {\n  constructor(error) {\n    super();\n    this.error = error;\n  }\n  render(_ref6) {\n    let {\n      _n\n    } = _ref6;\n    return \"throw \".concat(this.error, \";\") + _n;\n  }\n  get names() {\n    return this.error.names;\n  }\n}\nclass AnyCode extends Node {\n  constructor(code) {\n    super();\n    this.code = code;\n  }\n  render(_ref7) {\n    let {\n      _n\n    } = _ref7;\n    return \"\".concat(this.code, \";\") + _n;\n  }\n  optimizeNodes() {\n    return \"\".concat(this.code) ? this : undefined;\n  }\n  optimizeNames(names, constants) {\n    this.code = optimizeExpr(this.code, names, constants);\n    return this;\n  }\n  get names() {\n    return this.code instanceof code_1._CodeOrName ? this.code.names : {};\n  }\n}\nclass ParentNode extends Node {\n  constructor() {\n    let nodes = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n    super();\n    this.nodes = nodes;\n  }\n  render(opts) {\n    return this.nodes.reduce((code, n) => code + n.render(opts), \"\");\n  }\n  optimizeNodes() {\n    const {\n      nodes\n    } = this;\n    let i = nodes.length;\n    while (i--) {\n      const n = nodes[i].optimizeNodes();\n      if (Array.isArray(n)) nodes.splice(i, 1, ...n);else if (n) nodes[i] = n;else nodes.splice(i, 1);\n    }\n    return nodes.length > 0 ? this : undefined;\n  }\n  optimizeNames(names, constants) {\n    const {\n      nodes\n    } = this;\n    let i = nodes.length;\n    while (i--) {\n      // iterating backwards improves 1-pass optimization\n      const n = nodes[i];\n      if (n.optimizeNames(names, constants)) continue;\n      subtractNames(names, n.names);\n      nodes.splice(i, 1);\n    }\n    return nodes.length > 0 ? this : undefined;\n  }\n  get names() {\n    return this.nodes.reduce((names, n) => addNames(names, n.names), {});\n  }\n}\nclass BlockNode extends ParentNode {\n  render(opts) {\n    return \"{\" + opts._n + super.render(opts) + \"}\" + opts._n;\n  }\n}\nclass Root extends ParentNode {}\nclass Else extends BlockNode {}\nElse.kind = \"else\";\nclass If extends BlockNode {\n  constructor(condition, nodes) {\n    super(nodes);\n    this.condition = condition;\n  }\n  render(opts) {\n    let code = \"if(\".concat(this.condition, \")\") + super.render(opts);\n    if (this.else) code += \"else \" + this.else.render(opts);\n    return code;\n  }\n  optimizeNodes() {\n    super.optimizeNodes();\n    const cond = this.condition;\n    if (cond === true) return this.nodes; // else is ignored here\n    let e = this.else;\n    if (e) {\n      const ns = e.optimizeNodes();\n      e = this.else = Array.isArray(ns) ? new Else(ns) : ns;\n    }\n    if (e) {\n      if (cond === false) return e instanceof If ? e : e.nodes;\n      if (this.nodes.length) return this;\n      return new If(not(cond), e instanceof If ? [e] : e.nodes);\n    }\n    if (cond === false || !this.nodes.length) return undefined;\n    return this;\n  }\n  optimizeNames(names, constants) {\n    var _a;\n    this.else = (_a = this.else) === null || _a === void 0 ? void 0 : _a.optimizeNames(names, constants);\n    if (!(super.optimizeNames(names, constants) || this.else)) return;\n    this.condition = optimizeExpr(this.condition, names, constants);\n    return this;\n  }\n  get names() {\n    const names = super.names;\n    addExprNames(names, this.condition);\n    if (this.else) addNames(names, this.else.names);\n    return names;\n  }\n}\nIf.kind = \"if\";\nclass For extends BlockNode {}\nFor.kind = \"for\";\nclass ForLoop extends For {\n  constructor(iteration) {\n    super();\n    this.iteration = iteration;\n  }\n  render(opts) {\n    return \"for(\".concat(this.iteration, \")\") + super.render(opts);\n  }\n  optimizeNames(names, constants) {\n    if (!super.optimizeNames(names, constants)) return;\n    this.iteration = optimizeExpr(this.iteration, names, constants);\n    return this;\n  }\n  get names() {\n    return addNames(super.names, this.iteration.names);\n  }\n}\nclass ForRange extends For {\n  constructor(varKind, name, from, to) {\n    super();\n    this.varKind = varKind;\n    this.name = name;\n    this.from = from;\n    this.to = to;\n  }\n  render(opts) {\n    const varKind = opts.es5 ? scope_1.varKinds.var : this.varKind;\n    const {\n      name,\n      from,\n      to\n    } = this;\n    return \"for(\".concat(varKind, \" \").concat(name, \"=\").concat(from, \"; \").concat(name, \"<\").concat(to, \"; \").concat(name, \"++)\") + super.render(opts);\n  }\n  get names() {\n    const names = addExprNames(super.names, this.from);\n    return addExprNames(names, this.to);\n  }\n}\nclass ForIter extends For {\n  constructor(loop, varKind, name, iterable) {\n    super();\n    this.loop = loop;\n    this.varKind = varKind;\n    this.name = name;\n    this.iterable = iterable;\n  }\n  render(opts) {\n    return \"for(\".concat(this.varKind, \" \").concat(this.name, \" \").concat(this.loop, \" \").concat(this.iterable, \")\") + super.render(opts);\n  }\n  optimizeNames(names, constants) {\n    if (!super.optimizeNames(names, constants)) return;\n    this.iterable = optimizeExpr(this.iterable, names, constants);\n    return this;\n  }\n  get names() {\n    return addNames(super.names, this.iterable.names);\n  }\n}\nclass Func extends BlockNode {\n  constructor(name, args, async) {\n    super();\n    this.name = name;\n    this.args = args;\n    this.async = async;\n  }\n  render(opts) {\n    const _async = this.async ? \"async \" : \"\";\n    return \"\".concat(_async, \"function \").concat(this.name, \"(\").concat(this.args, \")\") + super.render(opts);\n  }\n}\nFunc.kind = \"func\";\nclass Return extends ParentNode {\n  render(opts) {\n    return \"return \" + super.render(opts);\n  }\n}\nReturn.kind = \"return\";\nclass Try extends BlockNode {\n  render(opts) {\n    let code = \"try\" + super.render(opts);\n    if (this.catch) code += this.catch.render(opts);\n    if (this.finally) code += this.finally.render(opts);\n    return code;\n  }\n  optimizeNodes() {\n    var _a, _b;\n    super.optimizeNodes();\n    (_a = this.catch) === null || _a === void 0 ? void 0 : _a.optimizeNodes();\n    (_b = this.finally) === null || _b === void 0 ? void 0 : _b.optimizeNodes();\n    return this;\n  }\n  optimizeNames(names, constants) {\n    var _a, _b;\n    super.optimizeNames(names, constants);\n    (_a = this.catch) === null || _a === void 0 ? void 0 : _a.optimizeNames(names, constants);\n    (_b = this.finally) === null || _b === void 0 ? void 0 : _b.optimizeNames(names, constants);\n    return this;\n  }\n  get names() {\n    const names = super.names;\n    if (this.catch) addNames(names, this.catch.names);\n    if (this.finally) addNames(names, this.finally.names);\n    return names;\n  }\n}\nclass Catch extends BlockNode {\n  constructor(error) {\n    super();\n    this.error = error;\n  }\n  render(opts) {\n    return \"catch(\".concat(this.error, \")\") + super.render(opts);\n  }\n}\nCatch.kind = \"catch\";\nclass Finally extends BlockNode {\n  render(opts) {\n    return \"finally\" + super.render(opts);\n  }\n}\nFinally.kind = \"finally\";\nclass CodeGen {\n  constructor(extScope) {\n    let opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    this._values = {};\n    this._blockStarts = [];\n    this._constants = {};\n    this.opts = _objectSpread(_objectSpread({}, opts), {}, {\n      _n: opts.lines ? \"\\n\" : \"\"\n    });\n    this._extScope = extScope;\n    this._scope = new scope_1.Scope({\n      parent: extScope\n    });\n    this._nodes = [new Root()];\n  }\n  toString() {\n    return this._root.render(this.opts);\n  }\n  // returns unique name in the internal scope\n  name(prefix) {\n    return this._scope.name(prefix);\n  }\n  // reserves unique name in the external scope\n  scopeName(prefix) {\n    return this._extScope.name(prefix);\n  }\n  // reserves unique name in the external scope and assigns value to it\n  scopeValue(prefixOrName, value) {\n    const name = this._extScope.value(prefixOrName, value);\n    const vs = this._values[name.prefix] || (this._values[name.prefix] = new Set());\n    vs.add(name);\n    return name;\n  }\n  getScopeValue(prefix, keyOrRef) {\n    return this._extScope.getValue(prefix, keyOrRef);\n  }\n  // return code that assigns values in the external scope to the names that are used internally\n  // (same names that were returned by gen.scopeName or gen.scopeValue)\n  scopeRefs(scopeName) {\n    return this._extScope.scopeRefs(scopeName, this._values);\n  }\n  scopeCode() {\n    return this._extScope.scopeCode(this._values);\n  }\n  _def(varKind, nameOrPrefix, rhs, constant) {\n    const name = this._scope.toName(nameOrPrefix);\n    if (rhs !== undefined && constant) this._constants[name.str] = rhs;\n    this._leafNode(new Def(varKind, name, rhs));\n    return name;\n  }\n  // `const` declaration (`var` in es5 mode)\n  const(nameOrPrefix, rhs, _constant) {\n    return this._def(scope_1.varKinds.const, nameOrPrefix, rhs, _constant);\n  }\n  // `let` declaration with optional assignment (`var` in es5 mode)\n  let(nameOrPrefix, rhs, _constant) {\n    return this._def(scope_1.varKinds.let, nameOrPrefix, rhs, _constant);\n  }\n  // `var` declaration with optional assignment\n  var(nameOrPrefix, rhs, _constant) {\n    return this._def(scope_1.varKinds.var, nameOrPrefix, rhs, _constant);\n  }\n  // assignment code\n  assign(lhs, rhs, sideEffects) {\n    return this._leafNode(new Assign(lhs, rhs, sideEffects));\n  }\n  // `+=` code\n  add(lhs, rhs) {\n    return this._leafNode(new AssignOp(lhs, exports.operators.ADD, rhs));\n  }\n  // appends passed SafeExpr to code or executes Block\n  code(c) {\n    if (typeof c == \"function\") c();else if (c !== code_1.nil) this._leafNode(new AnyCode(c));\n    return this;\n  }\n  // returns code for object literal for the passed argument list of key-value pairs\n  object() {\n    const code = [\"{\"];\n    for (var _len = arguments.length, keyValues = new Array(_len), _key = 0; _key < _len; _key++) {\n      keyValues[_key] = arguments[_key];\n    }\n    for (const [key, value] of keyValues) {\n      if (code.length > 1) code.push(\",\");\n      code.push(key);\n      if (key !== value || this.opts.es5) {\n        code.push(\":\");\n        (0, code_1.addCodeArg)(code, value);\n      }\n    }\n    code.push(\"}\");\n    return new code_1._Code(code);\n  }\n  // `if` clause (or statement if `thenBody` and, optionally, `elseBody` are passed)\n  if(condition, thenBody, elseBody) {\n    this._blockNode(new If(condition));\n    if (thenBody && elseBody) {\n      this.code(thenBody).else().code(elseBody).endIf();\n    } else if (thenBody) {\n      this.code(thenBody).endIf();\n    } else if (elseBody) {\n      throw new Error('CodeGen: \"else\" body without \"then\" body');\n    }\n    return this;\n  }\n  // `else if` clause - invalid without `if` or after `else` clauses\n  elseIf(condition) {\n    return this._elseNode(new If(condition));\n  }\n  // `else` clause - only valid after `if` or `else if` clauses\n  else() {\n    return this._elseNode(new Else());\n  }\n  // end `if` statement (needed if gen.if was used only with condition)\n  endIf() {\n    return this._endBlockNode(If, Else);\n  }\n  _for(node, forBody) {\n    this._blockNode(node);\n    if (forBody) this.code(forBody).endFor();\n    return this;\n  }\n  // a generic `for` clause (or statement if `forBody` is passed)\n  for(iteration, forBody) {\n    return this._for(new ForLoop(iteration), forBody);\n  }\n  // `for` statement for a range of values\n  forRange(nameOrPrefix, from, to, forBody) {\n    let varKind = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : this.opts.es5 ? scope_1.varKinds.var : scope_1.varKinds.let;\n    const name = this._scope.toName(nameOrPrefix);\n    return this._for(new ForRange(varKind, name, from, to), () => forBody(name));\n  }\n  // `for-of` statement (in es5 mode replace with a normal for loop)\n  forOf(nameOrPrefix, iterable, forBody) {\n    let varKind = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : scope_1.varKinds.const;\n    const name = this._scope.toName(nameOrPrefix);\n    if (this.opts.es5) {\n      const arr = iterable instanceof code_1.Name ? iterable : this.var(\"_arr\", iterable);\n      return this.forRange(\"_i\", 0, (0, code_1._)(_templateObject || (_templateObject = _taggedTemplateLiteral([\"\", \".length\"])), arr), i => {\n        this.var(name, (0, code_1._)(_templateObject2 || (_templateObject2 = _taggedTemplateLiteral([\"\", \"[\", \"]\"])), arr, i));\n        forBody(name);\n      });\n    }\n    return this._for(new ForIter(\"of\", varKind, name, iterable), () => forBody(name));\n  }\n  // `for-in` statement.\n  // With option `ownProperties` replaced with a `for-of` loop for object keys\n  forIn(nameOrPrefix, obj, forBody) {\n    let varKind = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : this.opts.es5 ? scope_1.varKinds.var : scope_1.varKinds.const;\n    if (this.opts.ownProperties) {\n      return this.forOf(nameOrPrefix, (0, code_1._)(_templateObject3 || (_templateObject3 = _taggedTemplateLiteral([\"Object.keys(\", \")\"])), obj), forBody);\n    }\n    const name = this._scope.toName(nameOrPrefix);\n    return this._for(new ForIter(\"in\", varKind, name, obj), () => forBody(name));\n  }\n  // end `for` loop\n  endFor() {\n    return this._endBlockNode(For);\n  }\n  // `label` statement\n  label(label) {\n    return this._leafNode(new Label(label));\n  }\n  // `break` statement\n  break(label) {\n    return this._leafNode(new Break(label));\n  }\n  // `return` statement\n  return(value) {\n    const node = new Return();\n    this._blockNode(node);\n    this.code(value);\n    if (node.nodes.length !== 1) throw new Error('CodeGen: \"return\" should have one node');\n    return this._endBlockNode(Return);\n  }\n  // `try` statement\n  try(tryBody, catchCode, finallyCode) {\n    if (!catchCode && !finallyCode) throw new Error('CodeGen: \"try\" without \"catch\" and \"finally\"');\n    const node = new Try();\n    this._blockNode(node);\n    this.code(tryBody);\n    if (catchCode) {\n      const error = this.name(\"e\");\n      this._currNode = node.catch = new Catch(error);\n      catchCode(error);\n    }\n    if (finallyCode) {\n      this._currNode = node.finally = new Finally();\n      this.code(finallyCode);\n    }\n    return this._endBlockNode(Catch, Finally);\n  }\n  // `throw` statement\n  throw(error) {\n    return this._leafNode(new Throw(error));\n  }\n  // start self-balancing block\n  block(body, nodeCount) {\n    this._blockStarts.push(this._nodes.length);\n    if (body) this.code(body).endBlock(nodeCount);\n    return this;\n  }\n  // end the current self-balancing block\n  endBlock(nodeCount) {\n    const len = this._blockStarts.pop();\n    if (len === undefined) throw new Error(\"CodeGen: not in self-balancing block\");\n    const toClose = this._nodes.length - len;\n    if (toClose < 0 || nodeCount !== undefined && toClose !== nodeCount) {\n      throw new Error(\"CodeGen: wrong number of nodes: \".concat(toClose, \" vs \").concat(nodeCount, \" expected\"));\n    }\n    this._nodes.length = len;\n    return this;\n  }\n  // `function` heading (or definition if funcBody is passed)\n  func(name) {\n    let args = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : code_1.nil;\n    let async = arguments.length > 2 ? arguments[2] : undefined;\n    let funcBody = arguments.length > 3 ? arguments[3] : undefined;\n    this._blockNode(new Func(name, args, async));\n    if (funcBody) this.code(funcBody).endFunc();\n    return this;\n  }\n  // end function definition\n  endFunc() {\n    return this._endBlockNode(Func);\n  }\n  optimize() {\n    let n = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;\n    while (n-- > 0) {\n      this._root.optimizeNodes();\n      this._root.optimizeNames(this._root.names, this._constants);\n    }\n  }\n  _leafNode(node) {\n    this._currNode.nodes.push(node);\n    return this;\n  }\n  _blockNode(node) {\n    this._currNode.nodes.push(node);\n    this._nodes.push(node);\n  }\n  _endBlockNode(N1, N2) {\n    const n = this._currNode;\n    if (n instanceof N1 || N2 && n instanceof N2) {\n      this._nodes.pop();\n      return this;\n    }\n    throw new Error(\"CodeGen: not in block \\\"\".concat(N2 ? \"\".concat(N1.kind, \"/\").concat(N2.kind) : N1.kind, \"\\\"\"));\n  }\n  _elseNode(node) {\n    const n = this._currNode;\n    if (!(n instanceof If)) {\n      throw new Error('CodeGen: \"else\" without \"if\"');\n    }\n    this._currNode = n.else = node;\n    return this;\n  }\n  get _root() {\n    return this._nodes[0];\n  }\n  get _currNode() {\n    const ns = this._nodes;\n    return ns[ns.length - 1];\n  }\n  set _currNode(node) {\n    const ns = this._nodes;\n    ns[ns.length - 1] = node;\n  }\n}\nexports.CodeGen = CodeGen;\nfunction addNames(names, from) {\n  for (const n in from) names[n] = (names[n] || 0) + (from[n] || 0);\n  return names;\n}\nfunction addExprNames(names, from) {\n  return from instanceof code_1._CodeOrName ? addNames(names, from.names) : names;\n}\nfunction optimizeExpr(expr, names, constants) {\n  if (expr instanceof code_1.Name) return replaceName(expr);\n  if (!canOptimize(expr)) return expr;\n  return new code_1._Code(expr._items.reduce((items, c) => {\n    if (c instanceof code_1.Name) c = replaceName(c);\n    if (c instanceof code_1._Code) items.push(...c._items);else items.push(c);\n    return items;\n  }, []));\n  function replaceName(n) {\n    const c = constants[n.str];\n    if (c === undefined || names[n.str] !== 1) return n;\n    delete names[n.str];\n    return c;\n  }\n  function canOptimize(e) {\n    return e instanceof code_1._Code && e._items.some(c => c instanceof code_1.Name && names[c.str] === 1 && constants[c.str] !== undefined);\n  }\n}\nfunction subtractNames(names, from) {\n  for (const n in from) names[n] = (names[n] || 0) - (from[n] || 0);\n}\nfunction not(x) {\n  return typeof x == \"boolean\" || typeof x == \"number\" || x === null ? !x : (0, code_1._)(_templateObject4 || (_templateObject4 = _taggedTemplateLiteral([\"!\", \"\"])), par(x));\n}\nexports.not = not;\nconst andCode = mappend(exports.operators.AND);\n// boolean AND (&&) expression with the passed arguments\nfunction and() {\n  for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n    args[_key2] = arguments[_key2];\n  }\n  return args.reduce(andCode);\n}\nexports.and = and;\nconst orCode = mappend(exports.operators.OR);\n// boolean OR (||) expression with the passed arguments\nfunction or() {\n  for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n    args[_key3] = arguments[_key3];\n  }\n  return args.reduce(orCode);\n}\nexports.or = or;\nfunction mappend(op) {\n  return (x, y) => x === code_1.nil ? y : y === code_1.nil ? x : (0, code_1._)(_templateObject5 || (_templateObject5 = _taggedTemplateLiteral([\"\", \" \", \" \", \"\"])), par(x), op, par(y));\n}\nfunction par(x) {\n  return x instanceof code_1.Name ? x : (0, code_1._)(_templateObject6 || (_templateObject6 = _taggedTemplateLiteral([\"(\", \")\"])), x);\n}","map":{"version":3,"names":["code_1","require","scope_1","code_2","Object","defineProperty","exports","enumerable","get","_","str","strConcat","nil","getProperty","stringify","regexpCode","Name","scope_2","Scope","ValueScope","ValueScopeName","varKinds","operators","GT","_Code","GTE","LT","LTE","EQ","NEQ","NOT","OR","AND","ADD","Node","optimizeNodes","optimizeNames","_names","_constants","Def","constructor","varKind","name","rhs","render","_ref","es5","_n","var","undefined","concat","names","constants","optimizeExpr","_CodeOrName","Assign","lhs","sideEffects","_ref2","_objectSpread","addExprNames","AssignOp","op","_ref3","Label","label","_ref4","Break","_ref5","Throw","error","_ref6","AnyCode","code","_ref7","ParentNode","nodes","arguments","length","opts","reduce","n","i","Array","isArray","splice","subtractNames","addNames","BlockNode","Root","Else","kind","If","condition","else","cond","e","ns","not","_a","For","ForLoop","iteration","ForRange","from","to","ForIter","loop","iterable","Func","args","async","_async","Return","Try","catch","finally","_b","Catch","Finally","CodeGen","extScope","_values","_blockStarts","lines","_extScope","_scope","parent","_nodes","toString","_root","prefix","scopeName","scopeValue","prefixOrName","value","vs","Set","add","getScopeValue","keyOrRef","getValue","scopeRefs","scopeCode","_def","nameOrPrefix","constant","toName","_leafNode","const","_constant","let","assign","c","object","_len","keyValues","_key","key","push","addCodeArg","if","thenBody","elseBody","_blockNode","endIf","Error","elseIf","_elseNode","_endBlockNode","_for","node","forBody","endFor","for","forRange","forOf","arr","_templateObject","_taggedTemplateLiteral","_templateObject2","forIn","obj","ownProperties","_templateObject3","break","return","try","tryBody","catchCode","finallyCode","_currNode","throw","block","body","nodeCount","endBlock","len","pop","toClose","func","funcBody","endFunc","optimize","N1","N2","expr","replaceName","canOptimize","_items","items","some","x","_templateObject4","par","andCode","mappend","and","_len2","_key2","orCode","or","_len3","_key3","y","_templateObject5","_templateObject6"],"sources":["/home/runner/work/sgex/sgex/node_modules/ajv/lib/compile/codegen/index.ts"],"sourcesContent":["import type {ScopeValueSets, NameValue, ValueScope, ValueScopeName} from \"./scope\"\nimport {_, nil, _Code, Code, Name, UsedNames, CodeItem, addCodeArg, _CodeOrName} from \"./code\"\nimport {Scope, varKinds} from \"./scope\"\n\nexport {_, str, strConcat, nil, getProperty, stringify, regexpCode, Name, Code} from \"./code\"\nexport {Scope, ScopeStore, ValueScope, ValueScopeName, ScopeValueSets, varKinds} from \"./scope\"\n\n// type for expressions that can be safely inserted in code without quotes\nexport type SafeExpr = Code | number | boolean | null\n\n// type that is either Code of function that adds code to CodeGen instance using its methods\nexport type Block = Code | (() => void)\n\nexport const operators = {\n  GT: new _Code(\">\"),\n  GTE: new _Code(\">=\"),\n  LT: new _Code(\"<\"),\n  LTE: new _Code(\"<=\"),\n  EQ: new _Code(\"===\"),\n  NEQ: new _Code(\"!==\"),\n  NOT: new _Code(\"!\"),\n  OR: new _Code(\"||\"),\n  AND: new _Code(\"&&\"),\n  ADD: new _Code(\"+\"),\n}\n\nabstract class Node {\n  abstract readonly names: UsedNames\n\n  optimizeNodes(): this | ChildNode | ChildNode[] | undefined {\n    return this\n  }\n\n  optimizeNames(_names: UsedNames, _constants: Constants): this | undefined {\n    return this\n  }\n\n  // get count(): number {\n  //   return 1\n  // }\n}\n\nclass Def extends Node {\n  constructor(\n    private readonly varKind: Name,\n    private readonly name: Name,\n    private rhs?: SafeExpr\n  ) {\n    super()\n  }\n\n  render({es5, _n}: CGOptions): string {\n    const varKind = es5 ? varKinds.var : this.varKind\n    const rhs = this.rhs === undefined ? \"\" : ` = ${this.rhs}`\n    return `${varKind} ${this.name}${rhs};` + _n\n  }\n\n  optimizeNames(names: UsedNames, constants: Constants): this | undefined {\n    if (!names[this.name.str]) return\n    if (this.rhs) this.rhs = optimizeExpr(this.rhs, names, constants)\n    return this\n  }\n\n  get names(): UsedNames {\n    return this.rhs instanceof _CodeOrName ? this.rhs.names : {}\n  }\n}\n\nclass Assign extends Node {\n  constructor(\n    readonly lhs: Code,\n    public rhs: SafeExpr,\n    private readonly sideEffects?: boolean\n  ) {\n    super()\n  }\n\n  render({_n}: CGOptions): string {\n    return `${this.lhs} = ${this.rhs};` + _n\n  }\n\n  optimizeNames(names: UsedNames, constants: Constants): this | undefined {\n    if (this.lhs instanceof Name && !names[this.lhs.str] && !this.sideEffects) return\n    this.rhs = optimizeExpr(this.rhs, names, constants)\n    return this\n  }\n\n  get names(): UsedNames {\n    const names = this.lhs instanceof Name ? {} : {...this.lhs.names}\n    return addExprNames(names, this.rhs)\n  }\n}\n\nclass AssignOp extends Assign {\n  constructor(\n    lhs: Code,\n    private readonly op: Code,\n    rhs: SafeExpr,\n    sideEffects?: boolean\n  ) {\n    super(lhs, rhs, sideEffects)\n  }\n\n  render({_n}: CGOptions): string {\n    return `${this.lhs} ${this.op}= ${this.rhs};` + _n\n  }\n}\n\nclass Label extends Node {\n  readonly names: UsedNames = {}\n  constructor(readonly label: Name) {\n    super()\n  }\n\n  render({_n}: CGOptions): string {\n    return `${this.label}:` + _n\n  }\n}\n\nclass Break extends Node {\n  readonly names: UsedNames = {}\n  constructor(readonly label?: Code) {\n    super()\n  }\n\n  render({_n}: CGOptions): string {\n    const label = this.label ? ` ${this.label}` : \"\"\n    return `break${label};` + _n\n  }\n}\n\nclass Throw extends Node {\n  constructor(readonly error: Code) {\n    super()\n  }\n\n  render({_n}: CGOptions): string {\n    return `throw ${this.error};` + _n\n  }\n\n  get names(): UsedNames {\n    return this.error.names\n  }\n}\n\nclass AnyCode extends Node {\n  constructor(private code: SafeExpr) {\n    super()\n  }\n\n  render({_n}: CGOptions): string {\n    return `${this.code};` + _n\n  }\n\n  optimizeNodes(): this | undefined {\n    return `${this.code}` ? this : undefined\n  }\n\n  optimizeNames(names: UsedNames, constants: Constants): this {\n    this.code = optimizeExpr(this.code, names, constants)\n    return this\n  }\n\n  get names(): UsedNames {\n    return this.code instanceof _CodeOrName ? this.code.names : {}\n  }\n}\n\nabstract class ParentNode extends Node {\n  constructor(readonly nodes: ChildNode[] = []) {\n    super()\n  }\n\n  render(opts: CGOptions): string {\n    return this.nodes.reduce((code, n) => code + n.render(opts), \"\")\n  }\n\n  optimizeNodes(): this | ChildNode | ChildNode[] | undefined {\n    const {nodes} = this\n    let i = nodes.length\n    while (i--) {\n      const n = nodes[i].optimizeNodes()\n      if (Array.isArray(n)) nodes.splice(i, 1, ...n)\n      else if (n) nodes[i] = n\n      else nodes.splice(i, 1)\n    }\n    return nodes.length > 0 ? this : undefined\n  }\n\n  optimizeNames(names: UsedNames, constants: Constants): this | undefined {\n    const {nodes} = this\n    let i = nodes.length\n    while (i--) {\n      // iterating backwards improves 1-pass optimization\n      const n = nodes[i]\n      if (n.optimizeNames(names, constants)) continue\n      subtractNames(names, n.names)\n      nodes.splice(i, 1)\n    }\n    return nodes.length > 0 ? this : undefined\n  }\n\n  get names(): UsedNames {\n    return this.nodes.reduce((names: UsedNames, n) => addNames(names, n.names), {})\n  }\n\n  // get count(): number {\n  //   return this.nodes.reduce((c, n) => c + n.count, 1)\n  // }\n}\n\nabstract class BlockNode extends ParentNode {\n  render(opts: CGOptions): string {\n    return \"{\" + opts._n + super.render(opts) + \"}\" + opts._n\n  }\n}\n\nclass Root extends ParentNode {}\n\nclass Else extends BlockNode {\n  static readonly kind = \"else\"\n}\n\nclass If extends BlockNode {\n  static readonly kind = \"if\"\n  else?: If | Else\n  constructor(\n    private condition: Code | boolean,\n    nodes?: ChildNode[]\n  ) {\n    super(nodes)\n  }\n\n  render(opts: CGOptions): string {\n    let code = `if(${this.condition})` + super.render(opts)\n    if (this.else) code += \"else \" + this.else.render(opts)\n    return code\n  }\n\n  optimizeNodes(): If | ChildNode[] | undefined {\n    super.optimizeNodes()\n    const cond = this.condition\n    if (cond === true) return this.nodes // else is ignored here\n    let e = this.else\n    if (e) {\n      const ns = e.optimizeNodes()\n      e = this.else = Array.isArray(ns) ? new Else(ns) : (ns as Else | undefined)\n    }\n    if (e) {\n      if (cond === false) return e instanceof If ? e : e.nodes\n      if (this.nodes.length) return this\n      return new If(not(cond), e instanceof If ? [e] : e.nodes)\n    }\n    if (cond === false || !this.nodes.length) return undefined\n    return this\n  }\n\n  optimizeNames(names: UsedNames, constants: Constants): this | undefined {\n    this.else = this.else?.optimizeNames(names, constants)\n    if (!(super.optimizeNames(names, constants) || this.else)) return\n    this.condition = optimizeExpr(this.condition, names, constants)\n    return this\n  }\n\n  get names(): UsedNames {\n    const names = super.names\n    addExprNames(names, this.condition)\n    if (this.else) addNames(names, this.else.names)\n    return names\n  }\n\n  // get count(): number {\n  //   return super.count + (this.else?.count || 0)\n  // }\n}\n\nabstract class For extends BlockNode {\n  static readonly kind = \"for\"\n}\n\nclass ForLoop extends For {\n  constructor(private iteration: Code) {\n    super()\n  }\n\n  render(opts: CGOptions): string {\n    return `for(${this.iteration})` + super.render(opts)\n  }\n\n  optimizeNames(names: UsedNames, constants: Constants): this | undefined {\n    if (!super.optimizeNames(names, constants)) return\n    this.iteration = optimizeExpr(this.iteration, names, constants)\n    return this\n  }\n\n  get names(): UsedNames {\n    return addNames(super.names, this.iteration.names)\n  }\n}\n\nclass ForRange extends For {\n  constructor(\n    private readonly varKind: Name,\n    private readonly name: Name,\n    private readonly from: SafeExpr,\n    private readonly to: SafeExpr\n  ) {\n    super()\n  }\n\n  render(opts: CGOptions): string {\n    const varKind = opts.es5 ? varKinds.var : this.varKind\n    const {name, from, to} = this\n    return `for(${varKind} ${name}=${from}; ${name}<${to}; ${name}++)` + super.render(opts)\n  }\n\n  get names(): UsedNames {\n    const names = addExprNames(super.names, this.from)\n    return addExprNames(names, this.to)\n  }\n}\n\nclass ForIter extends For {\n  constructor(\n    private readonly loop: \"of\" | \"in\",\n    private readonly varKind: Name,\n    private readonly name: Name,\n    private iterable: Code\n  ) {\n    super()\n  }\n\n  render(opts: CGOptions): string {\n    return `for(${this.varKind} ${this.name} ${this.loop} ${this.iterable})` + super.render(opts)\n  }\n\n  optimizeNames(names: UsedNames, constants: Constants): this | undefined {\n    if (!super.optimizeNames(names, constants)) return\n    this.iterable = optimizeExpr(this.iterable, names, constants)\n    return this\n  }\n\n  get names(): UsedNames {\n    return addNames(super.names, this.iterable.names)\n  }\n}\n\nclass Func extends BlockNode {\n  static readonly kind = \"func\"\n  constructor(\n    public name: Name,\n    public args: Code,\n    public async?: boolean\n  ) {\n    super()\n  }\n\n  render(opts: CGOptions): string {\n    const _async = this.async ? \"async \" : \"\"\n    return `${_async}function ${this.name}(${this.args})` + super.render(opts)\n  }\n}\n\nclass Return extends ParentNode {\n  static readonly kind = \"return\"\n\n  render(opts: CGOptions): string {\n    return \"return \" + super.render(opts)\n  }\n}\n\nclass Try extends BlockNode {\n  catch?: Catch\n  finally?: Finally\n\n  render(opts: CGOptions): string {\n    let code = \"try\" + super.render(opts)\n    if (this.catch) code += this.catch.render(opts)\n    if (this.finally) code += this.finally.render(opts)\n    return code\n  }\n\n  optimizeNodes(): this {\n    super.optimizeNodes()\n    this.catch?.optimizeNodes() as Catch | undefined\n    this.finally?.optimizeNodes() as Finally | undefined\n    return this\n  }\n\n  optimizeNames(names: UsedNames, constants: Constants): this {\n    super.optimizeNames(names, constants)\n    this.catch?.optimizeNames(names, constants)\n    this.finally?.optimizeNames(names, constants)\n    return this\n  }\n\n  get names(): UsedNames {\n    const names = super.names\n    if (this.catch) addNames(names, this.catch.names)\n    if (this.finally) addNames(names, this.finally.names)\n    return names\n  }\n\n  // get count(): number {\n  //   return super.count + (this.catch?.count || 0) + (this.finally?.count || 0)\n  // }\n}\n\nclass Catch extends BlockNode {\n  static readonly kind = \"catch\"\n  constructor(readonly error: Name) {\n    super()\n  }\n\n  render(opts: CGOptions): string {\n    return `catch(${this.error})` + super.render(opts)\n  }\n}\n\nclass Finally extends BlockNode {\n  static readonly kind = \"finally\"\n  render(opts: CGOptions): string {\n    return \"finally\" + super.render(opts)\n  }\n}\n\ntype StartBlockNode = If | For | Func | Return | Try\n\ntype LeafNode = Def | Assign | Label | Break | Throw | AnyCode\n\ntype ChildNode = StartBlockNode | LeafNode\n\ntype EndBlockNodeType =\n  | typeof If\n  | typeof Else\n  | typeof For\n  | typeof Func\n  | typeof Return\n  | typeof Catch\n  | typeof Finally\n\ntype Constants = Record<string, SafeExpr | undefined>\n\nexport interface CodeGenOptions {\n  es5?: boolean\n  lines?: boolean\n  ownProperties?: boolean\n}\n\ninterface CGOptions extends CodeGenOptions {\n  _n: \"\\n\" | \"\"\n}\n\nexport class CodeGen {\n  readonly _scope: Scope\n  readonly _extScope: ValueScope\n  readonly _values: ScopeValueSets = {}\n  private readonly _nodes: ParentNode[]\n  private readonly _blockStarts: number[] = []\n  private readonly _constants: Constants = {}\n  private readonly opts: CGOptions\n\n  constructor(extScope: ValueScope, opts: CodeGenOptions = {}) {\n    this.opts = {...opts, _n: opts.lines ? \"\\n\" : \"\"}\n    this._extScope = extScope\n    this._scope = new Scope({parent: extScope})\n    this._nodes = [new Root()]\n  }\n\n  toString(): string {\n    return this._root.render(this.opts)\n  }\n\n  // returns unique name in the internal scope\n  name(prefix: string): Name {\n    return this._scope.name(prefix)\n  }\n\n  // reserves unique name in the external scope\n  scopeName(prefix: string): ValueScopeName {\n    return this._extScope.name(prefix)\n  }\n\n  // reserves unique name in the external scope and assigns value to it\n  scopeValue(prefixOrName: ValueScopeName | string, value: NameValue): Name {\n    const name = this._extScope.value(prefixOrName, value)\n    const vs = this._values[name.prefix] || (this._values[name.prefix] = new Set())\n    vs.add(name)\n    return name\n  }\n\n  getScopeValue(prefix: string, keyOrRef: unknown): ValueScopeName | undefined {\n    return this._extScope.getValue(prefix, keyOrRef)\n  }\n\n  // return code that assigns values in the external scope to the names that are used internally\n  // (same names that were returned by gen.scopeName or gen.scopeValue)\n  scopeRefs(scopeName: Name): Code {\n    return this._extScope.scopeRefs(scopeName, this._values)\n  }\n\n  scopeCode(): Code {\n    return this._extScope.scopeCode(this._values)\n  }\n\n  private _def(\n    varKind: Name,\n    nameOrPrefix: Name | string,\n    rhs?: SafeExpr,\n    constant?: boolean\n  ): Name {\n    const name = this._scope.toName(nameOrPrefix)\n    if (rhs !== undefined && constant) this._constants[name.str] = rhs\n    this._leafNode(new Def(varKind, name, rhs))\n    return name\n  }\n\n  // `const` declaration (`var` in es5 mode)\n  const(nameOrPrefix: Name | string, rhs: SafeExpr, _constant?: boolean): Name {\n    return this._def(varKinds.const, nameOrPrefix, rhs, _constant)\n  }\n\n  // `let` declaration with optional assignment (`var` in es5 mode)\n  let(nameOrPrefix: Name | string, rhs?: SafeExpr, _constant?: boolean): Name {\n    return this._def(varKinds.let, nameOrPrefix, rhs, _constant)\n  }\n\n  // `var` declaration with optional assignment\n  var(nameOrPrefix: Name | string, rhs?: SafeExpr, _constant?: boolean): Name {\n    return this._def(varKinds.var, nameOrPrefix, rhs, _constant)\n  }\n\n  // assignment code\n  assign(lhs: Code, rhs: SafeExpr, sideEffects?: boolean): CodeGen {\n    return this._leafNode(new Assign(lhs, rhs, sideEffects))\n  }\n\n  // `+=` code\n  add(lhs: Code, rhs: SafeExpr): CodeGen {\n    return this._leafNode(new AssignOp(lhs, operators.ADD, rhs))\n  }\n\n  // appends passed SafeExpr to code or executes Block\n  code(c: Block | SafeExpr): CodeGen {\n    if (typeof c == \"function\") c()\n    else if (c !== nil) this._leafNode(new AnyCode(c))\n    return this\n  }\n\n  // returns code for object literal for the passed argument list of key-value pairs\n  object(...keyValues: [Name | string, SafeExpr | string][]): _Code {\n    const code: CodeItem[] = [\"{\"]\n    for (const [key, value] of keyValues) {\n      if (code.length > 1) code.push(\",\")\n      code.push(key)\n      if (key !== value || this.opts.es5) {\n        code.push(\":\")\n        addCodeArg(code, value)\n      }\n    }\n    code.push(\"}\")\n    return new _Code(code)\n  }\n\n  // `if` clause (or statement if `thenBody` and, optionally, `elseBody` are passed)\n  if(condition: Code | boolean, thenBody?: Block, elseBody?: Block): CodeGen {\n    this._blockNode(new If(condition))\n\n    if (thenBody && elseBody) {\n      this.code(thenBody).else().code(elseBody).endIf()\n    } else if (thenBody) {\n      this.code(thenBody).endIf()\n    } else if (elseBody) {\n      throw new Error('CodeGen: \"else\" body without \"then\" body')\n    }\n    return this\n  }\n\n  // `else if` clause - invalid without `if` or after `else` clauses\n  elseIf(condition: Code | boolean): CodeGen {\n    return this._elseNode(new If(condition))\n  }\n\n  // `else` clause - only valid after `if` or `else if` clauses\n  else(): CodeGen {\n    return this._elseNode(new Else())\n  }\n\n  // end `if` statement (needed if gen.if was used only with condition)\n  endIf(): CodeGen {\n    return this._endBlockNode(If, Else)\n  }\n\n  private _for(node: For, forBody?: Block): CodeGen {\n    this._blockNode(node)\n    if (forBody) this.code(forBody).endFor()\n    return this\n  }\n\n  // a generic `for` clause (or statement if `forBody` is passed)\n  for(iteration: Code, forBody?: Block): CodeGen {\n    return this._for(new ForLoop(iteration), forBody)\n  }\n\n  // `for` statement for a range of values\n  forRange(\n    nameOrPrefix: Name | string,\n    from: SafeExpr,\n    to: SafeExpr,\n    forBody: (index: Name) => void,\n    varKind: Code = this.opts.es5 ? varKinds.var : varKinds.let\n  ): CodeGen {\n    const name = this._scope.toName(nameOrPrefix)\n    return this._for(new ForRange(varKind, name, from, to), () => forBody(name))\n  }\n\n  // `for-of` statement (in es5 mode replace with a normal for loop)\n  forOf(\n    nameOrPrefix: Name | string,\n    iterable: Code,\n    forBody: (item: Name) => void,\n    varKind: Code = varKinds.const\n  ): CodeGen {\n    const name = this._scope.toName(nameOrPrefix)\n    if (this.opts.es5) {\n      const arr = iterable instanceof Name ? iterable : this.var(\"_arr\", iterable)\n      return this.forRange(\"_i\", 0, _`${arr}.length`, (i) => {\n        this.var(name, _`${arr}[${i}]`)\n        forBody(name)\n      })\n    }\n    return this._for(new ForIter(\"of\", varKind, name, iterable), () => forBody(name))\n  }\n\n  // `for-in` statement.\n  // With option `ownProperties` replaced with a `for-of` loop for object keys\n  forIn(\n    nameOrPrefix: Name | string,\n    obj: Code,\n    forBody: (item: Name) => void,\n    varKind: Code = this.opts.es5 ? varKinds.var : varKinds.const\n  ): CodeGen {\n    if (this.opts.ownProperties) {\n      return this.forOf(nameOrPrefix, _`Object.keys(${obj})`, forBody)\n    }\n    const name = this._scope.toName(nameOrPrefix)\n    return this._for(new ForIter(\"in\", varKind, name, obj), () => forBody(name))\n  }\n\n  // end `for` loop\n  endFor(): CodeGen {\n    return this._endBlockNode(For)\n  }\n\n  // `label` statement\n  label(label: Name): CodeGen {\n    return this._leafNode(new Label(label))\n  }\n\n  // `break` statement\n  break(label?: Code): CodeGen {\n    return this._leafNode(new Break(label))\n  }\n\n  // `return` statement\n  return(value: Block | SafeExpr): CodeGen {\n    const node = new Return()\n    this._blockNode(node)\n    this.code(value)\n    if (node.nodes.length !== 1) throw new Error('CodeGen: \"return\" should have one node')\n    return this._endBlockNode(Return)\n  }\n\n  // `try` statement\n  try(tryBody: Block, catchCode?: (e: Name) => void, finallyCode?: Block): CodeGen {\n    if (!catchCode && !finallyCode) throw new Error('CodeGen: \"try\" without \"catch\" and \"finally\"')\n    const node = new Try()\n    this._blockNode(node)\n    this.code(tryBody)\n    if (catchCode) {\n      const error = this.name(\"e\")\n      this._currNode = node.catch = new Catch(error)\n      catchCode(error)\n    }\n    if (finallyCode) {\n      this._currNode = node.finally = new Finally()\n      this.code(finallyCode)\n    }\n    return this._endBlockNode(Catch, Finally)\n  }\n\n  // `throw` statement\n  throw(error: Code): CodeGen {\n    return this._leafNode(new Throw(error))\n  }\n\n  // start self-balancing block\n  block(body?: Block, nodeCount?: number): CodeGen {\n    this._blockStarts.push(this._nodes.length)\n    if (body) this.code(body).endBlock(nodeCount)\n    return this\n  }\n\n  // end the current self-balancing block\n  endBlock(nodeCount?: number): CodeGen {\n    const len = this._blockStarts.pop()\n    if (len === undefined) throw new Error(\"CodeGen: not in self-balancing block\")\n    const toClose = this._nodes.length - len\n    if (toClose < 0 || (nodeCount !== undefined && toClose !== nodeCount)) {\n      throw new Error(`CodeGen: wrong number of nodes: ${toClose} vs ${nodeCount} expected`)\n    }\n    this._nodes.length = len\n    return this\n  }\n\n  // `function` heading (or definition if funcBody is passed)\n  func(name: Name, args: Code = nil, async?: boolean, funcBody?: Block): CodeGen {\n    this._blockNode(new Func(name, args, async))\n    if (funcBody) this.code(funcBody).endFunc()\n    return this\n  }\n\n  // end function definition\n  endFunc(): CodeGen {\n    return this._endBlockNode(Func)\n  }\n\n  optimize(n = 1): void {\n    while (n-- > 0) {\n      this._root.optimizeNodes()\n      this._root.optimizeNames(this._root.names, this._constants)\n    }\n  }\n\n  private _leafNode(node: LeafNode): CodeGen {\n    this._currNode.nodes.push(node)\n    return this\n  }\n\n  private _blockNode(node: StartBlockNode): void {\n    this._currNode.nodes.push(node)\n    this._nodes.push(node)\n  }\n\n  private _endBlockNode(N1: EndBlockNodeType, N2?: EndBlockNodeType): CodeGen {\n    const n = this._currNode\n    if (n instanceof N1 || (N2 && n instanceof N2)) {\n      this._nodes.pop()\n      return this\n    }\n    throw new Error(`CodeGen: not in block \"${N2 ? `${N1.kind}/${N2.kind}` : N1.kind}\"`)\n  }\n\n  private _elseNode(node: If | Else): CodeGen {\n    const n = this._currNode\n    if (!(n instanceof If)) {\n      throw new Error('CodeGen: \"else\" without \"if\"')\n    }\n    this._currNode = n.else = node\n    return this\n  }\n\n  private get _root(): Root {\n    return this._nodes[0] as Root\n  }\n\n  private get _currNode(): ParentNode {\n    const ns = this._nodes\n    return ns[ns.length - 1]\n  }\n\n  private set _currNode(node: ParentNode) {\n    const ns = this._nodes\n    ns[ns.length - 1] = node\n  }\n\n  // get nodeCount(): number {\n  //   return this._root.count\n  // }\n}\n\nfunction addNames(names: UsedNames, from: UsedNames): UsedNames {\n  for (const n in from) names[n] = (names[n] || 0) + (from[n] || 0)\n  return names\n}\n\nfunction addExprNames(names: UsedNames, from: SafeExpr): UsedNames {\n  return from instanceof _CodeOrName ? addNames(names, from.names) : names\n}\n\nfunction optimizeExpr<T extends SafeExpr | Code>(expr: T, names: UsedNames, constants: Constants): T\nfunction optimizeExpr(expr: SafeExpr, names: UsedNames, constants: Constants): SafeExpr {\n  if (expr instanceof Name) return replaceName(expr)\n  if (!canOptimize(expr)) return expr\n  return new _Code(\n    expr._items.reduce((items: CodeItem[], c: SafeExpr | string) => {\n      if (c instanceof Name) c = replaceName(c)\n      if (c instanceof _Code) items.push(...c._items)\n      else items.push(c)\n      return items\n    }, [])\n  )\n\n  function replaceName(n: Name): SafeExpr {\n    const c = constants[n.str]\n    if (c === undefined || names[n.str] !== 1) return n\n    delete names[n.str]\n    return c\n  }\n\n  function canOptimize(e: SafeExpr): e is _Code {\n    return (\n      e instanceof _Code &&\n      e._items.some(\n        (c) => c instanceof Name && names[c.str] === 1 && constants[c.str] !== undefined\n      )\n    )\n  }\n}\n\nfunction subtractNames(names: UsedNames, from: UsedNames): void {\n  for (const n in from) names[n] = (names[n] || 0) - (from[n] || 0)\n}\n\nexport function not<T extends Code | SafeExpr>(x: T): T\nexport function not(x: Code | SafeExpr): Code | SafeExpr {\n  return typeof x == \"boolean\" || typeof x == \"number\" || x === null ? !x : _`!${par(x)}`\n}\n\nconst andCode = mappend(operators.AND)\n\n// boolean AND (&&) expression with the passed arguments\nexport function and(...args: Code[]): Code {\n  return args.reduce(andCode)\n}\n\nconst orCode = mappend(operators.OR)\n\n// boolean OR (||) expression with the passed arguments\nexport function or(...args: Code[]): Code {\n  return args.reduce(orCode)\n}\n\ntype MAppend = (x: Code, y: Code) => Code\n\nfunction mappend(op: Code): MAppend {\n  return (x, y) => (x === nil ? y : y === nil ? x : _`${par(x)} ${op} ${par(y)}`)\n}\n\nfunction par(x: Code): Code {\n  return x instanceof Name ? x : _`(${x})`\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}