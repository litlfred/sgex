{"ast":null,"code":"import { assign, forEach } from 'min-dash';\nimport { getResizedSourceAnchor, getResizedTargetAnchor } from './helper/AnchorsHelper';\n\n/**\n * @typedef {import('../Modeling').default} Modeling\n */\n\n/**\n * A handler that implements reversible resizing of shapes.\n *\n * @param {Modeling} modeling\n */\nexport default function ResizeShapeHandler(modeling) {\n  this._modeling = modeling;\n}\nResizeShapeHandler.$inject = ['modeling'];\n\n/**\n * {\n *   shape: {....}\n *   newBounds: {\n *     width:  20,\n *     height: 40,\n *     x:       5,\n *     y:      10\n *   }\n *\n * }\n */\nResizeShapeHandler.prototype.execute = function (context) {\n  var shape = context.shape,\n    newBounds = context.newBounds,\n    minBounds = context.minBounds;\n  if (newBounds.x === undefined || newBounds.y === undefined || newBounds.width === undefined || newBounds.height === undefined) {\n    throw new Error('newBounds must have {x, y, width, height} properties');\n  }\n  if (minBounds && (newBounds.width < minBounds.width || newBounds.height < minBounds.height)) {\n    throw new Error('width and height cannot be less than minimum height and width');\n  } else if (!minBounds && newBounds.width < 10 || newBounds.height < 10) {\n    throw new Error('width and height cannot be less than 10px');\n  }\n\n  // save old bbox in context\n  context.oldBounds = {\n    width: shape.width,\n    height: shape.height,\n    x: shape.x,\n    y: shape.y\n  };\n\n  // update shape\n  assign(shape, {\n    width: newBounds.width,\n    height: newBounds.height,\n    x: newBounds.x,\n    y: newBounds.y\n  });\n  return shape;\n};\nResizeShapeHandler.prototype.postExecute = function (context) {\n  var modeling = this._modeling;\n  var shape = context.shape,\n    oldBounds = context.oldBounds,\n    hints = context.hints || {};\n  if (hints.layout === false) {\n    return;\n  }\n  forEach(shape.incoming, function (c) {\n    modeling.layoutConnection(c, {\n      connectionEnd: getResizedTargetAnchor(c, shape, oldBounds)\n    });\n  });\n  forEach(shape.outgoing, function (c) {\n    modeling.layoutConnection(c, {\n      connectionStart: getResizedSourceAnchor(c, shape, oldBounds)\n    });\n  });\n};\nResizeShapeHandler.prototype.revert = function (context) {\n  var shape = context.shape,\n    oldBounds = context.oldBounds;\n\n  // restore previous bbox\n  assign(shape, {\n    width: oldBounds.width,\n    height: oldBounds.height,\n    x: oldBounds.x,\n    y: oldBounds.y\n  });\n  return shape;\n};","map":{"version":3,"names":["assign","forEach","getResizedSourceAnchor","getResizedTargetAnchor","ResizeShapeHandler","modeling","_modeling","$inject","prototype","execute","context","shape","newBounds","minBounds","x","undefined","y","width","height","Error","oldBounds","postExecute","hints","layout","incoming","c","layoutConnection","connectionEnd","outgoing","connectionStart","revert"],"sources":["/home/runner/work/sgex/sgex/node_modules/diagram-js/lib/features/modeling/cmd/ResizeShapeHandler.js"],"sourcesContent":["import {\n  assign,\n  forEach\n} from 'min-dash';\n\nimport {\n  getResizedSourceAnchor,\n  getResizedTargetAnchor\n} from './helper/AnchorsHelper';\n\n/**\n * @typedef {import('../Modeling').default} Modeling\n */\n\n/**\n * A handler that implements reversible resizing of shapes.\n *\n * @param {Modeling} modeling\n */\nexport default function ResizeShapeHandler(modeling) {\n  this._modeling = modeling;\n}\n\nResizeShapeHandler.$inject = [ 'modeling' ];\n\n/**\n * {\n *   shape: {....}\n *   newBounds: {\n *     width:  20,\n *     height: 40,\n *     x:       5,\n *     y:      10\n *   }\n *\n * }\n */\nResizeShapeHandler.prototype.execute = function(context) {\n  var shape = context.shape,\n      newBounds = context.newBounds,\n      minBounds = context.minBounds;\n\n  if (newBounds.x === undefined || newBounds.y === undefined ||\n      newBounds.width === undefined || newBounds.height === undefined) {\n    throw new Error('newBounds must have {x, y, width, height} properties');\n  }\n\n  if (minBounds && (newBounds.width < minBounds.width\n    || newBounds.height < minBounds.height)) {\n    throw new Error('width and height cannot be less than minimum height and width');\n  } else if (!minBounds\n    && newBounds.width < 10 || newBounds.height < 10) {\n    throw new Error('width and height cannot be less than 10px');\n  }\n\n  // save old bbox in context\n  context.oldBounds = {\n    width:  shape.width,\n    height: shape.height,\n    x:      shape.x,\n    y:      shape.y\n  };\n\n  // update shape\n  assign(shape, {\n    width:  newBounds.width,\n    height: newBounds.height,\n    x:      newBounds.x,\n    y:      newBounds.y\n  });\n\n  return shape;\n};\n\nResizeShapeHandler.prototype.postExecute = function(context) {\n  var modeling = this._modeling;\n\n  var shape = context.shape,\n      oldBounds = context.oldBounds,\n      hints = context.hints || {};\n\n  if (hints.layout === false) {\n    return;\n  }\n\n  forEach(shape.incoming, function(c) {\n    modeling.layoutConnection(c, {\n      connectionEnd: getResizedTargetAnchor(c, shape, oldBounds)\n    });\n  });\n\n  forEach(shape.outgoing, function(c) {\n    modeling.layoutConnection(c, {\n      connectionStart: getResizedSourceAnchor(c, shape, oldBounds)\n    });\n  });\n\n};\n\nResizeShapeHandler.prototype.revert = function(context) {\n\n  var shape = context.shape,\n      oldBounds = context.oldBounds;\n\n  // restore previous bbox\n  assign(shape, {\n    width:  oldBounds.width,\n    height: oldBounds.height,\n    x:      oldBounds.x,\n    y:      oldBounds.y\n  });\n\n  return shape;\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}