{"ast":null,"code":"/**\n * @typedef {import('../../core/Types').ConnectionLike} Connection\n * @typedef {import('../../core/Types').ShapeLike} Shape\n *\n * @typedef {import('../../core/EventBus').Event} Event\n *\n * @typedef {import('../../util/Types').Axis} Axis\n */\n\nvar abs = Math.abs,\n  round = Math.round;\n\n/**\n * Snap value to a collection of reference values.\n *\n * @param {number} value\n * @param {Array<number>} values\n * @param {number} [tolerance=10]\n *\n * @return {number} the value we snapped to or null, if none snapped\n */\nexport function snapTo(value, values, tolerance) {\n  tolerance = tolerance === undefined ? 10 : tolerance;\n  var idx, snapValue;\n  for (idx = 0; idx < values.length; idx++) {\n    snapValue = values[idx];\n    if (abs(snapValue - value) <= tolerance) {\n      return snapValue;\n    }\n  }\n}\nexport function topLeft(bounds) {\n  return {\n    x: bounds.x,\n    y: bounds.y\n  };\n}\nexport function topRight(bounds) {\n  return {\n    x: bounds.x + bounds.width,\n    y: bounds.y\n  };\n}\nexport function bottomLeft(bounds) {\n  return {\n    x: bounds.x,\n    y: bounds.y + bounds.height\n  };\n}\nexport function bottomRight(bounds) {\n  return {\n    x: bounds.x + bounds.width,\n    y: bounds.y + bounds.height\n  };\n}\nexport function mid(bounds, defaultValue) {\n  if (!bounds || isNaN(bounds.x) || isNaN(bounds.y)) {\n    return defaultValue;\n  }\n  return {\n    x: round(bounds.x + bounds.width / 2),\n    y: round(bounds.y + bounds.height / 2)\n  };\n}\n\n/**\n * Retrieve the snap state of the given event.\n *\n * @param {Event} event\n * @param {Axis} axis\n *\n * @return {boolean} the snapped state\n *\n */\nexport function isSnapped(event, axis) {\n  var snapped = event.snapped;\n  if (!snapped) {\n    return false;\n  }\n  if (typeof axis === 'string') {\n    return snapped[axis];\n  }\n  return snapped.x && snapped.y;\n}\n\n/**\n * Set the given event as snapped.\n *\n * This method may change the x and/or y position of the shape\n * from the given event!\n *\n * @param {Event} event\n * @param {Axis} axis\n * @param {number|boolean} value\n *\n * @return {number} old value\n */\nexport function setSnapped(event, axis, value) {\n  if (typeof axis !== 'string') {\n    throw new Error('axis must be in [x, y]');\n  }\n  if (typeof value !== 'number' && value !== false) {\n    throw new Error('value must be Number or false');\n  }\n  var delta,\n    previousValue = event[axis];\n  var snapped = event.snapped = event.snapped || {};\n  if (value === false) {\n    snapped[axis] = false;\n  } else {\n    snapped[axis] = true;\n    delta = value - previousValue;\n    event[axis] += delta;\n    event['d' + axis] += delta;\n  }\n  return previousValue;\n}\n\n/**\n * Get children of a shape.\n *\n * @param {Shape} parent\n *\n * @return {Array<Shape|Connection>}\n */\nexport function getChildren(parent) {\n  return parent.children || [];\n}","map":{"version":3,"names":["abs","Math","round","snapTo","value","values","tolerance","undefined","idx","snapValue","length","topLeft","bounds","x","y","topRight","width","bottomLeft","height","bottomRight","mid","defaultValue","isNaN","isSnapped","event","axis","snapped","setSnapped","Error","delta","previousValue","getChildren","parent","children"],"sources":["/home/runner/work/sgex/sgex/node_modules/diagram-js/lib/features/snapping/SnapUtil.js"],"sourcesContent":["/**\n * @typedef {import('../../core/Types').ConnectionLike} Connection\n * @typedef {import('../../core/Types').ShapeLike} Shape\n *\n * @typedef {import('../../core/EventBus').Event} Event\n *\n * @typedef {import('../../util/Types').Axis} Axis\n */\n\nvar abs = Math.abs,\n    round = Math.round;\n\n\n/**\n * Snap value to a collection of reference values.\n *\n * @param {number} value\n * @param {Array<number>} values\n * @param {number} [tolerance=10]\n *\n * @return {number} the value we snapped to or null, if none snapped\n */\nexport function snapTo(value, values, tolerance) {\n  tolerance = tolerance === undefined ? 10 : tolerance;\n\n  var idx, snapValue;\n\n  for (idx = 0; idx < values.length; idx++) {\n    snapValue = values[idx];\n\n    if (abs(snapValue - value) <= tolerance) {\n      return snapValue;\n    }\n  }\n}\n\n\nexport function topLeft(bounds) {\n  return {\n    x: bounds.x,\n    y: bounds.y\n  };\n}\n\nexport function topRight(bounds) {\n  return {\n    x: bounds.x + bounds.width,\n    y: bounds.y\n  };\n}\n\nexport function bottomLeft(bounds) {\n  return {\n    x: bounds.x,\n    y: bounds.y + bounds.height\n  };\n}\n\nexport function bottomRight(bounds) {\n  return {\n    x: bounds.x + bounds.width,\n    y: bounds.y + bounds.height\n  };\n}\n\nexport function mid(bounds, defaultValue) {\n\n  if (!bounds || isNaN(bounds.x) || isNaN(bounds.y)) {\n    return defaultValue;\n  }\n\n  return {\n    x: round(bounds.x + bounds.width / 2),\n    y: round(bounds.y + bounds.height / 2)\n  };\n}\n\n\n/**\n * Retrieve the snap state of the given event.\n *\n * @param {Event} event\n * @param {Axis} axis\n *\n * @return {boolean} the snapped state\n *\n */\nexport function isSnapped(event, axis) {\n  var snapped = event.snapped;\n\n  if (!snapped) {\n    return false;\n  }\n\n  if (typeof axis === 'string') {\n    return snapped[axis];\n  }\n\n  return snapped.x && snapped.y;\n}\n\n\n/**\n * Set the given event as snapped.\n *\n * This method may change the x and/or y position of the shape\n * from the given event!\n *\n * @param {Event} event\n * @param {Axis} axis\n * @param {number|boolean} value\n *\n * @return {number} old value\n */\nexport function setSnapped(event, axis, value) {\n  if (typeof axis !== 'string') {\n    throw new Error('axis must be in [x, y]');\n  }\n\n  if (typeof value !== 'number' && value !== false) {\n    throw new Error('value must be Number or false');\n  }\n\n  var delta,\n      previousValue = event[axis];\n\n  var snapped = event.snapped = (event.snapped || {});\n\n\n  if (value === false) {\n    snapped[axis] = false;\n  } else {\n    snapped[axis] = true;\n\n    delta = value - previousValue;\n\n    event[axis] += delta;\n    event['d' + axis] += delta;\n  }\n\n  return previousValue;\n}\n\n/**\n * Get children of a shape.\n *\n * @param {Shape} parent\n *\n * @return {Array<Shape|Connection>}\n */\nexport function getChildren(parent) {\n  return parent.children || [];\n}"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}