{"ast":null,"code":"import { asTRBL, getOrientation, getMid } from '../../layout/LayoutUtil';\nimport { find, reduce } from 'min-dash';\n\n/**\n * @typedef {import('../../model/Types').Connection} Connection\n * @typedef {import('../../model/Types').Element} Element\n * @typedef {import('../../model/Types').Shape} Shape\n *\n * @typedef {import('../../util/Types').Point} Point\n */\n\n// padding to detect element placement\nvar PLACEMENT_DETECTION_PAD = 10;\nexport var DEFAULT_DISTANCE = 50;\nvar DEFAULT_MAX_DISTANCE = 250;\n\n/**\n * Get free position starting from given position.\n *\n * @param {Shape} source\n * @param {Shape} element\n * @param {Point} position\n * @param {(element: Element, position: Point, connectedAtPosition: Element) => Point} getNextPosition\n *\n * @return {Point}\n */\nexport function findFreePosition(source, element, position, getNextPosition) {\n  var connectedAtPosition;\n  while (connectedAtPosition = getConnectedAtPosition(source, position, element)) {\n    position = getNextPosition(element, position, connectedAtPosition);\n  }\n  return position;\n}\n\n/**\n * Returns function that returns next position.\n *\n * @param {Object} nextPositionDirection\n * @param {Object} [nextPositionDirection.x]\n * @param {Object} [nextPositionDirection.y]\n *\n * @return {(element: Element, previousPosition: Point, connectedAtPosition: Element) => Point}\n */\nexport function generateGetNextPosition(nextPositionDirection) {\n  return function (element, previousPosition, connectedAtPosition) {\n    var nextPosition = {\n      x: previousPosition.x,\n      y: previousPosition.y\n    };\n    ['x', 'y'].forEach(function (axis) {\n      var nextPositionDirectionForAxis = nextPositionDirection[axis];\n      if (!nextPositionDirectionForAxis) {\n        return;\n      }\n      var dimension = axis === 'x' ? 'width' : 'height';\n      var margin = nextPositionDirectionForAxis.margin,\n        minDistance = nextPositionDirectionForAxis.minDistance;\n      if (margin < 0) {\n        nextPosition[axis] = Math.min(connectedAtPosition[axis] + margin - element[dimension] / 2, previousPosition[axis] - minDistance + margin);\n      } else {\n        nextPosition[axis] = Math.max(connectedAtPosition[axis] + connectedAtPosition[dimension] + margin + element[dimension] / 2, previousPosition[axis] + minDistance + margin);\n      }\n    });\n    return nextPosition;\n  };\n}\n\n/**\n * Return connected element at given position and within given bounds. Takes\n * connected elements from host and attachers into account, too.\n *\n * @param {Shape} source\n * @param {Point} position\n * @param {Shape} element\n *\n * @return {Shape|undefined}\n */\nexport function getConnectedAtPosition(source, position, element) {\n  var bounds = {\n    x: position.x - element.width / 2,\n    y: position.y - element.height / 2,\n    width: element.width,\n    height: element.height\n  };\n  var closure = getAutoPlaceClosure(source);\n  return find(closure, function (target) {\n    if (target === element) {\n      return false;\n    }\n    var orientation = getOrientation(target, bounds, PLACEMENT_DETECTION_PAD);\n    return orientation === 'intersect';\n  });\n}\n\n/**\n* Compute optimal distance between source and target based on existing connections to and from source.\n* Assumes left-to-right and top-to-down modeling.\n*\n* @param {Shape} source\n* @param {Object} [hints]\n* @param {number} [hints.defaultDistance]\n* @param {string} [hints.direction]\n* @param {(connection: Connection) => boolean} [hints.filter]\n* @param {(connection: Connection) => number} [hints.getWeight]\n* @param {number} [hints.maxDistance]\n* @param {'start'|'center'|'end'} [hints.reference]\n*\n* @return {number}\n*/\nexport function getConnectedDistance(source, hints) {\n  if (!hints) {\n    hints = {};\n  }\n\n  // targets > sources by default\n  function getDefaultWeight(connection) {\n    return connection.source === source ? 1 : -1;\n  }\n  var defaultDistance = hints.defaultDistance || DEFAULT_DISTANCE,\n    direction = hints.direction || 'e',\n    filter = hints.filter,\n    getWeight = hints.getWeight || getDefaultWeight,\n    maxDistance = hints.maxDistance || DEFAULT_MAX_DISTANCE,\n    reference = hints.reference || 'start';\n  if (!filter) {\n    filter = noneFilter;\n  }\n  function getDistance(a, b) {\n    if (direction === 'n') {\n      if (reference === 'start') {\n        return asTRBL(a).top - asTRBL(b).bottom;\n      } else if (reference === 'center') {\n        return asTRBL(a).top - getMid(b).y;\n      } else {\n        return asTRBL(a).top - asTRBL(b).top;\n      }\n    } else if (direction === 'w') {\n      if (reference === 'start') {\n        return asTRBL(a).left - asTRBL(b).right;\n      } else if (reference === 'center') {\n        return asTRBL(a).left - getMid(b).x;\n      } else {\n        return asTRBL(a).left - asTRBL(b).left;\n      }\n    } else if (direction === 's') {\n      if (reference === 'start') {\n        return asTRBL(b).top - asTRBL(a).bottom;\n      } else if (reference === 'center') {\n        return getMid(b).y - asTRBL(a).bottom;\n      } else {\n        return asTRBL(b).bottom - asTRBL(a).bottom;\n      }\n    } else {\n      if (reference === 'start') {\n        return asTRBL(b).left - asTRBL(a).right;\n      } else if (reference === 'center') {\n        return getMid(b).x - asTRBL(a).right;\n      } else {\n        return asTRBL(b).right - asTRBL(a).right;\n      }\n    }\n  }\n  var sourcesDistances = source.incoming.filter(filter).map(function (connection) {\n    var weight = getWeight(connection);\n    var distance = weight < 0 ? getDistance(connection.source, source) : getDistance(source, connection.source);\n    return {\n      id: connection.source.id,\n      distance: distance,\n      weight: weight\n    };\n  });\n  var targetsDistances = source.outgoing.filter(filter).map(function (connection) {\n    var weight = getWeight(connection);\n    var distance = weight > 0 ? getDistance(source, connection.target) : getDistance(connection.target, source);\n    return {\n      id: connection.target.id,\n      distance: distance,\n      weight: weight\n    };\n  });\n  var distances = sourcesDistances.concat(targetsDistances).reduce(function (accumulator, currentValue) {\n    accumulator[currentValue.id + '__weight_' + currentValue.weight] = currentValue;\n    return accumulator;\n  }, {});\n  var distancesGrouped = reduce(distances, function (accumulator, currentValue) {\n    var distance = currentValue.distance,\n      weight = currentValue.weight;\n    if (distance < 0 || distance > maxDistance) {\n      return accumulator;\n    }\n    if (!accumulator[String(distance)]) {\n      accumulator[String(distance)] = 0;\n    }\n    accumulator[String(distance)] += 1 * weight;\n    if (!accumulator.distance || accumulator[accumulator.distance] < accumulator[String(distance)]) {\n      accumulator.distance = distance;\n    }\n    return accumulator;\n  }, {});\n  return distancesGrouped.distance || defaultDistance;\n}\n\n/**\n * Returns all elements connected to given source.\n *\n * This includes:\n *\n *   - elements connected to source\n *   - elements connected to host if source is an attacher\n *   - elements connected to attachers if source is a host\n *\n * @param {Shape} source\n *\n * @return {Shape[]}\n */\nfunction getAutoPlaceClosure(source) {\n  var allConnected = getConnected(source);\n  if (source.host) {\n    allConnected = allConnected.concat(getConnected(source.host));\n  }\n  if (source.attachers) {\n    allConnected = allConnected.concat(source.attachers.reduce(function (shapes, attacher) {\n      return shapes.concat(getConnected(attacher));\n    }, []));\n  }\n  return allConnected;\n}\n\n/**\n * Get all connected elements.\n *\n * @param {Shape} element\n *\n * @returns {Shape[]}\n */\nfunction getConnected(element) {\n  return getTargets(element).concat(getSources(element));\n}\nfunction getSources(shape) {\n  return shape.incoming.map(function (connection) {\n    return connection.source;\n  });\n}\nfunction getTargets(shape) {\n  return shape.outgoing.map(function (connection) {\n    return connection.target;\n  });\n}\nfunction noneFilter() {\n  return true;\n}","map":{"version":3,"names":["asTRBL","getOrientation","getMid","find","reduce","PLACEMENT_DETECTION_PAD","DEFAULT_DISTANCE","DEFAULT_MAX_DISTANCE","findFreePosition","source","element","position","getNextPosition","connectedAtPosition","getConnectedAtPosition","generateGetNextPosition","nextPositionDirection","previousPosition","nextPosition","x","y","forEach","axis","nextPositionDirectionForAxis","dimension","margin","minDistance","Math","min","max","bounds","width","height","closure","getAutoPlaceClosure","target","orientation","getConnectedDistance","hints","getDefaultWeight","connection","defaultDistance","direction","filter","getWeight","maxDistance","reference","noneFilter","getDistance","a","b","top","bottom","left","right","sourcesDistances","incoming","map","weight","distance","id","targetsDistances","outgoing","distances","concat","accumulator","currentValue","distancesGrouped","String","allConnected","getConnected","host","attachers","shapes","attacher","getTargets","getSources","shape"],"sources":["/home/runner/work/sgex/sgex/node_modules/diagram-js/lib/features/auto-place/AutoPlaceUtil.js"],"sourcesContent":["import {\n  asTRBL,\n  getOrientation,\n  getMid\n} from '../../layout/LayoutUtil';\n\nimport {\n  find,\n  reduce\n} from 'min-dash';\n\n/**\n * @typedef {import('../../model/Types').Connection} Connection\n * @typedef {import('../../model/Types').Element} Element\n * @typedef {import('../../model/Types').Shape} Shape\n *\n * @typedef {import('../../util/Types').Point} Point\n */\n\n// padding to detect element placement\nvar PLACEMENT_DETECTION_PAD = 10;\n\nexport var DEFAULT_DISTANCE = 50;\n\nvar DEFAULT_MAX_DISTANCE = 250;\n\n\n/**\n * Get free position starting from given position.\n *\n * @param {Shape} source\n * @param {Shape} element\n * @param {Point} position\n * @param {(element: Element, position: Point, connectedAtPosition: Element) => Point} getNextPosition\n *\n * @return {Point}\n */\nexport function findFreePosition(source, element, position, getNextPosition) {\n  var connectedAtPosition;\n\n  while ((connectedAtPosition = getConnectedAtPosition(source, position, element))) {\n    position = getNextPosition(element, position, connectedAtPosition);\n  }\n\n  return position;\n}\n\n/**\n * Returns function that returns next position.\n *\n * @param {Object} nextPositionDirection\n * @param {Object} [nextPositionDirection.x]\n * @param {Object} [nextPositionDirection.y]\n *\n * @return {(element: Element, previousPosition: Point, connectedAtPosition: Element) => Point}\n */\nexport function generateGetNextPosition(nextPositionDirection) {\n  return function(element, previousPosition, connectedAtPosition) {\n    var nextPosition = {\n      x: previousPosition.x,\n      y: previousPosition.y\n    };\n\n    [ 'x', 'y' ].forEach(function(axis) {\n\n      var nextPositionDirectionForAxis = nextPositionDirection[ axis ];\n\n      if (!nextPositionDirectionForAxis) {\n        return;\n      }\n\n      var dimension = axis === 'x' ? 'width' : 'height';\n\n      var margin = nextPositionDirectionForAxis.margin,\n          minDistance = nextPositionDirectionForAxis.minDistance;\n\n      if (margin < 0) {\n        nextPosition[ axis ] = Math.min(\n          connectedAtPosition[ axis ] + margin - element[ dimension ] / 2,\n          previousPosition[ axis ] - minDistance + margin\n        );\n      } else {\n        nextPosition[ axis ] = Math.max(\n          connectedAtPosition[ axis ] + connectedAtPosition[ dimension ] + margin + element[ dimension ] / 2,\n          previousPosition[ axis ] + minDistance + margin\n        );\n      }\n    });\n\n    return nextPosition;\n  };\n}\n\n/**\n * Return connected element at given position and within given bounds. Takes\n * connected elements from host and attachers into account, too.\n *\n * @param {Shape} source\n * @param {Point} position\n * @param {Shape} element\n *\n * @return {Shape|undefined}\n */\nexport function getConnectedAtPosition(source, position, element) {\n\n  var bounds = {\n    x: position.x - (element.width / 2),\n    y: position.y - (element.height / 2),\n    width: element.width,\n    height: element.height\n  };\n\n  var closure = getAutoPlaceClosure(source);\n\n  return find(closure, function(target) {\n\n    if (target === element) {\n      return false;\n    }\n\n    var orientation = getOrientation(target, bounds, PLACEMENT_DETECTION_PAD);\n\n    return orientation === 'intersect';\n  });\n}\n\n/**\n* Compute optimal distance between source and target based on existing connections to and from source.\n* Assumes left-to-right and top-to-down modeling.\n*\n* @param {Shape} source\n* @param {Object} [hints]\n* @param {number} [hints.defaultDistance]\n* @param {string} [hints.direction]\n* @param {(connection: Connection) => boolean} [hints.filter]\n* @param {(connection: Connection) => number} [hints.getWeight]\n* @param {number} [hints.maxDistance]\n* @param {'start'|'center'|'end'} [hints.reference]\n*\n* @return {number}\n*/\nexport function getConnectedDistance(source, hints) {\n  if (!hints) {\n    hints = {};\n  }\n\n  // targets > sources by default\n  function getDefaultWeight(connection) {\n    return connection.source === source ? 1 : -1;\n  }\n\n  var defaultDistance = hints.defaultDistance || DEFAULT_DISTANCE,\n      direction = hints.direction || 'e',\n      filter = hints.filter,\n      getWeight = hints.getWeight || getDefaultWeight,\n      maxDistance = hints.maxDistance || DEFAULT_MAX_DISTANCE,\n      reference = hints.reference || 'start';\n\n  if (!filter) {\n    filter = noneFilter;\n  }\n\n  function getDistance(a, b) {\n    if (direction === 'n') {\n      if (reference === 'start') {\n        return asTRBL(a).top - asTRBL(b).bottom;\n      } else if (reference === 'center') {\n        return asTRBL(a).top - getMid(b).y;\n      } else {\n        return asTRBL(a).top - asTRBL(b).top;\n      }\n    } else if (direction === 'w') {\n      if (reference === 'start') {\n        return asTRBL(a).left - asTRBL(b).right;\n      } else if (reference === 'center') {\n        return asTRBL(a).left - getMid(b).x;\n      } else {\n        return asTRBL(a).left - asTRBL(b).left;\n      }\n    } else if (direction === 's') {\n      if (reference === 'start') {\n        return asTRBL(b).top - asTRBL(a).bottom;\n      } else if (reference === 'center') {\n        return getMid(b).y - asTRBL(a).bottom;\n      } else {\n        return asTRBL(b).bottom - asTRBL(a).bottom;\n      }\n    } else {\n      if (reference === 'start') {\n        return asTRBL(b).left - asTRBL(a).right;\n      } else if (reference === 'center') {\n        return getMid(b).x - asTRBL(a).right;\n      } else {\n        return asTRBL(b).right - asTRBL(a).right;\n      }\n    }\n  }\n\n  var sourcesDistances = source.incoming\n    .filter(filter)\n    .map(function(connection) {\n      var weight = getWeight(connection);\n\n      var distance = weight < 0\n        ? getDistance(connection.source, source)\n        : getDistance(source, connection.source);\n\n      return {\n        id: connection.source.id,\n        distance: distance,\n        weight: weight\n      };\n    });\n\n  var targetsDistances = source.outgoing\n    .filter(filter)\n    .map(function(connection) {\n      var weight = getWeight(connection);\n\n      var distance = weight > 0\n        ? getDistance(source, connection.target)\n        : getDistance(connection.target, source);\n\n      return {\n        id: connection.target.id,\n        distance: distance,\n        weight: weight\n      };\n    });\n\n  var distances = sourcesDistances.concat(targetsDistances).reduce(function(accumulator, currentValue) {\n    accumulator[ currentValue.id + '__weight_' + currentValue.weight ] = currentValue;\n\n    return accumulator;\n  }, {});\n\n  var distancesGrouped = reduce(distances, function(accumulator, currentValue) {\n    var distance = currentValue.distance,\n        weight = currentValue.weight;\n\n    if (distance < 0 || distance > maxDistance) {\n      return accumulator;\n    }\n\n    if (!accumulator[ String(distance) ]) {\n      accumulator[ String(distance) ] = 0;\n    }\n\n    accumulator[ String(distance) ] += 1 * weight;\n\n    if (!accumulator.distance || accumulator[ accumulator.distance ] < accumulator[ String(distance) ]) {\n      accumulator.distance = distance;\n    }\n\n    return accumulator;\n  }, {});\n\n  return distancesGrouped.distance || defaultDistance;\n}\n\n/**\n * Returns all elements connected to given source.\n *\n * This includes:\n *\n *   - elements connected to source\n *   - elements connected to host if source is an attacher\n *   - elements connected to attachers if source is a host\n *\n * @param {Shape} source\n *\n * @return {Shape[]}\n */\nfunction getAutoPlaceClosure(source) {\n\n  var allConnected = getConnected(source);\n\n  if (source.host) {\n    allConnected = allConnected.concat(getConnected(source.host));\n  }\n\n  if (source.attachers) {\n    allConnected = allConnected.concat(source.attachers.reduce(function(shapes, attacher) {\n      return shapes.concat(getConnected(attacher));\n    }, []));\n  }\n\n  return allConnected;\n}\n\n/**\n * Get all connected elements.\n *\n * @param {Shape} element\n *\n * @returns {Shape[]}\n */\nfunction getConnected(element) {\n  return getTargets(element).concat(getSources(element));\n}\n\nfunction getSources(shape) {\n  return shape.incoming.map(function(connection) {\n    return connection.source;\n  });\n}\n\nfunction getTargets(shape) {\n  return shape.outgoing.map(function(connection) {\n    return connection.target;\n  });\n}\n\nfunction noneFilter() {\n  return true;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}