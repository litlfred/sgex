{"ast":null,"code":"import { is } from '../../util/ModelUtil';\nimport { isAny, isDirectionHorizontal } from '../modeling/util/ModelingUtil';\nimport { getMid, asTRBL, getOrientation } from 'diagram-js/lib/layout/LayoutUtil';\nimport { findFreePosition, generateGetNextPosition, getConnectedDistance } from 'diagram-js/lib/features/auto-place/AutoPlaceUtil';\nimport { isConnection } from 'diagram-js/lib/util/ModelUtil';\n\n/**\n * @typedef {import('../../model/Types').Shape} Shape\n *\n * @typedef {import('diagram-js/lib/core/ElementRegistry').default} ElementRegistry\n * @typedef {import('diagram-js/lib/util/Types').Point} Point\n * @typedef {import('diagram-js/lib/util/Types').DirectionTRBL} DirectionTRBL\n */\n\n/**\n * Get the position for given new target relative to the source it will be\n * connected to.\n *\n * @param  {Shape} source\n * @param  {Shape} element\n * @param  {ElementRegistry} elementRegistry\n *\n * @return {Point}\n */\nexport function getNewShapePosition(source, element, elementRegistry) {\n  var placeHorizontally = isDirectionHorizontal(source, elementRegistry);\n  if (is(element, 'bpmn:TextAnnotation')) {\n    return getTextAnnotationPosition(source, element, placeHorizontally);\n  }\n  if (isAny(element, ['bpmn:DataObjectReference', 'bpmn:DataStoreReference'])) {\n    return getDataElementPosition(source, element, placeHorizontally);\n  }\n  if (is(element, 'bpmn:FlowNode')) {\n    return getFlowNodePosition(source, element, placeHorizontally);\n  }\n}\n\n/**\n * Get the position for given new flow node. Try placing the flow node right/bottom of\n * the source.\n *\n * @param {Shape} source\n * @param {Shape} element\n * @param {boolean} placeHorizontally Whether to place the new element horizontally\n *\n * @return {Point}\n */\nexport function getFlowNodePosition(source, element, placeHorizontally) {\n  var sourceTrbl = asTRBL(source);\n  var sourceMid = getMid(source);\n  var placement = placeHorizontally ? {\n    directionHint: 'e',\n    minDistance: 80,\n    baseOrientation: 'left',\n    boundaryOrientation: 'top',\n    start: 'top',\n    end: 'bottom'\n  } : {\n    directionHint: 's',\n    minDistance: 90,\n    baseOrientation: 'top',\n    boundaryOrientation: 'left',\n    start: 'left',\n    end: 'right'\n  };\n  var connectedDistance = getConnectedDistance(source, {\n    filter: function (connection) {\n      return is(connection, 'bpmn:SequenceFlow');\n    },\n    direction: placement.directionHint\n  });\n  var margin = 30,\n    minDistance = placement.minDistance,\n    orientation = placement.baseOrientation;\n  if (is(source, 'bpmn:BoundaryEvent')) {\n    orientation = getOrientation(source, source.host, -25);\n    if (orientation.indexOf(placement.boundaryOrientation) !== -1) {\n      margin *= -1;\n    }\n  }\n  var position = placeHorizontally ? {\n    x: sourceTrbl.right + connectedDistance + element.width / 2,\n    y: sourceMid.y + getDistance(orientation, minDistance, placement)\n  } : {\n    x: sourceMid.x + getDistance(orientation, minDistance, placement),\n    y: sourceTrbl.bottom + connectedDistance + element.height / 2\n  };\n  var nextPosition = {\n    margin: margin,\n    minDistance: minDistance\n  };\n  var nextPositionDirection = placeHorizontally ? {\n    y: nextPosition\n  } : {\n    x: nextPosition\n  };\n  return findFreePosition(source, element, position, generateGetNextPosition(nextPositionDirection));\n}\n\n/**\n * @param {DirectionTRBL} orientation\n * @param {number} minDistance\n * @param {{ start: DirectionTRBL, end: DirectionTRBL }} placement\n *\n * @return {number}\n */\nfunction getDistance(orientation, minDistance, placement) {\n  if (orientation.includes(placement.start)) {\n    return -1 * minDistance;\n  } else if (orientation.includes(placement.end)) {\n    return minDistance;\n  } else {\n    return 0;\n  }\n}\n\n/**\n * Get the position for given text annotation. Try placing the text annotation\n * top-right of the source (bottom-right in vertical layouts).\n *\n * @param {Shape} source\n * @param {Shape} element\n * @param {boolean} placeHorizontally Whether to place the new element horizontally\n *\n * @return {Point}\n */\nexport function getTextAnnotationPosition(source, element, placeHorizontally) {\n  var sourceTrbl = asTRBL(source);\n  var position = placeHorizontally ? {\n    x: sourceTrbl.right + element.width / 2,\n    y: sourceTrbl.top - 50 - element.height / 2\n  } : {\n    x: sourceTrbl.right + 50 + element.width / 2,\n    y: sourceTrbl.bottom + element.height / 2\n  };\n  if (isConnection(source)) {\n    position = getMid(source);\n    if (placeHorizontally) {\n      position.x += 100;\n      position.y -= 50;\n    } else {\n      position.x += 100;\n      position.y += 50;\n    }\n  }\n  var nextPosition = {\n    margin: placeHorizontally ? -30 : 30,\n    minDistance: 20\n  };\n  var nextPositionDirection = placeHorizontally ? {\n    y: nextPosition\n  } : {\n    x: nextPosition\n  };\n  return findFreePosition(source, element, position, generateGetNextPosition(nextPositionDirection));\n}\n\n/**\n * Get the position for given new data element. Try placing the data element\n * bottom-right of the source (bottom-left in vertical layouts).\n *\n * @param {Shape} source\n * @param {Shape} element\n * @param {boolean} placeHorizontally Whether to place the new element horizontally\n *\n * @return {Point}\n */\nexport function getDataElementPosition(source, element, placeHorizontally) {\n  var sourceTrbl = asTRBL(source);\n  var position = placeHorizontally ? {\n    x: sourceTrbl.right - 10 + element.width / 2,\n    y: sourceTrbl.bottom + 40 + element.width / 2\n  } : {\n    x: sourceTrbl.left - 40 - element.width / 2,\n    y: sourceTrbl.bottom - 10 + element.height / 2\n  };\n  var nextPosition = {\n    margin: 30,\n    minDistance: 30\n  };\n  var nextPositionDirection = placeHorizontally ? {\n    x: nextPosition\n  } : {\n    y: nextPosition\n  };\n  return findFreePosition(source, element, position, generateGetNextPosition(nextPositionDirection));\n}","map":{"version":3,"names":["is","isAny","isDirectionHorizontal","getMid","asTRBL","getOrientation","findFreePosition","generateGetNextPosition","getConnectedDistance","isConnection","getNewShapePosition","source","element","elementRegistry","placeHorizontally","getTextAnnotationPosition","getDataElementPosition","getFlowNodePosition","sourceTrbl","sourceMid","placement","directionHint","minDistance","baseOrientation","boundaryOrientation","start","end","connectedDistance","filter","connection","direction","margin","orientation","host","indexOf","position","x","right","width","y","getDistance","bottom","height","nextPosition","nextPositionDirection","includes","top","left"],"sources":["/home/runner/work/sgex/sgex/node_modules/bpmn-js/lib/features/auto-place/BpmnAutoPlaceUtil.js"],"sourcesContent":["import { is } from '../../util/ModelUtil';\n\nimport {\n  isAny,\n  isDirectionHorizontal\n} from '../modeling/util/ModelingUtil';\n\nimport {\n  getMid,\n  asTRBL,\n  getOrientation\n} from 'diagram-js/lib/layout/LayoutUtil';\n\nimport {\n  findFreePosition,\n  generateGetNextPosition,\n  getConnectedDistance\n} from 'diagram-js/lib/features/auto-place/AutoPlaceUtil';\n\nimport { isConnection } from 'diagram-js/lib/util/ModelUtil';\n\n/**\n * @typedef {import('../../model/Types').Shape} Shape\n *\n * @typedef {import('diagram-js/lib/core/ElementRegistry').default} ElementRegistry\n * @typedef {import('diagram-js/lib/util/Types').Point} Point\n * @typedef {import('diagram-js/lib/util/Types').DirectionTRBL} DirectionTRBL\n */\n\n/**\n * Get the position for given new target relative to the source it will be\n * connected to.\n *\n * @param  {Shape} source\n * @param  {Shape} element\n * @param  {ElementRegistry} elementRegistry\n *\n * @return {Point}\n */\nexport function getNewShapePosition(source, element, elementRegistry) {\n\n  var placeHorizontally = isDirectionHorizontal(source, elementRegistry);\n\n  if (is(element, 'bpmn:TextAnnotation')) {\n    return getTextAnnotationPosition(source, element, placeHorizontally);\n  }\n\n  if (isAny(element, [ 'bpmn:DataObjectReference', 'bpmn:DataStoreReference' ])) {\n    return getDataElementPosition(source, element, placeHorizontally);\n  }\n\n  if (is(element, 'bpmn:FlowNode')) {\n    return getFlowNodePosition(source, element, placeHorizontally);\n  }\n}\n\n/**\n * Get the position for given new flow node. Try placing the flow node right/bottom of\n * the source.\n *\n * @param {Shape} source\n * @param {Shape} element\n * @param {boolean} placeHorizontally Whether to place the new element horizontally\n *\n * @return {Point}\n */\nexport function getFlowNodePosition(source, element, placeHorizontally) {\n\n  var sourceTrbl = asTRBL(source);\n  var sourceMid = getMid(source);\n\n  var placement = placeHorizontally ? {\n    directionHint: 'e',\n    minDistance: 80,\n    baseOrientation: 'left',\n    boundaryOrientation: 'top',\n    start: 'top',\n    end: 'bottom'\n  } : {\n    directionHint: 's',\n    minDistance: 90,\n    baseOrientation: 'top',\n    boundaryOrientation: 'left',\n    start: 'left',\n    end: 'right'\n  };\n\n  var connectedDistance = getConnectedDistance(source, {\n    filter: function(connection) {\n      return is(connection, 'bpmn:SequenceFlow');\n    },\n    direction: placement.directionHint\n  });\n\n  var margin = 30,\n      minDistance = placement.minDistance,\n      orientation = placement.baseOrientation;\n\n  if (is(source, 'bpmn:BoundaryEvent')) {\n    orientation = getOrientation(source, source.host, -25);\n\n    if (orientation.indexOf(placement.boundaryOrientation) !== -1) {\n      margin *= -1;\n    }\n  }\n\n  var position = placeHorizontally ? {\n    x: sourceTrbl.right + connectedDistance + element.width / 2,\n    y: sourceMid.y + getDistance(orientation, minDistance, placement)\n  } : {\n    x: sourceMid.x + getDistance(orientation, minDistance, placement),\n    y: sourceTrbl.bottom + connectedDistance + element.height / 2\n  };\n\n  var nextPosition = {\n    margin: margin,\n    minDistance: minDistance\n  };\n\n  var nextPositionDirection = placeHorizontally ? {\n    y: nextPosition\n  } : {\n    x: nextPosition\n  };\n\n  return findFreePosition(source, element, position, generateGetNextPosition(nextPositionDirection));\n}\n\n/**\n * @param {DirectionTRBL} orientation\n * @param {number} minDistance\n * @param {{ start: DirectionTRBL, end: DirectionTRBL }} placement\n *\n * @return {number}\n */\nfunction getDistance(orientation, minDistance, placement) {\n  if (orientation.includes(placement.start)) {\n    return -1 * minDistance;\n  } else if (orientation.includes(placement.end)) {\n    return minDistance;\n  } else {\n    return 0;\n  }\n}\n\n\n/**\n * Get the position for given text annotation. Try placing the text annotation\n * top-right of the source (bottom-right in vertical layouts).\n *\n * @param {Shape} source\n * @param {Shape} element\n * @param {boolean} placeHorizontally Whether to place the new element horizontally\n *\n * @return {Point}\n */\nexport function getTextAnnotationPosition(source, element, placeHorizontally) {\n\n  var sourceTrbl = asTRBL(source);\n\n  var position = placeHorizontally ? {\n    x: sourceTrbl.right + element.width / 2,\n    y: sourceTrbl.top - 50 - element.height / 2\n  } : {\n    x: sourceTrbl.right + 50 + element.width / 2,\n    y: sourceTrbl.bottom + element.height / 2\n  };\n\n  if (isConnection(source)) {\n    position = getMid(source);\n    if (placeHorizontally) {\n      position.x += 100;\n      position.y -= 50;\n    } else {\n      position.x += 100;\n      position.y += 50;\n    }\n  }\n\n  var nextPosition = {\n    margin: placeHorizontally ? -30 : 30,\n    minDistance: 20\n  };\n  var nextPositionDirection = placeHorizontally ? {\n    y: nextPosition\n  } : {\n    x: nextPosition\n  };\n\n  return findFreePosition(source, element, position, generateGetNextPosition(nextPositionDirection));\n}\n\n\n/**\n * Get the position for given new data element. Try placing the data element\n * bottom-right of the source (bottom-left in vertical layouts).\n *\n * @param {Shape} source\n * @param {Shape} element\n * @param {boolean} placeHorizontally Whether to place the new element horizontally\n *\n * @return {Point}\n */\nexport function getDataElementPosition(source, element, placeHorizontally) {\n\n  var sourceTrbl = asTRBL(source);\n\n  var position = placeHorizontally ? {\n    x: sourceTrbl.right - 10 + element.width / 2,\n    y: sourceTrbl.bottom + 40 + element.width / 2\n  } : {\n    x: sourceTrbl.left - 40 - element.width / 2,\n    y: sourceTrbl.bottom - 10 + element.height / 2\n  };\n\n  var nextPosition = {\n    margin: 30,\n    minDistance: 30\n  };\n  var nextPositionDirection = placeHorizontally ? {\n    x: nextPosition\n  } : {\n    y: nextPosition\n  };\n\n  return findFreePosition(source, element, position, generateGetNextPosition(nextPositionDirection));\n}"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}