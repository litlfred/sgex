{"ast":null,"code":"import inherits from 'inherits-browser';\nimport CommandInterceptor from 'diagram-js/lib/command/CommandInterceptor';\nimport { is } from '../../../util/ModelUtil';\nimport { filter, forEach } from 'min-dash';\n\n/**\n * @typedef {import('diagram-js/lib/core/EventBus').default} EventBus\n * @typedef {import('../Modeling').default} Modeling\n */\n\n/**\n * BPMN specific boundary event behavior.\n *\n * @param {EventBus} eventBus\n * @param {Modeling} modeling\n */\nexport default function BoundaryEventBehavior(eventBus, modeling) {\n  CommandInterceptor.call(this, eventBus);\n  function getBoundaryEvents(element) {\n    return filter(element.attachers, function (attacher) {\n      return is(attacher, 'bpmn:BoundaryEvent');\n    });\n  }\n\n  // remove after connecting to event-based gateway\n  this.postExecute('connection.create', function (event) {\n    var source = event.context.source,\n      target = event.context.target,\n      boundaryEvents = getBoundaryEvents(target);\n    if (is(source, 'bpmn:EventBasedGateway') && is(target, 'bpmn:ReceiveTask') && boundaryEvents.length > 0) {\n      modeling.removeElements(boundaryEvents);\n    }\n  });\n\n  // remove after replacing connected gateway with event-based gateway\n  this.postExecute('connection.reconnect', function (event) {\n    var oldSource = event.context.oldSource,\n      newSource = event.context.newSource;\n    if (is(oldSource, 'bpmn:Gateway') && is(newSource, 'bpmn:EventBasedGateway')) {\n      forEach(newSource.outgoing, function (connection) {\n        var target = connection.target,\n          attachedboundaryEvents = getBoundaryEvents(target);\n        if (is(target, 'bpmn:ReceiveTask') && attachedboundaryEvents.length > 0) {\n          modeling.removeElements(attachedboundaryEvents);\n        }\n      });\n    }\n  });\n}\nBoundaryEventBehavior.$inject = ['eventBus', 'modeling'];\ninherits(BoundaryEventBehavior, CommandInterceptor);","map":{"version":3,"names":["inherits","CommandInterceptor","is","filter","forEach","BoundaryEventBehavior","eventBus","modeling","call","getBoundaryEvents","element","attachers","attacher","postExecute","event","source","context","target","boundaryEvents","length","removeElements","oldSource","newSource","outgoing","connection","attachedboundaryEvents","$inject"],"sources":["/home/runner/work/sgex/sgex/node_modules/bpmn-js/lib/features/modeling/behavior/BoundaryEventBehavior.js"],"sourcesContent":["import inherits from 'inherits-browser';\n\nimport CommandInterceptor from 'diagram-js/lib/command/CommandInterceptor';\n\nimport { is } from '../../../util/ModelUtil';\n\nimport {\n  filter,\n  forEach\n} from 'min-dash';\n\n/**\n * @typedef {import('diagram-js/lib/core/EventBus').default} EventBus\n * @typedef {import('../Modeling').default} Modeling\n */\n\n/**\n * BPMN specific boundary event behavior.\n *\n * @param {EventBus} eventBus\n * @param {Modeling} modeling\n */\nexport default function BoundaryEventBehavior(eventBus, modeling) {\n\n  CommandInterceptor.call(this, eventBus);\n\n  function getBoundaryEvents(element) {\n    return filter(element.attachers, function(attacher) {\n      return is(attacher, 'bpmn:BoundaryEvent');\n    });\n  }\n\n  // remove after connecting to event-based gateway\n  this.postExecute('connection.create', function(event) {\n    var source = event.context.source,\n        target = event.context.target,\n        boundaryEvents = getBoundaryEvents(target);\n\n    if (\n      is(source, 'bpmn:EventBasedGateway') &&\n      is(target, 'bpmn:ReceiveTask') &&\n      boundaryEvents.length > 0\n    ) {\n      modeling.removeElements(boundaryEvents);\n    }\n\n  });\n\n  // remove after replacing connected gateway with event-based gateway\n  this.postExecute('connection.reconnect', function(event) {\n    var oldSource = event.context.oldSource,\n        newSource = event.context.newSource;\n\n    if (is(oldSource, 'bpmn:Gateway') &&\n        is(newSource, 'bpmn:EventBasedGateway')) {\n      forEach(newSource.outgoing, function(connection) {\n        var target = connection.target,\n            attachedboundaryEvents = getBoundaryEvents(target);\n\n        if (is(target, 'bpmn:ReceiveTask') &&\n            attachedboundaryEvents.length > 0) {\n          modeling.removeElements(attachedboundaryEvents);\n        }\n      });\n    }\n  });\n\n}\n\nBoundaryEventBehavior.$inject = [\n  'eventBus',\n  'modeling'\n];\n\ninherits(BoundaryEventBehavior, CommandInterceptor);"],"mappings":"AAAA,OAAOA,QAAQ,MAAM,kBAAkB;AAEvC,OAAOC,kBAAkB,MAAM,2CAA2C;AAE1E,SAASC,EAAE,QAAQ,yBAAyB;AAE5C,SACEC,MAAM,EACNC,OAAO,QACF,UAAU;;AAEjB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,SAASC,qBAAqBA,CAACC,QAAQ,EAAEC,QAAQ,EAAE;EAEhEN,kBAAkB,CAACO,IAAI,CAAC,IAAI,EAAEF,QAAQ,CAAC;EAEvC,SAASG,iBAAiBA,CAACC,OAAO,EAAE;IAClC,OAAOP,MAAM,CAACO,OAAO,CAACC,SAAS,EAAE,UAASC,QAAQ,EAAE;MAClD,OAAOV,EAAE,CAACU,QAAQ,EAAE,oBAAoB,CAAC;IAC3C,CAAC,CAAC;EACJ;;EAEA;EACA,IAAI,CAACC,WAAW,CAAC,mBAAmB,EAAE,UAASC,KAAK,EAAE;IACpD,IAAIC,MAAM,GAAGD,KAAK,CAACE,OAAO,CAACD,MAAM;MAC7BE,MAAM,GAAGH,KAAK,CAACE,OAAO,CAACC,MAAM;MAC7BC,cAAc,GAAGT,iBAAiB,CAACQ,MAAM,CAAC;IAE9C,IACEf,EAAE,CAACa,MAAM,EAAE,wBAAwB,CAAC,IACpCb,EAAE,CAACe,MAAM,EAAE,kBAAkB,CAAC,IAC9BC,cAAc,CAACC,MAAM,GAAG,CAAC,EACzB;MACAZ,QAAQ,CAACa,cAAc,CAACF,cAAc,CAAC;IACzC;EAEF,CAAC,CAAC;;EAEF;EACA,IAAI,CAACL,WAAW,CAAC,sBAAsB,EAAE,UAASC,KAAK,EAAE;IACvD,IAAIO,SAAS,GAAGP,KAAK,CAACE,OAAO,CAACK,SAAS;MACnCC,SAAS,GAAGR,KAAK,CAACE,OAAO,CAACM,SAAS;IAEvC,IAAIpB,EAAE,CAACmB,SAAS,EAAE,cAAc,CAAC,IAC7BnB,EAAE,CAACoB,SAAS,EAAE,wBAAwB,CAAC,EAAE;MAC3ClB,OAAO,CAACkB,SAAS,CAACC,QAAQ,EAAE,UAASC,UAAU,EAAE;QAC/C,IAAIP,MAAM,GAAGO,UAAU,CAACP,MAAM;UAC1BQ,sBAAsB,GAAGhB,iBAAiB,CAACQ,MAAM,CAAC;QAEtD,IAAIf,EAAE,CAACe,MAAM,EAAE,kBAAkB,CAAC,IAC9BQ,sBAAsB,CAACN,MAAM,GAAG,CAAC,EAAE;UACrCZ,QAAQ,CAACa,cAAc,CAACK,sBAAsB,CAAC;QACjD;MACF,CAAC,CAAC;IACJ;EACF,CAAC,CAAC;AAEJ;AAEApB,qBAAqB,CAACqB,OAAO,GAAG,CAC9B,UAAU,EACV,UAAU,CACX;AAED1B,QAAQ,CAACK,qBAAqB,EAAEJ,kBAAkB,CAAC","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}