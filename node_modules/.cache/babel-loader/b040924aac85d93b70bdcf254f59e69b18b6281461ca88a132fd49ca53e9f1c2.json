{"ast":null,"code":"import { filter } from 'min-dash';\nimport { eachElement } from 'diagram-js/lib/util/Elements';\nimport { getLanesRoot, getChildLanes, LANE_INDENTATION } from '../util/LaneUtil';\nimport { isHorizontal } from '../../../util/DiUtil';\n\n/**\n * @typedef {import('diagram-js/lib/command/CommandHandler').default} CommandHandler\n *\n * @typedef {import('../Modeling').default} Modeling\n * @typedef {import('../../space-tool/BpmnSpaceTool').default} SpaceTool\n */\n\n/**\n * A handler that allows us to add a new lane\n * above or below an existing one.\n *\n * @implements {CommandHandler}\n *\n * @param {Modeling} modeling\n * @param {SpaceTool} spaceTool\n */\nexport default function AddLaneHandler(modeling, spaceTool) {\n  this._modeling = modeling;\n  this._spaceTool = spaceTool;\n}\nAddLaneHandler.$inject = ['modeling', 'spaceTool'];\nAddLaneHandler.prototype.preExecute = function (context) {\n  var spaceTool = this._spaceTool,\n    modeling = this._modeling;\n  var shape = context.shape,\n    location = context.location;\n  var lanesRoot = getLanesRoot(shape);\n  var isRoot = lanesRoot === shape,\n    laneParent = isRoot ? shape : shape.parent;\n  var existingChildLanes = getChildLanes(laneParent);\n  var isHorizontalLane = isHorizontal(shape);\n\n  // never mix up horizontal/vertical lanes\n  if (isHorizontalLane) {\n    if (location === 'left') {\n      location = 'top';\n    } else if (location === 'right') {\n      location = 'bottom';\n    }\n  } else {\n    if (location === 'top') {\n      location = 'left';\n    } else if (location === 'bottom') {\n      location = 'right';\n    }\n  }\n\n  // (0) add a lane if we currently got none and are adding to root\n  if (!existingChildLanes.length) {\n    var siblingPosition = isHorizontalLane ? {\n      x: shape.x + LANE_INDENTATION,\n      y: shape.y,\n      width: shape.width - LANE_INDENTATION,\n      height: shape.height\n    } : {\n      x: shape.x,\n      y: shape.y + LANE_INDENTATION,\n      width: shape.width,\n      height: shape.height - LANE_INDENTATION\n    };\n    modeling.createShape({\n      type: 'bpmn:Lane',\n      isHorizontal: isHorizontalLane\n    }, siblingPosition, laneParent);\n  }\n\n  // (1) collect affected elements to create necessary space\n  var allAffected = [];\n  eachElement(lanesRoot, function (element) {\n    allAffected.push(element);\n\n    // handle element labels in the diagram root\n    if (element.label) {\n      allAffected.push(element.label);\n    }\n    if (element === shape) {\n      return [];\n    }\n    return filter(element.children, function (c) {\n      return c !== shape;\n    });\n  });\n  var offset, lanePosition, spacePos, direction, axis;\n  if (location === 'top') {\n    offset = -120;\n    lanePosition = shape.y;\n    spacePos = lanePosition + 10;\n    direction = 'n';\n    axis = 'y';\n  } else if (location === 'left') {\n    offset = -120;\n    lanePosition = shape.x;\n    spacePos = lanePosition + 10;\n    direction = 'w';\n    axis = 'x';\n  } else if (location === 'bottom') {\n    offset = 120;\n    lanePosition = shape.y + shape.height;\n    spacePos = lanePosition - 10;\n    direction = 's';\n    axis = 'y';\n  } else if (location === 'right') {\n    offset = 120;\n    lanePosition = shape.x + shape.width;\n    spacePos = lanePosition - 10;\n    direction = 'e';\n    axis = 'x';\n  }\n  var adjustments = spaceTool.calculateAdjustments(allAffected, axis, offset, spacePos);\n  var delta = isHorizontalLane ? {\n    x: 0,\n    y: offset\n  } : {\n    x: offset,\n    y: 0\n  };\n  spaceTool.makeSpace(adjustments.movingShapes, adjustments.resizingShapes, delta, direction, spacePos);\n\n  // (2) create new lane at open space\n  var newLanePosition = isHorizontalLane ? {\n    x: shape.x + (isRoot ? LANE_INDENTATION : 0),\n    y: lanePosition - (location === 'top' ? 120 : 0),\n    width: shape.width - (isRoot ? LANE_INDENTATION : 0),\n    height: 120\n  } : {\n    x: lanePosition - (location === 'left' ? 120 : 0),\n    y: shape.y + (isRoot ? LANE_INDENTATION : 0),\n    width: 120,\n    height: shape.height - (isRoot ? LANE_INDENTATION : 0)\n  };\n  context.newLane = modeling.createShape({\n    type: 'bpmn:Lane',\n    isHorizontal: isHorizontalLane\n  }, newLanePosition, laneParent);\n};","map":{"version":3,"names":["filter","eachElement","getLanesRoot","getChildLanes","LANE_INDENTATION","isHorizontal","AddLaneHandler","modeling","spaceTool","_modeling","_spaceTool","$inject","prototype","preExecute","context","shape","location","lanesRoot","isRoot","laneParent","parent","existingChildLanes","isHorizontalLane","length","siblingPosition","x","y","width","height","createShape","type","allAffected","element","push","label","children","c","offset","lanePosition","spacePos","direction","axis","adjustments","calculateAdjustments","delta","makeSpace","movingShapes","resizingShapes","newLanePosition","newLane"],"sources":["/home/runner/work/sgex/sgex/node_modules/bpmn-js/lib/features/modeling/cmd/AddLaneHandler.js"],"sourcesContent":["import {\n  filter\n} from 'min-dash';\n\nimport {\n  eachElement\n} from 'diagram-js/lib/util/Elements';\n\nimport {\n  getLanesRoot,\n  getChildLanes,\n  LANE_INDENTATION\n} from '../util/LaneUtil';\n\nimport {\n  isHorizontal\n} from '../../../util/DiUtil';\n\n/**\n * @typedef {import('diagram-js/lib/command/CommandHandler').default} CommandHandler\n *\n * @typedef {import('../Modeling').default} Modeling\n * @typedef {import('../../space-tool/BpmnSpaceTool').default} SpaceTool\n */\n\n/**\n * A handler that allows us to add a new lane\n * above or below an existing one.\n *\n * @implements {CommandHandler}\n *\n * @param {Modeling} modeling\n * @param {SpaceTool} spaceTool\n */\nexport default function AddLaneHandler(modeling, spaceTool) {\n  this._modeling = modeling;\n  this._spaceTool = spaceTool;\n}\n\nAddLaneHandler.$inject = [\n  'modeling',\n  'spaceTool'\n];\n\n\nAddLaneHandler.prototype.preExecute = function(context) {\n\n  var spaceTool = this._spaceTool,\n      modeling = this._modeling;\n\n  var shape = context.shape,\n      location = context.location;\n\n  var lanesRoot = getLanesRoot(shape);\n\n  var isRoot = lanesRoot === shape,\n      laneParent = isRoot ? shape : shape.parent;\n\n  var existingChildLanes = getChildLanes(laneParent);\n\n  var isHorizontalLane = isHorizontal(shape);\n\n  // never mix up horizontal/vertical lanes\n  if (isHorizontalLane) {\n    if (location === 'left') {\n      location = 'top';\n    } else if (location === 'right') {\n      location = 'bottom';\n    }\n  } else {\n    if (location === 'top') {\n      location = 'left';\n    } else if (location === 'bottom') {\n      location = 'right';\n    }\n  }\n\n  // (0) add a lane if we currently got none and are adding to root\n  if (!existingChildLanes.length) {\n    var siblingPosition = isHorizontalLane ? {\n      x: shape.x + LANE_INDENTATION,\n      y: shape.y,\n      width: shape.width - LANE_INDENTATION,\n      height: shape.height\n    } : {\n      x: shape.x,\n      y: shape.y + LANE_INDENTATION,\n      width: shape.width,\n      height: shape.height - LANE_INDENTATION\n    };\n\n    modeling.createShape(\n      {\n        type: 'bpmn:Lane',\n        isHorizontal: isHorizontalLane\n      },\n      siblingPosition,\n      laneParent\n    );\n  }\n\n  // (1) collect affected elements to create necessary space\n  var allAffected = [];\n\n  eachElement(lanesRoot, function(element) {\n    allAffected.push(element);\n\n    // handle element labels in the diagram root\n    if (element.label) {\n      allAffected.push(element.label);\n    }\n\n    if (element === shape) {\n      return [];\n    }\n\n    return filter(element.children, function(c) {\n      return c !== shape;\n    });\n  });\n\n  var offset,\n      lanePosition,\n      spacePos,\n      direction,\n      axis;\n\n  if (location === 'top') {\n    offset = -120;\n    lanePosition = shape.y;\n    spacePos = lanePosition + 10;\n    direction = 'n';\n    axis = 'y';\n  } else if (location === 'left') {\n    offset = -120;\n    lanePosition = shape.x;\n    spacePos = lanePosition + 10;\n    direction = 'w';\n    axis = 'x';\n  } else if (location === 'bottom') {\n    offset = 120;\n    lanePosition = shape.y + shape.height;\n    spacePos = lanePosition - 10;\n    direction = 's';\n    axis = 'y';\n  } else if (location === 'right') {\n    offset = 120;\n    lanePosition = shape.x + shape.width;\n    spacePos = lanePosition - 10;\n    direction = 'e';\n    axis = 'x';\n  }\n\n  var adjustments = spaceTool.calculateAdjustments(allAffected, axis, offset, spacePos);\n\n  var delta = isHorizontalLane ? { x: 0, y: offset } : { x: offset, y: 0 };\n\n  spaceTool.makeSpace(\n    adjustments.movingShapes,\n    adjustments.resizingShapes,\n    delta,\n    direction,\n    spacePos\n  );\n\n  // (2) create new lane at open space\n  var newLanePosition = isHorizontalLane ? {\n    x: shape.x + (isRoot ? LANE_INDENTATION : 0),\n    y: lanePosition - (location === 'top' ? 120 : 0),\n    width: shape.width - (isRoot ? LANE_INDENTATION : 0),\n    height: 120\n  } : {\n    x: lanePosition - (location === 'left' ? 120 : 0),\n    y: shape.y + (isRoot ? LANE_INDENTATION : 0),\n    width: 120,\n    height: shape.height - (isRoot ? LANE_INDENTATION : 0)\n  };\n\n  context.newLane = modeling.createShape(\n    {\n      type: 'bpmn:Lane',\n      isHorizontal: isHorizontalLane\n    },\n    newLanePosition,\n    laneParent\n  );\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}