{"ast":null,"code":"var fromCharCode = String.fromCharCode;\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\nvar ENTITY_PATTERN = /&#(\\d+);|&#x([0-9a-f]+);|&(\\w+);/ig;\nvar ENTITY_MAPPING = {\n  'amp': '&',\n  'apos': '\\'',\n  'gt': '>',\n  'lt': '<',\n  'quot': '\"'\n};\n\n// map UPPERCASE variants of supported special chars\nObject.keys(ENTITY_MAPPING).forEach(function (k) {\n  ENTITY_MAPPING[k.toUpperCase()] = ENTITY_MAPPING[k];\n});\nfunction replaceEntities(_, d, x, z) {\n  // reserved names, i.e. &nbsp;\n  if (z) {\n    if (hasOwnProperty.call(ENTITY_MAPPING, z)) {\n      return ENTITY_MAPPING[z];\n    } else {\n      // fall back to original value\n      return '&' + z + ';';\n    }\n  }\n\n  // decimal encoded char\n  if (d) {\n    return fromCharCode(d);\n  }\n\n  // hex encoded char\n  return fromCharCode(parseInt(x, 16));\n}\n\n/**\n * A basic entity decoder that can decode a minimal\n * sub-set of reserved names (&amp;) as well as\n * hex (&#xaaf;) and decimal (&#1231;) encoded characters.\n *\n * @param {string} s\n *\n * @return {string} decoded string\n */\nfunction decodeEntities(s) {\n  if (s.length > 3 && s.indexOf('&') !== -1) {\n    return s.replace(ENTITY_PATTERN, replaceEntities);\n  }\n  return s;\n}\nvar NON_WHITESPACE_OUTSIDE_ROOT_NODE = 'non-whitespace outside of root node';\nfunction error(msg) {\n  return new Error(msg);\n}\nfunction missingNamespaceForPrefix(prefix) {\n  return 'missing namespace for prefix <' + prefix + '>';\n}\nfunction getter(getFn) {\n  return {\n    'get': getFn,\n    'enumerable': true\n  };\n}\nfunction cloneNsMatrix(nsMatrix) {\n  var clone = {},\n    key;\n  for (key in nsMatrix) {\n    clone[key] = nsMatrix[key];\n  }\n  return clone;\n}\nfunction uriPrefix(prefix) {\n  return prefix + '$uri';\n}\nfunction buildNsMatrix(nsUriToPrefix) {\n  var nsMatrix = {},\n    uri,\n    prefix;\n  for (uri in nsUriToPrefix) {\n    prefix = nsUriToPrefix[uri];\n    nsMatrix[prefix] = prefix;\n    nsMatrix[uriPrefix(prefix)] = uri;\n  }\n  return nsMatrix;\n}\nfunction noopGetContext() {\n  return {\n    line: 0,\n    column: 0\n  };\n}\nfunction throwFunc(err) {\n  throw err;\n}\n\n/**\n * Creates a new parser with the given options.\n *\n * @constructor\n *\n * @param  {!Object<string, ?>=} options\n */\nfunction Parser(options) {\n  if (!this) {\n    return new Parser(options);\n  }\n  var proxy = options && options['proxy'];\n  var onText,\n    onOpenTag,\n    onCloseTag,\n    onCDATA,\n    onError = throwFunc,\n    onWarning,\n    onComment,\n    onQuestion,\n    onAttention;\n  var getContext = noopGetContext;\n\n  /**\n   * Do we need to parse the current elements attributes for namespaces?\n   *\n   * @type {boolean}\n   */\n  var maybeNS = false;\n\n  /**\n   * Do we process namespaces at all?\n   *\n   * @type {boolean}\n   */\n  var isNamespace = false;\n\n  /**\n   * The caught error returned on parse end\n   *\n   * @type {Error}\n   */\n  var returnError = null;\n\n  /**\n   * Should we stop parsing?\n   *\n   * @type {boolean}\n   */\n  var parseStop = false;\n\n  /**\n   * A map of { uri: prefix } used by the parser.\n   *\n   * This map will ensure we can normalize prefixes during processing;\n   * for each uri, only one prefix will be exposed to the handlers.\n   *\n   * @type {!Object<string, string>}}\n   */\n  var nsUriToPrefix;\n\n  /**\n   * Handle parse error.\n   *\n   * @param  {string|Error} err\n   */\n  function handleError(err) {\n    if (!(err instanceof Error)) {\n      err = error(err);\n    }\n    returnError = err;\n    onError(err, getContext);\n  }\n\n  /**\n   * Handle parse error.\n   *\n   * @param  {string|Error} err\n   */\n  function handleWarning(err) {\n    if (!onWarning) {\n      return;\n    }\n    if (!(err instanceof Error)) {\n      err = error(err);\n    }\n    onWarning(err, getContext);\n  }\n\n  /**\n   * Register parse listener.\n   *\n   * @param  {string}   name\n   * @param  {Function} cb\n   *\n   * @return {Parser}\n   */\n  this['on'] = function (name, cb) {\n    if (typeof cb !== 'function') {\n      throw error('required args <name, cb>');\n    }\n    switch (name) {\n      case 'openTag':\n        onOpenTag = cb;\n        break;\n      case 'text':\n        onText = cb;\n        break;\n      case 'closeTag':\n        onCloseTag = cb;\n        break;\n      case 'error':\n        onError = cb;\n        break;\n      case 'warn':\n        onWarning = cb;\n        break;\n      case 'cdata':\n        onCDATA = cb;\n        break;\n      case 'attention':\n        onAttention = cb;\n        break;\n      // <!XXXXX zzzz=\"eeee\">\n      case 'question':\n        onQuestion = cb;\n        break;\n      // <? ....  ?>\n      case 'comment':\n        onComment = cb;\n        break;\n      default:\n        throw error('unsupported event: ' + name);\n    }\n    return this;\n  };\n\n  /**\n   * Set the namespace to prefix mapping.\n   *\n   * @example\n   *\n   * parser.ns({\n   *   'http://foo': 'foo',\n   *   'http://bar': 'bar'\n   * });\n   *\n   * @param  {!Object<string, string>} nsMap\n   *\n   * @return {Parser}\n   */\n  this['ns'] = function (nsMap) {\n    if (typeof nsMap === 'undefined') {\n      nsMap = {};\n    }\n    if (typeof nsMap !== 'object') {\n      throw error('required args <nsMap={}>');\n    }\n    var _nsUriToPrefix = {},\n      k;\n    for (k in nsMap) {\n      _nsUriToPrefix[k] = nsMap[k];\n    }\n    isNamespace = true;\n    nsUriToPrefix = _nsUriToPrefix;\n    return this;\n  };\n\n  /**\n   * Parse xml string.\n   *\n   * @param  {string} xml\n   *\n   * @return {Error} returnError, if not thrown\n   */\n  this['parse'] = function (xml) {\n    if (typeof xml !== 'string') {\n      throw error('required args <xml=string>');\n    }\n    returnError = null;\n    parse(xml);\n    getContext = noopGetContext;\n    parseStop = false;\n    return returnError;\n  };\n\n  /**\n   * Stop parsing.\n   */\n  this['stop'] = function () {\n    parseStop = true;\n  };\n\n  /**\n   * Parse string, invoking configured listeners on element.\n   *\n   * @param  {string} xml\n   */\n  function parse(xml) {\n    var nsMatrixStack = isNamespace ? [] : null,\n      nsMatrix = isNamespace ? buildNsMatrix(nsUriToPrefix) : null,\n      _nsMatrix,\n      nodeStack = [],\n      anonymousNsCount = 0,\n      tagStart = false,\n      tagEnd = false,\n      i = 0,\n      j = 0,\n      x,\n      y,\n      q,\n      w,\n      v,\n      xmlns,\n      elementName,\n      _elementName,\n      elementProxy;\n    var attrsString = '',\n      attrsStart = 0,\n      cachedAttrs // false = parsed with errors, null = needs parsing\n    ;\n\n    /**\n     * Parse attributes on demand and returns the parsed attributes.\n     *\n     * Return semantics: (1) `false` on attribute parse error,\n     * (2) object hash on extracted attrs.\n     *\n     * @return {boolean|Object}\n     */\n    function getAttrs() {\n      if (cachedAttrs !== null) {\n        return cachedAttrs;\n      }\n      var nsUri,\n        nsUriPrefix,\n        nsName,\n        defaultAlias = isNamespace && nsMatrix['xmlns'],\n        attrList = isNamespace && maybeNS ? [] : null,\n        i = attrsStart,\n        s = attrsString,\n        l = s.length,\n        hasNewMatrix,\n        newalias,\n        value,\n        alias,\n        name,\n        attrs = {},\n        seenAttrs = {},\n        skipAttr,\n        w,\n        j;\n      parseAttr: for (; i < l; i++) {\n        skipAttr = false;\n        w = s.charCodeAt(i);\n        if (w === 32 || w < 14 && w > 8) {\n          // WHITESPACE={ \\f\\n\\r\\t\\v}\n          continue;\n        }\n\n        // wait for non whitespace character\n        if (w < 65 || w > 122 || w > 90 && w < 97) {\n          if (w !== 95 && w !== 58) {\n            // char 95\"_\" 58\":\"\n            handleWarning('illegal first char attribute name');\n            skipAttr = true;\n          }\n        }\n\n        // parse attribute name\n        for (j = i + 1; j < l; j++) {\n          w = s.charCodeAt(j);\n          if (w > 96 && w < 123 || w > 64 && w < 91 || w > 47 && w < 59 || w === 46 ||\n          // '.'\n          w === 45 ||\n          // '-'\n          w === 95 // '_'\n          ) {\n            continue;\n          }\n\n          // unexpected whitespace\n          if (w === 32 || w < 14 && w > 8) {\n            // WHITESPACE\n            handleWarning('missing attribute value');\n            i = j;\n            continue parseAttr;\n          }\n\n          // expected \"=\"\n          if (w === 61) {\n            // \"=\" == 61\n            break;\n          }\n          handleWarning('illegal attribute name char');\n          skipAttr = true;\n        }\n        name = s.substring(i, j);\n        if (name === 'xmlns:xmlns') {\n          handleWarning('illegal declaration of xmlns');\n          skipAttr = true;\n        }\n        w = s.charCodeAt(j + 1);\n        if (w === 34) {\n          // '\"'\n          j = s.indexOf('\"', i = j + 2);\n          if (j === -1) {\n            j = s.indexOf('\\'', i);\n            if (j !== -1) {\n              handleWarning('attribute value quote missmatch');\n              skipAttr = true;\n            }\n          }\n        } else if (w === 39) {\n          // \"'\"\n          j = s.indexOf('\\'', i = j + 2);\n          if (j === -1) {\n            j = s.indexOf('\"', i);\n            if (j !== -1) {\n              handleWarning('attribute value quote missmatch');\n              skipAttr = true;\n            }\n          }\n        } else {\n          handleWarning('missing attribute value quotes');\n          skipAttr = true;\n\n          // skip to next space\n          for (j = j + 1; j < l; j++) {\n            w = s.charCodeAt(j + 1);\n            if (w === 32 || w < 14 && w > 8) {\n              // WHITESPACE\n              break;\n            }\n          }\n        }\n        if (j === -1) {\n          handleWarning('missing closing quotes');\n          j = l;\n          skipAttr = true;\n        }\n        if (!skipAttr) {\n          value = s.substring(i, j);\n        }\n        i = j;\n\n        // ensure SPACE follows attribute\n        // skip illegal content otherwise\n        // example a=\"b\"c\n        for (; j + 1 < l; j++) {\n          w = s.charCodeAt(j + 1);\n          if (w === 32 || w < 14 && w > 8) {\n            // WHITESPACE\n            break;\n          }\n\n          // FIRST ILLEGAL CHAR\n          if (i === j) {\n            handleWarning('illegal character after attribute end');\n            skipAttr = true;\n          }\n        }\n\n        // advance cursor to next attribute\n        i = j + 1;\n        if (skipAttr) {\n          continue parseAttr;\n        }\n\n        // check attribute re-declaration\n        if (name in seenAttrs) {\n          handleWarning('attribute <' + name + '> already defined');\n          continue;\n        }\n        seenAttrs[name] = true;\n        if (!isNamespace) {\n          attrs[name] = value;\n          continue;\n        }\n\n        // try to extract namespace information\n        if (maybeNS) {\n          newalias = name === 'xmlns' ? 'xmlns' : name.charCodeAt(0) === 120 && name.substr(0, 6) === 'xmlns:' ? name.substr(6) : null;\n\n          // handle xmlns(:alias) assignment\n          if (newalias !== null) {\n            nsUri = decodeEntities(value);\n            nsUriPrefix = uriPrefix(newalias);\n            alias = nsUriToPrefix[nsUri];\n            if (!alias) {\n              // no prefix defined or prefix collision\n              if (newalias === 'xmlns' || nsUriPrefix in nsMatrix && nsMatrix[nsUriPrefix] !== nsUri) {\n                // alocate free ns prefix\n                do {\n                  alias = 'ns' + anonymousNsCount++;\n                } while (typeof nsMatrix[alias] !== 'undefined');\n              } else {\n                alias = newalias;\n              }\n              nsUriToPrefix[nsUri] = alias;\n            }\n            if (nsMatrix[newalias] !== alias) {\n              if (!hasNewMatrix) {\n                nsMatrix = cloneNsMatrix(nsMatrix);\n                hasNewMatrix = true;\n              }\n              nsMatrix[newalias] = alias;\n              if (newalias === 'xmlns') {\n                nsMatrix[uriPrefix(alias)] = nsUri;\n                defaultAlias = alias;\n              }\n              nsMatrix[nsUriPrefix] = nsUri;\n            }\n\n            // expose xmlns(:asd)=\"...\" in attributes\n            attrs[name] = value;\n            continue;\n          }\n\n          // collect attributes until all namespace\n          // declarations are processed\n          attrList.push(name, value);\n          continue;\n        } /** end if (maybeNs) */\n\n        // handle attributes on element without\n        // namespace declarations\n        w = name.indexOf(':');\n        if (w === -1) {\n          attrs[name] = value;\n          continue;\n        }\n\n        // normalize ns attribute name\n        if (!(nsName = nsMatrix[name.substring(0, w)])) {\n          handleWarning(missingNamespaceForPrefix(name.substring(0, w)));\n          continue;\n        }\n        name = defaultAlias === nsName ? name.substr(w + 1) : nsName + name.substr(w);\n\n        // end: normalize ns attribute name\n\n        attrs[name] = value;\n      }\n\n      // handle deferred, possibly namespaced attributes\n      if (maybeNS) {\n        // normalize captured attributes\n        for (i = 0, l = attrList.length; i < l; i++) {\n          name = attrList[i++];\n          value = attrList[i];\n          w = name.indexOf(':');\n          if (w !== -1) {\n            // normalize ns attribute name\n            if (!(nsName = nsMatrix[name.substring(0, w)])) {\n              handleWarning(missingNamespaceForPrefix(name.substring(0, w)));\n              continue;\n            }\n            name = defaultAlias === nsName ? name.substr(w + 1) : nsName + name.substr(w);\n\n            // end: normalize ns attribute name\n          }\n          attrs[name] = value;\n        }\n\n        // end: normalize captured attributes\n      }\n      return cachedAttrs = attrs;\n    }\n\n    /**\n     * Extract the parse context { line, column, part }\n     * from the current parser position.\n     *\n     * @return {Object} parse context\n     */\n    function getParseContext() {\n      var splitsRe = /(\\r\\n|\\r|\\n)/g;\n      var line = 0;\n      var column = 0;\n      var startOfLine = 0;\n      var endOfLine = j;\n      var match;\n      var data;\n      while (i >= startOfLine) {\n        match = splitsRe.exec(xml);\n        if (!match) {\n          break;\n        }\n\n        // end of line = (break idx + break chars)\n        endOfLine = match[0].length + match.index;\n        if (endOfLine > i) {\n          break;\n        }\n\n        // advance to next line\n        line += 1;\n        startOfLine = endOfLine;\n      }\n\n      // EOF errors\n      if (i == -1) {\n        column = endOfLine;\n        data = xml.substring(j);\n      } else\n        // start errors\n        if (j === 0) {\n          data = xml.substring(j, i);\n        }\n\n        // other errors\n        else {\n          column = i - startOfLine;\n          data = j == -1 ? xml.substring(i) : xml.substring(i, j + 1);\n        }\n      return {\n        'data': data,\n        'line': line,\n        'column': column\n      };\n    }\n    getContext = getParseContext;\n    if (proxy) {\n      elementProxy = Object.create({}, {\n        'name': getter(function () {\n          return elementName;\n        }),\n        'originalName': getter(function () {\n          return _elementName;\n        }),\n        'attrs': getter(getAttrs),\n        'ns': getter(function () {\n          return nsMatrix;\n        })\n      });\n    }\n\n    // actual parse logic\n    while (j !== -1) {\n      if (xml.charCodeAt(j) === 60) {\n        // \"<\"\n        i = j;\n      } else {\n        i = xml.indexOf('<', j);\n      }\n\n      // parse end\n      if (i === -1) {\n        if (nodeStack.length) {\n          return handleError('unexpected end of file');\n        }\n        if (j === 0) {\n          return handleError('missing start tag');\n        }\n        if (j < xml.length) {\n          if (xml.substring(j).trim()) {\n            handleWarning(NON_WHITESPACE_OUTSIDE_ROOT_NODE);\n          }\n        }\n        return;\n      }\n\n      // parse text\n      if (j !== i) {\n        if (nodeStack.length) {\n          if (onText) {\n            onText(xml.substring(j, i), decodeEntities, getContext);\n            if (parseStop) {\n              return;\n            }\n          }\n        } else {\n          if (xml.substring(j, i).trim()) {\n            handleWarning(NON_WHITESPACE_OUTSIDE_ROOT_NODE);\n            if (parseStop) {\n              return;\n            }\n          }\n        }\n      }\n      w = xml.charCodeAt(i + 1);\n\n      // parse comments + CDATA\n      if (w === 33) {\n        // \"!\"\n        q = xml.charCodeAt(i + 2);\n\n        // CDATA section\n        if (q === 91 && xml.substr(i + 3, 6) === 'CDATA[') {\n          // 91 == \"[\"\n          j = xml.indexOf(']]>', i);\n          if (j === -1) {\n            return handleError('unclosed cdata');\n          }\n          if (onCDATA) {\n            onCDATA(xml.substring(i + 9, j), getContext);\n            if (parseStop) {\n              return;\n            }\n          }\n          j += 3;\n          continue;\n        }\n\n        // comment\n        if (q === 45 && xml.charCodeAt(i + 3) === 45) {\n          // 45 == \"-\"\n          j = xml.indexOf('-->', i);\n          if (j === -1) {\n            return handleError('unclosed comment');\n          }\n          if (onComment) {\n            onComment(xml.substring(i + 4, j), decodeEntities, getContext);\n            if (parseStop) {\n              return;\n            }\n          }\n          j += 3;\n          continue;\n        }\n      }\n\n      // parse question <? ... ?>\n      if (w === 63) {\n        // \"?\"\n        j = xml.indexOf('?>', i);\n        if (j === -1) {\n          return handleError('unclosed question');\n        }\n        if (onQuestion) {\n          onQuestion(xml.substring(i, j + 2), getContext);\n          if (parseStop) {\n            return;\n          }\n        }\n        j += 2;\n        continue;\n      }\n\n      // find matching closing tag for attention or standard tags\n      // for that we must skip through attribute values\n      // (enclosed in single or double quotes)\n      for (x = i + 1;; x++) {\n        v = xml.charCodeAt(x);\n        if (isNaN(v)) {\n          j = -1;\n          return handleError('unclosed tag');\n        }\n\n        // [10] AttValue ::= '\"' ([^<&\"] | Reference)* '\"' | \"'\" ([^<&'] | Reference)* \"'\"\n        // skips the quoted string\n        // (double quotes) does not appear in a literal enclosed by (double quotes)\n        // (single quote) does not appear in a literal enclosed by (single quote)\n        if (v === 34) {\n          //  '\"'\n          q = xml.indexOf('\"', x + 1);\n          x = q !== -1 ? q : x;\n        } else if (v === 39) {\n          // \"'\"\n          q = xml.indexOf(\"'\", x + 1);\n          x = q !== -1 ? q : x;\n        } else if (v === 62) {\n          // '>'\n          j = x;\n          break;\n        }\n      }\n\n      // parse attention <! ...>\n      // previously comment and CDATA have already been parsed\n      if (w === 33) {\n        // \"!\"\n\n        if (onAttention) {\n          onAttention(xml.substring(i, j + 1), decodeEntities, getContext);\n          if (parseStop) {\n            return;\n          }\n        }\n        j += 1;\n        continue;\n      }\n\n      // don't process attributes;\n      // there are none\n      cachedAttrs = {};\n\n      // if (xml.charCodeAt(i+1) === 47) { // </...\n      if (w === 47) {\n        // </...\n        tagStart = false;\n        tagEnd = true;\n        if (!nodeStack.length) {\n          return handleError('missing open tag');\n        }\n\n        // verify open <-> close tag match\n        x = elementName = nodeStack.pop();\n        q = i + 2 + x.length;\n        if (xml.substring(i + 2, q) !== x) {\n          return handleError('closing tag mismatch');\n        }\n\n        // verify chars in close tag\n        for (; q < j; q++) {\n          w = xml.charCodeAt(q);\n          if (w === 32 || w > 8 && w < 14) {\n            // \\f\\n\\r\\t\\v space\n            continue;\n          }\n          return handleError('close tag');\n        }\n      } else {\n        if (xml.charCodeAt(j - 1) === 47) {\n          // .../>\n          x = elementName = xml.substring(i + 1, j - 1);\n          tagStart = true;\n          tagEnd = true;\n        } else {\n          x = elementName = xml.substring(i + 1, j);\n          tagStart = true;\n          tagEnd = false;\n        }\n        if (!(w > 96 && w < 123 || w > 64 && w < 91 || w === 95 || w === 58)) {\n          // char 95\"_\" 58\":\"\n          return handleError('illegal first char nodeName');\n        }\n        for (q = 1, y = x.length; q < y; q++) {\n          w = x.charCodeAt(q);\n          if (w > 96 && w < 123 || w > 64 && w < 91 || w > 47 && w < 59 || w === 45 || w === 95 || w == 46) {\n            continue;\n          }\n          if (w === 32 || w < 14 && w > 8) {\n            // \\f\\n\\r\\t\\v space\n            elementName = x.substring(0, q);\n\n            // maybe there are attributes\n            cachedAttrs = null;\n            break;\n          }\n          return handleError('invalid nodeName');\n        }\n        if (!tagEnd) {\n          nodeStack.push(elementName);\n        }\n      }\n      if (isNamespace) {\n        _nsMatrix = nsMatrix;\n        if (tagStart) {\n          // remember old namespace\n          // unless we're self-closing\n          if (!tagEnd) {\n            nsMatrixStack.push(_nsMatrix);\n          }\n          if (cachedAttrs === null) {\n            // quick check, whether there may be namespace\n            // declarations on the node; if that is the case\n            // we need to eagerly parse the node attributes\n            if (maybeNS = x.indexOf('xmlns', q) !== -1) {\n              attrsStart = q;\n              attrsString = x;\n              getAttrs();\n              maybeNS = false;\n            }\n          }\n        }\n        _elementName = elementName;\n        w = elementName.indexOf(':');\n        if (w !== -1) {\n          xmlns = nsMatrix[elementName.substring(0, w)];\n\n          // prefix given; namespace must exist\n          if (!xmlns) {\n            return handleError('missing namespace on <' + _elementName + '>');\n          }\n          elementName = elementName.substr(w + 1);\n        } else {\n          xmlns = nsMatrix['xmlns'];\n\n          // if no default namespace is defined,\n          // we'll import the element as anonymous.\n          //\n          // it is up to users to correct that to the document defined\n          // targetNamespace, or whatever their undersanding of the\n          // XML spec mandates.\n        }\n\n        // adjust namespace prefixs as configured\n        if (xmlns) {\n          elementName = xmlns + ':' + elementName;\n        }\n      }\n      if (tagStart) {\n        attrsStart = q;\n        attrsString = x;\n        if (onOpenTag) {\n          if (proxy) {\n            onOpenTag(elementProxy, decodeEntities, tagEnd, getContext);\n          } else {\n            onOpenTag(elementName, getAttrs, decodeEntities, tagEnd, getContext);\n          }\n          if (parseStop) {\n            return;\n          }\n        }\n      }\n      if (tagEnd) {\n        if (onCloseTag) {\n          onCloseTag(proxy ? elementProxy : elementName, decodeEntities, tagStart, getContext);\n          if (parseStop) {\n            return;\n          }\n        }\n\n        // restore old namespace\n        if (isNamespace) {\n          if (!tagStart) {\n            nsMatrix = nsMatrixStack.pop();\n          } else {\n            nsMatrix = _nsMatrix;\n          }\n        }\n      }\n      j += 1;\n    }\n  } /** end parse */\n}\nexport { Parser, decodeEntities as decode };","map":{"version":3,"names":["fromCharCode","String","hasOwnProperty","Object","prototype","ENTITY_PATTERN","ENTITY_MAPPING","keys","forEach","k","toUpperCase","replaceEntities","_","d","x","z","call","parseInt","decodeEntities","s","length","indexOf","replace","NON_WHITESPACE_OUTSIDE_ROOT_NODE","error","msg","Error","missingNamespaceForPrefix","prefix","getter","getFn","cloneNsMatrix","nsMatrix","clone","key","uriPrefix","buildNsMatrix","nsUriToPrefix","uri","noopGetContext","line","column","throwFunc","err","Parser","options","proxy","onText","onOpenTag","onCloseTag","onCDATA","onError","onWarning","onComment","onQuestion","onAttention","getContext","maybeNS","isNamespace","returnError","parseStop","handleError","handleWarning","name","cb","nsMap","_nsUriToPrefix","xml","parse","nsMatrixStack","_nsMatrix","nodeStack","anonymousNsCount","tagStart","tagEnd","i","j","y","q","w","v","xmlns","elementName","_elementName","elementProxy","attrsString","attrsStart","cachedAttrs","getAttrs","nsUri","nsUriPrefix","nsName","defaultAlias","attrList","l","hasNewMatrix","newalias","value","alias","attrs","seenAttrs","skipAttr","parseAttr","charCodeAt","substring","substr","push","getParseContext","splitsRe","startOfLine","endOfLine","match","data","exec","index","create","trim","isNaN","pop"],"sources":["/home/runner/work/sgex/sgex/node_modules/saxen/lib/decode.js","/home/runner/work/sgex/sgex/node_modules/saxen/lib/parser.js"],"sourcesContent":["var fromCharCode = String.fromCharCode;\n\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\n\nvar ENTITY_PATTERN = /&#(\\d+);|&#x([0-9a-f]+);|&(\\w+);/ig;\n\nvar ENTITY_MAPPING = {\n  'amp': '&',\n  'apos': '\\'',\n  'gt': '>',\n  'lt': '<',\n  'quot': '\"'\n};\n\n// map UPPERCASE variants of supported special chars\nObject.keys(ENTITY_MAPPING).forEach(function(k) {\n  ENTITY_MAPPING[k.toUpperCase()] = ENTITY_MAPPING[k];\n});\n\n\nfunction replaceEntities(_, d, x, z) {\n\n  // reserved names, i.e. &nbsp;\n  if (z) {\n    if (hasOwnProperty.call(ENTITY_MAPPING, z)) {\n      return ENTITY_MAPPING[z];\n    } else {\n\n      // fall back to original value\n      return '&' + z + ';';\n    }\n  }\n\n  // decimal encoded char\n  if (d) {\n    return fromCharCode(d);\n  }\n\n  // hex encoded char\n  return fromCharCode(parseInt(x, 16));\n}\n\n\n/**\n * A basic entity decoder that can decode a minimal\n * sub-set of reserved names (&amp;) as well as\n * hex (&#xaaf;) and decimal (&#1231;) encoded characters.\n *\n * @param {string} s\n *\n * @return {string} decoded string\n */\nexport default function decodeEntities(s) {\n  if (s.length > 3 && s.indexOf('&') !== -1) {\n    return s.replace(ENTITY_PATTERN, replaceEntities);\n  }\n\n  return s;\n}","import decodeEntities from './decode.js';\n\nvar NON_WHITESPACE_OUTSIDE_ROOT_NODE = 'non-whitespace outside of root node';\n\nfunction error(msg) {\n  return new Error(msg);\n}\n\nfunction missingNamespaceForPrefix(prefix) {\n  return 'missing namespace for prefix <' + prefix + '>';\n}\n\nfunction getter(getFn) {\n  return {\n    'get': getFn,\n    'enumerable': true\n  };\n}\n\nfunction cloneNsMatrix(nsMatrix) {\n  var clone = {}, key;\n  for (key in nsMatrix) {\n    clone[key] = nsMatrix[key];\n  }\n  return clone;\n}\n\nfunction uriPrefix(prefix) {\n  return prefix + '$uri';\n}\n\nfunction buildNsMatrix(nsUriToPrefix) {\n  var nsMatrix = {},\n      uri,\n      prefix;\n\n  for (uri in nsUriToPrefix) {\n    prefix = nsUriToPrefix[uri];\n    nsMatrix[prefix] = prefix;\n    nsMatrix[uriPrefix(prefix)] = uri;\n  }\n\n  return nsMatrix;\n}\n\nfunction noopGetContext() {\n  return { line: 0, column: 0 };\n}\n\nfunction throwFunc(err) {\n  throw err;\n}\n\n/**\n * Creates a new parser with the given options.\n *\n * @constructor\n *\n * @param  {!Object<string, ?>=} options\n */\nexport default function Parser(options) {\n\n  if (!this) {\n    return new Parser(options);\n  }\n\n  var proxy = options && options['proxy'];\n\n  var onText,\n      onOpenTag,\n      onCloseTag,\n      onCDATA,\n      onError = throwFunc,\n      onWarning,\n      onComment,\n      onQuestion,\n      onAttention;\n\n  var getContext = noopGetContext;\n\n  /**\n   * Do we need to parse the current elements attributes for namespaces?\n   *\n   * @type {boolean}\n   */\n  var maybeNS = false;\n\n  /**\n   * Do we process namespaces at all?\n   *\n   * @type {boolean}\n   */\n  var isNamespace = false;\n\n  /**\n   * The caught error returned on parse end\n   *\n   * @type {Error}\n   */\n  var returnError = null;\n\n  /**\n   * Should we stop parsing?\n   *\n   * @type {boolean}\n   */\n  var parseStop = false;\n\n  /**\n   * A map of { uri: prefix } used by the parser.\n   *\n   * This map will ensure we can normalize prefixes during processing;\n   * for each uri, only one prefix will be exposed to the handlers.\n   *\n   * @type {!Object<string, string>}}\n   */\n  var nsUriToPrefix;\n\n  /**\n   * Handle parse error.\n   *\n   * @param  {string|Error} err\n   */\n  function handleError(err) {\n    if (!(err instanceof Error)) {\n      err = error(err);\n    }\n\n    returnError = err;\n\n    onError(err, getContext);\n  }\n\n  /**\n   * Handle parse error.\n   *\n   * @param  {string|Error} err\n   */\n  function handleWarning(err) {\n\n    if (!onWarning) {\n      return;\n    }\n\n    if (!(err instanceof Error)) {\n      err = error(err);\n    }\n\n    onWarning(err, getContext);\n  }\n\n  /**\n   * Register parse listener.\n   *\n   * @param  {string}   name\n   * @param  {Function} cb\n   *\n   * @return {Parser}\n   */\n  this['on'] = function(name, cb) {\n\n    if (typeof cb !== 'function') {\n      throw error('required args <name, cb>');\n    }\n\n    switch (name) {\n    case 'openTag': onOpenTag = cb; break;\n    case 'text': onText = cb; break;\n    case 'closeTag': onCloseTag = cb; break;\n    case 'error': onError = cb; break;\n    case 'warn': onWarning = cb; break;\n    case 'cdata': onCDATA = cb; break;\n    case 'attention': onAttention = cb; break; // <!XXXXX zzzz=\"eeee\">\n    case 'question': onQuestion = cb; break; // <? ....  ?>\n    case 'comment': onComment = cb; break;\n    default:\n      throw error('unsupported event: ' + name);\n    }\n\n    return this;\n  };\n\n  /**\n   * Set the namespace to prefix mapping.\n   *\n   * @example\n   *\n   * parser.ns({\n   *   'http://foo': 'foo',\n   *   'http://bar': 'bar'\n   * });\n   *\n   * @param  {!Object<string, string>} nsMap\n   *\n   * @return {Parser}\n   */\n  this['ns'] = function(nsMap) {\n\n    if (typeof nsMap === 'undefined') {\n      nsMap = {};\n    }\n\n    if (typeof nsMap !== 'object') {\n      throw error('required args <nsMap={}>');\n    }\n\n    var _nsUriToPrefix = {}, k;\n\n    for (k in nsMap) {\n      _nsUriToPrefix[k] = nsMap[k];\n    }\n\n    isNamespace = true;\n    nsUriToPrefix = _nsUriToPrefix;\n\n    return this;\n  };\n\n  /**\n   * Parse xml string.\n   *\n   * @param  {string} xml\n   *\n   * @return {Error} returnError, if not thrown\n   */\n  this['parse'] = function(xml) {\n    if (typeof xml !== 'string') {\n      throw error('required args <xml=string>');\n    }\n\n    returnError = null;\n\n    parse(xml);\n\n    getContext = noopGetContext;\n    parseStop = false;\n\n    return returnError;\n  };\n\n  /**\n   * Stop parsing.\n   */\n  this['stop'] = function() {\n    parseStop = true;\n  };\n\n  /**\n   * Parse string, invoking configured listeners on element.\n   *\n   * @param  {string} xml\n   */\n  function parse(xml) {\n    var nsMatrixStack = isNamespace ? [] : null,\n        nsMatrix = isNamespace ? buildNsMatrix(nsUriToPrefix) : null,\n        _nsMatrix,\n        nodeStack = [],\n        anonymousNsCount = 0,\n        tagStart = false,\n        tagEnd = false,\n        i = 0, j = 0,\n        x, y, q, w, v,\n        xmlns,\n        elementName,\n        _elementName,\n        elementProxy\n        ;\n\n    var attrsString = '',\n        attrsStart = 0,\n        cachedAttrs // false = parsed with errors, null = needs parsing\n        ;\n\n    /**\n     * Parse attributes on demand and returns the parsed attributes.\n     *\n     * Return semantics: (1) `false` on attribute parse error,\n     * (2) object hash on extracted attrs.\n     *\n     * @return {boolean|Object}\n     */\n    function getAttrs() {\n      if (cachedAttrs !== null) {\n        return cachedAttrs;\n      }\n\n      var nsUri,\n          nsUriPrefix,\n          nsName,\n          defaultAlias = isNamespace && nsMatrix['xmlns'],\n          attrList = isNamespace && maybeNS ? [] : null,\n          i = attrsStart,\n          s = attrsString,\n          l = s.length,\n          hasNewMatrix,\n          newalias,\n          value,\n          alias,\n          name,\n          attrs = {},\n          seenAttrs = {},\n          skipAttr,\n          w,\n          j;\n\n      parseAttr:\n      for (; i < l; i++) {\n        skipAttr = false;\n        w = s.charCodeAt(i);\n\n        if (w === 32 || (w < 14 && w > 8)) { // WHITESPACE={ \\f\\n\\r\\t\\v}\n          continue;\n        }\n\n        // wait for non whitespace character\n        if (w < 65 || w > 122 || (w > 90 && w < 97)) {\n          if (w !== 95 && w !== 58) { // char 95\"_\" 58\":\"\n            handleWarning('illegal first char attribute name');\n            skipAttr = true;\n          }\n        }\n\n        // parse attribute name\n        for (j = i + 1; j < l; j++) {\n          w = s.charCodeAt(j);\n\n          if (\n            w > 96 && w < 123 ||\n            w > 64 && w < 91 ||\n            w > 47 && w < 59 ||\n            w === 46 || // '.'\n            w === 45 || // '-'\n            w === 95 // '_'\n          ) {\n            continue;\n          }\n\n          // unexpected whitespace\n          if (w === 32 || (w < 14 && w > 8)) { // WHITESPACE\n            handleWarning('missing attribute value');\n            i = j;\n\n            continue parseAttr;\n          }\n\n          // expected \"=\"\n          if (w === 61) { // \"=\" == 61\n            break;\n          }\n\n          handleWarning('illegal attribute name char');\n          skipAttr = true;\n        }\n\n        name = s.substring(i, j);\n\n        if (name === 'xmlns:xmlns') {\n          handleWarning('illegal declaration of xmlns');\n          skipAttr = true;\n        }\n\n        w = s.charCodeAt(j + 1);\n\n        if (w === 34) { // '\"'\n          j = s.indexOf('\"', i = j + 2);\n\n          if (j === -1) {\n            j = s.indexOf('\\'', i);\n\n            if (j !== -1) {\n              handleWarning('attribute value quote missmatch');\n              skipAttr = true;\n            }\n          }\n\n        } else if (w === 39) { // \"'\"\n          j = s.indexOf('\\'', i = j + 2);\n\n          if (j === -1) {\n            j = s.indexOf('\"', i);\n\n            if (j !== -1) {\n              handleWarning('attribute value quote missmatch');\n              skipAttr = true;\n            }\n          }\n\n        } else {\n          handleWarning('missing attribute value quotes');\n          skipAttr = true;\n\n          // skip to next space\n          for (j = j + 1; j < l; j++) {\n            w = s.charCodeAt(j + 1);\n\n            if (w === 32 || (w < 14 && w > 8)) { // WHITESPACE\n              break;\n            }\n          }\n\n        }\n\n        if (j === -1) {\n          handleWarning('missing closing quotes');\n\n          j = l;\n          skipAttr = true;\n        }\n\n        if (!skipAttr) {\n          value = s.substring(i, j);\n        }\n\n        i = j;\n\n        // ensure SPACE follows attribute\n        // skip illegal content otherwise\n        // example a=\"b\"c\n        for (; j + 1 < l; j++) {\n          w = s.charCodeAt(j + 1);\n\n          if (w === 32 || (w < 14 && w > 8)) { // WHITESPACE\n            break;\n          }\n\n          // FIRST ILLEGAL CHAR\n          if (i === j) {\n            handleWarning('illegal character after attribute end');\n            skipAttr = true;\n          }\n        }\n\n        // advance cursor to next attribute\n        i = j + 1;\n\n        if (skipAttr) {\n          continue parseAttr;\n        }\n\n        // check attribute re-declaration\n        if (name in seenAttrs) {\n          handleWarning('attribute <' + name + '> already defined');\n          continue;\n        }\n\n        seenAttrs[name] = true;\n\n        if (!isNamespace) {\n          attrs[name] = value;\n          continue;\n        }\n\n        // try to extract namespace information\n        if (maybeNS) {\n          newalias = (\n            name === 'xmlns'\n              ? 'xmlns'\n              : (name.charCodeAt(0) === 120 && name.substr(0, 6) === 'xmlns:')\n                ? name.substr(6)\n                : null\n          );\n\n          // handle xmlns(:alias) assignment\n          if (newalias !== null) {\n            nsUri = decodeEntities(value);\n            nsUriPrefix = uriPrefix(newalias);\n\n            alias = nsUriToPrefix[nsUri];\n\n            if (!alias) {\n\n              // no prefix defined or prefix collision\n              if (\n                (newalias === 'xmlns') ||\n                (nsUriPrefix in nsMatrix && nsMatrix[nsUriPrefix] !== nsUri)\n              ) {\n\n                // alocate free ns prefix\n                do {\n                  alias = 'ns' + (anonymousNsCount++);\n                } while (typeof nsMatrix[alias] !== 'undefined');\n              } else {\n                alias = newalias;\n              }\n\n              nsUriToPrefix[nsUri] = alias;\n            }\n\n            if (nsMatrix[newalias] !== alias) {\n              if (!hasNewMatrix) {\n                nsMatrix = cloneNsMatrix(nsMatrix);\n                hasNewMatrix = true;\n              }\n\n              nsMatrix[newalias] = alias;\n              if (newalias === 'xmlns') {\n                nsMatrix[uriPrefix(alias)] = nsUri;\n                defaultAlias = alias;\n              }\n\n              nsMatrix[nsUriPrefix] = nsUri;\n            }\n\n            // expose xmlns(:asd)=\"...\" in attributes\n            attrs[name] = value;\n            continue;\n          }\n\n          // collect attributes until all namespace\n          // declarations are processed\n          attrList.push(name, value);\n          continue;\n\n        } /** end if (maybeNs) */\n\n        // handle attributes on element without\n        // namespace declarations\n        w = name.indexOf(':');\n        if (w === -1) {\n          attrs[name] = value;\n          continue;\n        }\n\n        // normalize ns attribute name\n        if (!(nsName = nsMatrix[name.substring(0, w)])) {\n          handleWarning(missingNamespaceForPrefix(name.substring(0, w)));\n          continue;\n        }\n\n        name = defaultAlias === nsName\n          ? name.substr(w + 1)\n          : nsName + name.substr(w);\n\n        // end: normalize ns attribute name\n\n        attrs[name] = value;\n      }\n\n\n      // handle deferred, possibly namespaced attributes\n      if (maybeNS) {\n\n        // normalize captured attributes\n        for (i = 0, l = attrList.length; i < l; i++) {\n\n          name = attrList[i++];\n          value = attrList[i];\n\n          w = name.indexOf(':');\n\n          if (w !== -1) {\n\n            // normalize ns attribute name\n            if (!(nsName = nsMatrix[name.substring(0, w)])) {\n              handleWarning(missingNamespaceForPrefix(name.substring(0, w)));\n              continue;\n            }\n\n            name = defaultAlias === nsName\n              ? name.substr(w + 1)\n              : nsName + name.substr(w);\n\n            // end: normalize ns attribute name\n          }\n\n          attrs[name] = value;\n        }\n\n        // end: normalize captured attributes\n      }\n\n      return cachedAttrs = attrs;\n    }\n\n    /**\n     * Extract the parse context { line, column, part }\n     * from the current parser position.\n     *\n     * @return {Object} parse context\n     */\n    function getParseContext() {\n      var splitsRe = /(\\r\\n|\\r|\\n)/g;\n\n      var line = 0;\n      var column = 0;\n      var startOfLine = 0;\n      var endOfLine = j;\n      var match;\n      var data;\n\n      while (i >= startOfLine) {\n\n        match = splitsRe.exec(xml);\n\n        if (!match) {\n          break;\n        }\n\n        // end of line = (break idx + break chars)\n        endOfLine = match[0].length + match.index;\n\n        if (endOfLine > i) {\n          break;\n        }\n\n        // advance to next line\n        line += 1;\n\n        startOfLine = endOfLine;\n      }\n\n      // EOF errors\n      if (i == -1) {\n        column = endOfLine;\n        data = xml.substring(j);\n      } else\n\n      // start errors\n      if (j === 0) {\n        data = xml.substring(j, i);\n      }\n\n      // other errors\n      else {\n        column = i - startOfLine;\n        data = (j == -1 ? xml.substring(i) : xml.substring(i, j + 1));\n      }\n\n      return {\n        'data': data,\n        'line': line,\n        'column': column\n      };\n    }\n\n    getContext = getParseContext;\n\n\n    if (proxy) {\n      elementProxy = Object.create({}, {\n        'name': getter(function() {\n          return elementName;\n        }),\n        'originalName': getter(function() {\n          return _elementName;\n        }),\n        'attrs': getter(getAttrs),\n        'ns': getter(function() {\n          return nsMatrix;\n        })\n      });\n    }\n\n    // actual parse logic\n    while (j !== -1) {\n\n      if (xml.charCodeAt(j) === 60) { // \"<\"\n        i = j;\n      } else {\n        i = xml.indexOf('<', j);\n      }\n\n      // parse end\n      if (i === -1) {\n        if (nodeStack.length) {\n          return handleError('unexpected end of file');\n        }\n\n        if (j === 0) {\n          return handleError('missing start tag');\n        }\n\n        if (j < xml.length) {\n          if (xml.substring(j).trim()) {\n            handleWarning(NON_WHITESPACE_OUTSIDE_ROOT_NODE);\n          }\n        }\n\n        return;\n      }\n\n      // parse text\n      if (j !== i) {\n\n        if (nodeStack.length) {\n          if (onText) {\n            onText(xml.substring(j, i), decodeEntities, getContext);\n\n            if (parseStop) {\n              return;\n            }\n          }\n        } else {\n          if (xml.substring(j, i).trim()) {\n            handleWarning(NON_WHITESPACE_OUTSIDE_ROOT_NODE);\n\n            if (parseStop) {\n              return;\n            }\n          }\n        }\n      }\n\n      w = xml.charCodeAt(i + 1);\n\n      // parse comments + CDATA\n      if (w === 33) { // \"!\"\n        q = xml.charCodeAt(i + 2);\n\n        // CDATA section\n        if (q === 91 && xml.substr(i + 3, 6) === 'CDATA[') { // 91 == \"[\"\n          j = xml.indexOf(']]>', i);\n          if (j === -1) {\n            return handleError('unclosed cdata');\n          }\n\n          if (onCDATA) {\n            onCDATA(xml.substring(i + 9, j), getContext);\n            if (parseStop) {\n              return;\n            }\n          }\n\n          j += 3;\n          continue;\n        }\n\n        // comment\n        if (q === 45 && xml.charCodeAt(i + 3) === 45) { // 45 == \"-\"\n          j = xml.indexOf('-->', i);\n          if (j === -1) {\n            return handleError('unclosed comment');\n          }\n\n\n          if (onComment) {\n            onComment(xml.substring(i + 4, j), decodeEntities, getContext);\n            if (parseStop) {\n              return;\n            }\n          }\n\n          j += 3;\n          continue;\n        }\n      }\n\n      // parse question <? ... ?>\n      if (w === 63) { // \"?\"\n        j = xml.indexOf('?>', i);\n        if (j === -1) {\n          return handleError('unclosed question');\n        }\n\n        if (onQuestion) {\n          onQuestion(xml.substring(i, j + 2), getContext);\n          if (parseStop) {\n            return;\n          }\n        }\n\n        j += 2;\n        continue;\n      }\n\n      // find matching closing tag for attention or standard tags\n      // for that we must skip through attribute values\n      // (enclosed in single or double quotes)\n      for (x = i + 1; ; x++) {\n        v = xml.charCodeAt(x);\n        if (isNaN(v)) {\n          j = -1;\n          return handleError('unclosed tag');\n        }\n\n        // [10] AttValue ::= '\"' ([^<&\"] | Reference)* '\"' | \"'\" ([^<&'] | Reference)* \"'\"\n        // skips the quoted string\n        // (double quotes) does not appear in a literal enclosed by (double quotes)\n        // (single quote) does not appear in a literal enclosed by (single quote)\n        if (v === 34) { //  '\"'\n          q = xml.indexOf('\"', x + 1);\n          x = q !== -1 ? q : x;\n        } else if (v === 39) { // \"'\"\n          q = xml.indexOf(\"'\", x + 1);\n          x = q !== -1 ? q : x;\n        } else if (v === 62) { // '>'\n          j = x;\n          break;\n        }\n      }\n\n\n      // parse attention <! ...>\n      // previously comment and CDATA have already been parsed\n      if (w === 33) { // \"!\"\n\n        if (onAttention) {\n          onAttention(xml.substring(i, j + 1), decodeEntities, getContext);\n          if (parseStop) {\n            return;\n          }\n        }\n\n        j += 1;\n        continue;\n      }\n\n      // don't process attributes;\n      // there are none\n      cachedAttrs = {};\n\n      // if (xml.charCodeAt(i+1) === 47) { // </...\n      if (w === 47) { // </...\n        tagStart = false;\n        tagEnd = true;\n\n        if (!nodeStack.length) {\n          return handleError('missing open tag');\n        }\n\n        // verify open <-> close tag match\n        x = elementName = nodeStack.pop();\n        q = i + 2 + x.length;\n\n        if (xml.substring(i + 2, q) !== x) {\n          return handleError('closing tag mismatch');\n        }\n\n        // verify chars in close tag\n        for (; q < j; q++) {\n          w = xml.charCodeAt(q);\n\n          if (w === 32 || (w > 8 && w < 14)) { // \\f\\n\\r\\t\\v space\n            continue;\n          }\n\n          return handleError('close tag');\n        }\n\n      } else {\n        if (xml.charCodeAt(j - 1) === 47) { // .../>\n          x = elementName = xml.substring(i + 1, j - 1);\n\n          tagStart = true;\n          tagEnd = true;\n\n        } else {\n          x = elementName = xml.substring(i + 1, j);\n\n          tagStart = true;\n          tagEnd = false;\n        }\n\n        if (!(w > 96 && w < 123 || w > 64 && w < 91 || w === 95 || w === 58)) { // char 95\"_\" 58\":\"\n          return handleError('illegal first char nodeName');\n        }\n\n        for (q = 1, y = x.length; q < y; q++) {\n          w = x.charCodeAt(q);\n\n          if (w > 96 && w < 123 || w > 64 && w < 91 || w > 47 && w < 59 || w === 45 || w === 95 || w == 46) {\n            continue;\n          }\n\n          if (w === 32 || (w < 14 && w > 8)) { // \\f\\n\\r\\t\\v space\n            elementName = x.substring(0, q);\n\n            // maybe there are attributes\n            cachedAttrs = null;\n            break;\n          }\n\n          return handleError('invalid nodeName');\n        }\n\n        if (!tagEnd) {\n          nodeStack.push(elementName);\n        }\n      }\n\n      if (isNamespace) {\n\n        _nsMatrix = nsMatrix;\n\n        if (tagStart) {\n\n          // remember old namespace\n          // unless we're self-closing\n          if (!tagEnd) {\n            nsMatrixStack.push(_nsMatrix);\n          }\n\n          if (cachedAttrs === null) {\n\n            // quick check, whether there may be namespace\n            // declarations on the node; if that is the case\n            // we need to eagerly parse the node attributes\n            if ((maybeNS = x.indexOf('xmlns', q) !== -1)) {\n              attrsStart = q;\n              attrsString = x;\n\n              getAttrs();\n\n              maybeNS = false;\n            }\n          }\n        }\n\n        _elementName = elementName;\n\n        w = elementName.indexOf(':');\n        if (w !== -1) {\n          xmlns = nsMatrix[elementName.substring(0, w)];\n\n          // prefix given; namespace must exist\n          if (!xmlns) {\n            return handleError('missing namespace on <' + _elementName + '>');\n          }\n\n          elementName = elementName.substr(w + 1);\n        } else {\n          xmlns = nsMatrix['xmlns'];\n\n          // if no default namespace is defined,\n          // we'll import the element as anonymous.\n          //\n          // it is up to users to correct that to the document defined\n          // targetNamespace, or whatever their undersanding of the\n          // XML spec mandates.\n        }\n\n        // adjust namespace prefixs as configured\n        if (xmlns) {\n          elementName = xmlns + ':' + elementName;\n        }\n\n      }\n\n      if (tagStart) {\n        attrsStart = q;\n        attrsString = x;\n\n        if (onOpenTag) {\n          if (proxy) {\n            onOpenTag(elementProxy, decodeEntities, tagEnd, getContext);\n          } else {\n            onOpenTag(elementName, getAttrs, decodeEntities, tagEnd, getContext);\n          }\n\n          if (parseStop) {\n            return;\n          }\n        }\n\n      }\n\n      if (tagEnd) {\n\n        if (onCloseTag) {\n          onCloseTag(proxy ? elementProxy : elementName, decodeEntities, tagStart, getContext);\n\n          if (parseStop) {\n            return;\n          }\n        }\n\n        // restore old namespace\n        if (isNamespace) {\n          if (!tagStart) {\n            nsMatrix = nsMatrixStack.pop();\n          } else {\n            nsMatrix = _nsMatrix;\n          }\n        }\n      }\n\n      j += 1;\n    }\n  } /** end parse */\n\n}"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}