{"ast":null,"code":"/**\n * Simple in-memory cache for repository compatibility checks\n * Prevents redundant sushi-config.yaml downloads during scanning\n */class RepositoryCompatibilityCache{constructor(){let ttlMinutes=arguments.length>0&&arguments[0]!==undefined?arguments[0]:30;this.cache=new Map();this.ttl=ttlMinutes*60*1000;// Convert to milliseconds\n}/**\n   * Generate cache key for a repository\n   * @param {string} owner - Repository owner\n   * @param {string} repo - Repository name\n   * @returns {string} Cache key\n   */_getCacheKey(owner,repo){return\"\".concat(owner,\"/\").concat(repo);}/**\n   * Check if cache entry is still valid\n   * @param {Object} entry - Cache entry\n   * @returns {boolean} True if valid\n   */_isValid(entry){return Date.now()-entry.timestamp<this.ttl;}/**\n   * Get cached compatibility result\n   * @param {string} owner - Repository owner\n   * @param {string} repo - Repository name\n   * @returns {boolean|null} Cached result or null if not cached/expired\n   */get(owner,repo){const key=this._getCacheKey(owner,repo);const entry=this.cache.get(key);if(!entry){return null;}if(!this._isValid(entry)){this.cache.delete(key);return null;}return entry.compatible;}/**\n   * Set cached compatibility result\n   * @param {string} owner - Repository owner\n   * @param {string} repo - Repository name\n   * @param {boolean} compatible - Whether repository is SMART guidelines compatible\n   */set(owner,repo,compatible){const key=this._getCacheKey(owner,repo);this.cache.set(key,{compatible,timestamp:Date.now()});}/**\n   * Clear all cached entries\n   */clear(){this.cache.clear();}/**\n   * Clean up expired entries\n   */cleanup(){const now=Date.now();for(const[key,entry]of this.cache.entries()){if(now-entry.timestamp>=this.ttl){this.cache.delete(key);}}}/**\n   * Get cache statistics\n   * @returns {Object} Cache stats\n   */getStats(){this.cleanup();return{size:this.cache.size,ttlMinutes:this.ttl/(60*1000),entries:Array.from(this.cache.entries()).map(_ref=>{let[key,entry]=_ref;return{repository:key,compatible:entry.compatible,ageMinutes:Math.round((Date.now()-entry.timestamp)/(60*1000))};})};}}// Create a singleton instance\nconst repositoryCompatibilityCache=new RepositoryCompatibilityCache();export default repositoryCompatibilityCache;","map":{"version":3,"names":["RepositoryCompatibilityCache","constructor","ttlMinutes","arguments","length","undefined","cache","Map","ttl","_getCacheKey","owner","repo","concat","_isValid","entry","Date","now","timestamp","get","key","delete","compatible","set","clear","cleanup","entries","getStats","size","Array","from","map","_ref","repository","ageMinutes","Math","round","repositoryCompatibilityCache"],"sources":["/home/runner/work/sgex/sgex/src/utils/repositoryCompatibilityCache.js"],"sourcesContent":["/**\n * Simple in-memory cache for repository compatibility checks\n * Prevents redundant sushi-config.yaml downloads during scanning\n */\n\nclass RepositoryCompatibilityCache {\n  constructor(ttlMinutes = 30) {\n    this.cache = new Map();\n    this.ttl = ttlMinutes * 60 * 1000; // Convert to milliseconds\n  }\n\n  /**\n   * Generate cache key for a repository\n   * @param {string} owner - Repository owner\n   * @param {string} repo - Repository name\n   * @returns {string} Cache key\n   */\n  _getCacheKey(owner, repo) {\n    return `${owner}/${repo}`;\n  }\n\n  /**\n   * Check if cache entry is still valid\n   * @param {Object} entry - Cache entry\n   * @returns {boolean} True if valid\n   */\n  _isValid(entry) {\n    return Date.now() - entry.timestamp < this.ttl;\n  }\n\n  /**\n   * Get cached compatibility result\n   * @param {string} owner - Repository owner\n   * @param {string} repo - Repository name\n   * @returns {boolean|null} Cached result or null if not cached/expired\n   */\n  get(owner, repo) {\n    const key = this._getCacheKey(owner, repo);\n    const entry = this.cache.get(key);\n    \n    if (!entry) {\n      return null;\n    }\n    \n    if (!this._isValid(entry)) {\n      this.cache.delete(key);\n      return null;\n    }\n    \n    return entry.compatible;\n  }\n\n  /**\n   * Set cached compatibility result\n   * @param {string} owner - Repository owner\n   * @param {string} repo - Repository name\n   * @param {boolean} compatible - Whether repository is SMART guidelines compatible\n   */\n  set(owner, repo, compatible) {\n    const key = this._getCacheKey(owner, repo);\n    this.cache.set(key, {\n      compatible,\n      timestamp: Date.now()\n    });\n  }\n\n  /**\n   * Clear all cached entries\n   */\n  clear() {\n    this.cache.clear();\n  }\n\n  /**\n   * Clean up expired entries\n   */\n  cleanup() {\n    const now = Date.now();\n    for (const [key, entry] of this.cache.entries()) {\n      if (now - entry.timestamp >= this.ttl) {\n        this.cache.delete(key);\n      }\n    }\n  }\n\n  /**\n   * Get cache statistics\n   * @returns {Object} Cache stats\n   */\n  getStats() {\n    this.cleanup();\n    return {\n      size: this.cache.size,\n      ttlMinutes: this.ttl / (60 * 1000),\n      entries: Array.from(this.cache.entries()).map(([key, entry]) => ({\n        repository: key,\n        compatible: entry.compatible,\n        ageMinutes: Math.round((Date.now() - entry.timestamp) / (60 * 1000))\n      }))\n    };\n  }\n}\n\n// Create a singleton instance\nconst repositoryCompatibilityCache = new RepositoryCompatibilityCache();\n\nexport default repositoryCompatibilityCache;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}