{"ast":null,"code":"var MARKER_OK = 'drop-ok',\n  MARKER_NOT_OK = 'drop-not-ok',\n  MARKER_ATTACH = 'attach-ok',\n  MARKER_NEW_PARENT = 'new-parent';\nimport { assign, filter, find, forEach, isArray, isNumber, map } from 'min-dash';\nimport { getBBox } from '../../util/Elements';\nimport { isConnection, isLabel } from '../../util/ModelUtil';\n\n/**\n * @typedef {import('../../core/Types').ElementLike} Element\n * @typedef {import('../../core/Types').ShapeLike} Shape\n *\n * @typedef {import('../../util/Types').Point} Point\n *\n * @typedef {import('../../core/Canvas').default} Canvas\n * @typedef {import('../dragging/Dragging').default} Dragging\n * @typedef {import('../../core/EventBus').default} EventBus\n * @typedef {import('../modeling/Modeling').default} Modeling\n * @typedef {import('../rules/Rules').default} Rules\n */\n\nvar PREFIX = 'create';\nvar HIGH_PRIORITY = 2000;\n\n/**\n * Create new elements through drag and drop.\n *\n * @param {Canvas} canvas\n * @param {Dragging} dragging\n * @param {EventBus} eventBus\n * @param {Modeling} modeling\n * @param {Rules} rules\n */\nexport default function Create(canvas, dragging, eventBus, modeling, rules) {\n  // rules //////////\n\n  /**\n   * Check wether elements can be created.\n   *\n   * @param {Element[]} elements\n   * @param {Shape} target\n   * @param {Point} position\n   * @param {Element} [source]\n   *\n   * @return {boolean|null|Object}\n   */\n  function canCreate(elements, target, position, source, hints) {\n    if (!target) {\n      return false;\n    }\n\n    // ignore child elements and external labels\n    elements = filter(elements, function (element) {\n      var labelTarget = element.labelTarget;\n      return !element.parent && !(isLabel(element) && elements.indexOf(labelTarget) !== -1);\n    });\n    var shape = find(elements, function (element) {\n      return !isConnection(element);\n    });\n    var attach = false,\n      connect = false,\n      create = false;\n\n    // (1) attaching single shapes\n    if (isSingleShape(elements)) {\n      attach = rules.allowed('shape.attach', {\n        position: position,\n        shape: shape,\n        target: target\n      });\n    }\n    if (!attach) {\n      // (2) creating elements\n      if (isSingleShape(elements)) {\n        create = rules.allowed('shape.create', {\n          position: position,\n          shape: shape,\n          source: source,\n          target: target\n        });\n      } else {\n        create = rules.allowed('elements.create', {\n          elements: elements,\n          position: position,\n          target: target\n        });\n      }\n    }\n    var connectionTarget = hints.connectionTarget;\n\n    // (3) appending single shapes\n    if (create || attach) {\n      if (shape && source) {\n        connect = rules.allowed('connection.create', {\n          source: connectionTarget === source ? shape : source,\n          target: connectionTarget === source ? source : shape,\n          hints: {\n            targetParent: target,\n            targetAttach: attach\n          }\n        });\n      }\n      return {\n        attach: attach,\n        connect: connect\n      };\n    }\n\n    // ignore wether or not elements can be created\n    if (create === null || attach === null) {\n      return null;\n    }\n    return false;\n  }\n  function setMarker(element, marker) {\n    [MARKER_ATTACH, MARKER_OK, MARKER_NOT_OK, MARKER_NEW_PARENT].forEach(function (m) {\n      if (m === marker) {\n        canvas.addMarker(element, m);\n      } else {\n        canvas.removeMarker(element, m);\n      }\n    });\n  }\n\n  // event handling //////////\n\n  eventBus.on(['create.move', 'create.hover'], function (event) {\n    var context = event.context,\n      elements = context.elements,\n      hover = event.hover,\n      source = context.source,\n      hints = context.hints || {};\n    if (!hover) {\n      context.canExecute = false;\n      context.target = null;\n      return;\n    }\n    ensureConstraints(event);\n    var position = {\n      x: event.x,\n      y: event.y\n    };\n    var canExecute = context.canExecute = hover && canCreate(elements, hover, position, source, hints);\n    if (hover && canExecute !== null) {\n      context.target = hover;\n      if (canExecute && canExecute.attach) {\n        setMarker(hover, MARKER_ATTACH);\n      } else {\n        setMarker(hover, canExecute ? MARKER_NEW_PARENT : MARKER_NOT_OK);\n      }\n    }\n  });\n  eventBus.on(['create.end', 'create.out', 'create.cleanup'], function (event) {\n    var hover = event.hover;\n    if (hover) {\n      setMarker(hover, null);\n    }\n  });\n  eventBus.on('create.end', function (event) {\n    var context = event.context,\n      source = context.source,\n      shape = context.shape,\n      elements = context.elements,\n      target = context.target,\n      canExecute = context.canExecute,\n      attach = canExecute && canExecute.attach,\n      connect = canExecute && canExecute.connect,\n      hints = context.hints || {};\n    if (canExecute === false || !target) {\n      return false;\n    }\n    ensureConstraints(event);\n    var position = {\n      x: event.x,\n      y: event.y\n    };\n    if (connect) {\n      shape = modeling.appendShape(source, shape, position, target, {\n        attach: attach,\n        connection: connect === true ? {} : connect,\n        connectionTarget: hints.connectionTarget\n      });\n    } else {\n      elements = modeling.createElements(elements, position, target, assign({}, hints, {\n        attach: attach\n      }));\n\n      // update shape\n      shape = find(elements, function (element) {\n        return !isConnection(element);\n      });\n    }\n\n    // update elements and shape\n    assign(context, {\n      elements: elements,\n      shape: shape\n    });\n    assign(event, {\n      elements: elements,\n      shape: shape\n    });\n  });\n  function cancel() {\n    var context = dragging.context();\n    if (context && context.prefix === PREFIX) {\n      dragging.cancel();\n    }\n  }\n\n  // cancel on <elements.changed> that is not result of <drag.end>\n  eventBus.on('create.init', function () {\n    eventBus.on('elements.changed', cancel);\n    eventBus.once(['create.cancel', 'create.end'], HIGH_PRIORITY, function () {\n      eventBus.off('elements.changed', cancel);\n    });\n  });\n\n  // API //////////\n\n  /**\n   * @param event\n   * @param elements\n   * @param {any} [context={}]\n   */\n  this.start = function (event, elements, context) {\n    if (!isArray(elements)) {\n      elements = [elements];\n    }\n    var shape = find(elements, function (element) {\n      return !isConnection(element);\n    });\n    if (!shape) {\n      // at least one shape is required\n      return;\n    }\n    context = assign({\n      elements: elements,\n      hints: {},\n      shape: shape\n    }, context || {});\n\n    // make sure each element has x and y\n    forEach(elements, function (element) {\n      if (!isNumber(element.x)) {\n        element.x = 0;\n      }\n      if (!isNumber(element.y)) {\n        element.y = 0;\n      }\n    });\n    var visibleElements = filter(elements, function (element) {\n      return !element.hidden;\n    });\n    var bbox = getBBox(visibleElements);\n\n    // center elements around cursor\n    forEach(elements, function (element) {\n      if (isConnection(element)) {\n        element.waypoints = map(element.waypoints, function (waypoint) {\n          return {\n            x: waypoint.x - bbox.x - bbox.width / 2,\n            y: waypoint.y - bbox.y - bbox.height / 2\n          };\n        });\n      }\n      assign(element, {\n        x: element.x - bbox.x - bbox.width / 2,\n        y: element.y - bbox.y - bbox.height / 2\n      });\n    });\n    dragging.init(event, PREFIX, {\n      cursor: 'grabbing',\n      autoActivate: true,\n      data: {\n        shape: shape,\n        elements: elements,\n        context: context\n      }\n    });\n  };\n}\nCreate.$inject = ['canvas', 'dragging', 'eventBus', 'modeling', 'rules'];\n\n// helpers //////////\n\nfunction ensureConstraints(event) {\n  var context = event.context,\n    createConstraints = context.createConstraints;\n  if (!createConstraints) {\n    return;\n  }\n  if (createConstraints.left) {\n    event.x = Math.max(event.x, createConstraints.left);\n  }\n  if (createConstraints.right) {\n    event.x = Math.min(event.x, createConstraints.right);\n  }\n  if (createConstraints.top) {\n    event.y = Math.max(event.y, createConstraints.top);\n  }\n  if (createConstraints.bottom) {\n    event.y = Math.min(event.y, createConstraints.bottom);\n  }\n}\nfunction isSingleShape(elements) {\n  return elements && elements.length === 1 && !isConnection(elements[0]);\n}","map":{"version":3,"names":["MARKER_OK","MARKER_NOT_OK","MARKER_ATTACH","MARKER_NEW_PARENT","assign","filter","find","forEach","isArray","isNumber","map","getBBox","isConnection","isLabel","PREFIX","HIGH_PRIORITY","Create","canvas","dragging","eventBus","modeling","rules","canCreate","elements","target","position","source","hints","element","labelTarget","parent","indexOf","shape","attach","connect","create","isSingleShape","allowed","connectionTarget","targetParent","targetAttach","setMarker","marker","m","addMarker","removeMarker","on","event","context","hover","canExecute","ensureConstraints","x","y","appendShape","connection","createElements","cancel","prefix","once","off","start","visibleElements","hidden","bbox","waypoints","waypoint","width","height","init","cursor","autoActivate","data","$inject","createConstraints","left","Math","max","right","min","top","bottom","length"],"sources":["/home/runner/work/sgex/sgex/node_modules/diagram-js/lib/features/create/Create.js"],"sourcesContent":["var MARKER_OK = 'drop-ok',\n    MARKER_NOT_OK = 'drop-not-ok',\n    MARKER_ATTACH = 'attach-ok',\n    MARKER_NEW_PARENT = 'new-parent';\n\nimport {\n  assign,\n  filter,\n  find,\n  forEach,\n  isArray,\n  isNumber,\n  map\n} from 'min-dash';\n\nimport { getBBox } from '../../util/Elements';\n\nimport {\n  isConnection,\n  isLabel\n} from '../../util/ModelUtil';\n\n/**\n * @typedef {import('../../core/Types').ElementLike} Element\n * @typedef {import('../../core/Types').ShapeLike} Shape\n *\n * @typedef {import('../../util/Types').Point} Point\n *\n * @typedef {import('../../core/Canvas').default} Canvas\n * @typedef {import('../dragging/Dragging').default} Dragging\n * @typedef {import('../../core/EventBus').default} EventBus\n * @typedef {import('../modeling/Modeling').default} Modeling\n * @typedef {import('../rules/Rules').default} Rules\n */\n\nvar PREFIX = 'create';\n\nvar HIGH_PRIORITY = 2000;\n\n\n/**\n * Create new elements through drag and drop.\n *\n * @param {Canvas} canvas\n * @param {Dragging} dragging\n * @param {EventBus} eventBus\n * @param {Modeling} modeling\n * @param {Rules} rules\n */\nexport default function Create(\n    canvas,\n    dragging,\n    eventBus,\n    modeling,\n    rules\n) {\n\n  // rules //////////\n\n  /**\n   * Check wether elements can be created.\n   *\n   * @param {Element[]} elements\n   * @param {Shape} target\n   * @param {Point} position\n   * @param {Element} [source]\n   *\n   * @return {boolean|null|Object}\n   */\n  function canCreate(elements, target, position, source, hints) {\n    if (!target) {\n      return false;\n    }\n\n    // ignore child elements and external labels\n    elements = filter(elements, function(element) {\n      var labelTarget = element.labelTarget;\n\n      return !element.parent && !(isLabel(element) && elements.indexOf(labelTarget) !== -1);\n    });\n\n    var shape = find(elements, function(element) {\n      return !isConnection(element);\n    });\n\n    var attach = false,\n        connect = false,\n        create = false;\n\n    // (1) attaching single shapes\n    if (isSingleShape(elements)) {\n      attach = rules.allowed('shape.attach', {\n        position: position,\n        shape: shape,\n        target: target\n      });\n    }\n\n    if (!attach) {\n\n      // (2) creating elements\n      if (isSingleShape(elements)) {\n        create = rules.allowed('shape.create', {\n          position: position,\n          shape: shape,\n          source: source,\n          target: target\n        });\n      } else {\n        create = rules.allowed('elements.create', {\n          elements: elements,\n          position: position,\n          target: target\n        });\n      }\n\n    }\n\n    var connectionTarget = hints.connectionTarget;\n\n    // (3) appending single shapes\n    if (create || attach) {\n      if (shape && source) {\n        connect = rules.allowed('connection.create', {\n          source: connectionTarget === source ? shape : source,\n          target: connectionTarget === source ? source : shape,\n          hints: {\n            targetParent: target,\n            targetAttach: attach\n          }\n        });\n      }\n\n      return {\n        attach: attach,\n        connect: connect\n      };\n    }\n\n    // ignore wether or not elements can be created\n    if (create === null || attach === null) {\n      return null;\n    }\n\n    return false;\n  }\n\n  function setMarker(element, marker) {\n    [ MARKER_ATTACH, MARKER_OK, MARKER_NOT_OK, MARKER_NEW_PARENT ].forEach(function(m) {\n\n      if (m === marker) {\n        canvas.addMarker(element, m);\n      } else {\n        canvas.removeMarker(element, m);\n      }\n    });\n  }\n\n  // event handling //////////\n\n  eventBus.on([ 'create.move', 'create.hover' ], function(event) {\n    var context = event.context,\n        elements = context.elements,\n        hover = event.hover,\n        source = context.source,\n        hints = context.hints || {};\n\n    if (!hover) {\n      context.canExecute = false;\n      context.target = null;\n\n      return;\n    }\n\n    ensureConstraints(event);\n\n    var position = {\n      x: event.x,\n      y: event.y\n    };\n\n    var canExecute = context.canExecute = hover && canCreate(elements, hover, position, source, hints);\n\n    if (hover && canExecute !== null) {\n      context.target = hover;\n\n      if (canExecute && canExecute.attach) {\n        setMarker(hover, MARKER_ATTACH);\n      } else {\n        setMarker(hover, canExecute ? MARKER_NEW_PARENT : MARKER_NOT_OK);\n      }\n    }\n  });\n\n  eventBus.on([ 'create.end', 'create.out', 'create.cleanup' ], function(event) {\n    var hover = event.hover;\n\n    if (hover) {\n      setMarker(hover, null);\n    }\n  });\n\n  eventBus.on('create.end', function(event) {\n    var context = event.context,\n        source = context.source,\n        shape = context.shape,\n        elements = context.elements,\n        target = context.target,\n        canExecute = context.canExecute,\n        attach = canExecute && canExecute.attach,\n        connect = canExecute && canExecute.connect,\n        hints = context.hints || {};\n\n    if (canExecute === false || !target) {\n      return false;\n    }\n\n    ensureConstraints(event);\n\n    var position = {\n      x: event.x,\n      y: event.y\n    };\n\n    if (connect) {\n      shape = modeling.appendShape(source, shape, position, target, {\n        attach: attach,\n        connection: connect === true ? {} : connect,\n        connectionTarget: hints.connectionTarget\n      });\n    } else {\n      elements = modeling.createElements(elements, position, target, assign({}, hints, {\n        attach: attach\n      }));\n\n      // update shape\n      shape = find(elements, function(element) {\n        return !isConnection(element);\n      });\n    }\n\n    // update elements and shape\n    assign(context, {\n      elements: elements,\n      shape: shape\n    });\n\n    assign(event, {\n      elements: elements,\n      shape: shape\n    });\n  });\n\n  function cancel() {\n    var context = dragging.context();\n\n    if (context && context.prefix === PREFIX) {\n      dragging.cancel();\n    }\n  }\n\n  // cancel on <elements.changed> that is not result of <drag.end>\n  eventBus.on('create.init', function() {\n    eventBus.on('elements.changed', cancel);\n\n    eventBus.once([ 'create.cancel', 'create.end' ], HIGH_PRIORITY, function() {\n      eventBus.off('elements.changed', cancel);\n    });\n  });\n\n  // API //////////\n\n  /**\n   * @param event\n   * @param elements\n   * @param {any} [context={}]\n   */\n  this.start = function(event, elements, context) {\n    if (!isArray(elements)) {\n      elements = [ elements ];\n    }\n\n    var shape = find(elements, function(element) {\n      return !isConnection(element);\n    });\n\n    if (!shape) {\n\n      // at least one shape is required\n      return;\n    }\n\n    context = assign({\n      elements: elements,\n      hints: {},\n      shape: shape\n    }, context || {});\n\n    // make sure each element has x and y\n    forEach(elements, function(element) {\n      if (!isNumber(element.x)) {\n        element.x = 0;\n      }\n\n      if (!isNumber(element.y)) {\n        element.y = 0;\n      }\n    });\n\n    var visibleElements = filter(elements, function(element) {\n      return !element.hidden;\n    });\n\n    var bbox = getBBox(visibleElements);\n\n    // center elements around cursor\n    forEach(elements, function(element) {\n      if (isConnection(element)) {\n        element.waypoints = map(element.waypoints, function(waypoint) {\n          return {\n            x: waypoint.x - bbox.x - bbox.width / 2,\n            y: waypoint.y - bbox.y - bbox.height / 2\n          };\n        });\n      }\n\n      assign(element, {\n        x: element.x - bbox.x - bbox.width / 2,\n        y: element.y - bbox.y - bbox.height / 2\n      });\n    });\n\n    dragging.init(event, PREFIX, {\n      cursor: 'grabbing',\n      autoActivate: true,\n      data: {\n        shape: shape,\n        elements: elements,\n        context: context\n      }\n    });\n  };\n}\n\nCreate.$inject = [\n  'canvas',\n  'dragging',\n  'eventBus',\n  'modeling',\n  'rules'\n];\n\n// helpers //////////\n\nfunction ensureConstraints(event) {\n  var context = event.context,\n      createConstraints = context.createConstraints;\n\n  if (!createConstraints) {\n    return;\n  }\n\n  if (createConstraints.left) {\n    event.x = Math.max(event.x, createConstraints.left);\n  }\n\n  if (createConstraints.right) {\n    event.x = Math.min(event.x, createConstraints.right);\n  }\n\n  if (createConstraints.top) {\n    event.y = Math.max(event.y, createConstraints.top);\n  }\n\n  if (createConstraints.bottom) {\n    event.y = Math.min(event.y, createConstraints.bottom);\n  }\n}\n\nfunction isSingleShape(elements) {\n  return elements && elements.length === 1 && !isConnection(elements[ 0 ]);\n}"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}