{"ast":null,"code":"import inherits from 'inherits-browser';\nimport { getBBox as getBoundingBox } from '../../util/Elements';\nimport { asTRBL, asBounds } from '../../layout/LayoutUtil';\nimport { assign, flatten, find, forEach, groupBy, isArray, matchPattern, pick, values } from 'min-dash';\nimport CommandInterceptor from '../../command/CommandInterceptor';\n\n/**\n * @typedef {import('../../model/Types').Element} Element\n * @typedef {import('../../model/Types').Shape} Shape\n *\n * @typedef {import('../../util/Types').Direction} Direction\n * @typedef {import('../../util/Types').Rect} Rect\n * @typedef {import('../../util/Types').RectTRBL} RectTRBL\n *\n * @typedef {import('../../core/ElementRegistry').default} ElementRegistry\n * @typedef {import('../../core/EventBus').default} EventBus\n * @typedef {import('../modeling/Modeling').default} Modeling\n * @typedef {import('../rules/Rules').default} Rules\n */\n\n/**\n * An auto resize component that takes care of expanding a parent element\n * if child elements are created or moved close the parents edge.\n *\n * @param {EventBus} eventBus\n * @param {ElementRegistry} elementRegistry\n * @param {Modeling} modeling\n * @param {Rules} rules\n */\nexport default function AutoResize(eventBus, elementRegistry, modeling, rules) {\n  CommandInterceptor.call(this, eventBus);\n  this._elementRegistry = elementRegistry;\n  this._modeling = modeling;\n  this._rules = rules;\n  var self = this;\n  this.postExecuted(['shape.create'], function (event) {\n    var context = event.context,\n      hints = context.hints || {},\n      shape = context.shape,\n      parent = context.parent || context.newParent;\n    if (hints.autoResize === false) {\n      return;\n    }\n    self._expand([shape], parent);\n  });\n  this.postExecuted(['elements.move'], function (event) {\n    var context = event.context,\n      elements = flatten(values(context.closure.topLevel)),\n      hints = context.hints;\n    var autoResize = hints ? hints.autoResize : true;\n    if (autoResize === false) {\n      return;\n    }\n    var expandings = groupBy(elements, function (element) {\n      return element.parent.id;\n    });\n    forEach(expandings, function (elements, parentId) {\n      // optionally filter elements to be considered when resizing\n      if (isArray(autoResize)) {\n        elements = elements.filter(function (element) {\n          return find(autoResize, matchPattern({\n            id: element.id\n          }));\n        });\n      }\n      self._expand(elements, parentId);\n    });\n  });\n  this.postExecuted(['shape.toggleCollapse'], function (event) {\n    var context = event.context,\n      hints = context.hints,\n      shape = context.shape;\n    if (hints && hints.autoResize === false) {\n      return;\n    }\n    if (shape.collapsed) {\n      return;\n    }\n    self._expand(shape.children || [], shape);\n  });\n  this.postExecuted(['shape.resize'], function (event) {\n    var context = event.context,\n      hints = context.hints,\n      shape = context.shape,\n      parent = shape.parent;\n    if (hints && hints.autoResize === false) {\n      return;\n    }\n    if (parent) {\n      self._expand([shape], parent);\n    }\n  });\n}\nAutoResize.$inject = ['eventBus', 'elementRegistry', 'modeling', 'rules'];\ninherits(AutoResize, CommandInterceptor);\n\n/**\n * Calculate the new bounds of the target shape, given\n * a number of elements have been moved or added into the parent.\n *\n * This method considers the current size, the added elements as well as\n * the provided padding for the new bounds.\n *\n * @param {Shape[]} elements\n * @param {Shape} target\n */\nAutoResize.prototype._getOptimalBounds = function (elements, target) {\n  var offset = this.getOffset(target),\n    padding = this.getPadding(target);\n  var elementsTrbl = asTRBL(getBoundingBox(elements)),\n    targetTrbl = asTRBL(target);\n  var newTrbl = {};\n  if (elementsTrbl.top - targetTrbl.top < padding.top) {\n    newTrbl.top = elementsTrbl.top - offset.top;\n  }\n  if (elementsTrbl.left - targetTrbl.left < padding.left) {\n    newTrbl.left = elementsTrbl.left - offset.left;\n  }\n  if (targetTrbl.right - elementsTrbl.right < padding.right) {\n    newTrbl.right = elementsTrbl.right + offset.right;\n  }\n  if (targetTrbl.bottom - elementsTrbl.bottom < padding.bottom) {\n    newTrbl.bottom = elementsTrbl.bottom + offset.bottom;\n  }\n  return asBounds(assign({}, targetTrbl, newTrbl));\n};\n\n/**\n * Expand the target shape respecting rules, offset and padding\n *\n * @param {Shape[]} elements\n * @param {Shape|string} target The target or its ID.\n */\nAutoResize.prototype._expand = function (elements, target) {\n  if (typeof target === 'string') {\n    target = this._elementRegistry.get(target);\n  }\n  var allowed = this._rules.allowed('element.autoResize', {\n    elements: elements,\n    target: target\n  });\n  if (!allowed) {\n    return;\n  }\n\n  // calculate the new bounds\n  var newBounds = this._getOptimalBounds(elements, target);\n  if (!boundsChanged(newBounds, target)) {\n    return;\n  }\n  var resizeDirections = getResizeDirections(pick(target, ['x', 'y', 'width', 'height']), newBounds);\n\n  // resize the parent shape\n  this.resize(target, newBounds, {\n    autoResize: resizeDirections\n  });\n  var parent = target.parent;\n\n  // recursively expand parent elements\n  if (parent) {\n    this._expand([target], parent);\n  }\n};\n\n/**\n * Get the amount to expand the given shape in each direction.\n *\n * @param {Shape} shape\n *\n * @return {RectTRBL}\n */\nAutoResize.prototype.getOffset = function (shape) {\n  return {\n    top: 60,\n    bottom: 60,\n    left: 100,\n    right: 100\n  };\n};\n\n/**\n * Get the activation threshold for each side for which\n * resize triggers.\n *\n * @param {Shape} shape\n *\n * @return {RectTRBL}\n */\nAutoResize.prototype.getPadding = function (shape) {\n  return {\n    top: 2,\n    bottom: 2,\n    left: 15,\n    right: 15\n  };\n};\n\n/**\n * Perform the actual resize operation.\n *\n * @param {Shape} shape\n * @param {Rect} newBounds\n * @param {Object} [hints]\n * @param {string} [hints.autoResize]\n */\nAutoResize.prototype.resize = function (shape, newBounds, hints) {\n  this._modeling.resizeShape(shape, newBounds, null, hints);\n};\nfunction boundsChanged(newBounds, oldBounds) {\n  return newBounds.x !== oldBounds.x || newBounds.y !== oldBounds.y || newBounds.width !== oldBounds.width || newBounds.height !== oldBounds.height;\n}\n\n/**\n * Get directions of resize as {n|w|s|e} e.g. \"nw\".\n *\n * @param {Rect} oldBounds\n * @param {Rect} newBounds\n *\n * @return {Direction} Resize directions as {n|w|s|e}.\n */\nfunction getResizeDirections(oldBounds, newBounds) {\n  var directions = '';\n  oldBounds = asTRBL(oldBounds);\n  newBounds = asTRBL(newBounds);\n  if (oldBounds.top > newBounds.top) {\n    directions = directions.concat('n');\n  }\n  if (oldBounds.right < newBounds.right) {\n    directions = directions.concat('w');\n  }\n  if (oldBounds.bottom < newBounds.bottom) {\n    directions = directions.concat('s');\n  }\n  if (oldBounds.left > newBounds.left) {\n    directions = directions.concat('e');\n  }\n  return directions;\n}","map":{"version":3,"names":["inherits","getBBox","getBoundingBox","asTRBL","asBounds","assign","flatten","find","forEach","groupBy","isArray","matchPattern","pick","values","CommandInterceptor","AutoResize","eventBus","elementRegistry","modeling","rules","call","_elementRegistry","_modeling","_rules","self","postExecuted","event","context","hints","shape","parent","newParent","autoResize","_expand","elements","closure","topLevel","expandings","element","id","parentId","filter","collapsed","children","$inject","prototype","_getOptimalBounds","target","offset","getOffset","padding","getPadding","elementsTrbl","targetTrbl","newTrbl","top","left","right","bottom","get","allowed","newBounds","boundsChanged","resizeDirections","getResizeDirections","resize","resizeShape","oldBounds","x","y","width","height","directions","concat"],"sources":["/home/runner/work/sgex/sgex/node_modules/diagram-js/lib/features/auto-resize/AutoResize.js"],"sourcesContent":["import inherits from 'inherits-browser';\n\nimport { getBBox as getBoundingBox } from '../../util/Elements';\n\nimport {\n  asTRBL,\n  asBounds\n} from '../../layout/LayoutUtil';\n\nimport {\n  assign,\n  flatten,\n  find,\n  forEach,\n  groupBy,\n  isArray,\n  matchPattern,\n  pick,\n  values\n} from 'min-dash';\n\nimport CommandInterceptor from '../../command/CommandInterceptor';\n\n/**\n * @typedef {import('../../model/Types').Element} Element\n * @typedef {import('../../model/Types').Shape} Shape\n *\n * @typedef {import('../../util/Types').Direction} Direction\n * @typedef {import('../../util/Types').Rect} Rect\n * @typedef {import('../../util/Types').RectTRBL} RectTRBL\n *\n * @typedef {import('../../core/ElementRegistry').default} ElementRegistry\n * @typedef {import('../../core/EventBus').default} EventBus\n * @typedef {import('../modeling/Modeling').default} Modeling\n * @typedef {import('../rules/Rules').default} Rules\n */\n\n/**\n * An auto resize component that takes care of expanding a parent element\n * if child elements are created or moved close the parents edge.\n *\n * @param {EventBus} eventBus\n * @param {ElementRegistry} elementRegistry\n * @param {Modeling} modeling\n * @param {Rules} rules\n */\nexport default function AutoResize(eventBus, elementRegistry, modeling, rules) {\n\n  CommandInterceptor.call(this, eventBus);\n\n  this._elementRegistry = elementRegistry;\n  this._modeling = modeling;\n  this._rules = rules;\n\n  var self = this;\n\n  this.postExecuted([ 'shape.create' ], function(event) {\n    var context = event.context,\n        hints = context.hints || {},\n        shape = context.shape,\n        parent = context.parent || context.newParent;\n\n    if (hints.autoResize === false) {\n      return;\n    }\n\n    self._expand([ shape ], parent);\n  });\n\n  this.postExecuted([ 'elements.move' ], function(event) {\n    var context = event.context,\n        elements = flatten(values(context.closure.topLevel)),\n        hints = context.hints;\n\n    var autoResize = hints ? hints.autoResize : true;\n\n    if (autoResize === false) {\n      return;\n    }\n\n    var expandings = groupBy(elements, function(element) {\n      return element.parent.id;\n    });\n\n    forEach(expandings, function(elements, parentId) {\n\n      // optionally filter elements to be considered when resizing\n      if (isArray(autoResize)) {\n        elements = elements.filter(function(element) {\n          return find(autoResize, matchPattern({ id: element.id }));\n        });\n      }\n\n      self._expand(elements, parentId);\n    });\n  });\n\n  this.postExecuted([ 'shape.toggleCollapse' ], function(event) {\n    var context = event.context,\n        hints = context.hints,\n        shape = context.shape;\n\n    if (hints && hints.autoResize === false) {\n      return;\n    }\n\n    if (shape.collapsed) {\n      return;\n    }\n\n    self._expand(shape.children || [], shape);\n  });\n\n  this.postExecuted([ 'shape.resize' ], function(event) {\n    var context = event.context,\n        hints = context.hints,\n        shape = context.shape,\n        parent = shape.parent;\n\n    if (hints && hints.autoResize === false) {\n      return;\n    }\n\n    if (parent) {\n      self._expand([ shape ], parent);\n    }\n  });\n\n}\n\nAutoResize.$inject = [\n  'eventBus',\n  'elementRegistry',\n  'modeling',\n  'rules'\n];\n\ninherits(AutoResize, CommandInterceptor);\n\n\n/**\n * Calculate the new bounds of the target shape, given\n * a number of elements have been moved or added into the parent.\n *\n * This method considers the current size, the added elements as well as\n * the provided padding for the new bounds.\n *\n * @param {Shape[]} elements\n * @param {Shape} target\n */\nAutoResize.prototype._getOptimalBounds = function(elements, target) {\n\n  var offset = this.getOffset(target),\n      padding = this.getPadding(target);\n\n  var elementsTrbl = asTRBL(getBoundingBox(elements)),\n      targetTrbl = asTRBL(target);\n\n  var newTrbl = {};\n\n  if (elementsTrbl.top - targetTrbl.top < padding.top) {\n    newTrbl.top = elementsTrbl.top - offset.top;\n  }\n\n  if (elementsTrbl.left - targetTrbl.left < padding.left) {\n    newTrbl.left = elementsTrbl.left - offset.left;\n  }\n\n  if (targetTrbl.right - elementsTrbl.right < padding.right) {\n    newTrbl.right = elementsTrbl.right + offset.right;\n  }\n\n  if (targetTrbl.bottom - elementsTrbl.bottom < padding.bottom) {\n    newTrbl.bottom = elementsTrbl.bottom + offset.bottom;\n  }\n\n  return asBounds(assign({}, targetTrbl, newTrbl));\n};\n\n\n/**\n * Expand the target shape respecting rules, offset and padding\n *\n * @param {Shape[]} elements\n * @param {Shape|string} target The target or its ID.\n */\nAutoResize.prototype._expand = function(elements, target) {\n\n  if (typeof target === 'string') {\n    target = this._elementRegistry.get(target);\n  }\n\n  var allowed = this._rules.allowed('element.autoResize', {\n    elements: elements,\n    target: target\n  });\n\n  if (!allowed) {\n    return;\n  }\n\n  // calculate the new bounds\n  var newBounds = this._getOptimalBounds(elements, target);\n\n  if (!boundsChanged(newBounds, target)) {\n    return;\n  }\n\n  var resizeDirections = getResizeDirections(pick(target, [ 'x', 'y', 'width', 'height' ]), newBounds);\n\n  // resize the parent shape\n  this.resize(target, newBounds, {\n    autoResize: resizeDirections\n  });\n\n  var parent = target.parent;\n\n  // recursively expand parent elements\n  if (parent) {\n    this._expand([ target ], parent);\n  }\n};\n\n\n/**\n * Get the amount to expand the given shape in each direction.\n *\n * @param {Shape} shape\n *\n * @return {RectTRBL}\n */\nAutoResize.prototype.getOffset = function(shape) {\n  return { top: 60, bottom: 60, left: 100, right: 100 };\n};\n\n\n/**\n * Get the activation threshold for each side for which\n * resize triggers.\n *\n * @param {Shape} shape\n *\n * @return {RectTRBL}\n */\nAutoResize.prototype.getPadding = function(shape) {\n  return { top: 2, bottom: 2, left: 15, right: 15 };\n};\n\n\n/**\n * Perform the actual resize operation.\n *\n * @param {Shape} shape\n * @param {Rect} newBounds\n * @param {Object} [hints]\n * @param {string} [hints.autoResize]\n */\nAutoResize.prototype.resize = function(shape, newBounds, hints) {\n  this._modeling.resizeShape(shape, newBounds, null, hints);\n};\n\n\nfunction boundsChanged(newBounds, oldBounds) {\n  return (\n    newBounds.x !== oldBounds.x ||\n    newBounds.y !== oldBounds.y ||\n    newBounds.width !== oldBounds.width ||\n    newBounds.height !== oldBounds.height\n  );\n}\n\n/**\n * Get directions of resize as {n|w|s|e} e.g. \"nw\".\n *\n * @param {Rect} oldBounds\n * @param {Rect} newBounds\n *\n * @return {Direction} Resize directions as {n|w|s|e}.\n */\nfunction getResizeDirections(oldBounds, newBounds) {\n  var directions = '';\n\n  oldBounds = asTRBL(oldBounds);\n  newBounds = asTRBL(newBounds);\n\n  if (oldBounds.top > newBounds.top) {\n    directions = directions.concat('n');\n  }\n\n  if (oldBounds.right < newBounds.right) {\n    directions = directions.concat('w');\n  }\n\n  if (oldBounds.bottom < newBounds.bottom) {\n    directions = directions.concat('s');\n  }\n\n  if (oldBounds.left > newBounds.left) {\n    directions = directions.concat('e');\n  }\n\n  return directions;\n}"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}