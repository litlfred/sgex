{"ast":null,"code":"import { assign, forEach } from 'min-dash';\n\n/**\n * @typedef {import('../../model/Types').Shape} Shape\n *\n * @typedef {import('../Modeling').default} Modeling\n */\n\n/**\n * A handler that toggles the collapsed state of an element\n * and the visibility of all its children.\n *\n * @param {Modeling} modeling\n */\nexport default function ToggleShapeCollapseHandler(modeling) {\n  this._modeling = modeling;\n}\nToggleShapeCollapseHandler.$inject = ['modeling'];\nToggleShapeCollapseHandler.prototype.execute = function (context) {\n  var shape = context.shape,\n    children = shape.children;\n\n  // recursively remember previous visibility of children\n  context.oldChildrenVisibility = getElementsVisibilityRecursive(children);\n\n  // toggle state\n  shape.collapsed = !shape.collapsed;\n\n  // recursively hide/show children\n  var result = setHiddenRecursive(children, shape.collapsed);\n  return [shape].concat(result);\n};\nToggleShapeCollapseHandler.prototype.revert = function (context) {\n  var shape = context.shape,\n    oldChildrenVisibility = context.oldChildrenVisibility;\n  var children = shape.children;\n\n  // recursively set old visability of children\n  var result = restoreVisibilityRecursive(children, oldChildrenVisibility);\n\n  // retoggle state\n  shape.collapsed = !shape.collapsed;\n  return [shape].concat(result);\n};\n\n// helpers //////////////////////\n\n/**\n * Return a map { elementId -> hiddenState}.\n *\n * @param {Shape[]} elements\n *\n * @return {Object}\n */\nfunction getElementsVisibilityRecursive(elements) {\n  var result = {};\n  forEach(elements, function (element) {\n    result[element.id] = element.hidden;\n    if (element.children) {\n      result = assign({}, result, getElementsVisibilityRecursive(element.children));\n    }\n  });\n  return result;\n}\nfunction setHiddenRecursive(elements, newHidden) {\n  var result = [];\n  forEach(elements, function (element) {\n    element.hidden = newHidden;\n    result = result.concat(element);\n    if (element.children) {\n      result = result.concat(setHiddenRecursive(element.children, element.collapsed || newHidden));\n    }\n  });\n  return result;\n}\nfunction restoreVisibilityRecursive(elements, lastState) {\n  var result = [];\n  forEach(elements, function (element) {\n    element.hidden = lastState[element.id];\n    result = result.concat(element);\n    if (element.children) {\n      result = result.concat(restoreVisibilityRecursive(element.children, lastState));\n    }\n  });\n  return result;\n}","map":{"version":3,"names":["assign","forEach","ToggleShapeCollapseHandler","modeling","_modeling","$inject","prototype","execute","context","shape","children","oldChildrenVisibility","getElementsVisibilityRecursive","collapsed","result","setHiddenRecursive","concat","revert","restoreVisibilityRecursive","elements","element","id","hidden","newHidden","lastState"],"sources":["/home/runner/work/sgex/sgex/node_modules/diagram-js/lib/features/modeling/cmd/ToggleShapeCollapseHandler.js"],"sourcesContent":["import {\n  assign,\n  forEach\n} from 'min-dash';\n\n/**\n * @typedef {import('../../model/Types').Shape} Shape\n *\n * @typedef {import('../Modeling').default} Modeling\n */\n\n/**\n * A handler that toggles the collapsed state of an element\n * and the visibility of all its children.\n *\n * @param {Modeling} modeling\n */\nexport default function ToggleShapeCollapseHandler(modeling) {\n  this._modeling = modeling;\n}\n\nToggleShapeCollapseHandler.$inject = [ 'modeling' ];\n\n\nToggleShapeCollapseHandler.prototype.execute = function(context) {\n\n  var shape = context.shape,\n      children = shape.children;\n\n  // recursively remember previous visibility of children\n  context.oldChildrenVisibility = getElementsVisibilityRecursive(children);\n\n  // toggle state\n  shape.collapsed = !shape.collapsed;\n\n  // recursively hide/show children\n  var result = setHiddenRecursive(children, shape.collapsed);\n\n  return [ shape ].concat(result);\n};\n\n\nToggleShapeCollapseHandler.prototype.revert = function(context) {\n\n  var shape = context.shape,\n      oldChildrenVisibility = context.oldChildrenVisibility;\n\n  var children = shape.children;\n\n  // recursively set old visability of children\n  var result = restoreVisibilityRecursive(children, oldChildrenVisibility);\n\n  // retoggle state\n  shape.collapsed = !shape.collapsed;\n\n  return [ shape ].concat(result);\n};\n\n\n// helpers //////////////////////\n\n/**\n * Return a map { elementId -> hiddenState}.\n *\n * @param {Shape[]} elements\n *\n * @return {Object}\n */\nfunction getElementsVisibilityRecursive(elements) {\n\n  var result = {};\n\n  forEach(elements, function(element) {\n    result[element.id] = element.hidden;\n\n    if (element.children) {\n      result = assign({}, result, getElementsVisibilityRecursive(element.children));\n    }\n  });\n\n  return result;\n}\n\n\nfunction setHiddenRecursive(elements, newHidden) {\n  var result = [];\n  forEach(elements, function(element) {\n    element.hidden = newHidden;\n\n    result = result.concat(element);\n\n    if (element.children) {\n      result = result.concat(setHiddenRecursive(element.children, element.collapsed || newHidden));\n    }\n  });\n\n  return result;\n}\n\nfunction restoreVisibilityRecursive(elements, lastState) {\n  var result = [];\n  forEach(elements, function(element) {\n    element.hidden = lastState[element.id];\n\n    result = result.concat(element);\n\n    if (element.children) {\n      result = result.concat(restoreVisibilityRecursive(element.children, lastState));\n    }\n  });\n\n  return result;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}