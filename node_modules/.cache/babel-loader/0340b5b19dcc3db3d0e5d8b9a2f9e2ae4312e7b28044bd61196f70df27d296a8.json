{"ast":null,"code":"import inherits from 'inherits-browser';\nimport CommandInterceptor from 'diagram-js/lib/command/CommandInterceptor';\nimport { add as collectionAdd, remove as collectionRemove } from 'diagram-js/lib/util/Collections';\nimport { find } from 'min-dash';\nimport { is } from '../../../util/ModelUtil';\n\n/**\n * @typedef {import('diagram-js/lib/core/EventBus').default} EventBus\n * @typedef {import('../BpmnFactory').default} BpmnFactory\n */\n\nvar TARGET_REF_PLACEHOLDER_NAME = '__targetRef_placeholder';\n\n/**\n * This behavior makes sure we always set a fake\n * DataInputAssociation#targetRef as demanded by the BPMN 2.0\n * XSD schema.\n *\n * The reference is set to a bpmn:Property{ name: '__targetRef_placeholder' }\n * which is created on the fly and cleaned up afterwards if not needed\n * anymore.\n *\n * @param {EventBus} eventBus\n * @param {BpmnFactory} bpmnFactory\n */\nexport default function DataInputAssociationBehavior(eventBus, bpmnFactory) {\n  CommandInterceptor.call(this, eventBus);\n  this.executed(['connection.create', 'connection.delete', 'connection.move', 'connection.reconnect'], ifDataInputAssociation(fixTargetRef));\n  this.reverted(['connection.create', 'connection.delete', 'connection.move', 'connection.reconnect'], ifDataInputAssociation(fixTargetRef));\n  function usesTargetRef(element, targetRef, removedConnection) {\n    var inputAssociations = element.get('dataInputAssociations');\n    return find(inputAssociations, function (association) {\n      return association !== removedConnection && association.targetRef === targetRef;\n    });\n  }\n  function getTargetRef(element, create) {\n    var properties = element.get('properties');\n    var targetRefProp = find(properties, function (p) {\n      return p.name === TARGET_REF_PLACEHOLDER_NAME;\n    });\n    if (!targetRefProp && create) {\n      targetRefProp = bpmnFactory.create('bpmn:Property', {\n        name: TARGET_REF_PLACEHOLDER_NAME\n      });\n      collectionAdd(properties, targetRefProp);\n    }\n    return targetRefProp;\n  }\n  function cleanupTargetRef(element, connection) {\n    var targetRefProp = getTargetRef(element);\n    if (!targetRefProp) {\n      return;\n    }\n    if (!usesTargetRef(element, targetRefProp, connection)) {\n      collectionRemove(element.get('properties'), targetRefProp);\n    }\n  }\n\n  /**\n   * Make sure targetRef is set to a valid property or\n   * `null` if the connection is detached.\n   *\n   * @param {Event} event\n   */\n  function fixTargetRef(event) {\n    var context = event.context,\n      connection = context.connection,\n      connectionBo = connection.businessObject,\n      target = connection.target,\n      targetBo = target && target.businessObject,\n      newTarget = context.newTarget,\n      newTargetBo = newTarget && newTarget.businessObject,\n      oldTarget = context.oldTarget || context.target,\n      oldTargetBo = oldTarget && oldTarget.businessObject;\n    var dataAssociation = connection.businessObject,\n      targetRefProp;\n    if (oldTargetBo && oldTargetBo !== targetBo) {\n      cleanupTargetRef(oldTargetBo, connectionBo);\n    }\n    if (newTargetBo && newTargetBo !== targetBo) {\n      cleanupTargetRef(newTargetBo, connectionBo);\n    }\n    if (targetBo) {\n      targetRefProp = getTargetRef(targetBo, true);\n      dataAssociation.targetRef = targetRefProp;\n    } else {\n      dataAssociation.targetRef = null;\n    }\n  }\n}\nDataInputAssociationBehavior.$inject = ['eventBus', 'bpmnFactory'];\ninherits(DataInputAssociationBehavior, CommandInterceptor);\n\n/**\n * Only call the given function when the event\n * changes a bpmn:DataInputAssociation.\n *\n * @param {Function} fn\n * @return {Function}\n */\nfunction ifDataInputAssociation(fn) {\n  return function (event) {\n    var context = event.context,\n      connection = context.connection;\n    if (is(connection, 'bpmn:DataInputAssociation')) {\n      return fn(event);\n    }\n  };\n}","map":{"version":3,"names":["inherits","CommandInterceptor","add","collectionAdd","remove","collectionRemove","find","is","TARGET_REF_PLACEHOLDER_NAME","DataInputAssociationBehavior","eventBus","bpmnFactory","call","executed","ifDataInputAssociation","fixTargetRef","reverted","usesTargetRef","element","targetRef","removedConnection","inputAssociations","get","association","getTargetRef","create","properties","targetRefProp","p","name","cleanupTargetRef","connection","event","context","connectionBo","businessObject","target","targetBo","newTarget","newTargetBo","oldTarget","oldTargetBo","dataAssociation","$inject","fn"],"sources":["/home/runner/work/sgex/sgex/node_modules/bpmn-js/lib/features/modeling/behavior/DataInputAssociationBehavior.js"],"sourcesContent":["import inherits from 'inherits-browser';\n\nimport CommandInterceptor from 'diagram-js/lib/command/CommandInterceptor';\n\nimport {\n  add as collectionAdd,\n  remove as collectionRemove\n} from 'diagram-js/lib/util/Collections';\n\nimport {\n  find\n} from 'min-dash';\n\nimport {\n  is\n} from '../../../util/ModelUtil';\n\n/**\n * @typedef {import('diagram-js/lib/core/EventBus').default} EventBus\n * @typedef {import('../BpmnFactory').default} BpmnFactory\n */\n\nvar TARGET_REF_PLACEHOLDER_NAME = '__targetRef_placeholder';\n\n\n/**\n * This behavior makes sure we always set a fake\n * DataInputAssociation#targetRef as demanded by the BPMN 2.0\n * XSD schema.\n *\n * The reference is set to a bpmn:Property{ name: '__targetRef_placeholder' }\n * which is created on the fly and cleaned up afterwards if not needed\n * anymore.\n *\n * @param {EventBus} eventBus\n * @param {BpmnFactory} bpmnFactory\n */\nexport default function DataInputAssociationBehavior(eventBus, bpmnFactory) {\n\n  CommandInterceptor.call(this, eventBus);\n\n\n  this.executed([\n    'connection.create',\n    'connection.delete',\n    'connection.move',\n    'connection.reconnect'\n  ], ifDataInputAssociation(fixTargetRef));\n\n  this.reverted([\n    'connection.create',\n    'connection.delete',\n    'connection.move',\n    'connection.reconnect'\n  ], ifDataInputAssociation(fixTargetRef));\n\n\n  function usesTargetRef(element, targetRef, removedConnection) {\n\n    var inputAssociations = element.get('dataInputAssociations');\n\n    return find(inputAssociations, function(association) {\n      return association !== removedConnection &&\n             association.targetRef === targetRef;\n    });\n  }\n\n  function getTargetRef(element, create) {\n\n    var properties = element.get('properties');\n\n    var targetRefProp = find(properties, function(p) {\n      return p.name === TARGET_REF_PLACEHOLDER_NAME;\n    });\n\n    if (!targetRefProp && create) {\n      targetRefProp = bpmnFactory.create('bpmn:Property', {\n        name: TARGET_REF_PLACEHOLDER_NAME\n      });\n\n      collectionAdd(properties, targetRefProp);\n    }\n\n    return targetRefProp;\n  }\n\n  function cleanupTargetRef(element, connection) {\n\n    var targetRefProp = getTargetRef(element);\n\n    if (!targetRefProp) {\n      return;\n    }\n\n    if (!usesTargetRef(element, targetRefProp, connection)) {\n      collectionRemove(element.get('properties'), targetRefProp);\n    }\n  }\n\n  /**\n   * Make sure targetRef is set to a valid property or\n   * `null` if the connection is detached.\n   *\n   * @param {Event} event\n   */\n  function fixTargetRef(event) {\n\n    var context = event.context,\n        connection = context.connection,\n        connectionBo = connection.businessObject,\n        target = connection.target,\n        targetBo = target && target.businessObject,\n        newTarget = context.newTarget,\n        newTargetBo = newTarget && newTarget.businessObject,\n        oldTarget = context.oldTarget || context.target,\n        oldTargetBo = oldTarget && oldTarget.businessObject;\n\n    var dataAssociation = connection.businessObject,\n        targetRefProp;\n\n    if (oldTargetBo && oldTargetBo !== targetBo) {\n      cleanupTargetRef(oldTargetBo, connectionBo);\n    }\n\n    if (newTargetBo && newTargetBo !== targetBo) {\n      cleanupTargetRef(newTargetBo, connectionBo);\n    }\n\n    if (targetBo) {\n      targetRefProp = getTargetRef(targetBo, true);\n      dataAssociation.targetRef = targetRefProp;\n    } else {\n      dataAssociation.targetRef = null;\n    }\n  }\n}\n\nDataInputAssociationBehavior.$inject = [\n  'eventBus',\n  'bpmnFactory'\n];\n\ninherits(DataInputAssociationBehavior, CommandInterceptor);\n\n\n/**\n * Only call the given function when the event\n * changes a bpmn:DataInputAssociation.\n *\n * @param {Function} fn\n * @return {Function}\n */\nfunction ifDataInputAssociation(fn) {\n\n  return function(event) {\n    var context = event.context,\n        connection = context.connection;\n\n    if (is(connection, 'bpmn:DataInputAssociation')) {\n      return fn(event);\n    }\n  };\n}"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}