{"ast":null,"code":"import { filterRedundantWaypoints } from '../../layout/LayoutUtil';\n\n/**\n * @typedef {import('didi').Injector} Injector\n *\n * @typedef {import('../../core/Canvas').default} Canvas\n * @typedef {import('../dragging/Dragging').default} Dragging\n * @typedef {import('../../core/EventBus').default} EventBus\n * @typedef {import('../modeling/Modeling').default} Modeling\n * @typedef {import('../rules/Rules').default} Rules\n */\n\nvar round = Math.round;\nvar RECONNECT_START = 'reconnectStart',\n  RECONNECT_END = 'reconnectEnd',\n  UPDATE_WAYPOINTS = 'updateWaypoints';\n\n/**\n * Move bendpoints through drag and drop to add/remove bendpoints or reconnect connection.\n *\n * @param {Injector} injector\n * @param {EventBus} eventBus\n * @param {Canvas} canvas\n * @param {Dragging} dragging\n * @param {Rules} rules\n * @param {Modeling} modeling\n */\nexport default function BendpointMove(injector, eventBus, canvas, dragging, rules, modeling) {\n  this._injector = injector;\n  this.start = function (event, connection, bendpointIndex, insert) {\n    var gfx = canvas.getGraphics(connection),\n      source = connection.source,\n      target = connection.target,\n      waypoints = connection.waypoints,\n      type;\n    if (!insert && bendpointIndex === 0) {\n      type = RECONNECT_START;\n    } else if (!insert && bendpointIndex === waypoints.length - 1) {\n      type = RECONNECT_END;\n    } else {\n      type = UPDATE_WAYPOINTS;\n    }\n    var command = type === UPDATE_WAYPOINTS ? 'connection.updateWaypoints' : 'connection.reconnect';\n    var allowed = rules.allowed(command, {\n      connection: connection,\n      source: source,\n      target: target\n    });\n    if (allowed === false) {\n      allowed = rules.allowed(command, {\n        connection: connection,\n        source: target,\n        target: source\n      });\n    }\n    if (allowed === false) {\n      return;\n    }\n    dragging.init(event, 'bendpoint.move', {\n      data: {\n        connection: connection,\n        connectionGfx: gfx,\n        context: {\n          allowed: allowed,\n          bendpointIndex: bendpointIndex,\n          connection: connection,\n          source: source,\n          target: target,\n          insert: insert,\n          type: type\n        }\n      }\n    });\n  };\n  eventBus.on('bendpoint.move.hover', function (event) {\n    var context = event.context,\n      connection = context.connection,\n      source = connection.source,\n      target = connection.target,\n      hover = event.hover,\n      type = context.type;\n\n    // cache hover state\n    context.hover = hover;\n    var allowed;\n    if (!hover) {\n      return;\n    }\n    var command = type === UPDATE_WAYPOINTS ? 'connection.updateWaypoints' : 'connection.reconnect';\n    allowed = context.allowed = rules.allowed(command, {\n      connection: connection,\n      source: type === RECONNECT_START ? hover : source,\n      target: type === RECONNECT_END ? hover : target\n    });\n    if (allowed) {\n      context.source = type === RECONNECT_START ? hover : source;\n      context.target = type === RECONNECT_END ? hover : target;\n      return;\n    }\n    if (allowed === false) {\n      allowed = context.allowed = rules.allowed(command, {\n        connection: connection,\n        source: type === RECONNECT_END ? hover : target,\n        target: type === RECONNECT_START ? hover : source\n      });\n    }\n    if (allowed) {\n      context.source = type === RECONNECT_END ? hover : target;\n      context.target = type === RECONNECT_START ? hover : source;\n    }\n  });\n  eventBus.on(['bendpoint.move.out', 'bendpoint.move.cleanup'], function (event) {\n    var context = event.context,\n      type = context.type;\n    context.hover = null;\n    context.source = null;\n    context.target = null;\n    if (type !== UPDATE_WAYPOINTS) {\n      context.allowed = false;\n    }\n  });\n  eventBus.on('bendpoint.move.end', function (event) {\n    var context = event.context,\n      allowed = context.allowed,\n      bendpointIndex = context.bendpointIndex,\n      connection = context.connection,\n      insert = context.insert,\n      newWaypoints = connection.waypoints.slice(),\n      source = context.source,\n      target = context.target,\n      type = context.type,\n      hints = context.hints || {};\n\n    // ensure integer values (important if zoom level was > 1 during move)\n    var docking = {\n      x: round(event.x),\n      y: round(event.y)\n    };\n    if (!allowed) {\n      return false;\n    }\n    if (type === UPDATE_WAYPOINTS) {\n      if (insert) {\n        // insert new bendpoint\n        newWaypoints.splice(bendpointIndex, 0, docking);\n      } else {\n        // swap previous waypoint with moved one\n        newWaypoints[bendpointIndex] = docking;\n      }\n\n      // pass hints about actual moved bendpoint\n      // useful for connection/label layout\n      hints.bendpointMove = {\n        insert: insert,\n        bendpointIndex: bendpointIndex\n      };\n      newWaypoints = this.cropWaypoints(connection, newWaypoints);\n      modeling.updateWaypoints(connection, filterRedundantWaypoints(newWaypoints), hints);\n    } else {\n      if (type === RECONNECT_START) {\n        hints.docking = 'source';\n        if (isReverse(context)) {\n          hints.docking = 'target';\n          hints.newWaypoints = newWaypoints.reverse();\n        }\n      } else if (type === RECONNECT_END) {\n        hints.docking = 'target';\n        if (isReverse(context)) {\n          hints.docking = 'source';\n          hints.newWaypoints = newWaypoints.reverse();\n        }\n      }\n      modeling.reconnect(connection, source, target, docking, hints);\n    }\n  }, this);\n}\nBendpointMove.$inject = ['injector', 'eventBus', 'canvas', 'dragging', 'rules', 'modeling'];\nBendpointMove.prototype.cropWaypoints = function (connection, newWaypoints) {\n  var connectionDocking = this._injector.get('connectionDocking', false);\n  if (!connectionDocking) {\n    return newWaypoints;\n  }\n  var waypoints = connection.waypoints;\n  connection.waypoints = newWaypoints;\n  connection.waypoints = connectionDocking.getCroppedWaypoints(connection);\n  newWaypoints = connection.waypoints;\n  connection.waypoints = waypoints;\n  return newWaypoints;\n};\n\n// helpers //////////\n\nexport function isReverse(context) {\n  var hover = context.hover,\n    source = context.source,\n    target = context.target,\n    type = context.type;\n  if (type === RECONNECT_START) {\n    return hover && target && hover === target && source !== target;\n  }\n  if (type === RECONNECT_END) {\n    return hover && source && hover === source && source !== target;\n  }\n}","map":{"version":3,"names":["filterRedundantWaypoints","round","Math","RECONNECT_START","RECONNECT_END","UPDATE_WAYPOINTS","BendpointMove","injector","eventBus","canvas","dragging","rules","modeling","_injector","start","event","connection","bendpointIndex","insert","gfx","getGraphics","source","target","waypoints","type","length","command","allowed","init","data","connectionGfx","context","on","hover","newWaypoints","slice","hints","docking","x","y","splice","bendpointMove","cropWaypoints","updateWaypoints","isReverse","reverse","reconnect","$inject","prototype","connectionDocking","get","getCroppedWaypoints"],"sources":["/home/runner/work/sgex/sgex/node_modules/diagram-js/lib/features/bendpoints/BendpointMove.js"],"sourcesContent":["import { filterRedundantWaypoints } from '../../layout/LayoutUtil';\n\n/**\n * @typedef {import('didi').Injector} Injector\n *\n * @typedef {import('../../core/Canvas').default} Canvas\n * @typedef {import('../dragging/Dragging').default} Dragging\n * @typedef {import('../../core/EventBus').default} EventBus\n * @typedef {import('../modeling/Modeling').default} Modeling\n * @typedef {import('../rules/Rules').default} Rules\n */\n\nvar round = Math.round;\n\nvar RECONNECT_START = 'reconnectStart',\n    RECONNECT_END = 'reconnectEnd',\n    UPDATE_WAYPOINTS = 'updateWaypoints';\n\n\n/**\n * Move bendpoints through drag and drop to add/remove bendpoints or reconnect connection.\n *\n * @param {Injector} injector\n * @param {EventBus} eventBus\n * @param {Canvas} canvas\n * @param {Dragging} dragging\n * @param {Rules} rules\n * @param {Modeling} modeling\n */\nexport default function BendpointMove(injector, eventBus, canvas, dragging, rules, modeling) {\n  this._injector = injector;\n\n  this.start = function(event, connection, bendpointIndex, insert) {\n    var gfx = canvas.getGraphics(connection),\n        source = connection.source,\n        target = connection.target,\n        waypoints = connection.waypoints,\n        type;\n\n    if (!insert && bendpointIndex === 0) {\n      type = RECONNECT_START;\n    } else if (!insert && bendpointIndex === waypoints.length - 1) {\n      type = RECONNECT_END;\n    } else {\n      type = UPDATE_WAYPOINTS;\n    }\n\n    var command = type === UPDATE_WAYPOINTS ? 'connection.updateWaypoints' : 'connection.reconnect';\n\n    var allowed = rules.allowed(command, {\n      connection: connection,\n      source: source,\n      target: target\n    });\n\n    if (allowed === false) {\n      allowed = rules.allowed(command, {\n        connection: connection,\n        source: target,\n        target: source\n      });\n    }\n\n    if (allowed === false) {\n      return;\n    }\n\n    dragging.init(event, 'bendpoint.move', {\n      data: {\n        connection: connection,\n        connectionGfx: gfx,\n        context: {\n          allowed: allowed,\n          bendpointIndex: bendpointIndex,\n          connection: connection,\n          source: source,\n          target: target,\n          insert: insert,\n          type: type\n        }\n      }\n    });\n  };\n\n  eventBus.on('bendpoint.move.hover', function(event) {\n    var context = event.context,\n        connection = context.connection,\n        source = connection.source,\n        target = connection.target,\n        hover = event.hover,\n        type = context.type;\n\n    // cache hover state\n    context.hover = hover;\n\n    var allowed;\n\n    if (!hover) {\n      return;\n    }\n\n    var command = type === UPDATE_WAYPOINTS ? 'connection.updateWaypoints' : 'connection.reconnect';\n\n    allowed = context.allowed = rules.allowed(command, {\n      connection: connection,\n      source: type === RECONNECT_START ? hover : source,\n      target: type === RECONNECT_END ? hover : target\n    });\n\n    if (allowed) {\n      context.source = type === RECONNECT_START ? hover : source;\n      context.target = type === RECONNECT_END ? hover : target;\n\n      return;\n    }\n\n    if (allowed === false) {\n      allowed = context.allowed = rules.allowed(command, {\n        connection: connection,\n        source: type === RECONNECT_END ? hover : target,\n        target: type === RECONNECT_START ? hover : source\n      });\n    }\n\n    if (allowed) {\n      context.source = type === RECONNECT_END ? hover : target;\n      context.target = type === RECONNECT_START ? hover : source;\n    }\n  });\n\n  eventBus.on([ 'bendpoint.move.out', 'bendpoint.move.cleanup' ], function(event) {\n    var context = event.context,\n        type = context.type;\n\n    context.hover = null;\n    context.source = null;\n    context.target = null;\n\n    if (type !== UPDATE_WAYPOINTS) {\n      context.allowed = false;\n    }\n  });\n\n  eventBus.on('bendpoint.move.end', function(event) {\n    var context = event.context,\n        allowed = context.allowed,\n        bendpointIndex = context.bendpointIndex,\n        connection = context.connection,\n        insert = context.insert,\n        newWaypoints = connection.waypoints.slice(),\n        source = context.source,\n        target = context.target,\n        type = context.type,\n        hints = context.hints || {};\n\n    // ensure integer values (important if zoom level was > 1 during move)\n    var docking = {\n      x: round(event.x),\n      y: round(event.y)\n    };\n\n    if (!allowed) {\n      return false;\n    }\n\n    if (type === UPDATE_WAYPOINTS) {\n      if (insert) {\n\n        // insert new bendpoint\n        newWaypoints.splice(bendpointIndex, 0, docking);\n      } else {\n\n        // swap previous waypoint with moved one\n        newWaypoints[bendpointIndex] = docking;\n      }\n\n      // pass hints about actual moved bendpoint\n      // useful for connection/label layout\n      hints.bendpointMove = {\n        insert: insert,\n        bendpointIndex: bendpointIndex\n      };\n\n      newWaypoints = this.cropWaypoints(connection, newWaypoints);\n\n      modeling.updateWaypoints(connection, filterRedundantWaypoints(newWaypoints), hints);\n    } else {\n      if (type === RECONNECT_START) {\n        hints.docking = 'source';\n\n        if (isReverse(context)) {\n          hints.docking = 'target';\n\n          hints.newWaypoints = newWaypoints.reverse();\n        }\n      } else if (type === RECONNECT_END) {\n        hints.docking = 'target';\n\n        if (isReverse(context)) {\n          hints.docking = 'source';\n\n          hints.newWaypoints = newWaypoints.reverse();\n        }\n      }\n\n      modeling.reconnect(connection, source, target, docking, hints);\n    }\n  }, this);\n}\n\nBendpointMove.$inject = [\n  'injector',\n  'eventBus',\n  'canvas',\n  'dragging',\n  'rules',\n  'modeling'\n];\n\nBendpointMove.prototype.cropWaypoints = function(connection, newWaypoints) {\n  var connectionDocking = this._injector.get('connectionDocking', false);\n\n  if (!connectionDocking) {\n    return newWaypoints;\n  }\n\n  var waypoints = connection.waypoints;\n\n  connection.waypoints = newWaypoints;\n\n  connection.waypoints = connectionDocking.getCroppedWaypoints(connection);\n\n  newWaypoints = connection.waypoints;\n\n  connection.waypoints = waypoints;\n\n  return newWaypoints;\n};\n\n\n// helpers //////////\n\nexport function isReverse(context) {\n  var hover = context.hover,\n      source = context.source,\n      target = context.target,\n      type = context.type;\n\n  if (type === RECONNECT_START) {\n    return hover && target && hover === target && source !== target;\n  }\n\n  if (type === RECONNECT_END) {\n    return hover && source && hover === source && source !== target;\n  }\n}"],"mappings":"AAAA,SAASA,wBAAwB,QAAQ,yBAAyB;;AAElE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,IAAIC,KAAK,GAAGC,IAAI,CAACD,KAAK;AAEtB,IAAIE,eAAe,GAAG,gBAAgB;EAClCC,aAAa,GAAG,cAAc;EAC9BC,gBAAgB,GAAG,iBAAiB;;AAGxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,SAASC,aAAaA,CAACC,QAAQ,EAAEC,QAAQ,EAAEC,MAAM,EAAEC,QAAQ,EAAEC,KAAK,EAAEC,QAAQ,EAAE;EAC3F,IAAI,CAACC,SAAS,GAAGN,QAAQ;EAEzB,IAAI,CAACO,KAAK,GAAG,UAASC,KAAK,EAAEC,UAAU,EAAEC,cAAc,EAAEC,MAAM,EAAE;IAC/D,IAAIC,GAAG,GAAGV,MAAM,CAACW,WAAW,CAACJ,UAAU,CAAC;MACpCK,MAAM,GAAGL,UAAU,CAACK,MAAM;MAC1BC,MAAM,GAAGN,UAAU,CAACM,MAAM;MAC1BC,SAAS,GAAGP,UAAU,CAACO,SAAS;MAChCC,IAAI;IAER,IAAI,CAACN,MAAM,IAAID,cAAc,KAAK,CAAC,EAAE;MACnCO,IAAI,GAAGrB,eAAe;IACxB,CAAC,MAAM,IAAI,CAACe,MAAM,IAAID,cAAc,KAAKM,SAAS,CAACE,MAAM,GAAG,CAAC,EAAE;MAC7DD,IAAI,GAAGpB,aAAa;IACtB,CAAC,MAAM;MACLoB,IAAI,GAAGnB,gBAAgB;IACzB;IAEA,IAAIqB,OAAO,GAAGF,IAAI,KAAKnB,gBAAgB,GAAG,4BAA4B,GAAG,sBAAsB;IAE/F,IAAIsB,OAAO,GAAGhB,KAAK,CAACgB,OAAO,CAACD,OAAO,EAAE;MACnCV,UAAU,EAAEA,UAAU;MACtBK,MAAM,EAAEA,MAAM;MACdC,MAAM,EAAEA;IACV,CAAC,CAAC;IAEF,IAAIK,OAAO,KAAK,KAAK,EAAE;MACrBA,OAAO,GAAGhB,KAAK,CAACgB,OAAO,CAACD,OAAO,EAAE;QAC/BV,UAAU,EAAEA,UAAU;QACtBK,MAAM,EAAEC,MAAM;QACdA,MAAM,EAAED;MACV,CAAC,CAAC;IACJ;IAEA,IAAIM,OAAO,KAAK,KAAK,EAAE;MACrB;IACF;IAEAjB,QAAQ,CAACkB,IAAI,CAACb,KAAK,EAAE,gBAAgB,EAAE;MACrCc,IAAI,EAAE;QACJb,UAAU,EAAEA,UAAU;QACtBc,aAAa,EAAEX,GAAG;QAClBY,OAAO,EAAE;UACPJ,OAAO,EAAEA,OAAO;UAChBV,cAAc,EAAEA,cAAc;UAC9BD,UAAU,EAAEA,UAAU;UACtBK,MAAM,EAAEA,MAAM;UACdC,MAAM,EAAEA,MAAM;UACdJ,MAAM,EAAEA,MAAM;UACdM,IAAI,EAAEA;QACR;MACF;IACF,CAAC,CAAC;EACJ,CAAC;EAEDhB,QAAQ,CAACwB,EAAE,CAAC,sBAAsB,EAAE,UAASjB,KAAK,EAAE;IAClD,IAAIgB,OAAO,GAAGhB,KAAK,CAACgB,OAAO;MACvBf,UAAU,GAAGe,OAAO,CAACf,UAAU;MAC/BK,MAAM,GAAGL,UAAU,CAACK,MAAM;MAC1BC,MAAM,GAAGN,UAAU,CAACM,MAAM;MAC1BW,KAAK,GAAGlB,KAAK,CAACkB,KAAK;MACnBT,IAAI,GAAGO,OAAO,CAACP,IAAI;;IAEvB;IACAO,OAAO,CAACE,KAAK,GAAGA,KAAK;IAErB,IAAIN,OAAO;IAEX,IAAI,CAACM,KAAK,EAAE;MACV;IACF;IAEA,IAAIP,OAAO,GAAGF,IAAI,KAAKnB,gBAAgB,GAAG,4BAA4B,GAAG,sBAAsB;IAE/FsB,OAAO,GAAGI,OAAO,CAACJ,OAAO,GAAGhB,KAAK,CAACgB,OAAO,CAACD,OAAO,EAAE;MACjDV,UAAU,EAAEA,UAAU;MACtBK,MAAM,EAAEG,IAAI,KAAKrB,eAAe,GAAG8B,KAAK,GAAGZ,MAAM;MACjDC,MAAM,EAAEE,IAAI,KAAKpB,aAAa,GAAG6B,KAAK,GAAGX;IAC3C,CAAC,CAAC;IAEF,IAAIK,OAAO,EAAE;MACXI,OAAO,CAACV,MAAM,GAAGG,IAAI,KAAKrB,eAAe,GAAG8B,KAAK,GAAGZ,MAAM;MAC1DU,OAAO,CAACT,MAAM,GAAGE,IAAI,KAAKpB,aAAa,GAAG6B,KAAK,GAAGX,MAAM;MAExD;IACF;IAEA,IAAIK,OAAO,KAAK,KAAK,EAAE;MACrBA,OAAO,GAAGI,OAAO,CAACJ,OAAO,GAAGhB,KAAK,CAACgB,OAAO,CAACD,OAAO,EAAE;QACjDV,UAAU,EAAEA,UAAU;QACtBK,MAAM,EAAEG,IAAI,KAAKpB,aAAa,GAAG6B,KAAK,GAAGX,MAAM;QAC/CA,MAAM,EAAEE,IAAI,KAAKrB,eAAe,GAAG8B,KAAK,GAAGZ;MAC7C,CAAC,CAAC;IACJ;IAEA,IAAIM,OAAO,EAAE;MACXI,OAAO,CAACV,MAAM,GAAGG,IAAI,KAAKpB,aAAa,GAAG6B,KAAK,GAAGX,MAAM;MACxDS,OAAO,CAACT,MAAM,GAAGE,IAAI,KAAKrB,eAAe,GAAG8B,KAAK,GAAGZ,MAAM;IAC5D;EACF,CAAC,CAAC;EAEFb,QAAQ,CAACwB,EAAE,CAAC,CAAE,oBAAoB,EAAE,wBAAwB,CAAE,EAAE,UAASjB,KAAK,EAAE;IAC9E,IAAIgB,OAAO,GAAGhB,KAAK,CAACgB,OAAO;MACvBP,IAAI,GAAGO,OAAO,CAACP,IAAI;IAEvBO,OAAO,CAACE,KAAK,GAAG,IAAI;IACpBF,OAAO,CAACV,MAAM,GAAG,IAAI;IACrBU,OAAO,CAACT,MAAM,GAAG,IAAI;IAErB,IAAIE,IAAI,KAAKnB,gBAAgB,EAAE;MAC7B0B,OAAO,CAACJ,OAAO,GAAG,KAAK;IACzB;EACF,CAAC,CAAC;EAEFnB,QAAQ,CAACwB,EAAE,CAAC,oBAAoB,EAAE,UAASjB,KAAK,EAAE;IAChD,IAAIgB,OAAO,GAAGhB,KAAK,CAACgB,OAAO;MACvBJ,OAAO,GAAGI,OAAO,CAACJ,OAAO;MACzBV,cAAc,GAAGc,OAAO,CAACd,cAAc;MACvCD,UAAU,GAAGe,OAAO,CAACf,UAAU;MAC/BE,MAAM,GAAGa,OAAO,CAACb,MAAM;MACvBgB,YAAY,GAAGlB,UAAU,CAACO,SAAS,CAACY,KAAK,CAAC,CAAC;MAC3Cd,MAAM,GAAGU,OAAO,CAACV,MAAM;MACvBC,MAAM,GAAGS,OAAO,CAACT,MAAM;MACvBE,IAAI,GAAGO,OAAO,CAACP,IAAI;MACnBY,KAAK,GAAGL,OAAO,CAACK,KAAK,IAAI,CAAC,CAAC;;IAE/B;IACA,IAAIC,OAAO,GAAG;MACZC,CAAC,EAAErC,KAAK,CAACc,KAAK,CAACuB,CAAC,CAAC;MACjBC,CAAC,EAAEtC,KAAK,CAACc,KAAK,CAACwB,CAAC;IAClB,CAAC;IAED,IAAI,CAACZ,OAAO,EAAE;MACZ,OAAO,KAAK;IACd;IAEA,IAAIH,IAAI,KAAKnB,gBAAgB,EAAE;MAC7B,IAAIa,MAAM,EAAE;QAEV;QACAgB,YAAY,CAACM,MAAM,CAACvB,cAAc,EAAE,CAAC,EAAEoB,OAAO,CAAC;MACjD,CAAC,MAAM;QAEL;QACAH,YAAY,CAACjB,cAAc,CAAC,GAAGoB,OAAO;MACxC;;MAEA;MACA;MACAD,KAAK,CAACK,aAAa,GAAG;QACpBvB,MAAM,EAAEA,MAAM;QACdD,cAAc,EAAEA;MAClB,CAAC;MAEDiB,YAAY,GAAG,IAAI,CAACQ,aAAa,CAAC1B,UAAU,EAAEkB,YAAY,CAAC;MAE3DtB,QAAQ,CAAC+B,eAAe,CAAC3B,UAAU,EAAEhB,wBAAwB,CAACkC,YAAY,CAAC,EAAEE,KAAK,CAAC;IACrF,CAAC,MAAM;MACL,IAAIZ,IAAI,KAAKrB,eAAe,EAAE;QAC5BiC,KAAK,CAACC,OAAO,GAAG,QAAQ;QAExB,IAAIO,SAAS,CAACb,OAAO,CAAC,EAAE;UACtBK,KAAK,CAACC,OAAO,GAAG,QAAQ;UAExBD,KAAK,CAACF,YAAY,GAAGA,YAAY,CAACW,OAAO,CAAC,CAAC;QAC7C;MACF,CAAC,MAAM,IAAIrB,IAAI,KAAKpB,aAAa,EAAE;QACjCgC,KAAK,CAACC,OAAO,GAAG,QAAQ;QAExB,IAAIO,SAAS,CAACb,OAAO,CAAC,EAAE;UACtBK,KAAK,CAACC,OAAO,GAAG,QAAQ;UAExBD,KAAK,CAACF,YAAY,GAAGA,YAAY,CAACW,OAAO,CAAC,CAAC;QAC7C;MACF;MAEAjC,QAAQ,CAACkC,SAAS,CAAC9B,UAAU,EAAEK,MAAM,EAAEC,MAAM,EAAEe,OAAO,EAAED,KAAK,CAAC;IAChE;EACF,CAAC,EAAE,IAAI,CAAC;AACV;AAEA9B,aAAa,CAACyC,OAAO,GAAG,CACtB,UAAU,EACV,UAAU,EACV,QAAQ,EACR,UAAU,EACV,OAAO,EACP,UAAU,CACX;AAEDzC,aAAa,CAAC0C,SAAS,CAACN,aAAa,GAAG,UAAS1B,UAAU,EAAEkB,YAAY,EAAE;EACzE,IAAIe,iBAAiB,GAAG,IAAI,CAACpC,SAAS,CAACqC,GAAG,CAAC,mBAAmB,EAAE,KAAK,CAAC;EAEtE,IAAI,CAACD,iBAAiB,EAAE;IACtB,OAAOf,YAAY;EACrB;EAEA,IAAIX,SAAS,GAAGP,UAAU,CAACO,SAAS;EAEpCP,UAAU,CAACO,SAAS,GAAGW,YAAY;EAEnClB,UAAU,CAACO,SAAS,GAAG0B,iBAAiB,CAACE,mBAAmB,CAACnC,UAAU,CAAC;EAExEkB,YAAY,GAAGlB,UAAU,CAACO,SAAS;EAEnCP,UAAU,CAACO,SAAS,GAAGA,SAAS;EAEhC,OAAOW,YAAY;AACrB,CAAC;;AAGD;;AAEA,OAAO,SAASU,SAASA,CAACb,OAAO,EAAE;EACjC,IAAIE,KAAK,GAAGF,OAAO,CAACE,KAAK;IACrBZ,MAAM,GAAGU,OAAO,CAACV,MAAM;IACvBC,MAAM,GAAGS,OAAO,CAACT,MAAM;IACvBE,IAAI,GAAGO,OAAO,CAACP,IAAI;EAEvB,IAAIA,IAAI,KAAKrB,eAAe,EAAE;IAC5B,OAAO8B,KAAK,IAAIX,MAAM,IAAIW,KAAK,KAAKX,MAAM,IAAID,MAAM,KAAKC,MAAM;EACjE;EAEA,IAAIE,IAAI,KAAKpB,aAAa,EAAE;IAC1B,OAAO6B,KAAK,IAAIZ,MAAM,IAAIY,KAAK,KAAKZ,MAAM,IAAIA,MAAM,KAAKC,MAAM;EACjE;AACF","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}