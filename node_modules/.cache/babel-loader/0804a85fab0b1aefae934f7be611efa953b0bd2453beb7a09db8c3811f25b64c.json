{"ast":null,"code":"\"use strict\";\n\nvar _objectSpread = require(\"/home/runner/work/sgex/sgex/node_modules/@babel/runtime/helpers/objectSpread2.js\").default;\nvar _taggedTemplateLiteral = require(\"/home/runner/work/sgex/sgex/node_modules/@babel/runtime/helpers/taggedTemplateLiteral.js\").default;\nvar _templateObject, _templateObject2, _templateObject3, _templateObject4, _templateObject5, _templateObject6, _templateObject7, _templateObject8, _templateObject9, _templateObject0, _templateObject1, _templateObject10, _templateObject11, _templateObject12, _templateObject13, _templateObject14, _templateObject15, _templateObject16;\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.checkStrictMode = exports.getErrorPath = exports.Type = exports.useFunc = exports.setEvaluated = exports.evaluatedPropsToName = exports.mergeEvaluated = exports.eachItem = exports.unescapeJsonPointer = exports.escapeJsonPointer = exports.escapeFragment = exports.unescapeFragment = exports.schemaRefOrVal = exports.schemaHasRulesButRef = exports.schemaHasRules = exports.checkUnknownRules = exports.alwaysValidSchema = exports.toHash = void 0;\nconst codegen_1 = require(\"./codegen\");\nconst code_1 = require(\"./codegen/code\");\n// TODO refactor to use Set\nfunction toHash(arr) {\n  const hash = {};\n  for (const item of arr) hash[item] = true;\n  return hash;\n}\nexports.toHash = toHash;\nfunction alwaysValidSchema(it, schema) {\n  if (typeof schema == \"boolean\") return schema;\n  if (Object.keys(schema).length === 0) return true;\n  checkUnknownRules(it, schema);\n  return !schemaHasRules(schema, it.self.RULES.all);\n}\nexports.alwaysValidSchema = alwaysValidSchema;\nfunction checkUnknownRules(it) {\n  let schema = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : it.schema;\n  const {\n    opts,\n    self\n  } = it;\n  if (!opts.strictSchema) return;\n  if (typeof schema === \"boolean\") return;\n  const rules = self.RULES.keywords;\n  for (const key in schema) {\n    if (!rules[key]) checkStrictMode(it, \"unknown keyword: \\\"\".concat(key, \"\\\"\"));\n  }\n}\nexports.checkUnknownRules = checkUnknownRules;\nfunction schemaHasRules(schema, rules) {\n  if (typeof schema == \"boolean\") return !schema;\n  for (const key in schema) if (rules[key]) return true;\n  return false;\n}\nexports.schemaHasRules = schemaHasRules;\nfunction schemaHasRulesButRef(schema, RULES) {\n  if (typeof schema == \"boolean\") return !schema;\n  for (const key in schema) if (key !== \"$ref\" && RULES.all[key]) return true;\n  return false;\n}\nexports.schemaHasRulesButRef = schemaHasRulesButRef;\nfunction schemaRefOrVal(_ref, schema, keyword, $data) {\n  let {\n    topSchemaRef,\n    schemaPath\n  } = _ref;\n  if (!$data) {\n    if (typeof schema == \"number\" || typeof schema == \"boolean\") return schema;\n    if (typeof schema == \"string\") return (0, codegen_1._)(_templateObject || (_templateObject = _taggedTemplateLiteral([\"\", \"\"])), schema);\n  }\n  return (0, codegen_1._)(_templateObject2 || (_templateObject2 = _taggedTemplateLiteral([\"\", \"\", \"\", \"\"])), topSchemaRef, schemaPath, (0, codegen_1.getProperty)(keyword));\n}\nexports.schemaRefOrVal = schemaRefOrVal;\nfunction unescapeFragment(str) {\n  return unescapeJsonPointer(decodeURIComponent(str));\n}\nexports.unescapeFragment = unescapeFragment;\nfunction escapeFragment(str) {\n  return encodeURIComponent(escapeJsonPointer(str));\n}\nexports.escapeFragment = escapeFragment;\nfunction escapeJsonPointer(str) {\n  if (typeof str == \"number\") return \"\".concat(str);\n  return str.replace(/~/g, \"~0\").replace(/\\//g, \"~1\");\n}\nexports.escapeJsonPointer = escapeJsonPointer;\nfunction unescapeJsonPointer(str) {\n  return str.replace(/~1/g, \"/\").replace(/~0/g, \"~\");\n}\nexports.unescapeJsonPointer = unescapeJsonPointer;\nfunction eachItem(xs, f) {\n  if (Array.isArray(xs)) {\n    for (const x of xs) f(x);\n  } else {\n    f(xs);\n  }\n}\nexports.eachItem = eachItem;\nfunction makeMergeEvaluated(_ref2) {\n  let {\n    mergeNames,\n    mergeToName,\n    mergeValues,\n    resultToName\n  } = _ref2;\n  return (gen, from, to, toName) => {\n    const res = to === undefined ? from : to instanceof codegen_1.Name ? (from instanceof codegen_1.Name ? mergeNames(gen, from, to) : mergeToName(gen, from, to), to) : from instanceof codegen_1.Name ? (mergeToName(gen, to, from), from) : mergeValues(from, to);\n    return toName === codegen_1.Name && !(res instanceof codegen_1.Name) ? resultToName(gen, res) : res;\n  };\n}\nexports.mergeEvaluated = {\n  props: makeMergeEvaluated({\n    mergeNames: (gen, from, to) => gen.if((0, codegen_1._)(_templateObject3 || (_templateObject3 = _taggedTemplateLiteral([\"\", \" !== true && \", \" !== undefined\"])), to, from), () => {\n      gen.if((0, codegen_1._)(_templateObject4 || (_templateObject4 = _taggedTemplateLiteral([\"\", \" === true\"])), from), () => gen.assign(to, true), () => gen.assign(to, (0, codegen_1._)(_templateObject5 || (_templateObject5 = _taggedTemplateLiteral([\"\", \" || {}\"])), to)).code((0, codegen_1._)(_templateObject6 || (_templateObject6 = _taggedTemplateLiteral([\"Object.assign(\", \", \", \")\"])), to, from)));\n    }),\n    mergeToName: (gen, from, to) => gen.if((0, codegen_1._)(_templateObject7 || (_templateObject7 = _taggedTemplateLiteral([\"\", \" !== true\"])), to), () => {\n      if (from === true) {\n        gen.assign(to, true);\n      } else {\n        gen.assign(to, (0, codegen_1._)(_templateObject8 || (_templateObject8 = _taggedTemplateLiteral([\"\", \" || {}\"])), to));\n        setEvaluated(gen, to, from);\n      }\n    }),\n    mergeValues: (from, to) => from === true ? true : _objectSpread(_objectSpread({}, from), to),\n    resultToName: evaluatedPropsToName\n  }),\n  items: makeMergeEvaluated({\n    mergeNames: (gen, from, to) => gen.if((0, codegen_1._)(_templateObject9 || (_templateObject9 = _taggedTemplateLiteral([\"\", \" !== true && \", \" !== undefined\"])), to, from), () => gen.assign(to, (0, codegen_1._)(_templateObject0 || (_templateObject0 = _taggedTemplateLiteral([\"\", \" === true ? true : \", \" > \", \" ? \", \" : \", \"\"])), from, to, from, to, from))),\n    mergeToName: (gen, from, to) => gen.if((0, codegen_1._)(_templateObject1 || (_templateObject1 = _taggedTemplateLiteral([\"\", \" !== true\"])), to), () => gen.assign(to, from === true ? true : (0, codegen_1._)(_templateObject10 || (_templateObject10 = _taggedTemplateLiteral([\"\", \" > \", \" ? \", \" : \", \"\"])), to, from, to, from))),\n    mergeValues: (from, to) => from === true ? true : Math.max(from, to),\n    resultToName: (gen, items) => gen.var(\"items\", items)\n  })\n};\nfunction evaluatedPropsToName(gen, ps) {\n  if (ps === true) return gen.var(\"props\", true);\n  const props = gen.var(\"props\", (0, codegen_1._)(_templateObject11 || (_templateObject11 = _taggedTemplateLiteral([\"{}\"]))));\n  if (ps !== undefined) setEvaluated(gen, props, ps);\n  return props;\n}\nexports.evaluatedPropsToName = evaluatedPropsToName;\nfunction setEvaluated(gen, props, ps) {\n  Object.keys(ps).forEach(p => gen.assign((0, codegen_1._)(_templateObject12 || (_templateObject12 = _taggedTemplateLiteral([\"\", \"\", \"\"])), props, (0, codegen_1.getProperty)(p)), true));\n}\nexports.setEvaluated = setEvaluated;\nconst snippets = {};\nfunction useFunc(gen, f) {\n  return gen.scopeValue(\"func\", {\n    ref: f,\n    code: snippets[f.code] || (snippets[f.code] = new code_1._Code(f.code))\n  });\n}\nexports.useFunc = useFunc;\nvar Type;\n(function (Type) {\n  Type[Type[\"Num\"] = 0] = \"Num\";\n  Type[Type[\"Str\"] = 1] = \"Str\";\n})(Type || (exports.Type = Type = {}));\nfunction getErrorPath(dataProp, dataPropType, jsPropertySyntax) {\n  // let path\n  if (dataProp instanceof codegen_1.Name) {\n    const isNumber = dataPropType === Type.Num;\n    return jsPropertySyntax ? isNumber ? (0, codegen_1._)(_templateObject13 || (_templateObject13 = _taggedTemplateLiteral([\"\\\"[\\\" + \", \" + \\\"]\\\"\"])), dataProp) : (0, codegen_1._)(_templateObject14 || (_templateObject14 = _taggedTemplateLiteral([\"\\\"['\\\" + \", \" + \\\"']\\\"\"])), dataProp) : isNumber ? (0, codegen_1._)(_templateObject15 || (_templateObject15 = _taggedTemplateLiteral([\"\\\"/\\\" + \", \"\"])), dataProp) : (0, codegen_1._)(_templateObject16 || (_templateObject16 = _taggedTemplateLiteral([\"\\\"/\\\" + \", \".replace(/~/g, \\\"~0\\\").replace(/\\\\//g, \\\"~1\\\")\"], [\"\\\"/\\\" + \", \".replace(/~/g, \\\"~0\\\").replace(/\\\\\\\\//g, \\\"~1\\\")\"])), dataProp); // TODO maybe use global escapePointer\n  }\n  return jsPropertySyntax ? (0, codegen_1.getProperty)(dataProp).toString() : \"/\" + escapeJsonPointer(dataProp);\n}\nexports.getErrorPath = getErrorPath;\nfunction checkStrictMode(it, msg) {\n  let mode = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : it.opts.strictSchema;\n  if (!mode) return;\n  msg = \"strict mode: \".concat(msg);\n  if (mode === true) throw new Error(msg);\n  it.self.logger.warn(msg);\n}\nexports.checkStrictMode = checkStrictMode;","map":{"version":3,"names":["codegen_1","require","code_1","toHash","arr","hash","item","exports","alwaysValidSchema","it","schema","Object","keys","length","checkUnknownRules","schemaHasRules","self","RULES","all","arguments","undefined","opts","strictSchema","rules","keywords","key","checkStrictMode","concat","schemaHasRulesButRef","schemaRefOrVal","_ref","keyword","$data","topSchemaRef","schemaPath","_","_templateObject","_taggedTemplateLiteral","_templateObject2","getProperty","unescapeFragment","str","unescapeJsonPointer","decodeURIComponent","escapeFragment","encodeURIComponent","escapeJsonPointer","replace","eachItem","xs","f","Array","isArray","x","makeMergeEvaluated","_ref2","mergeNames","mergeToName","mergeValues","resultToName","gen","from","to","toName","res","Name","mergeEvaluated","props","if","_templateObject3","_templateObject4","assign","_templateObject5","code","_templateObject6","_templateObject7","_templateObject8","setEvaluated","_objectSpread","evaluatedPropsToName","items","_templateObject9","_templateObject0","_templateObject1","_templateObject10","Math","max","var","ps","_templateObject11","forEach","p","_templateObject12","snippets","useFunc","scopeValue","ref","_Code","Type","getErrorPath","dataProp","dataPropType","jsPropertySyntax","isNumber","Num","_templateObject13","_templateObject14","_templateObject15","_templateObject16","toString","msg","mode","Error","logger","warn"],"sources":["/home/runner/work/sgex/sgex/node_modules/ajv/lib/compile/util.ts"],"sourcesContent":["import type {AnySchema, EvaluatedProperties, EvaluatedItems} from \"../types\"\nimport type {SchemaCxt, SchemaObjCxt} from \".\"\nimport {_, getProperty, Code, Name, CodeGen} from \"./codegen\"\nimport {_Code} from \"./codegen/code\"\nimport type {Rule, ValidationRules} from \"./rules\"\n\n// TODO refactor to use Set\nexport function toHash<T extends string = string>(arr: T[]): {[K in T]?: true} {\n  const hash: {[K in T]?: true} = {}\n  for (const item of arr) hash[item] = true\n  return hash\n}\n\nexport function alwaysValidSchema(it: SchemaCxt, schema: AnySchema): boolean | void {\n  if (typeof schema == \"boolean\") return schema\n  if (Object.keys(schema).length === 0) return true\n  checkUnknownRules(it, schema)\n  return !schemaHasRules(schema, it.self.RULES.all)\n}\n\nexport function checkUnknownRules(it: SchemaCxt, schema: AnySchema = it.schema): void {\n  const {opts, self} = it\n  if (!opts.strictSchema) return\n  if (typeof schema === \"boolean\") return\n  const rules = self.RULES.keywords\n  for (const key in schema) {\n    if (!rules[key]) checkStrictMode(it, `unknown keyword: \"${key}\"`)\n  }\n}\n\nexport function schemaHasRules(\n  schema: AnySchema,\n  rules: {[Key in string]?: boolean | Rule}\n): boolean {\n  if (typeof schema == \"boolean\") return !schema\n  for (const key in schema) if (rules[key]) return true\n  return false\n}\n\nexport function schemaHasRulesButRef(schema: AnySchema, RULES: ValidationRules): boolean {\n  if (typeof schema == \"boolean\") return !schema\n  for (const key in schema) if (key !== \"$ref\" && RULES.all[key]) return true\n  return false\n}\n\nexport function schemaRefOrVal(\n  {topSchemaRef, schemaPath}: SchemaObjCxt,\n  schema: unknown,\n  keyword: string,\n  $data?: string | false\n): Code | number | boolean {\n  if (!$data) {\n    if (typeof schema == \"number\" || typeof schema == \"boolean\") return schema\n    if (typeof schema == \"string\") return _`${schema}`\n  }\n  return _`${topSchemaRef}${schemaPath}${getProperty(keyword)}`\n}\n\nexport function unescapeFragment(str: string): string {\n  return unescapeJsonPointer(decodeURIComponent(str))\n}\n\nexport function escapeFragment(str: string | number): string {\n  return encodeURIComponent(escapeJsonPointer(str))\n}\n\nexport function escapeJsonPointer(str: string | number): string {\n  if (typeof str == \"number\") return `${str}`\n  return str.replace(/~/g, \"~0\").replace(/\\//g, \"~1\")\n}\n\nexport function unescapeJsonPointer(str: string): string {\n  return str.replace(/~1/g, \"/\").replace(/~0/g, \"~\")\n}\n\nexport function eachItem<T>(xs: T | T[], f: (x: T) => void): void {\n  if (Array.isArray(xs)) {\n    for (const x of xs) f(x)\n  } else {\n    f(xs)\n  }\n}\n\ntype SomeEvaluated = EvaluatedProperties | EvaluatedItems\n\ntype MergeEvaluatedFunc<T extends SomeEvaluated> = (\n  gen: CodeGen,\n  from: Name | T,\n  to: Name | Exclude<T, true> | undefined,\n  toName?: typeof Name\n) => Name | T\n\ninterface MakeMergeFuncArgs<T extends SomeEvaluated> {\n  mergeNames: (gen: CodeGen, from: Name, to: Name) => void\n  mergeToName: (gen: CodeGen, from: T, to: Name) => void\n  mergeValues: (from: T, to: Exclude<T, true>) => T\n  resultToName: (gen: CodeGen, res?: T) => Name\n}\n\nfunction makeMergeEvaluated<T extends SomeEvaluated>({\n  mergeNames,\n  mergeToName,\n  mergeValues,\n  resultToName,\n}: MakeMergeFuncArgs<T>): MergeEvaluatedFunc<T> {\n  return (gen, from, to, toName) => {\n    const res =\n      to === undefined\n        ? from\n        : to instanceof Name\n        ? (from instanceof Name ? mergeNames(gen, from, to) : mergeToName(gen, from, to), to)\n        : from instanceof Name\n        ? (mergeToName(gen, to, from), from)\n        : mergeValues(from, to)\n    return toName === Name && !(res instanceof Name) ? resultToName(gen, res) : res\n  }\n}\n\ninterface MergeEvaluated {\n  props: MergeEvaluatedFunc<EvaluatedProperties>\n  items: MergeEvaluatedFunc<EvaluatedItems>\n}\n\nexport const mergeEvaluated: MergeEvaluated = {\n  props: makeMergeEvaluated({\n    mergeNames: (gen, from, to) =>\n      gen.if(_`${to} !== true && ${from} !== undefined`, () => {\n        gen.if(\n          _`${from} === true`,\n          () => gen.assign(to, true),\n          () => gen.assign(to, _`${to} || {}`).code(_`Object.assign(${to}, ${from})`)\n        )\n      }),\n    mergeToName: (gen, from, to) =>\n      gen.if(_`${to} !== true`, () => {\n        if (from === true) {\n          gen.assign(to, true)\n        } else {\n          gen.assign(to, _`${to} || {}`)\n          setEvaluated(gen, to, from)\n        }\n      }),\n    mergeValues: (from, to) => (from === true ? true : {...from, ...to}),\n    resultToName: evaluatedPropsToName,\n  }),\n  items: makeMergeEvaluated({\n    mergeNames: (gen, from, to) =>\n      gen.if(_`${to} !== true && ${from} !== undefined`, () =>\n        gen.assign(to, _`${from} === true ? true : ${to} > ${from} ? ${to} : ${from}`)\n      ),\n    mergeToName: (gen, from, to) =>\n      gen.if(_`${to} !== true`, () =>\n        gen.assign(to, from === true ? true : _`${to} > ${from} ? ${to} : ${from}`)\n      ),\n    mergeValues: (from, to) => (from === true ? true : Math.max(from, to)),\n    resultToName: (gen, items) => gen.var(\"items\", items),\n  }),\n}\n\nexport function evaluatedPropsToName(gen: CodeGen, ps?: EvaluatedProperties): Name {\n  if (ps === true) return gen.var(\"props\", true)\n  const props = gen.var(\"props\", _`{}`)\n  if (ps !== undefined) setEvaluated(gen, props, ps)\n  return props\n}\n\nexport function setEvaluated(gen: CodeGen, props: Name, ps: {[K in string]?: true}): void {\n  Object.keys(ps).forEach((p) => gen.assign(_`${props}${getProperty(p)}`, true))\n}\n\nconst snippets: {[S in string]?: _Code} = {}\n\nexport function useFunc(gen: CodeGen, f: {code: string}): Name {\n  return gen.scopeValue(\"func\", {\n    ref: f,\n    code: snippets[f.code] || (snippets[f.code] = new _Code(f.code)),\n  })\n}\n\nexport enum Type {\n  Num,\n  Str,\n}\n\nexport function getErrorPath(\n  dataProp: Name | string | number,\n  dataPropType?: Type,\n  jsPropertySyntax?: boolean\n): Code | string {\n  // let path\n  if (dataProp instanceof Name) {\n    const isNumber = dataPropType === Type.Num\n    return jsPropertySyntax\n      ? isNumber\n        ? _`\"[\" + ${dataProp} + \"]\"`\n        : _`\"['\" + ${dataProp} + \"']\"`\n      : isNumber\n      ? _`\"/\" + ${dataProp}`\n      : _`\"/\" + ${dataProp}.replace(/~/g, \"~0\").replace(/\\\\//g, \"~1\")` // TODO maybe use global escapePointer\n  }\n  return jsPropertySyntax ? getProperty(dataProp).toString() : \"/\" + escapeJsonPointer(dataProp)\n}\n\nexport function checkStrictMode(\n  it: SchemaCxt,\n  msg: string,\n  mode: boolean | \"log\" = it.opts.strictSchema\n): void {\n  if (!mode) return\n  msg = `strict mode: ${msg}`\n  if (mode === true) throw new Error(msg)\n  it.self.logger.warn(msg)\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}