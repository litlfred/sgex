{"ast":null,"code":"/**\n * @typedef {import('didi').Injector} Injector\n */\n\n/**\n * A service that provides rules for certain diagram actions.\n *\n * The default implementation will hook into the {@link CommandStack}\n * to perform the actual rule evaluation. Make sure to provide the\n * `commandStack` service with this module if you plan to use it.\n *\n * Together with this implementation you may use the {@link import('./RuleProvider').default}\n * to implement your own rule checkers.\n *\n * This module is ment to be easily replaced, thus the tiny foot print.\n *\n * @param {Injector} injector\n */\nexport default function Rules(injector) {\n  this._commandStack = injector.get('commandStack', false);\n}\nRules.$inject = ['injector'];\n\n/**\n * Returns whether or not a given modeling action can be executed\n * in the specified context.\n *\n * This implementation will respond with allow unless anyone\n * objects.\n *\n * @param {string} action The action to be allowed or disallowed.\n * @param {Object} [context] The context for allowing or disallowing the action.\n *\n * @return {boolean|null} Wether the action is allowed. Returns `null` if the action\n * is to be ignored.\n */\nRules.prototype.allowed = function (action, context) {\n  var allowed = true;\n  var commandStack = this._commandStack;\n  if (commandStack) {\n    allowed = commandStack.canExecute(action, context);\n  }\n\n  // map undefined to true, i.e. no rules\n  return allowed === undefined ? true : allowed;\n};","map":{"version":3,"names":["Rules","injector","_commandStack","get","$inject","prototype","allowed","action","context","commandStack","canExecute","undefined"],"sources":["/home/runner/work/sgex/sgex/node_modules/diagram-js/lib/features/rules/Rules.js"],"sourcesContent":["/**\n * @typedef {import('didi').Injector} Injector\n */\n\n/**\n * A service that provides rules for certain diagram actions.\n *\n * The default implementation will hook into the {@link CommandStack}\n * to perform the actual rule evaluation. Make sure to provide the\n * `commandStack` service with this module if you plan to use it.\n *\n * Together with this implementation you may use the {@link import('./RuleProvider').default}\n * to implement your own rule checkers.\n *\n * This module is ment to be easily replaced, thus the tiny foot print.\n *\n * @param {Injector} injector\n */\nexport default function Rules(injector) {\n  this._commandStack = injector.get('commandStack', false);\n}\n\nRules.$inject = [ 'injector' ];\n\n\n/**\n * Returns whether or not a given modeling action can be executed\n * in the specified context.\n *\n * This implementation will respond with allow unless anyone\n * objects.\n *\n * @param {string} action The action to be allowed or disallowed.\n * @param {Object} [context] The context for allowing or disallowing the action.\n *\n * @return {boolean|null} Wether the action is allowed. Returns `null` if the action\n * is to be ignored.\n */\nRules.prototype.allowed = function(action, context) {\n  var allowed = true;\n\n  var commandStack = this._commandStack;\n\n  if (commandStack) {\n    allowed = commandStack.canExecute(action, context);\n  }\n\n  // map undefined to true, i.e. no rules\n  return allowed === undefined ? true : allowed;\n};"],"mappings":"AAAA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,SAASA,KAAKA,CAACC,QAAQ,EAAE;EACtC,IAAI,CAACC,aAAa,GAAGD,QAAQ,CAACE,GAAG,CAAC,cAAc,EAAE,KAAK,CAAC;AAC1D;AAEAH,KAAK,CAACI,OAAO,GAAG,CAAE,UAAU,CAAE;;AAG9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACAJ,KAAK,CAACK,SAAS,CAACC,OAAO,GAAG,UAASC,MAAM,EAAEC,OAAO,EAAE;EAClD,IAAIF,OAAO,GAAG,IAAI;EAElB,IAAIG,YAAY,GAAG,IAAI,CAACP,aAAa;EAErC,IAAIO,YAAY,EAAE;IAChBH,OAAO,GAAGG,YAAY,CAACC,UAAU,CAACH,MAAM,EAAEC,OAAO,CAAC;EACpD;;EAEA;EACA,OAAOF,OAAO,KAAKK,SAAS,GAAG,IAAI,GAAGL,OAAO;AAC/C,CAAC","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}