{"ast":null,"code":"export const xmlReplacer = /[\"$&'<>\\u0080-\\uFFFF]/g;\nconst xmlCodeMap = new Map([[34, \"&quot;\"], [38, \"&amp;\"], [39, \"&apos;\"], [60, \"&lt;\"], [62, \"&gt;\"]]);\n// For compatibility with node < 4, we wrap `codePointAt`\nexport const getCodePoint =\n// eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\nString.prototype.codePointAt == null ? (c, index) => (c.charCodeAt(index) & 64512) === 55296 ? (c.charCodeAt(index) - 55296) * 1024 + c.charCodeAt(index + 1) - 56320 + 65536 : c.charCodeAt(index) :\n// http://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae\n(input, index) => input.codePointAt(index);\n/**\n * Encodes all non-ASCII characters, as well as characters not valid in XML\n * documents using XML entities.\n *\n * If a character has no equivalent entity, a\n * numeric hexadecimal reference (eg. `&#xfc;`) will be used.\n */\nexport function encodeXML(input) {\n  let returnValue = \"\";\n  let lastIndex = 0;\n  let match;\n  while ((match = xmlReplacer.exec(input)) !== null) {\n    const {\n      index\n    } = match;\n    const char = input.charCodeAt(index);\n    const next = xmlCodeMap.get(char);\n    if (next === undefined) {\n      returnValue += \"\".concat(input.substring(lastIndex, index), \"&#x\").concat(getCodePoint(input, index).toString(16), \";\");\n      // Increase by 1 if we have a surrogate pair\n      lastIndex = xmlReplacer.lastIndex += Number((char & 64512) === 55296);\n    } else {\n      returnValue += input.substring(lastIndex, index) + next;\n      lastIndex = index + 1;\n    }\n  }\n  return returnValue + input.substr(lastIndex);\n}\n/**\n * Encodes all non-ASCII characters, as well as characters not valid in XML\n * documents using numeric hexadecimal reference (eg. `&#xfc;`).\n *\n * Have a look at `escapeUTF8` if you want a more concise output at the expense\n * of reduced transportability.\n *\n * @param data String to escape.\n */\nexport const escape = encodeXML;\n/**\n * Creates a function that escapes all characters matched by the given regular\n * expression using the given map of characters to escape to their entities.\n *\n * @param regex Regular expression to match characters to escape.\n * @param map Map of characters to escape to their entities.\n *\n * @returns Function that escapes all characters matched by the given regular\n * expression using the given map of characters to escape to their entities.\n */\nfunction getEscaper(regex, map) {\n  return function escape(data) {\n    let match;\n    let lastIndex = 0;\n    let result = \"\";\n    while (match = regex.exec(data)) {\n      if (lastIndex !== match.index) {\n        result += data.substring(lastIndex, match.index);\n      }\n      // We know that this character will be in the map.\n      result += map.get(match[0].charCodeAt(0));\n      // Every match will be of length 1\n      lastIndex = match.index + 1;\n    }\n    return result + data.substring(lastIndex);\n  };\n}\n/**\n * Encodes all characters not valid in XML documents using XML entities.\n *\n * Note that the output will be character-set dependent.\n *\n * @param data String to escape.\n */\nexport const escapeUTF8 = /* #__PURE__ */getEscaper(/[\"&'<>]/g, xmlCodeMap);\n/**\n * Encodes all characters that have to be escaped in HTML attributes,\n * following {@link https://html.spec.whatwg.org/multipage/parsing.html#escapingString}.\n *\n * @param data String to escape.\n */\nexport const escapeAttribute = /* #__PURE__ */getEscaper(/[\"&\\u00A0]/g, new Map([[34, \"&quot;\"], [38, \"&amp;\"], [160, \"&nbsp;\"]]));\n/**\n * Encodes all characters that have to be escaped in HTML text,\n * following {@link https://html.spec.whatwg.org/multipage/parsing.html#escapingString}.\n *\n * @param data String to escape.\n */\nexport const escapeText = /* #__PURE__ */getEscaper(/[&<>\\u00A0]/g, new Map([[38, \"&amp;\"], [60, \"&lt;\"], [62, \"&gt;\"], [160, \"&nbsp;\"]]));","map":{"version":3,"names":["xmlReplacer","xmlCodeMap","Map","getCodePoint","String","prototype","codePointAt","c","index","charCodeAt","input","encodeXML","returnValue","lastIndex","match","exec","char","next","get","undefined","concat","substring","toString","Number","substr","escape","getEscaper","regex","map","data","result","escapeUTF8","escapeAttribute","escapeText"],"sources":["/home/runner/work/sgex/sgex/node_modules/entities/src/escape.ts"],"sourcesContent":["export const xmlReplacer: RegExp = /[\"$&'<>\\u0080-\\uFFFF]/g;\n\nconst xmlCodeMap = new Map([\n    [34, \"&quot;\"],\n    [38, \"&amp;\"],\n    [39, \"&apos;\"],\n    [60, \"&lt;\"],\n    [62, \"&gt;\"],\n]);\n\n// For compatibility with node < 4, we wrap `codePointAt`\nexport const getCodePoint: (c: string, index: number) => number =\n    // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n    String.prototype.codePointAt == null\n        ? (c: string, index: number): number =>\n              (c.charCodeAt(index) & 0xfc_00) === 0xd8_00\n                  ? (c.charCodeAt(index) - 0xd8_00) * 0x4_00 +\n                    c.charCodeAt(index + 1) -\n                    0xdc_00 +\n                    0x1_00_00\n                  : c.charCodeAt(index)\n        : // http://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae\n          (input: string, index: number): number => input.codePointAt(index)!;\n\n/**\n * Encodes all non-ASCII characters, as well as characters not valid in XML\n * documents using XML entities.\n *\n * If a character has no equivalent entity, a\n * numeric hexadecimal reference (eg. `&#xfc;`) will be used.\n */\nexport function encodeXML(input: string): string {\n    let returnValue = \"\";\n    let lastIndex = 0;\n    let match;\n\n    while ((match = xmlReplacer.exec(input)) !== null) {\n        const { index } = match;\n        const char = input.charCodeAt(index);\n        const next = xmlCodeMap.get(char);\n\n        if (next === undefined) {\n            returnValue += `${input.substring(lastIndex, index)}&#x${getCodePoint(\n                input,\n                index,\n            ).toString(16)};`;\n            // Increase by 1 if we have a surrogate pair\n            lastIndex = xmlReplacer.lastIndex += Number(\n                (char & 0xfc_00) === 0xd8_00,\n            );\n        } else {\n            returnValue += input.substring(lastIndex, index) + next;\n            lastIndex = index + 1;\n        }\n    }\n\n    return returnValue + input.substr(lastIndex);\n}\n\n/**\n * Encodes all non-ASCII characters, as well as characters not valid in XML\n * documents using numeric hexadecimal reference (eg. `&#xfc;`).\n *\n * Have a look at `escapeUTF8` if you want a more concise output at the expense\n * of reduced transportability.\n *\n * @param data String to escape.\n */\nexport const escape: typeof encodeXML = encodeXML;\n\n/**\n * Creates a function that escapes all characters matched by the given regular\n * expression using the given map of characters to escape to their entities.\n *\n * @param regex Regular expression to match characters to escape.\n * @param map Map of characters to escape to their entities.\n *\n * @returns Function that escapes all characters matched by the given regular\n * expression using the given map of characters to escape to their entities.\n */\nfunction getEscaper(\n    regex: RegExp,\n    map: Map<number, string>,\n): (data: string) => string {\n    return function escape(data: string): string {\n        let match;\n        let lastIndex = 0;\n        let result = \"\";\n\n        while ((match = regex.exec(data))) {\n            if (lastIndex !== match.index) {\n                result += data.substring(lastIndex, match.index);\n            }\n\n            // We know that this character will be in the map.\n            result += map.get(match[0].charCodeAt(0))!;\n\n            // Every match will be of length 1\n            lastIndex = match.index + 1;\n        }\n\n        return result + data.substring(lastIndex);\n    };\n}\n\n/**\n * Encodes all characters not valid in XML documents using XML entities.\n *\n * Note that the output will be character-set dependent.\n *\n * @param data String to escape.\n */\nexport const escapeUTF8: (data: string) => string = /* #__PURE__ */ getEscaper(\n    /[\"&'<>]/g,\n    xmlCodeMap,\n);\n\n/**\n * Encodes all characters that have to be escaped in HTML attributes,\n * following {@link https://html.spec.whatwg.org/multipage/parsing.html#escapingString}.\n *\n * @param data String to escape.\n */\nexport const escapeAttribute: (data: string) => string =\n    /* #__PURE__ */ getEscaper(\n        /[\"&\\u00A0]/g,\n        new Map([\n            [34, \"&quot;\"],\n            [38, \"&amp;\"],\n            [160, \"&nbsp;\"],\n        ]),\n    );\n\n/**\n * Encodes all characters that have to be escaped in HTML text,\n * following {@link https://html.spec.whatwg.org/multipage/parsing.html#escapingString}.\n *\n * @param data String to escape.\n */\nexport const escapeText: (data: string) => string = /* #__PURE__ */ getEscaper(\n    /[&<>\\u00A0]/g,\n    new Map([\n        [38, \"&amp;\"],\n        [60, \"&lt;\"],\n        [62, \"&gt;\"],\n        [160, \"&nbsp;\"],\n    ]),\n);\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}