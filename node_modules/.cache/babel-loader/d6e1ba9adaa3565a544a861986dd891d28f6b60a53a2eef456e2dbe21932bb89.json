{"ast":null,"code":"/**\n * @typedef {import('diagram-js/lib/util/Types').Point} Point\n *\n * @typedef { {\n*   type: 'bendpoint' | 'segment';\n*   position: Point;\n*   segmentIndex: number;\n*   bendpointIndex?: number;\n*   relativeLocation?: number;\n* } } Attachment\n*/\n\nvar sqrt = Math.sqrt,\n  min = Math.min,\n  max = Math.max,\n  abs = Math.abs;\n\n/**\n * Calculate the square (power to two) of a number.\n *\n * @param {number} n\n *\n * @return {number}\n */\nfunction sq(n) {\n  return Math.pow(n, 2);\n}\n\n/**\n * Get distance between two points.\n *\n * @param {Point} p1\n * @param {Point} p2\n *\n * @return {number}\n */\nfunction getDistance(p1, p2) {\n  return sqrt(sq(p1.x - p2.x) + sq(p1.y - p2.y));\n}\n\n/**\n * Return the attachment of the given point on the specified line.\n *\n * The attachment is either a bendpoint (attached to the given point)\n * or segment (attached to a location on a line segment) attachment:\n *\n * ```javascript\n * var pointAttachment = {\n *   type: 'bendpoint',\n *   bendpointIndex: 3,\n *   position: { x: 10, y: 10 } // the attach point on the line\n * };\n *\n * var segmentAttachment = {\n *   type: 'segment',\n *   segmentIndex: 2,\n *   relativeLocation: 0.31, // attach point location between 0 (at start) and 1 (at end)\n *   position: { x: 10, y: 10 } // the attach point on the line\n * };\n * ```\n *\n * @param {Point} point\n * @param {Point[]} line\n *\n * @return {Attachment}\n */\nexport function getAttachment(point, line) {\n  var idx = 0,\n    segmentStart,\n    segmentEnd,\n    segmentStartDistance,\n    segmentEndDistance,\n    attachmentPosition,\n    minDistance,\n    intersections,\n    attachment,\n    attachmentDistance,\n    closestAttachmentDistance,\n    closestAttachment;\n  for (idx = 0; idx < line.length - 1; idx++) {\n    segmentStart = line[idx];\n    segmentEnd = line[idx + 1];\n    if (pointsEqual(segmentStart, segmentEnd)) {\n      intersections = [segmentStart];\n    } else {\n      segmentStartDistance = getDistance(point, segmentStart);\n      segmentEndDistance = getDistance(point, segmentEnd);\n      minDistance = min(segmentStartDistance, segmentEndDistance);\n      intersections = getCircleSegmentIntersections(segmentStart, segmentEnd, point, minDistance);\n    }\n    if (intersections.length < 1) {\n      throw new Error('expected between [1, 2] circle -> line intersections');\n    }\n\n    // one intersection -> bendpoint attachment\n    if (intersections.length === 1) {\n      attachment = {\n        type: 'bendpoint',\n        position: intersections[0],\n        segmentIndex: idx,\n        bendpointIndex: pointsEqual(segmentStart, intersections[0]) ? idx : idx + 1\n      };\n    }\n\n    // two intersections -> segment attachment\n    if (intersections.length === 2) {\n      attachmentPosition = mid(intersections[0], intersections[1]);\n      attachment = {\n        type: 'segment',\n        position: attachmentPosition,\n        segmentIndex: idx,\n        relativeLocation: getDistance(segmentStart, attachmentPosition) / getDistance(segmentStart, segmentEnd)\n      };\n    }\n    attachmentDistance = getDistance(attachment.position, point);\n    if (!closestAttachment || closestAttachmentDistance > attachmentDistance) {\n      closestAttachment = attachment;\n      closestAttachmentDistance = attachmentDistance;\n    }\n  }\n  return closestAttachment;\n}\n\n/**\n * Get the intersection between a circle and a line segment.\n *\n * @param {Point} s1 segment start\n * @param {Point} s2 segment end\n * @param {Point} cc circle center\n * @param {number} cr circle radius\n *\n * @return {Point[]} intersections\n */\nfunction getCircleSegmentIntersections(s1, s2, cc, cr) {\n  var baX = s2.x - s1.x;\n  var baY = s2.y - s1.y;\n  var caX = cc.x - s1.x;\n  var caY = cc.y - s1.y;\n  var a = baX * baX + baY * baY;\n  var bBy2 = baX * caX + baY * caY;\n  var c = caX * caX + caY * caY - cr * cr;\n  var pBy2 = bBy2 / a;\n  var q = c / a;\n  var disc = pBy2 * pBy2 - q;\n\n  // check against negative value to work around\n  // negative, very close to zero results (-4e-15)\n  // being produced in some environments\n  if (disc < 0 && disc > -0.000001) {\n    disc = 0;\n  }\n  if (disc < 0) {\n    return [];\n  }\n\n  // if disc == 0 ... dealt with later\n  var tmpSqrt = sqrt(disc);\n  var abScalingFactor1 = -pBy2 + tmpSqrt;\n  var abScalingFactor2 = -pBy2 - tmpSqrt;\n  var i1 = {\n    x: s1.x - baX * abScalingFactor1,\n    y: s1.y - baY * abScalingFactor1\n  };\n  if (disc === 0) {\n    // abScalingFactor1 == abScalingFactor2\n    return [i1];\n  }\n  var i2 = {\n    x: s1.x - baX * abScalingFactor2,\n    y: s1.y - baY * abScalingFactor2\n  };\n\n  // return only points on line segment\n  return [i1, i2].filter(function (p) {\n    return isPointInSegment(p, s1, s2);\n  });\n}\nfunction isPointInSegment(p, segmentStart, segmentEnd) {\n  return fenced(p.x, segmentStart.x, segmentEnd.x) && fenced(p.y, segmentStart.y, segmentEnd.y);\n}\nfunction fenced(n, rangeStart, rangeEnd) {\n  // use matching threshold to work around\n  // precision errors in intersection computation\n\n  return n >= min(rangeStart, rangeEnd) - EQUAL_THRESHOLD && n <= max(rangeStart, rangeEnd) + EQUAL_THRESHOLD;\n}\n\n/**\n * Calculate the mid between two points.\n *\n * @param {Point} p1\n * @param {Point} p2\n *\n * @return {Point}\n */\nfunction mid(p1, p2) {\n  return {\n    x: (p1.x + p2.x) / 2,\n    y: (p1.y + p2.y) / 2\n  };\n}\nvar EQUAL_THRESHOLD = 0.1;\nfunction pointsEqual(p1, p2) {\n  return abs(p1.x - p2.x) <= EQUAL_THRESHOLD && abs(p1.y - p2.y) <= EQUAL_THRESHOLD;\n}","map":{"version":3,"names":["sqrt","Math","min","max","abs","sq","n","pow","getDistance","p1","p2","x","y","getAttachment","point","line","idx","segmentStart","segmentEnd","segmentStartDistance","segmentEndDistance","attachmentPosition","minDistance","intersections","attachment","attachmentDistance","closestAttachmentDistance","closestAttachment","length","pointsEqual","getCircleSegmentIntersections","Error","type","position","segmentIndex","bendpointIndex","mid","relativeLocation","s1","s2","cc","cr","baX","baY","caX","caY","a","bBy2","c","pBy2","q","disc","tmpSqrt","abScalingFactor1","abScalingFactor2","i1","i2","filter","p","isPointInSegment","fenced","rangeStart","rangeEnd","EQUAL_THRESHOLD"],"sources":["/home/runner/work/sgex/sgex/node_modules/bpmn-js/lib/features/modeling/behavior/util/LineAttachmentUtil.js"],"sourcesContent":["/**\n * @typedef {import('diagram-js/lib/util/Types').Point} Point\n *\n * @typedef { {\n*   type: 'bendpoint' | 'segment';\n*   position: Point;\n*   segmentIndex: number;\n*   bendpointIndex?: number;\n*   relativeLocation?: number;\n* } } Attachment\n*/\n\nvar sqrt = Math.sqrt,\n    min = Math.min,\n    max = Math.max,\n    abs = Math.abs;\n\n/**\n * Calculate the square (power to two) of a number.\n *\n * @param {number} n\n *\n * @return {number}\n */\nfunction sq(n) {\n  return Math.pow(n, 2);\n}\n\n/**\n * Get distance between two points.\n *\n * @param {Point} p1\n * @param {Point} p2\n *\n * @return {number}\n */\nfunction getDistance(p1, p2) {\n  return sqrt(sq(p1.x - p2.x) + sq(p1.y - p2.y));\n}\n\n/**\n * Return the attachment of the given point on the specified line.\n *\n * The attachment is either a bendpoint (attached to the given point)\n * or segment (attached to a location on a line segment) attachment:\n *\n * ```javascript\n * var pointAttachment = {\n *   type: 'bendpoint',\n *   bendpointIndex: 3,\n *   position: { x: 10, y: 10 } // the attach point on the line\n * };\n *\n * var segmentAttachment = {\n *   type: 'segment',\n *   segmentIndex: 2,\n *   relativeLocation: 0.31, // attach point location between 0 (at start) and 1 (at end)\n *   position: { x: 10, y: 10 } // the attach point on the line\n * };\n * ```\n *\n * @param {Point} point\n * @param {Point[]} line\n *\n * @return {Attachment}\n */\nexport function getAttachment(point, line) {\n\n  var idx = 0,\n      segmentStart,\n      segmentEnd,\n      segmentStartDistance,\n      segmentEndDistance,\n      attachmentPosition,\n      minDistance,\n      intersections,\n      attachment,\n      attachmentDistance,\n      closestAttachmentDistance,\n      closestAttachment;\n\n  for (idx = 0; idx < line.length - 1; idx++) {\n\n    segmentStart = line[idx];\n    segmentEnd = line[idx + 1];\n\n    if (pointsEqual(segmentStart, segmentEnd)) {\n      intersections = [ segmentStart ];\n    } else {\n      segmentStartDistance = getDistance(point, segmentStart);\n      segmentEndDistance = getDistance(point, segmentEnd);\n\n      minDistance = min(segmentStartDistance, segmentEndDistance);\n\n      intersections = getCircleSegmentIntersections(segmentStart, segmentEnd, point, minDistance);\n    }\n\n    if (intersections.length < 1) {\n      throw new Error('expected between [1, 2] circle -> line intersections');\n    }\n\n    // one intersection -> bendpoint attachment\n    if (intersections.length === 1) {\n      attachment = {\n        type: 'bendpoint',\n        position: intersections[0],\n        segmentIndex: idx,\n        bendpointIndex: pointsEqual(segmentStart, intersections[0]) ? idx : idx + 1\n      };\n    }\n\n    // two intersections -> segment attachment\n    if (intersections.length === 2) {\n\n      attachmentPosition = mid(intersections[0], intersections[1]);\n\n      attachment = {\n        type: 'segment',\n        position: attachmentPosition,\n        segmentIndex: idx,\n        relativeLocation: getDistance(segmentStart, attachmentPosition) / getDistance(segmentStart, segmentEnd)\n      };\n    }\n\n    attachmentDistance = getDistance(attachment.position, point);\n\n    if (!closestAttachment || closestAttachmentDistance > attachmentDistance) {\n      closestAttachment = attachment;\n      closestAttachmentDistance = attachmentDistance;\n    }\n  }\n\n  return closestAttachment;\n}\n\n/**\n * Get the intersection between a circle and a line segment.\n *\n * @param {Point} s1 segment start\n * @param {Point} s2 segment end\n * @param {Point} cc circle center\n * @param {number} cr circle radius\n *\n * @return {Point[]} intersections\n */\nfunction getCircleSegmentIntersections(s1, s2, cc, cr) {\n\n  var baX = s2.x - s1.x;\n  var baY = s2.y - s1.y;\n  var caX = cc.x - s1.x;\n  var caY = cc.y - s1.y;\n\n  var a = baX * baX + baY * baY;\n  var bBy2 = baX * caX + baY * caY;\n  var c = caX * caX + caY * caY - cr * cr;\n\n  var pBy2 = bBy2 / a;\n  var q = c / a;\n\n  var disc = pBy2 * pBy2 - q;\n\n  // check against negative value to work around\n  // negative, very close to zero results (-4e-15)\n  // being produced in some environments\n  if (disc < 0 && disc > -0.000001) {\n    disc = 0;\n  }\n\n  if (disc < 0) {\n    return [];\n  }\n\n  // if disc == 0 ... dealt with later\n  var tmpSqrt = sqrt(disc);\n  var abScalingFactor1 = -pBy2 + tmpSqrt;\n  var abScalingFactor2 = -pBy2 - tmpSqrt;\n\n  var i1 = {\n    x: s1.x - baX * abScalingFactor1,\n    y: s1.y - baY * abScalingFactor1\n  };\n\n  if (disc === 0) { // abScalingFactor1 == abScalingFactor2\n    return [ i1 ];\n  }\n\n  var i2 = {\n    x: s1.x - baX * abScalingFactor2,\n    y: s1.y - baY * abScalingFactor2\n  };\n\n  // return only points on line segment\n  return [ i1, i2 ].filter(function(p) {\n    return isPointInSegment(p, s1, s2);\n  });\n}\n\n\nfunction isPointInSegment(p, segmentStart, segmentEnd) {\n  return (\n    fenced(p.x, segmentStart.x, segmentEnd.x) &&\n    fenced(p.y, segmentStart.y, segmentEnd.y)\n  );\n}\n\nfunction fenced(n, rangeStart, rangeEnd) {\n\n  // use matching threshold to work around\n  // precision errors in intersection computation\n\n  return (\n    n >= min(rangeStart, rangeEnd) - EQUAL_THRESHOLD &&\n    n <= max(rangeStart, rangeEnd) + EQUAL_THRESHOLD\n  );\n}\n\n/**\n * Calculate the mid between two points.\n *\n * @param {Point} p1\n * @param {Point} p2\n *\n * @return {Point}\n */\nfunction mid(p1, p2) {\n\n  return {\n    x: (p1.x + p2.x) / 2,\n    y: (p1.y + p2.y) / 2\n  };\n}\n\nvar EQUAL_THRESHOLD = 0.1;\n\nfunction pointsEqual(p1, p2) {\n\n  return (\n    abs(p1.x - p2.x) <= EQUAL_THRESHOLD &&\n    abs(p1.y - p2.y) <= EQUAL_THRESHOLD\n  );\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}