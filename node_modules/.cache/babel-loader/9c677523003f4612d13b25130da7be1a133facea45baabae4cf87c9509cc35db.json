{"ast":null,"code":"import { assign, find, isArray, without } from 'min-dash';\nimport { getOrientation, getMid } from './LayoutUtil';\nimport { pointInRect, pointDistance, pointsAligned, pointsOnLine } from '../util/Geometry';\n\n/**\n * @typedef {import('../util/Types').Point} Point\n * @typedef {import('../util/Types').Rect} Rect\n */\n\nvar MIN_SEGMENT_LENGTH = 20,\n  POINT_ORIENTATION_PADDING = 5;\nvar round = Math.round;\nvar INTERSECTION_THRESHOLD = 20,\n  ORIENTATION_THRESHOLD = {\n    'h:h': 20,\n    'v:v': 20,\n    'h:v': -10,\n    'v:h': -10\n  };\nfunction needsTurn(orientation, startDirection) {\n  return !{\n    t: /top/,\n    r: /right/,\n    b: /bottom/,\n    l: /left/,\n    h: /./,\n    v: /./\n  }[startDirection].test(orientation);\n}\nfunction canLayoutStraight(direction, targetOrientation) {\n  return {\n    t: /top/,\n    r: /right/,\n    b: /bottom/,\n    l: /left/,\n    h: /left|right/,\n    v: /top|bottom/\n  }[direction].test(targetOrientation);\n}\nfunction getSegmentBendpoints(a, b, directions) {\n  var orientation = getOrientation(b, a, POINT_ORIENTATION_PADDING);\n  var startDirection = directions.split(':')[0];\n  var xmid = round((b.x - a.x) / 2 + a.x),\n    ymid = round((b.y - a.y) / 2 + a.y);\n  var segmentEnd, segmentDirections;\n  var layoutStraight = canLayoutStraight(startDirection, orientation),\n    layoutHorizontal = /h|r|l/.test(startDirection),\n    layoutTurn = false;\n  var turnNextDirections = false;\n  if (layoutStraight) {\n    segmentEnd = layoutHorizontal ? {\n      x: xmid,\n      y: a.y\n    } : {\n      x: a.x,\n      y: ymid\n    };\n    segmentDirections = layoutHorizontal ? 'h:h' : 'v:v';\n  } else {\n    layoutTurn = needsTurn(orientation, startDirection);\n    segmentDirections = layoutHorizontal ? 'h:v' : 'v:h';\n    if (layoutTurn) {\n      if (layoutHorizontal) {\n        turnNextDirections = ymid === a.y;\n        segmentEnd = {\n          x: a.x + MIN_SEGMENT_LENGTH * (/l/.test(startDirection) ? -1 : 1),\n          y: turnNextDirections ? ymid + MIN_SEGMENT_LENGTH : ymid\n        };\n      } else {\n        turnNextDirections = xmid === a.x;\n        segmentEnd = {\n          x: turnNextDirections ? xmid + MIN_SEGMENT_LENGTH : xmid,\n          y: a.y + MIN_SEGMENT_LENGTH * (/t/.test(startDirection) ? -1 : 1)\n        };\n      }\n    } else {\n      segmentEnd = {\n        x: xmid,\n        y: ymid\n      };\n    }\n  }\n  return {\n    waypoints: getBendpoints(a, segmentEnd, segmentDirections).concat(segmentEnd),\n    directions: segmentDirections,\n    turnNextDirections: turnNextDirections\n  };\n}\nfunction getStartSegment(a, b, directions) {\n  return getSegmentBendpoints(a, b, directions);\n}\nfunction getEndSegment(a, b, directions) {\n  var invertedSegment = getSegmentBendpoints(b, a, invertDirections(directions));\n  return {\n    waypoints: invertedSegment.waypoints.slice().reverse(),\n    directions: invertDirections(invertedSegment.directions),\n    turnNextDirections: invertedSegment.turnNextDirections\n  };\n}\nfunction getMidSegment(startSegment, endSegment) {\n  var startDirection = startSegment.directions.split(':')[1],\n    endDirection = endSegment.directions.split(':')[0];\n  if (startSegment.turnNextDirections) {\n    startDirection = startDirection == 'h' ? 'v' : 'h';\n  }\n  if (endSegment.turnNextDirections) {\n    endDirection = endDirection == 'h' ? 'v' : 'h';\n  }\n  var directions = startDirection + ':' + endDirection;\n  var bendpoints = getBendpoints(startSegment.waypoints[startSegment.waypoints.length - 1], endSegment.waypoints[0], directions);\n  return {\n    waypoints: bendpoints,\n    directions: directions\n  };\n}\nfunction invertDirections(directions) {\n  return directions.split(':').reverse().join(':');\n}\n\n/**\n * Handle simple layouts with maximum two bendpoints.\n */\nfunction getSimpleBendpoints(a, b, directions) {\n  var xmid = round((b.x - a.x) / 2 + a.x),\n    ymid = round((b.y - a.y) / 2 + a.y);\n\n  // one point, right or left from a\n  if (directions === 'h:v') {\n    return [{\n      x: b.x,\n      y: a.y\n    }];\n  }\n\n  // one point, above or below a\n  if (directions === 'v:h') {\n    return [{\n      x: a.x,\n      y: b.y\n    }];\n  }\n\n  // vertical segment between a and b\n  if (directions === 'h:h') {\n    return [{\n      x: xmid,\n      y: a.y\n    }, {\n      x: xmid,\n      y: b.y\n    }];\n  }\n\n  // horizontal segment between a and b\n  if (directions === 'v:v') {\n    return [{\n      x: a.x,\n      y: ymid\n    }, {\n      x: b.x,\n      y: ymid\n    }];\n  }\n  throw new Error('invalid directions: can only handle varians of [hv]:[hv]');\n}\n\n/**\n * Returns the mid points for a manhattan connection between two points.\n *\n * @example h:h (horizontal:horizontal)\n *\n * [a]----[x]\n *         |\n *        [x]----[b]\n *\n * @example h:v (horizontal:vertical)\n *\n * [a]----[x]\n *         |\n *        [b]\n *\n * @example h:r (horizontal:right)\n *\n * [a]----[x]\n *         |\n *    [b]-[x]\n *\n * @param {Point} a\n * @param {Point} b\n * @param {string} directions\n *\n * @return {Point[]}\n */\nfunction getBendpoints(a, b, directions) {\n  directions = directions || 'h:h';\n  if (!isValidDirections(directions)) {\n    throw new Error('unknown directions: <' + directions + '>: ' + 'must be specified as <start>:<end> ' + 'with start/end in { h,v,t,r,b,l }');\n  }\n\n  // compute explicit directions, involving trbl dockings\n  // using a three segmented layouting algorithm\n  if (isExplicitDirections(directions)) {\n    var startSegment = getStartSegment(a, b, directions),\n      endSegment = getEndSegment(a, b, directions),\n      midSegment = getMidSegment(startSegment, endSegment);\n    return [].concat(startSegment.waypoints, midSegment.waypoints, endSegment.waypoints);\n  }\n\n  // handle simple [hv]:[hv] cases that can be easily computed\n  return getSimpleBendpoints(a, b, directions);\n}\n\n/**\n * Create a connection between the two points according\n * to the manhattan layout (only horizontal and vertical) edges.\n *\n * @param {Point} a\n * @param {Point} b\n * @param {string} [directions='h:h'] Specifies manhattan directions for each\n * point as {direction}:{direction}. A direction for a point is either\n * `h` (horizontal) or `v` (vertical).\n *\n * @return {Point[]}\n */\nexport function connectPoints(a, b, directions) {\n  var points = getBendpoints(a, b, directions);\n  points.unshift(a);\n  points.push(b);\n  return withoutRedundantPoints(points);\n}\n\n/**\n * Connect two rectangles using a manhattan layouted connection.\n *\n * @param {Rect} source source rectangle\n * @param {Rect} target target rectangle\n * @param {Point} [start] source docking\n * @param {Point} [end] target docking\n * @param {Object} [hints]\n * @param {string} [hints.preserveDocking=source] preserve docking on selected side\n * @param {string[]} [hints.preferredLayouts]\n * @param {Point|boolean} [hints.connectionStart] whether the start changed\n * @param {Point|boolean} [hints.connectionEnd] whether the end changed\n *\n * @return {Point[]} connection points\n */\nexport function connectRectangles(source, target, start, end, hints) {\n  var preferredLayouts = hints && hints.preferredLayouts || [];\n  var preferredLayout = without(preferredLayouts, 'straight')[0] || 'h:h';\n  var threshold = ORIENTATION_THRESHOLD[preferredLayout] || 0;\n  var orientation = getOrientation(source, target, threshold);\n  var directions = getDirections(orientation, preferredLayout);\n  start = start || getMid(source);\n  end = end || getMid(target);\n  var directionSplit = directions.split(':');\n\n  // compute actual docking points for start / end\n  // this ensures we properly layout only parts of the\n  // connection that lies in between the two rectangles\n  var startDocking = getDockingPoint(start, source, directionSplit[0], invertOrientation(orientation)),\n    endDocking = getDockingPoint(end, target, directionSplit[1], orientation);\n  return connectPoints(startDocking, endDocking, directions);\n}\n\n/**\n * Repair the connection between two rectangles, of which one has been updated.\n *\n * @param {Rect} source\n * @param {Rect} target\n * @param {Point} [start]\n * @param {Point} [end]\n * @param {Point[]} [waypoints]\n * @param {Object} [hints]\n * @param {string[]} [hints.preferredLayouts] The list of preferred layouts.\n * @param {boolean} [hints.connectionStart]\n * @param {boolean} [hints.connectionEnd]\n *\n * @return {Point[]} The waypoints of the repaired connection.\n */\nexport function repairConnection(source, target, start, end, waypoints, hints) {\n  if (isArray(start)) {\n    waypoints = start;\n    hints = end;\n    start = getMid(source);\n    end = getMid(target);\n  }\n  hints = assign({\n    preferredLayouts: []\n  }, hints);\n  waypoints = waypoints || [];\n  var preferredLayouts = hints.preferredLayouts,\n    preferStraight = preferredLayouts.indexOf('straight') !== -1,\n    repairedWaypoints;\n\n  // just layout non-existing or simple connections\n  // attempt to render straight lines, if required\n\n  // attempt to layout a straight line\n  repairedWaypoints = preferStraight && tryLayoutStraight(source, target, start, end, hints);\n  if (repairedWaypoints) {\n    return repairedWaypoints;\n  }\n\n  // try to layout from end\n  repairedWaypoints = hints.connectionEnd && tryRepairConnectionEnd(target, source, end, waypoints);\n  if (repairedWaypoints) {\n    return repairedWaypoints;\n  }\n\n  // try to layout from start\n  repairedWaypoints = hints.connectionStart && tryRepairConnectionStart(source, target, start, waypoints);\n  if (repairedWaypoints) {\n    return repairedWaypoints;\n  }\n\n  // or whether nothing seems to have changed\n  if (!hints.connectionStart && !hints.connectionEnd && waypoints && waypoints.length) {\n    return waypoints;\n  }\n\n  // simply reconnect if nothing else worked\n  return connectRectangles(source, target, start, end, hints);\n}\nfunction inRange(a, start, end) {\n  return a >= start && a <= end;\n}\nfunction isInRange(axis, a, b) {\n  var size = {\n    x: 'width',\n    y: 'height'\n  };\n  return inRange(a[axis], b[axis], b[axis] + b[size[axis]]);\n}\n\n/**\n * Lay out a straight connection.\n *\n * @param {Rect} source\n * @param {Rect} target\n * @param {Point} start\n * @param {Point} end\n * @param {Object} [hints]\n * @param {string} [hints.preserveDocking]\n *\n * @return {Point[]|null} The waypoints or null if layout isn't possible.\n */\nexport function tryLayoutStraight(source, target, start, end, hints) {\n  var axis = {},\n    primaryAxis,\n    orientation;\n  orientation = getOrientation(source, target);\n\n  // only layout a straight connection if shapes are\n  // horizontally or vertically aligned\n  if (!/^(top|bottom|left|right)$/.test(orientation)) {\n    return null;\n  }\n  if (/top|bottom/.test(orientation)) {\n    primaryAxis = 'x';\n  }\n  if (/left|right/.test(orientation)) {\n    primaryAxis = 'y';\n  }\n  if (hints.preserveDocking === 'target') {\n    if (!isInRange(primaryAxis, end, source)) {\n      return null;\n    }\n    axis[primaryAxis] = end[primaryAxis];\n    return [{\n      x: axis.x !== undefined ? axis.x : start.x,\n      y: axis.y !== undefined ? axis.y : start.y,\n      original: {\n        x: axis.x !== undefined ? axis.x : start.x,\n        y: axis.y !== undefined ? axis.y : start.y\n      }\n    }, {\n      x: end.x,\n      y: end.y\n    }];\n  } else {\n    if (!isInRange(primaryAxis, start, target)) {\n      return null;\n    }\n    axis[primaryAxis] = start[primaryAxis];\n    return [{\n      x: start.x,\n      y: start.y\n    }, {\n      x: axis.x !== undefined ? axis.x : end.x,\n      y: axis.y !== undefined ? axis.y : end.y,\n      original: {\n        x: axis.x !== undefined ? axis.x : end.x,\n        y: axis.y !== undefined ? axis.y : end.y\n      }\n    }];\n  }\n}\n\n/**\n * Repair a connection from start.\n *\n * @param {Rect} moved\n * @param {Rect} other\n * @param {Point} newDocking\n * @param {Point[]} points originalPoints from moved to other\n *\n * @return {Point[]|null} The waypoints of the repaired connection.\n */\nfunction tryRepairConnectionStart(moved, other, newDocking, points) {\n  return _tryRepairConnectionSide(moved, other, newDocking, points);\n}\n\n/**\n * Repair a connection from end.\n *\n * @param {Rect} moved\n * @param {Rect} other\n * @param {Point} newDocking\n * @param {Point[]} points originalPoints from moved to other\n *\n * @return {Point[]|null} The waypoints of the repaired connection.\n */\nfunction tryRepairConnectionEnd(moved, other, newDocking, points) {\n  var waypoints = points.slice().reverse();\n  waypoints = _tryRepairConnectionSide(moved, other, newDocking, waypoints);\n  return waypoints ? waypoints.reverse() : null;\n}\n\n/**\n * Repair a connection from one side that moved.\n *\n * @param {Rect} moved\n * @param {Rect} other\n * @param {Point} newDocking\n * @param {Point[]} points originalPoints from moved to other\n *\n * @return {Point[]} The waypoints of the repaired connection.\n */\nfunction _tryRepairConnectionSide(moved, other, newDocking, points) {\n  function needsRelayout(points) {\n    if (points.length < 3) {\n      return true;\n    }\n    if (points.length > 4) {\n      return false;\n    }\n\n    // relayout if two points overlap\n    // this is most likely due to\n    return !!find(points, function (p, idx) {\n      var q = points[idx - 1];\n      return q && pointDistance(p, q) < 3;\n    });\n  }\n  function repairBendpoint(candidate, oldPeer, newPeer) {\n    var alignment = pointsAligned(oldPeer, candidate);\n    switch (alignment) {\n      case 'v':\n        // repair horizontal alignment\n        return {\n          x: newPeer.x,\n          y: candidate.y\n        };\n      case 'h':\n        // repair vertical alignment\n        return {\n          x: candidate.x,\n          y: newPeer.y\n        };\n    }\n    return {\n      x: candidate.x,\n      y: candidate.y\n    };\n  }\n  function removeOverlapping(points, a, b) {\n    var i;\n    for (i = points.length - 2; i !== 0; i--) {\n      // intersects (?) break, remove all bendpoints up to this one and relayout\n      if (pointInRect(points[i], a, INTERSECTION_THRESHOLD) || pointInRect(points[i], b, INTERSECTION_THRESHOLD)) {\n        // return sliced old connection\n        return points.slice(i);\n      }\n    }\n    return points;\n  }\n\n  // (0) only repair what has layoutable bendpoints\n\n  // (1) if only one bendpoint and on shape moved onto other shapes axis\n  //     (horizontally / vertically), relayout\n\n  if (needsRelayout(points)) {\n    return null;\n  }\n  var oldDocking = points[0],\n    newPoints = points.slice(),\n    slicedPoints;\n\n  // (2) repair only last line segment and only if it was layouted before\n\n  newPoints[0] = newDocking;\n  newPoints[1] = repairBendpoint(newPoints[1], oldDocking, newDocking);\n\n  // (3) if shape intersects with any bendpoint after repair,\n  //     remove all segments up to this bendpoint and repair from there\n  slicedPoints = removeOverlapping(newPoints, moved, other);\n  if (slicedPoints !== newPoints) {\n    newPoints = _tryRepairConnectionSide(moved, other, newDocking, slicedPoints);\n  }\n\n  // (4) do NOT repair if repaired bendpoints are aligned\n  if (newPoints && pointsAligned(newPoints)) {\n    return null;\n  }\n  return newPoints;\n}\n\n/**\n * Returns the manhattan directions connecting two rectangles\n * with the given orientation.\n *\n * Will always return the default layout, if it is specific\n * regarding sides already (trbl).\n *\n * @example\n *\n * ```javascript\n * getDirections('top'); // -> 'v:v'\n * getDirections('intersect'); // -> 't:t'\n *\n * getDirections('top-right', 'v:h'); // -> 'v:h'\n * getDirections('top-right', 'h:h'); // -> 'h:h'\n * ```\n *\n * @param {string} orientation\n * @param {string} defaultLayout\n *\n * @return {string}\n */\nfunction getDirections(orientation, defaultLayout) {\n  // don't override specific trbl directions\n  if (isExplicitDirections(defaultLayout)) {\n    return defaultLayout;\n  }\n  switch (orientation) {\n    case 'intersect':\n      return 't:t';\n    case 'top':\n    case 'bottom':\n      return 'v:v';\n    case 'left':\n    case 'right':\n      return 'h:h';\n\n    // 'top-left'\n    // 'top-right'\n    // 'bottom-left'\n    // 'bottom-right'\n    default:\n      return defaultLayout;\n  }\n}\nfunction isValidDirections(directions) {\n  return directions && /^h|v|t|r|b|l:h|v|t|r|b|l$/.test(directions);\n}\nfunction isExplicitDirections(directions) {\n  return directions && /t|r|b|l/.test(directions);\n}\nfunction invertOrientation(orientation) {\n  return {\n    'top': 'bottom',\n    'bottom': 'top',\n    'left': 'right',\n    'right': 'left',\n    'top-left': 'bottom-right',\n    'bottom-right': 'top-left',\n    'top-right': 'bottom-left',\n    'bottom-left': 'top-right'\n  }[orientation];\n}\nfunction getDockingPoint(point, rectangle, dockingDirection, targetOrientation) {\n  // ensure we end up with a specific docking direction\n  // based on the targetOrientation, if <h|v> is being passed\n\n  if (dockingDirection === 'h') {\n    dockingDirection = /left/.test(targetOrientation) ? 'l' : 'r';\n  }\n  if (dockingDirection === 'v') {\n    dockingDirection = /top/.test(targetOrientation) ? 't' : 'b';\n  }\n  if (dockingDirection === 't') {\n    return {\n      original: point,\n      x: point.x,\n      y: rectangle.y\n    };\n  }\n  if (dockingDirection === 'r') {\n    return {\n      original: point,\n      x: rectangle.x + rectangle.width,\n      y: point.y\n    };\n  }\n  if (dockingDirection === 'b') {\n    return {\n      original: point,\n      x: point.x,\n      y: rectangle.y + rectangle.height\n    };\n  }\n  if (dockingDirection === 'l') {\n    return {\n      original: point,\n      x: rectangle.x,\n      y: point.y\n    };\n  }\n  throw new Error('unexpected dockingDirection: <' + dockingDirection + '>');\n}\n\n/**\n * Return list of waypoints with redundant ones filtered out.\n *\n * @example\n *\n * Original points:\n *\n *   [x] ----- [x] ------ [x]\n *                         |\n *                        [x] ----- [x] - [x]\n *\n * Filtered:\n *\n *   [x] ---------------- [x]\n *                         |\n *                        [x] ----------- [x]\n *\n * @param {Point[]} waypoints\n *\n * @return {Point[]}\n */\nexport function withoutRedundantPoints(waypoints) {\n  return waypoints.reduce(function (points, p, idx) {\n    var previous = points[points.length - 1],\n      next = waypoints[idx + 1];\n    if (!pointsOnLine(previous, next, p, 0)) {\n      points.push(p);\n    }\n    return points;\n  }, []);\n}","map":{"version":3,"names":["assign","find","isArray","without","getOrientation","getMid","pointInRect","pointDistance","pointsAligned","pointsOnLine","MIN_SEGMENT_LENGTH","POINT_ORIENTATION_PADDING","round","Math","INTERSECTION_THRESHOLD","ORIENTATION_THRESHOLD","needsTurn","orientation","startDirection","t","r","b","l","h","v","test","canLayoutStraight","direction","targetOrientation","getSegmentBendpoints","a","directions","split","xmid","x","ymid","y","segmentEnd","segmentDirections","layoutStraight","layoutHorizontal","layoutTurn","turnNextDirections","waypoints","getBendpoints","concat","getStartSegment","getEndSegment","invertedSegment","invertDirections","slice","reverse","getMidSegment","startSegment","endSegment","endDirection","bendpoints","length","join","getSimpleBendpoints","Error","isValidDirections","isExplicitDirections","midSegment","connectPoints","points","unshift","push","withoutRedundantPoints","connectRectangles","source","target","start","end","hints","preferredLayouts","preferredLayout","threshold","getDirections","directionSplit","startDocking","getDockingPoint","invertOrientation","endDocking","repairConnection","preferStraight","indexOf","repairedWaypoints","tryLayoutStraight","connectionEnd","tryRepairConnectionEnd","connectionStart","tryRepairConnectionStart","inRange","isInRange","axis","size","primaryAxis","preserveDocking","undefined","original","moved","other","newDocking","_tryRepairConnectionSide","needsRelayout","p","idx","q","repairBendpoint","candidate","oldPeer","newPeer","alignment","removeOverlapping","i","oldDocking","newPoints","slicedPoints","defaultLayout","point","rectangle","dockingDirection","width","height","reduce","previous","next"],"sources":["/home/runner/work/sgex/sgex/node_modules/diagram-js/lib/layout/ManhattanLayout.js"],"sourcesContent":["import {\n  assign,\n  find,\n  isArray,\n  without\n} from 'min-dash';\n\nimport {\n  getOrientation,\n  getMid\n} from './LayoutUtil';\n\nimport {\n  pointInRect,\n  pointDistance,\n  pointsAligned,\n  pointsOnLine\n} from '../util/Geometry';\n\n/**\n * @typedef {import('../util/Types').Point} Point\n * @typedef {import('../util/Types').Rect} Rect\n */\n\nvar MIN_SEGMENT_LENGTH = 20,\n    POINT_ORIENTATION_PADDING = 5;\n\nvar round = Math.round;\n\nvar INTERSECTION_THRESHOLD = 20,\n    ORIENTATION_THRESHOLD = {\n      'h:h': 20,\n      'v:v': 20,\n      'h:v': -10,\n      'v:h': -10\n    };\n\nfunction needsTurn(orientation, startDirection) {\n  return !{\n    t: /top/,\n    r: /right/,\n    b: /bottom/,\n    l: /left/,\n    h: /./,\n    v: /./\n  }[startDirection].test(orientation);\n}\n\nfunction canLayoutStraight(direction, targetOrientation) {\n  return {\n    t: /top/,\n    r: /right/,\n    b: /bottom/,\n    l: /left/,\n    h: /left|right/,\n    v: /top|bottom/\n  }[direction].test(targetOrientation);\n}\n\nfunction getSegmentBendpoints(a, b, directions) {\n  var orientation = getOrientation(b, a, POINT_ORIENTATION_PADDING);\n\n  var startDirection = directions.split(':')[0];\n\n  var xmid = round((b.x - a.x) / 2 + a.x),\n      ymid = round((b.y - a.y) / 2 + a.y);\n\n  var segmentEnd, segmentDirections;\n\n  var layoutStraight = canLayoutStraight(startDirection, orientation),\n      layoutHorizontal = /h|r|l/.test(startDirection),\n      layoutTurn = false;\n\n  var turnNextDirections = false;\n\n  if (layoutStraight) {\n    segmentEnd = layoutHorizontal ? { x: xmid, y: a.y } : { x: a.x, y: ymid };\n\n    segmentDirections = layoutHorizontal ? 'h:h' : 'v:v';\n  } else {\n    layoutTurn = needsTurn(orientation, startDirection);\n\n    segmentDirections = layoutHorizontal ? 'h:v' : 'v:h';\n\n    if (layoutTurn) {\n\n      if (layoutHorizontal) {\n        turnNextDirections = ymid === a.y;\n\n        segmentEnd = {\n          x: a.x + MIN_SEGMENT_LENGTH * (/l/.test(startDirection) ? -1 : 1),\n          y: turnNextDirections ? ymid + MIN_SEGMENT_LENGTH : ymid\n        };\n      } else {\n        turnNextDirections = xmid === a.x;\n\n        segmentEnd = {\n          x: turnNextDirections ? xmid + MIN_SEGMENT_LENGTH : xmid,\n          y: a.y + MIN_SEGMENT_LENGTH * (/t/.test(startDirection) ? -1 : 1)\n        };\n      }\n\n    } else {\n      segmentEnd = {\n        x: xmid,\n        y: ymid\n      };\n    }\n  }\n\n  return {\n    waypoints: getBendpoints(a, segmentEnd, segmentDirections).concat(segmentEnd),\n    directions:  segmentDirections,\n    turnNextDirections: turnNextDirections\n  };\n}\n\nfunction getStartSegment(a, b, directions) {\n  return getSegmentBendpoints(a, b, directions);\n}\n\nfunction getEndSegment(a, b, directions) {\n  var invertedSegment = getSegmentBendpoints(b, a, invertDirections(directions));\n\n  return {\n    waypoints: invertedSegment.waypoints.slice().reverse(),\n    directions: invertDirections(invertedSegment.directions),\n    turnNextDirections: invertedSegment.turnNextDirections\n  };\n}\n\nfunction getMidSegment(startSegment, endSegment) {\n\n  var startDirection = startSegment.directions.split(':')[1],\n      endDirection = endSegment.directions.split(':')[0];\n\n  if (startSegment.turnNextDirections) {\n    startDirection = startDirection == 'h' ? 'v' : 'h';\n  }\n\n  if (endSegment.turnNextDirections) {\n    endDirection = endDirection == 'h' ? 'v' : 'h';\n  }\n\n  var directions = startDirection + ':' + endDirection;\n\n  var bendpoints = getBendpoints(\n    startSegment.waypoints[startSegment.waypoints.length - 1],\n    endSegment.waypoints[0],\n    directions\n  );\n\n  return {\n    waypoints: bendpoints,\n    directions: directions\n  };\n}\n\nfunction invertDirections(directions) {\n  return directions.split(':').reverse().join(':');\n}\n\n/**\n * Handle simple layouts with maximum two bendpoints.\n */\nfunction getSimpleBendpoints(a, b, directions) {\n\n  var xmid = round((b.x - a.x) / 2 + a.x),\n      ymid = round((b.y - a.y) / 2 + a.y);\n\n  // one point, right or left from a\n  if (directions === 'h:v') {\n    return [ { x: b.x, y: a.y } ];\n  }\n\n  // one point, above or below a\n  if (directions === 'v:h') {\n    return [ { x: a.x, y: b.y } ];\n  }\n\n  // vertical segment between a and b\n  if (directions === 'h:h') {\n    return [\n      { x: xmid, y: a.y },\n      { x: xmid, y: b.y }\n    ];\n  }\n\n  // horizontal segment between a and b\n  if (directions === 'v:v') {\n    return [\n      { x: a.x, y: ymid },\n      { x: b.x, y: ymid }\n    ];\n  }\n\n  throw new Error('invalid directions: can only handle varians of [hv]:[hv]');\n}\n\n\n/**\n * Returns the mid points for a manhattan connection between two points.\n *\n * @example h:h (horizontal:horizontal)\n *\n * [a]----[x]\n *         |\n *        [x]----[b]\n *\n * @example h:v (horizontal:vertical)\n *\n * [a]----[x]\n *         |\n *        [b]\n *\n * @example h:r (horizontal:right)\n *\n * [a]----[x]\n *         |\n *    [b]-[x]\n *\n * @param {Point} a\n * @param {Point} b\n * @param {string} directions\n *\n * @return {Point[]}\n */\nfunction getBendpoints(a, b, directions) {\n  directions = directions || 'h:h';\n\n  if (!isValidDirections(directions)) {\n    throw new Error(\n      'unknown directions: <' + directions + '>: ' +\n      'must be specified as <start>:<end> ' +\n      'with start/end in { h,v,t,r,b,l }'\n    );\n  }\n\n  // compute explicit directions, involving trbl dockings\n  // using a three segmented layouting algorithm\n  if (isExplicitDirections(directions)) {\n    var startSegment = getStartSegment(a, b, directions),\n        endSegment = getEndSegment(a, b, directions),\n        midSegment = getMidSegment(startSegment, endSegment);\n\n    return [].concat(\n      startSegment.waypoints,\n      midSegment.waypoints,\n      endSegment.waypoints\n    );\n  }\n\n  // handle simple [hv]:[hv] cases that can be easily computed\n  return getSimpleBendpoints(a, b, directions);\n}\n\n/**\n * Create a connection between the two points according\n * to the manhattan layout (only horizontal and vertical) edges.\n *\n * @param {Point} a\n * @param {Point} b\n * @param {string} [directions='h:h'] Specifies manhattan directions for each\n * point as {direction}:{direction}. A direction for a point is either\n * `h` (horizontal) or `v` (vertical).\n *\n * @return {Point[]}\n */\nexport function connectPoints(a, b, directions) {\n\n  var points = getBendpoints(a, b, directions);\n\n  points.unshift(a);\n  points.push(b);\n\n  return withoutRedundantPoints(points);\n}\n\n\n/**\n * Connect two rectangles using a manhattan layouted connection.\n *\n * @param {Rect} source source rectangle\n * @param {Rect} target target rectangle\n * @param {Point} [start] source docking\n * @param {Point} [end] target docking\n * @param {Object} [hints]\n * @param {string} [hints.preserveDocking=source] preserve docking on selected side\n * @param {string[]} [hints.preferredLayouts]\n * @param {Point|boolean} [hints.connectionStart] whether the start changed\n * @param {Point|boolean} [hints.connectionEnd] whether the end changed\n *\n * @return {Point[]} connection points\n */\nexport function connectRectangles(source, target, start, end, hints) {\n\n  var preferredLayouts = hints && hints.preferredLayouts || [];\n\n  var preferredLayout = without(preferredLayouts, 'straight')[0] || 'h:h';\n\n  var threshold = ORIENTATION_THRESHOLD[preferredLayout] || 0;\n\n  var orientation = getOrientation(source, target, threshold);\n\n  var directions = getDirections(orientation, preferredLayout);\n\n  start = start || getMid(source);\n  end = end || getMid(target);\n\n  var directionSplit = directions.split(':');\n\n  // compute actual docking points for start / end\n  // this ensures we properly layout only parts of the\n  // connection that lies in between the two rectangles\n  var startDocking = getDockingPoint(start, source, directionSplit[0], invertOrientation(orientation)),\n      endDocking = getDockingPoint(end, target, directionSplit[1], orientation);\n\n  return connectPoints(startDocking, endDocking, directions);\n}\n\n\n/**\n * Repair the connection between two rectangles, of which one has been updated.\n *\n * @param {Rect} source\n * @param {Rect} target\n * @param {Point} [start]\n * @param {Point} [end]\n * @param {Point[]} [waypoints]\n * @param {Object} [hints]\n * @param {string[]} [hints.preferredLayouts] The list of preferred layouts.\n * @param {boolean} [hints.connectionStart]\n * @param {boolean} [hints.connectionEnd]\n *\n * @return {Point[]} The waypoints of the repaired connection.\n */\nexport function repairConnection(source, target, start, end, waypoints, hints) {\n\n  if (isArray(start)) {\n    waypoints = start;\n    hints = end;\n\n    start = getMid(source);\n    end = getMid(target);\n  }\n\n  hints = assign({ preferredLayouts: [] }, hints);\n  waypoints = waypoints || [];\n\n  var preferredLayouts = hints.preferredLayouts,\n      preferStraight = preferredLayouts.indexOf('straight') !== -1,\n      repairedWaypoints;\n\n  // just layout non-existing or simple connections\n  // attempt to render straight lines, if required\n\n  // attempt to layout a straight line\n  repairedWaypoints = preferStraight && tryLayoutStraight(source, target, start, end, hints);\n\n  if (repairedWaypoints) {\n    return repairedWaypoints;\n  }\n\n  // try to layout from end\n  repairedWaypoints = hints.connectionEnd && tryRepairConnectionEnd(target, source, end, waypoints);\n\n  if (repairedWaypoints) {\n    return repairedWaypoints;\n  }\n\n  // try to layout from start\n  repairedWaypoints = hints.connectionStart && tryRepairConnectionStart(source, target, start, waypoints);\n\n  if (repairedWaypoints) {\n    return repairedWaypoints;\n  }\n\n  // or whether nothing seems to have changed\n  if (!hints.connectionStart && !hints.connectionEnd && waypoints && waypoints.length) {\n    return waypoints;\n  }\n\n  // simply reconnect if nothing else worked\n  return connectRectangles(source, target, start, end, hints);\n}\n\n\nfunction inRange(a, start, end) {\n  return a >= start && a <= end;\n}\n\nfunction isInRange(axis, a, b) {\n  var size = {\n    x: 'width',\n    y: 'height'\n  };\n\n  return inRange(a[axis], b[axis], b[axis] + b[size[axis]]);\n}\n\n/**\n * Lay out a straight connection.\n *\n * @param {Rect} source\n * @param {Rect} target\n * @param {Point} start\n * @param {Point} end\n * @param {Object} [hints]\n * @param {string} [hints.preserveDocking]\n *\n * @return {Point[]|null} The waypoints or null if layout isn't possible.\n */\nexport function tryLayoutStraight(source, target, start, end, hints) {\n  var axis = {},\n      primaryAxis,\n      orientation;\n\n  orientation = getOrientation(source, target);\n\n  // only layout a straight connection if shapes are\n  // horizontally or vertically aligned\n  if (!/^(top|bottom|left|right)$/.test(orientation)) {\n    return null;\n  }\n\n  if (/top|bottom/.test(orientation)) {\n    primaryAxis = 'x';\n  }\n\n  if (/left|right/.test(orientation)) {\n    primaryAxis = 'y';\n  }\n\n  if (hints.preserveDocking === 'target') {\n\n    if (!isInRange(primaryAxis, end, source)) {\n      return null;\n    }\n\n    axis[primaryAxis] = end[primaryAxis];\n\n    return [\n      {\n        x: axis.x !== undefined ? axis.x : start.x,\n        y: axis.y !== undefined ? axis.y : start.y,\n        original: {\n          x: axis.x !== undefined ? axis.x : start.x,\n          y: axis.y !== undefined ? axis.y : start.y\n        }\n      },\n      {\n        x: end.x,\n        y: end.y\n      }\n    ];\n\n  } else {\n\n    if (!isInRange(primaryAxis, start, target)) {\n      return null;\n    }\n\n    axis[primaryAxis] = start[primaryAxis];\n\n    return [\n      {\n        x: start.x,\n        y: start.y\n      },\n      {\n        x: axis.x !== undefined ? axis.x : end.x,\n        y: axis.y !== undefined ? axis.y : end.y,\n        original: {\n          x: axis.x !== undefined ? axis.x : end.x,\n          y: axis.y !== undefined ? axis.y : end.y\n        }\n      }\n    ];\n  }\n\n}\n\n/**\n * Repair a connection from start.\n *\n * @param {Rect} moved\n * @param {Rect} other\n * @param {Point} newDocking\n * @param {Point[]} points originalPoints from moved to other\n *\n * @return {Point[]|null} The waypoints of the repaired connection.\n */\nfunction tryRepairConnectionStart(moved, other, newDocking, points) {\n  return _tryRepairConnectionSide(moved, other, newDocking, points);\n}\n\n/**\n * Repair a connection from end.\n *\n * @param {Rect} moved\n * @param {Rect} other\n * @param {Point} newDocking\n * @param {Point[]} points originalPoints from moved to other\n *\n * @return {Point[]|null} The waypoints of the repaired connection.\n */\nfunction tryRepairConnectionEnd(moved, other, newDocking, points) {\n  var waypoints = points.slice().reverse();\n\n  waypoints = _tryRepairConnectionSide(moved, other, newDocking, waypoints);\n\n  return waypoints ? waypoints.reverse() : null;\n}\n\n/**\n * Repair a connection from one side that moved.\n *\n * @param {Rect} moved\n * @param {Rect} other\n * @param {Point} newDocking\n * @param {Point[]} points originalPoints from moved to other\n *\n * @return {Point[]} The waypoints of the repaired connection.\n */\nfunction _tryRepairConnectionSide(moved, other, newDocking, points) {\n\n  function needsRelayout(points) {\n    if (points.length < 3) {\n      return true;\n    }\n\n    if (points.length > 4) {\n      return false;\n    }\n\n    // relayout if two points overlap\n    // this is most likely due to\n    return !!find(points, function(p, idx) {\n      var q = points[idx - 1];\n\n      return q && pointDistance(p, q) < 3;\n    });\n  }\n\n  function repairBendpoint(candidate, oldPeer, newPeer) {\n\n    var alignment = pointsAligned(oldPeer, candidate);\n\n    switch (alignment) {\n    case 'v':\n\n      // repair horizontal alignment\n      return { x: newPeer.x, y: candidate.y };\n    case 'h':\n\n      // repair vertical alignment\n      return { x: candidate.x, y: newPeer.y };\n    }\n\n    return { x: candidate.x, y: candidate. y };\n  }\n\n  function removeOverlapping(points, a, b) {\n    var i;\n\n    for (i = points.length - 2; i !== 0; i--) {\n\n      // intersects (?) break, remove all bendpoints up to this one and relayout\n      if (pointInRect(points[i], a, INTERSECTION_THRESHOLD) ||\n          pointInRect(points[i], b, INTERSECTION_THRESHOLD)) {\n\n        // return sliced old connection\n        return points.slice(i);\n      }\n    }\n\n    return points;\n  }\n\n  // (0) only repair what has layoutable bendpoints\n\n  // (1) if only one bendpoint and on shape moved onto other shapes axis\n  //     (horizontally / vertically), relayout\n\n  if (needsRelayout(points)) {\n    return null;\n  }\n\n  var oldDocking = points[0],\n      newPoints = points.slice(),\n      slicedPoints;\n\n  // (2) repair only last line segment and only if it was layouted before\n\n  newPoints[0] = newDocking;\n  newPoints[1] = repairBendpoint(newPoints[1], oldDocking, newDocking);\n\n\n  // (3) if shape intersects with any bendpoint after repair,\n  //     remove all segments up to this bendpoint and repair from there\n  slicedPoints = removeOverlapping(newPoints, moved, other);\n\n  if (slicedPoints !== newPoints) {\n    newPoints = _tryRepairConnectionSide(moved, other, newDocking, slicedPoints);\n  }\n\n  // (4) do NOT repair if repaired bendpoints are aligned\n  if (newPoints && pointsAligned(newPoints)) {\n    return null;\n  }\n\n  return newPoints;\n}\n\n\n/**\n * Returns the manhattan directions connecting two rectangles\n * with the given orientation.\n *\n * Will always return the default layout, if it is specific\n * regarding sides already (trbl).\n *\n * @example\n *\n * ```javascript\n * getDirections('top'); // -> 'v:v'\n * getDirections('intersect'); // -> 't:t'\n *\n * getDirections('top-right', 'v:h'); // -> 'v:h'\n * getDirections('top-right', 'h:h'); // -> 'h:h'\n * ```\n *\n * @param {string} orientation\n * @param {string} defaultLayout\n *\n * @return {string}\n */\nfunction getDirections(orientation, defaultLayout) {\n\n  // don't override specific trbl directions\n  if (isExplicitDirections(defaultLayout)) {\n    return defaultLayout;\n  }\n\n  switch (orientation) {\n  case 'intersect':\n    return 't:t';\n\n  case 'top':\n  case 'bottom':\n    return 'v:v';\n\n  case 'left':\n  case 'right':\n    return 'h:h';\n\n  // 'top-left'\n  // 'top-right'\n  // 'bottom-left'\n  // 'bottom-right'\n  default:\n    return defaultLayout;\n  }\n}\n\nfunction isValidDirections(directions) {\n  return directions && /^h|v|t|r|b|l:h|v|t|r|b|l$/.test(directions);\n}\n\nfunction isExplicitDirections(directions) {\n  return directions && /t|r|b|l/.test(directions);\n}\n\nfunction invertOrientation(orientation) {\n  return {\n    'top': 'bottom',\n    'bottom': 'top',\n    'left': 'right',\n    'right': 'left',\n    'top-left': 'bottom-right',\n    'bottom-right': 'top-left',\n    'top-right': 'bottom-left',\n    'bottom-left': 'top-right',\n  }[orientation];\n}\n\nfunction getDockingPoint(point, rectangle, dockingDirection, targetOrientation) {\n\n  // ensure we end up with a specific docking direction\n  // based on the targetOrientation, if <h|v> is being passed\n\n  if (dockingDirection === 'h') {\n    dockingDirection = /left/.test(targetOrientation) ? 'l' : 'r';\n  }\n\n  if (dockingDirection === 'v') {\n    dockingDirection = /top/.test(targetOrientation) ? 't' : 'b';\n  }\n\n  if (dockingDirection === 't') {\n    return { original: point, x: point.x, y: rectangle.y };\n  }\n\n  if (dockingDirection === 'r') {\n    return { original: point, x: rectangle.x + rectangle.width, y: point.y };\n  }\n\n  if (dockingDirection === 'b') {\n    return { original: point, x: point.x, y: rectangle.y + rectangle.height };\n  }\n\n  if (dockingDirection === 'l') {\n    return { original: point, x: rectangle.x, y: point.y };\n  }\n\n  throw new Error('unexpected dockingDirection: <' + dockingDirection + '>');\n}\n\n\n/**\n * Return list of waypoints with redundant ones filtered out.\n *\n * @example\n *\n * Original points:\n *\n *   [x] ----- [x] ------ [x]\n *                         |\n *                        [x] ----- [x] - [x]\n *\n * Filtered:\n *\n *   [x] ---------------- [x]\n *                         |\n *                        [x] ----------- [x]\n *\n * @param {Point[]} waypoints\n *\n * @return {Point[]}\n */\nexport function withoutRedundantPoints(waypoints) {\n  return waypoints.reduce(function(points, p, idx) {\n\n    var previous = points[points.length - 1],\n        next = waypoints[idx + 1];\n\n    if (!pointsOnLine(previous, next, p, 0)) {\n      points.push(p);\n    }\n\n    return points;\n  }, []);\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}