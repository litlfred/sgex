{"ast":null,"code":"/**\n * SecureTokenStorage - Secure storage for GitHub Personal Access Tokens\n * \n * Features:\n * - XOR encryption using browser fingerprint-based keys\n * - Token format validation (classic and fine-grained PATs)\n * - Automatic token expiration (24 hours)\n * - Secure token masking for logs and error messages\n */import logger from'../utils/logger';class SecureTokenStorage{constructor(){this.logger=logger.getLogger('SecureTokenStorage');this.storageKey='sgex_secure_token';this.expirationHours=24;this.logger.debug('SecureTokenStorage instance created');}/**\n   * Generate a browser fingerprint for encryption key\n   * @returns {string} Browser fingerprint\n   */generateBrowserFingerprint(){const canvas=document.createElement('canvas');const ctx=canvas.getContext('2d');ctx.textBaseline='top';ctx.font='14px Arial';ctx.fillText('Browser fingerprint',2,2);const fingerprint=[navigator.userAgent,navigator.language,window.screen.width+'x'+window.screen.height,window.screen.colorDepth,new Date().getTimezoneOffset(),canvas.toDataURL()].join('|');// Create a simple hash of the fingerprint\nlet hash=0;for(let i=0;i<fingerprint.length;i++){const char=fingerprint.charCodeAt(i);hash=(hash<<5)-hash+char;hash=hash&hash;// Convert to 32-bit integer\n}return Math.abs(hash).toString(36);}/**\n   * XOR encrypt/decrypt text using a key\n   * @param {string} text - Text to encrypt/decrypt\n   * @param {string} key - Encryption key\n   * @returns {string} Encrypted/decrypted text\n   */xorCipher(text,key){let result='';for(let i=0;i<text.length;i++){result+=String.fromCharCode(text.charCodeAt(i)^key.charCodeAt(i%key.length));}return result;}/**\n   * Validate GitHub Personal Access Token format\n   * @param {string} token - Token to validate\n   * @returns {object} Validation result with type and validity\n   */validateTokenFormat(token){if(!token||typeof token!=='string'){return{isValid:false,type:'invalid',reason:'Token is empty or not a string'};}// Remove any whitespace\nconst cleanToken=token.trim();// Classic Personal Access Token format: ghp_[36 characters A-Za-z0-9]\nif(cleanToken.match(/^ghp_[A-Za-z0-9]{36}$/)){return{isValid:true,type:'classic',token:cleanToken};}// Fine-grained Personal Access Token format: github_pat_[22 characters]_[59 characters]\nif(cleanToken.match(/^github_pat_[A-Za-z0-9]{22}_[A-Za-z0-9]{59}$/)){return{isValid:true,type:'fine-grained',token:cleanToken};}// OAuth token format: gho_[36 characters] (for completeness)\nif(cleanToken.match(/^gho_[A-Za-z0-9]{36}$/)){return{isValid:true,type:'oauth',token:cleanToken};}// Check for old-style tokens (40 hex characters) - deprecated but might still work\nif(cleanToken.match(/^[a-fA-F0-9]{40}$/)){return{isValid:true,type:'legacy',token:cleanToken};}return{isValid:false,type:'invalid',reason:'Token does not match expected GitHub PAT format'};}/**\n   * Mask token for safe logging\n   * @param {string} token - Token to mask\n   * @returns {string} Masked token\n   */maskToken(token){if(!token||typeof token!=='string'){return'[INVALID_TOKEN]';}const cleanToken=token.trim();if(cleanToken.length<8){return'[INVALID_TOKEN]';}// Show first 4 and last 4 characters for debugging purposes\nreturn\"\".concat(cleanToken.substring(0,4)).concat('*'.repeat(cleanToken.length-8)).concat(cleanToken.substring(cleanToken.length-4));}/**\n   * Store token securely with encryption and expiration\n   * @param {string} token - GitHub Personal Access Token\n   * @returns {boolean} Success status\n   */storeToken(token){try{this.logger.debug('Starting secure token storage');// Validate token format\nconst validation=this.validateTokenFormat(token);if(!validation.isValid){this.logger.warn('Token validation failed',{reason:validation.reason,tokenMask:this.maskToken(token)});return false;}this.logger.debug('Token validation successful',{type:validation.type,tokenMask:this.maskToken(token)});// Generate encryption key\nconst fingerprint=this.generateBrowserFingerprint();const encryptionKey=\"sgex_\".concat(fingerprint,\"_\").concat(Date.now().toString(36));// Encrypt token\nconst encryptedToken=this.xorCipher(validation.token,encryptionKey);// Create storage object with metadata\nconst storageData={token:btoa(encryptedToken),// Base64 encode for safe storage\nkey:btoa(encryptionKey),// Base64 encode the key\ntype:validation.type,created:Date.now(),expires:Date.now()+this.expirationHours*60*60*1000,fingerprint:fingerprint};// Store in sessionStorage (more secure than localStorage for tokens)\nsessionStorage.setItem(this.storageKey,JSON.stringify(storageData));// Clear any old tokens from localStorage\nlocalStorage.removeItem('github_token');sessionStorage.removeItem('github_token');this.logger.debug('Token stored securely',{type:validation.type,expires:new Date(storageData.expires).toISOString(),tokenMask:this.maskToken(token)});return true;}catch(error){this.logger.error('Failed to store token securely',{error:error.message,tokenMask:this.maskToken(token)});return false;}}/**\n   * Retrieve and decrypt stored token\n   * @returns {object|null} Token data or null if not found/expired\n   */retrieveToken(){try{this.logger.debug('Attempting to retrieve secure token');const storedData=sessionStorage.getItem(this.storageKey);if(!storedData){this.logger.debug('No secure token found in storage');return null;}const data=JSON.parse(storedData);// Check expiration\nif(Date.now()>data.expires){this.logger.warn('Stored token has expired');this.clearToken();return null;}// Verify browser fingerprint\nconst currentFingerprint=this.generateBrowserFingerprint();if(data.fingerprint!==currentFingerprint){this.logger.warn('Browser fingerprint mismatch - possible security issue');this.clearToken();return null;}// Decrypt token\nconst encryptionKey=atob(data.key);const encryptedToken=atob(data.token);const decryptedToken=this.xorCipher(encryptedToken,encryptionKey);// Validate decrypted token\nconst validation=this.validateTokenFormat(decryptedToken);if(!validation.isValid){this.logger.error('Decrypted token failed validation');this.clearToken();return null;}this.logger.debug('Token retrieved and decrypted successfully',{type:data.type,expires:new Date(data.expires).toISOString(),tokenMask:this.maskToken(decryptedToken)});return{token:validation.token,type:data.type,created:data.created,expires:data.expires};}catch(error){this.logger.error('Failed to retrieve secure token',{error:error.message});this.clearToken();return null;}}/**\n   * Check if a valid token exists without retrieving it\n   * @returns {boolean} True if valid token exists\n   */hasValidToken(){try{const storedData=sessionStorage.getItem(this.storageKey);if(!storedData){return false;}const data=JSON.parse(storedData);// Check expiration\nif(Date.now()>data.expires){this.clearToken();return false;}// Verify browser fingerprint\nconst currentFingerprint=this.generateBrowserFingerprint();if(data.fingerprint!==currentFingerprint){this.clearToken();return false;}return true;}catch(error){this.logger.error('Error checking token validity',{error:error.message});this.clearToken();return false;}}/**\n   * Clear stored token and cleanup\n   */clearToken(){this.logger.debug('Clearing secure token storage');sessionStorage.removeItem(this.storageKey);// Also clear legacy token storage\nsessionStorage.removeItem('github_token');localStorage.removeItem('github_token');}/**\n   * Get token expiration info\n   * @returns {object|null} Expiration info or null if no token\n   */getTokenInfo(){try{const storedData=sessionStorage.getItem(this.storageKey);if(!storedData){return null;}const data=JSON.parse(storedData);const timeRemaining=data.expires-Date.now();return{type:data.type,created:new Date(data.created),expires:new Date(data.expires),timeRemaining:Math.max(0,timeRemaining),isExpired:timeRemaining<=0,isValid:this.hasValidToken()};}catch(error){this.logger.error('Error getting token info',{error:error.message});return null;}}/**\n   * Migrate from legacy token storage\n   * @returns {boolean} True if migration was successful\n   */migrateLegacyToken(){try{// Check for tokens in legacy storage\nconst legacyToken=sessionStorage.getItem('github_token')||localStorage.getItem('github_token');if(!legacyToken){this.logger.debug('No legacy token found for migration');return false;}this.logger.debug('Migrating legacy token to secure storage');// Store using new secure method\nconst success=this.storeToken(legacyToken);if(success){// Clear legacy storage\nsessionStorage.removeItem('github_token');localStorage.removeItem('github_token');this.logger.debug('Legacy token migration completed successfully');return true;}else{this.logger.error('Failed to migrate legacy token');return false;}}catch(error){this.logger.error('Error during legacy token migration',{error:error.message});return false;}}}// Create singleton instance\nconst secureTokenStorage=new SecureTokenStorage();export default secureTokenStorage;","map":{"version":3,"names":["logger","SecureTokenStorage","constructor","getLogger","storageKey","expirationHours","debug","generateBrowserFingerprint","canvas","document","createElement","ctx","getContext","textBaseline","font","fillText","fingerprint","navigator","userAgent","language","window","screen","width","height","colorDepth","Date","getTimezoneOffset","toDataURL","join","hash","i","length","char","charCodeAt","Math","abs","toString","xorCipher","text","key","result","String","fromCharCode","validateTokenFormat","token","isValid","type","reason","cleanToken","trim","match","maskToken","concat","substring","repeat","storeToken","validation","warn","tokenMask","encryptionKey","now","encryptedToken","storageData","btoa","created","expires","sessionStorage","setItem","JSON","stringify","localStorage","removeItem","toISOString","error","message","retrieveToken","storedData","getItem","data","parse","clearToken","currentFingerprint","atob","decryptedToken","hasValidToken","getTokenInfo","timeRemaining","max","isExpired","migrateLegacyToken","legacyToken","success","secureTokenStorage"],"sources":["/home/runner/work/sgex/sgex/src/services/secureTokenStorage.js"],"sourcesContent":["/**\n * SecureTokenStorage - Secure storage for GitHub Personal Access Tokens\n * \n * Features:\n * - XOR encryption using browser fingerprint-based keys\n * - Token format validation (classic and fine-grained PATs)\n * - Automatic token expiration (24 hours)\n * - Secure token masking for logs and error messages\n */\n\nimport logger from '../utils/logger';\n\nclass SecureTokenStorage {\n  constructor() {\n    this.logger = logger.getLogger('SecureTokenStorage');\n    this.storageKey = 'sgex_secure_token';\n    this.expirationHours = 24;\n    this.logger.debug('SecureTokenStorage instance created');\n  }\n\n  /**\n   * Generate a browser fingerprint for encryption key\n   * @returns {string} Browser fingerprint\n   */\n  generateBrowserFingerprint() {\n    const canvas = document.createElement('canvas');\n    const ctx = canvas.getContext('2d');\n    ctx.textBaseline = 'top';\n    ctx.font = '14px Arial';\n    ctx.fillText('Browser fingerprint', 2, 2);\n    \n    const fingerprint = [\n      navigator.userAgent,\n      navigator.language,\n      window.screen.width + 'x' + window.screen.height,\n      window.screen.colorDepth,\n      new Date().getTimezoneOffset(),\n      canvas.toDataURL()\n    ].join('|');\n    \n    // Create a simple hash of the fingerprint\n    let hash = 0;\n    for (let i = 0; i < fingerprint.length; i++) {\n      const char = fingerprint.charCodeAt(i);\n      hash = ((hash << 5) - hash) + char;\n      hash = hash & hash; // Convert to 32-bit integer\n    }\n    \n    return Math.abs(hash).toString(36);\n  }\n\n  /**\n   * XOR encrypt/decrypt text using a key\n   * @param {string} text - Text to encrypt/decrypt\n   * @param {string} key - Encryption key\n   * @returns {string} Encrypted/decrypted text\n   */\n  xorCipher(text, key) {\n    let result = '';\n    for (let i = 0; i < text.length; i++) {\n      result += String.fromCharCode(\n        text.charCodeAt(i) ^ key.charCodeAt(i % key.length)\n      );\n    }\n    return result;\n  }\n\n  /**\n   * Validate GitHub Personal Access Token format\n   * @param {string} token - Token to validate\n   * @returns {object} Validation result with type and validity\n   */\n  validateTokenFormat(token) {\n    if (!token || typeof token !== 'string') {\n      return { isValid: false, type: 'invalid', reason: 'Token is empty or not a string' };\n    }\n\n    // Remove any whitespace\n    const cleanToken = token.trim();\n\n    // Classic Personal Access Token format: ghp_[36 characters A-Za-z0-9]\n    if (cleanToken.match(/^ghp_[A-Za-z0-9]{36}$/)) {\n      return { isValid: true, type: 'classic', token: cleanToken };\n    }\n\n    // Fine-grained Personal Access Token format: github_pat_[22 characters]_[59 characters]\n    if (cleanToken.match(/^github_pat_[A-Za-z0-9]{22}_[A-Za-z0-9]{59}$/)) {\n      return { isValid: true, type: 'fine-grained', token: cleanToken };\n    }\n\n    // OAuth token format: gho_[36 characters] (for completeness)\n    if (cleanToken.match(/^gho_[A-Za-z0-9]{36}$/)) {\n      return { isValid: true, type: 'oauth', token: cleanToken };\n    }\n\n    // Check for old-style tokens (40 hex characters) - deprecated but might still work\n    if (cleanToken.match(/^[a-fA-F0-9]{40}$/)) {\n      return { isValid: true, type: 'legacy', token: cleanToken };\n    }\n\n    return { \n      isValid: false, \n      type: 'invalid', \n      reason: 'Token does not match expected GitHub PAT format'\n    };\n  }\n\n  /**\n   * Mask token for safe logging\n   * @param {string} token - Token to mask\n   * @returns {string} Masked token\n   */\n  maskToken(token) {\n    if (!token || typeof token !== 'string') {\n      return '[INVALID_TOKEN]';\n    }\n\n    const cleanToken = token.trim();\n    if (cleanToken.length < 8) {\n      return '[INVALID_TOKEN]';\n    }\n\n    // Show first 4 and last 4 characters for debugging purposes\n    return `${cleanToken.substring(0, 4)}${'*'.repeat(cleanToken.length - 8)}${cleanToken.substring(cleanToken.length - 4)}`;\n  }\n\n  /**\n   * Store token securely with encryption and expiration\n   * @param {string} token - GitHub Personal Access Token\n   * @returns {boolean} Success status\n   */\n  storeToken(token) {\n    try {\n      this.logger.debug('Starting secure token storage');\n\n      // Validate token format\n      const validation = this.validateTokenFormat(token);\n      if (!validation.isValid) {\n        this.logger.warn('Token validation failed', { \n          reason: validation.reason,\n          tokenMask: this.maskToken(token)\n        });\n        return false;\n      }\n\n      this.logger.debug('Token validation successful', { \n        type: validation.type,\n        tokenMask: this.maskToken(token)\n      });\n\n      // Generate encryption key\n      const fingerprint = this.generateBrowserFingerprint();\n      const encryptionKey = `sgex_${fingerprint}_${Date.now().toString(36)}`;\n\n      // Encrypt token\n      const encryptedToken = this.xorCipher(validation.token, encryptionKey);\n      \n      // Create storage object with metadata\n      const storageData = {\n        token: btoa(encryptedToken), // Base64 encode for safe storage\n        key: btoa(encryptionKey), // Base64 encode the key\n        type: validation.type,\n        created: Date.now(),\n        expires: Date.now() + (this.expirationHours * 60 * 60 * 1000),\n        fingerprint: fingerprint\n      };\n\n      // Store in sessionStorage (more secure than localStorage for tokens)\n      sessionStorage.setItem(this.storageKey, JSON.stringify(storageData));\n      \n      // Clear any old tokens from localStorage\n      localStorage.removeItem('github_token');\n      sessionStorage.removeItem('github_token');\n\n      this.logger.debug('Token stored securely', { \n        type: validation.type,\n        expires: new Date(storageData.expires).toISOString(),\n        tokenMask: this.maskToken(token)\n      });\n\n      return true;\n    } catch (error) {\n      this.logger.error('Failed to store token securely', { \n        error: error.message,\n        tokenMask: this.maskToken(token)\n      });\n      return false;\n    }\n  }\n\n  /**\n   * Retrieve and decrypt stored token\n   * @returns {object|null} Token data or null if not found/expired\n   */\n  retrieveToken() {\n    try {\n      this.logger.debug('Attempting to retrieve secure token');\n\n      const storedData = sessionStorage.getItem(this.storageKey);\n      if (!storedData) {\n        this.logger.debug('No secure token found in storage');\n        return null;\n      }\n\n      const data = JSON.parse(storedData);\n      \n      // Check expiration\n      if (Date.now() > data.expires) {\n        this.logger.warn('Stored token has expired');\n        this.clearToken();\n        return null;\n      }\n\n      // Verify browser fingerprint\n      const currentFingerprint = this.generateBrowserFingerprint();\n      if (data.fingerprint !== currentFingerprint) {\n        this.logger.warn('Browser fingerprint mismatch - possible security issue');\n        this.clearToken();\n        return null;\n      }\n\n      // Decrypt token\n      const encryptionKey = atob(data.key);\n      const encryptedToken = atob(data.token);\n      const decryptedToken = this.xorCipher(encryptedToken, encryptionKey);\n\n      // Validate decrypted token\n      const validation = this.validateTokenFormat(decryptedToken);\n      if (!validation.isValid) {\n        this.logger.error('Decrypted token failed validation');\n        this.clearToken();\n        return null;\n      }\n\n      this.logger.debug('Token retrieved and decrypted successfully', { \n        type: data.type,\n        expires: new Date(data.expires).toISOString(),\n        tokenMask: this.maskToken(decryptedToken)\n      });\n\n      return {\n        token: validation.token,\n        type: data.type,\n        created: data.created,\n        expires: data.expires\n      };\n    } catch (error) {\n      this.logger.error('Failed to retrieve secure token', { error: error.message });\n      this.clearToken();\n      return null;\n    }\n  }\n\n  /**\n   * Check if a valid token exists without retrieving it\n   * @returns {boolean} True if valid token exists\n   */\n  hasValidToken() {\n    try {\n      const storedData = sessionStorage.getItem(this.storageKey);\n      if (!storedData) {\n        return false;\n      }\n\n      const data = JSON.parse(storedData);\n      \n      // Check expiration\n      if (Date.now() > data.expires) {\n        this.clearToken();\n        return false;\n      }\n\n      // Verify browser fingerprint\n      const currentFingerprint = this.generateBrowserFingerprint();\n      if (data.fingerprint !== currentFingerprint) {\n        this.clearToken();\n        return false;\n      }\n\n      return true;\n    } catch (error) {\n      this.logger.error('Error checking token validity', { error: error.message });\n      this.clearToken();\n      return false;\n    }\n  }\n\n  /**\n   * Clear stored token and cleanup\n   */\n  clearToken() {\n    this.logger.debug('Clearing secure token storage');\n    \n    sessionStorage.removeItem(this.storageKey);\n    \n    // Also clear legacy token storage\n    sessionStorage.removeItem('github_token');\n    localStorage.removeItem('github_token');\n  }\n\n  /**\n   * Get token expiration info\n   * @returns {object|null} Expiration info or null if no token\n   */\n  getTokenInfo() {\n    try {\n      const storedData = sessionStorage.getItem(this.storageKey);\n      if (!storedData) {\n        return null;\n      }\n\n      const data = JSON.parse(storedData);\n      const timeRemaining = data.expires - Date.now();\n      \n      return {\n        type: data.type,\n        created: new Date(data.created),\n        expires: new Date(data.expires),\n        timeRemaining: Math.max(0, timeRemaining),\n        isExpired: timeRemaining <= 0,\n        isValid: this.hasValidToken()\n      };\n    } catch (error) {\n      this.logger.error('Error getting token info', { error: error.message });\n      return null;\n    }\n  }\n\n  /**\n   * Migrate from legacy token storage\n   * @returns {boolean} True if migration was successful\n   */\n  migrateLegacyToken() {\n    try {\n      // Check for tokens in legacy storage\n      const legacyToken = sessionStorage.getItem('github_token') || localStorage.getItem('github_token');\n      \n      if (!legacyToken) {\n        this.logger.debug('No legacy token found for migration');\n        return false;\n      }\n\n      this.logger.debug('Migrating legacy token to secure storage');\n\n      // Store using new secure method\n      const success = this.storeToken(legacyToken);\n      \n      if (success) {\n        // Clear legacy storage\n        sessionStorage.removeItem('github_token');\n        localStorage.removeItem('github_token');\n        this.logger.debug('Legacy token migration completed successfully');\n        return true;\n      } else {\n        this.logger.error('Failed to migrate legacy token');\n        return false;\n      }\n    } catch (error) {\n      this.logger.error('Error during legacy token migration', { error: error.message });\n      return false;\n    }\n  }\n}\n\n// Create singleton instance\nconst secureTokenStorage = new SecureTokenStorage();\n\nexport default secureTokenStorage;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}