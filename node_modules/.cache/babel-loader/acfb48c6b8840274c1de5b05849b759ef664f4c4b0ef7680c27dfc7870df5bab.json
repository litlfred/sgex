{"ast":null,"code":"/**\n * Profile Subscription Service - Manages profile subscriptions in localStorage\n * \n * Provides functionality to manage profile subscriptions:\n * - Always includes WorldHealthOrganization\n * - Includes logged-in user when authenticated\n * - Auto-adds users when browsing their profiles\n * - Allows removal of profiles (except WHO and current user)\n */class ProfileSubscriptionService{constructor(){this.storageKey='sgex-profile-subscriptions';this.whoProfile='WorldHealthOrganization';}/**\n   * Get profile subscriptions from localStorage\n   * @returns {Array} Array of profile objects\n   */getSubscriptions(){try{const stored=localStorage.getItem(this.storageKey);const subscriptions=stored?JSON.parse(stored):[];// Always ensure WHO is included\nif(!subscriptions.find(profile=>profile.login===this.whoProfile)){subscriptions.unshift({login:this.whoProfile,name:'World Health Organization',avatar_url:`https://github.com/${this.whoProfile}.png`,type:'Organization',isPermanent:true,addedAt:new Date().toISOString()});this.saveSubscriptions(subscriptions);}return subscriptions;}catch(error){console.warn('Error reading profile subscriptions from localStorage:',error);// Return minimal default with WHO\nreturn[{login:this.whoProfile,name:'World Health Organization',avatar_url:`https://github.com/${this.whoProfile}.png`,type:'Organization',isPermanent:true,addedAt:new Date().toISOString()}];}}/**\n   * Save profile subscriptions to localStorage\n   * @param {Array} subscriptions - Array of profile objects\n   */saveSubscriptions(subscriptions){try{localStorage.setItem(this.storageKey,JSON.stringify(subscriptions));}catch(error){console.error('Error saving profile subscriptions to localStorage:',error);throw error;}}/**\n   * Add a profile to subscriptions\n   * @param {Object} profile - Profile object with login, name, avatar_url, type\n   * @param {boolean} isPermanent - Whether the profile cannot be removed\n   * @returns {Object} The added profile\n   */addSubscription(profile){let isPermanent=arguments.length>1&&arguments[1]!==undefined?arguments[1]:false;if(!profile||!profile.login){throw new Error('Profile must have a login property');}const subscriptions=this.getSubscriptions();// Check if already subscribed\nconst existingIndex=subscriptions.findIndex(p=>p.login===profile.login);if(existingIndex!==-1){// Update existing subscription\nsubscriptions[existingIndex]={...subscriptions[existingIndex],...profile,isPermanent:subscriptions[existingIndex].isPermanent||isPermanent,lastUpdated:new Date().toISOString()};this.saveSubscriptions(subscriptions);return subscriptions[existingIndex];}// Add new subscription\nconst newSubscription={login:profile.login,name:profile.name||profile.login,avatar_url:profile.avatar_url||`https://github.com/${profile.login}.png`,type:profile.type||'User',isPermanent,addedAt:new Date().toISOString(),lastUpdated:new Date().toISOString()};subscriptions.push(newSubscription);this.saveSubscriptions(subscriptions);return newSubscription;}/**\n   * Remove a profile from subscriptions\n   * @param {string} login - Login/username to remove\n   * @returns {boolean} Success status\n   */removeSubscription(login){if(!login){return false;}try{const subscriptions=this.getSubscriptions();const profileIndex=subscriptions.findIndex(p=>p.login===login);if(profileIndex===-1){return false;// Profile not found\n}const profile=subscriptions[profileIndex];// Cannot remove permanent profiles (WHO, current user)\nif(profile.isPermanent){console.warn(`Cannot remove permanent profile: ${login}`);return false;}subscriptions.splice(profileIndex,1);this.saveSubscriptions(subscriptions);return true;}catch(error){console.error('Error removing profile subscription:',error);return false;}}/**\n   * Check if a profile is subscribed\n   * @param {string} login - Login/username to check\n   * @returns {boolean} Whether the profile is subscribed\n   */isSubscribed(login){if(!login)return false;const subscriptions=this.getSubscriptions();return subscriptions.some(p=>p.login===login);}/**\n   * Get a specific subscription by login\n   * @param {string} login - Login/username to find\n   * @returns {Object|null} Profile object or null if not found\n   */getSubscription(login){if(!login)return null;const subscriptions=this.getSubscriptions();return subscriptions.find(p=>p.login===login)||null;}/**\n   * Auto-add current user to subscriptions (when logged in)\n   * @param {Object} userProfile - Current user's profile\n   */ensureCurrentUserSubscribed(userProfile){if(!userProfile||!userProfile.login){return;}const existing=this.getSubscription(userProfile.login);if(!existing){this.addSubscription({...userProfile,isPermanent:true// Current user cannot be removed\n},true);}else if(!existing.isPermanent){// Update existing to be permanent\nthis.addSubscription({...existing,...userProfile,isPermanent:true},true);}}/**\n   * Auto-add a visited user profile (from browsing)\n   * @param {Object} visitedProfile - Profile that user is browsing\n   */autoAddVisitedProfile(visitedProfile){if(!visitedProfile||!visitedProfile.login){return;}// Don't auto-add if already subscribed\nif(this.isSubscribed(visitedProfile.login)){return;}// Don't auto-add demo profiles\nif(visitedProfile.isDemo){return;}this.addSubscription(visitedProfile,false);}/**\n   * Get subscriptions sorted alphabetically by name\n   * @returns {Array} Sorted array of profile objects\n   */getSubscriptionsSorted(){const subscriptions=this.getSubscriptions();return subscriptions.sort((a,b)=>{// WHO always first\nif(a.login===this.whoProfile)return-1;if(b.login===this.whoProfile)return 1;// Then sort by name/login\nconst nameA=a.name||a.login;const nameB=b.name||b.login;return nameA.localeCompare(nameB);});}/**\n   * Get subscriptions for profile selection (formatted for UI)\n   * @returns {Array} Array of profile objects formatted for selection UI\n   */getSubscriptionsForSelection(){return this.getSubscriptionsSorted().map(profile=>({...profile,displayName:profile.name||profile.login,isRemovable:!profile.isPermanent}));}/**\n   * Update subscription with latest profile information\n   * @param {string} login - Login/username to update\n   * @param {Object} updatedProfile - Updated profile information\n   * @returns {boolean} Success status\n   */updateSubscription(login,updatedProfile){if(!login||!updatedProfile){return false;}try{const subscriptions=this.getSubscriptions();const index=subscriptions.findIndex(p=>p.login===login);if(index===-1){return false;}subscriptions[index]={...subscriptions[index],...updatedProfile,login,// Preserve original login\nlastUpdated:new Date().toISOString()};this.saveSubscriptions(subscriptions);return true;}catch(error){console.error('Error updating subscription:',error);return false;}}/**\n   * Clear all subscriptions (except WHO)\n   */clearSubscriptions(){try{const whoProfile={login:this.whoProfile,name:'World Health Organization',avatar_url:`https://github.com/${this.whoProfile}.png`,type:'Organization',isPermanent:true,addedAt:new Date().toISOString()};this.saveSubscriptions([whoProfile]);}catch(error){console.error('Error clearing subscriptions:',error);}}/**\n   * Export subscriptions as JSON\n   * @returns {string} JSON string of subscriptions\n   */exportSubscriptions(){const subscriptions=this.getSubscriptions();return JSON.stringify(subscriptions,null,2);}/**\n   * Import subscriptions from JSON\n   * @param {string} jsonString - JSON string of subscriptions\n   * @param {boolean} merge - Whether to merge with existing subscriptions\n   * @returns {boolean} Success status\n   */importSubscriptions(jsonString){let merge=arguments.length>1&&arguments[1]!==undefined?arguments[1]:false;try{const importedSubscriptions=JSON.parse(jsonString);if(!Array.isArray(importedSubscriptions)){throw new Error('Invalid subscription format');}let finalSubscriptions;if(merge){const existingSubscriptions=this.getSubscriptions();const mergedSubscriptions=[...existingSubscriptions];importedSubscriptions.forEach(imported=>{const existingIndex=mergedSubscriptions.findIndex(p=>p.login===imported.login);if(existingIndex!==-1){// Preserve permanence of existing subscriptions\nmergedSubscriptions[existingIndex]={...imported,isPermanent:mergedSubscriptions[existingIndex].isPermanent||imported.isPermanent};}else{mergedSubscriptions.push(imported);}});finalSubscriptions=mergedSubscriptions;}else{finalSubscriptions=importedSubscriptions;}// Ensure WHO is always included\nif(!finalSubscriptions.find(p=>p.login===this.whoProfile)){finalSubscriptions.unshift({login:this.whoProfile,name:'World Health Organization',avatar_url:`https://github.com/${this.whoProfile}.png`,type:'Organization',isPermanent:true,addedAt:new Date().toISOString()});}this.saveSubscriptions(finalSubscriptions);return true;}catch(error){console.error('Error importing subscriptions:',error);return false;}}}// Create and export singleton instance\nconst profileSubscriptionService=new ProfileSubscriptionService();export default profileSubscriptionService;","map":{"version":3,"names":["ProfileSubscriptionService","constructor","storageKey","whoProfile","getSubscriptions","stored","localStorage","getItem","subscriptions","JSON","parse","find","profile","login","unshift","name","avatar_url","type","isPermanent","addedAt","Date","toISOString","saveSubscriptions","error","console","warn","setItem","stringify","addSubscription","arguments","length","undefined","Error","existingIndex","findIndex","p","lastUpdated","newSubscription","push","removeSubscription","profileIndex","splice","isSubscribed","some","getSubscription","ensureCurrentUserSubscribed","userProfile","existing","autoAddVisitedProfile","visitedProfile","isDemo","getSubscriptionsSorted","sort","a","b","nameA","nameB","localeCompare","getSubscriptionsForSelection","map","displayName","isRemovable","updateSubscription","updatedProfile","index","clearSubscriptions","exportSubscriptions","importSubscriptions","jsonString","merge","importedSubscriptions","Array","isArray","finalSubscriptions","existingSubscriptions","mergedSubscriptions","forEach","imported","profileSubscriptionService"],"sources":["/home/runner/work/sgex/sgex/src/services/profileSubscriptionService.js"],"sourcesContent":["/**\n * Profile Subscription Service - Manages profile subscriptions in localStorage\n * \n * Provides functionality to manage profile subscriptions:\n * - Always includes WorldHealthOrganization\n * - Includes logged-in user when authenticated\n * - Auto-adds users when browsing their profiles\n * - Allows removal of profiles (except WHO and current user)\n */\nclass ProfileSubscriptionService {\n  constructor() {\n    this.storageKey = 'sgex-profile-subscriptions';\n    this.whoProfile = 'WorldHealthOrganization';\n  }\n\n  /**\n   * Get profile subscriptions from localStorage\n   * @returns {Array} Array of profile objects\n   */\n  getSubscriptions() {\n    try {\n      const stored = localStorage.getItem(this.storageKey);\n      const subscriptions = stored ? JSON.parse(stored) : [];\n      \n      // Always ensure WHO is included\n      if (!subscriptions.find(profile => profile.login === this.whoProfile)) {\n        subscriptions.unshift({\n          login: this.whoProfile,\n          name: 'World Health Organization',\n          avatar_url: `https://github.com/${this.whoProfile}.png`,\n          type: 'Organization',\n          isPermanent: true,\n          addedAt: new Date().toISOString()\n        });\n        this.saveSubscriptions(subscriptions);\n      }\n      \n      return subscriptions;\n    } catch (error) {\n      console.warn('Error reading profile subscriptions from localStorage:', error);\n      // Return minimal default with WHO\n      return [{\n        login: this.whoProfile,\n        name: 'World Health Organization',\n        avatar_url: `https://github.com/${this.whoProfile}.png`,\n        type: 'Organization',\n        isPermanent: true,\n        addedAt: new Date().toISOString()\n      }];\n    }\n  }\n\n  /**\n   * Save profile subscriptions to localStorage\n   * @param {Array} subscriptions - Array of profile objects\n   */\n  saveSubscriptions(subscriptions) {\n    try {\n      localStorage.setItem(this.storageKey, JSON.stringify(subscriptions));\n    } catch (error) {\n      console.error('Error saving profile subscriptions to localStorage:', error);\n      throw error;\n    }\n  }\n\n  /**\n   * Add a profile to subscriptions\n   * @param {Object} profile - Profile object with login, name, avatar_url, type\n   * @param {boolean} isPermanent - Whether the profile cannot be removed\n   * @returns {Object} The added profile\n   */\n  addSubscription(profile, isPermanent = false) {\n    if (!profile || !profile.login) {\n      throw new Error('Profile must have a login property');\n    }\n\n    const subscriptions = this.getSubscriptions();\n    \n    // Check if already subscribed\n    const existingIndex = subscriptions.findIndex(p => p.login === profile.login);\n    if (existingIndex !== -1) {\n      // Update existing subscription\n      subscriptions[existingIndex] = {\n        ...subscriptions[existingIndex],\n        ...profile,\n        isPermanent: subscriptions[existingIndex].isPermanent || isPermanent,\n        lastUpdated: new Date().toISOString()\n      };\n      this.saveSubscriptions(subscriptions);\n      return subscriptions[existingIndex];\n    }\n\n    // Add new subscription\n    const newSubscription = {\n      login: profile.login,\n      name: profile.name || profile.login,\n      avatar_url: profile.avatar_url || `https://github.com/${profile.login}.png`,\n      type: profile.type || 'User',\n      isPermanent,\n      addedAt: new Date().toISOString(),\n      lastUpdated: new Date().toISOString()\n    };\n\n    subscriptions.push(newSubscription);\n    this.saveSubscriptions(subscriptions);\n    return newSubscription;\n  }\n\n  /**\n   * Remove a profile from subscriptions\n   * @param {string} login - Login/username to remove\n   * @returns {boolean} Success status\n   */\n  removeSubscription(login) {\n    if (!login) {\n      return false;\n    }\n\n    try {\n      const subscriptions = this.getSubscriptions();\n      const profileIndex = subscriptions.findIndex(p => p.login === login);\n      \n      if (profileIndex === -1) {\n        return false; // Profile not found\n      }\n\n      const profile = subscriptions[profileIndex];\n      \n      // Cannot remove permanent profiles (WHO, current user)\n      if (profile.isPermanent) {\n        console.warn(`Cannot remove permanent profile: ${login}`);\n        return false;\n      }\n\n      subscriptions.splice(profileIndex, 1);\n      this.saveSubscriptions(subscriptions);\n      return true;\n    } catch (error) {\n      console.error('Error removing profile subscription:', error);\n      return false;\n    }\n  }\n\n  /**\n   * Check if a profile is subscribed\n   * @param {string} login - Login/username to check\n   * @returns {boolean} Whether the profile is subscribed\n   */\n  isSubscribed(login) {\n    if (!login) return false;\n    const subscriptions = this.getSubscriptions();\n    return subscriptions.some(p => p.login === login);\n  }\n\n  /**\n   * Get a specific subscription by login\n   * @param {string} login - Login/username to find\n   * @returns {Object|null} Profile object or null if not found\n   */\n  getSubscription(login) {\n    if (!login) return null;\n    const subscriptions = this.getSubscriptions();\n    return subscriptions.find(p => p.login === login) || null;\n  }\n\n  /**\n   * Auto-add current user to subscriptions (when logged in)\n   * @param {Object} userProfile - Current user's profile\n   */\n  ensureCurrentUserSubscribed(userProfile) {\n    if (!userProfile || !userProfile.login) {\n      return;\n    }\n\n    const existing = this.getSubscription(userProfile.login);\n    if (!existing) {\n      this.addSubscription({\n        ...userProfile,\n        isPermanent: true // Current user cannot be removed\n      }, true);\n    } else if (!existing.isPermanent) {\n      // Update existing to be permanent\n      this.addSubscription({\n        ...existing,\n        ...userProfile,\n        isPermanent: true\n      }, true);\n    }\n  }\n\n  /**\n   * Auto-add a visited user profile (from browsing)\n   * @param {Object} visitedProfile - Profile that user is browsing\n   */\n  autoAddVisitedProfile(visitedProfile) {\n    if (!visitedProfile || !visitedProfile.login) {\n      return;\n    }\n\n    // Don't auto-add if already subscribed\n    if (this.isSubscribed(visitedProfile.login)) {\n      return;\n    }\n\n    // Don't auto-add demo profiles\n    if (visitedProfile.isDemo) {\n      return;\n    }\n\n    this.addSubscription(visitedProfile, false);\n  }\n\n  /**\n   * Get subscriptions sorted alphabetically by name\n   * @returns {Array} Sorted array of profile objects\n   */\n  getSubscriptionsSorted() {\n    const subscriptions = this.getSubscriptions();\n    return subscriptions.sort((a, b) => {\n      // WHO always first\n      if (a.login === this.whoProfile) return -1;\n      if (b.login === this.whoProfile) return 1;\n      \n      // Then sort by name/login\n      const nameA = a.name || a.login;\n      const nameB = b.name || b.login;\n      return nameA.localeCompare(nameB);\n    });\n  }\n\n  /**\n   * Get subscriptions for profile selection (formatted for UI)\n   * @returns {Array} Array of profile objects formatted for selection UI\n   */\n  getSubscriptionsForSelection() {\n    return this.getSubscriptionsSorted().map(profile => ({\n      ...profile,\n      displayName: profile.name || profile.login,\n      isRemovable: !profile.isPermanent\n    }));\n  }\n\n  /**\n   * Update subscription with latest profile information\n   * @param {string} login - Login/username to update\n   * @param {Object} updatedProfile - Updated profile information\n   * @returns {boolean} Success status\n   */\n  updateSubscription(login, updatedProfile) {\n    if (!login || !updatedProfile) {\n      return false;\n    }\n\n    try {\n      const subscriptions = this.getSubscriptions();\n      const index = subscriptions.findIndex(p => p.login === login);\n      \n      if (index === -1) {\n        return false;\n      }\n\n      subscriptions[index] = {\n        ...subscriptions[index],\n        ...updatedProfile,\n        login, // Preserve original login\n        lastUpdated: new Date().toISOString()\n      };\n\n      this.saveSubscriptions(subscriptions);\n      return true;\n    } catch (error) {\n      console.error('Error updating subscription:', error);\n      return false;\n    }\n  }\n\n  /**\n   * Clear all subscriptions (except WHO)\n   */\n  clearSubscriptions() {\n    try {\n      const whoProfile = {\n        login: this.whoProfile,\n        name: 'World Health Organization',\n        avatar_url: `https://github.com/${this.whoProfile}.png`,\n        type: 'Organization',\n        isPermanent: true,\n        addedAt: new Date().toISOString()\n      };\n      this.saveSubscriptions([whoProfile]);\n    } catch (error) {\n      console.error('Error clearing subscriptions:', error);\n    }\n  }\n\n  /**\n   * Export subscriptions as JSON\n   * @returns {string} JSON string of subscriptions\n   */\n  exportSubscriptions() {\n    const subscriptions = this.getSubscriptions();\n    return JSON.stringify(subscriptions, null, 2);\n  }\n\n  /**\n   * Import subscriptions from JSON\n   * @param {string} jsonString - JSON string of subscriptions\n   * @param {boolean} merge - Whether to merge with existing subscriptions\n   * @returns {boolean} Success status\n   */\n  importSubscriptions(jsonString, merge = false) {\n    try {\n      const importedSubscriptions = JSON.parse(jsonString);\n      \n      if (!Array.isArray(importedSubscriptions)) {\n        throw new Error('Invalid subscription format');\n      }\n\n      let finalSubscriptions;\n      \n      if (merge) {\n        const existingSubscriptions = this.getSubscriptions();\n        const mergedSubscriptions = [...existingSubscriptions];\n        \n        importedSubscriptions.forEach(imported => {\n          const existingIndex = mergedSubscriptions.findIndex(p => p.login === imported.login);\n          if (existingIndex !== -1) {\n            // Preserve permanence of existing subscriptions\n            mergedSubscriptions[existingIndex] = {\n              ...imported,\n              isPermanent: mergedSubscriptions[existingIndex].isPermanent || imported.isPermanent\n            };\n          } else {\n            mergedSubscriptions.push(imported);\n          }\n        });\n        \n        finalSubscriptions = mergedSubscriptions;\n      } else {\n        finalSubscriptions = importedSubscriptions;\n      }\n\n      // Ensure WHO is always included\n      if (!finalSubscriptions.find(p => p.login === this.whoProfile)) {\n        finalSubscriptions.unshift({\n          login: this.whoProfile,\n          name: 'World Health Organization',\n          avatar_url: `https://github.com/${this.whoProfile}.png`,\n          type: 'Organization',\n          isPermanent: true,\n          addedAt: new Date().toISOString()\n        });\n      }\n      \n      this.saveSubscriptions(finalSubscriptions);\n      return true;\n    } catch (error) {\n      console.error('Error importing subscriptions:', error);\n      return false;\n    }\n  }\n}\n\n// Create and export singleton instance\nconst profileSubscriptionService = new ProfileSubscriptionService();\nexport default profileSubscriptionService;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}