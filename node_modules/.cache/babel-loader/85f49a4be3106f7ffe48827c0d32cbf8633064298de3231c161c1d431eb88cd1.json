{"ast":null,"code":"import { every, find, forEach, some } from 'min-dash';\nimport inherits from 'inherits-browser';\nimport { is, getBusinessObject } from '../../util/ModelUtil';\nimport { getParent, isAny } from '../modeling/util/ModelingUtil';\nimport { isLabel } from '../../util/LabelUtil';\nimport { isExpanded, isEventSubProcess, isInterrupting, hasErrorEventDefinition, hasEscalationEventDefinition, hasCompensateEventDefinition } from '../../util/DiUtil';\nimport RuleProvider from 'diagram-js/lib/features/rules/RuleProvider';\nimport { getBoundaryAttachment as isBoundaryAttachment } from '../snapping/BpmnSnappingUtil';\nimport { isConnection } from 'diagram-js/lib/util/ModelUtil';\n\n/**\n * @typedef {import('diagram-js/lib/core/EventBus').default} EventBus\n *\n * @typedef {import('../../model/Types').Connection} Connection\n * @typedef {import('../../model/Types').Element} Element\n * @typedef {import('../../model/Types').Shape} Shape\n * @typedef {import('../../model/Types').ModdleElement} ModdleElement\n *\n * @typedef {import('diagram-js/lib/util/Types').Point} Point\n * @typedef {import('diagram-js/lib/util/Types').Rect} Rect\n *\n * @typedef { {\n *   associationDirection?: 'None' | 'One' | 'Both';\n *   type: string;\n * } | boolean | null } CanConnectResult\n *\n * @typedef { {\n *   id: string;\n *   type: string;\n * } | boolean } CanReplaceResult\n */\n\n/**\n * BPMN-specific modeling rules.\n *\n * @param {EventBus} eventBus\n */\nexport default function BpmnRules(eventBus) {\n  RuleProvider.call(this, eventBus);\n}\ninherits(BpmnRules, RuleProvider);\nBpmnRules.$inject = ['eventBus'];\nBpmnRules.prototype.init = function () {\n  this.addRule('connection.start', function (context) {\n    var source = context.source;\n    return canStartConnection(source);\n  });\n  this.addRule('connection.create', function (context) {\n    var source = context.source,\n      target = context.target,\n      hints = context.hints || {},\n      targetParent = hints.targetParent,\n      targetAttach = hints.targetAttach;\n\n    // don't allow incoming connections on\n    // newly created boundary events\n    // to boundary events\n    if (targetAttach) {\n      return false;\n    }\n\n    // temporarily set target parent for scoping\n    // checks to work\n    if (targetParent) {\n      target.parent = targetParent;\n    }\n    try {\n      return canConnect(source, target);\n    } finally {\n      // unset temporary target parent\n      if (targetParent) {\n        target.parent = null;\n      }\n    }\n  });\n  this.addRule('connection.reconnect', function (context) {\n    var connection = context.connection,\n      source = context.source,\n      target = context.target;\n    return canConnect(source, target, connection);\n  });\n  this.addRule('connection.updateWaypoints', function (context) {\n    return {\n      type: context.connection.type\n    };\n  });\n  this.addRule('shape.resize', function (context) {\n    var shape = context.shape,\n      newBounds = context.newBounds;\n    return canResize(shape, newBounds);\n  });\n  this.addRule('elements.create', function (context) {\n    var elements = context.elements,\n      position = context.position,\n      target = context.target;\n    if (isConnection(target) && !canInsert(elements, target, position)) {\n      return false;\n    }\n    return every(elements, function (element) {\n      if (isConnection(element)) {\n        return canConnect(element.source, element.target, element);\n      }\n      if (element.host) {\n        return canAttach(element, element.host, null, position);\n      }\n      return canCreate(element, target, null, position);\n    });\n  });\n  this.addRule('elements.move', function (context) {\n    var target = context.target,\n      shapes = context.shapes,\n      position = context.position;\n    return canAttach(shapes, target, null, position) || canReplace(shapes, target, position) || canMove(shapes, target, position) || canInsert(shapes, target, position);\n  });\n  this.addRule('shape.create', function (context) {\n    return canCreate(context.shape, context.target, context.source, context.position);\n  });\n  this.addRule('shape.attach', function (context) {\n    return canAttach(context.shape, context.target, null, context.position);\n  });\n  this.addRule('element.copy', function (context) {\n    var element = context.element,\n      elements = context.elements;\n    return canCopy(elements, element);\n  });\n};\nBpmnRules.prototype.canConnectMessageFlow = canConnectMessageFlow;\nBpmnRules.prototype.canConnectSequenceFlow = canConnectSequenceFlow;\nBpmnRules.prototype.canConnectDataAssociation = canConnectDataAssociation;\nBpmnRules.prototype.canConnectAssociation = canConnectAssociation;\nBpmnRules.prototype.canConnectCompensationAssociation = canConnectCompensationAssociation;\nBpmnRules.prototype.canMove = canMove;\nBpmnRules.prototype.canAttach = canAttach;\nBpmnRules.prototype.canReplace = canReplace;\nBpmnRules.prototype.canDrop = canDrop;\nBpmnRules.prototype.canInsert = canInsert;\nBpmnRules.prototype.canCreate = canCreate;\nBpmnRules.prototype.canConnect = canConnect;\nBpmnRules.prototype.canResize = canResize;\nBpmnRules.prototype.canCopy = canCopy;\n\n/**\n * Utility functions for rule checking\n */\n\n/**\n * Checks if given element can be used for starting connection.\n *\n * @param  {Element} source\n *\n * @return {boolean}\n */\nfunction canStartConnection(element) {\n  if (nonExistingOrLabel(element)) {\n    return null;\n  }\n  return isAny(element, ['bpmn:FlowNode', 'bpmn:InteractionNode', 'bpmn:DataObjectReference', 'bpmn:DataStoreReference', 'bpmn:Group', 'bpmn:TextAnnotation']);\n}\n\n/**\n * @param {Element} element\n *\n * @return {boolean}\n */\nfunction nonExistingOrLabel(element) {\n  return !element || isLabel(element);\n}\nfunction isSame(a, b) {\n  return a === b;\n}\n\n/**\n * @param {Element} element\n *\n * @return {ModdleElement}\n */\nfunction getOrganizationalParent(element) {\n  do {\n    if (is(element, 'bpmn:Process')) {\n      return getBusinessObject(element);\n    }\n    if (is(element, 'bpmn:Participant')) {\n      return getBusinessObject(element).processRef || getBusinessObject(element);\n    }\n  } while (element = element.parent);\n}\n\n/**\n * @param {Element} element\n *\n * @return {boolean}\n */\nfunction isTextAnnotation(element) {\n  return is(element, 'bpmn:TextAnnotation');\n}\n\n/**\n * @param {Element} element\n *\n * @return {boolean}\n */\nfunction isGroup(element) {\n  return is(element, 'bpmn:Group') && !element.labelTarget;\n}\n\n/**\n * @param {Element} element\n *\n * @return {boolean}\n */\nfunction isCompensationBoundary(element) {\n  return is(element, 'bpmn:BoundaryEvent') && hasEventDefinition(element, 'bpmn:CompensateEventDefinition');\n}\n\n/**\n * @param {Element} element\n *\n * @return {boolean}\n */\nfunction isForCompensation(element) {\n  return getBusinessObject(element).isForCompensation;\n}\n\n/**\n * @param {Element} a\n * @param {Element} b\n *\n * @return {boolean}\n */\nfunction isSameOrganization(a, b) {\n  var parentA = getOrganizationalParent(a),\n    parentB = getOrganizationalParent(b);\n  return parentA === parentB;\n}\n\n/**\n * @param {Element} element\n *\n * @return {boolean}\n */\nfunction isMessageFlowSource(element) {\n  return is(element, 'bpmn:InteractionNode') && !is(element, 'bpmn:BoundaryEvent') && (!is(element, 'bpmn:Event') || is(element, 'bpmn:ThrowEvent') && hasEventDefinitionOrNone(element, 'bpmn:MessageEventDefinition'));\n}\n\n/**\n * @param {Element} element\n *\n * @return {boolean}\n */\nfunction isMessageFlowTarget(element) {\n  return is(element, 'bpmn:InteractionNode') && !isForCompensation(element) && (!is(element, 'bpmn:Event') || is(element, 'bpmn:CatchEvent') && hasEventDefinitionOrNone(element, 'bpmn:MessageEventDefinition')) && !(is(element, 'bpmn:BoundaryEvent') && !hasEventDefinition(element, 'bpmn:MessageEventDefinition'));\n}\n\n/**\n * @param {Element} element\n *\n * @return {ModdleElement}\n */\nfunction getScopeParent(element) {\n  var parent = element;\n  while (parent = parent.parent) {\n    if (is(parent, 'bpmn:FlowElementsContainer')) {\n      return getBusinessObject(parent);\n    }\n    if (is(parent, 'bpmn:Participant')) {\n      return getBusinessObject(parent).processRef;\n    }\n  }\n  return null;\n}\n\n/**\n * @param {Element} a\n * @param {Element} b\n *\n * @return {boolean}\n */\nfunction isSameScope(a, b) {\n  var scopeParentA = getScopeParent(a),\n    scopeParentB = getScopeParent(b);\n  return scopeParentA === scopeParentB;\n}\n\n/**\n * @param {Element} element\n * @param {string} eventDefinition\n *\n * @return {boolean}\n */\nfunction hasEventDefinition(element, eventDefinition) {\n  var businessObject = getBusinessObject(element);\n  return !!find(businessObject.eventDefinitions || [], function (definition) {\n    return is(definition, eventDefinition);\n  });\n}\n\n/**\n * @param {Element} element\n * @param {string} eventDefinition\n *\n * @return {boolean}\n */\nfunction hasEventDefinitionOrNone(element, eventDefinition) {\n  var businessObject = getBusinessObject(element);\n  return (businessObject.eventDefinitions || []).every(function (definition) {\n    return is(definition, eventDefinition);\n  });\n}\n\n/**\n * @param {Element} element\n *\n * @return {boolean}\n */\nfunction isSequenceFlowSource(element) {\n  return is(element, 'bpmn:FlowNode') && !is(element, 'bpmn:EndEvent') && !isEventSubProcess(element) && !(is(element, 'bpmn:IntermediateThrowEvent') && hasEventDefinition(element, 'bpmn:LinkEventDefinition')) && !isCompensationBoundary(element) && !isForCompensation(element);\n}\n\n/**\n * @param {Element} element\n *\n * @return {boolean}\n */\nfunction isSequenceFlowTarget(element) {\n  return is(element, 'bpmn:FlowNode') && !is(element, 'bpmn:StartEvent') && !is(element, 'bpmn:BoundaryEvent') && !isEventSubProcess(element) && !(is(element, 'bpmn:IntermediateCatchEvent') && hasEventDefinition(element, 'bpmn:LinkEventDefinition')) && !isForCompensation(element);\n}\n\n/**\n * @param {Element} element\n *\n * @return {boolean}\n */\nfunction isEventBasedTarget(element) {\n  return is(element, 'bpmn:ReceiveTask') || is(element, 'bpmn:IntermediateCatchEvent') && (hasEventDefinition(element, 'bpmn:MessageEventDefinition') || hasEventDefinition(element, 'bpmn:TimerEventDefinition') || hasEventDefinition(element, 'bpmn:ConditionalEventDefinition') || hasEventDefinition(element, 'bpmn:SignalEventDefinition'));\n}\n\n/**\n * @param {Element} element\n *\n * @return {Shape[]}\n */\nfunction getParents(element) {\n  var parents = [];\n  while (element) {\n    element = element.parent;\n    if (element) {\n      parents.push(element);\n    }\n  }\n  return parents;\n}\n\n/**\n * @param {Shape} possibleParent\n * @param {Element} element\n *\n * @return {boolean}\n */\nfunction isParent(possibleParent, element) {\n  var allParents = getParents(element);\n  return allParents.indexOf(possibleParent) !== -1;\n}\n\n/**\n * @param {Element} source\n * @param {Element} target\n * @param {Connection} connection\n *\n * @return {CanConnectResult}\n */\nfunction canConnect(source, target, connection) {\n  if (nonExistingOrLabel(source) || nonExistingOrLabel(target)) {\n    return null;\n  }\n  if (!is(connection, 'bpmn:DataAssociation')) {\n    if (canConnectMessageFlow(source, target)) {\n      return {\n        type: 'bpmn:MessageFlow'\n      };\n    }\n    if (canConnectSequenceFlow(source, target)) {\n      return {\n        type: 'bpmn:SequenceFlow'\n      };\n    }\n  }\n  var connectDataAssociation = canConnectDataAssociation(source, target);\n  if (connectDataAssociation) {\n    return connectDataAssociation;\n  }\n  if (canConnectCompensationAssociation(source, target)) {\n    return {\n      type: 'bpmn:Association',\n      associationDirection: 'One'\n    };\n  }\n  if (canConnectAssociation(source, target)) {\n    return {\n      type: 'bpmn:Association',\n      associationDirection: 'None'\n    };\n  }\n  return false;\n}\n\n/**\n * Can an element be dropped into the target element.\n *\n * @param {Element} element\n * @param {Shape} target\n *\n * @return {boolean}\n */\nfunction canDrop(element, target) {\n  // can move labels and groups everywhere\n  if (isLabel(element) || isGroup(element)) {\n    return true;\n  }\n\n  // disallow to create elements on collapsed pools\n  if (is(target, 'bpmn:Participant') && !isExpanded(target)) {\n    return false;\n  }\n\n  // allow to create new participants on\n  // existing collaboration and process diagrams\n  if (is(element, 'bpmn:Participant')) {\n    return is(target, 'bpmn:Process') || is(target, 'bpmn:Collaboration');\n  }\n\n  // allow moving DataInput / DataOutput within its original container only\n  if (isAny(element, ['bpmn:DataInput', 'bpmn:DataOutput'])) {\n    if (element.parent) {\n      return target === element.parent;\n    }\n  }\n\n  // allow creating lanes on participants and other lanes only\n  if (is(element, 'bpmn:Lane')) {\n    return is(target, 'bpmn:Participant') || is(target, 'bpmn:Lane');\n  }\n\n  // disallow dropping boundary events which cannot replace with intermediate event\n  if (is(element, 'bpmn:BoundaryEvent') && !isDroppableBoundaryEvent(element)) {\n    return false;\n  }\n\n  // drop flow elements onto flow element containers\n  // and participants\n  if (is(element, 'bpmn:FlowElement') && !is(element, 'bpmn:DataStoreReference')) {\n    if (is(target, 'bpmn:FlowElementsContainer')) {\n      return isExpanded(target);\n    }\n    return isAny(target, ['bpmn:Participant', 'bpmn:Lane']);\n  }\n\n  // disallow dropping data store reference if there is no process to append to\n  if (is(element, 'bpmn:DataStoreReference') && is(target, 'bpmn:Collaboration')) {\n    return some(getBusinessObject(target).get('participants'), function (participant) {\n      return !!participant.get('processRef');\n    });\n  }\n\n  // account for the fact that data associations are always\n  // rendered and moved to top (Process or Collaboration level)\n  //\n  // artifacts may be placed wherever, too\n  if (isAny(element, ['bpmn:Artifact', 'bpmn:DataAssociation', 'bpmn:DataStoreReference'])) {\n    return isAny(target, ['bpmn:Collaboration', 'bpmn:Lane', 'bpmn:Participant', 'bpmn:Process', 'bpmn:SubProcess']);\n  }\n  if (is(element, 'bpmn:MessageFlow')) {\n    return is(target, 'bpmn:Collaboration') || element.source.parent == target || element.target.parent == target;\n  }\n  return false;\n}\n\n/**\n * @param {Shape} event\n *\n * @return {boolean}\n */\nfunction isDroppableBoundaryEvent(event) {\n  return getBusinessObject(event).cancelActivity && (hasNoEventDefinition(event) || hasCommonBoundaryIntermediateEventDefinition(event));\n}\n\n/**\n * @param {Element} element\n *\n * @return {boolean}\n */\nfunction isBoundaryEvent(element) {\n  return !isLabel(element) && is(element, 'bpmn:BoundaryEvent');\n}\n\n/**\n * @param {Element} element\n *\n * @return {boolean}\n */\nfunction isLane(element) {\n  return is(element, 'bpmn:Lane');\n}\n\n/**\n * `bpmn:IntermediateThrowEvents` are treated as boundary events during create.\n *\n * @param {Element} element\n *\n * @return {boolean}\n */\nfunction isBoundaryCandidate(element) {\n  if (isBoundaryEvent(element)) {\n    return true;\n  }\n  if (is(element, 'bpmn:IntermediateThrowEvent') && hasNoEventDefinition(element)) {\n    return true;\n  }\n  return is(element, 'bpmn:IntermediateCatchEvent') && hasCommonBoundaryIntermediateEventDefinition(element);\n}\n\n/**\n * @param {Element} element\n *\n * @return {boolean}\n */\nfunction hasNoEventDefinition(element) {\n  var businessObject = getBusinessObject(element);\n  return businessObject && !(businessObject.eventDefinitions && businessObject.eventDefinitions.length);\n}\n\n/**\n * @param {Element} element\n *\n * @return {boolean}\n */\nfunction hasCommonBoundaryIntermediateEventDefinition(element) {\n  return hasOneOfEventDefinitions(element, ['bpmn:MessageEventDefinition', 'bpmn:TimerEventDefinition', 'bpmn:SignalEventDefinition', 'bpmn:ConditionalEventDefinition']);\n}\n\n/**\n * @param {Element} element\n * @param {string[]} eventDefinitions\n *\n * @return {boolean}\n */\nfunction hasOneOfEventDefinitions(element, eventDefinitions) {\n  return eventDefinitions.some(function (definition) {\n    return hasEventDefinition(element, definition);\n  });\n}\n\n/**\n * @param {Element} element\n *\n * @return {boolean}\n */\nfunction isReceiveTaskAfterEventBasedGateway(element) {\n  return is(element, 'bpmn:ReceiveTask') && find(element.incoming, function (incoming) {\n    return is(incoming.source, 'bpmn:EventBasedGateway');\n  });\n}\n\n/**\n * TODO(philippfromme): remove `source` parameter\n *\n * @param {Element[]} elements\n * @param {Shape} target\n * @param {Element} source\n * @param {Point} [position]\n *\n * @return {boolean | 'attach'}\n */\nfunction canAttach(elements, target, source, position) {\n  if (!Array.isArray(elements)) {\n    elements = [elements];\n  }\n\n  // only (re-)attach one element at a time\n  if (elements.length !== 1) {\n    return false;\n  }\n  var element = elements[0];\n\n  // do not attach labels\n  if (isLabel(element)) {\n    return false;\n  }\n\n  // only handle boundary events\n  if (!isBoundaryCandidate(element)) {\n    return false;\n  }\n\n  // disallow drop on event sub processes\n  if (isEventSubProcess(target)) {\n    return false;\n  }\n\n  // only allow drop on non compensation activities\n  if (!is(target, 'bpmn:Activity') || isForCompensation(target)) {\n    return false;\n  }\n\n  // only attach to subprocess border\n  if (position && !isBoundaryAttachment(position, target)) {\n    return false;\n  }\n\n  // do not attach on receive tasks after event based gateways\n  if (isReceiveTaskAfterEventBasedGateway(target)) {\n    return false;\n  }\n  return 'attach';\n}\n\n/**\n * Check whether the given elements can be replaced. Return all elements which\n * can be replaced.\n *\n * @example\n *\n * ```javascript\n * [{\n *   id: 'IntermediateEvent_1',\n *   type: 'bpmn:StartEvent'\n * },\n * {\n *   id: 'Task_1',\n *   type: 'bpmn:ServiceTask'\n * }]\n * ```\n *\n * @param  {Element[]} elements\n * @param  {Shape} [target]\n * @param  {Point} [position]\n *\n * @return {CanReplaceResult}\n */\nfunction canReplace(elements, target, position) {\n  if (!target) {\n    return false;\n  }\n  var canExecute = {\n    replacements: []\n  };\n  forEach(elements, function (element) {\n    if (!isEventSubProcess(target)) {\n      if (is(element, 'bpmn:StartEvent') && element.type !== 'label' && canDrop(element, target)) {\n        // replace a non-interrupting start event by a blank interrupting start event\n        // when the target is not an event sub process\n        if (!isInterrupting(element)) {\n          canExecute.replacements.push({\n            oldElementId: element.id,\n            newElementType: 'bpmn:StartEvent'\n          });\n        }\n\n        // replace an error/escalation/compensate start event by a blank interrupting start event\n        // when the target is not an event sub process\n        if (hasErrorEventDefinition(element) || hasEscalationEventDefinition(element) || hasCompensateEventDefinition(element)) {\n          canExecute.replacements.push({\n            oldElementId: element.id,\n            newElementType: 'bpmn:StartEvent'\n          });\n        }\n\n        // replace a typed start event by a blank interrupting start event\n        // when the target is a sub process but not an event sub process\n        if (hasOneOfEventDefinitions(element, ['bpmn:MessageEventDefinition', 'bpmn:TimerEventDefinition', 'bpmn:SignalEventDefinition', 'bpmn:ConditionalEventDefinition']) && is(target, 'bpmn:SubProcess')) {\n          canExecute.replacements.push({\n            oldElementId: element.id,\n            newElementType: 'bpmn:StartEvent'\n          });\n        }\n      }\n    }\n    if (!is(target, 'bpmn:Transaction')) {\n      if (hasEventDefinition(element, 'bpmn:CancelEventDefinition') && element.type !== 'label') {\n        if (is(element, 'bpmn:EndEvent') && canDrop(element, target)) {\n          canExecute.replacements.push({\n            oldElementId: element.id,\n            newElementType: 'bpmn:EndEvent'\n          });\n        }\n        if (is(element, 'bpmn:BoundaryEvent') && canAttach(element, target, null, position)) {\n          canExecute.replacements.push({\n            oldElementId: element.id,\n            newElementType: 'bpmn:BoundaryEvent'\n          });\n        }\n      }\n    }\n  });\n  return canExecute.replacements.length ? canExecute : false;\n}\n\n/**\n * @param {Element[]} elements\n * @param {Shape} target\n *\n * @return {boolean}\n */\nfunction canMove(elements, target) {\n  // do not move selection containing lanes\n  if (some(elements, isLane)) {\n    return false;\n  }\n\n  // allow default move check to start move operation\n  if (!target) {\n    return true;\n  }\n  return elements.every(function (element) {\n    return canDrop(element, target);\n  });\n}\n\n/**\n * @param {Shape} shape\n * @param {Shape} target\n * @param {Element} source\n * @param {Point} position\n *\n * @return {boolean}\n */\nfunction canCreate(shape, target, source, position) {\n  if (!target) {\n    return false;\n  }\n  if (isLabel(shape) || isGroup(shape)) {\n    return true;\n  }\n  if (isSame(source, target)) {\n    return false;\n  }\n\n  // ensure we do not drop the element\n  // into source\n  if (source && isParent(source, target)) {\n    return false;\n  }\n  return canDrop(shape, target, position) || canInsert(shape, target, position);\n}\n\n/**\n * @param {Shape} shape\n * @param {Rect} newBounds\n *\n * @return {boolean}\n */\nfunction canResize(shape, newBounds) {\n  if (is(shape, 'bpmn:SubProcess')) {\n    return isExpanded(shape) && (!newBounds || newBounds.width >= 100 && newBounds.height >= 80);\n  }\n  if (is(shape, 'bpmn:Lane')) {\n    return true;\n  }\n  if (is(shape, 'bpmn:Participant')) {\n    return true;\n  }\n  if (isTextAnnotation(shape)) {\n    return true;\n  }\n  if (isGroup(shape)) {\n    return true;\n  }\n  return false;\n}\n\n/**\n * Check whether one of of the elements to be connected is a text annotation.\n *\n * @param {Element} source\n * @param {Element} target\n *\n * @return {boolean}\n */\nfunction isOneTextAnnotation(source, target) {\n  var sourceTextAnnotation = isTextAnnotation(source),\n    targetTextAnnotation = isTextAnnotation(target);\n  return (sourceTextAnnotation || targetTextAnnotation) && sourceTextAnnotation !== targetTextAnnotation;\n}\n\n/**\n * @param {Element} source\n * @param {Element} target\n *\n * @return {CanConnectResult}\n */\nfunction canConnectAssociation(source, target) {\n  // don't connect parent <-> child\n  if (isParent(target, source) || isParent(source, target)) {\n    return false;\n  }\n\n  // allow connection of associations between <!TextAnnotation> and <TextAnnotation>\n  if (isOneTextAnnotation(source, target)) {\n    return true;\n  }\n\n  // can connect associations where we can connect\n  // data associations, too (!)\n  return !!canConnectDataAssociation(source, target);\n}\n\n/**\n * @param {Element} source\n * @param {Element} target\n *\n * @return {boolean}\n */\nfunction canConnectCompensationAssociation(source, target) {\n  return isSameScope(source, target) && isCompensationBoundary(source) && is(target, 'bpmn:Activity') && !isHostOfElement(target, source) && !isEventSubProcess(target);\n}\n\n/**\n * @param {Element} source\n * @param {Element} target\n *\n * @return {boolean}\n */\nfunction canConnectMessageFlow(source, target) {\n  // during connect user might move mouse out of canvas\n  // https://github.com/bpmn-io/bpmn-js/issues/1033\n  if (getRootElement(source) && !getRootElement(target)) {\n    return false;\n  }\n  return isMessageFlowSource(source) && isMessageFlowTarget(target) && !isSameOrganization(source, target);\n}\n\n/**\n * @param {Element} source\n * @param {Element} target\n *\n * @return {boolean}\n */\nfunction canConnectSequenceFlow(source, target) {\n  return isSequenceFlowSource(source) && isSequenceFlowTarget(target) && isSameScope(source, target) && !(is(source, 'bpmn:EventBasedGateway') && !isEventBasedTarget(target));\n}\n\n/**\n * @param {Element} source\n * @param {Element} target\n *\n * @return {CanConnectResult}\n */\nfunction canConnectDataAssociation(source, target) {\n  if (isAny(source, ['bpmn:DataObjectReference', 'bpmn:DataStoreReference']) && isAny(target, ['bpmn:Activity', 'bpmn:ThrowEvent'])) {\n    return {\n      type: 'bpmn:DataInputAssociation'\n    };\n  }\n  if (isAny(target, ['bpmn:DataObjectReference', 'bpmn:DataStoreReference']) && isAny(source, ['bpmn:Activity', 'bpmn:CatchEvent'])) {\n    return {\n      type: 'bpmn:DataOutputAssociation'\n    };\n  }\n  return false;\n}\n\n/**\n * @param {Shape} shape\n * @param {Connection} connection\n * @param {Point} position\n *\n * @return {boolean}\n */\nfunction canInsert(shape, connection, position) {\n  if (!connection) {\n    return false;\n  }\n  if (Array.isArray(shape)) {\n    if (shape.length !== 1) {\n      return false;\n    }\n    shape = shape[0];\n  }\n  if (connection.source === shape || connection.target === shape) {\n    return false;\n  }\n\n  // return true if shape can be inserted into connection parent\n  return isAny(connection, ['bpmn:SequenceFlow', 'bpmn:MessageFlow']) && !isLabel(connection) && is(shape, 'bpmn:FlowNode') && !is(shape, 'bpmn:BoundaryEvent') && canDrop(shape, connection.parent, position);\n}\n\n/**\n * @param {Element[]} elements\n * @param {Element} element\n *\n * @return {boolean}\n */\nfunction includes(elements, element) {\n  return elements && element && elements.indexOf(element) !== -1;\n}\n\n/**\n * @param {Element[]} elements\n * @param {Element} element\n *\n * @return {boolean}\n */\nfunction canCopy(elements, element) {\n  if (isLabel(element)) {\n    return true;\n  }\n  if (is(element, 'bpmn:Lane') && !includes(elements, element.parent)) {\n    return false;\n  }\n  return true;\n}\n\n/**\n * @param {Element} element\n *\n * @return {Element|null}\n */\nfunction getRootElement(element) {\n  return getParent(element, 'bpmn:Process') || getParent(element, 'bpmn:Collaboration');\n}\nfunction isHostOfElement(potentialHost, element) {\n  return potentialHost.attachers.includes(element);\n}","map":{"version":3,"names":["every","find","forEach","some","inherits","is","getBusinessObject","getParent","isAny","isLabel","isExpanded","isEventSubProcess","isInterrupting","hasErrorEventDefinition","hasEscalationEventDefinition","hasCompensateEventDefinition","RuleProvider","getBoundaryAttachment","isBoundaryAttachment","isConnection","BpmnRules","eventBus","call","$inject","prototype","init","addRule","context","source","canStartConnection","target","hints","targetParent","targetAttach","parent","canConnect","connection","type","shape","newBounds","canResize","elements","position","canInsert","element","host","canAttach","canCreate","shapes","canReplace","canMove","canCopy","canConnectMessageFlow","canConnectSequenceFlow","canConnectDataAssociation","canConnectAssociation","canConnectCompensationAssociation","canDrop","nonExistingOrLabel","isSame","a","b","getOrganizationalParent","processRef","isTextAnnotation","isGroup","labelTarget","isCompensationBoundary","hasEventDefinition","isForCompensation","isSameOrganization","parentA","parentB","isMessageFlowSource","hasEventDefinitionOrNone","isMessageFlowTarget","getScopeParent","isSameScope","scopeParentA","scopeParentB","eventDefinition","businessObject","eventDefinitions","definition","isSequenceFlowSource","isSequenceFlowTarget","isEventBasedTarget","getParents","parents","push","isParent","possibleParent","allParents","indexOf","connectDataAssociation","associationDirection","isDroppableBoundaryEvent","get","participant","event","cancelActivity","hasNoEventDefinition","hasCommonBoundaryIntermediateEventDefinition","isBoundaryEvent","isLane","isBoundaryCandidate","length","hasOneOfEventDefinitions","isReceiveTaskAfterEventBasedGateway","incoming","Array","isArray","canExecute","replacements","oldElementId","id","newElementType","width","height","isOneTextAnnotation","sourceTextAnnotation","targetTextAnnotation","isHostOfElement","getRootElement","includes","potentialHost","attachers"],"sources":["/home/runner/work/sgex/sgex/node_modules/bpmn-js/lib/features/rules/BpmnRules.js"],"sourcesContent":["import {\n  every,\n  find,\n  forEach,\n  some\n} from 'min-dash';\n\nimport inherits from 'inherits-browser';\n\nimport {\n  is,\n  getBusinessObject\n} from '../../util/ModelUtil';\n\nimport {\n  getParent,\n  isAny\n} from '../modeling/util/ModelingUtil';\n\nimport {\n  isLabel\n} from '../../util/LabelUtil';\n\nimport {\n  isExpanded,\n  isEventSubProcess,\n  isInterrupting,\n  hasErrorEventDefinition,\n  hasEscalationEventDefinition,\n  hasCompensateEventDefinition\n} from '../../util/DiUtil';\n\nimport RuleProvider from 'diagram-js/lib/features/rules/RuleProvider';\n\nimport {\n  getBoundaryAttachment as isBoundaryAttachment\n} from '../snapping/BpmnSnappingUtil';\n\nimport { isConnection } from 'diagram-js/lib/util/ModelUtil';\n\n/**\n * @typedef {import('diagram-js/lib/core/EventBus').default} EventBus\n *\n * @typedef {import('../../model/Types').Connection} Connection\n * @typedef {import('../../model/Types').Element} Element\n * @typedef {import('../../model/Types').Shape} Shape\n * @typedef {import('../../model/Types').ModdleElement} ModdleElement\n *\n * @typedef {import('diagram-js/lib/util/Types').Point} Point\n * @typedef {import('diagram-js/lib/util/Types').Rect} Rect\n *\n * @typedef { {\n *   associationDirection?: 'None' | 'One' | 'Both';\n *   type: string;\n * } | boolean | null } CanConnectResult\n *\n * @typedef { {\n *   id: string;\n *   type: string;\n * } | boolean } CanReplaceResult\n */\n\n/**\n * BPMN-specific modeling rules.\n *\n * @param {EventBus} eventBus\n */\nexport default function BpmnRules(eventBus) {\n  RuleProvider.call(this, eventBus);\n}\n\ninherits(BpmnRules, RuleProvider);\n\nBpmnRules.$inject = [ 'eventBus' ];\n\nBpmnRules.prototype.init = function() {\n\n  this.addRule('connection.start', function(context) {\n    var source = context.source;\n\n    return canStartConnection(source);\n  });\n\n  this.addRule('connection.create', function(context) {\n    var source = context.source,\n        target = context.target,\n        hints = context.hints || {},\n        targetParent = hints.targetParent,\n        targetAttach = hints.targetAttach;\n\n    // don't allow incoming connections on\n    // newly created boundary events\n    // to boundary events\n    if (targetAttach) {\n      return false;\n    }\n\n    // temporarily set target parent for scoping\n    // checks to work\n    if (targetParent) {\n      target.parent = targetParent;\n    }\n\n    try {\n      return canConnect(source, target);\n    } finally {\n\n      // unset temporary target parent\n      if (targetParent) {\n        target.parent = null;\n      }\n    }\n  });\n\n  this.addRule('connection.reconnect', function(context) {\n\n    var connection = context.connection,\n        source = context.source,\n        target = context.target;\n\n    return canConnect(source, target, connection);\n  });\n\n  this.addRule('connection.updateWaypoints', function(context) {\n    return {\n      type: context.connection.type\n    };\n  });\n\n  this.addRule('shape.resize', function(context) {\n\n    var shape = context.shape,\n        newBounds = context.newBounds;\n\n    return canResize(shape, newBounds);\n  });\n\n  this.addRule('elements.create', function(context) {\n    var elements = context.elements,\n        position = context.position,\n        target = context.target;\n\n    if (isConnection(target) && !canInsert(elements, target, position)) {\n      return false;\n    }\n\n    return every(elements, function(element) {\n      if (isConnection(element)) {\n        return canConnect(element.source, element.target, element);\n      }\n\n      if (element.host) {\n        return canAttach(element, element.host, null, position);\n      }\n\n      return canCreate(element, target, null, position);\n    });\n  });\n\n  this.addRule('elements.move', function(context) {\n\n    var target = context.target,\n        shapes = context.shapes,\n        position = context.position;\n\n    return canAttach(shapes, target, null, position) ||\n           canReplace(shapes, target, position) ||\n           canMove(shapes, target, position) ||\n           canInsert(shapes, target, position);\n  });\n\n  this.addRule('shape.create', function(context) {\n    return canCreate(\n      context.shape,\n      context.target,\n      context.source,\n      context.position\n    );\n  });\n\n  this.addRule('shape.attach', function(context) {\n\n    return canAttach(\n      context.shape,\n      context.target,\n      null,\n      context.position\n    );\n  });\n\n  this.addRule('element.copy', function(context) {\n    var element = context.element,\n        elements = context.elements;\n\n    return canCopy(elements, element);\n  });\n};\n\nBpmnRules.prototype.canConnectMessageFlow = canConnectMessageFlow;\n\nBpmnRules.prototype.canConnectSequenceFlow = canConnectSequenceFlow;\n\nBpmnRules.prototype.canConnectDataAssociation = canConnectDataAssociation;\n\nBpmnRules.prototype.canConnectAssociation = canConnectAssociation;\n\nBpmnRules.prototype.canConnectCompensationAssociation = canConnectCompensationAssociation;\n\nBpmnRules.prototype.canMove = canMove;\n\nBpmnRules.prototype.canAttach = canAttach;\n\nBpmnRules.prototype.canReplace = canReplace;\n\nBpmnRules.prototype.canDrop = canDrop;\n\nBpmnRules.prototype.canInsert = canInsert;\n\nBpmnRules.prototype.canCreate = canCreate;\n\nBpmnRules.prototype.canConnect = canConnect;\n\nBpmnRules.prototype.canResize = canResize;\n\nBpmnRules.prototype.canCopy = canCopy;\n\n/**\n * Utility functions for rule checking\n */\n\n/**\n * Checks if given element can be used for starting connection.\n *\n * @param  {Element} source\n *\n * @return {boolean}\n */\nfunction canStartConnection(element) {\n  if (nonExistingOrLabel(element)) {\n    return null;\n  }\n\n  return isAny(element, [\n    'bpmn:FlowNode',\n    'bpmn:InteractionNode',\n    'bpmn:DataObjectReference',\n    'bpmn:DataStoreReference',\n    'bpmn:Group',\n    'bpmn:TextAnnotation'\n  ]);\n}\n\n/**\n * @param {Element} element\n *\n * @return {boolean}\n */\nfunction nonExistingOrLabel(element) {\n  return !element || isLabel(element);\n}\n\nfunction isSame(a, b) {\n  return a === b;\n}\n\n/**\n * @param {Element} element\n *\n * @return {ModdleElement}\n */\nfunction getOrganizationalParent(element) {\n\n  do {\n    if (is(element, 'bpmn:Process')) {\n      return getBusinessObject(element);\n    }\n\n    if (is(element, 'bpmn:Participant')) {\n      return (\n        getBusinessObject(element).processRef ||\n        getBusinessObject(element)\n      );\n    }\n  } while ((element = element.parent));\n\n}\n\n/**\n * @param {Element} element\n *\n * @return {boolean}\n */\nfunction isTextAnnotation(element) {\n  return is(element, 'bpmn:TextAnnotation');\n}\n\n/**\n * @param {Element} element\n *\n * @return {boolean}\n */\nfunction isGroup(element) {\n  return is(element, 'bpmn:Group') && !element.labelTarget;\n}\n\n/**\n * @param {Element} element\n *\n * @return {boolean}\n */\nfunction isCompensationBoundary(element) {\n  return is(element, 'bpmn:BoundaryEvent') &&\n         hasEventDefinition(element, 'bpmn:CompensateEventDefinition');\n}\n\n/**\n * @param {Element} element\n *\n * @return {boolean}\n */\nfunction isForCompensation(element) {\n  return getBusinessObject(element).isForCompensation;\n}\n\n/**\n * @param {Element} a\n * @param {Element} b\n *\n * @return {boolean}\n */\nfunction isSameOrganization(a, b) {\n  var parentA = getOrganizationalParent(a),\n      parentB = getOrganizationalParent(b);\n\n  return parentA === parentB;\n}\n\n/**\n * @param {Element} element\n *\n * @return {boolean}\n */\nfunction isMessageFlowSource(element) {\n  return (\n    is(element, 'bpmn:InteractionNode') &&\n    !is(element, 'bpmn:BoundaryEvent') && (\n      !is(element, 'bpmn:Event') || (\n        is(element, 'bpmn:ThrowEvent') &&\n        hasEventDefinitionOrNone(element, 'bpmn:MessageEventDefinition')\n      )\n    )\n  );\n}\n\n/**\n * @param {Element} element\n *\n * @return {boolean}\n */\nfunction isMessageFlowTarget(element) {\n  return (\n    is(element, 'bpmn:InteractionNode') &&\n    !isForCompensation(element) && (\n      !is(element, 'bpmn:Event') || (\n        is(element, 'bpmn:CatchEvent') &&\n        hasEventDefinitionOrNone(element, 'bpmn:MessageEventDefinition')\n      )\n    ) && !(\n      is(element, 'bpmn:BoundaryEvent') &&\n      !hasEventDefinition(element, 'bpmn:MessageEventDefinition')\n    )\n  );\n}\n\n/**\n * @param {Element} element\n *\n * @return {ModdleElement}\n */\nfunction getScopeParent(element) {\n\n  var parent = element;\n\n  while ((parent = parent.parent)) {\n\n    if (is(parent, 'bpmn:FlowElementsContainer')) {\n      return getBusinessObject(parent);\n    }\n\n    if (is(parent, 'bpmn:Participant')) {\n      return getBusinessObject(parent).processRef;\n    }\n  }\n\n  return null;\n}\n\n/**\n * @param {Element} a\n * @param {Element} b\n *\n * @return {boolean}\n */\nfunction isSameScope(a, b) {\n  var scopeParentA = getScopeParent(a),\n      scopeParentB = getScopeParent(b);\n\n  return scopeParentA === scopeParentB;\n}\n\n/**\n * @param {Element} element\n * @param {string} eventDefinition\n *\n * @return {boolean}\n */\nfunction hasEventDefinition(element, eventDefinition) {\n  var businessObject = getBusinessObject(element);\n\n  return !!find(businessObject.eventDefinitions || [], function(definition) {\n    return is(definition, eventDefinition);\n  });\n}\n\n/**\n * @param {Element} element\n * @param {string} eventDefinition\n *\n * @return {boolean}\n */\nfunction hasEventDefinitionOrNone(element, eventDefinition) {\n  var businessObject = getBusinessObject(element);\n\n  return (businessObject.eventDefinitions || []).every(function(definition) {\n    return is(definition, eventDefinition);\n  });\n}\n\n/**\n * @param {Element} element\n *\n * @return {boolean}\n */\nfunction isSequenceFlowSource(element) {\n  return (\n    is(element, 'bpmn:FlowNode') &&\n    !is(element, 'bpmn:EndEvent') &&\n    !isEventSubProcess(element) &&\n    !(is(element, 'bpmn:IntermediateThrowEvent') &&\n      hasEventDefinition(element, 'bpmn:LinkEventDefinition')\n    ) &&\n    !isCompensationBoundary(element) &&\n    !isForCompensation(element)\n  );\n}\n\n/**\n * @param {Element} element\n *\n * @return {boolean}\n */\nfunction isSequenceFlowTarget(element) {\n  return (\n    is(element, 'bpmn:FlowNode') &&\n    !is(element, 'bpmn:StartEvent') &&\n    !is(element, 'bpmn:BoundaryEvent') &&\n    !isEventSubProcess(element) &&\n    !(is(element, 'bpmn:IntermediateCatchEvent') &&\n      hasEventDefinition(element, 'bpmn:LinkEventDefinition')\n    ) &&\n    !isForCompensation(element)\n  );\n}\n\n/**\n * @param {Element} element\n *\n * @return {boolean}\n */\nfunction isEventBasedTarget(element) {\n  return (\n    is(element, 'bpmn:ReceiveTask') || (\n      is(element, 'bpmn:IntermediateCatchEvent') && (\n        hasEventDefinition(element, 'bpmn:MessageEventDefinition') ||\n        hasEventDefinition(element, 'bpmn:TimerEventDefinition') ||\n        hasEventDefinition(element, 'bpmn:ConditionalEventDefinition') ||\n        hasEventDefinition(element, 'bpmn:SignalEventDefinition')\n      )\n    )\n  );\n}\n\n/**\n * @param {Element} element\n *\n * @return {Shape[]}\n */\nfunction getParents(element) {\n\n  var parents = [];\n\n  while (element) {\n    element = element.parent;\n\n    if (element) {\n      parents.push(element);\n    }\n  }\n\n  return parents;\n}\n\n/**\n * @param {Shape} possibleParent\n * @param {Element} element\n *\n * @return {boolean}\n */\nfunction isParent(possibleParent, element) {\n  var allParents = getParents(element);\n\n  return allParents.indexOf(possibleParent) !== -1;\n}\n\n/**\n * @param {Element} source\n * @param {Element} target\n * @param {Connection} connection\n *\n * @return {CanConnectResult}\n */\nfunction canConnect(source, target, connection) {\n\n  if (nonExistingOrLabel(source) || nonExistingOrLabel(target)) {\n    return null;\n  }\n\n  if (!is(connection, 'bpmn:DataAssociation')) {\n\n    if (canConnectMessageFlow(source, target)) {\n      return { type: 'bpmn:MessageFlow' };\n    }\n\n    if (canConnectSequenceFlow(source, target)) {\n      return { type: 'bpmn:SequenceFlow' };\n    }\n  }\n\n  var connectDataAssociation = canConnectDataAssociation(source, target);\n\n  if (connectDataAssociation) {\n    return connectDataAssociation;\n  }\n\n  if (canConnectCompensationAssociation(source, target)) {\n    return {\n      type: 'bpmn:Association',\n      associationDirection: 'One'\n    };\n  }\n\n  if (canConnectAssociation(source, target)) {\n    return {\n      type: 'bpmn:Association',\n      associationDirection: 'None'\n    };\n  }\n\n  return false;\n}\n\n/**\n * Can an element be dropped into the target element.\n *\n * @param {Element} element\n * @param {Shape} target\n *\n * @return {boolean}\n */\nfunction canDrop(element, target) {\n\n  // can move labels and groups everywhere\n  if (isLabel(element) || isGroup(element)) {\n    return true;\n  }\n\n\n  // disallow to create elements on collapsed pools\n  if (is(target, 'bpmn:Participant') && !isExpanded(target)) {\n    return false;\n  }\n\n  // allow to create new participants on\n  // existing collaboration and process diagrams\n  if (is(element, 'bpmn:Participant')) {\n    return is(target, 'bpmn:Process') || is(target, 'bpmn:Collaboration');\n  }\n\n  // allow moving DataInput / DataOutput within its original container only\n  if (isAny(element, [ 'bpmn:DataInput', 'bpmn:DataOutput' ])) {\n\n    if (element.parent) {\n      return target === element.parent;\n    }\n  }\n\n  // allow creating lanes on participants and other lanes only\n  if (is(element, 'bpmn:Lane')) {\n    return is(target, 'bpmn:Participant') || is(target, 'bpmn:Lane');\n  }\n\n  // disallow dropping boundary events which cannot replace with intermediate event\n  if (is(element, 'bpmn:BoundaryEvent') && !isDroppableBoundaryEvent(element)) {\n    return false;\n  }\n\n  // drop flow elements onto flow element containers\n  // and participants\n  if (is(element, 'bpmn:FlowElement') && !is(element, 'bpmn:DataStoreReference')) {\n    if (is(target, 'bpmn:FlowElementsContainer')) {\n      return isExpanded(target);\n    }\n\n    return isAny(target, [ 'bpmn:Participant', 'bpmn:Lane' ]);\n  }\n\n  // disallow dropping data store reference if there is no process to append to\n  if (is(element, 'bpmn:DataStoreReference') && is(target, 'bpmn:Collaboration')) {\n    return some(getBusinessObject(target).get('participants'), function(participant) {\n      return !!participant.get('processRef');\n    });\n  }\n\n  // account for the fact that data associations are always\n  // rendered and moved to top (Process or Collaboration level)\n  //\n  // artifacts may be placed wherever, too\n  if (isAny(element, [ 'bpmn:Artifact', 'bpmn:DataAssociation', 'bpmn:DataStoreReference' ])) {\n    return isAny(target, [\n      'bpmn:Collaboration',\n      'bpmn:Lane',\n      'bpmn:Participant',\n      'bpmn:Process',\n      'bpmn:SubProcess' ]);\n  }\n\n  if (is(element, 'bpmn:MessageFlow')) {\n    return is(target, 'bpmn:Collaboration')\n      || element.source.parent == target\n      || element.target.parent == target;\n  }\n\n  return false;\n}\n\n/**\n * @param {Shape} event\n *\n * @return {boolean}\n */\nfunction isDroppableBoundaryEvent(event) {\n  return getBusinessObject(event).cancelActivity && (\n    hasNoEventDefinition(event) || hasCommonBoundaryIntermediateEventDefinition(event)\n  );\n}\n\n/**\n * @param {Element} element\n *\n * @return {boolean}\n */\nfunction isBoundaryEvent(element) {\n  return !isLabel(element) && is(element, 'bpmn:BoundaryEvent');\n}\n\n/**\n * @param {Element} element\n *\n * @return {boolean}\n */\nfunction isLane(element) {\n  return is(element, 'bpmn:Lane');\n}\n\n/**\n * `bpmn:IntermediateThrowEvents` are treated as boundary events during create.\n *\n * @param {Element} element\n *\n * @return {boolean}\n */\nfunction isBoundaryCandidate(element) {\n  if (isBoundaryEvent(element)) {\n    return true;\n  }\n\n  if (is(element, 'bpmn:IntermediateThrowEvent') && hasNoEventDefinition(element)) {\n    return true;\n  }\n\n  return (\n    is(element, 'bpmn:IntermediateCatchEvent') &&\n    hasCommonBoundaryIntermediateEventDefinition(element)\n  );\n}\n\n/**\n * @param {Element} element\n *\n * @return {boolean}\n */\nfunction hasNoEventDefinition(element) {\n  var businessObject = getBusinessObject(element);\n\n  return businessObject && !(businessObject.eventDefinitions && businessObject.eventDefinitions.length);\n}\n\n/**\n * @param {Element} element\n *\n * @return {boolean}\n */\nfunction hasCommonBoundaryIntermediateEventDefinition(element) {\n  return hasOneOfEventDefinitions(element, [\n    'bpmn:MessageEventDefinition',\n    'bpmn:TimerEventDefinition',\n    'bpmn:SignalEventDefinition',\n    'bpmn:ConditionalEventDefinition'\n  ]);\n}\n\n/**\n * @param {Element} element\n * @param {string[]} eventDefinitions\n *\n * @return {boolean}\n */\nfunction hasOneOfEventDefinitions(element, eventDefinitions) {\n  return eventDefinitions.some(function(definition) {\n    return hasEventDefinition(element, definition);\n  });\n}\n\n/**\n * @param {Element} element\n *\n * @return {boolean}\n */\nfunction isReceiveTaskAfterEventBasedGateway(element) {\n  return (\n    is(element, 'bpmn:ReceiveTask') &&\n    find(element.incoming, function(incoming) {\n      return is(incoming.source, 'bpmn:EventBasedGateway');\n    })\n  );\n}\n\n/**\n * TODO(philippfromme): remove `source` parameter\n *\n * @param {Element[]} elements\n * @param {Shape} target\n * @param {Element} source\n * @param {Point} [position]\n *\n * @return {boolean | 'attach'}\n */\nfunction canAttach(elements, target, source, position) {\n\n  if (!Array.isArray(elements)) {\n    elements = [ elements ];\n  }\n\n  // only (re-)attach one element at a time\n  if (elements.length !== 1) {\n    return false;\n  }\n\n  var element = elements[0];\n\n  // do not attach labels\n  if (isLabel(element)) {\n    return false;\n  }\n\n  // only handle boundary events\n  if (!isBoundaryCandidate(element)) {\n    return false;\n  }\n\n  // disallow drop on event sub processes\n  if (isEventSubProcess(target)) {\n    return false;\n  }\n\n  // only allow drop on non compensation activities\n  if (!is(target, 'bpmn:Activity') || isForCompensation(target)) {\n    return false;\n  }\n\n  // only attach to subprocess border\n  if (position && !isBoundaryAttachment(position, target)) {\n    return false;\n  }\n\n  // do not attach on receive tasks after event based gateways\n  if (isReceiveTaskAfterEventBasedGateway(target)) {\n    return false;\n  }\n\n  return 'attach';\n}\n\n/**\n * Check whether the given elements can be replaced. Return all elements which\n * can be replaced.\n *\n * @example\n *\n * ```javascript\n * [{\n *   id: 'IntermediateEvent_1',\n *   type: 'bpmn:StartEvent'\n * },\n * {\n *   id: 'Task_1',\n *   type: 'bpmn:ServiceTask'\n * }]\n * ```\n *\n * @param  {Element[]} elements\n * @param  {Shape} [target]\n * @param  {Point} [position]\n *\n * @return {CanReplaceResult}\n */\nfunction canReplace(elements, target, position) {\n\n  if (!target) {\n    return false;\n  }\n\n  var canExecute = {\n    replacements: []\n  };\n\n  forEach(elements, function(element) {\n\n    if (!isEventSubProcess(target)) {\n\n      if (is(element, 'bpmn:StartEvent') &&\n          element.type !== 'label' &&\n          canDrop(element, target)) {\n\n        // replace a non-interrupting start event by a blank interrupting start event\n        // when the target is not an event sub process\n        if (!isInterrupting(element)) {\n          canExecute.replacements.push({\n            oldElementId: element.id,\n            newElementType: 'bpmn:StartEvent'\n          });\n        }\n\n        // replace an error/escalation/compensate start event by a blank interrupting start event\n        // when the target is not an event sub process\n        if (hasErrorEventDefinition(element) ||\n            hasEscalationEventDefinition(element) ||\n            hasCompensateEventDefinition(element)) {\n          canExecute.replacements.push({\n            oldElementId: element.id,\n            newElementType: 'bpmn:StartEvent'\n          });\n        }\n\n        // replace a typed start event by a blank interrupting start event\n        // when the target is a sub process but not an event sub process\n        if (hasOneOfEventDefinitions(element,\n          [\n            'bpmn:MessageEventDefinition',\n            'bpmn:TimerEventDefinition',\n            'bpmn:SignalEventDefinition',\n            'bpmn:ConditionalEventDefinition'\n          ]) &&\n            is(target, 'bpmn:SubProcess')) {\n          canExecute.replacements.push({\n            oldElementId: element.id,\n            newElementType: 'bpmn:StartEvent'\n          });\n        }\n      }\n    }\n\n    if (!is(target, 'bpmn:Transaction')) {\n      if (hasEventDefinition(element, 'bpmn:CancelEventDefinition') &&\n          element.type !== 'label') {\n\n        if (is(element, 'bpmn:EndEvent') && canDrop(element, target)) {\n          canExecute.replacements.push({\n            oldElementId: element.id,\n            newElementType: 'bpmn:EndEvent'\n          });\n        }\n\n        if (is(element, 'bpmn:BoundaryEvent') && canAttach(element, target, null, position)) {\n          canExecute.replacements.push({\n            oldElementId: element.id,\n            newElementType: 'bpmn:BoundaryEvent'\n          });\n        }\n      }\n    }\n  });\n\n  return canExecute.replacements.length ? canExecute : false;\n}\n\n/**\n * @param {Element[]} elements\n * @param {Shape} target\n *\n * @return {boolean}\n */\nfunction canMove(elements, target) {\n\n  // do not move selection containing lanes\n  if (some(elements, isLane)) {\n    return false;\n  }\n\n  // allow default move check to start move operation\n  if (!target) {\n    return true;\n  }\n\n  return elements.every(function(element) {\n    return canDrop(element, target);\n  });\n}\n\n/**\n * @param {Shape} shape\n * @param {Shape} target\n * @param {Element} source\n * @param {Point} position\n *\n * @return {boolean}\n */\nfunction canCreate(shape, target, source, position) {\n\n  if (!target) {\n    return false;\n  }\n\n  if (isLabel(shape) || isGroup(shape)) {\n    return true;\n  }\n\n  if (isSame(source, target)) {\n    return false;\n  }\n\n  // ensure we do not drop the element\n  // into source\n  if (source && isParent(source, target)) {\n    return false;\n  }\n\n  return canDrop(shape, target, position) || canInsert(shape, target, position);\n}\n\n/**\n * @param {Shape} shape\n * @param {Rect} newBounds\n *\n * @return {boolean}\n */\nfunction canResize(shape, newBounds) {\n  if (is(shape, 'bpmn:SubProcess')) {\n    return (\n      isExpanded(shape) && (\n        !newBounds || (newBounds.width >= 100 && newBounds.height >= 80)\n      )\n    );\n  }\n\n  if (is(shape, 'bpmn:Lane')) {\n    return true;\n  }\n\n  if (is(shape, 'bpmn:Participant')) {\n    return true;\n  }\n\n  if (isTextAnnotation(shape)) {\n    return true;\n  }\n\n  if (isGroup(shape)) {\n    return true;\n  }\n\n  return false;\n}\n\n/**\n * Check whether one of of the elements to be connected is a text annotation.\n *\n * @param {Element} source\n * @param {Element} target\n *\n * @return {boolean}\n */\nfunction isOneTextAnnotation(source, target) {\n\n  var sourceTextAnnotation = isTextAnnotation(source),\n      targetTextAnnotation = isTextAnnotation(target);\n\n  return (\n    (sourceTextAnnotation || targetTextAnnotation) &&\n    (sourceTextAnnotation !== targetTextAnnotation)\n  );\n}\n\n/**\n * @param {Element} source\n * @param {Element} target\n *\n * @return {CanConnectResult}\n */\nfunction canConnectAssociation(source, target) {\n\n  // don't connect parent <-> child\n  if (isParent(target, source) || isParent(source, target)) {\n    return false;\n  }\n\n  // allow connection of associations between <!TextAnnotation> and <TextAnnotation>\n  if (isOneTextAnnotation(source, target)) {\n    return true;\n  }\n\n  // can connect associations where we can connect\n  // data associations, too (!)\n  return !!canConnectDataAssociation(source, target);\n}\n\n/**\n * @param {Element} source\n * @param {Element} target\n *\n * @return {boolean}\n */\nfunction canConnectCompensationAssociation(source, target) {\n  return (\n    isSameScope(source, target) &&\n    isCompensationBoundary(source) &&\n    is(target, 'bpmn:Activity') &&\n    !isHostOfElement(target, source) &&\n    !isEventSubProcess(target)\n  );\n}\n\n/**\n * @param {Element} source\n * @param {Element} target\n *\n * @return {boolean}\n */\nfunction canConnectMessageFlow(source, target) {\n\n  // during connect user might move mouse out of canvas\n  // https://github.com/bpmn-io/bpmn-js/issues/1033\n  if (getRootElement(source) && !getRootElement(target)) {\n    return false;\n  }\n\n  return (\n    isMessageFlowSource(source) &&\n    isMessageFlowTarget(target) &&\n    !isSameOrganization(source, target)\n  );\n}\n\n/**\n * @param {Element} source\n * @param {Element} target\n *\n * @return {boolean}\n */\nfunction canConnectSequenceFlow(source, target) {\n  return isSequenceFlowSource(source) &&\n         isSequenceFlowTarget(target) &&\n         isSameScope(source, target) &&\n         !(is(source, 'bpmn:EventBasedGateway') && !isEventBasedTarget(target));\n}\n\n/**\n * @param {Element} source\n * @param {Element} target\n *\n * @return {CanConnectResult}\n */\nfunction canConnectDataAssociation(source, target) {\n\n  if (isAny(source, [ 'bpmn:DataObjectReference', 'bpmn:DataStoreReference' ]) &&\n      isAny(target, [ 'bpmn:Activity', 'bpmn:ThrowEvent' ])) {\n    return { type: 'bpmn:DataInputAssociation' };\n  }\n\n  if (isAny(target, [ 'bpmn:DataObjectReference', 'bpmn:DataStoreReference' ]) &&\n      isAny(source, [ 'bpmn:Activity', 'bpmn:CatchEvent' ])) {\n    return { type: 'bpmn:DataOutputAssociation' };\n  }\n\n  return false;\n}\n\n/**\n * @param {Shape} shape\n * @param {Connection} connection\n * @param {Point} position\n *\n * @return {boolean}\n */\nfunction canInsert(shape, connection, position) {\n  if (!connection) {\n    return false;\n  }\n\n  if (Array.isArray(shape)) {\n    if (shape.length !== 1) {\n      return false;\n    }\n\n    shape = shape[ 0 ];\n  }\n\n  if (connection.source === shape ||\n      connection.target === shape) {\n    return false;\n  }\n\n  // return true if shape can be inserted into connection parent\n  return (\n    isAny(connection, [ 'bpmn:SequenceFlow', 'bpmn:MessageFlow' ]) &&\n    !isLabel(connection) &&\n    is(shape, 'bpmn:FlowNode') &&\n    !is(shape, 'bpmn:BoundaryEvent') &&\n    canDrop(shape, connection.parent, position));\n}\n\n/**\n * @param {Element[]} elements\n * @param {Element} element\n *\n * @return {boolean}\n */\nfunction includes(elements, element) {\n  return (elements && element) && elements.indexOf(element) !== -1;\n}\n\n/**\n * @param {Element[]} elements\n * @param {Element} element\n *\n * @return {boolean}\n */\nfunction canCopy(elements, element) {\n  if (isLabel(element)) {\n    return true;\n  }\n\n  if (is(element, 'bpmn:Lane') && !includes(elements, element.parent)) {\n    return false;\n  }\n\n  return true;\n}\n\n/**\n * @param {Element} element\n *\n * @return {Element|null}\n */\nfunction getRootElement(element) {\n  return getParent(element, 'bpmn:Process') || getParent(element, 'bpmn:Collaboration');\n}\n\nfunction isHostOfElement(potentialHost, element) {\n  return potentialHost.attachers.includes(element);\n}\n"],"mappings":"AAAA,SACEA,KAAK,EACLC,IAAI,EACJC,OAAO,EACPC,IAAI,QACC,UAAU;AAEjB,OAAOC,QAAQ,MAAM,kBAAkB;AAEvC,SACEC,EAAE,EACFC,iBAAiB,QACZ,sBAAsB;AAE7B,SACEC,SAAS,EACTC,KAAK,QACA,+BAA+B;AAEtC,SACEC,OAAO,QACF,sBAAsB;AAE7B,SACEC,UAAU,EACVC,iBAAiB,EACjBC,cAAc,EACdC,uBAAuB,EACvBC,4BAA4B,EAC5BC,4BAA4B,QACvB,mBAAmB;AAE1B,OAAOC,YAAY,MAAM,4CAA4C;AAErE,SACEC,qBAAqB,IAAIC,oBAAoB,QACxC,8BAA8B;AAErC,SAASC,YAAY,QAAQ,+BAA+B;;AAE5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,eAAe,SAASC,SAASA,CAACC,QAAQ,EAAE;EAC1CL,YAAY,CAACM,IAAI,CAAC,IAAI,EAAED,QAAQ,CAAC;AACnC;AAEAjB,QAAQ,CAACgB,SAAS,EAAEJ,YAAY,CAAC;AAEjCI,SAAS,CAACG,OAAO,GAAG,CAAE,UAAU,CAAE;AAElCH,SAAS,CAACI,SAAS,CAACC,IAAI,GAAG,YAAW;EAEpC,IAAI,CAACC,OAAO,CAAC,kBAAkB,EAAE,UAASC,OAAO,EAAE;IACjD,IAAIC,MAAM,GAAGD,OAAO,CAACC,MAAM;IAE3B,OAAOC,kBAAkB,CAACD,MAAM,CAAC;EACnC,CAAC,CAAC;EAEF,IAAI,CAACF,OAAO,CAAC,mBAAmB,EAAE,UAASC,OAAO,EAAE;IAClD,IAAIC,MAAM,GAAGD,OAAO,CAACC,MAAM;MACvBE,MAAM,GAAGH,OAAO,CAACG,MAAM;MACvBC,KAAK,GAAGJ,OAAO,CAACI,KAAK,IAAI,CAAC,CAAC;MAC3BC,YAAY,GAAGD,KAAK,CAACC,YAAY;MACjCC,YAAY,GAAGF,KAAK,CAACE,YAAY;;IAErC;IACA;IACA;IACA,IAAIA,YAAY,EAAE;MAChB,OAAO,KAAK;IACd;;IAEA;IACA;IACA,IAAID,YAAY,EAAE;MAChBF,MAAM,CAACI,MAAM,GAAGF,YAAY;IAC9B;IAEA,IAAI;MACF,OAAOG,UAAU,CAACP,MAAM,EAAEE,MAAM,CAAC;IACnC,CAAC,SAAS;MAER;MACA,IAAIE,YAAY,EAAE;QAChBF,MAAM,CAACI,MAAM,GAAG,IAAI;MACtB;IACF;EACF,CAAC,CAAC;EAEF,IAAI,CAACR,OAAO,CAAC,sBAAsB,EAAE,UAASC,OAAO,EAAE;IAErD,IAAIS,UAAU,GAAGT,OAAO,CAACS,UAAU;MAC/BR,MAAM,GAAGD,OAAO,CAACC,MAAM;MACvBE,MAAM,GAAGH,OAAO,CAACG,MAAM;IAE3B,OAAOK,UAAU,CAACP,MAAM,EAAEE,MAAM,EAAEM,UAAU,CAAC;EAC/C,CAAC,CAAC;EAEF,IAAI,CAACV,OAAO,CAAC,4BAA4B,EAAE,UAASC,OAAO,EAAE;IAC3D,OAAO;MACLU,IAAI,EAAEV,OAAO,CAACS,UAAU,CAACC;IAC3B,CAAC;EACH,CAAC,CAAC;EAEF,IAAI,CAACX,OAAO,CAAC,cAAc,EAAE,UAASC,OAAO,EAAE;IAE7C,IAAIW,KAAK,GAAGX,OAAO,CAACW,KAAK;MACrBC,SAAS,GAAGZ,OAAO,CAACY,SAAS;IAEjC,OAAOC,SAAS,CAACF,KAAK,EAAEC,SAAS,CAAC;EACpC,CAAC,CAAC;EAEF,IAAI,CAACb,OAAO,CAAC,iBAAiB,EAAE,UAASC,OAAO,EAAE;IAChD,IAAIc,QAAQ,GAAGd,OAAO,CAACc,QAAQ;MAC3BC,QAAQ,GAAGf,OAAO,CAACe,QAAQ;MAC3BZ,MAAM,GAAGH,OAAO,CAACG,MAAM;IAE3B,IAAIX,YAAY,CAACW,MAAM,CAAC,IAAI,CAACa,SAAS,CAACF,QAAQ,EAAEX,MAAM,EAAEY,QAAQ,CAAC,EAAE;MAClE,OAAO,KAAK;IACd;IAEA,OAAO1C,KAAK,CAACyC,QAAQ,EAAE,UAASG,OAAO,EAAE;MACvC,IAAIzB,YAAY,CAACyB,OAAO,CAAC,EAAE;QACzB,OAAOT,UAAU,CAACS,OAAO,CAAChB,MAAM,EAAEgB,OAAO,CAACd,MAAM,EAAEc,OAAO,CAAC;MAC5D;MAEA,IAAIA,OAAO,CAACC,IAAI,EAAE;QAChB,OAAOC,SAAS,CAACF,OAAO,EAAEA,OAAO,CAACC,IAAI,EAAE,IAAI,EAAEH,QAAQ,CAAC;MACzD;MAEA,OAAOK,SAAS,CAACH,OAAO,EAAEd,MAAM,EAAE,IAAI,EAAEY,QAAQ,CAAC;IACnD,CAAC,CAAC;EACJ,CAAC,CAAC;EAEF,IAAI,CAAChB,OAAO,CAAC,eAAe,EAAE,UAASC,OAAO,EAAE;IAE9C,IAAIG,MAAM,GAAGH,OAAO,CAACG,MAAM;MACvBkB,MAAM,GAAGrB,OAAO,CAACqB,MAAM;MACvBN,QAAQ,GAAGf,OAAO,CAACe,QAAQ;IAE/B,OAAOI,SAAS,CAACE,MAAM,EAAElB,MAAM,EAAE,IAAI,EAAEY,QAAQ,CAAC,IACzCO,UAAU,CAACD,MAAM,EAAElB,MAAM,EAAEY,QAAQ,CAAC,IACpCQ,OAAO,CAACF,MAAM,EAAElB,MAAM,EAAEY,QAAQ,CAAC,IACjCC,SAAS,CAACK,MAAM,EAAElB,MAAM,EAAEY,QAAQ,CAAC;EAC5C,CAAC,CAAC;EAEF,IAAI,CAAChB,OAAO,CAAC,cAAc,EAAE,UAASC,OAAO,EAAE;IAC7C,OAAOoB,SAAS,CACdpB,OAAO,CAACW,KAAK,EACbX,OAAO,CAACG,MAAM,EACdH,OAAO,CAACC,MAAM,EACdD,OAAO,CAACe,QACV,CAAC;EACH,CAAC,CAAC;EAEF,IAAI,CAAChB,OAAO,CAAC,cAAc,EAAE,UAASC,OAAO,EAAE;IAE7C,OAAOmB,SAAS,CACdnB,OAAO,CAACW,KAAK,EACbX,OAAO,CAACG,MAAM,EACd,IAAI,EACJH,OAAO,CAACe,QACV,CAAC;EACH,CAAC,CAAC;EAEF,IAAI,CAAChB,OAAO,CAAC,cAAc,EAAE,UAASC,OAAO,EAAE;IAC7C,IAAIiB,OAAO,GAAGjB,OAAO,CAACiB,OAAO;MACzBH,QAAQ,GAAGd,OAAO,CAACc,QAAQ;IAE/B,OAAOU,OAAO,CAACV,QAAQ,EAAEG,OAAO,CAAC;EACnC,CAAC,CAAC;AACJ,CAAC;AAEDxB,SAAS,CAACI,SAAS,CAAC4B,qBAAqB,GAAGA,qBAAqB;AAEjEhC,SAAS,CAACI,SAAS,CAAC6B,sBAAsB,GAAGA,sBAAsB;AAEnEjC,SAAS,CAACI,SAAS,CAAC8B,yBAAyB,GAAGA,yBAAyB;AAEzElC,SAAS,CAACI,SAAS,CAAC+B,qBAAqB,GAAGA,qBAAqB;AAEjEnC,SAAS,CAACI,SAAS,CAACgC,iCAAiC,GAAGA,iCAAiC;AAEzFpC,SAAS,CAACI,SAAS,CAAC0B,OAAO,GAAGA,OAAO;AAErC9B,SAAS,CAACI,SAAS,CAACsB,SAAS,GAAGA,SAAS;AAEzC1B,SAAS,CAACI,SAAS,CAACyB,UAAU,GAAGA,UAAU;AAE3C7B,SAAS,CAACI,SAAS,CAACiC,OAAO,GAAGA,OAAO;AAErCrC,SAAS,CAACI,SAAS,CAACmB,SAAS,GAAGA,SAAS;AAEzCvB,SAAS,CAACI,SAAS,CAACuB,SAAS,GAAGA,SAAS;AAEzC3B,SAAS,CAACI,SAAS,CAACW,UAAU,GAAGA,UAAU;AAE3Cf,SAAS,CAACI,SAAS,CAACgB,SAAS,GAAGA,SAAS;AAEzCpB,SAAS,CAACI,SAAS,CAAC2B,OAAO,GAAGA,OAAO;;AAErC;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAStB,kBAAkBA,CAACe,OAAO,EAAE;EACnC,IAAIc,kBAAkB,CAACd,OAAO,CAAC,EAAE;IAC/B,OAAO,IAAI;EACb;EAEA,OAAOpC,KAAK,CAACoC,OAAO,EAAE,CACpB,eAAe,EACf,sBAAsB,EACtB,0BAA0B,EAC1B,yBAAyB,EACzB,YAAY,EACZ,qBAAqB,CACtB,CAAC;AACJ;;AAEA;AACA;AACA;AACA;AACA;AACA,SAASc,kBAAkBA,CAACd,OAAO,EAAE;EACnC,OAAO,CAACA,OAAO,IAAInC,OAAO,CAACmC,OAAO,CAAC;AACrC;AAEA,SAASe,MAAMA,CAACC,CAAC,EAAEC,CAAC,EAAE;EACpB,OAAOD,CAAC,KAAKC,CAAC;AAChB;;AAEA;AACA;AACA;AACA;AACA;AACA,SAASC,uBAAuBA,CAAClB,OAAO,EAAE;EAExC,GAAG;IACD,IAAIvC,EAAE,CAACuC,OAAO,EAAE,cAAc,CAAC,EAAE;MAC/B,OAAOtC,iBAAiB,CAACsC,OAAO,CAAC;IACnC;IAEA,IAAIvC,EAAE,CAACuC,OAAO,EAAE,kBAAkB,CAAC,EAAE;MACnC,OACEtC,iBAAiB,CAACsC,OAAO,CAAC,CAACmB,UAAU,IACrCzD,iBAAiB,CAACsC,OAAO,CAAC;IAE9B;EACF,CAAC,QAASA,OAAO,GAAGA,OAAO,CAACV,MAAM;AAEpC;;AAEA;AACA;AACA;AACA;AACA;AACA,SAAS8B,gBAAgBA,CAACpB,OAAO,EAAE;EACjC,OAAOvC,EAAE,CAACuC,OAAO,EAAE,qBAAqB,CAAC;AAC3C;;AAEA;AACA;AACA;AACA;AACA;AACA,SAASqB,OAAOA,CAACrB,OAAO,EAAE;EACxB,OAAOvC,EAAE,CAACuC,OAAO,EAAE,YAAY,CAAC,IAAI,CAACA,OAAO,CAACsB,WAAW;AAC1D;;AAEA;AACA;AACA;AACA;AACA;AACA,SAASC,sBAAsBA,CAACvB,OAAO,EAAE;EACvC,OAAOvC,EAAE,CAACuC,OAAO,EAAE,oBAAoB,CAAC,IACjCwB,kBAAkB,CAACxB,OAAO,EAAE,gCAAgC,CAAC;AACtE;;AAEA;AACA;AACA;AACA;AACA;AACA,SAASyB,iBAAiBA,CAACzB,OAAO,EAAE;EAClC,OAAOtC,iBAAiB,CAACsC,OAAO,CAAC,CAACyB,iBAAiB;AACrD;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,SAASC,kBAAkBA,CAACV,CAAC,EAAEC,CAAC,EAAE;EAChC,IAAIU,OAAO,GAAGT,uBAAuB,CAACF,CAAC,CAAC;IACpCY,OAAO,GAAGV,uBAAuB,CAACD,CAAC,CAAC;EAExC,OAAOU,OAAO,KAAKC,OAAO;AAC5B;;AAEA;AACA;AACA;AACA;AACA;AACA,SAASC,mBAAmBA,CAAC7B,OAAO,EAAE;EACpC,OACEvC,EAAE,CAACuC,OAAO,EAAE,sBAAsB,CAAC,IACnC,CAACvC,EAAE,CAACuC,OAAO,EAAE,oBAAoB,CAAC,KAChC,CAACvC,EAAE,CAACuC,OAAO,EAAE,YAAY,CAAC,IACxBvC,EAAE,CAACuC,OAAO,EAAE,iBAAiB,CAAC,IAC9B8B,wBAAwB,CAAC9B,OAAO,EAAE,6BAA6B,CAChE,CACF;AAEL;;AAEA;AACA;AACA;AACA;AACA;AACA,SAAS+B,mBAAmBA,CAAC/B,OAAO,EAAE;EACpC,OACEvC,EAAE,CAACuC,OAAO,EAAE,sBAAsB,CAAC,IACnC,CAACyB,iBAAiB,CAACzB,OAAO,CAAC,KACzB,CAACvC,EAAE,CAACuC,OAAO,EAAE,YAAY,CAAC,IACxBvC,EAAE,CAACuC,OAAO,EAAE,iBAAiB,CAAC,IAC9B8B,wBAAwB,CAAC9B,OAAO,EAAE,6BAA6B,CAChE,CACF,IAAI,EACHvC,EAAE,CAACuC,OAAO,EAAE,oBAAoB,CAAC,IACjC,CAACwB,kBAAkB,CAACxB,OAAO,EAAE,6BAA6B,CAAC,CAC5D;AAEL;;AAEA;AACA;AACA;AACA;AACA;AACA,SAASgC,cAAcA,CAAChC,OAAO,EAAE;EAE/B,IAAIV,MAAM,GAAGU,OAAO;EAEpB,OAAQV,MAAM,GAAGA,MAAM,CAACA,MAAM,EAAG;IAE/B,IAAI7B,EAAE,CAAC6B,MAAM,EAAE,4BAA4B,CAAC,EAAE;MAC5C,OAAO5B,iBAAiB,CAAC4B,MAAM,CAAC;IAClC;IAEA,IAAI7B,EAAE,CAAC6B,MAAM,EAAE,kBAAkB,CAAC,EAAE;MAClC,OAAO5B,iBAAiB,CAAC4B,MAAM,CAAC,CAAC6B,UAAU;IAC7C;EACF;EAEA,OAAO,IAAI;AACb;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,SAASc,WAAWA,CAACjB,CAAC,EAAEC,CAAC,EAAE;EACzB,IAAIiB,YAAY,GAAGF,cAAc,CAAChB,CAAC,CAAC;IAChCmB,YAAY,GAAGH,cAAc,CAACf,CAAC,CAAC;EAEpC,OAAOiB,YAAY,KAAKC,YAAY;AACtC;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,SAASX,kBAAkBA,CAACxB,OAAO,EAAEoC,eAAe,EAAE;EACpD,IAAIC,cAAc,GAAG3E,iBAAiB,CAACsC,OAAO,CAAC;EAE/C,OAAO,CAAC,CAAC3C,IAAI,CAACgF,cAAc,CAACC,gBAAgB,IAAI,EAAE,EAAE,UAASC,UAAU,EAAE;IACxE,OAAO9E,EAAE,CAAC8E,UAAU,EAAEH,eAAe,CAAC;EACxC,CAAC,CAAC;AACJ;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,SAASN,wBAAwBA,CAAC9B,OAAO,EAAEoC,eAAe,EAAE;EAC1D,IAAIC,cAAc,GAAG3E,iBAAiB,CAACsC,OAAO,CAAC;EAE/C,OAAO,CAACqC,cAAc,CAACC,gBAAgB,IAAI,EAAE,EAAElF,KAAK,CAAC,UAASmF,UAAU,EAAE;IACxE,OAAO9E,EAAE,CAAC8E,UAAU,EAAEH,eAAe,CAAC;EACxC,CAAC,CAAC;AACJ;;AAEA;AACA;AACA;AACA;AACA;AACA,SAASI,oBAAoBA,CAACxC,OAAO,EAAE;EACrC,OACEvC,EAAE,CAACuC,OAAO,EAAE,eAAe,CAAC,IAC5B,CAACvC,EAAE,CAACuC,OAAO,EAAE,eAAe,CAAC,IAC7B,CAACjC,iBAAiB,CAACiC,OAAO,CAAC,IAC3B,EAAEvC,EAAE,CAACuC,OAAO,EAAE,6BAA6B,CAAC,IAC1CwB,kBAAkB,CAACxB,OAAO,EAAE,0BAA0B,CAAC,CACxD,IACD,CAACuB,sBAAsB,CAACvB,OAAO,CAAC,IAChC,CAACyB,iBAAiB,CAACzB,OAAO,CAAC;AAE/B;;AAEA;AACA;AACA;AACA;AACA;AACA,SAASyC,oBAAoBA,CAACzC,OAAO,EAAE;EACrC,OACEvC,EAAE,CAACuC,OAAO,EAAE,eAAe,CAAC,IAC5B,CAACvC,EAAE,CAACuC,OAAO,EAAE,iBAAiB,CAAC,IAC/B,CAACvC,EAAE,CAACuC,OAAO,EAAE,oBAAoB,CAAC,IAClC,CAACjC,iBAAiB,CAACiC,OAAO,CAAC,IAC3B,EAAEvC,EAAE,CAACuC,OAAO,EAAE,6BAA6B,CAAC,IAC1CwB,kBAAkB,CAACxB,OAAO,EAAE,0BAA0B,CAAC,CACxD,IACD,CAACyB,iBAAiB,CAACzB,OAAO,CAAC;AAE/B;;AAEA;AACA;AACA;AACA;AACA;AACA,SAAS0C,kBAAkBA,CAAC1C,OAAO,EAAE;EACnC,OACEvC,EAAE,CAACuC,OAAO,EAAE,kBAAkB,CAAC,IAC7BvC,EAAE,CAACuC,OAAO,EAAE,6BAA6B,CAAC,KACxCwB,kBAAkB,CAACxB,OAAO,EAAE,6BAA6B,CAAC,IAC1DwB,kBAAkB,CAACxB,OAAO,EAAE,2BAA2B,CAAC,IACxDwB,kBAAkB,CAACxB,OAAO,EAAE,iCAAiC,CAAC,IAC9DwB,kBAAkB,CAACxB,OAAO,EAAE,4BAA4B,CAAC,CAE5D;AAEL;;AAEA;AACA;AACA;AACA;AACA;AACA,SAAS2C,UAAUA,CAAC3C,OAAO,EAAE;EAE3B,IAAI4C,OAAO,GAAG,EAAE;EAEhB,OAAO5C,OAAO,EAAE;IACdA,OAAO,GAAGA,OAAO,CAACV,MAAM;IAExB,IAAIU,OAAO,EAAE;MACX4C,OAAO,CAACC,IAAI,CAAC7C,OAAO,CAAC;IACvB;EACF;EAEA,OAAO4C,OAAO;AAChB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,SAASE,QAAQA,CAACC,cAAc,EAAE/C,OAAO,EAAE;EACzC,IAAIgD,UAAU,GAAGL,UAAU,CAAC3C,OAAO,CAAC;EAEpC,OAAOgD,UAAU,CAACC,OAAO,CAACF,cAAc,CAAC,KAAK,CAAC,CAAC;AAClD;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASxD,UAAUA,CAACP,MAAM,EAAEE,MAAM,EAAEM,UAAU,EAAE;EAE9C,IAAIsB,kBAAkB,CAAC9B,MAAM,CAAC,IAAI8B,kBAAkB,CAAC5B,MAAM,CAAC,EAAE;IAC5D,OAAO,IAAI;EACb;EAEA,IAAI,CAACzB,EAAE,CAAC+B,UAAU,EAAE,sBAAsB,CAAC,EAAE;IAE3C,IAAIgB,qBAAqB,CAACxB,MAAM,EAAEE,MAAM,CAAC,EAAE;MACzC,OAAO;QAAEO,IAAI,EAAE;MAAmB,CAAC;IACrC;IAEA,IAAIgB,sBAAsB,CAACzB,MAAM,EAAEE,MAAM,CAAC,EAAE;MAC1C,OAAO;QAAEO,IAAI,EAAE;MAAoB,CAAC;IACtC;EACF;EAEA,IAAIyD,sBAAsB,GAAGxC,yBAAyB,CAAC1B,MAAM,EAAEE,MAAM,CAAC;EAEtE,IAAIgE,sBAAsB,EAAE;IAC1B,OAAOA,sBAAsB;EAC/B;EAEA,IAAItC,iCAAiC,CAAC5B,MAAM,EAAEE,MAAM,CAAC,EAAE;IACrD,OAAO;MACLO,IAAI,EAAE,kBAAkB;MACxB0D,oBAAoB,EAAE;IACxB,CAAC;EACH;EAEA,IAAIxC,qBAAqB,CAAC3B,MAAM,EAAEE,MAAM,CAAC,EAAE;IACzC,OAAO;MACLO,IAAI,EAAE,kBAAkB;MACxB0D,oBAAoB,EAAE;IACxB,CAAC;EACH;EAEA,OAAO,KAAK;AACd;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAStC,OAAOA,CAACb,OAAO,EAAEd,MAAM,EAAE;EAEhC;EACA,IAAIrB,OAAO,CAACmC,OAAO,CAAC,IAAIqB,OAAO,CAACrB,OAAO,CAAC,EAAE;IACxC,OAAO,IAAI;EACb;;EAGA;EACA,IAAIvC,EAAE,CAACyB,MAAM,EAAE,kBAAkB,CAAC,IAAI,CAACpB,UAAU,CAACoB,MAAM,CAAC,EAAE;IACzD,OAAO,KAAK;EACd;;EAEA;EACA;EACA,IAAIzB,EAAE,CAACuC,OAAO,EAAE,kBAAkB,CAAC,EAAE;IACnC,OAAOvC,EAAE,CAACyB,MAAM,EAAE,cAAc,CAAC,IAAIzB,EAAE,CAACyB,MAAM,EAAE,oBAAoB,CAAC;EACvE;;EAEA;EACA,IAAItB,KAAK,CAACoC,OAAO,EAAE,CAAE,gBAAgB,EAAE,iBAAiB,CAAE,CAAC,EAAE;IAE3D,IAAIA,OAAO,CAACV,MAAM,EAAE;MAClB,OAAOJ,MAAM,KAAKc,OAAO,CAACV,MAAM;IAClC;EACF;;EAEA;EACA,IAAI7B,EAAE,CAACuC,OAAO,EAAE,WAAW,CAAC,EAAE;IAC5B,OAAOvC,EAAE,CAACyB,MAAM,EAAE,kBAAkB,CAAC,IAAIzB,EAAE,CAACyB,MAAM,EAAE,WAAW,CAAC;EAClE;;EAEA;EACA,IAAIzB,EAAE,CAACuC,OAAO,EAAE,oBAAoB,CAAC,IAAI,CAACoD,wBAAwB,CAACpD,OAAO,CAAC,EAAE;IAC3E,OAAO,KAAK;EACd;;EAEA;EACA;EACA,IAAIvC,EAAE,CAACuC,OAAO,EAAE,kBAAkB,CAAC,IAAI,CAACvC,EAAE,CAACuC,OAAO,EAAE,yBAAyB,CAAC,EAAE;IAC9E,IAAIvC,EAAE,CAACyB,MAAM,EAAE,4BAA4B,CAAC,EAAE;MAC5C,OAAOpB,UAAU,CAACoB,MAAM,CAAC;IAC3B;IAEA,OAAOtB,KAAK,CAACsB,MAAM,EAAE,CAAE,kBAAkB,EAAE,WAAW,CAAE,CAAC;EAC3D;;EAEA;EACA,IAAIzB,EAAE,CAACuC,OAAO,EAAE,yBAAyB,CAAC,IAAIvC,EAAE,CAACyB,MAAM,EAAE,oBAAoB,CAAC,EAAE;IAC9E,OAAO3B,IAAI,CAACG,iBAAiB,CAACwB,MAAM,CAAC,CAACmE,GAAG,CAAC,cAAc,CAAC,EAAE,UAASC,WAAW,EAAE;MAC/E,OAAO,CAAC,CAACA,WAAW,CAACD,GAAG,CAAC,YAAY,CAAC;IACxC,CAAC,CAAC;EACJ;;EAEA;EACA;EACA;EACA;EACA,IAAIzF,KAAK,CAACoC,OAAO,EAAE,CAAE,eAAe,EAAE,sBAAsB,EAAE,yBAAyB,CAAE,CAAC,EAAE;IAC1F,OAAOpC,KAAK,CAACsB,MAAM,EAAE,CACnB,oBAAoB,EACpB,WAAW,EACX,kBAAkB,EAClB,cAAc,EACd,iBAAiB,CAAE,CAAC;EACxB;EAEA,IAAIzB,EAAE,CAACuC,OAAO,EAAE,kBAAkB,CAAC,EAAE;IACnC,OAAOvC,EAAE,CAACyB,MAAM,EAAE,oBAAoB,CAAC,IAClCc,OAAO,CAAChB,MAAM,CAACM,MAAM,IAAIJ,MAAM,IAC/Bc,OAAO,CAACd,MAAM,CAACI,MAAM,IAAIJ,MAAM;EACtC;EAEA,OAAO,KAAK;AACd;;AAEA;AACA;AACA;AACA;AACA;AACA,SAASkE,wBAAwBA,CAACG,KAAK,EAAE;EACvC,OAAO7F,iBAAiB,CAAC6F,KAAK,CAAC,CAACC,cAAc,KAC5CC,oBAAoB,CAACF,KAAK,CAAC,IAAIG,4CAA4C,CAACH,KAAK,CAAC,CACnF;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA,SAASI,eAAeA,CAAC3D,OAAO,EAAE;EAChC,OAAO,CAACnC,OAAO,CAACmC,OAAO,CAAC,IAAIvC,EAAE,CAACuC,OAAO,EAAE,oBAAoB,CAAC;AAC/D;;AAEA;AACA;AACA;AACA;AACA;AACA,SAAS4D,MAAMA,CAAC5D,OAAO,EAAE;EACvB,OAAOvC,EAAE,CAACuC,OAAO,EAAE,WAAW,CAAC;AACjC;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS6D,mBAAmBA,CAAC7D,OAAO,EAAE;EACpC,IAAI2D,eAAe,CAAC3D,OAAO,CAAC,EAAE;IAC5B,OAAO,IAAI;EACb;EAEA,IAAIvC,EAAE,CAACuC,OAAO,EAAE,6BAA6B,CAAC,IAAIyD,oBAAoB,CAACzD,OAAO,CAAC,EAAE;IAC/E,OAAO,IAAI;EACb;EAEA,OACEvC,EAAE,CAACuC,OAAO,EAAE,6BAA6B,CAAC,IAC1C0D,4CAA4C,CAAC1D,OAAO,CAAC;AAEzD;;AAEA;AACA;AACA;AACA;AACA;AACA,SAASyD,oBAAoBA,CAACzD,OAAO,EAAE;EACrC,IAAIqC,cAAc,GAAG3E,iBAAiB,CAACsC,OAAO,CAAC;EAE/C,OAAOqC,cAAc,IAAI,EAAEA,cAAc,CAACC,gBAAgB,IAAID,cAAc,CAACC,gBAAgB,CAACwB,MAAM,CAAC;AACvG;;AAEA;AACA;AACA;AACA;AACA;AACA,SAASJ,4CAA4CA,CAAC1D,OAAO,EAAE;EAC7D,OAAO+D,wBAAwB,CAAC/D,OAAO,EAAE,CACvC,6BAA6B,EAC7B,2BAA2B,EAC3B,4BAA4B,EAC5B,iCAAiC,CAClC,CAAC;AACJ;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS+D,wBAAwBA,CAAC/D,OAAO,EAAEsC,gBAAgB,EAAE;EAC3D,OAAOA,gBAAgB,CAAC/E,IAAI,CAAC,UAASgF,UAAU,EAAE;IAChD,OAAOf,kBAAkB,CAACxB,OAAO,EAAEuC,UAAU,CAAC;EAChD,CAAC,CAAC;AACJ;;AAEA;AACA;AACA;AACA;AACA;AACA,SAASyB,mCAAmCA,CAAChE,OAAO,EAAE;EACpD,OACEvC,EAAE,CAACuC,OAAO,EAAE,kBAAkB,CAAC,IAC/B3C,IAAI,CAAC2C,OAAO,CAACiE,QAAQ,EAAE,UAASA,QAAQ,EAAE;IACxC,OAAOxG,EAAE,CAACwG,QAAQ,CAACjF,MAAM,EAAE,wBAAwB,CAAC;EACtD,CAAC,CAAC;AAEN;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASkB,SAASA,CAACL,QAAQ,EAAEX,MAAM,EAAEF,MAAM,EAAEc,QAAQ,EAAE;EAErD,IAAI,CAACoE,KAAK,CAACC,OAAO,CAACtE,QAAQ,CAAC,EAAE;IAC5BA,QAAQ,GAAG,CAAEA,QAAQ,CAAE;EACzB;;EAEA;EACA,IAAIA,QAAQ,CAACiE,MAAM,KAAK,CAAC,EAAE;IACzB,OAAO,KAAK;EACd;EAEA,IAAI9D,OAAO,GAAGH,QAAQ,CAAC,CAAC,CAAC;;EAEzB;EACA,IAAIhC,OAAO,CAACmC,OAAO,CAAC,EAAE;IACpB,OAAO,KAAK;EACd;;EAEA;EACA,IAAI,CAAC6D,mBAAmB,CAAC7D,OAAO,CAAC,EAAE;IACjC,OAAO,KAAK;EACd;;EAEA;EACA,IAAIjC,iBAAiB,CAACmB,MAAM,CAAC,EAAE;IAC7B,OAAO,KAAK;EACd;;EAEA;EACA,IAAI,CAACzB,EAAE,CAACyB,MAAM,EAAE,eAAe,CAAC,IAAIuC,iBAAiB,CAACvC,MAAM,CAAC,EAAE;IAC7D,OAAO,KAAK;EACd;;EAEA;EACA,IAAIY,QAAQ,IAAI,CAACxB,oBAAoB,CAACwB,QAAQ,EAAEZ,MAAM,CAAC,EAAE;IACvD,OAAO,KAAK;EACd;;EAEA;EACA,IAAI8E,mCAAmC,CAAC9E,MAAM,CAAC,EAAE;IAC/C,OAAO,KAAK;EACd;EAEA,OAAO,QAAQ;AACjB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASmB,UAAUA,CAACR,QAAQ,EAAEX,MAAM,EAAEY,QAAQ,EAAE;EAE9C,IAAI,CAACZ,MAAM,EAAE;IACX,OAAO,KAAK;EACd;EAEA,IAAIkF,UAAU,GAAG;IACfC,YAAY,EAAE;EAChB,CAAC;EAED/G,OAAO,CAACuC,QAAQ,EAAE,UAASG,OAAO,EAAE;IAElC,IAAI,CAACjC,iBAAiB,CAACmB,MAAM,CAAC,EAAE;MAE9B,IAAIzB,EAAE,CAACuC,OAAO,EAAE,iBAAiB,CAAC,IAC9BA,OAAO,CAACP,IAAI,KAAK,OAAO,IACxBoB,OAAO,CAACb,OAAO,EAAEd,MAAM,CAAC,EAAE;QAE5B;QACA;QACA,IAAI,CAAClB,cAAc,CAACgC,OAAO,CAAC,EAAE;UAC5BoE,UAAU,CAACC,YAAY,CAACxB,IAAI,CAAC;YAC3ByB,YAAY,EAAEtE,OAAO,CAACuE,EAAE;YACxBC,cAAc,EAAE;UAClB,CAAC,CAAC;QACJ;;QAEA;QACA;QACA,IAAIvG,uBAAuB,CAAC+B,OAAO,CAAC,IAChC9B,4BAA4B,CAAC8B,OAAO,CAAC,IACrC7B,4BAA4B,CAAC6B,OAAO,CAAC,EAAE;UACzCoE,UAAU,CAACC,YAAY,CAACxB,IAAI,CAAC;YAC3ByB,YAAY,EAAEtE,OAAO,CAACuE,EAAE;YACxBC,cAAc,EAAE;UAClB,CAAC,CAAC;QACJ;;QAEA;QACA;QACA,IAAIT,wBAAwB,CAAC/D,OAAO,EAClC,CACE,6BAA6B,EAC7B,2BAA2B,EAC3B,4BAA4B,EAC5B,iCAAiC,CAClC,CAAC,IACAvC,EAAE,CAACyB,MAAM,EAAE,iBAAiB,CAAC,EAAE;UACjCkF,UAAU,CAACC,YAAY,CAACxB,IAAI,CAAC;YAC3ByB,YAAY,EAAEtE,OAAO,CAACuE,EAAE;YACxBC,cAAc,EAAE;UAClB,CAAC,CAAC;QACJ;MACF;IACF;IAEA,IAAI,CAAC/G,EAAE,CAACyB,MAAM,EAAE,kBAAkB,CAAC,EAAE;MACnC,IAAIsC,kBAAkB,CAACxB,OAAO,EAAE,4BAA4B,CAAC,IACzDA,OAAO,CAACP,IAAI,KAAK,OAAO,EAAE;QAE5B,IAAIhC,EAAE,CAACuC,OAAO,EAAE,eAAe,CAAC,IAAIa,OAAO,CAACb,OAAO,EAAEd,MAAM,CAAC,EAAE;UAC5DkF,UAAU,CAACC,YAAY,CAACxB,IAAI,CAAC;YAC3ByB,YAAY,EAAEtE,OAAO,CAACuE,EAAE;YACxBC,cAAc,EAAE;UAClB,CAAC,CAAC;QACJ;QAEA,IAAI/G,EAAE,CAACuC,OAAO,EAAE,oBAAoB,CAAC,IAAIE,SAAS,CAACF,OAAO,EAAEd,MAAM,EAAE,IAAI,EAAEY,QAAQ,CAAC,EAAE;UACnFsE,UAAU,CAACC,YAAY,CAACxB,IAAI,CAAC;YAC3ByB,YAAY,EAAEtE,OAAO,CAACuE,EAAE;YACxBC,cAAc,EAAE;UAClB,CAAC,CAAC;QACJ;MACF;IACF;EACF,CAAC,CAAC;EAEF,OAAOJ,UAAU,CAACC,YAAY,CAACP,MAAM,GAAGM,UAAU,GAAG,KAAK;AAC5D;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS9D,OAAOA,CAACT,QAAQ,EAAEX,MAAM,EAAE;EAEjC;EACA,IAAI3B,IAAI,CAACsC,QAAQ,EAAE+D,MAAM,CAAC,EAAE;IAC1B,OAAO,KAAK;EACd;;EAEA;EACA,IAAI,CAAC1E,MAAM,EAAE;IACX,OAAO,IAAI;EACb;EAEA,OAAOW,QAAQ,CAACzC,KAAK,CAAC,UAAS4C,OAAO,EAAE;IACtC,OAAOa,OAAO,CAACb,OAAO,EAAEd,MAAM,CAAC;EACjC,CAAC,CAAC;AACJ;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASiB,SAASA,CAACT,KAAK,EAAER,MAAM,EAAEF,MAAM,EAAEc,QAAQ,EAAE;EAElD,IAAI,CAACZ,MAAM,EAAE;IACX,OAAO,KAAK;EACd;EAEA,IAAIrB,OAAO,CAAC6B,KAAK,CAAC,IAAI2B,OAAO,CAAC3B,KAAK,CAAC,EAAE;IACpC,OAAO,IAAI;EACb;EAEA,IAAIqB,MAAM,CAAC/B,MAAM,EAAEE,MAAM,CAAC,EAAE;IAC1B,OAAO,KAAK;EACd;;EAEA;EACA;EACA,IAAIF,MAAM,IAAI8D,QAAQ,CAAC9D,MAAM,EAAEE,MAAM,CAAC,EAAE;IACtC,OAAO,KAAK;EACd;EAEA,OAAO2B,OAAO,CAACnB,KAAK,EAAER,MAAM,EAAEY,QAAQ,CAAC,IAAIC,SAAS,CAACL,KAAK,EAAER,MAAM,EAAEY,QAAQ,CAAC;AAC/E;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,SAASF,SAASA,CAACF,KAAK,EAAEC,SAAS,EAAE;EACnC,IAAIlC,EAAE,CAACiC,KAAK,EAAE,iBAAiB,CAAC,EAAE;IAChC,OACE5B,UAAU,CAAC4B,KAAK,CAAC,KACf,CAACC,SAAS,IAAKA,SAAS,CAAC8E,KAAK,IAAI,GAAG,IAAI9E,SAAS,CAAC+E,MAAM,IAAI,EAAG,CACjE;EAEL;EAEA,IAAIjH,EAAE,CAACiC,KAAK,EAAE,WAAW,CAAC,EAAE;IAC1B,OAAO,IAAI;EACb;EAEA,IAAIjC,EAAE,CAACiC,KAAK,EAAE,kBAAkB,CAAC,EAAE;IACjC,OAAO,IAAI;EACb;EAEA,IAAI0B,gBAAgB,CAAC1B,KAAK,CAAC,EAAE;IAC3B,OAAO,IAAI;EACb;EAEA,IAAI2B,OAAO,CAAC3B,KAAK,CAAC,EAAE;IAClB,OAAO,IAAI;EACb;EAEA,OAAO,KAAK;AACd;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASiF,mBAAmBA,CAAC3F,MAAM,EAAEE,MAAM,EAAE;EAE3C,IAAI0F,oBAAoB,GAAGxD,gBAAgB,CAACpC,MAAM,CAAC;IAC/C6F,oBAAoB,GAAGzD,gBAAgB,CAAClC,MAAM,CAAC;EAEnD,OACE,CAAC0F,oBAAoB,IAAIC,oBAAoB,KAC5CD,oBAAoB,KAAKC,oBAAqB;AAEnD;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,SAASlE,qBAAqBA,CAAC3B,MAAM,EAAEE,MAAM,EAAE;EAE7C;EACA,IAAI4D,QAAQ,CAAC5D,MAAM,EAAEF,MAAM,CAAC,IAAI8D,QAAQ,CAAC9D,MAAM,EAAEE,MAAM,CAAC,EAAE;IACxD,OAAO,KAAK;EACd;;EAEA;EACA,IAAIyF,mBAAmB,CAAC3F,MAAM,EAAEE,MAAM,CAAC,EAAE;IACvC,OAAO,IAAI;EACb;;EAEA;EACA;EACA,OAAO,CAAC,CAACwB,yBAAyB,CAAC1B,MAAM,EAAEE,MAAM,CAAC;AACpD;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS0B,iCAAiCA,CAAC5B,MAAM,EAAEE,MAAM,EAAE;EACzD,OACE+C,WAAW,CAACjD,MAAM,EAAEE,MAAM,CAAC,IAC3BqC,sBAAsB,CAACvC,MAAM,CAAC,IAC9BvB,EAAE,CAACyB,MAAM,EAAE,eAAe,CAAC,IAC3B,CAAC4F,eAAe,CAAC5F,MAAM,EAAEF,MAAM,CAAC,IAChC,CAACjB,iBAAiB,CAACmB,MAAM,CAAC;AAE9B;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,SAASsB,qBAAqBA,CAACxB,MAAM,EAAEE,MAAM,EAAE;EAE7C;EACA;EACA,IAAI6F,cAAc,CAAC/F,MAAM,CAAC,IAAI,CAAC+F,cAAc,CAAC7F,MAAM,CAAC,EAAE;IACrD,OAAO,KAAK;EACd;EAEA,OACE2C,mBAAmB,CAAC7C,MAAM,CAAC,IAC3B+C,mBAAmB,CAAC7C,MAAM,CAAC,IAC3B,CAACwC,kBAAkB,CAAC1C,MAAM,EAAEE,MAAM,CAAC;AAEvC;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,SAASuB,sBAAsBA,CAACzB,MAAM,EAAEE,MAAM,EAAE;EAC9C,OAAOsD,oBAAoB,CAACxD,MAAM,CAAC,IAC5ByD,oBAAoB,CAACvD,MAAM,CAAC,IAC5B+C,WAAW,CAACjD,MAAM,EAAEE,MAAM,CAAC,IAC3B,EAAEzB,EAAE,CAACuB,MAAM,EAAE,wBAAwB,CAAC,IAAI,CAAC0D,kBAAkB,CAACxD,MAAM,CAAC,CAAC;AAC/E;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,SAASwB,yBAAyBA,CAAC1B,MAAM,EAAEE,MAAM,EAAE;EAEjD,IAAItB,KAAK,CAACoB,MAAM,EAAE,CAAE,0BAA0B,EAAE,yBAAyB,CAAE,CAAC,IACxEpB,KAAK,CAACsB,MAAM,EAAE,CAAE,eAAe,EAAE,iBAAiB,CAAE,CAAC,EAAE;IACzD,OAAO;MAAEO,IAAI,EAAE;IAA4B,CAAC;EAC9C;EAEA,IAAI7B,KAAK,CAACsB,MAAM,EAAE,CAAE,0BAA0B,EAAE,yBAAyB,CAAE,CAAC,IACxEtB,KAAK,CAACoB,MAAM,EAAE,CAAE,eAAe,EAAE,iBAAiB,CAAE,CAAC,EAAE;IACzD,OAAO;MAAES,IAAI,EAAE;IAA6B,CAAC;EAC/C;EAEA,OAAO,KAAK;AACd;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASM,SAASA,CAACL,KAAK,EAAEF,UAAU,EAAEM,QAAQ,EAAE;EAC9C,IAAI,CAACN,UAAU,EAAE;IACf,OAAO,KAAK;EACd;EAEA,IAAI0E,KAAK,CAACC,OAAO,CAACzE,KAAK,CAAC,EAAE;IACxB,IAAIA,KAAK,CAACoE,MAAM,KAAK,CAAC,EAAE;MACtB,OAAO,KAAK;IACd;IAEApE,KAAK,GAAGA,KAAK,CAAE,CAAC,CAAE;EACpB;EAEA,IAAIF,UAAU,CAACR,MAAM,KAAKU,KAAK,IAC3BF,UAAU,CAACN,MAAM,KAAKQ,KAAK,EAAE;IAC/B,OAAO,KAAK;EACd;;EAEA;EACA,OACE9B,KAAK,CAAC4B,UAAU,EAAE,CAAE,mBAAmB,EAAE,kBAAkB,CAAE,CAAC,IAC9D,CAAC3B,OAAO,CAAC2B,UAAU,CAAC,IACpB/B,EAAE,CAACiC,KAAK,EAAE,eAAe,CAAC,IAC1B,CAACjC,EAAE,CAACiC,KAAK,EAAE,oBAAoB,CAAC,IAChCmB,OAAO,CAACnB,KAAK,EAAEF,UAAU,CAACF,MAAM,EAAEQ,QAAQ,CAAC;AAC/C;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,SAASkF,QAAQA,CAACnF,QAAQ,EAAEG,OAAO,EAAE;EACnC,OAAQH,QAAQ,IAAIG,OAAO,IAAKH,QAAQ,CAACoD,OAAO,CAACjD,OAAO,CAAC,KAAK,CAAC,CAAC;AAClE;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,SAASO,OAAOA,CAACV,QAAQ,EAAEG,OAAO,EAAE;EAClC,IAAInC,OAAO,CAACmC,OAAO,CAAC,EAAE;IACpB,OAAO,IAAI;EACb;EAEA,IAAIvC,EAAE,CAACuC,OAAO,EAAE,WAAW,CAAC,IAAI,CAACgF,QAAQ,CAACnF,QAAQ,EAAEG,OAAO,CAACV,MAAM,CAAC,EAAE;IACnE,OAAO,KAAK;EACd;EAEA,OAAO,IAAI;AACb;;AAEA;AACA;AACA;AACA;AACA;AACA,SAASyF,cAAcA,CAAC/E,OAAO,EAAE;EAC/B,OAAOrC,SAAS,CAACqC,OAAO,EAAE,cAAc,CAAC,IAAIrC,SAAS,CAACqC,OAAO,EAAE,oBAAoB,CAAC;AACvF;AAEA,SAAS8E,eAAeA,CAACG,aAAa,EAAEjF,OAAO,EAAE;EAC/C,OAAOiF,aAAa,CAACC,SAAS,CAACF,QAAQ,CAAChF,OAAO,CAAC;AAClD","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}