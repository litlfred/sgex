{"ast":null,"code":"import { forEach, sortBy } from 'min-dash';\n\n/**\n * @typedef {import('../Modeling').default} Modeling\n */\n\n/**\n * A handler that distributes elements evenly.\n *\n * @param {Modeling} modeling\n */\nexport default function DistributeElements(modeling) {\n  this._modeling = modeling;\n}\nDistributeElements.$inject = ['modeling'];\nvar OFF_AXIS = {\n  x: 'y',\n  y: 'x'\n};\nDistributeElements.prototype.preExecute = function (context) {\n  var modeling = this._modeling;\n  var groups = context.groups,\n    axis = context.axis,\n    dimension = context.dimension;\n  function updateRange(group, element) {\n    group.range.min = Math.min(element[axis], group.range.min);\n    group.range.max = Math.max(element[axis] + element[dimension], group.range.max);\n  }\n  function center(element) {\n    return element[axis] + element[dimension] / 2;\n  }\n  function lastIdx(arr) {\n    return arr.length - 1;\n  }\n  function rangeDiff(range) {\n    return range.max - range.min;\n  }\n  function centerElement(refCenter, element) {\n    var delta = {\n      y: 0\n    };\n    delta[axis] = refCenter - center(element);\n    if (delta[axis]) {\n      delta[OFF_AXIS[axis]] = 0;\n      modeling.moveElements([element], delta, element.parent);\n    }\n  }\n  var firstGroup = groups[0],\n    lastGroupIdx = lastIdx(groups),\n    lastGroup = groups[lastGroupIdx];\n  var margin,\n    spaceInBetween,\n    groupsSize = 0; // the size of each range\n\n  forEach(groups, function (group, idx) {\n    var sortedElements, refElem, refCenter;\n    if (group.elements.length < 2) {\n      if (idx && idx !== groups.length - 1) {\n        updateRange(group, group.elements[0]);\n        groupsSize += rangeDiff(group.range);\n      }\n      return;\n    }\n    sortedElements = sortBy(group.elements, axis);\n    refElem = sortedElements[0];\n    if (idx === lastGroupIdx) {\n      refElem = sortedElements[lastIdx(sortedElements)];\n    }\n    refCenter = center(refElem);\n\n    // wanna update the ranges after the shapes have been centered\n    group.range = null;\n    forEach(sortedElements, function (element) {\n      centerElement(refCenter, element);\n      if (group.range === null) {\n        group.range = {\n          min: element[axis],\n          max: element[axis] + element[dimension]\n        };\n        return;\n      }\n\n      // update group's range after centering the range elements\n      updateRange(group, element);\n    });\n    if (idx && idx !== groups.length - 1) {\n      groupsSize += rangeDiff(group.range);\n    }\n  });\n  spaceInBetween = Math.abs(lastGroup.range.min - firstGroup.range.max);\n  margin = Math.round((spaceInBetween - groupsSize) / (groups.length - 1));\n  if (margin < groups.length - 1) {\n    return;\n  }\n  forEach(groups, function (group, groupIdx) {\n    var delta = {},\n      prevGroup;\n    if (group === firstGroup || group === lastGroup) {\n      return;\n    }\n    prevGroup = groups[groupIdx - 1];\n    group.range.max = 0;\n    forEach(group.elements, function (element, idx) {\n      delta[OFF_AXIS[axis]] = 0;\n      delta[axis] = prevGroup.range.max - element[axis] + margin;\n      if (group.range.min !== element[axis]) {\n        delta[axis] += element[axis] - group.range.min;\n      }\n      if (delta[axis]) {\n        modeling.moveElements([element], delta, element.parent);\n      }\n      group.range.max = Math.max(element[axis] + element[dimension], idx ? group.range.max : 0);\n    });\n  });\n};\nDistributeElements.prototype.postExecute = function (context) {};","map":{"version":3,"names":["forEach","sortBy","DistributeElements","modeling","_modeling","$inject","OFF_AXIS","x","y","prototype","preExecute","context","groups","axis","dimension","updateRange","group","element","range","min","Math","max","center","lastIdx","arr","length","rangeDiff","centerElement","refCenter","delta","moveElements","parent","firstGroup","lastGroupIdx","lastGroup","margin","spaceInBetween","groupsSize","idx","sortedElements","refElem","elements","abs","round","groupIdx","prevGroup","postExecute"],"sources":["/home/runner/work/sgex/sgex/node_modules/diagram-js/lib/features/modeling/cmd/DistributeElementsHandler.js"],"sourcesContent":["import {\n  forEach,\n  sortBy\n} from 'min-dash';\n\n/**\n * @typedef {import('../Modeling').default} Modeling\n */\n\n/**\n * A handler that distributes elements evenly.\n *\n * @param {Modeling} modeling\n */\nexport default function DistributeElements(modeling) {\n  this._modeling = modeling;\n}\n\nDistributeElements.$inject = [ 'modeling' ];\n\nvar OFF_AXIS = {\n  x: 'y',\n  y: 'x'\n};\n\nDistributeElements.prototype.preExecute = function(context) {\n  var modeling = this._modeling;\n\n  var groups = context.groups,\n      axis = context.axis,\n      dimension = context.dimension;\n\n  function updateRange(group, element) {\n    group.range.min = Math.min(element[axis], group.range.min);\n    group.range.max = Math.max(element[axis] + element[dimension], group.range.max);\n  }\n\n  function center(element) {\n    return element[axis] + element[dimension] / 2;\n  }\n\n  function lastIdx(arr) {\n    return arr.length - 1;\n  }\n\n  function rangeDiff(range) {\n    return range.max - range.min;\n  }\n\n  function centerElement(refCenter, element) {\n    var delta = { y: 0 };\n\n    delta[axis] = refCenter - center(element);\n\n    if (delta[axis]) {\n\n      delta[OFF_AXIS[axis]] = 0;\n\n      modeling.moveElements([ element ], delta, element.parent);\n    }\n  }\n\n  var firstGroup = groups[0],\n      lastGroupIdx = lastIdx(groups),\n      lastGroup = groups[ lastGroupIdx ];\n\n  var margin,\n      spaceInBetween,\n      groupsSize = 0; // the size of each range\n\n  forEach(groups, function(group, idx) {\n    var sortedElements,\n        refElem,\n        refCenter;\n\n    if (group.elements.length < 2) {\n      if (idx && idx !== groups.length - 1) {\n        updateRange(group, group.elements[0]);\n\n        groupsSize += rangeDiff(group.range);\n      }\n      return;\n    }\n\n    sortedElements = sortBy(group.elements, axis);\n\n    refElem = sortedElements[0];\n\n    if (idx === lastGroupIdx) {\n      refElem = sortedElements[lastIdx(sortedElements)];\n    }\n\n    refCenter = center(refElem);\n\n    // wanna update the ranges after the shapes have been centered\n    group.range = null;\n\n    forEach(sortedElements, function(element) {\n\n      centerElement(refCenter, element);\n\n      if (group.range === null) {\n        group.range = {\n          min: element[axis],\n          max: element[axis] + element[dimension]\n        };\n\n        return;\n      }\n\n      // update group's range after centering the range elements\n      updateRange(group, element);\n    });\n\n    if (idx && idx !== groups.length - 1) {\n      groupsSize += rangeDiff(group.range);\n    }\n  });\n\n  spaceInBetween = Math.abs(lastGroup.range.min - firstGroup.range.max);\n\n  margin = Math.round((spaceInBetween - groupsSize) / (groups.length - 1));\n\n  if (margin < groups.length - 1) {\n    return;\n  }\n\n  forEach(groups, function(group, groupIdx) {\n    var delta = {},\n        prevGroup;\n\n    if (group === firstGroup || group === lastGroup) {\n      return;\n    }\n\n    prevGroup = groups[groupIdx - 1];\n\n    group.range.max = 0;\n\n    forEach(group.elements, function(element, idx) {\n      delta[OFF_AXIS[axis]] = 0;\n      delta[axis] = (prevGroup.range.max - element[axis]) + margin;\n\n      if (group.range.min !== element[axis]) {\n        delta[axis] += element[axis] - group.range.min;\n      }\n\n      if (delta[axis]) {\n        modeling.moveElements([ element ], delta, element.parent);\n      }\n\n      group.range.max = Math.max(element[axis] + element[dimension], idx ? group.range.max : 0);\n    });\n  });\n};\n\nDistributeElements.prototype.postExecute = function(context) {\n\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}