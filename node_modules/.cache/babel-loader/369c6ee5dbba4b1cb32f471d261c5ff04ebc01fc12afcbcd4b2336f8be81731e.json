{"ast":null,"code":"import { filter, forEach, isArray, sortBy } from 'min-dash';\n\n/**\n * @typedef {import('../../model/Types').Element} Element\n *\n * @typedef {import('../modeling/Modeling').default} Modeling\n * @typedef {import('../rules/Rules').default} Rules\n *\n * @typedef {import('../../util/Types').Axis} Axis\n * @typedef {import('../../util/Types').Dimension} Dimension\n *\n * @typedef { 'top' | 'right' | 'bottom' | 'left' | 'center' | 'middle' } Alignment\n */\n\nfunction last(arr) {\n  return arr && arr[arr.length - 1];\n}\nfunction sortTopOrMiddle(element) {\n  return element.y;\n}\nfunction sortLeftOrCenter(element) {\n  return element.x;\n}\n\n/**\n * Sorting functions for different alignments.\n *\n * @type {Record<string, Function>}\n */\nvar ALIGNMENT_SORTING = {\n  left: sortLeftOrCenter,\n  center: sortLeftOrCenter,\n  right: function (element) {\n    return element.x + element.width;\n  },\n  top: sortTopOrMiddle,\n  middle: sortTopOrMiddle,\n  bottom: function (element) {\n    return element.y + element.height;\n  }\n};\n\n/**\n * @param {Modeling} modeling\n * @param {Rules} rules\n */\nexport default function AlignElements(modeling, rules) {\n  this._modeling = modeling;\n  this._rules = rules;\n}\nAlignElements.$inject = ['modeling', 'rules'];\n\n/**\n * Get relevant axis and dimension for given alignment.\n *\n * @param {Alignment} type\n *\n * @return { {\n *   axis: Axis;\n *   dimension: Dimension;\n * } }\n */\nAlignElements.prototype._getOrientationDetails = function (type) {\n  var vertical = ['top', 'bottom', 'middle'],\n    axis = 'x',\n    dimension = 'width';\n  if (vertical.indexOf(type) !== -1) {\n    axis = 'y';\n    dimension = 'height';\n  }\n  return {\n    axis: axis,\n    dimension: dimension\n  };\n};\nAlignElements.prototype._isType = function (type, types) {\n  return types.indexOf(type) !== -1;\n};\n\n/**\n * Get point on relevant axis for given alignment.\n *\n * @param {Alignment} type\n * @param {Element[]} sortedElements\n *\n * @return {Partial<Record<Alignment, number>>}\n */\nAlignElements.prototype._alignmentPosition = function (type, sortedElements) {\n  var orientation = this._getOrientationDetails(type),\n    axis = orientation.axis,\n    dimension = orientation.dimension,\n    alignment = {},\n    centers = {},\n    hasSharedCenters = false,\n    centeredElements,\n    firstElement,\n    lastElement;\n  function getMiddleOrTop(first, last) {\n    return Math.round((first[axis] + last[axis] + last[dimension]) / 2);\n  }\n  if (this._isType(type, ['left', 'top'])) {\n    alignment[type] = sortedElements[0][axis];\n  } else if (this._isType(type, ['right', 'bottom'])) {\n    lastElement = last(sortedElements);\n    alignment[type] = lastElement[axis] + lastElement[dimension];\n  } else if (this._isType(type, ['center', 'middle'])) {\n    // check if there is a center shared by more than one shape\n    // if not, just take the middle of the range\n    forEach(sortedElements, function (element) {\n      var center = element[axis] + Math.round(element[dimension] / 2);\n      if (centers[center]) {\n        centers[center].elements.push(element);\n      } else {\n        centers[center] = {\n          elements: [element],\n          center: center\n        };\n      }\n    });\n    centeredElements = sortBy(centers, function (center) {\n      if (center.elements.length > 1) {\n        hasSharedCenters = true;\n      }\n      return center.elements.length;\n    });\n    if (hasSharedCenters) {\n      alignment[type] = last(centeredElements).center;\n      return alignment;\n    }\n    firstElement = sortedElements[0];\n    sortedElements = sortBy(sortedElements, function (element) {\n      return element[axis] + element[dimension];\n    });\n    lastElement = last(sortedElements);\n    alignment[type] = getMiddleOrTop(firstElement, lastElement);\n  }\n  return alignment;\n};\n\n/**\n * Align elements on relevant axis for given alignment.\n *\n * @param {Element[]} elements\n * @param {Alignment} type\n */\nAlignElements.prototype.trigger = function (elements, type) {\n  var modeling = this._modeling,\n    allowed;\n\n  // filter out elements which cannot be aligned\n  var filteredElements = filter(elements, function (element) {\n    return !(element.waypoints || element.host || element.labelTarget);\n  });\n\n  // filter out elements via rules\n  allowed = this._rules.allowed('elements.align', {\n    elements: filteredElements\n  });\n  if (isArray(allowed)) {\n    filteredElements = allowed;\n  }\n  if (filteredElements.length < 2 || !allowed) {\n    return;\n  }\n  var sortFn = ALIGNMENT_SORTING[type];\n  var sortedElements = sortBy(filteredElements, sortFn);\n  var alignment = this._alignmentPosition(type, sortedElements);\n  modeling.alignElements(sortedElements, alignment);\n};","map":{"version":3,"names":["filter","forEach","isArray","sortBy","last","arr","length","sortTopOrMiddle","element","y","sortLeftOrCenter","x","ALIGNMENT_SORTING","left","center","right","width","top","middle","bottom","height","AlignElements","modeling","rules","_modeling","_rules","$inject","prototype","_getOrientationDetails","type","vertical","axis","dimension","indexOf","_isType","types","_alignmentPosition","sortedElements","orientation","alignment","centers","hasSharedCenters","centeredElements","firstElement","lastElement","getMiddleOrTop","first","Math","round","elements","push","trigger","allowed","filteredElements","waypoints","host","labelTarget","sortFn","alignElements"],"sources":["/home/runner/work/sgex/sgex/node_modules/diagram-js/lib/features/align-elements/AlignElements.js"],"sourcesContent":["import {\n  filter,\n  forEach,\n  isArray,\n  sortBy\n} from 'min-dash';\n\n/**\n * @typedef {import('../../model/Types').Element} Element\n *\n * @typedef {import('../modeling/Modeling').default} Modeling\n * @typedef {import('../rules/Rules').default} Rules\n *\n * @typedef {import('../../util/Types').Axis} Axis\n * @typedef {import('../../util/Types').Dimension} Dimension\n *\n * @typedef { 'top' | 'right' | 'bottom' | 'left' | 'center' | 'middle' } Alignment\n */\n\nfunction last(arr) {\n  return arr && arr[arr.length - 1];\n}\n\nfunction sortTopOrMiddle(element) {\n  return element.y;\n}\n\nfunction sortLeftOrCenter(element) {\n  return element.x;\n}\n\n/**\n * Sorting functions for different alignments.\n *\n * @type {Record<string, Function>}\n */\nvar ALIGNMENT_SORTING = {\n  left: sortLeftOrCenter,\n  center: sortLeftOrCenter,\n  right: function(element) {\n    return element.x + element.width;\n  },\n  top: sortTopOrMiddle,\n  middle: sortTopOrMiddle,\n  bottom: function(element) {\n    return element.y + element.height;\n  }\n};\n\n/**\n * @param {Modeling} modeling\n * @param {Rules} rules\n */\nexport default function AlignElements(modeling, rules) {\n  this._modeling = modeling;\n  this._rules = rules;\n}\n\nAlignElements.$inject = [ 'modeling', 'rules' ];\n\n\n/**\n * Get relevant axis and dimension for given alignment.\n *\n * @param {Alignment} type\n *\n * @return { {\n *   axis: Axis;\n *   dimension: Dimension;\n * } }\n */\nAlignElements.prototype._getOrientationDetails = function(type) {\n  var vertical = [ 'top', 'bottom', 'middle' ],\n      axis = 'x',\n      dimension = 'width';\n\n  if (vertical.indexOf(type) !== -1) {\n    axis = 'y';\n    dimension = 'height';\n  }\n\n  return {\n    axis: axis,\n    dimension: dimension\n  };\n};\n\nAlignElements.prototype._isType = function(type, types) {\n  return types.indexOf(type) !== -1;\n};\n\n/**\n * Get point on relevant axis for given alignment.\n *\n * @param {Alignment} type\n * @param {Element[]} sortedElements\n *\n * @return {Partial<Record<Alignment, number>>}\n */\nAlignElements.prototype._alignmentPosition = function(type, sortedElements) {\n  var orientation = this._getOrientationDetails(type),\n      axis = orientation.axis,\n      dimension = orientation.dimension,\n      alignment = {},\n      centers = {},\n      hasSharedCenters = false,\n      centeredElements,\n      firstElement,\n      lastElement;\n\n  function getMiddleOrTop(first, last) {\n    return Math.round((first[axis] + last[axis] + last[dimension]) / 2);\n  }\n\n  if (this._isType(type, [ 'left', 'top' ])) {\n    alignment[type] = sortedElements[0][axis];\n\n  } else if (this._isType(type, [ 'right', 'bottom' ])) {\n    lastElement = last(sortedElements);\n\n    alignment[type] = lastElement[axis] + lastElement[dimension];\n\n  } else if (this._isType(type, [ 'center', 'middle' ])) {\n\n    // check if there is a center shared by more than one shape\n    // if not, just take the middle of the range\n    forEach(sortedElements, function(element) {\n      var center = element[axis] + Math.round(element[dimension] / 2);\n\n      if (centers[center]) {\n        centers[center].elements.push(element);\n      } else {\n        centers[center] = {\n          elements: [ element ],\n          center: center\n        };\n      }\n    });\n\n    centeredElements = sortBy(centers, function(center) {\n      if (center.elements.length > 1) {\n        hasSharedCenters = true;\n      }\n\n      return center.elements.length;\n    });\n\n    if (hasSharedCenters) {\n      alignment[type] = last(centeredElements).center;\n\n      return alignment;\n    }\n\n    firstElement = sortedElements[0];\n\n    sortedElements = sortBy(sortedElements, function(element) {\n      return element[axis] + element[dimension];\n    });\n\n    lastElement = last(sortedElements);\n\n    alignment[type] = getMiddleOrTop(firstElement, lastElement);\n  }\n\n  return alignment;\n};\n\n/**\n * Align elements on relevant axis for given alignment.\n *\n * @param {Element[]} elements\n * @param {Alignment} type\n */\nAlignElements.prototype.trigger = function(elements, type) {\n  var modeling = this._modeling,\n      allowed;\n\n  // filter out elements which cannot be aligned\n  var filteredElements = filter(elements, function(element) {\n    return !(element.waypoints || element.host || element.labelTarget);\n  });\n\n  // filter out elements via rules\n  allowed = this._rules.allowed('elements.align', { elements: filteredElements });\n  if (isArray(allowed)) {\n    filteredElements = allowed;\n  }\n\n  if (filteredElements.length < 2 || !allowed) {\n    return;\n  }\n\n  var sortFn = ALIGNMENT_SORTING[type];\n\n  var sortedElements = sortBy(filteredElements, sortFn);\n\n  var alignment = this._alignmentPosition(type, sortedElements);\n\n  modeling.alignElements(sortedElements, alignment);\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}