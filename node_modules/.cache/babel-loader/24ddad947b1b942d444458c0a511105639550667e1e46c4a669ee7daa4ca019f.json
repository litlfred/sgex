{"ast":null,"code":"import { sortBy, forEach, isArray } from 'min-dash';\n\n/**\n * @typedef {import('../../model/Types').Element} Element\n *\n * @typedef {import('../../util/Types').Axis} Axis\n * @typedef {import('../../util/Types').Dimension} Dimension\n * @typedef {import('../../util/Types').Rect} Rect\n *\n * @typedef {import('../modeling/Modeling').default} Modeling\n * @typedef {import('../rules/Rules').default} Rules\n *\n * @typedef { {\n *   min: number;\n *   max: number;\n * } } Range\n *\n * @typedef { {\n *   elements: Element[];\n *   range: Range;\n * } } Group\n */\n\nvar AXIS_DIMENSIONS = {\n  horizontal: ['x', 'width'],\n  vertical: ['y', 'height']\n};\nvar THRESHOLD = 5;\n\n/**\n * Groups and filters elements and then trigger even distribution.\n *\n * @param {Modeling} modeling\n * @param {Rules} rules\n */\nexport default function DistributeElements(modeling, rules) {\n  this._modeling = modeling;\n  this._filters = [];\n  this.registerFilter(function (elements) {\n    var allowed = rules.allowed('elements.distribute', {\n      elements: elements\n    });\n    if (isArray(allowed)) {\n      return allowed;\n    }\n    return allowed ? elements : [];\n  });\n}\nDistributeElements.$inject = ['modeling', 'rules'];\n\n/**\n * Registers filter functions that allow external parties to filter\n * out certain elements.\n *\n * @param {(distributableElements: Element[], axis: Axis, dimension: Dimension) => Element[]} filterFn\n */\nDistributeElements.prototype.registerFilter = function (filterFn) {\n  if (typeof filterFn !== 'function') {\n    throw new Error('the filter has to be a function');\n  }\n  this._filters.push(filterFn);\n};\n\n/**\n * Distributes the elements with a given orientation\n *\n * @param {Element[]} elements\n * @param {string} orientation\n */\nDistributeElements.prototype.trigger = function (elements, orientation) {\n  var modeling = this._modeling;\n  var groups, distributableElements;\n  if (elements.length < 3) {\n    return;\n  }\n  this._setOrientation(orientation);\n  distributableElements = this._filterElements(elements);\n  groups = this._createGroups(distributableElements);\n\n  // nothing to distribute\n  if (groups.length <= 2) {\n    return;\n  }\n  modeling.distributeElements(groups, this._axis, this._dimension);\n  return groups;\n};\n\n/**\n * Filters the elements with provided filters by external parties\n *\n * @param {Element[]} elements\n *\n * @return {Element[]}\n */\nDistributeElements.prototype._filterElements = function (elements) {\n  var filters = this._filters,\n    axis = this._axis,\n    dimension = this._dimension,\n    distributableElements = [].concat(elements);\n  if (!filters.length) {\n    return elements;\n  }\n  forEach(filters, function (filterFn) {\n    distributableElements = filterFn(distributableElements, axis, dimension);\n  });\n  return distributableElements;\n};\n\n/**\n * Create range (min, max) groups. Also tries to group elements\n * together that share the same range.\n *\n * @example\n *\n * ```javascript\n *   const groups = [\n *     {\n *       range: { min: 100, max: 200 },\n *       elements: [ { id: 'shape1', ... } ]\n *     }\n *   ]\n * ```\n *\n * @param {Element[]} elements\n *\n * @return {Group[]}\n */\nDistributeElements.prototype._createGroups = function (elements) {\n  var rangeGroups = [],\n    self = this,\n    axis = this._axis,\n    dimension = this._dimension;\n  if (!axis) {\n    throw new Error('must have a defined \"axis\" and \"dimension\"');\n  }\n\n  // sort by 'left->right' or 'top->bottom'\n  var sortedElements = sortBy(elements, axis);\n  forEach(sortedElements, function (element, idx) {\n    var elementRange = self._findRange(element, axis, dimension),\n      range;\n    var previous = rangeGroups[rangeGroups.length - 1];\n    if (previous && self._hasIntersection(previous.range, elementRange)) {\n      rangeGroups[rangeGroups.length - 1].elements.push(element);\n    } else {\n      range = {\n        range: elementRange,\n        elements: [element]\n      };\n      rangeGroups.push(range);\n    }\n  });\n  return rangeGroups;\n};\n\n/**\n * Maps a direction to the according axis and dimension.\n *\n * @param {'horizontal' | 'vertical'} direction 'horizontal' or 'vertical'\n */\nDistributeElements.prototype._setOrientation = function (direction) {\n  var orientation = AXIS_DIMENSIONS[direction];\n  this._axis = orientation[0];\n  this._dimension = orientation[1];\n};\n\n/**\n * Checks if the two ranges intercept each other.\n *\n * @param {Range} rangeA\n * @param {Range} rangeB\n *\n * @return {boolean}\n */\nDistributeElements.prototype._hasIntersection = function (rangeA, rangeB) {\n  return Math.max(rangeA.min, rangeA.max) >= Math.min(rangeB.min, rangeB.max) && Math.min(rangeA.min, rangeA.max) <= Math.max(rangeB.min, rangeB.max);\n};\n\n/**\n * Returns the min and max values for an element\n *\n * @param {Element} element\n *\n * @return {Range}\n */\nDistributeElements.prototype._findRange = function (element) {\n  var axis = element[this._axis],\n    dimension = element[this._dimension];\n  return {\n    min: axis + THRESHOLD,\n    max: axis + dimension - THRESHOLD\n  };\n};","map":{"version":3,"names":["sortBy","forEach","isArray","AXIS_DIMENSIONS","horizontal","vertical","THRESHOLD","DistributeElements","modeling","rules","_modeling","_filters","registerFilter","elements","allowed","$inject","prototype","filterFn","Error","push","trigger","orientation","groups","distributableElements","length","_setOrientation","_filterElements","_createGroups","distributeElements","_axis","_dimension","filters","axis","dimension","concat","rangeGroups","self","sortedElements","element","idx","elementRange","_findRange","range","previous","_hasIntersection","direction","rangeA","rangeB","Math","max","min"],"sources":["/home/runner/work/sgex/sgex/node_modules/diagram-js/lib/features/distribute-elements/DistributeElements.js"],"sourcesContent":["import {\n  sortBy,\n  forEach,\n  isArray\n} from 'min-dash';\n\n/**\n * @typedef {import('../../model/Types').Element} Element\n *\n * @typedef {import('../../util/Types').Axis} Axis\n * @typedef {import('../../util/Types').Dimension} Dimension\n * @typedef {import('../../util/Types').Rect} Rect\n *\n * @typedef {import('../modeling/Modeling').default} Modeling\n * @typedef {import('../rules/Rules').default} Rules\n *\n * @typedef { {\n *   min: number;\n *   max: number;\n * } } Range\n *\n * @typedef { {\n *   elements: Element[];\n *   range: Range;\n * } } Group\n */\n\nvar AXIS_DIMENSIONS = {\n  horizontal: [ 'x', 'width' ],\n  vertical: [ 'y', 'height' ]\n};\n\nvar THRESHOLD = 5;\n\n\n/**\n * Groups and filters elements and then trigger even distribution.\n *\n * @param {Modeling} modeling\n * @param {Rules} rules\n */\nexport default function DistributeElements(modeling, rules) {\n  this._modeling = modeling;\n\n  this._filters = [];\n\n  this.registerFilter(function(elements) {\n    var allowed = rules.allowed('elements.distribute', { elements: elements });\n\n    if (isArray(allowed)) {\n      return allowed;\n    }\n\n    return allowed ? elements : [];\n  });\n}\n\nDistributeElements.$inject = [ 'modeling', 'rules' ];\n\n\n/**\n * Registers filter functions that allow external parties to filter\n * out certain elements.\n *\n * @param {(distributableElements: Element[], axis: Axis, dimension: Dimension) => Element[]} filterFn\n */\nDistributeElements.prototype.registerFilter = function(filterFn) {\n  if (typeof filterFn !== 'function') {\n    throw new Error('the filter has to be a function');\n  }\n\n  this._filters.push(filterFn);\n};\n\n/**\n * Distributes the elements with a given orientation\n *\n * @param {Element[]} elements\n * @param {string} orientation\n */\nDistributeElements.prototype.trigger = function(elements, orientation) {\n  var modeling = this._modeling;\n\n  var groups,\n      distributableElements;\n\n  if (elements.length < 3) {\n    return;\n  }\n\n  this._setOrientation(orientation);\n\n  distributableElements = this._filterElements(elements);\n\n  groups = this._createGroups(distributableElements);\n\n  // nothing to distribute\n  if (groups.length <= 2) {\n    return;\n  }\n\n  modeling.distributeElements(groups, this._axis, this._dimension);\n\n  return groups;\n};\n\n/**\n * Filters the elements with provided filters by external parties\n *\n * @param {Element[]} elements\n *\n * @return {Element[]}\n */\nDistributeElements.prototype._filterElements = function(elements) {\n  var filters = this._filters,\n      axis = this._axis,\n      dimension = this._dimension,\n      distributableElements = [].concat(elements);\n\n  if (!filters.length) {\n    return elements;\n  }\n\n  forEach(filters, function(filterFn) {\n    distributableElements = filterFn(distributableElements, axis, dimension);\n  });\n\n  return distributableElements;\n};\n\n\n/**\n * Create range (min, max) groups. Also tries to group elements\n * together that share the same range.\n *\n * @example\n *\n * ```javascript\n *   const groups = [\n *     {\n *       range: { min: 100, max: 200 },\n *       elements: [ { id: 'shape1', ... } ]\n *     }\n *   ]\n * ```\n *\n * @param {Element[]} elements\n *\n * @return {Group[]}\n */\nDistributeElements.prototype._createGroups = function(elements) {\n  var rangeGroups = [],\n      self = this,\n      axis = this._axis,\n      dimension = this._dimension;\n\n  if (!axis) {\n    throw new Error('must have a defined \"axis\" and \"dimension\"');\n  }\n\n  // sort by 'left->right' or 'top->bottom'\n  var sortedElements = sortBy(elements, axis);\n\n  forEach(sortedElements, function(element, idx) {\n    var elementRange = self._findRange(element, axis, dimension),\n        range;\n\n    var previous = rangeGroups[rangeGroups.length - 1];\n\n    if (previous && self._hasIntersection(previous.range, elementRange)) {\n      rangeGroups[rangeGroups.length - 1].elements.push(element);\n    } else {\n      range = { range: elementRange, elements: [ element ] };\n\n      rangeGroups.push(range);\n    }\n  });\n\n  return rangeGroups;\n};\n\n\n/**\n * Maps a direction to the according axis and dimension.\n *\n * @param {'horizontal' | 'vertical'} direction 'horizontal' or 'vertical'\n */\nDistributeElements.prototype._setOrientation = function(direction) {\n  var orientation = AXIS_DIMENSIONS[direction];\n\n  this._axis = orientation[0];\n  this._dimension = orientation[1];\n};\n\n\n/**\n * Checks if the two ranges intercept each other.\n *\n * @param {Range} rangeA\n * @param {Range} rangeB\n *\n * @return {boolean}\n */\nDistributeElements.prototype._hasIntersection = function(rangeA, rangeB) {\n  return Math.max(rangeA.min, rangeA.max) >= Math.min(rangeB.min, rangeB.max) &&\n         Math.min(rangeA.min, rangeA.max) <= Math.max(rangeB.min, rangeB.max);\n};\n\n\n/**\n * Returns the min and max values for an element\n *\n * @param {Element} element\n *\n * @return {Range}\n */\nDistributeElements.prototype._findRange = function(element) {\n  var axis = element[this._axis],\n      dimension = element[this._dimension];\n\n  return {\n    min: axis + THRESHOLD,\n    max: axis + dimension - THRESHOLD\n  };\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}