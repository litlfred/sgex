{"ast":null,"code":"import { setSnapped, isSnapped } from '../snapping/SnapUtil';\nimport { isCmd } from '../keyboard/KeyboardUtil';\nimport { assign, isNumber } from 'min-dash';\nimport { SPACING, quantize } from './GridUtil';\n\n/**\r\n * @typedef {import('../../core/ElementRegistry').default} ElementRegistry\r\n * @typedef {import('../../core/EventBus').default} EventBus\r\n */\n\nvar LOWER_PRIORITY = 1200;\nvar LOW_PRIORITY = 800;\n\n/**\r\n * Basic grid snapping that covers connecting, creating, moving, resizing shapes, moving bendpoints\r\n * and connection segments.\r\n *\r\n * @param {ElementRegistry} elementRegistry\r\n * @param {EventBus} eventBus\r\n * @param {Object} config\r\n */\nexport default function GridSnapping(elementRegistry, eventBus, config) {\n  var active = !config || config.active !== false;\n  this._eventBus = eventBus;\n  var self = this;\n  eventBus.on('diagram.init', LOW_PRIORITY, function () {\n    self.setActive(active);\n  });\n  eventBus.on(['create.move', 'create.end', 'bendpoint.move.move', 'bendpoint.move.end', 'connect.move', 'connect.end', 'connectionSegment.move.move', 'connectionSegment.move.end', 'resize.move', 'resize.end', 'shape.move.move', 'shape.move.end'], LOWER_PRIORITY, function (event) {\n    var originalEvent = event.originalEvent;\n    if (!self.active || originalEvent && isCmd(originalEvent)) {\n      return;\n    }\n    var context = event.context,\n      gridSnappingContext = context.gridSnappingContext;\n    if (!gridSnappingContext) {\n      gridSnappingContext = context.gridSnappingContext = {};\n    }\n    ['x', 'y'].forEach(function (axis) {\n      var options = {};\n\n      // allow snapping with offset\n      var snapOffset = getSnapOffset(event, axis, elementRegistry);\n      if (snapOffset) {\n        options.offset = snapOffset;\n      }\n\n      // allow snapping with min and max\n      var snapConstraints = getSnapConstraints(event, axis);\n      if (snapConstraints) {\n        assign(options, snapConstraints);\n      }\n      if (!isSnapped(event, axis)) {\n        self.snapEvent(event, axis, options);\n      }\n    });\n  });\n}\n\n/**\r\n * Snap an events x or y with optional min, max and offset.\r\n *\r\n * @param {Object} event\r\n * @param {string} axis\r\n * @param {number} [options.min]\r\n * @param {number} [options.max]\r\n * @param {number} [options.offset]\r\n */\nGridSnapping.prototype.snapEvent = function (event, axis, options) {\n  var snappedValue = this.snapValue(event[axis], options);\n  setSnapped(event, axis, snappedValue);\n};\n\n/**\r\n * Expose grid spacing for third parties (i.e. extensions).\r\n *\r\n * @return {number} spacing of grid dots\r\n */\nGridSnapping.prototype.getGridSpacing = function () {\n  return SPACING;\n};\n\n/**\r\n * Snap value with optional min, max and offset.\r\n *\r\n * @param {number} value\r\n * @param {Object} options\r\n * @param {number} [options.min]\r\n * @param {number} [options.max]\r\n * @param {number} [options.offset]\r\n */\nGridSnapping.prototype.snapValue = function (value, options) {\n  var offset = 0;\n  if (options && options.offset) {\n    offset = options.offset;\n  }\n  value += offset;\n  value = quantize(value, SPACING);\n  var min, max;\n  if (options && options.min) {\n    min = options.min;\n    if (isNumber(min)) {\n      min = quantize(min + offset, SPACING, 'ceil');\n      value = Math.max(value, min);\n    }\n  }\n  if (options && options.max) {\n    max = options.max;\n    if (isNumber(max)) {\n      max = quantize(max + offset, SPACING, 'floor');\n      value = Math.min(value, max);\n    }\n  }\n  value -= offset;\n  return value;\n};\nGridSnapping.prototype.isActive = function () {\n  return this.active;\n};\nGridSnapping.prototype.setActive = function (active) {\n  this.active = active;\n  this._eventBus.fire('gridSnapping.toggle', {\n    active: active\n  });\n};\nGridSnapping.prototype.toggleActive = function () {\n  this.setActive(!this.active);\n};\nGridSnapping.$inject = ['elementRegistry', 'eventBus', 'config.gridSnapping'];\n\n// helpers //////////\n\n/**\r\n * Get minimum and maximum snap constraints.\r\n * Constraints are cached.\r\n *\r\n * @param {Object} event\r\n * @param {Object} event.context\r\n * @param {string} axis\r\n *\r\n * @return {boolean|Object}\r\n */\nfunction getSnapConstraints(event, axis) {\n  var context = event.context,\n    createConstraints = context.createConstraints,\n    resizeConstraints = context.resizeConstraints || {},\n    gridSnappingContext = context.gridSnappingContext,\n    snapConstraints = gridSnappingContext.snapConstraints;\n\n  // cache snap constraints\n  if (snapConstraints && snapConstraints[axis]) {\n    return snapConstraints[axis];\n  }\n  if (!snapConstraints) {\n    snapConstraints = gridSnappingContext.snapConstraints = {};\n  }\n  if (!snapConstraints[axis]) {\n    snapConstraints[axis] = {};\n  }\n  var direction = context.direction;\n\n  // create\n  if (createConstraints) {\n    if (isHorizontal(axis)) {\n      snapConstraints.x.min = createConstraints.left;\n      snapConstraints.x.max = createConstraints.right;\n    } else {\n      snapConstraints.y.min = createConstraints.top;\n      snapConstraints.y.max = createConstraints.bottom;\n    }\n  }\n\n  // resize\n  var minResizeConstraints = resizeConstraints.min,\n    maxResizeConstraints = resizeConstraints.max;\n  if (minResizeConstraints) {\n    if (isHorizontal(axis)) {\n      if (isWest(direction)) {\n        snapConstraints.x.max = minResizeConstraints.left;\n      } else {\n        snapConstraints.x.min = minResizeConstraints.right;\n      }\n    } else {\n      if (isNorth(direction)) {\n        snapConstraints.y.max = minResizeConstraints.top;\n      } else {\n        snapConstraints.y.min = minResizeConstraints.bottom;\n      }\n    }\n  }\n  if (maxResizeConstraints) {\n    if (isHorizontal(axis)) {\n      if (isWest(direction)) {\n        snapConstraints.x.min = maxResizeConstraints.left;\n      } else {\n        snapConstraints.x.max = maxResizeConstraints.right;\n      }\n    } else {\n      if (isNorth(direction)) {\n        snapConstraints.y.min = maxResizeConstraints.top;\n      } else {\n        snapConstraints.y.max = maxResizeConstraints.bottom;\n      }\n    }\n  }\n  return snapConstraints[axis];\n}\n\n/**\r\n * Get snap offset.\r\n * Offset is cached.\r\n *\r\n * @param {Object} event\r\n * @param {string} axis\r\n * @param {ElementRegistry} elementRegistry\r\n *\r\n * @return {number}\r\n */\nfunction getSnapOffset(event, axis, elementRegistry) {\n  var context = event.context,\n    shape = event.shape,\n    gridSnappingContext = context.gridSnappingContext,\n    snapLocation = gridSnappingContext.snapLocation,\n    snapOffset = gridSnappingContext.snapOffset;\n\n  // cache snap offset\n  if (snapOffset && isNumber(snapOffset[axis])) {\n    return snapOffset[axis];\n  }\n  if (!snapOffset) {\n    snapOffset = gridSnappingContext.snapOffset = {};\n  }\n  if (!isNumber(snapOffset[axis])) {\n    snapOffset[axis] = 0;\n  }\n  if (!shape) {\n    return snapOffset[axis];\n  }\n  if (!elementRegistry.get(shape.id)) {\n    if (isHorizontal(axis)) {\n      snapOffset[axis] += shape[axis] + shape.width / 2;\n    } else {\n      snapOffset[axis] += shape[axis] + shape.height / 2;\n    }\n  }\n  if (!snapLocation) {\n    return snapOffset[axis];\n  }\n  if (axis === 'x') {\n    if (/left/.test(snapLocation)) {\n      snapOffset[axis] -= shape.width / 2;\n    } else if (/right/.test(snapLocation)) {\n      snapOffset[axis] += shape.width / 2;\n    }\n  } else {\n    if (/top/.test(snapLocation)) {\n      snapOffset[axis] -= shape.height / 2;\n    } else if (/bottom/.test(snapLocation)) {\n      snapOffset[axis] += shape.height / 2;\n    }\n  }\n  return snapOffset[axis];\n}\nfunction isHorizontal(axis) {\n  return axis === 'x';\n}\nfunction isNorth(direction) {\n  return direction.indexOf('n') !== -1;\n}\nfunction isWest(direction) {\n  return direction.indexOf('w') !== -1;\n}","map":{"version":3,"names":["setSnapped","isSnapped","isCmd","assign","isNumber","SPACING","quantize","LOWER_PRIORITY","LOW_PRIORITY","GridSnapping","elementRegistry","eventBus","config","active","_eventBus","self","on","setActive","event","originalEvent","context","gridSnappingContext","forEach","axis","options","snapOffset","getSnapOffset","offset","snapConstraints","getSnapConstraints","snapEvent","prototype","snappedValue","snapValue","getGridSpacing","value","min","max","Math","isActive","fire","toggleActive","$inject","createConstraints","resizeConstraints","direction","isHorizontal","x","left","right","y","top","bottom","minResizeConstraints","maxResizeConstraints","isWest","isNorth","shape","snapLocation","get","id","width","height","test","indexOf"],"sources":["/home/runner/work/sgex/sgex/node_modules/diagram-js/lib/features/grid-snapping/GridSnapping.js"],"sourcesContent":["import {\r\n  setSnapped,\r\n  isSnapped\r\n} from '../snapping/SnapUtil';\r\n\r\nimport { isCmd } from '../keyboard/KeyboardUtil';\r\n\r\nimport {\r\n  assign,\r\n  isNumber\r\n} from 'min-dash';\r\n\r\nimport {\r\n  SPACING,\r\n  quantize\r\n} from './GridUtil';\r\n\r\n/**\r\n * @typedef {import('../../core/ElementRegistry').default} ElementRegistry\r\n * @typedef {import('../../core/EventBus').default} EventBus\r\n */\r\n\r\nvar LOWER_PRIORITY = 1200;\r\nvar LOW_PRIORITY = 800;\r\n\r\n/**\r\n * Basic grid snapping that covers connecting, creating, moving, resizing shapes, moving bendpoints\r\n * and connection segments.\r\n *\r\n * @param {ElementRegistry} elementRegistry\r\n * @param {EventBus} eventBus\r\n * @param {Object} config\r\n */\r\nexport default function GridSnapping(elementRegistry, eventBus, config) {\r\n\r\n  var active = !config || config.active !== false;\r\n\r\n  this._eventBus = eventBus;\r\n\r\n  var self = this;\r\n\r\n  eventBus.on('diagram.init', LOW_PRIORITY, function() {\r\n    self.setActive(active);\r\n  });\r\n\r\n  eventBus.on([\r\n    'create.move',\r\n    'create.end',\r\n    'bendpoint.move.move',\r\n    'bendpoint.move.end',\r\n    'connect.move',\r\n    'connect.end',\r\n    'connectionSegment.move.move',\r\n    'connectionSegment.move.end',\r\n    'resize.move',\r\n    'resize.end',\r\n    'shape.move.move',\r\n    'shape.move.end'\r\n  ], LOWER_PRIORITY, function(event) {\r\n    var originalEvent = event.originalEvent;\r\n\r\n    if (!self.active || (originalEvent && isCmd(originalEvent))) {\r\n      return;\r\n    }\r\n\r\n    var context = event.context,\r\n        gridSnappingContext = context.gridSnappingContext;\r\n\r\n    if (!gridSnappingContext) {\r\n      gridSnappingContext = context.gridSnappingContext = {};\r\n    }\r\n\r\n    [ 'x', 'y' ].forEach(function(axis) {\r\n      var options = {};\r\n\r\n      // allow snapping with offset\r\n      var snapOffset = getSnapOffset(event, axis, elementRegistry);\r\n\r\n      if (snapOffset) {\r\n        options.offset = snapOffset;\r\n      }\r\n\r\n      // allow snapping with min and max\r\n      var snapConstraints = getSnapConstraints(event, axis);\r\n\r\n      if (snapConstraints) {\r\n        assign(options, snapConstraints);\r\n      }\r\n\r\n      if (!isSnapped(event, axis)) {\r\n        self.snapEvent(event, axis, options);\r\n      }\r\n    });\r\n  });\r\n}\r\n\r\n/**\r\n * Snap an events x or y with optional min, max and offset.\r\n *\r\n * @param {Object} event\r\n * @param {string} axis\r\n * @param {number} [options.min]\r\n * @param {number} [options.max]\r\n * @param {number} [options.offset]\r\n */\r\nGridSnapping.prototype.snapEvent = function(event, axis, options) {\r\n  var snappedValue = this.snapValue(event[ axis ], options);\r\n\r\n  setSnapped(event, axis, snappedValue);\r\n};\r\n\r\n/**\r\n * Expose grid spacing for third parties (i.e. extensions).\r\n *\r\n * @return {number} spacing of grid dots\r\n */\r\nGridSnapping.prototype.getGridSpacing = function() {\r\n  return SPACING;\r\n};\r\n\r\n/**\r\n * Snap value with optional min, max and offset.\r\n *\r\n * @param {number} value\r\n * @param {Object} options\r\n * @param {number} [options.min]\r\n * @param {number} [options.max]\r\n * @param {number} [options.offset]\r\n */\r\nGridSnapping.prototype.snapValue = function(value, options) {\r\n  var offset = 0;\r\n\r\n  if (options && options.offset) {\r\n    offset = options.offset;\r\n  }\r\n\r\n  value += offset;\r\n\r\n  value = quantize(value, SPACING);\r\n\r\n  var min, max;\r\n\r\n  if (options && options.min) {\r\n    min = options.min;\r\n\r\n    if (isNumber(min)) {\r\n      min = quantize(min + offset, SPACING, 'ceil');\r\n\r\n      value = Math.max(value, min);\r\n    }\r\n  }\r\n\r\n  if (options && options.max) {\r\n    max = options.max;\r\n\r\n    if (isNumber(max)) {\r\n      max = quantize(max + offset, SPACING, 'floor');\r\n\r\n      value = Math.min(value, max);\r\n    }\r\n  }\r\n\r\n  value -= offset;\r\n\r\n  return value;\r\n};\r\n\r\nGridSnapping.prototype.isActive = function() {\r\n  return this.active;\r\n};\r\n\r\nGridSnapping.prototype.setActive = function(active) {\r\n  this.active = active;\r\n\r\n  this._eventBus.fire('gridSnapping.toggle', { active: active });\r\n};\r\n\r\nGridSnapping.prototype.toggleActive = function() {\r\n  this.setActive(!this.active);\r\n};\r\n\r\nGridSnapping.$inject = [\r\n  'elementRegistry',\r\n  'eventBus',\r\n  'config.gridSnapping'\r\n];\r\n\r\n// helpers //////////\r\n\r\n/**\r\n * Get minimum and maximum snap constraints.\r\n * Constraints are cached.\r\n *\r\n * @param {Object} event\r\n * @param {Object} event.context\r\n * @param {string} axis\r\n *\r\n * @return {boolean|Object}\r\n */\r\nfunction getSnapConstraints(event, axis) {\r\n  var context = event.context,\r\n      createConstraints = context.createConstraints,\r\n      resizeConstraints = context.resizeConstraints || {},\r\n      gridSnappingContext = context.gridSnappingContext,\r\n      snapConstraints = gridSnappingContext.snapConstraints;\r\n\r\n  // cache snap constraints\r\n  if (snapConstraints && snapConstraints[ axis ]) {\r\n    return snapConstraints[ axis ];\r\n  }\r\n\r\n  if (!snapConstraints) {\r\n    snapConstraints = gridSnappingContext.snapConstraints = {};\r\n  }\r\n\r\n  if (!snapConstraints[ axis ]) {\r\n    snapConstraints[ axis ] = {};\r\n  }\r\n\r\n  var direction = context.direction;\r\n\r\n  // create\r\n  if (createConstraints) {\r\n    if (isHorizontal(axis)) {\r\n      snapConstraints.x.min = createConstraints.left;\r\n      snapConstraints.x.max = createConstraints.right;\r\n    } else {\r\n      snapConstraints.y.min = createConstraints.top;\r\n      snapConstraints.y.max = createConstraints.bottom;\r\n    }\r\n  }\r\n\r\n  // resize\r\n  var minResizeConstraints = resizeConstraints.min,\r\n      maxResizeConstraints = resizeConstraints.max;\r\n\r\n  if (minResizeConstraints) {\r\n    if (isHorizontal(axis)) {\r\n\r\n      if (isWest(direction)) {\r\n        snapConstraints.x.max = minResizeConstraints.left;\r\n      } else {\r\n        snapConstraints.x.min = minResizeConstraints.right;\r\n      }\r\n\r\n    } else {\r\n\r\n      if (isNorth(direction)) {\r\n        snapConstraints.y.max = minResizeConstraints.top;\r\n      } else {\r\n        snapConstraints.y.min = minResizeConstraints.bottom;\r\n      }\r\n\r\n    }\r\n  }\r\n\r\n  if (maxResizeConstraints) {\r\n    if (isHorizontal(axis)) {\r\n\r\n      if (isWest(direction)) {\r\n        snapConstraints.x.min = maxResizeConstraints.left;\r\n      } else {\r\n        snapConstraints.x.max = maxResizeConstraints.right;\r\n      }\r\n\r\n    } else {\r\n\r\n      if (isNorth(direction)) {\r\n        snapConstraints.y.min = maxResizeConstraints.top;\r\n      } else {\r\n        snapConstraints.y.max = maxResizeConstraints.bottom;\r\n      }\r\n\r\n    }\r\n  }\r\n\r\n  return snapConstraints[ axis ];\r\n}\r\n\r\n/**\r\n * Get snap offset.\r\n * Offset is cached.\r\n *\r\n * @param {Object} event\r\n * @param {string} axis\r\n * @param {ElementRegistry} elementRegistry\r\n *\r\n * @return {number}\r\n */\r\nfunction getSnapOffset(event, axis, elementRegistry) {\r\n  var context = event.context,\r\n      shape = event.shape,\r\n      gridSnappingContext = context.gridSnappingContext,\r\n      snapLocation = gridSnappingContext.snapLocation,\r\n      snapOffset = gridSnappingContext.snapOffset;\r\n\r\n  // cache snap offset\r\n  if (snapOffset && isNumber(snapOffset[ axis ])) {\r\n    return snapOffset[ axis ];\r\n  }\r\n\r\n  if (!snapOffset) {\r\n    snapOffset = gridSnappingContext.snapOffset = {};\r\n  }\r\n\r\n  if (!isNumber(snapOffset[ axis ])) {\r\n    snapOffset[ axis ] = 0;\r\n  }\r\n\r\n  if (!shape) {\r\n    return snapOffset[ axis ];\r\n  }\r\n\r\n  if (!elementRegistry.get(shape.id)) {\r\n\r\n    if (isHorizontal(axis)) {\r\n      snapOffset[ axis ] += shape[ axis ] + shape.width / 2;\r\n    } else {\r\n      snapOffset[ axis ] += shape[ axis ] + shape.height / 2;\r\n    }\r\n  }\r\n\r\n  if (!snapLocation) {\r\n    return snapOffset[ axis ];\r\n  }\r\n\r\n  if (axis === 'x') {\r\n    if (/left/.test(snapLocation)) {\r\n      snapOffset[ axis ] -= shape.width / 2;\r\n    } else if (/right/.test(snapLocation)) {\r\n      snapOffset[ axis ] += shape.width / 2;\r\n    }\r\n  } else {\r\n    if (/top/.test(snapLocation)) {\r\n      snapOffset[ axis ] -= shape.height / 2;\r\n    } else if (/bottom/.test(snapLocation)) {\r\n      snapOffset[ axis ] += shape.height / 2;\r\n    }\r\n  }\r\n\r\n  return snapOffset[ axis ];\r\n}\r\n\r\nfunction isHorizontal(axis) {\r\n  return axis === 'x';\r\n}\r\n\r\nfunction isNorth(direction) {\r\n  return direction.indexOf('n') !== -1;\r\n}\r\n\r\nfunction isWest(direction) {\r\n  return direction.indexOf('w') !== -1;\r\n}"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}