{"ast":null,"code":"import { pick, assign } from 'min-dash';\nimport { resizeBounds, ensureConstraints, computeChildrenBBox, getMinResizeBounds } from './ResizeUtil';\nimport { asTRBL, getMid, roundBounds } from '../../layout/LayoutUtil';\n\n/**\n * @typedef {import('../../core/Types').ShapeLike} Shape\n *\n * @typedef {import('../../util/Types').Direction} Direction\n * @typedef {import('../../util/Types').Point} Point\n *\n * @typedef {import('../../core/EventBus').default} EventBus\n * @typedef {import('../dragging/Dragging').default} Dragging\n * @typedef {import('../modeling/Modeling').default} Modeling\n * @typedef {import('../rules/Rules').default} Rules\n */\n\nvar DEFAULT_MIN_WIDTH = 10;\n\n/**\n * A component that provides resizing of shapes on the canvas.\n *\n * The following components are part of shape resize:\n *\n *  * adding resize handles,\n *  * creating a visual during resize\n *  * checking resize rules\n *  * committing a change once finished\n *\n *\n * ## Customizing\n *\n * It's possible to customize the resizing behaviour by intercepting 'resize.start'\n * and providing the following parameters through the 'context':\n *\n *   * minDimensions ({ width, height }): minimum shape dimensions\n *\n *   * childrenBoxPadding ({ left, top, bottom, right } || number):\n *     gap between the minimum bounding box and the container\n *\n * f.ex:\n *\n * ```javascript\n * eventBus.on('resize.start', 1500, function(event) {\n *   var context = event.context,\n *\n *  context.minDimensions = { width: 140, height: 120 };\n *\n *  // Passing general padding\n *  context.childrenBoxPadding = 30;\n *\n *  // Passing padding to a specific side\n *  context.childrenBoxPadding.left = 20;\n * });\n * ```\n *\n * @param {EventBus} eventBus\n * @param {Rules} rules\n * @param {Modeling} modeling\n * @param {Dragging} dragging\n */\nexport default function Resize(eventBus, rules, modeling, dragging) {\n  this._dragging = dragging;\n  this._rules = rules;\n  var self = this;\n\n  /**\n   * Handle resize move by specified delta.\n   *\n   * @param {Object} context\n   * @param {Point} delta\n   */\n  function handleMove(context, delta) {\n    var shape = context.shape,\n      direction = context.direction,\n      resizeConstraints = context.resizeConstraints,\n      newBounds;\n    context.delta = delta;\n    newBounds = resizeBounds(shape, direction, delta);\n\n    // ensure constraints during resize\n    context.newBounds = ensureConstraints(newBounds, resizeConstraints);\n\n    // update + cache executable state\n    context.canExecute = self.canResize(context);\n  }\n\n  /**\n   * Handle resize start.\n   *\n   * @param {Object} context\n   */\n  function handleStart(context) {\n    var resizeConstraints = context.resizeConstraints,\n      // evaluate minBounds for backwards compatibility\n      minBounds = context.minBounds;\n    if (resizeConstraints !== undefined) {\n      return;\n    }\n    if (minBounds === undefined) {\n      minBounds = self.computeMinResizeBox(context);\n    }\n    context.resizeConstraints = {\n      min: asTRBL(minBounds)\n    };\n  }\n\n  /**\n   * Handle resize end.\n   *\n   * @param {Object} context\n   */\n  function handleEnd(context) {\n    var shape = context.shape,\n      canExecute = context.canExecute,\n      newBounds = context.newBounds;\n    if (canExecute) {\n      // ensure we have actual pixel values for new bounds\n      // (important when zoom level was > 1 during move)\n      newBounds = roundBounds(newBounds);\n      if (!boundsChanged(shape, newBounds)) {\n        // no resize necessary\n        return;\n      }\n\n      // perform the actual resize\n      modeling.resizeShape(shape, newBounds);\n    }\n  }\n  eventBus.on('resize.start', function (event) {\n    handleStart(event.context);\n  });\n  eventBus.on('resize.move', function (event) {\n    var delta = {\n      x: event.dx,\n      y: event.dy\n    };\n    handleMove(event.context, delta);\n  });\n  eventBus.on('resize.end', function (event) {\n    handleEnd(event.context);\n  });\n}\nResize.prototype.canResize = function (context) {\n  var rules = this._rules;\n  var ctx = pick(context, ['newBounds', 'shape', 'delta', 'direction']);\n  return rules.allowed('shape.resize', ctx);\n};\n\n/**\n * Activate a resize operation.\n *\n * You may specify additional contextual information and must specify a\n * resize direction during activation of the resize event.\n *\n * @param {MouseEvent|TouchEvent} event\n * @param {Shape} shape\n * @param {Object|Direction} contextOrDirection\n */\nResize.prototype.activate = function (event, shape, contextOrDirection) {\n  var dragging = this._dragging,\n    context,\n    direction;\n  if (typeof contextOrDirection === 'string') {\n    contextOrDirection = {\n      direction: contextOrDirection\n    };\n  }\n  context = assign({\n    shape: shape\n  }, contextOrDirection);\n  direction = context.direction;\n  if (!direction) {\n    throw new Error('must provide a direction (n|w|s|e|nw|se|ne|sw)');\n  }\n  dragging.init(event, getReferencePoint(shape, direction), 'resize', {\n    autoActivate: true,\n    cursor: getCursor(direction),\n    data: {\n      shape: shape,\n      context: context\n    }\n  });\n};\nResize.prototype.computeMinResizeBox = function (context) {\n  var shape = context.shape,\n    direction = context.direction,\n    minDimensions,\n    childrenBounds;\n  minDimensions = context.minDimensions || {\n    width: DEFAULT_MIN_WIDTH,\n    height: DEFAULT_MIN_WIDTH\n  };\n\n  // get children bounds\n  childrenBounds = computeChildrenBBox(shape, context.childrenBoxPadding);\n\n  // get correct minimum bounds from given resize direction\n  // basically ensures that the minBounds is max(childrenBounds, minDimensions)\n  return getMinResizeBounds(direction, shape, minDimensions, childrenBounds);\n};\nResize.$inject = ['eventBus', 'rules', 'modeling', 'dragging'];\n\n// helpers //////////\n\nfunction boundsChanged(shape, newBounds) {\n  return shape.x !== newBounds.x || shape.y !== newBounds.y || shape.width !== newBounds.width || shape.height !== newBounds.height;\n}\nexport function getReferencePoint(shape, direction) {\n  var mid = getMid(shape),\n    trbl = asTRBL(shape);\n  var referencePoint = {\n    x: mid.x,\n    y: mid.y\n  };\n  if (direction.indexOf('n') !== -1) {\n    referencePoint.y = trbl.top;\n  } else if (direction.indexOf('s') !== -1) {\n    referencePoint.y = trbl.bottom;\n  }\n  if (direction.indexOf('e') !== -1) {\n    referencePoint.x = trbl.right;\n  } else if (direction.indexOf('w') !== -1) {\n    referencePoint.x = trbl.left;\n  }\n  return referencePoint;\n}\nfunction getCursor(direction) {\n  var prefix = 'resize-';\n  if (direction === 'n' || direction === 's') {\n    return prefix + 'ns';\n  } else if (direction === 'e' || direction === 'w') {\n    return prefix + 'ew';\n  } else if (direction === 'nw' || direction === 'se') {\n    return prefix + 'nwse';\n  } else {\n    return prefix + 'nesw';\n  }\n}","map":{"version":3,"names":["pick","assign","resizeBounds","ensureConstraints","computeChildrenBBox","getMinResizeBounds","asTRBL","getMid","roundBounds","DEFAULT_MIN_WIDTH","Resize","eventBus","rules","modeling","dragging","_dragging","_rules","self","handleMove","context","delta","shape","direction","resizeConstraints","newBounds","canExecute","canResize","handleStart","minBounds","undefined","computeMinResizeBox","min","handleEnd","boundsChanged","resizeShape","on","event","x","dx","y","dy","prototype","ctx","allowed","activate","contextOrDirection","Error","init","getReferencePoint","autoActivate","cursor","getCursor","data","minDimensions","childrenBounds","width","height","childrenBoxPadding","$inject","mid","trbl","referencePoint","indexOf","top","bottom","right","left","prefix"],"sources":["/home/runner/work/sgex/sgex/node_modules/diagram-js/lib/features/resize/Resize.js"],"sourcesContent":["import {\n  pick,\n  assign\n} from 'min-dash';\n\nimport {\n  resizeBounds,\n  ensureConstraints,\n  computeChildrenBBox,\n  getMinResizeBounds\n} from './ResizeUtil';\n\nimport {\n  asTRBL,\n  getMid,\n  roundBounds\n} from '../../layout/LayoutUtil';\n\n/**\n * @typedef {import('../../core/Types').ShapeLike} Shape\n *\n * @typedef {import('../../util/Types').Direction} Direction\n * @typedef {import('../../util/Types').Point} Point\n *\n * @typedef {import('../../core/EventBus').default} EventBus\n * @typedef {import('../dragging/Dragging').default} Dragging\n * @typedef {import('../modeling/Modeling').default} Modeling\n * @typedef {import('../rules/Rules').default} Rules\n */\n\nvar DEFAULT_MIN_WIDTH = 10;\n\n\n/**\n * A component that provides resizing of shapes on the canvas.\n *\n * The following components are part of shape resize:\n *\n *  * adding resize handles,\n *  * creating a visual during resize\n *  * checking resize rules\n *  * committing a change once finished\n *\n *\n * ## Customizing\n *\n * It's possible to customize the resizing behaviour by intercepting 'resize.start'\n * and providing the following parameters through the 'context':\n *\n *   * minDimensions ({ width, height }): minimum shape dimensions\n *\n *   * childrenBoxPadding ({ left, top, bottom, right } || number):\n *     gap between the minimum bounding box and the container\n *\n * f.ex:\n *\n * ```javascript\n * eventBus.on('resize.start', 1500, function(event) {\n *   var context = event.context,\n *\n *  context.minDimensions = { width: 140, height: 120 };\n *\n *  // Passing general padding\n *  context.childrenBoxPadding = 30;\n *\n *  // Passing padding to a specific side\n *  context.childrenBoxPadding.left = 20;\n * });\n * ```\n *\n * @param {EventBus} eventBus\n * @param {Rules} rules\n * @param {Modeling} modeling\n * @param {Dragging} dragging\n */\nexport default function Resize(eventBus, rules, modeling, dragging) {\n\n  this._dragging = dragging;\n  this._rules = rules;\n\n  var self = this;\n\n\n  /**\n   * Handle resize move by specified delta.\n   *\n   * @param {Object} context\n   * @param {Point} delta\n   */\n  function handleMove(context, delta) {\n\n    var shape = context.shape,\n        direction = context.direction,\n        resizeConstraints = context.resizeConstraints,\n        newBounds;\n\n    context.delta = delta;\n\n    newBounds = resizeBounds(shape, direction, delta);\n\n    // ensure constraints during resize\n    context.newBounds = ensureConstraints(newBounds, resizeConstraints);\n\n    // update + cache executable state\n    context.canExecute = self.canResize(context);\n  }\n\n  /**\n   * Handle resize start.\n   *\n   * @param {Object} context\n   */\n  function handleStart(context) {\n\n    var resizeConstraints = context.resizeConstraints,\n\n        // evaluate minBounds for backwards compatibility\n        minBounds = context.minBounds;\n\n    if (resizeConstraints !== undefined) {\n      return;\n    }\n\n    if (minBounds === undefined) {\n      minBounds = self.computeMinResizeBox(context);\n    }\n\n    context.resizeConstraints = {\n      min: asTRBL(minBounds)\n    };\n  }\n\n  /**\n   * Handle resize end.\n   *\n   * @param {Object} context\n   */\n  function handleEnd(context) {\n    var shape = context.shape,\n        canExecute = context.canExecute,\n        newBounds = context.newBounds;\n\n    if (canExecute) {\n\n      // ensure we have actual pixel values for new bounds\n      // (important when zoom level was > 1 during move)\n      newBounds = roundBounds(newBounds);\n\n      if (!boundsChanged(shape, newBounds)) {\n\n        // no resize necessary\n        return;\n      }\n\n      // perform the actual resize\n      modeling.resizeShape(shape, newBounds);\n    }\n  }\n\n\n  eventBus.on('resize.start', function(event) {\n    handleStart(event.context);\n  });\n\n  eventBus.on('resize.move', function(event) {\n    var delta = {\n      x: event.dx,\n      y: event.dy\n    };\n\n    handleMove(event.context, delta);\n  });\n\n  eventBus.on('resize.end', function(event) {\n    handleEnd(event.context);\n  });\n\n}\n\n\nResize.prototype.canResize = function(context) {\n  var rules = this._rules;\n\n  var ctx = pick(context, [ 'newBounds', 'shape', 'delta', 'direction' ]);\n\n  return rules.allowed('shape.resize', ctx);\n};\n\n/**\n * Activate a resize operation.\n *\n * You may specify additional contextual information and must specify a\n * resize direction during activation of the resize event.\n *\n * @param {MouseEvent|TouchEvent} event\n * @param {Shape} shape\n * @param {Object|Direction} contextOrDirection\n */\nResize.prototype.activate = function(event, shape, contextOrDirection) {\n  var dragging = this._dragging,\n      context,\n      direction;\n\n  if (typeof contextOrDirection === 'string') {\n    contextOrDirection = {\n      direction: contextOrDirection\n    };\n  }\n\n  context = assign({ shape: shape }, contextOrDirection);\n\n  direction = context.direction;\n\n  if (!direction) {\n    throw new Error('must provide a direction (n|w|s|e|nw|se|ne|sw)');\n  }\n\n  dragging.init(event, getReferencePoint(shape, direction), 'resize', {\n    autoActivate: true,\n    cursor: getCursor(direction),\n    data: {\n      shape: shape,\n      context: context\n    }\n  });\n};\n\nResize.prototype.computeMinResizeBox = function(context) {\n  var shape = context.shape,\n      direction = context.direction,\n      minDimensions,\n      childrenBounds;\n\n  minDimensions = context.minDimensions || {\n    width: DEFAULT_MIN_WIDTH,\n    height: DEFAULT_MIN_WIDTH\n  };\n\n  // get children bounds\n  childrenBounds = computeChildrenBBox(shape, context.childrenBoxPadding);\n\n  // get correct minimum bounds from given resize direction\n  // basically ensures that the minBounds is max(childrenBounds, minDimensions)\n  return getMinResizeBounds(direction, shape, minDimensions, childrenBounds);\n};\n\n\nResize.$inject = [\n  'eventBus',\n  'rules',\n  'modeling',\n  'dragging'\n];\n\n// helpers //////////\n\nfunction boundsChanged(shape, newBounds) {\n  return shape.x !== newBounds.x ||\n    shape.y !== newBounds.y ||\n    shape.width !== newBounds.width ||\n    shape.height !== newBounds.height;\n}\n\nexport function getReferencePoint(shape, direction) {\n  var mid = getMid(shape),\n      trbl = asTRBL(shape);\n\n  var referencePoint = {\n    x: mid.x,\n    y: mid.y\n  };\n\n  if (direction.indexOf('n') !== -1) {\n    referencePoint.y = trbl.top;\n  } else if (direction.indexOf('s') !== -1) {\n    referencePoint.y = trbl.bottom;\n  }\n\n  if (direction.indexOf('e') !== -1) {\n    referencePoint.x = trbl.right;\n  } else if (direction.indexOf('w') !== -1) {\n    referencePoint.x = trbl.left;\n  }\n\n  return referencePoint;\n}\n\nfunction getCursor(direction) {\n  var prefix = 'resize-';\n\n  if (direction === 'n' || direction === 's') {\n    return prefix + 'ns';\n  } else if (direction === 'e' || direction === 'w') {\n    return prefix + 'ew';\n  } else if (direction === 'nw' || direction === 'se') {\n    return prefix + 'nwse';\n  } else {\n    return prefix + 'nesw';\n  }\n}"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}