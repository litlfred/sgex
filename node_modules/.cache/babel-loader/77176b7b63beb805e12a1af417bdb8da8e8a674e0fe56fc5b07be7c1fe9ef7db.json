{"ast":null,"code":"import ENDPOINTS from \"./generated/endpoints.js\";\nconst endpointMethodsMap = /* @__PURE__ */new Map();\nfor (const [scope, endpoints] of Object.entries(ENDPOINTS)) {\n  for (const [methodName, endpoint] of Object.entries(endpoints)) {\n    const [route, defaults, decorations] = endpoint;\n    const [method, url] = route.split(/ /);\n    const endpointDefaults = Object.assign({\n      method,\n      url\n    }, defaults);\n    if (!endpointMethodsMap.has(scope)) {\n      endpointMethodsMap.set(scope, /* @__PURE__ */new Map());\n    }\n    endpointMethodsMap.get(scope).set(methodName, {\n      scope,\n      methodName,\n      endpointDefaults,\n      decorations\n    });\n  }\n}\nconst handler = {\n  has(_ref, methodName) {\n    let {\n      scope\n    } = _ref;\n    return endpointMethodsMap.get(scope).has(methodName);\n  },\n  getOwnPropertyDescriptor(target, methodName) {\n    return {\n      value: this.get(target, methodName),\n      // ensures method is in the cache\n      configurable: true,\n      writable: true,\n      enumerable: true\n    };\n  },\n  defineProperty(target, methodName, descriptor) {\n    Object.defineProperty(target.cache, methodName, descriptor);\n    return true;\n  },\n  deleteProperty(target, methodName) {\n    delete target.cache[methodName];\n    return true;\n  },\n  ownKeys(_ref2) {\n    let {\n      scope\n    } = _ref2;\n    return [...endpointMethodsMap.get(scope).keys()];\n  },\n  set(target, methodName, value) {\n    return target.cache[methodName] = value;\n  },\n  get(_ref3, methodName) {\n    let {\n      octokit,\n      scope,\n      cache\n    } = _ref3;\n    if (cache[methodName]) {\n      return cache[methodName];\n    }\n    const method = endpointMethodsMap.get(scope).get(methodName);\n    if (!method) {\n      return void 0;\n    }\n    const {\n      endpointDefaults,\n      decorations\n    } = method;\n    if (decorations) {\n      cache[methodName] = decorate(octokit, scope, methodName, endpointDefaults, decorations);\n    } else {\n      cache[methodName] = octokit.request.defaults(endpointDefaults);\n    }\n    return cache[methodName];\n  }\n};\nfunction endpointsToMethods(octokit) {\n  const newMethods = {};\n  for (const scope of endpointMethodsMap.keys()) {\n    newMethods[scope] = new Proxy({\n      octokit,\n      scope,\n      cache: {}\n    }, handler);\n  }\n  return newMethods;\n}\nfunction decorate(octokit, scope, methodName, defaults, decorations) {\n  const requestWithDefaults = octokit.request.defaults(defaults);\n  function withDecorations() {\n    let options = requestWithDefaults.endpoint.merge(...arguments);\n    if (decorations.mapToData) {\n      options = Object.assign({}, options, {\n        data: options[decorations.mapToData],\n        [decorations.mapToData]: void 0\n      });\n      return requestWithDefaults(options);\n    }\n    if (decorations.renamed) {\n      const [newScope, newMethodName] = decorations.renamed;\n      octokit.log.warn(\"octokit.\".concat(scope, \".\").concat(methodName, \"() has been renamed to octokit.\").concat(newScope, \".\").concat(newMethodName, \"()\"));\n    }\n    if (decorations.deprecated) {\n      octokit.log.warn(decorations.deprecated);\n    }\n    if (decorations.renamedParameters) {\n      const options2 = requestWithDefaults.endpoint.merge(...arguments);\n      for (const [name, alias] of Object.entries(decorations.renamedParameters)) {\n        if (name in options2) {\n          octokit.log.warn(\"\\\"\".concat(name, \"\\\" parameter is deprecated for \\\"octokit.\").concat(scope, \".\").concat(methodName, \"()\\\". Use \\\"\").concat(alias, \"\\\" instead\"));\n          if (!(alias in options2)) {\n            options2[alias] = options2[name];\n          }\n          delete options2[name];\n        }\n      }\n      return requestWithDefaults(options2);\n    }\n    return requestWithDefaults(...arguments);\n  }\n  return Object.assign(withDecorations, requestWithDefaults);\n}\nexport { endpointsToMethods };","map":{"version":3,"names":["ENDPOINTS","endpointMethodsMap","Map","scope","endpoints","Object","entries","methodName","endpoint","route","defaults","decorations","method","url","split","endpointDefaults","assign","has","set","get","handler","_ref","getOwnPropertyDescriptor","target","value","configurable","writable","enumerable","defineProperty","descriptor","cache","deleteProperty","ownKeys","_ref2","keys","_ref3","octokit","decorate","request","endpointsToMethods","newMethods","Proxy","requestWithDefaults","withDecorations","options","merge","arguments","mapToData","data","renamed","newScope","newMethodName","log","warn","concat","deprecated","renamedParameters","options2","name","alias"],"sources":["/home/runner/work/sgex/sgex/node_modules/@octokit/src/endpoints-to-methods.ts"],"sourcesContent":["import type { Octokit } from \"@octokit/core\";\nimport type { EndpointOptions, RequestParameters, Route } from \"@octokit/types\";\nimport ENDPOINTS from \"./generated/endpoints.js\";\nimport type { RestEndpointMethods } from \"./generated/method-types.js\";\nimport type { EndpointDecorations } from \"./types.js\";\n\n// The following code was refactored in: https://github.com/octokit/plugin-rest-endpoint-methods.js/pull/622\n// to optimise the runtime performance of Octokit initialization.\n//\n// This optimization involves two key changes:\n// 1. Pre-Computation: The endpoint methods are pre-computed once at module load\n//    time instead of each invocation of `endpointsToMethods()`.\n// 2. Lazy initialization and caching: We use a Proxy for each scope to only\n//    initialize methods that are actually called. This reduces runtime overhead\n//    as the initialization involves deep merging of objects. The initialized\n//    methods are then cached for future use.\n\nconst endpointMethodsMap = new Map();\nfor (const [scope, endpoints] of Object.entries(ENDPOINTS)) {\n  for (const [methodName, endpoint] of Object.entries(endpoints)) {\n    const [route, defaults, decorations] = endpoint;\n    const [method, url] = route.split(/ /);\n    const endpointDefaults = Object.assign(\n      {\n        method,\n        url,\n      },\n      defaults,\n    );\n\n    if (!endpointMethodsMap.has(scope)) {\n      endpointMethodsMap.set(scope, new Map());\n    }\n\n    endpointMethodsMap.get(scope).set(methodName, {\n      scope,\n      methodName,\n      endpointDefaults,\n      decorations,\n    });\n  }\n}\n\ntype ProxyTarget = {\n  octokit: Octokit;\n  scope: string;\n  cache: Record<string, (...args: any[]) => any>;\n};\n\nconst handler = {\n  has({ scope }: ProxyTarget, methodName: string) {\n    return endpointMethodsMap.get(scope).has(methodName);\n  },\n  getOwnPropertyDescriptor(target: ProxyTarget, methodName: string) {\n    return {\n      value: this.get(target, methodName), // ensures method is in the cache\n      configurable: true,\n      writable: true,\n      enumerable: true,\n    };\n  },\n  defineProperty(\n    target: ProxyTarget,\n    methodName: string,\n    descriptor: PropertyDescriptor,\n  ) {\n    Object.defineProperty(target.cache, methodName, descriptor);\n    return true;\n  },\n  deleteProperty(target: ProxyTarget, methodName: string) {\n    delete target.cache[methodName];\n    return true;\n  },\n  ownKeys({ scope }: ProxyTarget) {\n    return [...endpointMethodsMap.get(scope).keys()];\n  },\n  set(target: ProxyTarget, methodName: string, value: any) {\n    return (target.cache[methodName] = value);\n  },\n  get({ octokit, scope, cache }: ProxyTarget, methodName: string) {\n    if (cache[methodName]) {\n      return cache[methodName];\n    }\n\n    const method = endpointMethodsMap.get(scope).get(methodName);\n    if (!method) {\n      return undefined;\n    }\n\n    const { endpointDefaults, decorations } = method;\n\n    if (decorations) {\n      cache[methodName] = decorate(\n        octokit,\n        scope,\n        methodName,\n        endpointDefaults,\n        decorations,\n      );\n    } else {\n      cache[methodName] = octokit.request.defaults(endpointDefaults);\n    }\n\n    return cache[methodName];\n  },\n};\n\nexport function endpointsToMethods(octokit: Octokit): RestEndpointMethods {\n  const newMethods = {} as { [key: string]: object };\n\n  for (const scope of endpointMethodsMap.keys()) {\n    newMethods[scope] = new Proxy({ octokit, scope, cache: {} }, handler);\n  }\n\n  return newMethods as RestEndpointMethods;\n}\n\nfunction decorate(\n  octokit: Octokit,\n  scope: string,\n  methodName: string,\n  defaults: EndpointOptions,\n  decorations: EndpointDecorations,\n) {\n  const requestWithDefaults = octokit.request.defaults(defaults);\n\n  /* istanbul ignore next */\n  function withDecorations(\n    ...args: [Route, RequestParameters?] | [EndpointOptions]\n  ) {\n    // @ts-ignore https://github.com/microsoft/TypeScript/issues/25488\n    let options = requestWithDefaults.endpoint.merge(...args);\n\n    // There are currently no other decorations than `.mapToData`\n    if (decorations.mapToData) {\n      options = Object.assign({}, options, {\n        data: options[decorations.mapToData],\n        [decorations.mapToData]: undefined,\n      });\n      return requestWithDefaults(options);\n    }\n\n    if (decorations.renamed) {\n      const [newScope, newMethodName] = decorations.renamed;\n      octokit.log.warn(\n        `octokit.${scope}.${methodName}() has been renamed to octokit.${newScope}.${newMethodName}()`,\n      );\n    }\n    if (decorations.deprecated) {\n      octokit.log.warn(decorations.deprecated);\n    }\n\n    if (decorations.renamedParameters) {\n      // @ts-ignore https://github.com/microsoft/TypeScript/issues/25488\n      const options = requestWithDefaults.endpoint.merge(...args);\n\n      for (const [name, alias] of Object.entries(\n        decorations.renamedParameters,\n      )) {\n        if (name in options) {\n          octokit.log.warn(\n            `\"${name}\" parameter is deprecated for \"octokit.${scope}.${methodName}()\". Use \"${alias}\" instead`,\n          );\n          if (!(alias in options)) {\n            options[alias] = options[name];\n          }\n          delete options[name];\n        }\n      }\n      return requestWithDefaults(options);\n    }\n\n    // @ts-ignore https://github.com/microsoft/TypeScript/issues/25488\n    return requestWithDefaults(...args);\n  }\n  return Object.assign(withDecorations, requestWithDefaults);\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}