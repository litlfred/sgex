{"ast":null,"code":"\"use strict\";\n\nvar _taggedTemplateLiteral = require(\"/home/runner/work/sgex/sgex/node_modules/@babel/runtime/helpers/taggedTemplateLiteral.js\").default;\nvar _templateObject, _templateObject2;\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nconst code_1 = require(\"../code\");\nconst codegen_1 = require(\"../../compile/codegen\");\nconst util_1 = require(\"../../compile/util\");\nconst util_2 = require(\"../../compile/util\");\nconst def = {\n  keyword: \"patternProperties\",\n  type: \"object\",\n  schemaType: \"object\",\n  code(cxt) {\n    const {\n      gen,\n      schema,\n      data,\n      parentSchema,\n      it\n    } = cxt;\n    const {\n      opts\n    } = it;\n    const patterns = (0, code_1.allSchemaProperties)(schema);\n    const alwaysValidPatterns = patterns.filter(p => (0, util_1.alwaysValidSchema)(it, schema[p]));\n    if (patterns.length === 0 || alwaysValidPatterns.length === patterns.length && (!it.opts.unevaluated || it.props === true)) {\n      return;\n    }\n    const checkProperties = opts.strictSchema && !opts.allowMatchingProperties && parentSchema.properties;\n    const valid = gen.name(\"valid\");\n    if (it.props !== true && !(it.props instanceof codegen_1.Name)) {\n      it.props = (0, util_2.evaluatedPropsToName)(gen, it.props);\n    }\n    const {\n      props\n    } = it;\n    validatePatternProperties();\n    function validatePatternProperties() {\n      for (const pat of patterns) {\n        if (checkProperties) checkMatchingProperties(pat);\n        if (it.allErrors) {\n          validateProperties(pat);\n        } else {\n          gen.var(valid, true); // TODO var\n          validateProperties(pat);\n          gen.if(valid);\n        }\n      }\n    }\n    function checkMatchingProperties(pat) {\n      for (const prop in checkProperties) {\n        if (new RegExp(pat).test(prop)) {\n          (0, util_1.checkStrictMode)(it, \"property \".concat(prop, \" matches pattern \").concat(pat, \" (use allowMatchingProperties)\"));\n        }\n      }\n    }\n    function validateProperties(pat) {\n      gen.forIn(\"key\", data, key => {\n        gen.if((0, codegen_1._)(_templateObject || (_templateObject = _taggedTemplateLiteral([\"\", \".test(\", \")\"])), (0, code_1.usePattern)(cxt, pat), key), () => {\n          const alwaysValid = alwaysValidPatterns.includes(pat);\n          if (!alwaysValid) {\n            cxt.subschema({\n              keyword: \"patternProperties\",\n              schemaProp: pat,\n              dataProp: key,\n              dataPropType: util_2.Type.Str\n            }, valid);\n          }\n          if (it.opts.unevaluated && props !== true) {\n            gen.assign((0, codegen_1._)(_templateObject2 || (_templateObject2 = _taggedTemplateLiteral([\"\", \"[\", \"]\"])), props, key), true);\n          } else if (!alwaysValid && !it.allErrors) {\n            // can short-circuit if `unevaluatedProperties` is not supported (opts.next === false)\n            // or if all properties were evaluated (props === true)\n            gen.if((0, codegen_1.not)(valid), () => gen.break());\n          }\n        });\n      });\n    }\n  }\n};\nexports.default = def;","map":{"version":3,"names":["code_1","require","codegen_1","util_1","util_2","def","keyword","type","schemaType","code","cxt","gen","schema","data","parentSchema","it","opts","patterns","allSchemaProperties","alwaysValidPatterns","filter","p","alwaysValidSchema","length","unevaluated","props","checkProperties","strictSchema","allowMatchingProperties","properties","valid","name","Name","evaluatedPropsToName","validatePatternProperties","pat","checkMatchingProperties","allErrors","validateProperties","var","if","prop","RegExp","test","checkStrictMode","concat","forIn","key","_","_templateObject","_taggedTemplateLiteral","usePattern","alwaysValid","includes","subschema","schemaProp","dataProp","dataPropType","Type","Str","assign","_templateObject2","not","break","exports","default"],"sources":["/home/runner/work/sgex/sgex/node_modules/ajv/lib/vocabularies/applicator/patternProperties.ts"],"sourcesContent":["import type {CodeKeywordDefinition} from \"../../types\"\nimport type {KeywordCxt} from \"../../compile/validate\"\nimport {allSchemaProperties, usePattern} from \"../code\"\nimport {_, not, Name} from \"../../compile/codegen\"\nimport {alwaysValidSchema, checkStrictMode} from \"../../compile/util\"\nimport {evaluatedPropsToName, Type} from \"../../compile/util\"\nimport {AnySchema} from \"../../types\"\n\nconst def: CodeKeywordDefinition = {\n  keyword: \"patternProperties\",\n  type: \"object\",\n  schemaType: \"object\",\n  code(cxt: KeywordCxt) {\n    const {gen, schema, data, parentSchema, it} = cxt\n    const {opts} = it\n    const patterns = allSchemaProperties(schema)\n    const alwaysValidPatterns = patterns.filter((p) =>\n      alwaysValidSchema(it, schema[p] as AnySchema)\n    )\n\n    if (\n      patterns.length === 0 ||\n      (alwaysValidPatterns.length === patterns.length &&\n        (!it.opts.unevaluated || it.props === true))\n    ) {\n      return\n    }\n\n    const checkProperties =\n      opts.strictSchema && !opts.allowMatchingProperties && parentSchema.properties\n    const valid = gen.name(\"valid\")\n    if (it.props !== true && !(it.props instanceof Name)) {\n      it.props = evaluatedPropsToName(gen, it.props)\n    }\n    const {props} = it\n    validatePatternProperties()\n\n    function validatePatternProperties(): void {\n      for (const pat of patterns) {\n        if (checkProperties) checkMatchingProperties(pat)\n        if (it.allErrors) {\n          validateProperties(pat)\n        } else {\n          gen.var(valid, true) // TODO var\n          validateProperties(pat)\n          gen.if(valid)\n        }\n      }\n    }\n\n    function checkMatchingProperties(pat: string): void {\n      for (const prop in checkProperties) {\n        if (new RegExp(pat).test(prop)) {\n          checkStrictMode(\n            it,\n            `property ${prop} matches pattern ${pat} (use allowMatchingProperties)`\n          )\n        }\n      }\n    }\n\n    function validateProperties(pat: string): void {\n      gen.forIn(\"key\", data, (key) => {\n        gen.if(_`${usePattern(cxt, pat)}.test(${key})`, () => {\n          const alwaysValid = alwaysValidPatterns.includes(pat)\n          if (!alwaysValid) {\n            cxt.subschema(\n              {\n                keyword: \"patternProperties\",\n                schemaProp: pat,\n                dataProp: key,\n                dataPropType: Type.Str,\n              },\n              valid\n            )\n          }\n\n          if (it.opts.unevaluated && props !== true) {\n            gen.assign(_`${props}[${key}]`, true)\n          } else if (!alwaysValid && !it.allErrors) {\n            // can short-circuit if `unevaluatedProperties` is not supported (opts.next === false)\n            // or if all properties were evaluated (props === true)\n            gen.if(not(valid), () => gen.break())\n          }\n        })\n      })\n    }\n  },\n}\n\nexport default def\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}