{"ast":null,"code":"var round = Math.round;\nimport { assign } from 'min-dash';\nimport { event as domEvent } from 'min-dom';\nimport { getOriginal, toPoint, stopPropagation } from '../../util/Event';\nimport { set as cursorSet, unset as cursorUnset } from '../../util/Cursor';\nimport { install as installClickTrap } from '../../util/ClickTrap';\nimport { delta as deltaPos } from '../../util/PositionUtil';\nimport { isKey } from '../keyboard/KeyboardUtil';\n\n/**\n * @typedef {import('../../util/Types').Point} Point\n *\n * @typedef {import('../../core/Canvas').default} Canvas\n * @typedef {import('../../core/ElementRegistry').default} ElementRegistry\n * @typedef {import('../../core/EventBus').default} EventBus\n * @typedef {import('../selection/Selection').default} Selection\n */\n\nvar DRAG_ACTIVE_CLS = 'djs-drag-active';\nfunction preventDefault(event) {\n  event.preventDefault();\n}\nfunction isTouchEvent(event) {\n  // check for TouchEvent being available first\n  // (i.e. not available on desktop Firefox)\n  return typeof TouchEvent !== 'undefined' && event instanceof TouchEvent;\n}\nfunction getLength(point) {\n  return Math.sqrt(Math.pow(point.x, 2) + Math.pow(point.y, 2));\n}\n\n/**\n * A helper that fires canvas localized drag events and realizes\n * the general \"drag-and-drop\" look and feel.\n *\n * Calling {@link Dragging#activate} activates dragging on a canvas.\n *\n * It provides the following:\n *\n *   * emits life cycle events, namespaced with a prefix assigned\n *     during dragging activation\n *   * sets and restores the cursor\n *   * sets and restores the selection if elements still exist\n *   * ensures there can be only one drag operation active at a time\n *\n * Dragging may be canceled manually by calling {@link Dragging#cancel}\n * or by pressing ESC.\n *\n *\n * ## Life-cycle events\n *\n * Dragging can be in three different states, off, initialized\n * and active.\n *\n * (1) off: no dragging operation is in progress\n * (2) initialized: a new drag operation got initialized but not yet\n *                  started (i.e. because of no initial move)\n * (3) started: dragging is in progress\n *\n * Eventually dragging will be off again after a drag operation has\n * been ended or canceled via user click or ESC key press.\n *\n * To indicate transitions between these states dragging emits generic\n * life-cycle events with the `drag.` prefix _and_ events namespaced\n * to a prefix choosen by a user during drag initialization.\n *\n * The following events are emitted (appropriately prefixed) via\n * the {@link EventBus}.\n *\n * * `init`\n * * `start`\n * * `move`\n * * `end`\n * * `ended` (dragging already in off state)\n * * `cancel` (only if previously started)\n * * `canceled` (dragging already in off state, only if previously started)\n * * `cleanup`\n *\n *\n * @example\n *\n * ```javascript\n * function MyDragComponent(eventBus, dragging) {\n *\n *   eventBus.on('mydrag.start', function(event) {\n *     console.log('yes, we start dragging');\n *   });\n *\n *   eventBus.on('mydrag.move', function(event) {\n *     console.log('canvas local coordinates', event.x, event.y, event.dx, event.dy);\n *\n *     // local drag data is passed with the event\n *     event.context.foo; // \"BAR\"\n *\n *     // the original mouse event, too\n *     event.originalEvent; // MouseEvent(...)\n *   });\n *\n *   eventBus.on('element.click', function(event) {\n *     dragging.init(event, 'mydrag', {\n *       cursor: 'grabbing',\n *       data: {\n *         context: {\n *           foo: \"BAR\"\n *         }\n *       }\n *     });\n *   });\n * }\n * ```\n *\n * @param {EventBus} eventBus\n * @param {Canvas} canvas\n * @param {Selection} selection\n * @param {ElementRegistry} elementRegistry\n */\nexport default function Dragging(eventBus, canvas, selection, elementRegistry) {\n  var defaultOptions = {\n    threshold: 5,\n    trapClick: true\n  };\n\n  // the currently active drag operation\n  // dragging is active as soon as this context exists.\n  //\n  // it is visually _active_ only when a context.active flag is set to true.\n  var context;\n\n  /* convert a global event into local coordinates */\n  function toLocalPoint(globalPosition) {\n    var viewbox = canvas.viewbox();\n    var clientRect = canvas._container.getBoundingClientRect();\n    return {\n      x: viewbox.x + (globalPosition.x - clientRect.left) / viewbox.scale,\n      y: viewbox.y + (globalPosition.y - clientRect.top) / viewbox.scale\n    };\n  }\n\n  // helpers\n\n  function fire(type, dragContext) {\n    dragContext = dragContext || context;\n    var event = eventBus.createEvent(assign({}, dragContext.payload, dragContext.data, {\n      isTouch: dragContext.isTouch\n    }));\n\n    // default integration\n    if (eventBus.fire('drag.' + type, event) === false) {\n      return false;\n    }\n    return eventBus.fire(dragContext.prefix + '.' + type, event);\n  }\n  function restoreSelection(previousSelection) {\n    var existingSelection = previousSelection.filter(function (element) {\n      return elementRegistry.get(element.id);\n    });\n    existingSelection.length && selection.select(existingSelection);\n  }\n\n  // event listeners\n\n  function move(event, activate) {\n    var payload = context.payload,\n      displacement = context.displacement;\n    var globalStart = context.globalStart,\n      globalCurrent = toPoint(event),\n      globalDelta = deltaPos(globalCurrent, globalStart);\n    var localStart = context.localStart,\n      localCurrent = toLocalPoint(globalCurrent),\n      localDelta = deltaPos(localCurrent, localStart);\n\n    // activate context explicitly or once threshold is reached\n    if (!context.active && (activate || getLength(globalDelta) > context.threshold)) {\n      // fire start event with original\n      // starting coordinates\n\n      assign(payload, {\n        x: round(localStart.x + displacement.x),\n        y: round(localStart.y + displacement.y),\n        dx: 0,\n        dy: 0\n      }, {\n        originalEvent: event\n      });\n      if (false === fire('start')) {\n        return cancel();\n      }\n      context.active = true;\n\n      // unset selection and remember old selection\n      // the previous (old) selection will always passed\n      // with the event via the event.previousSelection property\n      if (!context.keepSelection) {\n        payload.previousSelection = selection.get();\n        selection.select(null);\n      }\n\n      // allow custom cursor\n      if (context.cursor) {\n        cursorSet(context.cursor);\n      }\n\n      // indicate dragging via marker on root element\n      canvas.addMarker(canvas.getRootElement(), DRAG_ACTIVE_CLS);\n    }\n    stopPropagation(event);\n    if (context.active) {\n      // update payload with actual coordinates\n      assign(payload, {\n        x: round(localCurrent.x + displacement.x),\n        y: round(localCurrent.y + displacement.y),\n        dx: round(localDelta.x),\n        dy: round(localDelta.y)\n      }, {\n        originalEvent: event\n      });\n\n      // emit move event\n      fire('move');\n    }\n  }\n  function end(event) {\n    var previousContext,\n      returnValue = true;\n    if (context.active) {\n      if (event) {\n        context.payload.originalEvent = event;\n\n        // suppress original event (click, ...)\n        // because we just ended a drag operation\n        stopPropagation(event);\n      }\n\n      // implementations may stop restoring the\n      // original state (selections, ...) by preventing the\n      // end events default action\n      returnValue = fire('end');\n    }\n    if (returnValue === false) {\n      fire('rejected');\n    }\n    previousContext = cleanup(returnValue !== true);\n\n    // last event to be fired when all drag operations are done\n    // at this point in time no drag operation is in progress anymore\n    fire('ended', previousContext);\n  }\n\n  // cancel active drag operation if the user presses\n  // the ESC key on the keyboard\n\n  function checkCancel(event) {\n    if (isKey('Escape', event)) {\n      preventDefault(event);\n      cancel();\n    }\n  }\n\n  // prevent ghost click that might occur after a finished\n  // drag and drop session\n\n  function trapClickAndEnd(event) {\n    var untrap;\n\n    // trap the click in case we are part of an active\n    // drag operation. This will effectively prevent\n    // the ghost click that cannot be canceled otherwise.\n    if (context.active) {\n      untrap = installClickTrap(eventBus);\n\n      // remove trap after minimal delay\n      setTimeout(untrap, 400);\n\n      // prevent default action (click)\n      preventDefault(event);\n    }\n    end(event);\n  }\n  function trapTouch(event) {\n    move(event);\n  }\n\n  // update the drag events model element (`hover`) and graphical element (`hoverGfx`)\n  // properties during hover and out and fire {prefix}.hover and {prefix}.out properties\n  // respectively\n\n  function hover(event) {\n    var payload = context.payload;\n    payload.hoverGfx = event.gfx;\n    payload.hover = event.element;\n    fire('hover');\n  }\n  function out(event) {\n    fire('out');\n    var payload = context.payload;\n    payload.hoverGfx = null;\n    payload.hover = null;\n  }\n\n  // life-cycle methods\n\n  function cancel(restore) {\n    var previousContext;\n    if (!context) {\n      return;\n    }\n    var wasActive = context.active;\n    if (wasActive) {\n      fire('cancel');\n    }\n    previousContext = cleanup(restore);\n    if (wasActive) {\n      // last event to be fired when all drag operations are done\n      // at this point in time no drag operation is in progress anymore\n      fire('canceled', previousContext);\n    }\n  }\n  function cleanup(restore) {\n    var previousContext, endDrag;\n    fire('cleanup');\n\n    // reset cursor\n    cursorUnset();\n    if (context.trapClick) {\n      endDrag = trapClickAndEnd;\n    } else {\n      endDrag = end;\n    }\n\n    // reset dom listeners\n    domEvent.unbind(document, 'mousemove', move);\n    domEvent.unbind(document, 'dragstart', preventDefault);\n    domEvent.unbind(document, 'selectstart', preventDefault);\n    domEvent.unbind(document, 'mousedown', endDrag, true);\n    domEvent.unbind(document, 'mouseup', endDrag, true);\n    domEvent.unbind(document, 'keyup', checkCancel);\n    domEvent.unbind(document, 'touchstart', trapTouch, true);\n    domEvent.unbind(document, 'touchcancel', cancel, true);\n    domEvent.unbind(document, 'touchmove', move, true);\n    domEvent.unbind(document, 'touchend', end, true);\n    eventBus.off('element.hover', hover);\n    eventBus.off('element.out', out);\n\n    // remove drag marker on root element\n    canvas.removeMarker(canvas.getRootElement(), DRAG_ACTIVE_CLS);\n\n    // restore selection, unless it has changed\n    var previousSelection = context.payload.previousSelection;\n    if (restore !== false && previousSelection && !selection.get().length) {\n      restoreSelection(previousSelection);\n    }\n    previousContext = context;\n    context = null;\n    return previousContext;\n  }\n\n  /**\n   * Initialize a drag operation.\n   *\n   * If `localPosition` is given, drag events will be emitted\n   * relative to it.\n   *\n   * @param {MouseEvent|TouchEvent} [event]\n   * @param {Point} [relativeTo] actual diagram local position this drag operation should start at\n   * @param {string} prefix\n   * @param {Object} [options]\n   */\n  function init(event, relativeTo, prefix, options) {\n    // only one drag operation may be active, at a time\n    if (context) {\n      cancel(false);\n    }\n    if (typeof relativeTo === 'string') {\n      options = prefix;\n      prefix = relativeTo;\n      relativeTo = null;\n    }\n    options = assign({}, defaultOptions, options || {});\n    var data = options.data || {},\n      originalEvent,\n      globalStart,\n      localStart,\n      endDrag,\n      isTouch;\n    if (options.trapClick) {\n      endDrag = trapClickAndEnd;\n    } else {\n      endDrag = end;\n    }\n    if (event) {\n      originalEvent = getOriginal(event) || event;\n      globalStart = toPoint(event);\n      stopPropagation(event);\n\n      // prevent default browser dragging behavior\n      if (originalEvent.type === 'dragstart') {\n        preventDefault(originalEvent);\n      }\n    } else {\n      originalEvent = null;\n      globalStart = {\n        x: 0,\n        y: 0\n      };\n    }\n    localStart = toLocalPoint(globalStart);\n    if (!relativeTo) {\n      relativeTo = localStart;\n    }\n    isTouch = isTouchEvent(originalEvent);\n    context = assign({\n      prefix: prefix,\n      data: data,\n      payload: {},\n      globalStart: globalStart,\n      displacement: deltaPos(relativeTo, localStart),\n      localStart: localStart,\n      isTouch: isTouch\n    }, options);\n\n    // skip dom registration if trigger\n    // is set to manual (during testing)\n    if (!options.manual) {\n      // add dom listeners\n\n      if (isTouch) {\n        domEvent.bind(document, 'touchstart', trapTouch, true);\n        domEvent.bind(document, 'touchcancel', cancel, true);\n        domEvent.bind(document, 'touchmove', move, true);\n        domEvent.bind(document, 'touchend', end, true);\n      } else {\n        // assume we use the mouse to interact per default\n        domEvent.bind(document, 'mousemove', move);\n\n        // prevent default browser drag and text selection behavior\n        domEvent.bind(document, 'dragstart', preventDefault);\n        domEvent.bind(document, 'selectstart', preventDefault);\n        domEvent.bind(document, 'mousedown', endDrag, true);\n        domEvent.bind(document, 'mouseup', endDrag, true);\n      }\n      domEvent.bind(document, 'keyup', checkCancel);\n      eventBus.on('element.hover', hover);\n      eventBus.on('element.out', out);\n    }\n    fire('init');\n    if (options.autoActivate) {\n      move(event, true);\n    }\n  }\n\n  // cancel on diagram destruction\n  eventBus.on('diagram.destroy', cancel);\n\n  // API\n\n  this.init = init;\n  this.move = move;\n  this.hover = hover;\n  this.out = out;\n  this.end = end;\n  this.cancel = cancel;\n\n  // for introspection\n\n  this.context = function () {\n    return context;\n  };\n  this.setOptions = function (options) {\n    assign(defaultOptions, options);\n  };\n}\nDragging.$inject = ['eventBus', 'canvas', 'selection', 'elementRegistry'];","map":{"version":3,"names":["round","Math","assign","event","domEvent","getOriginal","toPoint","stopPropagation","set","cursorSet","unset","cursorUnset","install","installClickTrap","delta","deltaPos","isKey","DRAG_ACTIVE_CLS","preventDefault","isTouchEvent","TouchEvent","getLength","point","sqrt","pow","x","y","Dragging","eventBus","canvas","selection","elementRegistry","defaultOptions","threshold","trapClick","context","toLocalPoint","globalPosition","viewbox","clientRect","_container","getBoundingClientRect","left","scale","top","fire","type","dragContext","createEvent","payload","data","isTouch","prefix","restoreSelection","previousSelection","existingSelection","filter","element","get","id","length","select","move","activate","displacement","globalStart","globalCurrent","globalDelta","localStart","localCurrent","localDelta","active","dx","dy","originalEvent","cancel","keepSelection","cursor","addMarker","getRootElement","end","previousContext","returnValue","cleanup","checkCancel","trapClickAndEnd","untrap","setTimeout","trapTouch","hover","hoverGfx","gfx","out","restore","wasActive","endDrag","unbind","document","off","removeMarker","init","relativeTo","options","manual","bind","on","autoActivate","setOptions","$inject"],"sources":["/home/runner/work/sgex/sgex/node_modules/diagram-js/lib/features/dragging/Dragging.js"],"sourcesContent":["var round = Math.round;\n\nimport { assign } from 'min-dash';\n\nimport {\n  event as domEvent\n} from 'min-dom';\n\nimport {\n  getOriginal,\n  toPoint,\n  stopPropagation\n} from '../../util/Event';\n\nimport {\n  set as cursorSet,\n  unset as cursorUnset\n} from '../../util/Cursor';\n\nimport {\n  install as installClickTrap\n} from '../../util/ClickTrap';\n\nimport {\n  delta as deltaPos\n} from '../../util/PositionUtil';\n\nimport { isKey } from '../keyboard/KeyboardUtil';\n\n/**\n * @typedef {import('../../util/Types').Point} Point\n *\n * @typedef {import('../../core/Canvas').default} Canvas\n * @typedef {import('../../core/ElementRegistry').default} ElementRegistry\n * @typedef {import('../../core/EventBus').default} EventBus\n * @typedef {import('../selection/Selection').default} Selection\n */\n\nvar DRAG_ACTIVE_CLS = 'djs-drag-active';\n\n\nfunction preventDefault(event) {\n  event.preventDefault();\n}\n\nfunction isTouchEvent(event) {\n\n  // check for TouchEvent being available first\n  // (i.e. not available on desktop Firefox)\n  return typeof TouchEvent !== 'undefined' && event instanceof TouchEvent;\n}\n\nfunction getLength(point) {\n  return Math.sqrt(Math.pow(point.x, 2) + Math.pow(point.y, 2));\n}\n\n/**\n * A helper that fires canvas localized drag events and realizes\n * the general \"drag-and-drop\" look and feel.\n *\n * Calling {@link Dragging#activate} activates dragging on a canvas.\n *\n * It provides the following:\n *\n *   * emits life cycle events, namespaced with a prefix assigned\n *     during dragging activation\n *   * sets and restores the cursor\n *   * sets and restores the selection if elements still exist\n *   * ensures there can be only one drag operation active at a time\n *\n * Dragging may be canceled manually by calling {@link Dragging#cancel}\n * or by pressing ESC.\n *\n *\n * ## Life-cycle events\n *\n * Dragging can be in three different states, off, initialized\n * and active.\n *\n * (1) off: no dragging operation is in progress\n * (2) initialized: a new drag operation got initialized but not yet\n *                  started (i.e. because of no initial move)\n * (3) started: dragging is in progress\n *\n * Eventually dragging will be off again after a drag operation has\n * been ended or canceled via user click or ESC key press.\n *\n * To indicate transitions between these states dragging emits generic\n * life-cycle events with the `drag.` prefix _and_ events namespaced\n * to a prefix choosen by a user during drag initialization.\n *\n * The following events are emitted (appropriately prefixed) via\n * the {@link EventBus}.\n *\n * * `init`\n * * `start`\n * * `move`\n * * `end`\n * * `ended` (dragging already in off state)\n * * `cancel` (only if previously started)\n * * `canceled` (dragging already in off state, only if previously started)\n * * `cleanup`\n *\n *\n * @example\n *\n * ```javascript\n * function MyDragComponent(eventBus, dragging) {\n *\n *   eventBus.on('mydrag.start', function(event) {\n *     console.log('yes, we start dragging');\n *   });\n *\n *   eventBus.on('mydrag.move', function(event) {\n *     console.log('canvas local coordinates', event.x, event.y, event.dx, event.dy);\n *\n *     // local drag data is passed with the event\n *     event.context.foo; // \"BAR\"\n *\n *     // the original mouse event, too\n *     event.originalEvent; // MouseEvent(...)\n *   });\n *\n *   eventBus.on('element.click', function(event) {\n *     dragging.init(event, 'mydrag', {\n *       cursor: 'grabbing',\n *       data: {\n *         context: {\n *           foo: \"BAR\"\n *         }\n *       }\n *     });\n *   });\n * }\n * ```\n *\n * @param {EventBus} eventBus\n * @param {Canvas} canvas\n * @param {Selection} selection\n * @param {ElementRegistry} elementRegistry\n */\nexport default function Dragging(eventBus, canvas, selection, elementRegistry) {\n\n  var defaultOptions = {\n    threshold: 5,\n    trapClick: true\n  };\n\n  // the currently active drag operation\n  // dragging is active as soon as this context exists.\n  //\n  // it is visually _active_ only when a context.active flag is set to true.\n  var context;\n\n  /* convert a global event into local coordinates */\n  function toLocalPoint(globalPosition) {\n\n    var viewbox = canvas.viewbox();\n\n    var clientRect = canvas._container.getBoundingClientRect();\n\n    return {\n      x: viewbox.x + (globalPosition.x - clientRect.left) / viewbox.scale,\n      y: viewbox.y + (globalPosition.y - clientRect.top) / viewbox.scale\n    };\n  }\n\n  // helpers\n\n  function fire(type, dragContext) {\n    dragContext = dragContext || context;\n\n    var event = eventBus.createEvent(\n      assign(\n        {},\n        dragContext.payload,\n        dragContext.data,\n        { isTouch: dragContext.isTouch }\n      )\n    );\n\n    // default integration\n    if (eventBus.fire('drag.' + type, event) === false) {\n      return false;\n    }\n\n    return eventBus.fire(dragContext.prefix + '.' + type, event);\n  }\n\n  function restoreSelection(previousSelection) {\n    var existingSelection = previousSelection.filter(function(element) {\n      return elementRegistry.get(element.id);\n    });\n\n    existingSelection.length && selection.select(existingSelection);\n  }\n\n  // event listeners\n\n  function move(event, activate) {\n    var payload = context.payload,\n        displacement = context.displacement;\n\n    var globalStart = context.globalStart,\n        globalCurrent = toPoint(event),\n        globalDelta = deltaPos(globalCurrent, globalStart);\n\n    var localStart = context.localStart,\n        localCurrent = toLocalPoint(globalCurrent),\n        localDelta = deltaPos(localCurrent, localStart);\n\n\n    // activate context explicitly or once threshold is reached\n    if (!context.active && (activate || getLength(globalDelta) > context.threshold)) {\n\n      // fire start event with original\n      // starting coordinates\n\n      assign(payload, {\n        x: round(localStart.x + displacement.x),\n        y: round(localStart.y + displacement.y),\n        dx: 0,\n        dy: 0\n      }, { originalEvent: event });\n\n      if (false === fire('start')) {\n        return cancel();\n      }\n\n      context.active = true;\n\n      // unset selection and remember old selection\n      // the previous (old) selection will always passed\n      // with the event via the event.previousSelection property\n      if (!context.keepSelection) {\n        payload.previousSelection = selection.get();\n        selection.select(null);\n      }\n\n      // allow custom cursor\n      if (context.cursor) {\n        cursorSet(context.cursor);\n      }\n\n      // indicate dragging via marker on root element\n      canvas.addMarker(canvas.getRootElement(), DRAG_ACTIVE_CLS);\n    }\n\n    stopPropagation(event);\n\n    if (context.active) {\n\n      // update payload with actual coordinates\n      assign(payload, {\n        x: round(localCurrent.x + displacement.x),\n        y: round(localCurrent.y + displacement.y),\n        dx: round(localDelta.x),\n        dy: round(localDelta.y)\n      }, { originalEvent: event });\n\n      // emit move event\n      fire('move');\n    }\n  }\n\n  function end(event) {\n    var previousContext,\n        returnValue = true;\n\n    if (context.active) {\n\n      if (event) {\n        context.payload.originalEvent = event;\n\n        // suppress original event (click, ...)\n        // because we just ended a drag operation\n        stopPropagation(event);\n      }\n\n      // implementations may stop restoring the\n      // original state (selections, ...) by preventing the\n      // end events default action\n      returnValue = fire('end');\n    }\n\n    if (returnValue === false) {\n      fire('rejected');\n    }\n\n    previousContext = cleanup(returnValue !== true);\n\n    // last event to be fired when all drag operations are done\n    // at this point in time no drag operation is in progress anymore\n    fire('ended', previousContext);\n  }\n\n\n  // cancel active drag operation if the user presses\n  // the ESC key on the keyboard\n\n  function checkCancel(event) {\n\n    if (isKey('Escape', event)) {\n      preventDefault(event);\n\n      cancel();\n    }\n  }\n\n\n  // prevent ghost click that might occur after a finished\n  // drag and drop session\n\n  function trapClickAndEnd(event) {\n\n    var untrap;\n\n    // trap the click in case we are part of an active\n    // drag operation. This will effectively prevent\n    // the ghost click that cannot be canceled otherwise.\n    if (context.active) {\n\n      untrap = installClickTrap(eventBus);\n\n      // remove trap after minimal delay\n      setTimeout(untrap, 400);\n\n      // prevent default action (click)\n      preventDefault(event);\n    }\n\n    end(event);\n  }\n\n  function trapTouch(event) {\n    move(event);\n  }\n\n  // update the drag events model element (`hover`) and graphical element (`hoverGfx`)\n  // properties during hover and out and fire {prefix}.hover and {prefix}.out properties\n  // respectively\n\n  function hover(event) {\n    var payload = context.payload;\n\n    payload.hoverGfx = event.gfx;\n    payload.hover = event.element;\n\n    fire('hover');\n  }\n\n  function out(event) {\n    fire('out');\n\n    var payload = context.payload;\n\n    payload.hoverGfx = null;\n    payload.hover = null;\n  }\n\n\n  // life-cycle methods\n\n  function cancel(restore) {\n    var previousContext;\n\n    if (!context) {\n      return;\n    }\n\n    var wasActive = context.active;\n\n    if (wasActive) {\n      fire('cancel');\n    }\n\n    previousContext = cleanup(restore);\n\n    if (wasActive) {\n\n      // last event to be fired when all drag operations are done\n      // at this point in time no drag operation is in progress anymore\n      fire('canceled', previousContext);\n    }\n  }\n\n  function cleanup(restore) {\n    var previousContext,\n        endDrag;\n\n    fire('cleanup');\n\n    // reset cursor\n    cursorUnset();\n\n    if (context.trapClick) {\n      endDrag = trapClickAndEnd;\n    } else {\n      endDrag = end;\n    }\n\n    // reset dom listeners\n    domEvent.unbind(document, 'mousemove', move);\n\n    domEvent.unbind(document, 'dragstart', preventDefault);\n    domEvent.unbind(document, 'selectstart', preventDefault);\n\n    domEvent.unbind(document, 'mousedown', endDrag, true);\n    domEvent.unbind(document, 'mouseup', endDrag, true);\n\n    domEvent.unbind(document, 'keyup', checkCancel);\n\n    domEvent.unbind(document, 'touchstart', trapTouch, true);\n    domEvent.unbind(document, 'touchcancel', cancel, true);\n    domEvent.unbind(document, 'touchmove', move, true);\n    domEvent.unbind(document, 'touchend', end, true);\n\n    eventBus.off('element.hover', hover);\n    eventBus.off('element.out', out);\n\n    // remove drag marker on root element\n    canvas.removeMarker(canvas.getRootElement(), DRAG_ACTIVE_CLS);\n\n    // restore selection, unless it has changed\n    var previousSelection = context.payload.previousSelection;\n\n    if (restore !== false && previousSelection && !selection.get().length) {\n      restoreSelection(previousSelection);\n    }\n\n    previousContext = context;\n\n    context = null;\n\n    return previousContext;\n  }\n\n  /**\n   * Initialize a drag operation.\n   *\n   * If `localPosition` is given, drag events will be emitted\n   * relative to it.\n   *\n   * @param {MouseEvent|TouchEvent} [event]\n   * @param {Point} [relativeTo] actual diagram local position this drag operation should start at\n   * @param {string} prefix\n   * @param {Object} [options]\n   */\n  function init(event, relativeTo, prefix, options) {\n\n    // only one drag operation may be active, at a time\n    if (context) {\n      cancel(false);\n    }\n\n    if (typeof relativeTo === 'string') {\n      options = prefix;\n      prefix = relativeTo;\n      relativeTo = null;\n    }\n\n    options = assign({}, defaultOptions, options || {});\n\n    var data = options.data || {},\n        originalEvent,\n        globalStart,\n        localStart,\n        endDrag,\n        isTouch;\n\n    if (options.trapClick) {\n      endDrag = trapClickAndEnd;\n    } else {\n      endDrag = end;\n    }\n\n    if (event) {\n      originalEvent = getOriginal(event) || event;\n      globalStart = toPoint(event);\n\n      stopPropagation(event);\n\n      // prevent default browser dragging behavior\n      if (originalEvent.type === 'dragstart') {\n        preventDefault(originalEvent);\n      }\n    } else {\n      originalEvent = null;\n      globalStart = { x: 0, y: 0 };\n    }\n\n    localStart = toLocalPoint(globalStart);\n\n    if (!relativeTo) {\n      relativeTo = localStart;\n    }\n\n    isTouch = isTouchEvent(originalEvent);\n\n    context = assign({\n      prefix: prefix,\n      data: data,\n      payload: {},\n      globalStart: globalStart,\n      displacement: deltaPos(relativeTo, localStart),\n      localStart: localStart,\n      isTouch: isTouch\n    }, options);\n\n    // skip dom registration if trigger\n    // is set to manual (during testing)\n    if (!options.manual) {\n\n      // add dom listeners\n\n      if (isTouch) {\n        domEvent.bind(document, 'touchstart', trapTouch, true);\n        domEvent.bind(document, 'touchcancel', cancel, true);\n        domEvent.bind(document, 'touchmove', move, true);\n        domEvent.bind(document, 'touchend', end, true);\n      } else {\n\n        // assume we use the mouse to interact per default\n        domEvent.bind(document, 'mousemove', move);\n\n        // prevent default browser drag and text selection behavior\n        domEvent.bind(document, 'dragstart', preventDefault);\n        domEvent.bind(document, 'selectstart', preventDefault);\n\n        domEvent.bind(document, 'mousedown', endDrag, true);\n        domEvent.bind(document, 'mouseup', endDrag, true);\n      }\n\n      domEvent.bind(document, 'keyup', checkCancel);\n\n      eventBus.on('element.hover', hover);\n      eventBus.on('element.out', out);\n    }\n\n    fire('init');\n\n    if (options.autoActivate) {\n      move(event, true);\n    }\n  }\n\n  // cancel on diagram destruction\n  eventBus.on('diagram.destroy', cancel);\n\n\n  // API\n\n  this.init = init;\n  this.move = move;\n  this.hover = hover;\n  this.out = out;\n  this.end = end;\n\n  this.cancel = cancel;\n\n  // for introspection\n\n  this.context = function() {\n    return context;\n  };\n\n  this.setOptions = function(options) {\n    assign(defaultOptions, options);\n  };\n}\n\nDragging.$inject = [\n  'eventBus',\n  'canvas',\n  'selection',\n  'elementRegistry'\n];\n"],"mappings":"AAAA,IAAIA,KAAK,GAAGC,IAAI,CAACD,KAAK;AAEtB,SAASE,MAAM,QAAQ,UAAU;AAEjC,SACEC,KAAK,IAAIC,QAAQ,QACZ,SAAS;AAEhB,SACEC,WAAW,EACXC,OAAO,EACPC,eAAe,QACV,kBAAkB;AAEzB,SACEC,GAAG,IAAIC,SAAS,EAChBC,KAAK,IAAIC,WAAW,QACf,mBAAmB;AAE1B,SACEC,OAAO,IAAIC,gBAAgB,QACtB,sBAAsB;AAE7B,SACEC,KAAK,IAAIC,QAAQ,QACZ,yBAAyB;AAEhC,SAASC,KAAK,QAAQ,0BAA0B;;AAEhD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,IAAIC,eAAe,GAAG,iBAAiB;AAGvC,SAASC,cAAcA,CAACf,KAAK,EAAE;EAC7BA,KAAK,CAACe,cAAc,CAAC,CAAC;AACxB;AAEA,SAASC,YAAYA,CAAChB,KAAK,EAAE;EAE3B;EACA;EACA,OAAO,OAAOiB,UAAU,KAAK,WAAW,IAAIjB,KAAK,YAAYiB,UAAU;AACzE;AAEA,SAASC,SAASA,CAACC,KAAK,EAAE;EACxB,OAAOrB,IAAI,CAACsB,IAAI,CAACtB,IAAI,CAACuB,GAAG,CAACF,KAAK,CAACG,CAAC,EAAE,CAAC,CAAC,GAAGxB,IAAI,CAACuB,GAAG,CAACF,KAAK,CAACI,CAAC,EAAE,CAAC,CAAC,CAAC;AAC/D;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAC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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}