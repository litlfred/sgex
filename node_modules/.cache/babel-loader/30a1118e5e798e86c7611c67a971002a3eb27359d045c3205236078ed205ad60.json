{"ast":null,"code":"import { assign, filter, groupBy, isObject } from 'min-dash';\nimport { classes as svgClasses } from 'tiny-svg';\n\n/**\n * @typedef {import('../../core/Types').ElementLike} Element\n * @typedef {import('../../core/Types').ShapeLike} Shape\n *\n * @typedef {import('../dragging/Dragging').default} Dragging\n * @typedef {import('../../core/EventBus').default} EventBus\n * @typedef {import('../modeling/Modeling').default} Modeling\n * @typedef {import('../rules/Rules').default} Rules\n * @typedef {import('../selection/Selection').default} Selection\n */\n\nvar LOW_PRIORITY = 500,\n  MEDIUM_PRIORITY = 1250,\n  HIGH_PRIORITY = 1500;\nimport { getOriginal as getOriginalEvent } from '../../util/Event';\nimport { isPrimaryButton } from '../../util/Mouse';\nvar round = Math.round;\nfunction mid(element) {\n  return {\n    x: element.x + round(element.width / 2),\n    y: element.y + round(element.height / 2)\n  };\n}\n\n/**\n * A plugin that makes shapes draggable / droppable.\n *\n * @param {EventBus} eventBus\n * @param {Dragging} dragging\n * @param {Modeling} modeling\n * @param {Selection} selection\n * @param {Rules} rules\n */\nexport default function MoveEvents(eventBus, dragging, modeling, selection, rules) {\n  // rules\n\n  function canMove(shapes, delta, position, target) {\n    return rules.allowed('elements.move', {\n      shapes: shapes,\n      delta: delta,\n      position: position,\n      target: target\n    });\n  }\n\n  // move events\n\n  // assign a high priority to this handler to setup the environment\n  // others may hook up later, e.g. at default priority and modify\n  // the move environment.\n  //\n  // This sets up the context with\n  //\n  // * shape: the primary shape being moved\n  // * shapes: a list of shapes to be moved\n  // * validatedShapes: a list of shapes that are being checked\n  //                    against the rules before and during move\n  //\n  eventBus.on('shape.move.start', HIGH_PRIORITY, function (event) {\n    var context = event.context,\n      shape = event.shape,\n      shapes = selection.get().slice();\n\n    // move only single shape if the dragged element\n    // is not part of the current selection\n    if (shapes.indexOf(shape) === -1) {\n      shapes = [shape];\n    }\n\n    // ensure we remove nested elements in the collection\n    // and add attachers for a proper dragger\n    shapes = removeNested(shapes);\n\n    // attach shapes to drag context\n    assign(context, {\n      shapes: shapes,\n      validatedShapes: shapes,\n      shape: shape\n    });\n  });\n\n  // assign a high priority to this handler to setup the environment\n  // others may hook up later, e.g. at default priority and modify\n  // the move environment\n  //\n  eventBus.on('shape.move.start', MEDIUM_PRIORITY, function (event) {\n    var context = event.context,\n      validatedShapes = context.validatedShapes,\n      canExecute;\n    canExecute = context.canExecute = canMove(validatedShapes);\n\n    // check if we can move the elements\n    if (!canExecute) {\n      return false;\n    }\n  });\n\n  // assign a low priority to this handler\n  // to let others modify the move event before we update\n  // the context\n  //\n  eventBus.on('shape.move.move', LOW_PRIORITY, function (event) {\n    var context = event.context,\n      validatedShapes = context.validatedShapes,\n      hover = event.hover,\n      delta = {\n        x: event.dx,\n        y: event.dy\n      },\n      position = {\n        x: event.x,\n        y: event.y\n      },\n      canExecute;\n\n    // check if we can move the elements\n    canExecute = canMove(validatedShapes, delta, position, hover);\n    context.delta = delta;\n    context.canExecute = canExecute;\n\n    // simply ignore move over\n    if (canExecute === null) {\n      context.target = null;\n      return;\n    }\n    context.target = hover;\n  });\n  eventBus.on('shape.move.end', function (event) {\n    var context = event.context;\n    var delta = context.delta,\n      canExecute = context.canExecute,\n      isAttach = canExecute === 'attach',\n      shapes = context.shapes;\n    if (canExecute === false) {\n      return false;\n    }\n\n    // ensure we have actual pixel values deltas\n    // (important when zoom level was > 1 during move)\n    delta.x = round(delta.x);\n    delta.y = round(delta.y);\n    if (delta.x === 0 && delta.y === 0) {\n      // didn't move\n      return;\n    }\n    modeling.moveElements(shapes, delta, context.target, {\n      primaryShape: context.shape,\n      attach: isAttach\n    });\n  });\n\n  // move activation\n\n  eventBus.on('element.mousedown', function (event) {\n    if (!isPrimaryButton(event)) {\n      return;\n    }\n    var originalEvent = getOriginalEvent(event);\n    if (!originalEvent) {\n      throw new Error('must supply DOM mousedown event');\n    }\n    return start(originalEvent, event.element);\n  });\n\n  /**\n   * Start move.\n   *\n   * @param {MouseEvent|TouchEvent} event\n   * @param {Shape} element\n   * @param {boolean} [activate]\n   * @param {Object} [context]\n   */\n  function start(event, element, activate, context) {\n    if (isObject(activate)) {\n      context = activate;\n      activate = false;\n    }\n\n    // do not move connections or the root element\n    if (element.waypoints || !element.parent) {\n      return;\n    }\n\n    // ignore non-draggable hits\n    if (svgClasses(event.target).has('djs-hit-no-move')) {\n      return;\n    }\n    var referencePoint = mid(element);\n    dragging.init(event, referencePoint, 'shape.move', {\n      cursor: 'grabbing',\n      autoActivate: activate,\n      data: {\n        shape: element,\n        context: context || {}\n      }\n    });\n\n    // we've handled the event\n    return true;\n  }\n\n  // API\n\n  this.start = start;\n}\nMoveEvents.$inject = ['eventBus', 'dragging', 'modeling', 'selection', 'rules'];\n\n/**\n * Return a filtered list of elements that do not contain\n * those nested into others.\n *\n * @param {Element[]} elements\n *\n * @return {Element[]} filtered\n */\nfunction removeNested(elements) {\n  var ids = groupBy(elements, 'id');\n  return filter(elements, function (element) {\n    while (element = element.parent) {\n      // parent in selection\n      if (ids[element.id]) {\n        return false;\n      }\n    }\n    return true;\n  });\n}","map":{"version":3,"names":["assign","filter","groupBy","isObject","classes","svgClasses","LOW_PRIORITY","MEDIUM_PRIORITY","HIGH_PRIORITY","getOriginal","getOriginalEvent","isPrimaryButton","round","Math","mid","element","x","width","y","height","MoveEvents","eventBus","dragging","modeling","selection","rules","canMove","shapes","delta","position","target","allowed","on","event","context","shape","get","slice","indexOf","removeNested","validatedShapes","canExecute","hover","dx","dy","isAttach","moveElements","primaryShape","attach","originalEvent","Error","start","activate","waypoints","parent","has","referencePoint","init","cursor","autoActivate","data","$inject","elements","ids","id"],"sources":["/home/runner/work/sgex/sgex/node_modules/diagram-js/lib/features/move/Move.js"],"sourcesContent":["import {\n  assign,\n  filter,\n  groupBy,\n  isObject\n} from 'min-dash';\n\nimport {\n  classes as svgClasses\n} from 'tiny-svg';\n\n/**\n * @typedef {import('../../core/Types').ElementLike} Element\n * @typedef {import('../../core/Types').ShapeLike} Shape\n *\n * @typedef {import('../dragging/Dragging').default} Dragging\n * @typedef {import('../../core/EventBus').default} EventBus\n * @typedef {import('../modeling/Modeling').default} Modeling\n * @typedef {import('../rules/Rules').default} Rules\n * @typedef {import('../selection/Selection').default} Selection\n */\n\nvar LOW_PRIORITY = 500,\n    MEDIUM_PRIORITY = 1250,\n    HIGH_PRIORITY = 1500;\n\nimport { getOriginal as getOriginalEvent } from '../../util/Event';\n\nimport {\n  isPrimaryButton\n} from '../../util/Mouse';\n\nvar round = Math.round;\n\nfunction mid(element) {\n  return {\n    x: element.x + round(element.width / 2),\n    y: element.y + round(element.height / 2)\n  };\n}\n\n/**\n * A plugin that makes shapes draggable / droppable.\n *\n * @param {EventBus} eventBus\n * @param {Dragging} dragging\n * @param {Modeling} modeling\n * @param {Selection} selection\n * @param {Rules} rules\n */\nexport default function MoveEvents(\n    eventBus, dragging, modeling,\n    selection, rules) {\n\n  // rules\n\n  function canMove(shapes, delta, position, target) {\n\n    return rules.allowed('elements.move', {\n      shapes: shapes,\n      delta: delta,\n      position: position,\n      target: target\n    });\n  }\n\n\n  // move events\n\n  // assign a high priority to this handler to setup the environment\n  // others may hook up later, e.g. at default priority and modify\n  // the move environment.\n  //\n  // This sets up the context with\n  //\n  // * shape: the primary shape being moved\n  // * shapes: a list of shapes to be moved\n  // * validatedShapes: a list of shapes that are being checked\n  //                    against the rules before and during move\n  //\n  eventBus.on('shape.move.start', HIGH_PRIORITY, function(event) {\n\n    var context = event.context,\n        shape = event.shape,\n        shapes = selection.get().slice();\n\n    // move only single shape if the dragged element\n    // is not part of the current selection\n    if (shapes.indexOf(shape) === -1) {\n      shapes = [ shape ];\n    }\n\n    // ensure we remove nested elements in the collection\n    // and add attachers for a proper dragger\n    shapes = removeNested(shapes);\n\n    // attach shapes to drag context\n    assign(context, {\n      shapes: shapes,\n      validatedShapes: shapes,\n      shape: shape\n    });\n  });\n\n\n  // assign a high priority to this handler to setup the environment\n  // others may hook up later, e.g. at default priority and modify\n  // the move environment\n  //\n  eventBus.on('shape.move.start', MEDIUM_PRIORITY, function(event) {\n\n    var context = event.context,\n        validatedShapes = context.validatedShapes,\n        canExecute;\n\n    canExecute = context.canExecute = canMove(validatedShapes);\n\n    // check if we can move the elements\n    if (!canExecute) {\n      return false;\n    }\n  });\n\n  // assign a low priority to this handler\n  // to let others modify the move event before we update\n  // the context\n  //\n  eventBus.on('shape.move.move', LOW_PRIORITY, function(event) {\n\n    var context = event.context,\n        validatedShapes = context.validatedShapes,\n        hover = event.hover,\n        delta = { x: event.dx, y: event.dy },\n        position = { x: event.x, y: event.y },\n        canExecute;\n\n    // check if we can move the elements\n    canExecute = canMove(validatedShapes, delta, position, hover);\n\n    context.delta = delta;\n    context.canExecute = canExecute;\n\n    // simply ignore move over\n    if (canExecute === null) {\n      context.target = null;\n\n      return;\n    }\n\n    context.target = hover;\n  });\n\n  eventBus.on('shape.move.end', function(event) {\n\n    var context = event.context;\n\n    var delta = context.delta,\n        canExecute = context.canExecute,\n        isAttach = canExecute === 'attach',\n        shapes = context.shapes;\n\n    if (canExecute === false) {\n      return false;\n    }\n\n    // ensure we have actual pixel values deltas\n    // (important when zoom level was > 1 during move)\n    delta.x = round(delta.x);\n    delta.y = round(delta.y);\n\n    if (delta.x === 0 && delta.y === 0) {\n\n      // didn't move\n      return;\n    }\n\n    modeling.moveElements(shapes, delta, context.target, {\n      primaryShape: context.shape,\n      attach: isAttach\n    });\n  });\n\n\n  // move activation\n\n  eventBus.on('element.mousedown', function(event) {\n\n    if (!isPrimaryButton(event)) {\n      return;\n    }\n\n    var originalEvent = getOriginalEvent(event);\n\n    if (!originalEvent) {\n      throw new Error('must supply DOM mousedown event');\n    }\n\n    return start(originalEvent, event.element);\n  });\n\n  /**\n   * Start move.\n   *\n   * @param {MouseEvent|TouchEvent} event\n   * @param {Shape} element\n   * @param {boolean} [activate]\n   * @param {Object} [context]\n   */\n  function start(event, element, activate, context) {\n    if (isObject(activate)) {\n      context = activate;\n      activate = false;\n    }\n\n    // do not move connections or the root element\n    if (element.waypoints || !element.parent) {\n      return;\n    }\n\n    // ignore non-draggable hits\n    if (svgClasses(event.target).has('djs-hit-no-move')) {\n      return;\n    }\n\n    var referencePoint = mid(element);\n\n    dragging.init(event, referencePoint, 'shape.move', {\n      cursor: 'grabbing',\n      autoActivate: activate,\n      data: {\n        shape: element,\n        context: context || {}\n      }\n    });\n\n    // we've handled the event\n    return true;\n  }\n\n  // API\n\n  this.start = start;\n}\n\nMoveEvents.$inject = [\n  'eventBus',\n  'dragging',\n  'modeling',\n  'selection',\n  'rules'\n];\n\n\n/**\n * Return a filtered list of elements that do not contain\n * those nested into others.\n *\n * @param {Element[]} elements\n *\n * @return {Element[]} filtered\n */\nfunction removeNested(elements) {\n\n  var ids = groupBy(elements, 'id');\n\n  return filter(elements, function(element) {\n    while ((element = element.parent)) {\n\n      // parent in selection\n      if (ids[element.id]) {\n        return false;\n      }\n    }\n\n    return true;\n  });\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}