{"ast":null,"code":"import { append as svgAppend, attr as svgAttr, classes as svgClasses, clone as svgClone, create as svgCreate } from 'tiny-svg';\nimport { query as domQuery } from 'min-dom';\nimport { getVisual } from '../../util/GraphicsUtil';\nimport Ids from '../../util/IdGenerator';\n\n/**\r\n * @typedef {import('../../core/Types').ElementLike} Element\r\n * @typedef {import('../../core/Types').ShapeLike} Shape\r\n *\r\n * @typedef {import('../../core/Canvas').default} Canvas\r\n * @typedef {import('../../core/ElementRegistry').default} ElementRegistry\r\n * @typedef {import('../../core/EventBus').default} EventBus\r\n * @typedef {import('../../draw/Styles').default} Styles\r\n */\n\nconst cloneIds = new Ids('ps');\nvar MARKER_TYPES = ['marker-start', 'marker-mid', 'marker-end'];\nvar NODES_CAN_HAVE_MARKER = ['circle', 'ellipse', 'line', 'path', 'polygon', 'polyline', 'path', 'rect'];\n\n/**\r\n * Adds support for previews of moving/resizing elements.\r\n *\r\n * @param {ElementRegistry} elementRegistry\r\n * @param {EventBus} eventBus\r\n * @param {Canvas} canvas\r\n * @param {Styles} styles\r\n */\nexport default function PreviewSupport(elementRegistry, eventBus, canvas, styles) {\n  this._elementRegistry = elementRegistry;\n  this._canvas = canvas;\n  this._styles = styles;\n}\nPreviewSupport.$inject = ['elementRegistry', 'eventBus', 'canvas', 'styles'];\n\n// Markers are cleaned up with visuals, keep stub for compatibility\n// cf. https://github.com/camunda/camunda-modeler/issues/4307\nPreviewSupport.prototype.cleanUp = function () {\n  console.warn('PreviewSupport#cleanUp is deprecated and will be removed in future versions. You do not need to manually clean up previews anymore. cf. https://github.com/bpmn-io/diagram-js/pull/906');\n};\n\n/**\r\n * Returns graphics of an element.\r\n *\r\n * @param {Element} element\r\n *\r\n * @return {SVGElement}\r\n */\nPreviewSupport.prototype.getGfx = function (element) {\n  return this._elementRegistry.getGraphics(element);\n};\n\n/**\r\n * Adds a move preview of a given shape to a given SVG group.\r\n *\r\n * @param {Element} element The element to be moved.\r\n * @param {SVGElement} group The SVG group to add the preview to.\r\n * @param {SVGElement} [gfx] The optional graphical element of the element.\r\n * @param {string} [className=\"djs-dragger\"] The optional class name to add to the preview.\r\n *\r\n * @return {SVGElement} The preview.\r\n */\nPreviewSupport.prototype.addDragger = function (element, group, gfx) {\n  let className = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 'djs-dragger';\n  gfx = gfx || this.getGfx(element);\n  var dragger = svgClone(gfx);\n  var bbox = gfx.getBoundingClientRect();\n  this._cloneMarkers(getVisual(dragger), className);\n  svgAttr(dragger, this._styles.cls(className, [], {\n    x: bbox.top,\n    y: bbox.left\n  }));\n  svgAppend(group, dragger);\n  svgAttr(dragger, 'data-preview-support-element-id', element.id);\n  return dragger;\n};\n\n/**\r\n * Adds a resize preview of a given shape to a given SVG group.\r\n *\r\n * @param {Shape} shape The element to be resized.\r\n * @param {SVGElement} group The SVG group to add the preview to.\r\n *\r\n * @return {SVGElement} The preview.\r\n */\nPreviewSupport.prototype.addFrame = function (shape, group) {\n  var frame = svgCreate('rect', {\n    class: 'djs-resize-overlay',\n    width: shape.width,\n    height: shape.height,\n    x: shape.x,\n    y: shape.y\n  });\n  svgAppend(group, frame);\n  svgAttr(frame, 'data-preview-support-element-id', shape.id);\n  return frame;\n};\n\n/**\r\n * Clone all markers referenced by a node and its child nodes.\r\n *\r\n * @param {SVGElement} gfx\r\n * @param {string} [className=\"djs-dragger\"]\r\n */\nPreviewSupport.prototype._cloneMarkers = function (gfx) {\n  let className = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'djs-dragger';\n  let rootGfx = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : gfx;\n  var self = this;\n  if (gfx.childNodes) {\n    gfx.childNodes.forEach(childNode => {\n      self._cloneMarkers(childNode, className, rootGfx);\n    });\n  }\n  if (!canHaveMarker(gfx)) {\n    return;\n  }\n  MARKER_TYPES.forEach(function (markerType) {\n    if (svgAttr(gfx, markerType)) {\n      var marker = getMarker(gfx, markerType, self._canvas.getContainer());\n\n      // Only clone marker if it is already present on the DOM\n      marker && self._cloneMarker(rootGfx, gfx, marker, markerType, className);\n    }\n  });\n};\n\n/**\r\n * Clone marker referenced by an element.\r\n *\r\n * @param {SVGElement} gfx\r\n * @param {SVGElement} marker\r\n * @param {string} markerType\r\n * @param {string} [className=\"djs-dragger\"]\r\n */\nPreviewSupport.prototype._cloneMarker = function (parentGfx, gfx, marker, markerType) {\n  let className = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 'djs-dragger';\n  // Add a random suffix to the marker ID in case the same marker is previewed multiple times\n  var clonedMarkerId = [marker.id, className, cloneIds.next()].join('-');\n\n  // reuse marker if it was part of original gfx\n  var copiedMarker = domQuery('marker#' + marker.id, parentGfx);\n  parentGfx = parentGfx || this._canvas._svg;\n  var clonedMarker = copiedMarker || svgClone(marker);\n  clonedMarker.id = clonedMarkerId;\n  svgClasses(clonedMarker).add(className);\n  var defs = domQuery(':scope > defs', parentGfx);\n  if (!defs) {\n    defs = svgCreate('defs');\n    svgAppend(parentGfx, defs);\n  }\n  svgAppend(defs, clonedMarker);\n  var reference = idToReference(clonedMarker.id);\n  svgAttr(gfx, markerType, reference);\n};\n\n// helpers //////////\n\n/**\r\n * Get marker of given type referenced by node.\r\n *\r\n * @param {HTMLElement} node\r\n * @param {string} markerType\r\n * @param {HTMLElement} [parentNode]\r\n *\r\n * @param {HTMLElement}\r\n */\nfunction getMarker(node, markerType, parentNode) {\n  var id = referenceToId(svgAttr(node, markerType));\n  return domQuery('marker#' + id, parentNode || document);\n}\n\n/**\r\n * Get ID of fragment within current document from its functional IRI reference.\r\n * References may use single or double quotes.\r\n *\r\n * @param {string} reference\r\n *\r\n * @return {string}\r\n */\nfunction referenceToId(reference) {\n  return reference.match(/url\\(['\"]?#([^'\"]*)['\"]?\\)/)[1];\n}\n\n/**\r\n * Get functional IRI reference for given ID of fragment within current document.\r\n *\r\n * @param {string} id\r\n *\r\n * @return {string}\r\n */\nfunction idToReference(id) {\n  return 'url(#' + id + ')';\n}\n\n/**\r\n * Check wether node type can have marker attributes.\r\n *\r\n * @param {HTMLElement} node\r\n *\r\n * @return {boolean}\r\n */\nfunction canHaveMarker(node) {\n  return NODES_CAN_HAVE_MARKER.indexOf(node.nodeName) !== -1;\n}","map":{"version":3,"names":["append","svgAppend","attr","svgAttr","classes","svgClasses","clone","svgClone","create","svgCreate","query","domQuery","getVisual","Ids","cloneIds","MARKER_TYPES","NODES_CAN_HAVE_MARKER","PreviewSupport","elementRegistry","eventBus","canvas","styles","_elementRegistry","_canvas","_styles","$inject","prototype","cleanUp","console","warn","getGfx","element","getGraphics","addDragger","group","gfx","className","arguments","length","undefined","dragger","bbox","getBoundingClientRect","_cloneMarkers","cls","x","top","y","left","id","addFrame","shape","frame","class","width","height","rootGfx","self","childNodes","forEach","childNode","canHaveMarker","markerType","marker","getMarker","getContainer","_cloneMarker","parentGfx","clonedMarkerId","next","join","copiedMarker","_svg","clonedMarker","add","defs","reference","idToReference","node","parentNode","referenceToId","document","match","indexOf","nodeName"],"sources":["/home/runner/work/sgex/sgex/node_modules/diagram-js/lib/features/preview-support/PreviewSupport.js"],"sourcesContent":["import {\r\n  append as svgAppend,\r\n  attr as svgAttr,\r\n  classes as svgClasses,\r\n  clone as svgClone,\r\n  create as svgCreate,\r\n} from 'tiny-svg';\r\n\r\nimport { query as domQuery } from 'min-dom';\r\n\r\nimport { getVisual } from '../../util/GraphicsUtil';\r\n\r\nimport Ids from '../../util/IdGenerator';\r\n\r\n/**\r\n * @typedef {import('../../core/Types').ElementLike} Element\r\n * @typedef {import('../../core/Types').ShapeLike} Shape\r\n *\r\n * @typedef {import('../../core/Canvas').default} Canvas\r\n * @typedef {import('../../core/ElementRegistry').default} ElementRegistry\r\n * @typedef {import('../../core/EventBus').default} EventBus\r\n * @typedef {import('../../draw/Styles').default} Styles\r\n */\r\n\r\nconst cloneIds = new Ids('ps');\r\n\r\nvar MARKER_TYPES = [\r\n  'marker-start',\r\n  'marker-mid',\r\n  'marker-end'\r\n];\r\n\r\nvar NODES_CAN_HAVE_MARKER = [\r\n  'circle',\r\n  'ellipse',\r\n  'line',\r\n  'path',\r\n  'polygon',\r\n  'polyline',\r\n  'path',\r\n  'rect'\r\n];\r\n\r\n\r\n/**\r\n * Adds support for previews of moving/resizing elements.\r\n *\r\n * @param {ElementRegistry} elementRegistry\r\n * @param {EventBus} eventBus\r\n * @param {Canvas} canvas\r\n * @param {Styles} styles\r\n */\r\nexport default function PreviewSupport(elementRegistry, eventBus, canvas, styles) {\r\n  this._elementRegistry = elementRegistry;\r\n  this._canvas = canvas;\r\n  this._styles = styles;\r\n}\r\n\r\nPreviewSupport.$inject = [\r\n  'elementRegistry',\r\n  'eventBus',\r\n  'canvas',\r\n  'styles'\r\n];\r\n\r\n// Markers are cleaned up with visuals, keep stub for compatibility\r\n// cf. https://github.com/camunda/camunda-modeler/issues/4307\r\nPreviewSupport.prototype.cleanUp = function() {\r\n  console.warn('PreviewSupport#cleanUp is deprecated and will be removed in future versions. You do not need to manually clean up previews anymore. cf. https://github.com/bpmn-io/diagram-js/pull/906');\r\n};\r\n\r\n/**\r\n * Returns graphics of an element.\r\n *\r\n * @param {Element} element\r\n *\r\n * @return {SVGElement}\r\n */\r\nPreviewSupport.prototype.getGfx = function(element) {\r\n  return this._elementRegistry.getGraphics(element);\r\n};\r\n\r\n/**\r\n * Adds a move preview of a given shape to a given SVG group.\r\n *\r\n * @param {Element} element The element to be moved.\r\n * @param {SVGElement} group The SVG group to add the preview to.\r\n * @param {SVGElement} [gfx] The optional graphical element of the element.\r\n * @param {string} [className=\"djs-dragger\"] The optional class name to add to the preview.\r\n *\r\n * @return {SVGElement} The preview.\r\n */\r\nPreviewSupport.prototype.addDragger = function(element, group, gfx, className = 'djs-dragger') {\r\n  gfx = gfx || this.getGfx(element);\r\n\r\n  var dragger = svgClone(gfx);\r\n  var bbox = gfx.getBoundingClientRect();\r\n\r\n  this._cloneMarkers(getVisual(dragger), className);\r\n\r\n  svgAttr(dragger, this._styles.cls(className, [], {\r\n    x: bbox.top,\r\n    y: bbox.left\r\n  }));\r\n\r\n  svgAppend(group, dragger);\r\n\r\n  svgAttr(dragger, 'data-preview-support-element-id', element.id);\r\n\r\n  return dragger;\r\n};\r\n\r\n/**\r\n * Adds a resize preview of a given shape to a given SVG group.\r\n *\r\n * @param {Shape} shape The element to be resized.\r\n * @param {SVGElement} group The SVG group to add the preview to.\r\n *\r\n * @return {SVGElement} The preview.\r\n */\r\nPreviewSupport.prototype.addFrame = function(shape, group) {\r\n\r\n  var frame = svgCreate('rect', {\r\n    class: 'djs-resize-overlay',\r\n    width:  shape.width,\r\n    height: shape.height,\r\n    x: shape.x,\r\n    y: shape.y\r\n  });\r\n\r\n  svgAppend(group, frame);\r\n\r\n  svgAttr(frame, 'data-preview-support-element-id', shape.id);\r\n\r\n  return frame;\r\n};\r\n\r\n/**\r\n * Clone all markers referenced by a node and its child nodes.\r\n *\r\n * @param {SVGElement} gfx\r\n * @param {string} [className=\"djs-dragger\"]\r\n */\r\nPreviewSupport.prototype._cloneMarkers = function(gfx, className = 'djs-dragger', rootGfx = gfx) {\r\n  var self = this;\r\n\r\n  if (gfx.childNodes) {\r\n\r\n    gfx.childNodes.forEach((childNode) => {\r\n      self._cloneMarkers(childNode, className, rootGfx);\r\n    });\r\n\r\n  }\r\n\r\n  if (!canHaveMarker(gfx)) {\r\n    return;\r\n  }\r\n\r\n  MARKER_TYPES.forEach(function(markerType) {\r\n    if (svgAttr(gfx, markerType)) {\r\n      var marker = getMarker(gfx, markerType, self._canvas.getContainer());\r\n\r\n      // Only clone marker if it is already present on the DOM\r\n      marker && self._cloneMarker(rootGfx, gfx, marker, markerType, className);\r\n    }\r\n  });\r\n};\r\n\r\n/**\r\n * Clone marker referenced by an element.\r\n *\r\n * @param {SVGElement} gfx\r\n * @param {SVGElement} marker\r\n * @param {string} markerType\r\n * @param {string} [className=\"djs-dragger\"]\r\n */\r\nPreviewSupport.prototype._cloneMarker = function(parentGfx, gfx, marker, markerType, className = 'djs-dragger') {\r\n\r\n  // Add a random suffix to the marker ID in case the same marker is previewed multiple times\r\n  var clonedMarkerId = [ marker.id, className, cloneIds.next() ].join('-');\r\n\r\n  // reuse marker if it was part of original gfx\r\n  var copiedMarker = domQuery('marker#' + marker.id, parentGfx);\r\n\r\n  parentGfx = parentGfx || this._canvas._svg;\r\n\r\n  var clonedMarker = copiedMarker || svgClone(marker);\r\n\r\n  clonedMarker.id = clonedMarkerId;\r\n\r\n  svgClasses(clonedMarker).add(className);\r\n\r\n  var defs = domQuery(':scope > defs', parentGfx);\r\n\r\n  if (!defs) {\r\n    defs = svgCreate('defs');\r\n\r\n    svgAppend(parentGfx, defs);\r\n  }\r\n\r\n  svgAppend(defs, clonedMarker);\r\n\r\n  var reference = idToReference(clonedMarker.id);\r\n\r\n  svgAttr(gfx, markerType, reference);\r\n};\r\n\r\n// helpers //////////\r\n\r\n/**\r\n * Get marker of given type referenced by node.\r\n *\r\n * @param {HTMLElement} node\r\n * @param {string} markerType\r\n * @param {HTMLElement} [parentNode]\r\n *\r\n * @param {HTMLElement}\r\n */\r\nfunction getMarker(node, markerType, parentNode) {\r\n  var id = referenceToId(svgAttr(node, markerType));\r\n\r\n  return domQuery('marker#' + id, parentNode || document);\r\n}\r\n\r\n/**\r\n * Get ID of fragment within current document from its functional IRI reference.\r\n * References may use single or double quotes.\r\n *\r\n * @param {string} reference\r\n *\r\n * @return {string}\r\n */\r\nfunction referenceToId(reference) {\r\n  return reference.match(/url\\(['\"]?#([^'\"]*)['\"]?\\)/)[1];\r\n}\r\n\r\n/**\r\n * Get functional IRI reference for given ID of fragment within current document.\r\n *\r\n * @param {string} id\r\n *\r\n * @return {string}\r\n */\r\nfunction idToReference(id) {\r\n  return 'url(#' + id + ')';\r\n}\r\n\r\n/**\r\n * Check wether node type can have marker attributes.\r\n *\r\n * @param {HTMLElement} node\r\n *\r\n * @return {boolean}\r\n */\r\nfunction canHaveMarker(node) {\r\n  return NODES_CAN_HAVE_MARKER.indexOf(node.nodeName) !== -1;\r\n}"],"mappings":"AAAA,SACEA,MAAM,IAAIC,SAAS,EACnBC,IAAI,IAAIC,OAAO,EACfC,OAAO,IAAIC,UAAU,EACrBC,KAAK,IAAIC,QAAQ,EACjBC,MAAM,IAAIC,SAAS,QACd,UAAU;AAEjB,SAASC,KAAK,IAAIC,QAAQ,QAAQ,SAAS;AAE3C,SAASC,SAAS,QAAQ,yBAAyB;AAEnD,OAAOC,GAAG,MAAM,wBAAwB;;AAExC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,MAAMC,QAAQ,GAAG,IAAID,GAAG,CAAC,IAAI,CAAC;AAE9B,IAAIE,YAAY,GAAG,CACjB,cAAc,EACd,YAAY,EACZ,YAAY,CACb;AAED,IAAIC,qBAAqB,GAAG,CAC1B,QAAQ,EACR,SAAS,EACT,MAAM,EACN,MAAM,EACN,SAAS,EACT,UAAU,EACV,MAAM,EACN,MAAM,CACP;;AAGD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,SAASC,cAAcA,CAACC,eAAe,EAAEC,QAAQ,EAAEC,MAAM,EAAEC,MAAM,EAAE;EAChF,IAAI,CAACC,gBAAgB,GAAGJ,eAAe;EACvC,IAAI,CAACK,OAAO,GAAGH,MAAM;EACrB,IAAI,CAACI,OAAO,GAAGH,MAAM;AACvB;AAEAJ,cAAc,CAACQ,OAAO,GAAG,CACvB,iBAAiB,EACjB,UAAU,EACV,QAAQ,EACR,QAAQ,CACT;;AAED;AACA;AACAR,cAAc,CAACS,SAAS,CAACC,OAAO,GAAG,YAAW;EAC5CC,OAAO,CAACC,IAAI,CAAC,wLAAwL,CAAC;AACxM,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACAZ,cAAc,CAACS,SAAS,CAACI,MAAM,GAAG,UAASC,OAAO,EAAE;EAClD,OAAO,IAAI,CAACT,gBAAgB,CAACU,WAAW,CAACD,OAAO,CAAC;AACnD,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACAd,cAAc,CAACS,SAAS,CAACO,UAAU,GAAG,UAASF,OAAO,EAAEG,KAAK,EAAEC,GAAG,EAA6B;EAAA,IAA3BC,SAAS,GAAAC,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA,MAAG,aAAa;EAC3FF,GAAG,GAAGA,GAAG,IAAI,IAAI,CAACL,MAAM,CAACC,OAAO,CAAC;EAEjC,IAAIS,OAAO,GAAGjC,QAAQ,CAAC4B,GAAG,CAAC;EAC3B,IAAIM,IAAI,GAAGN,GAAG,CAACO,qBAAqB,CAAC,CAAC;EAEtC,IAAI,CAACC,aAAa,CAAC/B,SAAS,CAAC4B,OAAO,CAAC,EAAEJ,SAAS,CAAC;EAEjDjC,OAAO,CAACqC,OAAO,EAAE,IAAI,CAAChB,OAAO,CAACoB,GAAG,CAACR,SAAS,EAAE,EAAE,EAAE;IAC/CS,CAAC,EAAEJ,IAAI,CAACK,GAAG;IACXC,CAAC,EAAEN,IAAI,CAACO;EACV,CAAC,CAAC,CAAC;EAEH/C,SAAS,CAACiC,KAAK,EAAEM,OAAO,CAAC;EAEzBrC,OAAO,CAACqC,OAAO,EAAE,iCAAiC,EAAET,OAAO,CAACkB,EAAE,CAAC;EAE/D,OAAOT,OAAO;AAChB,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACAvB,cAAc,CAACS,SAAS,CAACwB,QAAQ,GAAG,UAASC,KAAK,EAAEjB,KAAK,EAAE;EAEzD,IAAIkB,KAAK,GAAG3C,SAAS,CAAC,MAAM,EAAE;IAC5B4C,KAAK,EAAE,oBAAoB;IAC3BC,KAAK,EAAGH,KAAK,CAACG,KAAK;IACnBC,MAAM,EAAEJ,KAAK,CAACI,MAAM;IACpBV,CAAC,EAAEM,KAAK,CAACN,CAAC;IACVE,CAAC,EAAEI,KAAK,CAACJ;EACX,CAAC,CAAC;EAEF9C,SAAS,CAACiC,KAAK,EAAEkB,KAAK,CAAC;EAEvBjD,OAAO,CAACiD,KAAK,EAAE,iCAAiC,EAAED,KAAK,CAACF,EAAE,CAAC;EAE3D,OAAOG,KAAK;AACd,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACAnC,cAAc,CAACS,SAAS,CAACiB,aAAa,GAAG,UAASR,GAAG,EAA4C;EAAA,IAA1CC,SAAS,GAAAC,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA,MAAG,aAAa;EAAA,IAAEmB,OAAO,GAAAnB,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA,MAAGF,GAAG;EAC7F,IAAIsB,IAAI,GAAG,IAAI;EAEf,IAAItB,GAAG,CAACuB,UAAU,EAAE;IAElBvB,GAAG,CAACuB,UAAU,CAACC,OAAO,CAAEC,SAAS,IAAK;MACpCH,IAAI,CAACd,aAAa,CAACiB,SAAS,EAAExB,SAAS,EAAEoB,OAAO,CAAC;IACnD,CAAC,CAAC;EAEJ;EAEA,IAAI,CAACK,aAAa,CAAC1B,GAAG,CAAC,EAAE;IACvB;EACF;EAEApB,YAAY,CAAC4C,OAAO,CAAC,UAASG,UAAU,EAAE;IACxC,IAAI3D,OAAO,CAACgC,GAAG,EAAE2B,UAAU,CAAC,EAAE;MAC5B,IAAIC,MAAM,GAAGC,SAAS,CAAC7B,GAAG,EAAE2B,UAAU,EAAEL,IAAI,CAAClC,OAAO,CAAC0C,YAAY,CAAC,CAAC,CAAC;;MAEpE;MACAF,MAAM,IAAIN,IAAI,CAACS,YAAY,CAACV,OAAO,EAAErB,GAAG,EAAE4B,MAAM,EAAED,UAAU,EAAE1B,SAAS,CAAC;IAC1E;EACF,CAAC,CAAC;AACJ,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACAnB,cAAc,CAACS,SAAS,CAACwC,YAAY,GAAG,UAASC,SAAS,EAAEhC,GAAG,EAAE4B,MAAM,EAAED,UAAU,EAA6B;EAAA,IAA3B1B,SAAS,GAAAC,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA,MAAG,aAAa;EAE5G;EACA,IAAI+B,cAAc,GAAG,CAAEL,MAAM,CAACd,EAAE,EAAEb,SAAS,EAAEtB,QAAQ,CAACuD,IAAI,CAAC,CAAC,CAAE,CAACC,IAAI,CAAC,GAAG,CAAC;;EAExE;EACA,IAAIC,YAAY,GAAG5D,QAAQ,CAAC,SAAS,GAAGoD,MAAM,CAACd,EAAE,EAAEkB,SAAS,CAAC;EAE7DA,SAAS,GAAGA,SAAS,IAAI,IAAI,CAAC5C,OAAO,CAACiD,IAAI;EAE1C,IAAIC,YAAY,GAAGF,YAAY,IAAIhE,QAAQ,CAACwD,MAAM,CAAC;EAEnDU,YAAY,CAACxB,EAAE,GAAGmB,cAAc;EAEhC/D,UAAU,CAACoE,YAAY,CAAC,CAACC,GAAG,CAACtC,SAAS,CAAC;EAEvC,IAAIuC,IAAI,GAAGhE,QAAQ,CAAC,eAAe,EAAEwD,SAAS,CAAC;EAE/C,IAAI,CAACQ,IAAI,EAAE;IACTA,IAAI,GAAGlE,SAAS,CAAC,MAAM,CAAC;IAExBR,SAAS,CAACkE,SAAS,EAAEQ,IAAI,CAAC;EAC5B;EAEA1E,SAAS,CAAC0E,IAAI,EAAEF,YAAY,CAAC;EAE7B,IAAIG,SAAS,GAAGC,aAAa,CAACJ,YAAY,CAACxB,EAAE,CAAC;EAE9C9C,OAAO,CAACgC,GAAG,EAAE2B,UAAU,EAAEc,SAAS,CAAC;AACrC,CAAC;;AAED;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASZ,SAASA,CAACc,IAAI,EAAEhB,UAAU,EAAEiB,UAAU,EAAE;EAC/C,IAAI9B,EAAE,GAAG+B,aAAa,CAAC7E,OAAO,CAAC2E,IAAI,EAAEhB,UAAU,CAAC,CAAC;EAEjD,OAAOnD,QAAQ,CAAC,SAAS,GAAGsC,EAAE,EAAE8B,UAAU,IAAIE,QAAQ,CAAC;AACzD;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASD,aAAaA,CAACJ,SAAS,EAAE;EAChC,OAAOA,SAAS,CAACM,KAAK,CAAC,4BAA4B,CAAC,CAAC,CAAC,CAAC;AACzD;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASL,aAAaA,CAAC5B,EAAE,EAAE;EACzB,OAAO,OAAO,GAAGA,EAAE,GAAG,GAAG;AAC3B;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASY,aAAaA,CAACiB,IAAI,EAAE;EAC3B,OAAO9D,qBAAqB,CAACmE,OAAO,CAACL,IAAI,CAACM,QAAQ,CAAC,KAAK,CAAC,CAAC;AAC5D","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}