{"ast":null,"code":"import { assign, forEach, isArray } from 'min-dash';\nimport { setSnapped } from '../snapping/SnapUtil';\nimport { getClosestPointOnConnection } from './BendpointUtil';\nimport { isConnection } from '../../util/ModelUtil';\n\n/**\n * @typedef {import('../../core/EventBus').default} EventBus\n */\nvar abs = Math.abs,\n  round = Math.round;\nvar TOLERANCE = 10;\n\n/**\n * @param {EventBus} eventBus\n */\nexport default function BendpointSnapping(eventBus) {\n  function snapTo(values, value) {\n    if (isArray(values)) {\n      var i = values.length;\n      while (i--) if (abs(values[i] - value) <= TOLERANCE) {\n        return values[i];\n      }\n    } else {\n      values = +values;\n      var rem = value % values;\n      if (rem < TOLERANCE) {\n        return value - rem;\n      }\n      if (rem > values - TOLERANCE) {\n        return value - rem + values;\n      }\n    }\n    return value;\n  }\n  function getSnapPoint(element, event) {\n    if (element.waypoints) {\n      return getClosestPointOnConnection(event, element);\n    }\n    if (element.width) {\n      return {\n        x: round(element.width / 2 + element.x),\n        y: round(element.height / 2 + element.y)\n      };\n    }\n  }\n\n  // connection segment snapping //////////////////////\n\n  function getConnectionSegmentSnaps(event) {\n    var context = event.context,\n      snapPoints = context.snapPoints,\n      connection = context.connection,\n      waypoints = connection.waypoints,\n      segmentStart = context.segmentStart,\n      segmentStartIndex = context.segmentStartIndex,\n      segmentEnd = context.segmentEnd,\n      segmentEndIndex = context.segmentEndIndex,\n      axis = context.axis;\n    if (snapPoints) {\n      return snapPoints;\n    }\n    var referenceWaypoints = [waypoints[segmentStartIndex - 1], segmentStart, segmentEnd, waypoints[segmentEndIndex + 1]];\n    if (segmentStartIndex < 2) {\n      referenceWaypoints.unshift(getSnapPoint(connection.source, event));\n    }\n    if (segmentEndIndex > waypoints.length - 3) {\n      referenceWaypoints.unshift(getSnapPoint(connection.target, event));\n    }\n    context.snapPoints = snapPoints = {\n      horizontal: [],\n      vertical: []\n    };\n    forEach(referenceWaypoints, function (p) {\n      // we snap on existing bendpoints only,\n      // not placeholders that are inserted during add\n      if (p) {\n        p = p.original || p;\n        if (axis === 'y') {\n          snapPoints.horizontal.push(p.y);\n        }\n        if (axis === 'x') {\n          snapPoints.vertical.push(p.x);\n        }\n      }\n    });\n    return snapPoints;\n  }\n  eventBus.on('connectionSegment.move.move', 1500, function (event) {\n    var snapPoints = getConnectionSegmentSnaps(event),\n      x = event.x,\n      y = event.y,\n      sx,\n      sy;\n    if (!snapPoints) {\n      return;\n    }\n\n    // snap\n    sx = snapTo(snapPoints.vertical, x);\n    sy = snapTo(snapPoints.horizontal, y);\n\n    // correction x/y\n    var cx = x - sx,\n      cy = y - sy;\n\n    // update delta\n    assign(event, {\n      dx: event.dx - cx,\n      dy: event.dy - cy,\n      x: sx,\n      y: sy\n    });\n\n    // only set snapped if actually snapped\n    if (cx || snapPoints.vertical.indexOf(x) !== -1) {\n      setSnapped(event, 'x', sx);\n    }\n    if (cy || snapPoints.horizontal.indexOf(y) !== -1) {\n      setSnapped(event, 'y', sy);\n    }\n  });\n\n  // bendpoint snapping //////////////////////\n\n  function getBendpointSnaps(context) {\n    var snapPoints = context.snapPoints,\n      waypoints = context.connection.waypoints,\n      bendpointIndex = context.bendpointIndex;\n    if (snapPoints) {\n      return snapPoints;\n    }\n    var referenceWaypoints = [waypoints[bendpointIndex - 1], waypoints[bendpointIndex + 1]];\n    context.snapPoints = snapPoints = {\n      horizontal: [],\n      vertical: []\n    };\n    forEach(referenceWaypoints, function (p) {\n      // we snap on existing bendpoints only,\n      // not placeholders that are inserted during add\n      if (p) {\n        p = p.original || p;\n        snapPoints.horizontal.push(p.y);\n        snapPoints.vertical.push(p.x);\n      }\n    });\n    return snapPoints;\n  }\n\n  // Snap Endpoint of new connection\n  eventBus.on(['connect.hover', 'connect.move', 'connect.end'], 1500, function (event) {\n    var context = event.context,\n      hover = context.hover,\n      hoverMid = hover && getSnapPoint(hover, event);\n\n    // only snap on connections, elements can have multiple connect endpoints\n    if (!isConnection(hover) || !hoverMid || !hoverMid.x || !hoverMid.y) {\n      return;\n    }\n    setSnapped(event, 'x', hoverMid.x);\n    setSnapped(event, 'y', hoverMid.y);\n  });\n  eventBus.on(['bendpoint.move.move', 'bendpoint.move.end'], 1500, function (event) {\n    var context = event.context,\n      snapPoints = getBendpointSnaps(context),\n      hover = context.hover,\n      hoverMid = hover && getSnapPoint(hover, event),\n      x = event.x,\n      y = event.y,\n      sx,\n      sy;\n    if (!snapPoints) {\n      return;\n    }\n\n    // snap to hover mid\n    sx = snapTo(hoverMid ? snapPoints.vertical.concat([hoverMid.x]) : snapPoints.vertical, x);\n    sy = snapTo(hoverMid ? snapPoints.horizontal.concat([hoverMid.y]) : snapPoints.horizontal, y);\n\n    // correction x/y\n    var cx = x - sx,\n      cy = y - sy;\n\n    // update delta\n    assign(event, {\n      dx: event.dx - cx,\n      dy: event.dy - cy,\n      x: event.x - cx,\n      y: event.y - cy\n    });\n\n    // only set snapped if actually snapped\n    if (cx || snapPoints.vertical.indexOf(x) !== -1) {\n      setSnapped(event, 'x', sx);\n    }\n    if (cy || snapPoints.horizontal.indexOf(y) !== -1) {\n      setSnapped(event, 'y', sy);\n    }\n  });\n}\nBendpointSnapping.$inject = ['eventBus'];","map":{"version":3,"names":["assign","forEach","isArray","setSnapped","getClosestPointOnConnection","isConnection","abs","Math","round","TOLERANCE","BendpointSnapping","eventBus","snapTo","values","value","i","length","rem","getSnapPoint","element","event","waypoints","width","x","y","height","getConnectionSegmentSnaps","context","snapPoints","connection","segmentStart","segmentStartIndex","segmentEnd","segmentEndIndex","axis","referenceWaypoints","unshift","source","target","horizontal","vertical","p","original","push","on","sx","sy","cx","cy","dx","dy","indexOf","getBendpointSnaps","bendpointIndex","hover","hoverMid","concat","$inject"],"sources":["/home/runner/work/sgex/sgex/node_modules/diagram-js/lib/features/bendpoints/BendpointSnapping.js"],"sourcesContent":["import {\n  assign,\n  forEach,\n  isArray\n} from 'min-dash';\n\nimport { setSnapped } from '../snapping/SnapUtil';\n\nimport { getClosestPointOnConnection } from './BendpointUtil';\n\nimport { isConnection } from '../../util/ModelUtil';\n\n/**\n * @typedef {import('../../core/EventBus').default} EventBus\n */\nvar abs = Math.abs,\n    round = Math.round;\n\nvar TOLERANCE = 10;\n\n/**\n * @param {EventBus} eventBus\n */\nexport default function BendpointSnapping(eventBus) {\n\n  function snapTo(values, value) {\n\n    if (isArray(values)) {\n      var i = values.length;\n\n      while (i--) if (abs(values[i] - value) <= TOLERANCE) {\n        return values[i];\n      }\n    } else {\n      values = +values;\n      var rem = value % values;\n\n      if (rem < TOLERANCE) {\n        return value - rem;\n      }\n\n      if (rem > values - TOLERANCE) {\n        return value - rem + values;\n      }\n    }\n\n    return value;\n  }\n\n  function getSnapPoint(element, event) {\n\n    if (element.waypoints) {\n      return getClosestPointOnConnection(event, element);\n    }\n\n    if (element.width) {\n      return {\n        x: round(element.width / 2 + element.x),\n        y: round(element.height / 2 + element.y)\n      };\n    }\n  }\n\n  // connection segment snapping //////////////////////\n\n  function getConnectionSegmentSnaps(event) {\n\n    var context = event.context,\n        snapPoints = context.snapPoints,\n        connection = context.connection,\n        waypoints = connection.waypoints,\n        segmentStart = context.segmentStart,\n        segmentStartIndex = context.segmentStartIndex,\n        segmentEnd = context.segmentEnd,\n        segmentEndIndex = context.segmentEndIndex,\n        axis = context.axis;\n\n    if (snapPoints) {\n      return snapPoints;\n    }\n\n    var referenceWaypoints = [\n      waypoints[segmentStartIndex - 1],\n      segmentStart,\n      segmentEnd,\n      waypoints[segmentEndIndex + 1]\n    ];\n\n    if (segmentStartIndex < 2) {\n      referenceWaypoints.unshift(getSnapPoint(connection.source, event));\n    }\n\n    if (segmentEndIndex > waypoints.length - 3) {\n      referenceWaypoints.unshift(getSnapPoint(connection.target, event));\n    }\n\n    context.snapPoints = snapPoints = { horizontal: [] , vertical: [] };\n\n    forEach(referenceWaypoints, function(p) {\n\n      // we snap on existing bendpoints only,\n      // not placeholders that are inserted during add\n      if (p) {\n        p = p.original || p;\n\n        if (axis === 'y') {\n          snapPoints.horizontal.push(p.y);\n        }\n\n        if (axis === 'x') {\n          snapPoints.vertical.push(p.x);\n        }\n      }\n    });\n\n    return snapPoints;\n  }\n\n  eventBus.on('connectionSegment.move.move', 1500, function(event) {\n    var snapPoints = getConnectionSegmentSnaps(event),\n        x = event.x,\n        y = event.y,\n        sx, sy;\n\n    if (!snapPoints) {\n      return;\n    }\n\n    // snap\n    sx = snapTo(snapPoints.vertical, x);\n    sy = snapTo(snapPoints.horizontal, y);\n\n\n    // correction x/y\n    var cx = (x - sx),\n        cy = (y - sy);\n\n    // update delta\n    assign(event, {\n      dx: event.dx - cx,\n      dy: event.dy - cy,\n      x: sx,\n      y: sy\n    });\n\n    // only set snapped if actually snapped\n    if (cx || snapPoints.vertical.indexOf(x) !== -1) {\n      setSnapped(event, 'x', sx);\n    }\n\n    if (cy || snapPoints.horizontal.indexOf(y) !== -1) {\n      setSnapped(event, 'y', sy);\n    }\n  });\n\n\n  // bendpoint snapping //////////////////////\n\n  function getBendpointSnaps(context) {\n\n    var snapPoints = context.snapPoints,\n        waypoints = context.connection.waypoints,\n        bendpointIndex = context.bendpointIndex;\n\n    if (snapPoints) {\n      return snapPoints;\n    }\n\n    var referenceWaypoints = [ waypoints[bendpointIndex - 1], waypoints[bendpointIndex + 1] ];\n\n    context.snapPoints = snapPoints = { horizontal: [] , vertical: [] };\n\n    forEach(referenceWaypoints, function(p) {\n\n      // we snap on existing bendpoints only,\n      // not placeholders that are inserted during add\n      if (p) {\n        p = p.original || p;\n\n        snapPoints.horizontal.push(p.y);\n        snapPoints.vertical.push(p.x);\n      }\n    });\n\n    return snapPoints;\n  }\n\n  // Snap Endpoint of new connection\n  eventBus.on([\n    'connect.hover',\n    'connect.move',\n    'connect.end'\n  ], 1500, function(event) {\n    var context = event.context,\n        hover = context.hover,\n        hoverMid = hover && getSnapPoint(hover, event);\n\n    // only snap on connections, elements can have multiple connect endpoints\n    if (!isConnection(hover) || !hoverMid || !hoverMid.x || !hoverMid.y) {\n      return;\n    }\n\n    setSnapped(event, 'x', hoverMid.x);\n    setSnapped(event, 'y', hoverMid.y);\n  });\n\n  eventBus.on([ 'bendpoint.move.move', 'bendpoint.move.end' ], 1500, function(event) {\n\n    var context = event.context,\n        snapPoints = getBendpointSnaps(context),\n        hover = context.hover,\n        hoverMid = hover && getSnapPoint(hover, event),\n        x = event.x,\n        y = event.y,\n        sx, sy;\n\n    if (!snapPoints) {\n      return;\n    }\n\n    // snap to hover mid\n    sx = snapTo(hoverMid ? snapPoints.vertical.concat([ hoverMid.x ]) : snapPoints.vertical, x);\n    sy = snapTo(hoverMid ? snapPoints.horizontal.concat([ hoverMid.y ]) : snapPoints.horizontal, y);\n\n    // correction x/y\n    var cx = (x - sx),\n        cy = (y - sy);\n\n    // update delta\n    assign(event, {\n      dx: event.dx - cx,\n      dy: event.dy - cy,\n      x: event.x - cx,\n      y: event.y - cy\n    });\n\n    // only set snapped if actually snapped\n    if (cx || snapPoints.vertical.indexOf(x) !== -1) {\n      setSnapped(event, 'x', sx);\n    }\n\n    if (cy || snapPoints.horizontal.indexOf(y) !== -1) {\n      setSnapped(event, 'y', sy);\n    }\n  });\n}\n\n\nBendpointSnapping.$inject = [ 'eventBus' ];\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}