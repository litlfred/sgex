{"ast":null,"code":"\"use strict\";\n\nvar _taggedTemplateLiteral = require(\"/home/runner/work/sgex/sgex/node_modules/@babel/runtime/helpers/taggedTemplateLiteral.js\").default;\nvar _templateObject, _templateObject2, _templateObject3, _templateObject4, _templateObject5;\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.extendSubschemaMode = exports.extendSubschemaData = exports.getSubschema = void 0;\nconst codegen_1 = require(\"../codegen\");\nconst util_1 = require(\"../util\");\nfunction getSubschema(it, _ref) {\n  let {\n    keyword,\n    schemaProp,\n    schema,\n    schemaPath,\n    errSchemaPath,\n    topSchemaRef\n  } = _ref;\n  if (keyword !== undefined && schema !== undefined) {\n    throw new Error('both \"keyword\" and \"schema\" passed, only one allowed');\n  }\n  if (keyword !== undefined) {\n    const sch = it.schema[keyword];\n    return schemaProp === undefined ? {\n      schema: sch,\n      schemaPath: (0, codegen_1._)(_templateObject || (_templateObject = _taggedTemplateLiteral([\"\", \"\", \"\"])), it.schemaPath, (0, codegen_1.getProperty)(keyword)),\n      errSchemaPath: \"\".concat(it.errSchemaPath, \"/\").concat(keyword)\n    } : {\n      schema: sch[schemaProp],\n      schemaPath: (0, codegen_1._)(_templateObject2 || (_templateObject2 = _taggedTemplateLiteral([\"\", \"\", \"\", \"\"])), it.schemaPath, (0, codegen_1.getProperty)(keyword), (0, codegen_1.getProperty)(schemaProp)),\n      errSchemaPath: \"\".concat(it.errSchemaPath, \"/\").concat(keyword, \"/\").concat((0, util_1.escapeFragment)(schemaProp))\n    };\n  }\n  if (schema !== undefined) {\n    if (schemaPath === undefined || errSchemaPath === undefined || topSchemaRef === undefined) {\n      throw new Error('\"schemaPath\", \"errSchemaPath\" and \"topSchemaRef\" are required with \"schema\"');\n    }\n    return {\n      schema,\n      schemaPath,\n      topSchemaRef,\n      errSchemaPath\n    };\n  }\n  throw new Error('either \"keyword\" or \"schema\" must be passed');\n}\nexports.getSubschema = getSubschema;\nfunction extendSubschemaData(subschema, it, _ref2) {\n  let {\n    dataProp,\n    dataPropType: dpType,\n    data,\n    dataTypes,\n    propertyName\n  } = _ref2;\n  if (data !== undefined && dataProp !== undefined) {\n    throw new Error('both \"data\" and \"dataProp\" passed, only one allowed');\n  }\n  const {\n    gen\n  } = it;\n  if (dataProp !== undefined) {\n    const {\n      errorPath,\n      dataPathArr,\n      opts\n    } = it;\n    const nextData = gen.let(\"data\", (0, codegen_1._)(_templateObject3 || (_templateObject3 = _taggedTemplateLiteral([\"\", \"\", \"\"])), it.data, (0, codegen_1.getProperty)(dataProp)), true);\n    dataContextProps(nextData);\n    subschema.errorPath = (0, codegen_1.str)(_templateObject4 || (_templateObject4 = _taggedTemplateLiteral([\"\", \"\", \"\"])), errorPath, (0, util_1.getErrorPath)(dataProp, dpType, opts.jsPropertySyntax));\n    subschema.parentDataProperty = (0, codegen_1._)(_templateObject5 || (_templateObject5 = _taggedTemplateLiteral([\"\", \"\"])), dataProp);\n    subschema.dataPathArr = [...dataPathArr, subschema.parentDataProperty];\n  }\n  if (data !== undefined) {\n    const nextData = data instanceof codegen_1.Name ? data : gen.let(\"data\", data, true); // replaceable if used once?\n    dataContextProps(nextData);\n    if (propertyName !== undefined) subschema.propertyName = propertyName;\n    // TODO something is possibly wrong here with not changing parentDataProperty and not appending dataPathArr\n  }\n  if (dataTypes) subschema.dataTypes = dataTypes;\n  function dataContextProps(_nextData) {\n    subschema.data = _nextData;\n    subschema.dataLevel = it.dataLevel + 1;\n    subschema.dataTypes = [];\n    it.definedProperties = new Set();\n    subschema.parentData = it.data;\n    subschema.dataNames = [...it.dataNames, _nextData];\n  }\n}\nexports.extendSubschemaData = extendSubschemaData;\nfunction extendSubschemaMode(subschema, _ref3) {\n  let {\n    jtdDiscriminator,\n    jtdMetadata,\n    compositeRule,\n    createErrors,\n    allErrors\n  } = _ref3;\n  if (compositeRule !== undefined) subschema.compositeRule = compositeRule;\n  if (createErrors !== undefined) subschema.createErrors = createErrors;\n  if (allErrors !== undefined) subschema.allErrors = allErrors;\n  subschema.jtdDiscriminator = jtdDiscriminator; // not inherited\n  subschema.jtdMetadata = jtdMetadata; // not inherited\n}\nexports.extendSubschemaMode = extendSubschemaMode;","map":{"version":3,"names":["codegen_1","require","util_1","getSubschema","it","_ref","keyword","schemaProp","schema","schemaPath","errSchemaPath","topSchemaRef","undefined","Error","sch","_","_templateObject","_taggedTemplateLiteral","getProperty","concat","_templateObject2","escapeFragment","exports","extendSubschemaData","subschema","_ref2","dataProp","dataPropType","dpType","data","dataTypes","propertyName","gen","errorPath","dataPathArr","opts","nextData","let","_templateObject3","dataContextProps","str","_templateObject4","getErrorPath","jsPropertySyntax","parentDataProperty","_templateObject5","Name","_nextData","dataLevel","definedProperties","Set","parentData","dataNames","extendSubschemaMode","_ref3","jtdDiscriminator","jtdMetadata","compositeRule","createErrors","allErrors"],"sources":["/home/runner/work/sgex/sgex/node_modules/ajv/lib/compile/validate/subschema.ts"],"sourcesContent":["import type {AnySchema} from \"../../types\"\nimport type {SchemaObjCxt} from \"..\"\nimport {_, str, getProperty, Code, Name} from \"../codegen\"\nimport {escapeFragment, getErrorPath, Type} from \"../util\"\nimport type {JSONType} from \"../rules\"\n\nexport interface SubschemaContext {\n  // TODO use Optional? align with SchemCxt property types\n  schema: AnySchema\n  schemaPath: Code\n  errSchemaPath: string\n  topSchemaRef?: Code\n  errorPath?: Code\n  dataLevel?: number\n  dataTypes?: JSONType[]\n  data?: Name\n  parentData?: Name\n  parentDataProperty?: Code | number\n  dataNames?: Name[]\n  dataPathArr?: (Code | number)[]\n  propertyName?: Name\n  jtdDiscriminator?: string\n  jtdMetadata?: boolean\n  compositeRule?: true\n  createErrors?: boolean\n  allErrors?: boolean\n}\n\nexport type SubschemaArgs = Partial<{\n  keyword: string\n  schemaProp: string | number\n  schema: AnySchema\n  schemaPath: Code\n  errSchemaPath: string\n  topSchemaRef: Code\n  data: Name | Code\n  dataProp: Code | string | number\n  dataTypes: JSONType[]\n  definedProperties: Set<string>\n  propertyName: Name\n  dataPropType: Type\n  jtdDiscriminator: string\n  jtdMetadata: boolean\n  compositeRule: true\n  createErrors: boolean\n  allErrors: boolean\n}>\n\nexport function getSubschema(\n  it: SchemaObjCxt,\n  {keyword, schemaProp, schema, schemaPath, errSchemaPath, topSchemaRef}: SubschemaArgs\n): SubschemaContext {\n  if (keyword !== undefined && schema !== undefined) {\n    throw new Error('both \"keyword\" and \"schema\" passed, only one allowed')\n  }\n\n  if (keyword !== undefined) {\n    const sch = it.schema[keyword]\n    return schemaProp === undefined\n      ? {\n          schema: sch,\n          schemaPath: _`${it.schemaPath}${getProperty(keyword)}`,\n          errSchemaPath: `${it.errSchemaPath}/${keyword}`,\n        }\n      : {\n          schema: sch[schemaProp],\n          schemaPath: _`${it.schemaPath}${getProperty(keyword)}${getProperty(schemaProp)}`,\n          errSchemaPath: `${it.errSchemaPath}/${keyword}/${escapeFragment(schemaProp)}`,\n        }\n  }\n\n  if (schema !== undefined) {\n    if (schemaPath === undefined || errSchemaPath === undefined || topSchemaRef === undefined) {\n      throw new Error('\"schemaPath\", \"errSchemaPath\" and \"topSchemaRef\" are required with \"schema\"')\n    }\n    return {\n      schema,\n      schemaPath,\n      topSchemaRef,\n      errSchemaPath,\n    }\n  }\n\n  throw new Error('either \"keyword\" or \"schema\" must be passed')\n}\n\nexport function extendSubschemaData(\n  subschema: SubschemaContext,\n  it: SchemaObjCxt,\n  {dataProp, dataPropType: dpType, data, dataTypes, propertyName}: SubschemaArgs\n): void {\n  if (data !== undefined && dataProp !== undefined) {\n    throw new Error('both \"data\" and \"dataProp\" passed, only one allowed')\n  }\n\n  const {gen} = it\n\n  if (dataProp !== undefined) {\n    const {errorPath, dataPathArr, opts} = it\n    const nextData = gen.let(\"data\", _`${it.data}${getProperty(dataProp)}`, true)\n    dataContextProps(nextData)\n    subschema.errorPath = str`${errorPath}${getErrorPath(dataProp, dpType, opts.jsPropertySyntax)}`\n    subschema.parentDataProperty = _`${dataProp}`\n    subschema.dataPathArr = [...dataPathArr, subschema.parentDataProperty]\n  }\n\n  if (data !== undefined) {\n    const nextData = data instanceof Name ? data : gen.let(\"data\", data, true) // replaceable if used once?\n    dataContextProps(nextData)\n    if (propertyName !== undefined) subschema.propertyName = propertyName\n    // TODO something is possibly wrong here with not changing parentDataProperty and not appending dataPathArr\n  }\n\n  if (dataTypes) subschema.dataTypes = dataTypes\n\n  function dataContextProps(_nextData: Name): void {\n    subschema.data = _nextData\n    subschema.dataLevel = it.dataLevel + 1\n    subschema.dataTypes = []\n    it.definedProperties = new Set<string>()\n    subschema.parentData = it.data\n    subschema.dataNames = [...it.dataNames, _nextData]\n  }\n}\n\nexport function extendSubschemaMode(\n  subschema: SubschemaContext,\n  {jtdDiscriminator, jtdMetadata, compositeRule, createErrors, allErrors}: SubschemaArgs\n): void {\n  if (compositeRule !== undefined) subschema.compositeRule = compositeRule\n  if (createErrors !== undefined) subschema.createErrors = createErrors\n  if (allErrors !== undefined) subschema.allErrors = allErrors\n  subschema.jtdDiscriminator = jtdDiscriminator // not inherited\n  subschema.jtdMetadata = jtdMetadata // not inherited\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}