{"ast":null,"code":"import inherits from 'inherits-browser';\nimport { getBusinessObject, is } from '../../../util/ModelUtil';\nimport CommandInterceptor from 'diagram-js/lib/command/CommandInterceptor';\nimport { hasEventDefinition, isEventSubProcess } from '../../../util/DiUtil';\n\n/**\n * @typedef {import('diagram-js/lib/core/EventBus').default} EventBus\n * @typedef {import('../lib/features/modeling/Modeling').default} Modeling\n */\n\n/**\n * Behavior ensuring that only a single compensation activity is connected to a\n * compensation boundary event when connecting, reconnecting or replacing shapes.\n *\n * @param {import('diagram-js/lib/core/EventBus').default} eventBus\n * @param {import('../Modeling').default} modeling\n * @param {import('../../rules/BpmnRules').default} bpmnRules\n */\nexport default function CompensateBoundaryEventBehavior(eventBus, modeling, bpmnRules) {\n  CommandInterceptor.call(this, eventBus);\n  this.preExecute('shape.replace', handleReplacement, true);\n  this.postExecuted('shape.replace', handleReplacementPostExecuted, true);\n  this.preExecute('connection.create', handleNewConnection, true);\n  this.postExecuted('connection.delete', handleConnectionRemoval, true);\n  this.postExecuted('connection.reconnect', handleReconnection, true);\n  this.postExecuted('element.updateProperties', handlePropertiesUpdate, true);\n\n  /**\n   * Given a connection from boundary event is removed, remove the `isForCompensation` property.\n   */\n  function handleConnectionRemoval(context) {\n    const source = context.source,\n      target = context.target;\n    if (isCompensationBoundaryEvent(source) && isForCompensation(target)) {\n      removeIsForCompensationProperty(target);\n    }\n  }\n\n  /**\n   * Add `isForCompensation` property and make sure only a single compensation activity is connected.\n   */\n  function handleNewConnection(context) {\n    const connection = context.connection,\n      source = context.source,\n      target = context.target;\n    if (isCompensationBoundaryEvent(source) && isForCompensationAllowed(target)) {\n      addIsForCompensationProperty(target);\n      removeExistingAssociations(source, [connection]);\n    }\n  }\n  function handleReconnection(context) {\n    const newTarget = context.newTarget,\n      oldSource = context.oldSource,\n      oldTarget = context.oldTarget;\n\n    // target changes\n    if (oldTarget !== newTarget) {\n      const source = oldSource;\n\n      // oldTarget perspective\n      if (isForCompensation(oldTarget)) {\n        removeIsForCompensationProperty(oldTarget);\n      }\n\n      // newTarget perspective\n      if (isCompensationBoundaryEvent(source) && isForCompensationAllowed(newTarget)) {\n        addIsForCompensationProperty(newTarget);\n      }\n    }\n  }\n  function handlePropertiesUpdate(context) {\n    const {\n      element\n    } = context;\n    if (isForCompensation(element)) {\n      removeDisallowedConnections(element);\n      removeAttachments(element);\n    } else if (isForCompensationAllowed(element)) {\n      removeIncomingCompensationAssociations(element);\n    }\n  }\n\n  /**\n   * When replacing a boundary event, make sure the compensation activity is connected,\n   * and remove the potential candidates for connection replacement to have a single compensation activity.\n   */\n  function handleReplacement(context) {\n    const {\n      newData,\n      oldShape\n    } = context;\n\n    // from compensate boundary event\n    if (isCompensationBoundaryEvent(context.oldShape) && newData.eventDefinitionType !== 'bpmn:CompensateEventDefinition' || newData.type !== 'bpmn:BoundaryEvent') {\n      const targetConnection = oldShape.outgoing.find(_ref => {\n        let {\n          target\n        } = _ref;\n        return isForCompensation(target);\n      });\n      if (targetConnection && targetConnection.target) {\n        context._connectionTarget = targetConnection.target;\n      }\n    }\n\n    // to compensate boundary event\n    else if (!isCompensationBoundaryEvent(context.oldShape) && newData.eventDefinitionType === 'bpmn:CompensateEventDefinition' && newData.type === 'bpmn:BoundaryEvent') {\n      const targetConnection = oldShape.outgoing.find(_ref2 => {\n        let {\n          target\n        } = _ref2;\n        return isForCompensationAllowed(target);\n      });\n      if (targetConnection && targetConnection.target) {\n        context._connectionTarget = targetConnection.target;\n      }\n      removeOutgoingSequenceFlows(oldShape);\n    }\n  }\n  function handleReplacementPostExecuted(context) {\n    const {\n      _connectionTarget: target,\n      newShape\n    } = context;\n    if (target) {\n      modeling.connect(newShape, target);\n    }\n  }\n  function addIsForCompensationProperty(target) {\n    modeling.updateProperties(target, {\n      isForCompensation: true\n    });\n  }\n  function removeIsForCompensationProperty(target) {\n    modeling.updateProperties(target, {\n      isForCompensation: undefined\n    });\n  }\n  function removeDisallowedConnections(element) {\n    for (const connection of element.incoming) {\n      if (!bpmnRules.canConnect(connection.source, element)) {\n        modeling.removeConnection(connection);\n      }\n    }\n    for (const connection of element.outgoing) {\n      if (!bpmnRules.canConnect(element, connection.target)) {\n        modeling.removeConnection(connection);\n      }\n    }\n  }\n  function removeExistingAssociations(boundaryEvent, ignoredAssociations) {\n    const associations = boundaryEvent.outgoing.filter(connection => is(connection, 'bpmn:Association'));\n    const associationsToRemove = associations.filter(association => {\n      return isForCompensation(association.target) && !ignoredAssociations.includes(association);\n    });\n\n    // remove existing associations\n    associationsToRemove.forEach(association => modeling.removeConnection(association));\n  }\n  function removeAttachments(element) {\n    const attachments = element.attachers.slice();\n    if (!attachments.length) {\n      return;\n    }\n    modeling.removeElements(attachments);\n  }\n  function removeIncomingCompensationAssociations(element) {\n    const compensationAssociations = element.incoming.filter(connection => isCompensationBoundaryEvent(connection.source));\n    modeling.removeElements(compensationAssociations);\n  }\n  function removeOutgoingSequenceFlows(element) {\n    const sequenceFlows = element.outgoing.filter(connection => is(connection, 'bpmn:SequenceFlow'));\n    modeling.removeElements(sequenceFlows);\n  }\n}\ninherits(CompensateBoundaryEventBehavior, CommandInterceptor);\nCompensateBoundaryEventBehavior.$inject = ['eventBus', 'modeling', 'bpmnRules'];\n\n// helpers //////////\n\nfunction isForCompensation(element) {\n  const bo = getBusinessObject(element);\n  return bo && bo.get('isForCompensation');\n}\nfunction isCompensationBoundaryEvent(element) {\n  return element && is(element, 'bpmn:BoundaryEvent') && hasEventDefinition(element, 'bpmn:CompensateEventDefinition');\n}\nfunction isForCompensationAllowed(element) {\n  return element && is(element, 'bpmn:Activity') && !isEventSubProcess(element);\n}","map":{"version":3,"names":["inherits","getBusinessObject","is","CommandInterceptor","hasEventDefinition","isEventSubProcess","CompensateBoundaryEventBehavior","eventBus","modeling","bpmnRules","call","preExecute","handleReplacement","postExecuted","handleReplacementPostExecuted","handleNewConnection","handleConnectionRemoval","handleReconnection","handlePropertiesUpdate","context","source","target","isCompensationBoundaryEvent","isForCompensation","removeIsForCompensationProperty","connection","isForCompensationAllowed","addIsForCompensationProperty","removeExistingAssociations","newTarget","oldSource","oldTarget","element","removeDisallowedConnections","removeAttachments","removeIncomingCompensationAssociations","newData","oldShape","eventDefinitionType","type","targetConnection","outgoing","find","_ref","_connectionTarget","_ref2","removeOutgoingSequenceFlows","newShape","connect","updateProperties","undefined","incoming","canConnect","removeConnection","boundaryEvent","ignoredAssociations","associations","filter","associationsToRemove","association","includes","forEach","attachments","attachers","slice","length","removeElements","compensationAssociations","sequenceFlows","$inject","bo","get"],"sources":["/home/runner/work/sgex/sgex/node_modules/bpmn-js/lib/features/modeling/behavior/CompensateBoundaryEventBehavior.js"],"sourcesContent":["import inherits from 'inherits-browser';\n\nimport { getBusinessObject, is } from '../../../util/ModelUtil';\n\nimport CommandInterceptor from 'diagram-js/lib/command/CommandInterceptor';\nimport { hasEventDefinition, isEventSubProcess } from '../../../util/DiUtil';\n\n/**\n * @typedef {import('diagram-js/lib/core/EventBus').default} EventBus\n * @typedef {import('../lib/features/modeling/Modeling').default} Modeling\n */\n\n/**\n * Behavior ensuring that only a single compensation activity is connected to a\n * compensation boundary event when connecting, reconnecting or replacing shapes.\n *\n * @param {import('diagram-js/lib/core/EventBus').default} eventBus\n * @param {import('../Modeling').default} modeling\n * @param {import('../../rules/BpmnRules').default} bpmnRules\n */\nexport default function CompensateBoundaryEventBehavior(eventBus, modeling, bpmnRules) {\n\n  CommandInterceptor.call(this, eventBus);\n\n  this.preExecute('shape.replace', handleReplacement, true);\n  this.postExecuted('shape.replace', handleReplacementPostExecuted, true);\n  this.preExecute('connection.create', handleNewConnection, true);\n  this.postExecuted('connection.delete', handleConnectionRemoval, true);\n  this.postExecuted('connection.reconnect', handleReconnection, true);\n  this.postExecuted('element.updateProperties', handlePropertiesUpdate, true);\n\n  /**\n   * Given a connection from boundary event is removed, remove the `isForCompensation` property.\n   */\n  function handleConnectionRemoval(context) {\n    const source = context.source,\n          target = context.target;\n\n    if (isCompensationBoundaryEvent(source) && isForCompensation(target)) {\n      removeIsForCompensationProperty(target);\n    }\n  }\n\n  /**\n   * Add `isForCompensation` property and make sure only a single compensation activity is connected.\n   */\n  function handleNewConnection(context) {\n    const connection = context.connection,\n          source = context.source,\n          target = context.target;\n\n    if (isCompensationBoundaryEvent(source) && isForCompensationAllowed(target)) {\n      addIsForCompensationProperty(target);\n      removeExistingAssociations(source, [ connection ]);\n    }\n  }\n\n  function handleReconnection(context) {\n    const newTarget = context.newTarget,\n          oldSource = context.oldSource,\n          oldTarget = context.oldTarget;\n\n    // target changes\n    if (oldTarget !== newTarget) {\n      const source = oldSource;\n\n      // oldTarget perspective\n      if (isForCompensation(oldTarget)) {\n        removeIsForCompensationProperty(oldTarget);\n      }\n\n      // newTarget perspective\n      if (isCompensationBoundaryEvent(source) && isForCompensationAllowed(newTarget)) {\n        addIsForCompensationProperty(newTarget);\n      }\n    }\n  }\n\n  function handlePropertiesUpdate(context) {\n    const { element } = context;\n\n    if (isForCompensation(element)) {\n      removeDisallowedConnections(element);\n      removeAttachments(element);\n    } else if (isForCompensationAllowed(element)) {\n      removeIncomingCompensationAssociations(element);\n    }\n  }\n\n  /**\n   * When replacing a boundary event, make sure the compensation activity is connected,\n   * and remove the potential candidates for connection replacement to have a single compensation activity.\n   */\n  function handleReplacement(context) {\n    const {\n      newData,\n      oldShape\n    } = context;\n\n    // from compensate boundary event\n    if (isCompensationBoundaryEvent(context.oldShape) &&\n      newData.eventDefinitionType !== 'bpmn:CompensateEventDefinition' ||\n      newData.type !== 'bpmn:BoundaryEvent'\n    ) {\n      const targetConnection = oldShape.outgoing.find(\n        ({ target }) => isForCompensation(target)\n      );\n\n      if (targetConnection && targetConnection.target) {\n        context._connectionTarget = targetConnection.target;\n      }\n    }\n\n    // to compensate boundary event\n    else if (\n      !isCompensationBoundaryEvent(context.oldShape) &&\n      newData.eventDefinitionType === 'bpmn:CompensateEventDefinition' &&\n      newData.type === 'bpmn:BoundaryEvent'\n    ) {\n      const targetConnection = oldShape.outgoing.find(\n        ({ target }) => isForCompensationAllowed(target)\n      );\n\n      if (targetConnection && targetConnection.target) {\n        context._connectionTarget = targetConnection.target;\n      }\n\n      removeOutgoingSequenceFlows(oldShape);\n    }\n  }\n\n  function handleReplacementPostExecuted(context) {\n    const { _connectionTarget: target, newShape } = context;\n\n    if (target) {\n      modeling.connect(newShape, target);\n    }\n  }\n\n  function addIsForCompensationProperty(target) {\n    modeling.updateProperties(target, { isForCompensation: true });\n  }\n\n  function removeIsForCompensationProperty(target) {\n    modeling.updateProperties(target, { isForCompensation: undefined });\n  }\n\n  function removeDisallowedConnections(element) {\n\n    for (const connection of element.incoming) {\n      if (!bpmnRules.canConnect(connection.source, element)) {\n        modeling.removeConnection(connection);\n      }\n    }\n\n    for (const connection of element.outgoing) {\n      if (!bpmnRules.canConnect(element, connection.target)) {\n        modeling.removeConnection(connection);\n      }\n    }\n  }\n\n  function removeExistingAssociations(boundaryEvent, ignoredAssociations) {\n    const associations = boundaryEvent.outgoing.filter(connection => is(connection, 'bpmn:Association'));\n    const associationsToRemove = associations.filter(association => {\n      return isForCompensation(association.target) && !ignoredAssociations.includes(association);\n    });\n\n    // remove existing associations\n    associationsToRemove.forEach(association => modeling.removeConnection(association));\n  }\n\n  function removeAttachments(element) {\n    const attachments = element.attachers.slice();\n\n    if (!attachments.length) {\n      return;\n    }\n\n    modeling.removeElements(attachments);\n  }\n\n  function removeIncomingCompensationAssociations(element) {\n    const compensationAssociations = element.incoming.filter(\n      connection => isCompensationBoundaryEvent(connection.source)\n    );\n\n    modeling.removeElements(compensationAssociations);\n  }\n\n  function removeOutgoingSequenceFlows(element) {\n    const sequenceFlows = element.outgoing.filter(\n      connection => is(connection, 'bpmn:SequenceFlow')\n    );\n\n    modeling.removeElements(sequenceFlows);\n  }\n}\n\ninherits(CompensateBoundaryEventBehavior, CommandInterceptor);\n\nCompensateBoundaryEventBehavior.$inject = [\n  'eventBus',\n  'modeling',\n  'bpmnRules'\n];\n\n// helpers //////////\n\nfunction isForCompensation(element) {\n  const bo = getBusinessObject(element);\n  return bo && bo.get('isForCompensation');\n}\n\nfunction isCompensationBoundaryEvent(element) {\n  return element && is(element, 'bpmn:BoundaryEvent') &&\n    hasEventDefinition(element, 'bpmn:CompensateEventDefinition');\n}\n\nfunction isForCompensationAllowed(element) {\n  return element && is(element, 'bpmn:Activity') && !isEventSubProcess(element);\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}