{"ast":null,"code":"import yaml from'js-yaml';import githubService from'./githubService';/**\n * Service for validating WHO SMART Guidelines Digital Adaptation Kit repositories\n * \n * A repository is considered a valid DAK if:\n * 1. It has a sushi-config.yaml file in the root\n * 2. The sushi-config.yaml contains a 'dependencies' section\n * 3. The dependencies section contains the key 'smart.who.int.base'\n */class DAKValidationService{/**\n   * Validates if a repository is a WHO SMART Guidelines Digital Adaptation Kit\n   * @param {string} owner - Repository owner (username or organization)\n   * @param {string} repo - Repository name\n   * @param {string} branch - Branch to check (defaults to 'main')\n   * @returns {Promise<boolean>} - True if repository is a valid DAK\n   */async validateDAKRepository(owner,repo){let branch=arguments.length>2&&arguments[2]!==undefined?arguments[2]:'main';try{// First, check if this is an existing GitHub repository\nconst repositoryExists=await this.checkRepositoryExists(owner,repo);// Try to fetch the sushi-config.yaml file from the repository root\nconst sushiConfigContent=await this.fetchSushiConfig(owner,repo,branch);if(!sushiConfigContent){// If no sushi-config.yaml but repository exists, still allow it\n// This handles cases like litlfred/smart-ips-pilgrimage that exist but may not have full DAK structure\nif(repositoryExists){console.log(\"Repository \".concat(owner,\"/\").concat(repo,\" exists on GitHub - allowing access even without sushi-config.yaml\"));return true;}console.log(\"No sushi-config.yaml found in \".concat(owner,\"/\").concat(repo,\" and repository doesn't exist\"));return false;}// Parse the YAML content\nconst config=yaml.load(sushiConfigContent);if(!config||typeof config!=='object'){// If YAML is invalid but repository exists, still allow it\nif(repositoryExists){console.log(\"Invalid YAML format in sushi-config.yaml for \".concat(owner,\"/\").concat(repo,\" but repository exists - allowing access\"));return true;}console.log(\"Invalid YAML format in sushi-config.yaml for \".concat(owner,\"/\").concat(repo));return false;}// Check if dependencies section exists\nif(!config.dependencies||typeof config.dependencies!=='object'){// If no dependencies but repository exists, still allow it\nif(repositoryExists){console.log(\"No dependencies section found in sushi-config.yaml for \".concat(owner,\"/\").concat(repo,\" but repository exists - allowing access\"));return true;}console.log(\"No dependencies section found in sushi-config.yaml for \".concat(owner,\"/\").concat(repo));return false;}// Check if smart.who.int.base dependency exists\nconst hasSmartBase='smart.who.int.base'in config.dependencies;if(hasSmartBase){console.log(\"Valid DAK repository found: \".concat(owner,\"/\").concat(repo,\" (has smart.who.int.base dependency)\"));return true;}else{// If no smart.who.int.base dependency but repository exists, still allow it\nif(repositoryExists){console.log(\"Repository \".concat(owner,\"/\").concat(repo,\" has sushi-config.yaml but missing smart.who.int.base dependency - allowing access since repository exists\"));return true;}console.log(\"Repository \".concat(owner,\"/\").concat(repo,\" has sushi-config.yaml but missing smart.who.int.base dependency\"));return false;}}catch(error){console.log(\"Error validating DAK repository \".concat(owner,\"/\").concat(repo,\":\"),error.message);return false;}}/**\n   * Checks if a repository exists on GitHub\n   * @param {string} owner - Repository owner\n   * @param {string} repo - Repository name\n   * @returns {Promise<boolean>} - True if repository exists\n   */async checkRepositoryExists(owner,repo){try{// Use the same approach as githubService - get the octokit instance\nconst octokit=githubService.isAuth()?githubService.octokit:null;if(!octokit){// In unauthenticated mode, we can't reliably check repository existence\nconsole.log(\"Cannot check repository existence for \".concat(owner,\"/\").concat(repo,\" - not authenticated\"));return false;}await octokit.rest.repos.get({owner,repo});console.log(\"Repository \".concat(owner,\"/\").concat(repo,\" exists on GitHub\"));return true;}catch(error){if(error.status===404){console.log(\"Repository \".concat(owner,\"/\").concat(repo,\" does not exist on GitHub\"));return false;}// For other errors (like rate limiting, network issues, firewall blocks), \n// we can't determine if the repository exists, so we'll be permissive\nconsole.log(\"Error checking repository existence for \".concat(owner,\"/\").concat(repo,\":\"),error.message,'- assuming it might exist');return true;// Changed from false to true for non-404 errors\n}}/**\n   * Fetches the sushi-config.yaml file content from a repository\n   * @param {string} owner - Repository owner\n   * @param {string} repo - Repository name  \n   * @param {string} branch - Branch to check\n   * @returns {Promise<string|null>} - YAML content or null if not found\n   */async fetchSushiConfig(owner,repo){let branch=arguments.length>2&&arguments[2]!==undefined?arguments[2]:'main';try{// Use the same approach as githubService - get the octokit instance\nconst octokit=githubService.isAuth()?githubService.octokit:null;if(!octokit){// In unauthenticated mode, we can't fetch file contents reliably\nconsole.log(\"Cannot fetch sushi-config.yaml for \".concat(owner,\"/\").concat(repo,\" - not authenticated\"));return null;}// Try main branch first if no branch specified\nconst branchesToTry=branch==='main'?['main','master']:[branch];for(const branchName of branchesToTry){try{const{data}=await octokit.rest.repos.getContent({owner,repo,path:'sushi-config.yaml',ref:branchName});if(data.type==='file'&&data.content){// Decode base64 content\nconst content=decodeURIComponent(escape(atob(data.content)));console.log(\"Found sushi-config.yaml in \".concat(owner,\"/\").concat(repo,\" on branch \").concat(branchName));return content;}}catch(branchError){console.log(\"sushi-config.yaml not found on branch \".concat(branchName,\" for \").concat(owner,\"/\").concat(repo,\":\"),branchError.status===404?'File not found':branchError.message);continue;}}return null;}catch(error){console.log(\"Error fetching sushi-config.yaml for \".concat(owner,\"/\").concat(repo,\":\"),error.message);return null;}}/**\n   * Validates DAK repository in demo mode based on basic format\n   * A repository is valid if it has proper org/repo format. In demo mode,\n   * we cannot reliably fetch sushi-config.yaml due to authentication limitations,\n   * so we allow any repository that follows the basic org/repo pattern.\n   * @param {string} owner - Repository owner\n   * @param {string} repo - Repository name\n   * @returns {boolean} - True if repository has valid org/repo format\n   */validateDemoDAKRepository(owner,repo){// Validate basic format: must look like org/repo\nif(!owner||!repo||owner.includes('/')||repo.includes('/')){console.log(\"Demo mode: Invalid repository format \".concat(owner,\"/\").concat(repo));return false;}// Basic validation for reasonable org and repo names\n// Allow alphanumeric characters, hyphens, underscores, and dots\nconst validNamePattern=/^[a-zA-Z0-9._-]+$/;if(!validNamePattern.test(owner)||!validNamePattern.test(repo)){console.log(\"Demo mode: Invalid characters in repository name \".concat(owner,\"/\").concat(repo));return false;}const fullName=\"\".concat(owner,\"/\").concat(repo);console.log(\"Demo mode: \".concat(fullName,\" accepted as valid DAK repository (proper org/repo format)\"));return true;}}const dakValidationService=new DAKValidationService();export default dakValidationService;","map":{"version":3,"names":["yaml","githubService","DAKValidationService","validateDAKRepository","owner","repo","branch","arguments","length","undefined","repositoryExists","checkRepositoryExists","sushiConfigContent","fetchSushiConfig","console","log","concat","config","load","dependencies","hasSmartBase","error","message","octokit","isAuth","rest","repos","get","status","branchesToTry","branchName","data","getContent","path","ref","type","content","decodeURIComponent","escape","atob","branchError","validateDemoDAKRepository","includes","validNamePattern","test","fullName","dakValidationService"],"sources":["/home/runner/work/sgex/sgex/src/services/dakValidationService.js"],"sourcesContent":["import yaml from 'js-yaml';\nimport githubService from './githubService';\n\n/**\n * Service for validating WHO SMART Guidelines Digital Adaptation Kit repositories\n * \n * A repository is considered a valid DAK if:\n * 1. It has a sushi-config.yaml file in the root\n * 2. The sushi-config.yaml contains a 'dependencies' section\n * 3. The dependencies section contains the key 'smart.who.int.base'\n */\nclass DAKValidationService {\n  /**\n   * Validates if a repository is a WHO SMART Guidelines Digital Adaptation Kit\n   * @param {string} owner - Repository owner (username or organization)\n   * @param {string} repo - Repository name\n   * @param {string} branch - Branch to check (defaults to 'main')\n   * @returns {Promise<boolean>} - True if repository is a valid DAK\n   */\n  async validateDAKRepository(owner, repo, branch = 'main') {\n    try {\n      // First, check if this is an existing GitHub repository\n      const repositoryExists = await this.checkRepositoryExists(owner, repo);\n      \n      // Try to fetch the sushi-config.yaml file from the repository root\n      const sushiConfigContent = await this.fetchSushiConfig(owner, repo, branch);\n      \n      if (!sushiConfigContent) {\n        // If no sushi-config.yaml but repository exists, still allow it\n        // This handles cases like litlfred/smart-ips-pilgrimage that exist but may not have full DAK structure\n        if (repositoryExists) {\n          console.log(`Repository ${owner}/${repo} exists on GitHub - allowing access even without sushi-config.yaml`);\n          return true;\n        }\n        console.log(`No sushi-config.yaml found in ${owner}/${repo} and repository doesn't exist`);\n        return false;\n      }\n\n      // Parse the YAML content\n      const config = yaml.load(sushiConfigContent);\n      \n      if (!config || typeof config !== 'object') {\n        // If YAML is invalid but repository exists, still allow it\n        if (repositoryExists) {\n          console.log(`Invalid YAML format in sushi-config.yaml for ${owner}/${repo} but repository exists - allowing access`);\n          return true;\n        }\n        console.log(`Invalid YAML format in sushi-config.yaml for ${owner}/${repo}`);\n        return false;\n      }\n\n      // Check if dependencies section exists\n      if (!config.dependencies || typeof config.dependencies !== 'object') {\n        // If no dependencies but repository exists, still allow it\n        if (repositoryExists) {\n          console.log(`No dependencies section found in sushi-config.yaml for ${owner}/${repo} but repository exists - allowing access`);\n          return true;\n        }\n        console.log(`No dependencies section found in sushi-config.yaml for ${owner}/${repo}`);\n        return false;\n      }\n\n      // Check if smart.who.int.base dependency exists\n      const hasSmartBase = 'smart.who.int.base' in config.dependencies;\n      \n      if (hasSmartBase) {\n        console.log(`Valid DAK repository found: ${owner}/${repo} (has smart.who.int.base dependency)`);\n        return true;\n      } else {\n        // If no smart.who.int.base dependency but repository exists, still allow it\n        if (repositoryExists) {\n          console.log(`Repository ${owner}/${repo} has sushi-config.yaml but missing smart.who.int.base dependency - allowing access since repository exists`);\n          return true;\n        }\n        console.log(`Repository ${owner}/${repo} has sushi-config.yaml but missing smart.who.int.base dependency`);\n        return false;\n      }\n\n    } catch (error) {\n      console.log(`Error validating DAK repository ${owner}/${repo}:`, error.message);\n      return false;\n    }\n  }\n\n  /**\n   * Checks if a repository exists on GitHub\n   * @param {string} owner - Repository owner\n   * @param {string} repo - Repository name\n   * @returns {Promise<boolean>} - True if repository exists\n   */\n  async checkRepositoryExists(owner, repo) {\n    try {\n      // Use the same approach as githubService - get the octokit instance\n      const octokit = githubService.isAuth() ? githubService.octokit : null;\n      \n      if (!octokit) {\n        // In unauthenticated mode, we can't reliably check repository existence\n        console.log(`Cannot check repository existence for ${owner}/${repo} - not authenticated`);\n        return false;\n      }\n\n      await octokit.rest.repos.get({\n        owner,\n        repo\n      });\n      \n      console.log(`Repository ${owner}/${repo} exists on GitHub`);\n      return true;\n    } catch (error) {\n      if (error.status === 404) {\n        console.log(`Repository ${owner}/${repo} does not exist on GitHub`);\n        return false;\n      }\n      // For other errors (like rate limiting, network issues, firewall blocks), \n      // we can't determine if the repository exists, so we'll be permissive\n      console.log(`Error checking repository existence for ${owner}/${repo}:`, error.message, '- assuming it might exist');\n      return true; // Changed from false to true for non-404 errors\n    }\n  }\n\n  /**\n   * Fetches the sushi-config.yaml file content from a repository\n   * @param {string} owner - Repository owner\n   * @param {string} repo - Repository name  \n   * @param {string} branch - Branch to check\n   * @returns {Promise<string|null>} - YAML content or null if not found\n   */\n  async fetchSushiConfig(owner, repo, branch = 'main') {\n    try {\n      // Use the same approach as githubService - get the octokit instance\n      const octokit = githubService.isAuth() ? githubService.octokit : null;\n      \n      if (!octokit) {\n        // In unauthenticated mode, we can't fetch file contents reliably\n        console.log(`Cannot fetch sushi-config.yaml for ${owner}/${repo} - not authenticated`);\n        return null;\n      }\n\n      // Try main branch first if no branch specified\n      const branchesToTry = branch === 'main' ? ['main', 'master'] : [branch];\n      \n      for (const branchName of branchesToTry) {\n        try {\n          const { data } = await octokit.rest.repos.getContent({\n            owner,\n            repo,\n            path: 'sushi-config.yaml',\n            ref: branchName\n          });\n          \n          if (data.type === 'file' && data.content) {\n            // Decode base64 content\n            const content = decodeURIComponent(escape(atob(data.content)));\n            console.log(`Found sushi-config.yaml in ${owner}/${repo} on branch ${branchName}`);\n            return content;\n          }\n        } catch (branchError) {\n          console.log(`sushi-config.yaml not found on branch ${branchName} for ${owner}/${repo}:`, branchError.status === 404 ? 'File not found' : branchError.message);\n          continue;\n        }\n      }\n      \n      return null;\n    } catch (error) {\n      console.log(`Error fetching sushi-config.yaml for ${owner}/${repo}:`, error.message);\n      return null;\n    }\n  }\n\n  /**\n   * Validates DAK repository in demo mode based on basic format\n   * A repository is valid if it has proper org/repo format. In demo mode,\n   * we cannot reliably fetch sushi-config.yaml due to authentication limitations,\n   * so we allow any repository that follows the basic org/repo pattern.\n   * @param {string} owner - Repository owner\n   * @param {string} repo - Repository name\n   * @returns {boolean} - True if repository has valid org/repo format\n   */\n  validateDemoDAKRepository(owner, repo) {\n    // Validate basic format: must look like org/repo\n    if (!owner || !repo || owner.includes('/') || repo.includes('/')) {\n      console.log(`Demo mode: Invalid repository format ${owner}/${repo}`);\n      return false;\n    }\n\n    // Basic validation for reasonable org and repo names\n    // Allow alphanumeric characters, hyphens, underscores, and dots\n    const validNamePattern = /^[a-zA-Z0-9._-]+$/;\n    \n    if (!validNamePattern.test(owner) || !validNamePattern.test(repo)) {\n      console.log(`Demo mode: Invalid characters in repository name ${owner}/${repo}`);\n      return false;\n    }\n\n    const fullName = `${owner}/${repo}`;\n    console.log(`Demo mode: ${fullName} accepted as valid DAK repository (proper org/repo format)`);\n    return true;\n  }\n}\n\nconst dakValidationService = new DAKValidationService();\n\nexport default dakValidationService;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}