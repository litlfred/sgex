{"ast":null,"code":"import { forEach } from 'min-dash';\nimport { getMovedSourceAnchor, getMovedTargetAnchor } from './AnchorsHelper';\nimport MoveClosure from './MoveClosure';\n\n/**\n * @typedef {import('../../../../core/Types').ElementLike} Element\n * @typedef {import('../../../../core/Types').ShapeLike} Shape\n *\n * @typedef {import('../../../../util/Types').Point} Point\n *\n * @typedef {import('../../Modeling').default} Modeling\n */\n\n/**\n * A helper that is able to carry out serialized move\n * operations on multiple elements.\n *\n * @param {Modeling} modeling\n */\nexport default function MoveHelper(modeling) {\n  this._modeling = modeling;\n}\n\n/**\n * Move the specified elements and all children by the given delta.\n *\n * This moves all enclosed connections, too and layouts all affected\n * external connections.\n *\n * @template {Element} T\n *\n * @param {T[]} elements\n * @param {Point} delta\n * @param {Shape} newParent The new parent of all elements that are not nested.\n *\n * @return {T[]}\n */\nMoveHelper.prototype.moveRecursive = function (elements, delta, newParent) {\n  if (!elements) {\n    return [];\n  } else {\n    return this.moveClosure(this.getClosure(elements), delta, newParent);\n  }\n};\n\n/**\n * Move the given closure of elmements.\n *\n * @param {Object} closure\n * @param {Point} delta\n * @param {Shape} [newParent]\n * @param {Shape} [newHost]\n */\nMoveHelper.prototype.moveClosure = function (closure, delta, newParent, newHost, primaryShape) {\n  var modeling = this._modeling;\n  var allShapes = closure.allShapes,\n    allConnections = closure.allConnections,\n    enclosedConnections = closure.enclosedConnections,\n    topLevel = closure.topLevel,\n    keepParent = false;\n  if (primaryShape && primaryShape.parent === newParent) {\n    keepParent = true;\n  }\n\n  // move all shapes\n  forEach(allShapes, function (shape) {\n    // move the element according to the given delta\n    modeling.moveShape(shape, delta, topLevel[shape.id] && !keepParent && newParent, {\n      recurse: false,\n      layout: false\n    });\n  });\n\n  // move all child connections / layout external connections\n  forEach(allConnections, function (c) {\n    var sourceMoved = !!allShapes[c.source.id],\n      targetMoved = !!allShapes[c.target.id];\n    if (enclosedConnections[c.id] && sourceMoved && targetMoved) {\n      modeling.moveConnection(c, delta, topLevel[c.id] && !keepParent && newParent);\n    } else {\n      modeling.layoutConnection(c, {\n        connectionStart: sourceMoved && getMovedSourceAnchor(c, c.source, delta),\n        connectionEnd: targetMoved && getMovedTargetAnchor(c, c.target, delta)\n      });\n    }\n  });\n};\n\n/**\n * Returns the closure for the selected elements\n *\n * @param {Element[]} elements\n *\n * @return {MoveClosure}\n */\nMoveHelper.prototype.getClosure = function (elements) {\n  return new MoveClosure().addAll(elements, true);\n};","map":{"version":3,"names":["forEach","getMovedSourceAnchor","getMovedTargetAnchor","MoveClosure","MoveHelper","modeling","_modeling","prototype","moveRecursive","elements","delta","newParent","moveClosure","getClosure","closure","newHost","primaryShape","allShapes","allConnections","enclosedConnections","topLevel","keepParent","parent","shape","moveShape","id","recurse","layout","c","sourceMoved","source","targetMoved","target","moveConnection","layoutConnection","connectionStart","connectionEnd","addAll"],"sources":["/home/runner/work/sgex/sgex/node_modules/diagram-js/lib/features/modeling/cmd/helper/MoveHelper.js"],"sourcesContent":["import {\n  forEach\n} from 'min-dash';\n\nimport {\n  getMovedSourceAnchor,\n  getMovedTargetAnchor\n} from './AnchorsHelper';\n\nimport MoveClosure from './MoveClosure';\n\n/**\n * @typedef {import('../../../../core/Types').ElementLike} Element\n * @typedef {import('../../../../core/Types').ShapeLike} Shape\n *\n * @typedef {import('../../../../util/Types').Point} Point\n *\n * @typedef {import('../../Modeling').default} Modeling\n */\n\n/**\n * A helper that is able to carry out serialized move\n * operations on multiple elements.\n *\n * @param {Modeling} modeling\n */\nexport default function MoveHelper(modeling) {\n  this._modeling = modeling;\n}\n\n/**\n * Move the specified elements and all children by the given delta.\n *\n * This moves all enclosed connections, too and layouts all affected\n * external connections.\n *\n * @template {Element} T\n *\n * @param {T[]} elements\n * @param {Point} delta\n * @param {Shape} newParent The new parent of all elements that are not nested.\n *\n * @return {T[]}\n */\nMoveHelper.prototype.moveRecursive = function(elements, delta, newParent) {\n  if (!elements) {\n    return [];\n  } else {\n    return this.moveClosure(this.getClosure(elements), delta, newParent);\n  }\n};\n\n/**\n * Move the given closure of elmements.\n *\n * @param {Object} closure\n * @param {Point} delta\n * @param {Shape} [newParent]\n * @param {Shape} [newHost]\n */\nMoveHelper.prototype.moveClosure = function(closure, delta, newParent, newHost, primaryShape) {\n  var modeling = this._modeling;\n\n  var allShapes = closure.allShapes,\n      allConnections = closure.allConnections,\n      enclosedConnections = closure.enclosedConnections,\n      topLevel = closure.topLevel,\n      keepParent = false;\n\n  if (primaryShape && primaryShape.parent === newParent) {\n    keepParent = true;\n  }\n\n  // move all shapes\n  forEach(allShapes, function(shape) {\n\n    // move the element according to the given delta\n    modeling.moveShape(shape, delta, topLevel[shape.id] && !keepParent && newParent, {\n      recurse: false,\n      layout: false\n    });\n  });\n\n  // move all child connections / layout external connections\n  forEach(allConnections, function(c) {\n\n    var sourceMoved = !!allShapes[c.source.id],\n        targetMoved = !!allShapes[c.target.id];\n\n    if (enclosedConnections[c.id] && sourceMoved && targetMoved) {\n      modeling.moveConnection(c, delta, topLevel[c.id] && !keepParent && newParent);\n    } else {\n      modeling.layoutConnection(c, {\n        connectionStart: sourceMoved && getMovedSourceAnchor(c, c.source, delta),\n        connectionEnd: targetMoved && getMovedTargetAnchor(c, c.target, delta)\n      });\n    }\n  });\n};\n\n/**\n * Returns the closure for the selected elements\n *\n * @param {Element[]} elements\n *\n * @return {MoveClosure}\n */\nMoveHelper.prototype.getClosure = function(elements) {\n  return new MoveClosure().addAll(elements, true);\n};"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}