{"ast":null,"code":"import { add as collectionAdd, indexOf as collectionIdx } from '../../../util/Collections';\nimport { saveClear } from '../../../util/Removal';\nimport { isConnection } from '../../../util/ModelUtil';\n\n/**\n * @typedef {import('../../../core/Canvas').default} Canvas\n * @typedef {import('../Modeling').default} Modeling\n */\n\n/**\n * A handler that implements reversible deletion of shapes.\n *\n * @param {Canvas} canvas\n * @param {Modeling} modeling\n */\nexport default function DeleteShapeHandler(canvas, modeling) {\n  this._canvas = canvas;\n  this._modeling = modeling;\n}\nDeleteShapeHandler.$inject = ['canvas', 'modeling'];\n\n/**\n * - Remove connections\n * - Remove all direct children\n */\nDeleteShapeHandler.prototype.preExecute = function (context) {\n  var modeling = this._modeling;\n  var shape = context.shape;\n\n  // remove connections\n  saveClear(shape.incoming, function (connection) {\n    // To make sure that the connection isn't removed twice\n    // For example if a container is removed\n    modeling.removeConnection(connection, {\n      nested: true\n    });\n  });\n  saveClear(shape.outgoing, function (connection) {\n    modeling.removeConnection(connection, {\n      nested: true\n    });\n  });\n\n  // remove child shapes and connections\n  saveClear(shape.children, function (child) {\n    if (isConnection(child)) {\n      modeling.removeConnection(child, {\n        nested: true\n      });\n    } else {\n      modeling.removeShape(child, {\n        nested: true\n      });\n    }\n  });\n};\n\n/**\n * Remove shape and remember the parent\n */\nDeleteShapeHandler.prototype.execute = function (context) {\n  var canvas = this._canvas;\n  var shape = context.shape,\n    oldParent = shape.parent;\n  context.oldParent = oldParent;\n\n  // remove containment\n  context.oldParentIndex = collectionIdx(oldParent.children, shape);\n\n  // remove shape\n  canvas.removeShape(shape);\n  return shape;\n};\n\n/**\n * Command revert implementation\n */\nDeleteShapeHandler.prototype.revert = function (context) {\n  var canvas = this._canvas;\n  var shape = context.shape,\n    oldParent = context.oldParent,\n    oldParentIndex = context.oldParentIndex;\n\n  // restore containment\n  collectionAdd(oldParent.children, shape, oldParentIndex);\n  canvas.addShape(shape, oldParent);\n  return shape;\n};","map":{"version":3,"names":["add","collectionAdd","indexOf","collectionIdx","saveClear","isConnection","DeleteShapeHandler","canvas","modeling","_canvas","_modeling","$inject","prototype","preExecute","context","shape","incoming","connection","removeConnection","nested","outgoing","children","child","removeShape","execute","oldParent","parent","oldParentIndex","revert","addShape"],"sources":["/home/runner/work/sgex/sgex/node_modules/diagram-js/lib/features/modeling/cmd/DeleteShapeHandler.js"],"sourcesContent":["import {\n  add as collectionAdd,\n  indexOf as collectionIdx\n} from '../../../util/Collections';\n\nimport { saveClear } from '../../../util/Removal';\n\nimport { isConnection } from '../../../util/ModelUtil';\n\n/**\n * @typedef {import('../../../core/Canvas').default} Canvas\n * @typedef {import('../Modeling').default} Modeling\n */\n\n/**\n * A handler that implements reversible deletion of shapes.\n *\n * @param {Canvas} canvas\n * @param {Modeling} modeling\n */\nexport default function DeleteShapeHandler(canvas, modeling) {\n  this._canvas = canvas;\n  this._modeling = modeling;\n}\n\nDeleteShapeHandler.$inject = [ 'canvas', 'modeling' ];\n\n\n/**\n * - Remove connections\n * - Remove all direct children\n */\nDeleteShapeHandler.prototype.preExecute = function(context) {\n\n  var modeling = this._modeling;\n\n  var shape = context.shape;\n\n  // remove connections\n  saveClear(shape.incoming, function(connection) {\n\n    // To make sure that the connection isn't removed twice\n    // For example if a container is removed\n    modeling.removeConnection(connection, { nested: true });\n  });\n\n  saveClear(shape.outgoing, function(connection) {\n    modeling.removeConnection(connection, { nested: true });\n  });\n\n  // remove child shapes and connections\n  saveClear(shape.children, function(child) {\n    if (isConnection(child)) {\n      modeling.removeConnection(child, { nested: true });\n    } else {\n      modeling.removeShape(child, { nested: true });\n    }\n  });\n};\n\n/**\n * Remove shape and remember the parent\n */\nDeleteShapeHandler.prototype.execute = function(context) {\n  var canvas = this._canvas;\n\n  var shape = context.shape,\n      oldParent = shape.parent;\n\n  context.oldParent = oldParent;\n\n  // remove containment\n  context.oldParentIndex = collectionIdx(oldParent.children, shape);\n\n  // remove shape\n  canvas.removeShape(shape);\n\n  return shape;\n};\n\n\n/**\n * Command revert implementation\n */\nDeleteShapeHandler.prototype.revert = function(context) {\n\n  var canvas = this._canvas;\n\n  var shape = context.shape,\n      oldParent = context.oldParent,\n      oldParentIndex = context.oldParentIndex;\n\n  // restore containment\n  collectionAdd(oldParent.children, shape, oldParentIndex);\n\n  canvas.addShape(shape, oldParent);\n\n  return shape;\n};\n"],"mappings":"AAAA,SACEA,GAAG,IAAIC,aAAa,EACpBC,OAAO,IAAIC,aAAa,QACnB,2BAA2B;AAElC,SAASC,SAAS,QAAQ,uBAAuB;AAEjD,SAASC,YAAY,QAAQ,yBAAyB;;AAEtD;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,SAASC,kBAAkBA,CAACC,MAAM,EAAEC,QAAQ,EAAE;EAC3D,IAAI,CAACC,OAAO,GAAGF,MAAM;EACrB,IAAI,CAACG,SAAS,GAAGF,QAAQ;AAC3B;AAEAF,kBAAkB,CAACK,OAAO,GAAG,CAAE,QAAQ,EAAE,UAAU,CAAE;;AAGrD;AACA;AACA;AACA;AACAL,kBAAkB,CAACM,SAAS,CAACC,UAAU,GAAG,UAASC,OAAO,EAAE;EAE1D,IAAIN,QAAQ,GAAG,IAAI,CAACE,SAAS;EAE7B,IAAIK,KAAK,GAAGD,OAAO,CAACC,KAAK;;EAEzB;EACAX,SAAS,CAACW,KAAK,CAACC,QAAQ,EAAE,UAASC,UAAU,EAAE;IAE7C;IACA;IACAT,QAAQ,CAACU,gBAAgB,CAACD,UAAU,EAAE;MAAEE,MAAM,EAAE;IAAK,CAAC,CAAC;EACzD,CAAC,CAAC;EAEFf,SAAS,CAACW,KAAK,CAACK,QAAQ,EAAE,UAASH,UAAU,EAAE;IAC7CT,QAAQ,CAACU,gBAAgB,CAACD,UAAU,EAAE;MAAEE,MAAM,EAAE;IAAK,CAAC,CAAC;EACzD,CAAC,CAAC;;EAEF;EACAf,SAAS,CAACW,KAAK,CAACM,QAAQ,EAAE,UAASC,KAAK,EAAE;IACxC,IAAIjB,YAAY,CAACiB,KAAK,CAAC,EAAE;MACvBd,QAAQ,CAACU,gBAAgB,CAACI,KAAK,EAAE;QAAEH,MAAM,EAAE;MAAK,CAAC,CAAC;IACpD,CAAC,MAAM;MACLX,QAAQ,CAACe,WAAW,CAACD,KAAK,EAAE;QAAEH,MAAM,EAAE;MAAK,CAAC,CAAC;IAC/C;EACF,CAAC,CAAC;AACJ,CAAC;;AAED;AACA;AACA;AACAb,kBAAkB,CAACM,SAAS,CAACY,OAAO,GAAG,UAASV,OAAO,EAAE;EACvD,IAAIP,MAAM,GAAG,IAAI,CAACE,OAAO;EAEzB,IAAIM,KAAK,GAAGD,OAAO,CAACC,KAAK;IACrBU,SAAS,GAAGV,KAAK,CAACW,MAAM;EAE5BZ,OAAO,CAACW,SAAS,GAAGA,SAAS;;EAE7B;EACAX,OAAO,CAACa,cAAc,GAAGxB,aAAa,CAACsB,SAAS,CAACJ,QAAQ,EAAEN,KAAK,CAAC;;EAEjE;EACAR,MAAM,CAACgB,WAAW,CAACR,KAAK,CAAC;EAEzB,OAAOA,KAAK;AACd,CAAC;;AAGD;AACA;AACA;AACAT,kBAAkB,CAACM,SAAS,CAACgB,MAAM,GAAG,UAASd,OAAO,EAAE;EAEtD,IAAIP,MAAM,GAAG,IAAI,CAACE,OAAO;EAEzB,IAAIM,KAAK,GAAGD,OAAO,CAACC,KAAK;IACrBU,SAAS,GAAGX,OAAO,CAACW,SAAS;IAC7BE,cAAc,GAAGb,OAAO,CAACa,cAAc;;EAE3C;EACA1B,aAAa,CAACwB,SAAS,CAACJ,QAAQ,EAAEN,KAAK,EAAEY,cAAc,CAAC;EAExDpB,MAAM,CAACsB,QAAQ,CAACd,KAAK,EAAEU,SAAS,CAAC;EAEjC,OAAOV,KAAK;AACd,CAAC","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}