{"ast":null,"code":"import { getChildLanes, LANE_INDENTATION } from '../util/LaneUtil';\nimport { isHorizontal } from '../../../util/DiUtil';\n\n/**\n * @typedef {import('diagram-js/lib/command/CommandHandler').default} CommandHandler\n *\n * @typedef {import('../Modeling').default} Modeling\n */\n\n/**\n * A handler that splits a lane into a number of sub-lanes,\n * creating new sub lanes, if necessary.\n *\n * @implements {CommandHandler}\n *\n * @param {Modeling} modeling\n */\nexport default function SplitLaneHandler(modeling) {\n  this._modeling = modeling;\n}\nSplitLaneHandler.$inject = ['modeling'];\nSplitLaneHandler.prototype.preExecute = function (context) {\n  var modeling = this._modeling;\n  var shape = context.shape,\n    newLanesCount = context.count;\n  var childLanes = getChildLanes(shape),\n    existingLanesCount = childLanes.length;\n  if (existingLanesCount > newLanesCount) {\n    throw new Error(\"more than <\".concat(newLanesCount, \"> child lanes\"));\n  }\n  var isHorizontalLane = isHorizontal(shape);\n  var laneBaseSize = isHorizontalLane ? shape.height : shape.width;\n  var newLanesSize = Math.round(laneBaseSize / newLanesCount);\n\n  // Iterate from first to last in child lane order,\n  // resizing existing lanes and creating new ones\n  // so that they split the parent proportionally.\n  //\n  // Due to rounding related errors, the last lane\n  // needs to take up all the remaining space.\n  var laneSize, laneBounds, newLaneAttrs, idx;\n  for (idx = 0; idx < newLanesCount; idx++) {\n    // if last lane\n    if (idx === newLanesCount - 1) {\n      laneSize = laneBaseSize - newLanesSize * idx;\n    } else {\n      laneSize = newLanesSize;\n    }\n    laneBounds = isHorizontalLane ? {\n      x: shape.x + LANE_INDENTATION,\n      y: shape.y + idx * newLanesSize,\n      width: shape.width - LANE_INDENTATION,\n      height: laneSize\n    } : {\n      x: shape.x + idx * newLanesSize,\n      y: shape.y + LANE_INDENTATION,\n      width: laneSize,\n      height: shape.height - LANE_INDENTATION\n    };\n    if (idx < existingLanesCount) {\n      // resize existing lane\n      modeling.resizeShape(childLanes[idx], laneBounds);\n    } else {\n      // create a new lane at position\n      newLaneAttrs = {\n        type: 'bpmn:Lane',\n        isHorizontal: isHorizontalLane\n      };\n      modeling.createShape(newLaneAttrs, laneBounds, shape);\n    }\n  }\n};","map":{"version":3,"names":["getChildLanes","LANE_INDENTATION","isHorizontal","SplitLaneHandler","modeling","_modeling","$inject","prototype","preExecute","context","shape","newLanesCount","count","childLanes","existingLanesCount","length","Error","concat","isHorizontalLane","laneBaseSize","height","width","newLanesSize","Math","round","laneSize","laneBounds","newLaneAttrs","idx","x","y","resizeShape","type","createShape"],"sources":["/home/runner/work/sgex/sgex/node_modules/bpmn-js/lib/features/modeling/cmd/SplitLaneHandler.js"],"sourcesContent":["import {\n  getChildLanes,\n  LANE_INDENTATION\n} from '../util/LaneUtil';\n\nimport {\n  isHorizontal\n} from '../../../util/DiUtil';\n\n/**\n * @typedef {import('diagram-js/lib/command/CommandHandler').default} CommandHandler\n *\n * @typedef {import('../Modeling').default} Modeling\n */\n\n/**\n * A handler that splits a lane into a number of sub-lanes,\n * creating new sub lanes, if necessary.\n *\n * @implements {CommandHandler}\n *\n * @param {Modeling} modeling\n */\nexport default function SplitLaneHandler(modeling) {\n  this._modeling = modeling;\n}\n\nSplitLaneHandler.$inject = [\n  'modeling'\n];\n\n\nSplitLaneHandler.prototype.preExecute = function(context) {\n\n  var modeling = this._modeling;\n\n  var shape = context.shape,\n      newLanesCount = context.count;\n\n  var childLanes = getChildLanes(shape),\n      existingLanesCount = childLanes.length;\n\n  if (existingLanesCount > newLanesCount) {\n    throw new Error(`more than <${ newLanesCount }> child lanes`);\n  }\n\n  var isHorizontalLane = isHorizontal(shape);\n\n  var laneBaseSize = isHorizontalLane ? shape.height : shape.width;\n  var newLanesSize = Math.round(laneBaseSize / newLanesCount);\n\n  // Iterate from first to last in child lane order,\n  // resizing existing lanes and creating new ones\n  // so that they split the parent proportionally.\n  //\n  // Due to rounding related errors, the last lane\n  // needs to take up all the remaining space.\n  var laneSize,\n      laneBounds,\n      newLaneAttrs,\n      idx;\n\n  for (idx = 0; idx < newLanesCount; idx++) {\n\n    // if last lane\n    if (idx === newLanesCount - 1) {\n      laneSize = laneBaseSize - (newLanesSize * idx);\n    } else {\n      laneSize = newLanesSize;\n    }\n\n    laneBounds = isHorizontalLane ? {\n      x: shape.x + LANE_INDENTATION,\n      y: shape.y + idx * newLanesSize,\n      width: shape.width - LANE_INDENTATION,\n      height: laneSize\n    } : {\n      x: shape.x + idx * newLanesSize,\n      y: shape.y + LANE_INDENTATION,\n      width: laneSize,\n      height: shape.height - LANE_INDENTATION\n    };\n\n    if (idx < existingLanesCount) {\n\n      // resize existing lane\n      modeling.resizeShape(childLanes[idx], laneBounds);\n    } else {\n\n      // create a new lane at position\n      newLaneAttrs = {\n        type: 'bpmn:Lane',\n        isHorizontal: isHorizontalLane\n      };\n\n      modeling.createShape(newLaneAttrs, laneBounds, shape);\n    }\n  }\n};\n"],"mappings":"AAAA,SACEA,aAAa,EACbC,gBAAgB,QACX,kBAAkB;AAEzB,SACEC,YAAY,QACP,sBAAsB;;AAE7B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,SAASC,gBAAgBA,CAACC,QAAQ,EAAE;EACjD,IAAI,CAACC,SAAS,GAAGD,QAAQ;AAC3B;AAEAD,gBAAgB,CAACG,OAAO,GAAG,CACzB,UAAU,CACX;AAGDH,gBAAgB,CAACI,SAAS,CAACC,UAAU,GAAG,UAASC,OAAO,EAAE;EAExD,IAAIL,QAAQ,GAAG,IAAI,CAACC,SAAS;EAE7B,IAAIK,KAAK,GAAGD,OAAO,CAACC,KAAK;IACrBC,aAAa,GAAGF,OAAO,CAACG,KAAK;EAEjC,IAAIC,UAAU,GAAGb,aAAa,CAACU,KAAK,CAAC;IACjCI,kBAAkB,GAAGD,UAAU,CAACE,MAAM;EAE1C,IAAID,kBAAkB,GAAGH,aAAa,EAAE;IACtC,MAAM,IAAIK,KAAK,eAAAC,MAAA,CAAgBN,aAAa,kBAAgB,CAAC;EAC/D;EAEA,IAAIO,gBAAgB,GAAGhB,YAAY,CAACQ,KAAK,CAAC;EAE1C,IAAIS,YAAY,GAAGD,gBAAgB,GAAGR,KAAK,CAACU,MAAM,GAAGV,KAAK,CAACW,KAAK;EAChE,IAAIC,YAAY,GAAGC,IAAI,CAACC,KAAK,CAACL,YAAY,GAAGR,aAAa,CAAC;;EAE3D;EACA;EACA;EACA;EACA;EACA;EACA,IAAIc,QAAQ,EACRC,UAAU,EACVC,YAAY,EACZC,GAAG;EAEP,KAAKA,GAAG,GAAG,CAAC,EAAEA,GAAG,GAAGjB,aAAa,EAAEiB,GAAG,EAAE,EAAE;IAExC;IACA,IAAIA,GAAG,KAAKjB,aAAa,GAAG,CAAC,EAAE;MAC7Bc,QAAQ,GAAGN,YAAY,GAAIG,YAAY,GAAGM,GAAI;IAChD,CAAC,MAAM;MACLH,QAAQ,GAAGH,YAAY;IACzB;IAEAI,UAAU,GAAGR,gBAAgB,GAAG;MAC9BW,CAAC,EAAEnB,KAAK,CAACmB,CAAC,GAAG5B,gBAAgB;MAC7B6B,CAAC,EAAEpB,KAAK,CAACoB,CAAC,GAAGF,GAAG,GAAGN,YAAY;MAC/BD,KAAK,EAAEX,KAAK,CAACW,KAAK,GAAGpB,gBAAgB;MACrCmB,MAAM,EAAEK;IACV,CAAC,GAAG;MACFI,CAAC,EAAEnB,KAAK,CAACmB,CAAC,GAAGD,GAAG,GAAGN,YAAY;MAC/BQ,CAAC,EAAEpB,KAAK,CAACoB,CAAC,GAAG7B,gBAAgB;MAC7BoB,KAAK,EAAEI,QAAQ;MACfL,MAAM,EAAEV,KAAK,CAACU,MAAM,GAAGnB;IACzB,CAAC;IAED,IAAI2B,GAAG,GAAGd,kBAAkB,EAAE;MAE5B;MACAV,QAAQ,CAAC2B,WAAW,CAAClB,UAAU,CAACe,GAAG,CAAC,EAAEF,UAAU,CAAC;IACnD,CAAC,MAAM;MAEL;MACAC,YAAY,GAAG;QACbK,IAAI,EAAE,WAAW;QACjB9B,YAAY,EAAEgB;MAChB,CAAC;MAEDd,QAAQ,CAAC6B,WAAW,CAACN,YAAY,EAAED,UAAU,EAAEhB,KAAK,CAAC;IACvD;EACF;AACF,CAAC","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}