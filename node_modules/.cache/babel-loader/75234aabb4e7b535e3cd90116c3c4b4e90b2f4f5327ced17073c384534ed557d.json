{"ast":null,"code":"\"use strict\";\n\nvar _taggedTemplateLiteral = require(\"/home/runner/work/sgex/sgex/node_modules/@babel/runtime/helpers/taggedTemplateLiteral.js\").default;\nvar _templateObject, _templateObject2, _templateObject3, _templateObject4, _templateObject5;\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nconst code_1 = require(\"../code\");\nconst codegen_1 = require(\"../../compile/codegen\");\nconst names_1 = require(\"../../compile/names\");\nconst util_1 = require(\"../../compile/util\");\nconst error = {\n  message: \"must NOT have additional properties\",\n  params: _ref => {\n    let {\n      params\n    } = _ref;\n    return (0, codegen_1._)(_templateObject || (_templateObject = _taggedTemplateLiteral([\"{additionalProperty: \", \"}\"])), params.additionalProperty);\n  }\n};\nconst def = {\n  keyword: \"additionalProperties\",\n  type: [\"object\"],\n  schemaType: [\"boolean\", \"object\"],\n  allowUndefined: true,\n  trackErrors: true,\n  error,\n  code(cxt) {\n    const {\n      gen,\n      schema,\n      parentSchema,\n      data,\n      errsCount,\n      it\n    } = cxt;\n    /* istanbul ignore if */\n    if (!errsCount) throw new Error(\"ajv implementation error\");\n    const {\n      allErrors,\n      opts\n    } = it;\n    it.props = true;\n    if (opts.removeAdditional !== \"all\" && (0, util_1.alwaysValidSchema)(it, schema)) return;\n    const props = (0, code_1.allSchemaProperties)(parentSchema.properties);\n    const patProps = (0, code_1.allSchemaProperties)(parentSchema.patternProperties);\n    checkAdditionalProperties();\n    cxt.ok((0, codegen_1._)(_templateObject2 || (_templateObject2 = _taggedTemplateLiteral([\"\", \" === \", \"\"])), errsCount, names_1.default.errors));\n    function checkAdditionalProperties() {\n      gen.forIn(\"key\", data, key => {\n        if (!props.length && !patProps.length) additionalPropertyCode(key);else gen.if(isAdditional(key), () => additionalPropertyCode(key));\n      });\n    }\n    function isAdditional(key) {\n      let definedProp;\n      if (props.length > 8) {\n        // TODO maybe an option instead of hard-coded 8?\n        const propsSchema = (0, util_1.schemaRefOrVal)(it, parentSchema.properties, \"properties\");\n        definedProp = (0, code_1.isOwnProperty)(gen, propsSchema, key);\n      } else if (props.length) {\n        definedProp = (0, codegen_1.or)(...props.map(p => (0, codegen_1._)(_templateObject3 || (_templateObject3 = _taggedTemplateLiteral([\"\", \" === \", \"\"])), key, p)));\n      } else {\n        definedProp = codegen_1.nil;\n      }\n      if (patProps.length) {\n        definedProp = (0, codegen_1.or)(definedProp, ...patProps.map(p => (0, codegen_1._)(_templateObject4 || (_templateObject4 = _taggedTemplateLiteral([\"\", \".test(\", \")\"])), (0, code_1.usePattern)(cxt, p), key)));\n      }\n      return (0, codegen_1.not)(definedProp);\n    }\n    function deleteAdditional(key) {\n      gen.code((0, codegen_1._)(_templateObject5 || (_templateObject5 = _taggedTemplateLiteral([\"delete \", \"[\", \"]\"])), data, key));\n    }\n    function additionalPropertyCode(key) {\n      if (opts.removeAdditional === \"all\" || opts.removeAdditional && schema === false) {\n        deleteAdditional(key);\n        return;\n      }\n      if (schema === false) {\n        cxt.setParams({\n          additionalProperty: key\n        });\n        cxt.error();\n        if (!allErrors) gen.break();\n        return;\n      }\n      if (typeof schema == \"object\" && !(0, util_1.alwaysValidSchema)(it, schema)) {\n        const valid = gen.name(\"valid\");\n        if (opts.removeAdditional === \"failing\") {\n          applyAdditionalSchema(key, valid, false);\n          gen.if((0, codegen_1.not)(valid), () => {\n            cxt.reset();\n            deleteAdditional(key);\n          });\n        } else {\n          applyAdditionalSchema(key, valid);\n          if (!allErrors) gen.if((0, codegen_1.not)(valid), () => gen.break());\n        }\n      }\n    }\n    function applyAdditionalSchema(key, valid, errors) {\n      const subschema = {\n        keyword: \"additionalProperties\",\n        dataProp: key,\n        dataPropType: util_1.Type.Str\n      };\n      if (errors === false) {\n        Object.assign(subschema, {\n          compositeRule: true,\n          createErrors: false,\n          allErrors: false\n        });\n      }\n      cxt.subschema(subschema, valid);\n    }\n  }\n};\nexports.default = def;","map":{"version":3,"names":["code_1","require","codegen_1","names_1","util_1","error","message","params","_ref","_","_templateObject","_taggedTemplateLiteral","additionalProperty","def","keyword","type","schemaType","allowUndefined","trackErrors","code","cxt","gen","schema","parentSchema","data","errsCount","it","Error","allErrors","opts","props","removeAdditional","alwaysValidSchema","allSchemaProperties","properties","patProps","patternProperties","checkAdditionalProperties","ok","_templateObject2","default","errors","forIn","key","length","additionalPropertyCode","if","isAdditional","definedProp","propsSchema","schemaRefOrVal","isOwnProperty","or","map","p","_templateObject3","nil","_templateObject4","usePattern","not","deleteAdditional","_templateObject5","setParams","break","valid","name","applyAdditionalSchema","reset","subschema","dataProp","dataPropType","Type","Str","Object","assign","compositeRule","createErrors","exports"],"sources":["/home/runner/work/sgex/sgex/node_modules/ajv/lib/vocabularies/applicator/additionalProperties.ts"],"sourcesContent":["import type {\n  CodeKeywordDefinition,\n  AddedKeywordDefinition,\n  ErrorObject,\n  KeywordErrorDefinition,\n  AnySchema,\n} from \"../../types\"\nimport {allSchemaProperties, usePattern, isOwnProperty} from \"../code\"\nimport {_, nil, or, not, Code, Name} from \"../../compile/codegen\"\nimport N from \"../../compile/names\"\nimport type {SubschemaArgs} from \"../../compile/validate/subschema\"\nimport {alwaysValidSchema, schemaRefOrVal, Type} from \"../../compile/util\"\n\nexport type AdditionalPropertiesError = ErrorObject<\n  \"additionalProperties\",\n  {additionalProperty: string},\n  AnySchema\n>\n\nconst error: KeywordErrorDefinition = {\n  message: \"must NOT have additional properties\",\n  params: ({params}) => _`{additionalProperty: ${params.additionalProperty}}`,\n}\n\nconst def: CodeKeywordDefinition & AddedKeywordDefinition = {\n  keyword: \"additionalProperties\",\n  type: [\"object\"],\n  schemaType: [\"boolean\", \"object\"],\n  allowUndefined: true,\n  trackErrors: true,\n  error,\n  code(cxt) {\n    const {gen, schema, parentSchema, data, errsCount, it} = cxt\n    /* istanbul ignore if */\n    if (!errsCount) throw new Error(\"ajv implementation error\")\n    const {allErrors, opts} = it\n    it.props = true\n    if (opts.removeAdditional !== \"all\" && alwaysValidSchema(it, schema)) return\n    const props = allSchemaProperties(parentSchema.properties)\n    const patProps = allSchemaProperties(parentSchema.patternProperties)\n    checkAdditionalProperties()\n    cxt.ok(_`${errsCount} === ${N.errors}`)\n\n    function checkAdditionalProperties(): void {\n      gen.forIn(\"key\", data, (key: Name) => {\n        if (!props.length && !patProps.length) additionalPropertyCode(key)\n        else gen.if(isAdditional(key), () => additionalPropertyCode(key))\n      })\n    }\n\n    function isAdditional(key: Name): Code {\n      let definedProp: Code\n      if (props.length > 8) {\n        // TODO maybe an option instead of hard-coded 8?\n        const propsSchema = schemaRefOrVal(it, parentSchema.properties, \"properties\")\n        definedProp = isOwnProperty(gen, propsSchema as Code, key)\n      } else if (props.length) {\n        definedProp = or(...props.map((p) => _`${key} === ${p}`))\n      } else {\n        definedProp = nil\n      }\n      if (patProps.length) {\n        definedProp = or(definedProp, ...patProps.map((p) => _`${usePattern(cxt, p)}.test(${key})`))\n      }\n      return not(definedProp)\n    }\n\n    function deleteAdditional(key: Name): void {\n      gen.code(_`delete ${data}[${key}]`)\n    }\n\n    function additionalPropertyCode(key: Name): void {\n      if (opts.removeAdditional === \"all\" || (opts.removeAdditional && schema === false)) {\n        deleteAdditional(key)\n        return\n      }\n\n      if (schema === false) {\n        cxt.setParams({additionalProperty: key})\n        cxt.error()\n        if (!allErrors) gen.break()\n        return\n      }\n\n      if (typeof schema == \"object\" && !alwaysValidSchema(it, schema)) {\n        const valid = gen.name(\"valid\")\n        if (opts.removeAdditional === \"failing\") {\n          applyAdditionalSchema(key, valid, false)\n          gen.if(not(valid), () => {\n            cxt.reset()\n            deleteAdditional(key)\n          })\n        } else {\n          applyAdditionalSchema(key, valid)\n          if (!allErrors) gen.if(not(valid), () => gen.break())\n        }\n      }\n    }\n\n    function applyAdditionalSchema(key: Name, valid: Name, errors?: false): void {\n      const subschema: SubschemaArgs = {\n        keyword: \"additionalProperties\",\n        dataProp: key,\n        dataPropType: Type.Str,\n      }\n      if (errors === false) {\n        Object.assign(subschema, {\n          compositeRule: true,\n          createErrors: false,\n          allErrors: false,\n        })\n      }\n      cxt.subschema(subschema, valid)\n    }\n  },\n}\n\nexport default def\n"],"mappings":";;;;;;;AAOA,MAAAA,MAAA,GAAAC,OAAA;AACA,MAAAC,SAAA,GAAAD,OAAA;AACA,MAAAE,OAAA,GAAAF,OAAA;AAEA,MAAAG,MAAA,GAAAH,OAAA;AAQA,MAAMI,KAAK,GAA2B;EACpCC,OAAO,EAAE,qCAAqC;EAC9CC,MAAM,EAAEC,IAAA;IAAA,IAAC;MAACD;IAAM,CAAC,GAAAC,IAAA;IAAA,QAAK,GAAAN,SAAA,CAAAO,CAAC,EAAAC,eAAA,KAAAA,eAAA,GAAAC,sBAAA,mCAAwBJ,MAAM,CAACK,kBAAkB;EAAA;CACzE;AAED,MAAMC,GAAG,GAAmD;EAC1DC,OAAO,EAAE,sBAAsB;EAC/BC,IAAI,EAAE,CAAC,QAAQ,CAAC;EAChBC,UAAU,EAAE,CAAC,SAAS,EAAE,QAAQ,CAAC;EACjCC,cAAc,EAAE,IAAI;EACpBC,WAAW,EAAE,IAAI;EACjBb,KAAK;EACLc,IAAIA,CAACC,GAAG;IACN,MAAM;MAACC,GAAG;MAAEC,MAAM;MAAEC,YAAY;MAAEC,IAAI;MAAEC,SAAS;MAAEC;IAAE,CAAC,GAAGN,GAAG;IAC5D;IACA,IAAI,CAACK,SAAS,EAAE,MAAM,IAAIE,KAAK,CAAC,0BAA0B,CAAC;IAC3D,MAAM;MAACC,SAAS;MAAEC;IAAI,CAAC,GAAGH,EAAE;IAC5BA,EAAE,CAACI,KAAK,GAAG,IAAI;IACf,IAAID,IAAI,CAACE,gBAAgB,KAAK,KAAK,IAAI,IAAA3B,MAAA,CAAA4B,iBAAiB,EAACN,EAAE,EAAEJ,MAAM,CAAC,EAAE;IACtE,MAAMQ,KAAK,GAAG,IAAA9B,MAAA,CAAAiC,mBAAmB,EAACV,YAAY,CAACW,UAAU,CAAC;IAC1D,MAAMC,QAAQ,GAAG,IAAAnC,MAAA,CAAAiC,mBAAmB,EAACV,YAAY,CAACa,iBAAiB,CAAC;IACpEC,yBAAyB,EAAE;IAC3BjB,GAAG,CAACkB,EAAE,EAAC,GAAApC,SAAA,CAAAO,CAAC,EAAA8B,gBAAA,KAAAA,gBAAA,GAAA5B,sBAAA,sBAAGc,SAAS,EAAQtB,OAAA,CAAAqC,OAAC,CAACC,MAAM,CAAE,CAAC;IAEvC,SAASJ,yBAAyBA,CAAA;MAChChB,GAAG,CAACqB,KAAK,CAAC,KAAK,EAAElB,IAAI,EAAGmB,GAAS,IAAI;QACnC,IAAI,CAACb,KAAK,CAACc,MAAM,IAAI,CAACT,QAAQ,CAACS,MAAM,EAAEC,sBAAsB,CAACF,GAAG,CAAC,MAC7DtB,GAAG,CAACyB,EAAE,CAACC,YAAY,CAACJ,GAAG,CAAC,EAAE,MAAME,sBAAsB,CAACF,GAAG,CAAC,CAAC;MACnE,CAAC,CAAC;IACJ;IAEA,SAASI,YAAYA,CAACJ,GAAS;MAC7B,IAAIK,WAAiB;MACrB,IAAIlB,KAAK,CAACc,MAAM,GAAG,CAAC,EAAE;QACpB;QACA,MAAMK,WAAW,GAAG,IAAA7C,MAAA,CAAA8C,cAAc,EAACxB,EAAE,EAAEH,YAAY,CAACW,UAAU,EAAE,YAAY,CAAC;QAC7Ec,WAAW,GAAG,IAAAhD,MAAA,CAAAmD,aAAa,EAAC9B,GAAG,EAAE4B,WAAmB,EAAEN,GAAG,CAAC;MAC5D,CAAC,MAAM,IAAIb,KAAK,CAACc,MAAM,EAAE;QACvBI,WAAW,GAAG,IAAA9C,SAAA,CAAAkD,EAAE,EAAC,GAAGtB,KAAK,CAACuB,GAAG,CAAEC,CAAC,KAAK,GAAApD,SAAA,CAAAO,CAAC,EAAA8C,gBAAA,KAAAA,gBAAA,GAAA5C,sBAAA,sBAAGgC,GAAG,EAAQW,CAAC,CAAE,CAAC,CAAC;MAC3D,CAAC,MAAM;QACLN,WAAW,GAAG9C,SAAA,CAAAsD,GAAG;MACnB;MACA,IAAIrB,QAAQ,CAACS,MAAM,EAAE;QACnBI,WAAW,GAAG,IAAA9C,SAAA,CAAAkD,EAAE,EAACJ,WAAW,EAAE,GAAGb,QAAQ,CAACkB,GAAG,CAAEC,CAAC,KAAK,GAAApD,SAAA,CAAAO,CAAC,EAAAgD,gBAAA,KAAAA,gBAAA,GAAA9C,sBAAA,wBAAG,IAAAX,MAAA,CAAA0D,UAAU,EAACtC,GAAG,EAAEkC,CAAC,CAAC,EAASX,GAAG,CAAG,CAAC,CAAC;MAC9F;MACA,OAAO,IAAAzC,SAAA,CAAAyD,GAAG,EAACX,WAAW,CAAC;IACzB;IAEA,SAASY,gBAAgBA,CAACjB,GAAS;MACjCtB,GAAG,CAACF,IAAI,EAAC,GAAAjB,SAAA,CAAAO,CAAC,EAAAoD,gBAAA,KAAAA,gBAAA,GAAAlD,sBAAA,0BAAUa,IAAI,EAAImB,GAAG,CAAG,CAAC;IACrC;IAEA,SAASE,sBAAsBA,CAACF,GAAS;MACvC,IAAId,IAAI,CAACE,gBAAgB,KAAK,KAAK,IAAKF,IAAI,CAACE,gBAAgB,IAAIT,MAAM,KAAK,KAAM,EAAE;QAClFsC,gBAAgB,CAACjB,GAAG,CAAC;QACrB;MACF;MAEA,IAAIrB,MAAM,KAAK,KAAK,EAAE;QACpBF,GAAG,CAAC0C,SAAS,CAAC;UAAClD,kBAAkB,EAAE+B;QAAG,CAAC,CAAC;QACxCvB,GAAG,CAACf,KAAK,EAAE;QACX,IAAI,CAACuB,SAAS,EAAEP,GAAG,CAAC0C,KAAK,EAAE;QAC3B;MACF;MAEA,IAAI,OAAOzC,MAAM,IAAI,QAAQ,IAAI,CAAC,IAAAlB,MAAA,CAAA4B,iBAAiB,EAACN,EAAE,EAAEJ,MAAM,CAAC,EAAE;QAC/D,MAAM0C,KAAK,GAAG3C,GAAG,CAAC4C,IAAI,CAAC,OAAO,CAAC;QAC/B,IAAIpC,IAAI,CAACE,gBAAgB,KAAK,SAAS,EAAE;UACvCmC,qBAAqB,CAACvB,GAAG,EAAEqB,KAAK,EAAE,KAAK,CAAC;UACxC3C,GAAG,CAACyB,EAAE,CAAC,IAAA5C,SAAA,CAAAyD,GAAG,EAACK,KAAK,CAAC,EAAE,MAAK;YACtB5C,GAAG,CAAC+C,KAAK,EAAE;YACXP,gBAAgB,CAACjB,GAAG,CAAC;UACvB,CAAC,CAAC;QACJ,CAAC,MAAM;UACLuB,qBAAqB,CAACvB,GAAG,EAAEqB,KAAK,CAAC;UACjC,IAAI,CAACpC,SAAS,EAAEP,GAAG,CAACyB,EAAE,CAAC,IAAA5C,SAAA,CAAAyD,GAAG,EAACK,KAAK,CAAC,EAAE,MAAM3C,GAAG,CAAC0C,KAAK,EAAE,CAAC;QACvD;MACF;IACF;IAEA,SAASG,qBAAqBA,CAACvB,GAAS,EAAEqB,KAAW,EAAEvB,MAAc;MACnE,MAAM2B,SAAS,GAAkB;QAC/BtD,OAAO,EAAE,sBAAsB;QAC/BuD,QAAQ,EAAE1B,GAAG;QACb2B,YAAY,EAAElE,MAAA,CAAAmE,IAAI,CAACC;OACpB;MACD,IAAI/B,MAAM,KAAK,KAAK,EAAE;QACpBgC,MAAM,CAACC,MAAM,CAACN,SAAS,EAAE;UACvBO,aAAa,EAAE,IAAI;UACnBC,YAAY,EAAE,KAAK;UACnBhD,SAAS,EAAE;SACZ,CAAC;MACJ;MACAR,GAAG,CAACgD,SAAS,CAACA,SAAS,EAAEJ,KAAK,CAAC;IACjC;EACF;CACD;AAEDa,OAAA,CAAArC,OAAA,GAAe3B,GAAG","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}