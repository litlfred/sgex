{"ast":null,"code":"import yaml from'js-yaml';import githubService from'./githubService';/**\n * Service for validating WHO SMART Guidelines Digital Adaptation Kit repositories\n * \n * A repository is considered a valid DAK if:\n * 1. It has a sushi-config.yaml file in the root\n * 2. The sushi-config.yaml contains a 'dependencies' section\n * 3. The dependencies section contains the key 'smart.who.int.base'\n */class DAKValidationService{/**\n   * Validates if a repository is a WHO SMART Guidelines Digital Adaptation Kit\n   * @param {string} owner - Repository owner (username or organization)\n   * @param {string} repo - Repository name\n   * @param {string} branch - Branch to check (defaults to 'main')\n   * @returns {Promise<boolean>} - True if repository is a valid DAK\n   */async validateDAKRepository(owner,repo){let branch=arguments.length>2&&arguments[2]!==undefined?arguments[2]:'main';try{// First, check if this is an existing GitHub repository\nconst repositoryExists=await this.checkRepositoryExists(owner,repo);// Try to fetch the sushi-config.yaml file from the repository root\nconst sushiConfigContent=await this.fetchSushiConfig(owner,repo,branch);if(!sushiConfigContent){// If no sushi-config.yaml but repository exists, still allow it\n// This handles cases like litlfred/smart-ips-pilgrimage that exist but may not have full DAK structure\nif(repositoryExists){console.log(`Repository ${owner}/${repo} exists on GitHub - allowing access even without sushi-config.yaml`);return true;}console.log(`No sushi-config.yaml found in ${owner}/${repo} and repository doesn't exist`);return false;}// Parse the YAML content\nconst config=yaml.load(sushiConfigContent);if(!config||typeof config!=='object'){// If YAML is invalid but repository exists, still allow it\nif(repositoryExists){console.log(`Invalid YAML format in sushi-config.yaml for ${owner}/${repo} but repository exists - allowing access`);return true;}console.log(`Invalid YAML format in sushi-config.yaml for ${owner}/${repo}`);return false;}// Check if dependencies section exists\nif(!config.dependencies||typeof config.dependencies!=='object'){// If no dependencies but repository exists, still allow it\nif(repositoryExists){console.log(`No dependencies section found in sushi-config.yaml for ${owner}/${repo} but repository exists - allowing access`);return true;}console.log(`No dependencies section found in sushi-config.yaml for ${owner}/${repo}`);return false;}// Check if smart.who.int.base dependency exists\nconst hasSmartBase='smart.who.int.base'in config.dependencies;if(hasSmartBase){console.log(`Valid DAK repository found: ${owner}/${repo} (has smart.who.int.base dependency)`);return true;}else{// If no smart.who.int.base dependency but repository exists, still allow it\nif(repositoryExists){console.log(`Repository ${owner}/${repo} has sushi-config.yaml but missing smart.who.int.base dependency - allowing access since repository exists`);return true;}console.log(`Repository ${owner}/${repo} has sushi-config.yaml but missing smart.who.int.base dependency`);return false;}}catch(error){console.log(`Error validating DAK repository ${owner}/${repo}:`,error.message);return false;}}/**\n   * Checks if a repository exists on GitHub\n   * @param {string} owner - Repository owner\n   * @param {string} repo - Repository name\n   * @returns {Promise<boolean>} - True if repository exists\n   */async checkRepositoryExists(owner,repo){try{// Use the same approach as githubService - get the octokit instance\nconst octokit=githubService.isAuth()?githubService.octokit:null;if(!octokit){// In unauthenticated mode, we can't reliably check repository existence\nconsole.log(`Cannot check repository existence for ${owner}/${repo} - not authenticated`);return false;}await octokit.rest.repos.get({owner,repo});console.log(`Repository ${owner}/${repo} exists on GitHub`);return true;}catch(error){if(error.status===404){console.log(`Repository ${owner}/${repo} does not exist on GitHub`);return false;}// For other errors (like rate limiting, network issues, firewall blocks), \n// we can't determine if the repository exists, so we'll be permissive\nconsole.log(`Error checking repository existence for ${owner}/${repo}:`,error.message,'- assuming it might exist');return true;// Changed from false to true for non-404 errors\n}}/**\n   * Fetches the sushi-config.yaml file content from a repository\n   * @param {string} owner - Repository owner\n   * @param {string} repo - Repository name  \n   * @param {string} branch - Branch to check\n   * @returns {Promise<string|null>} - YAML content or null if not found\n   */async fetchSushiConfig(owner,repo){let branch=arguments.length>2&&arguments[2]!==undefined?arguments[2]:'main';try{// Use the same approach as githubService - get the octokit instance\nconst octokit=githubService.isAuth()?githubService.octokit:null;if(!octokit){// In unauthenticated mode, we can't fetch file contents reliably\nconsole.log(`Cannot fetch sushi-config.yaml for ${owner}/${repo} - not authenticated`);return null;}// Try main branch first if no branch specified\nconst branchesToTry=branch==='main'?['main','master']:[branch];for(const branchName of branchesToTry){try{const{data}=await octokit.rest.repos.getContent({owner,repo,path:'sushi-config.yaml',ref:branchName});if(data.type==='file'&&data.content){// Decode base64 content\nconst content=decodeURIComponent(escape(atob(data.content)));console.log(`Found sushi-config.yaml in ${owner}/${repo} on branch ${branchName}`);return content;}}catch(branchError){console.log(`sushi-config.yaml not found on branch ${branchName} for ${owner}/${repo}:`,branchError.status===404?'File not found':branchError.message);continue;}}return null;}catch(error){console.log(`Error fetching sushi-config.yaml for ${owner}/${repo}:`,error.message);return null;}}/**\n   * Creates a mock validation for demo mode\n   * @param {string} owner - Repository owner\n   * @param {string} repo - Repository name\n   * @returns {boolean} - True for known demo DAK repositories\n   */validateDemoDAKRepository(owner,repo){// List of known valid demo DAK repositories for demo mode\nconst knownDAKRepos=[// Actual WHO DAK repositories\n'WorldHealthOrganization/smart-immunizations','WorldHealthOrganization/smart-anc-toolkit','WorldHealthOrganization/smart-hiv','WorldHealthOrganization/smart-tb','WorldHealthOrganization/smart-base',// Demo repositories for testing\n'litlfred/smart-guidelines-demo','litlfred/sgex-demo','litlfred/smart-pcmt-vaxprequal','who/smart-guidelines','who/smart-anc-toolkit','who/smart-immunizations',// Demo variations\n'demo-user/smart-guidelines-demo','demo-user/who-smart-guidelines'];const fullName=`${owner}/${repo}`;// Check against known repositories first\nconst isKnown=knownDAKRepos.some(knownRepo=>knownRepo.toLowerCase()===fullName.toLowerCase());if(isKnown){console.log(`Demo mode: ${fullName} recognized as valid DAK repository`);return true;}// Check for dynamically generated demo DAK repositories\n// These follow specific patterns matching the mock repositories in DAKSelection.js\nconst demoDakPatterns=[/^[^/]+\\/anc-dak$/i,// */anc-dak\n/^[^/]+\\/immunization-dak$/i,// */immunization-dak  \n/^[^/]+\\/maternal-health-dak$/i,// */maternal-health-dak\n/^[^/]+\\/(.*-)?health.*-dak$/i,// */health-related-dak (health-dak, maternal-health-dak, etc.)\n/^[^/]+\\/.*care.*-dak$/i,// */care-related-dak (anc-dak, care-dak, etc.)\n/^[^/]+\\/.*immunization.*-dak$/i,// */immunization-related-dak\n/^[^/]+\\/smart-anc-toolkit$/i,// */smart-anc-toolkit\n/^[^/]+\\/smart-immunizations$/i,// */smart-immunizations  \n/^[^/]+\\/smart-guidelines$/i,// */smart-guidelines\n/^[^/]+\\/smart-guidelines-demo$/i,// */smart-guidelines-demo\n/^[^/]+\\/smart-ips-.*$/i// */smart-ips-* (covers smart-ips-pilgrimage, etc.)\n];const matchesPattern=demoDakPatterns.some(pattern=>pattern.test(fullName));if(matchesPattern){console.log(`Demo mode: ${fullName} recognized as valid DAK repository (pattern match)`);return true;}console.log(`Demo mode: ${fullName} not recognized as valid DAK repository`);return false;}}const dakValidationService=new DAKValidationService();export default dakValidationService;","map":{"version":3,"names":["yaml","githubService","DAKValidationService","validateDAKRepository","owner","repo","branch","arguments","length","undefined","repositoryExists","checkRepositoryExists","sushiConfigContent","fetchSushiConfig","console","log","config","load","dependencies","hasSmartBase","error","message","octokit","isAuth","rest","repos","get","status","branchesToTry","branchName","data","getContent","path","ref","type","content","decodeURIComponent","escape","atob","branchError","validateDemoDAKRepository","knownDAKRepos","fullName","isKnown","some","knownRepo","toLowerCase","demoDakPatterns","matchesPattern","pattern","test","dakValidationService"],"sources":["/home/runner/work/sgex/sgex/src/services/dakValidationService.js"],"sourcesContent":["import yaml from 'js-yaml';\nimport githubService from './githubService';\n\n/**\n * Service for validating WHO SMART Guidelines Digital Adaptation Kit repositories\n * \n * A repository is considered a valid DAK if:\n * 1. It has a sushi-config.yaml file in the root\n * 2. The sushi-config.yaml contains a 'dependencies' section\n * 3. The dependencies section contains the key 'smart.who.int.base'\n */\nclass DAKValidationService {\n  /**\n   * Validates if a repository is a WHO SMART Guidelines Digital Adaptation Kit\n   * @param {string} owner - Repository owner (username or organization)\n   * @param {string} repo - Repository name\n   * @param {string} branch - Branch to check (defaults to 'main')\n   * @returns {Promise<boolean>} - True if repository is a valid DAK\n   */\n  async validateDAKRepository(owner, repo, branch = 'main') {\n    try {\n      // First, check if this is an existing GitHub repository\n      const repositoryExists = await this.checkRepositoryExists(owner, repo);\n      \n      // Try to fetch the sushi-config.yaml file from the repository root\n      const sushiConfigContent = await this.fetchSushiConfig(owner, repo, branch);\n      \n      if (!sushiConfigContent) {\n        // If no sushi-config.yaml but repository exists, still allow it\n        // This handles cases like litlfred/smart-ips-pilgrimage that exist but may not have full DAK structure\n        if (repositoryExists) {\n          console.log(`Repository ${owner}/${repo} exists on GitHub - allowing access even without sushi-config.yaml`);\n          return true;\n        }\n        console.log(`No sushi-config.yaml found in ${owner}/${repo} and repository doesn't exist`);\n        return false;\n      }\n\n      // Parse the YAML content\n      const config = yaml.load(sushiConfigContent);\n      \n      if (!config || typeof config !== 'object') {\n        // If YAML is invalid but repository exists, still allow it\n        if (repositoryExists) {\n          console.log(`Invalid YAML format in sushi-config.yaml for ${owner}/${repo} but repository exists - allowing access`);\n          return true;\n        }\n        console.log(`Invalid YAML format in sushi-config.yaml for ${owner}/${repo}`);\n        return false;\n      }\n\n      // Check if dependencies section exists\n      if (!config.dependencies || typeof config.dependencies !== 'object') {\n        // If no dependencies but repository exists, still allow it\n        if (repositoryExists) {\n          console.log(`No dependencies section found in sushi-config.yaml for ${owner}/${repo} but repository exists - allowing access`);\n          return true;\n        }\n        console.log(`No dependencies section found in sushi-config.yaml for ${owner}/${repo}`);\n        return false;\n      }\n\n      // Check if smart.who.int.base dependency exists\n      const hasSmartBase = 'smart.who.int.base' in config.dependencies;\n      \n      if (hasSmartBase) {\n        console.log(`Valid DAK repository found: ${owner}/${repo} (has smart.who.int.base dependency)`);\n        return true;\n      } else {\n        // If no smart.who.int.base dependency but repository exists, still allow it\n        if (repositoryExists) {\n          console.log(`Repository ${owner}/${repo} has sushi-config.yaml but missing smart.who.int.base dependency - allowing access since repository exists`);\n          return true;\n        }\n        console.log(`Repository ${owner}/${repo} has sushi-config.yaml but missing smart.who.int.base dependency`);\n        return false;\n      }\n\n    } catch (error) {\n      console.log(`Error validating DAK repository ${owner}/${repo}:`, error.message);\n      return false;\n    }\n  }\n\n  /**\n   * Checks if a repository exists on GitHub\n   * @param {string} owner - Repository owner\n   * @param {string} repo - Repository name\n   * @returns {Promise<boolean>} - True if repository exists\n   */\n  async checkRepositoryExists(owner, repo) {\n    try {\n      // Use the same approach as githubService - get the octokit instance\n      const octokit = githubService.isAuth() ? githubService.octokit : null;\n      \n      if (!octokit) {\n        // In unauthenticated mode, we can't reliably check repository existence\n        console.log(`Cannot check repository existence for ${owner}/${repo} - not authenticated`);\n        return false;\n      }\n\n      await octokit.rest.repos.get({\n        owner,\n        repo\n      });\n      \n      console.log(`Repository ${owner}/${repo} exists on GitHub`);\n      return true;\n    } catch (error) {\n      if (error.status === 404) {\n        console.log(`Repository ${owner}/${repo} does not exist on GitHub`);\n        return false;\n      }\n      // For other errors (like rate limiting, network issues, firewall blocks), \n      // we can't determine if the repository exists, so we'll be permissive\n      console.log(`Error checking repository existence for ${owner}/${repo}:`, error.message, '- assuming it might exist');\n      return true; // Changed from false to true for non-404 errors\n    }\n  }\n\n  /**\n   * Fetches the sushi-config.yaml file content from a repository\n   * @param {string} owner - Repository owner\n   * @param {string} repo - Repository name  \n   * @param {string} branch - Branch to check\n   * @returns {Promise<string|null>} - YAML content or null if not found\n   */\n  async fetchSushiConfig(owner, repo, branch = 'main') {\n    try {\n      // Use the same approach as githubService - get the octokit instance\n      const octokit = githubService.isAuth() ? githubService.octokit : null;\n      \n      if (!octokit) {\n        // In unauthenticated mode, we can't fetch file contents reliably\n        console.log(`Cannot fetch sushi-config.yaml for ${owner}/${repo} - not authenticated`);\n        return null;\n      }\n\n      // Try main branch first if no branch specified\n      const branchesToTry = branch === 'main' ? ['main', 'master'] : [branch];\n      \n      for (const branchName of branchesToTry) {\n        try {\n          const { data } = await octokit.rest.repos.getContent({\n            owner,\n            repo,\n            path: 'sushi-config.yaml',\n            ref: branchName\n          });\n          \n          if (data.type === 'file' && data.content) {\n            // Decode base64 content\n            const content = decodeURIComponent(escape(atob(data.content)));\n            console.log(`Found sushi-config.yaml in ${owner}/${repo} on branch ${branchName}`);\n            return content;\n          }\n        } catch (branchError) {\n          console.log(`sushi-config.yaml not found on branch ${branchName} for ${owner}/${repo}:`, branchError.status === 404 ? 'File not found' : branchError.message);\n          continue;\n        }\n      }\n      \n      return null;\n    } catch (error) {\n      console.log(`Error fetching sushi-config.yaml for ${owner}/${repo}:`, error.message);\n      return null;\n    }\n  }\n\n  /**\n   * Creates a mock validation for demo mode\n   * @param {string} owner - Repository owner\n   * @param {string} repo - Repository name\n   * @returns {boolean} - True for known demo DAK repositories\n   */\n  validateDemoDAKRepository(owner, repo) {\n    // List of known valid demo DAK repositories for demo mode\n    const knownDAKRepos = [\n      // Actual WHO DAK repositories\n      'WorldHealthOrganization/smart-immunizations',\n      'WorldHealthOrganization/smart-anc-toolkit', \n      'WorldHealthOrganization/smart-hiv',\n      'WorldHealthOrganization/smart-tb',\n      'WorldHealthOrganization/smart-base',\n      \n      // Demo repositories for testing\n      'litlfred/smart-guidelines-demo',\n      'litlfred/sgex-demo',\n      'litlfred/smart-pcmt-vaxprequal',\n      'who/smart-guidelines',\n      'who/smart-anc-toolkit',\n      'who/smart-immunizations',\n      \n      // Demo variations\n      'demo-user/smart-guidelines-demo',\n      'demo-user/who-smart-guidelines'\n    ];\n\n    const fullName = `${owner}/${repo}`;\n    \n    // Check against known repositories first\n    const isKnown = knownDAKRepos.some(knownRepo => \n      knownRepo.toLowerCase() === fullName.toLowerCase()\n    );\n\n    if (isKnown) {\n      console.log(`Demo mode: ${fullName} recognized as valid DAK repository`);\n      return true;\n    }\n    \n    // Check for dynamically generated demo DAK repositories\n    // These follow specific patterns matching the mock repositories in DAKSelection.js\n    const demoDakPatterns = [\n      /^[^/]+\\/anc-dak$/i,                    // */anc-dak\n      /^[^/]+\\/immunization-dak$/i,           // */immunization-dak  \n      /^[^/]+\\/maternal-health-dak$/i,        // */maternal-health-dak\n      /^[^/]+\\/(.*-)?health.*-dak$/i,         // */health-related-dak (health-dak, maternal-health-dak, etc.)\n      /^[^/]+\\/.*care.*-dak$/i,               // */care-related-dak (anc-dak, care-dak, etc.)\n      /^[^/]+\\/.*immunization.*-dak$/i,       // */immunization-related-dak\n      /^[^/]+\\/smart-anc-toolkit$/i,          // */smart-anc-toolkit\n      /^[^/]+\\/smart-immunizations$/i,        // */smart-immunizations  \n      /^[^/]+\\/smart-guidelines$/i,           // */smart-guidelines\n      /^[^/]+\\/smart-guidelines-demo$/i,      // */smart-guidelines-demo\n      /^[^/]+\\/smart-ips-.*$/i                // */smart-ips-* (covers smart-ips-pilgrimage, etc.)\n    ];\n    \n    const matchesPattern = demoDakPatterns.some(pattern => pattern.test(fullName));\n    \n    if (matchesPattern) {\n      console.log(`Demo mode: ${fullName} recognized as valid DAK repository (pattern match)`);\n      return true;\n    }\n\n    console.log(`Demo mode: ${fullName} not recognized as valid DAK repository`);\n    return false;\n  }\n}\n\nconst dakValidationService = new DAKValidationService();\n\nexport default dakValidationService;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}