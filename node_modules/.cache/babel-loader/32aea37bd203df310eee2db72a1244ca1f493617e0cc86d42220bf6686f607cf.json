{"ast":null,"code":"import { append as svgAppend, attr as svgAttr, classes as svgClasses, create as svgCreate, remove as svgRemove, clear as svgClear } from 'tiny-svg';\nimport { isObject } from 'min-dash';\nimport { getElementLineIntersection, getMid } from '../../layout/LayoutUtil';\nimport { createLine } from '../../util/RenderUtil';\n\n/**\n * @typedef {import('../../model/Types').Element} Element\n * @typedef {import('../../model/Types').Connection} Connection\n * @typedef {import('../../model/Types').Shape} Shape\n *\n * @typedef {import('../../util/Types').Point} Point\n *\n * @typedef {import('didi').Injector} Injector\n *\n * @typedef {import('../../core/Canvas').default} Canvas\n * @typedef {import('../../core/ElementFactory').default} ElementFactory\n * @typedef {import('../../core/GraphicsFactory').default} GraphicsFactory\n */\n\nvar MARKER_CONNECTION_PREVIEW = 'djs-dragger';\n\n/**\n * Draws connection preview. Optionally, this can use layouter and connection docking to draw\n * better looking previews.\n *\n * @param {Injector} injector\n * @param {Canvas} canvas\n * @param {GraphicsFactory} graphicsFactory\n * @param {ElementFactory} elementFactory\n */\nexport default function ConnectionPreview(injector, canvas, graphicsFactory, elementFactory) {\n  this._canvas = canvas;\n  this._graphicsFactory = graphicsFactory;\n  this._elementFactory = elementFactory;\n\n  // optional components\n  this._connectionDocking = injector.get('connectionDocking', false);\n  this._layouter = injector.get('layouter', false);\n}\nConnectionPreview.$inject = ['injector', 'canvas', 'graphicsFactory', 'elementFactory'];\n\n/**\n * Draw connection preview.\n *\n * Provide at least one of <source, connectionStart> and <target, connectionEnd> to create a preview.\n * In the clean up stage, call `connectionPreview#cleanUp` with the context to remove preview.\n *\n * @param {Object} context\n * @param {Object|boolean} canConnect\n * @param {Object} hints\n * @param {Element} [hints.source] source element\n * @param {Element} [hints.target] target element\n * @param {Point} [hints.connectionStart] connection preview start\n * @param {Point} [hints.connectionEnd] connection preview end\n * @param {Point[]} [hints.waypoints] provided waypoints for preview\n * @param {boolean} [hints.noLayout] true if preview should not be laid out\n * @param {boolean} [hints.noCropping] true if preview should not be cropped\n * @param {boolean} [hints.noNoop] true if simple connection should not be drawn\n */\nConnectionPreview.prototype.drawPreview = function (context, canConnect, hints) {\n  hints = hints || {};\n  var connectionPreviewGfx = context.connectionPreviewGfx,\n    getConnection = context.getConnection,\n    source = hints.source,\n    target = hints.target,\n    waypoints = hints.waypoints,\n    connectionStart = hints.connectionStart,\n    connectionEnd = hints.connectionEnd,\n    noLayout = hints.noLayout,\n    noCropping = hints.noCropping,\n    noNoop = hints.noNoop,\n    connection;\n  var self = this;\n  if (!connectionPreviewGfx) {\n    connectionPreviewGfx = context.connectionPreviewGfx = this.createConnectionPreviewGfx();\n  }\n  svgClear(connectionPreviewGfx);\n  if (!getConnection) {\n    getConnection = context.getConnection = cacheReturnValues(function (canConnect, source, target) {\n      return self.getConnection(canConnect, source, target);\n    });\n  }\n  if (canConnect) {\n    connection = getConnection(canConnect, source, target);\n  }\n  if (!connection) {\n    !noNoop && this.drawNoopPreview(connectionPreviewGfx, hints);\n    return;\n  }\n  connection.waypoints = waypoints || [];\n\n  // optional layout\n  if (this._layouter && !noLayout) {\n    connection.waypoints = this._layouter.layoutConnection(connection, {\n      source: source,\n      target: target,\n      connectionStart: connectionStart,\n      connectionEnd: connectionEnd,\n      waypoints: hints.waypoints || connection.waypoints\n    });\n  }\n\n  // fallback if no waypoints were provided nor created with layouter\n  if (!connection.waypoints || !connection.waypoints.length) {\n    connection.waypoints = [source ? getMid(source) : connectionStart, target ? getMid(target) : connectionEnd];\n  }\n\n  // optional cropping\n  if (this._connectionDocking && (source || target) && !noCropping) {\n    connection.waypoints = this._connectionDocking.getCroppedWaypoints(connection, source, target);\n  }\n  this._graphicsFactory.drawConnection(connectionPreviewGfx, connection, {\n    stroke: 'var(--element-dragger-color)'\n  });\n};\n\n/**\n * Draw simple connection between source and target or provided points.\n *\n * @param {SVGElement} connectionPreviewGfx container for the connection\n * @param {Object} hints\n * @param {Element} [hints.source] source element\n * @param {Element} [hints.target] target element\n * @param {Point} [hints.connectionStart] required if source is not provided\n * @param {Point} [hints.connectionEnd] required if target is not provided\n */\nConnectionPreview.prototype.drawNoopPreview = function (connectionPreviewGfx, hints) {\n  var source = hints.source,\n    target = hints.target,\n    start = hints.connectionStart || getMid(source),\n    end = hints.connectionEnd || getMid(target);\n  var waypoints = this.cropWaypoints(start, end, source, target);\n  var connection = this.createNoopConnection(waypoints[0], waypoints[1]);\n  svgAppend(connectionPreviewGfx, connection);\n};\n\n/**\n * Return cropped waypoints.\n *\n * @param {Point} start\n * @param {Point} end\n * @param {Element} source\n * @param {Element} target\n *\n * @return {Point[]}\n */\nConnectionPreview.prototype.cropWaypoints = function (start, end, source, target) {\n  var graphicsFactory = this._graphicsFactory,\n    sourcePath = source && graphicsFactory.getShapePath(source),\n    targetPath = target && graphicsFactory.getShapePath(target),\n    connectionPath = graphicsFactory.getConnectionPath({\n      waypoints: [start, end]\n    });\n  start = source && getElementLineIntersection(sourcePath, connectionPath, true) || start;\n  end = target && getElementLineIntersection(targetPath, connectionPath, false) || end;\n  return [start, end];\n};\n\n/**\n * Remove connection preview container if it exists.\n *\n * @param {Object} [context]\n * @param {SVGElement} [context.connectionPreviewGfx] preview container\n */\nConnectionPreview.prototype.cleanUp = function (context) {\n  if (context && context.connectionPreviewGfx) {\n    svgRemove(context.connectionPreviewGfx);\n  }\n};\n\n/**\n * Get connection that connects source and target.\n *\n * @param {Object|boolean} canConnect\n *\n * @return {Connection}\n */\nConnectionPreview.prototype.getConnection = function (canConnect) {\n  var attrs = ensureConnectionAttrs(canConnect);\n  return this._elementFactory.createConnection(attrs);\n};\n\n/**\n * Add and return preview graphics.\n *\n * @return {SVGElement}\n */\nConnectionPreview.prototype.createConnectionPreviewGfx = function () {\n  var gfx = svgCreate('g');\n  svgAttr(gfx, {\n    pointerEvents: 'none'\n  });\n  svgClasses(gfx).add(MARKER_CONNECTION_PREVIEW);\n  svgAppend(this._canvas.getActiveLayer(), gfx);\n  return gfx;\n};\n\n/**\n * Create and return simple connection.\n *\n * @param {Point} start\n * @param {Point} end\n *\n * @return {SVGElement}\n */\nConnectionPreview.prototype.createNoopConnection = function (start, end) {\n  return createLine([start, end], {\n    'stroke': '#333',\n    'strokeDasharray': [1],\n    'strokeWidth': 2,\n    'pointer-events': 'none'\n  });\n};\n\n// helpers //////////\n\n/**\n * Returns function that returns cached return values referenced by stringified first argument.\n *\n * @param {Function} fn\n *\n * @return {Function}\n */\nfunction cacheReturnValues(fn) {\n  var returnValues = {};\n\n  /**\n   * Return cached return value referenced by stringified first argument.\n   *\n   * @return {*}\n   */\n  return function (firstArgument) {\n    var key = JSON.stringify(firstArgument);\n    var returnValue = returnValues[key];\n    if (!returnValue) {\n      returnValue = returnValues[key] = fn.apply(null, arguments);\n    }\n    return returnValue;\n  };\n}\n\n/**\n * Ensure connection attributes is object.\n *\n * @param {Object|boolean} canConnect\n *\n * @return {Object}\n */\nfunction ensureConnectionAttrs(canConnect) {\n  if (isObject(canConnect)) {\n    return canConnect;\n  } else {\n    return {};\n  }\n}","map":{"version":3,"names":["append","svgAppend","attr","svgAttr","classes","svgClasses","create","svgCreate","remove","svgRemove","clear","svgClear","isObject","getElementLineIntersection","getMid","createLine","MARKER_CONNECTION_PREVIEW","ConnectionPreview","injector","canvas","graphicsFactory","elementFactory","_canvas","_graphicsFactory","_elementFactory","_connectionDocking","get","_layouter","$inject","prototype","drawPreview","context","canConnect","hints","connectionPreviewGfx","getConnection","source","target","waypoints","connectionStart","connectionEnd","noLayout","noCropping","noNoop","connection","self","createConnectionPreviewGfx","cacheReturnValues","drawNoopPreview","layoutConnection","length","getCroppedWaypoints","drawConnection","stroke","start","end","cropWaypoints","createNoopConnection","sourcePath","getShapePath","targetPath","connectionPath","getConnectionPath","cleanUp","attrs","ensureConnectionAttrs","createConnection","gfx","pointerEvents","add","getActiveLayer","fn","returnValues","firstArgument","key","JSON","stringify","returnValue","apply","arguments"],"sources":["/home/runner/work/sgex/sgex/node_modules/diagram-js/lib/features/connection-preview/ConnectionPreview.js"],"sourcesContent":["import {\n  append as svgAppend,\n  attr as svgAttr,\n  classes as svgClasses,\n  create as svgCreate,\n  remove as svgRemove,\n  clear as svgClear\n} from 'tiny-svg';\n\nimport {\n  isObject\n} from 'min-dash';\n\nimport {\n  getElementLineIntersection,\n  getMid\n} from '../../layout/LayoutUtil';\n\nimport {\n  createLine\n} from '../../util/RenderUtil';\n\n/**\n * @typedef {import('../../model/Types').Element} Element\n * @typedef {import('../../model/Types').Connection} Connection\n * @typedef {import('../../model/Types').Shape} Shape\n *\n * @typedef {import('../../util/Types').Point} Point\n *\n * @typedef {import('didi').Injector} Injector\n *\n * @typedef {import('../../core/Canvas').default} Canvas\n * @typedef {import('../../core/ElementFactory').default} ElementFactory\n * @typedef {import('../../core/GraphicsFactory').default} GraphicsFactory\n */\n\nvar MARKER_CONNECTION_PREVIEW = 'djs-dragger';\n\n/**\n * Draws connection preview. Optionally, this can use layouter and connection docking to draw\n * better looking previews.\n *\n * @param {Injector} injector\n * @param {Canvas} canvas\n * @param {GraphicsFactory} graphicsFactory\n * @param {ElementFactory} elementFactory\n */\nexport default function ConnectionPreview(\n    injector,\n    canvas,\n    graphicsFactory,\n    elementFactory\n) {\n  this._canvas = canvas;\n  this._graphicsFactory = graphicsFactory;\n  this._elementFactory = elementFactory;\n\n  // optional components\n  this._connectionDocking = injector.get('connectionDocking', false);\n  this._layouter = injector.get('layouter', false);\n}\n\nConnectionPreview.$inject = [\n  'injector',\n  'canvas',\n  'graphicsFactory',\n  'elementFactory'\n];\n\n/**\n * Draw connection preview.\n *\n * Provide at least one of <source, connectionStart> and <target, connectionEnd> to create a preview.\n * In the clean up stage, call `connectionPreview#cleanUp` with the context to remove preview.\n *\n * @param {Object} context\n * @param {Object|boolean} canConnect\n * @param {Object} hints\n * @param {Element} [hints.source] source element\n * @param {Element} [hints.target] target element\n * @param {Point} [hints.connectionStart] connection preview start\n * @param {Point} [hints.connectionEnd] connection preview end\n * @param {Point[]} [hints.waypoints] provided waypoints for preview\n * @param {boolean} [hints.noLayout] true if preview should not be laid out\n * @param {boolean} [hints.noCropping] true if preview should not be cropped\n * @param {boolean} [hints.noNoop] true if simple connection should not be drawn\n */\nConnectionPreview.prototype.drawPreview = function(context, canConnect, hints) {\n\n  hints = hints || {};\n\n  var connectionPreviewGfx = context.connectionPreviewGfx,\n      getConnection = context.getConnection,\n      source = hints.source,\n      target = hints.target,\n      waypoints = hints.waypoints,\n      connectionStart = hints.connectionStart,\n      connectionEnd = hints.connectionEnd,\n      noLayout = hints.noLayout,\n      noCropping = hints.noCropping,\n      noNoop = hints.noNoop,\n      connection;\n\n  var self = this;\n\n  if (!connectionPreviewGfx) {\n    connectionPreviewGfx = context.connectionPreviewGfx = this.createConnectionPreviewGfx();\n  }\n\n  svgClear(connectionPreviewGfx);\n\n  if (!getConnection) {\n    getConnection = context.getConnection = cacheReturnValues(function(canConnect, source, target) {\n      return self.getConnection(canConnect, source, target);\n    });\n  }\n\n  if (canConnect) {\n    connection = getConnection(canConnect, source, target);\n  }\n\n  if (!connection) {\n    !noNoop && this.drawNoopPreview(connectionPreviewGfx, hints);\n    return;\n  }\n\n  connection.waypoints = waypoints || [];\n\n  // optional layout\n  if (this._layouter && !noLayout) {\n    connection.waypoints = this._layouter.layoutConnection(connection, {\n      source: source,\n      target: target,\n      connectionStart: connectionStart,\n      connectionEnd: connectionEnd,\n      waypoints: hints.waypoints || connection.waypoints\n    });\n  }\n\n  // fallback if no waypoints were provided nor created with layouter\n  if (!connection.waypoints || !connection.waypoints.length) {\n    connection.waypoints = [\n      source ? getMid(source) : connectionStart,\n      target ? getMid(target) : connectionEnd\n    ];\n  }\n\n  // optional cropping\n  if (this._connectionDocking && (source || target) && !noCropping) {\n    connection.waypoints = this._connectionDocking.getCroppedWaypoints(connection, source, target);\n  }\n\n  this._graphicsFactory.drawConnection(connectionPreviewGfx, connection, {\n    stroke: 'var(--element-dragger-color)'\n  });\n};\n\n/**\n * Draw simple connection between source and target or provided points.\n *\n * @param {SVGElement} connectionPreviewGfx container for the connection\n * @param {Object} hints\n * @param {Element} [hints.source] source element\n * @param {Element} [hints.target] target element\n * @param {Point} [hints.connectionStart] required if source is not provided\n * @param {Point} [hints.connectionEnd] required if target is not provided\n */\nConnectionPreview.prototype.drawNoopPreview = function(connectionPreviewGfx, hints) {\n  var source = hints.source,\n      target = hints.target,\n      start = hints.connectionStart || getMid(source),\n      end = hints.connectionEnd || getMid(target);\n\n  var waypoints = this.cropWaypoints(start, end, source, target);\n\n  var connection = this.createNoopConnection(waypoints[0], waypoints[1]);\n\n  svgAppend(connectionPreviewGfx, connection);\n};\n\n/**\n * Return cropped waypoints.\n *\n * @param {Point} start\n * @param {Point} end\n * @param {Element} source\n * @param {Element} target\n *\n * @return {Point[]}\n */\nConnectionPreview.prototype.cropWaypoints = function(start, end, source, target) {\n  var graphicsFactory = this._graphicsFactory,\n      sourcePath = source && graphicsFactory.getShapePath(source),\n      targetPath = target && graphicsFactory.getShapePath(target),\n      connectionPath = graphicsFactory.getConnectionPath({ waypoints: [ start, end ] });\n\n  start = (source && getElementLineIntersection(sourcePath, connectionPath, true)) || start;\n  end = (target && getElementLineIntersection(targetPath, connectionPath, false)) || end;\n\n  return [ start, end ];\n};\n\n/**\n * Remove connection preview container if it exists.\n *\n * @param {Object} [context]\n * @param {SVGElement} [context.connectionPreviewGfx] preview container\n */\nConnectionPreview.prototype.cleanUp = function(context) {\n  if (context && context.connectionPreviewGfx) {\n    svgRemove(context.connectionPreviewGfx);\n  }\n};\n\n/**\n * Get connection that connects source and target.\n *\n * @param {Object|boolean} canConnect\n *\n * @return {Connection}\n */\nConnectionPreview.prototype.getConnection = function(canConnect) {\n  var attrs = ensureConnectionAttrs(canConnect);\n\n  return this._elementFactory.createConnection(attrs);\n};\n\n\n/**\n * Add and return preview graphics.\n *\n * @return {SVGElement}\n */\nConnectionPreview.prototype.createConnectionPreviewGfx = function() {\n  var gfx = svgCreate('g');\n\n  svgAttr(gfx, {\n    pointerEvents: 'none'\n  });\n\n  svgClasses(gfx).add(MARKER_CONNECTION_PREVIEW);\n\n  svgAppend(this._canvas.getActiveLayer(), gfx);\n\n  return gfx;\n};\n\n/**\n * Create and return simple connection.\n *\n * @param {Point} start\n * @param {Point} end\n *\n * @return {SVGElement}\n */\nConnectionPreview.prototype.createNoopConnection = function(start, end) {\n  return createLine([ start, end ], {\n    'stroke': '#333',\n    'strokeDasharray': [ 1 ],\n    'strokeWidth': 2,\n    'pointer-events': 'none'\n  });\n};\n\n// helpers //////////\n\n/**\n * Returns function that returns cached return values referenced by stringified first argument.\n *\n * @param {Function} fn\n *\n * @return {Function}\n */\nfunction cacheReturnValues(fn) {\n  var returnValues = {};\n\n  /**\n   * Return cached return value referenced by stringified first argument.\n   *\n   * @return {*}\n   */\n  return function(firstArgument) {\n    var key = JSON.stringify(firstArgument);\n\n    var returnValue = returnValues[key];\n\n    if (!returnValue) {\n      returnValue = returnValues[key] = fn.apply(null, arguments);\n    }\n\n    return returnValue;\n  };\n}\n\n/**\n * Ensure connection attributes is object.\n *\n * @param {Object|boolean} canConnect\n *\n * @return {Object}\n */\nfunction ensureConnectionAttrs(canConnect) {\n  if (isObject(canConnect)) {\n    return canConnect;\n  } else {\n    return {};\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}