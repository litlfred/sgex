{"ast":null,"code":"import { find, forEach, has, isArray, isDefined, isObject, matchPattern, reduce, sortBy } from 'min-dash';\nimport { is } from '../../util/ModelUtil';\nconst DISALLOWED_PROPERTIES = ['artifacts', 'dataInputAssociations', 'dataOutputAssociations', 'default', 'flowElements', 'lanes', 'incoming', 'outgoing', 'categoryValue'];\nconst ALLOWED_REFERENCES = ['errorRef', 'escalationRef', 'messageRef', 'signalRef'];\n\n/**\n * @typedef {import('diagram-js/lib/core/EventBus').default} EventBus\n * @typedef {import('../modeling/BpmnFactory').default} BpmnFactory\n * @typedef {import('../../model/Types').Moddle} Moddle\n *\n * @typedef {import('../../model/Types').ModdleElement} ModdleElement\n */\n\n/**\n * Utility for copying model properties from source element to target element.\n *\n * @param {EventBus} eventBus\n * @param {BpmnFactory} bpmnFactory\n * @param {Moddle} moddle\n */\nexport default function ModdleCopy(eventBus, bpmnFactory, moddle) {\n  this._bpmnFactory = bpmnFactory;\n  this._eventBus = eventBus;\n  this._moddle = moddle;\n\n  // copy extension elements last\n  eventBus.on('moddleCopy.canCopyProperties', context => {\n    const {\n      propertyNames\n    } = context;\n    if (!propertyNames || !propertyNames.length) {\n      return;\n    }\n    return sortBy(propertyNames, propertyName => {\n      return propertyName === 'extensionElements';\n    });\n  });\n\n  // default check whether property can be copied\n  eventBus.on('moddleCopy.canCopyProperty', context => {\n    const {\n      parent,\n      property,\n      propertyName\n    } = context;\n    const parentDescriptor = isObject(parent) && parent.$descriptor;\n    if (propertyName && ALLOWED_REFERENCES.includes(propertyName)) {\n      // allow copying reference\n      return property;\n    }\n    if (propertyName && DISALLOWED_PROPERTIES.includes(propertyName)) {\n      // disallow copying property\n      return false;\n    }\n    if (propertyName && parentDescriptor && !find(parentDescriptor.properties, matchPattern({\n      name: propertyName\n    }))) {\n      // disallow copying property\n      return false;\n    }\n  });\n\n  // do NOT allow to copy empty extension elements\n  eventBus.on('moddleCopy.canSetCopiedProperty', context => {\n    const {\n      property\n    } = context;\n    if (is(property, 'bpmn:ExtensionElements') && (!property.values || !property.values.length)) {\n      // disallow setting copied property\n      return false;\n    }\n  });\n}\nModdleCopy.$inject = ['eventBus', 'bpmnFactory', 'moddle'];\n\n/**\n * Copy model properties of source element to target element.\n *\n * @param {ModdleElement} sourceElement\n * @param {ModdleElement} targetElement\n * @param {string[]} [propertyNames]\n * @param {boolean} [clone=false]\n *\n * @return {ModdleElement}\n */\nModdleCopy.prototype.copyElement = function (sourceElement, targetElement, propertyNames) {\n  let clone = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n  if (propertyNames && !isArray(propertyNames)) {\n    propertyNames = [propertyNames];\n  }\n  propertyNames = propertyNames || getPropertyNames(sourceElement.$descriptor);\n  const canCopyProperties = this._eventBus.fire('moddleCopy.canCopyProperties', {\n    propertyNames: propertyNames,\n    sourceElement: sourceElement,\n    targetElement: targetElement,\n    clone: clone\n  });\n  if (canCopyProperties === false) {\n    return targetElement;\n  }\n  if (isArray(canCopyProperties)) {\n    propertyNames = canCopyProperties;\n  }\n\n  // copy properties\n  forEach(propertyNames, propertyName => {\n    let sourceProperty;\n    if (has(sourceElement, propertyName)) {\n      sourceProperty = sourceElement.get(propertyName);\n    }\n    const copiedProperty = this.copyProperty(sourceProperty, targetElement, propertyName, clone);\n    if (!isDefined(copiedProperty)) {\n      return;\n    }\n    const canSetProperty = this._eventBus.fire('moddleCopy.canSetCopiedProperty', {\n      parent: targetElement,\n      property: copiedProperty,\n      propertyName: propertyName\n    });\n    if (canSetProperty === false) {\n      return;\n    }\n\n    // TODO(nikku): unclaim old IDs if ID property is copied over\n    // this._moddle.getPropertyDescriptor(parent, propertyName)\n    targetElement.set(propertyName, copiedProperty);\n  });\n  return targetElement;\n};\n\n/**\n * Copy model property.\n *\n * @param {any} property\n * @param {ModdleElement} parent\n * @param {string} propertyName\n * @param {boolean} [clone=false]\n *\n * @return {any}\n */\nModdleCopy.prototype.copyProperty = function (property, parent, propertyName) {\n  let clone = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n  // allow others to copy property\n  let copiedProperty = this._eventBus.fire('moddleCopy.canCopyProperty', {\n    parent: parent,\n    property: property,\n    propertyName: propertyName,\n    clone: clone\n  });\n\n  // return if copying is NOT allowed\n  if (copiedProperty === false) {\n    return;\n  }\n  if (copiedProperty) {\n    if (isObject(copiedProperty) && copiedProperty.$type && !copiedProperty.$parent) {\n      copiedProperty.$parent = parent;\n    }\n    return copiedProperty;\n  }\n  const propertyDescriptor = this._moddle.getPropertyDescriptor(parent, propertyName);\n\n  // do NOT copy references\n  if (propertyDescriptor.isReference) {\n    return;\n  }\n\n  // copy id\n  if (propertyDescriptor.isId) {\n    return property && this._copyId(property, parent, clone);\n  }\n\n  // copy arrays\n  if (isArray(property)) {\n    return reduce(property, (childProperties, childProperty) => {\n      // recursion\n      const copiedProperty = this.copyProperty(childProperty, parent, propertyName, clone);\n\n      // copying might NOT be allowed\n      if (copiedProperty) {\n        return childProperties.concat(copiedProperty);\n      }\n      return childProperties;\n    }, []);\n  }\n\n  // copy model elements\n  if (isObject(property) && property.$type) {\n    if (this._moddle.getElementDescriptor(property).isGeneric) {\n      return;\n    }\n    copiedProperty = this._bpmnFactory.create(property.$type);\n    copiedProperty.$parent = parent;\n\n    // recursion\n    copiedProperty = this.copyElement(property, copiedProperty, null, clone);\n    return copiedProperty;\n  }\n\n  // copy primitive properties\n  return property;\n};\nModdleCopy.prototype._copyId = function (id, element) {\n  let clone = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n  if (clone) {\n    return id;\n  }\n\n  // disallow if already taken\n  if (this._moddle.ids.assigned(id)) {\n    return;\n  } else {\n    this._moddle.ids.claim(id, element);\n    return id;\n  }\n};\n\n// helpers //////////\n\nexport function getPropertyNames(descriptor, keepDefaultProperties) {\n  return reduce(descriptor.properties, (properties, property) => {\n    if (keepDefaultProperties && property.default) {\n      return properties;\n    }\n    return properties.concat(property.name);\n  }, []);\n}","map":{"version":3,"names":["find","forEach","has","isArray","isDefined","isObject","matchPattern","reduce","sortBy","is","DISALLOWED_PROPERTIES","ALLOWED_REFERENCES","ModdleCopy","eventBus","bpmnFactory","moddle","_bpmnFactory","_eventBus","_moddle","on","context","propertyNames","length","propertyName","parent","property","parentDescriptor","$descriptor","includes","properties","name","values","$inject","prototype","copyElement","sourceElement","targetElement","clone","arguments","undefined","getPropertyNames","canCopyProperties","fire","sourceProperty","get","copiedProperty","copyProperty","canSetProperty","set","$type","$parent","propertyDescriptor","getPropertyDescriptor","isReference","isId","_copyId","childProperties","childProperty","concat","getElementDescriptor","isGeneric","create","id","element","ids","assigned","claim","descriptor","keepDefaultProperties","default"],"sources":["/home/runner/work/sgex/sgex/node_modules/bpmn-js/lib/features/copy-paste/ModdleCopy.js"],"sourcesContent":["import {\n  find,\n  forEach,\n  has,\n  isArray,\n  isDefined,\n  isObject,\n  matchPattern,\n  reduce,\n  sortBy\n} from 'min-dash';\n\nimport { is } from '../../util/ModelUtil';\n\nconst DISALLOWED_PROPERTIES = [\n  'artifacts',\n  'dataInputAssociations',\n  'dataOutputAssociations',\n  'default',\n  'flowElements',\n  'lanes',\n  'incoming',\n  'outgoing',\n  'categoryValue'\n];\n\nconst ALLOWED_REFERENCES = [\n  'errorRef',\n  'escalationRef',\n  'messageRef',\n  'signalRef'\n];\n\n/**\n * @typedef {import('diagram-js/lib/core/EventBus').default} EventBus\n * @typedef {import('../modeling/BpmnFactory').default} BpmnFactory\n * @typedef {import('../../model/Types').Moddle} Moddle\n *\n * @typedef {import('../../model/Types').ModdleElement} ModdleElement\n */\n\n/**\n * Utility for copying model properties from source element to target element.\n *\n * @param {EventBus} eventBus\n * @param {BpmnFactory} bpmnFactory\n * @param {Moddle} moddle\n */\nexport default function ModdleCopy(eventBus, bpmnFactory, moddle) {\n  this._bpmnFactory = bpmnFactory;\n  this._eventBus = eventBus;\n  this._moddle = moddle;\n\n  // copy extension elements last\n  eventBus.on('moddleCopy.canCopyProperties', (context) => {\n    const { propertyNames } = context;\n\n    if (!propertyNames || !propertyNames.length) {\n      return;\n    }\n\n    return sortBy(propertyNames, (propertyName) => {\n      return propertyName === 'extensionElements';\n    });\n  });\n\n  // default check whether property can be copied\n  eventBus.on('moddleCopy.canCopyProperty', (context) => {\n    const {\n      parent,\n      property,\n      propertyName\n    } = context;\n\n    const parentDescriptor = isObject(parent) && parent.$descriptor;\n\n    if (propertyName && ALLOWED_REFERENCES.includes(propertyName)) {\n\n      // allow copying reference\n      return property;\n    }\n\n    if (propertyName && DISALLOWED_PROPERTIES.includes(propertyName)) {\n\n      // disallow copying property\n      return false;\n    }\n\n    if (propertyName &&\n      parentDescriptor &&\n      !find(parentDescriptor.properties, matchPattern({ name: propertyName }))) {\n\n      // disallow copying property\n      return false;\n    }\n  });\n\n  // do NOT allow to copy empty extension elements\n  eventBus.on('moddleCopy.canSetCopiedProperty', (context) => {\n    const { property } = context;\n\n    if (is(property, 'bpmn:ExtensionElements') && (!property.values || !property.values.length)) {\n\n      // disallow setting copied property\n      return false;\n    }\n  });\n}\n\nModdleCopy.$inject = [\n  'eventBus',\n  'bpmnFactory',\n  'moddle'\n];\n\n/**\n * Copy model properties of source element to target element.\n *\n * @param {ModdleElement} sourceElement\n * @param {ModdleElement} targetElement\n * @param {string[]} [propertyNames]\n * @param {boolean} [clone=false]\n *\n * @return {ModdleElement}\n */\nModdleCopy.prototype.copyElement = function(sourceElement, targetElement, propertyNames, clone = false) {\n  if (propertyNames && !isArray(propertyNames)) {\n    propertyNames = [ propertyNames ];\n  }\n\n  propertyNames = propertyNames || getPropertyNames(sourceElement.$descriptor);\n\n  const canCopyProperties = this._eventBus.fire('moddleCopy.canCopyProperties', {\n    propertyNames: propertyNames,\n    sourceElement: sourceElement,\n    targetElement: targetElement,\n    clone: clone\n  });\n\n  if (canCopyProperties === false) {\n    return targetElement;\n  }\n\n  if (isArray(canCopyProperties)) {\n    propertyNames = canCopyProperties;\n  }\n\n  // copy properties\n  forEach(propertyNames, (propertyName) => {\n    let sourceProperty;\n\n    if (has(sourceElement, propertyName)) {\n      sourceProperty = sourceElement.get(propertyName);\n    }\n\n    const copiedProperty = this.copyProperty(sourceProperty, targetElement, propertyName, clone);\n\n    if (!isDefined(copiedProperty)) {\n      return;\n    }\n\n    const canSetProperty = this._eventBus.fire('moddleCopy.canSetCopiedProperty', {\n      parent: targetElement,\n      property: copiedProperty,\n      propertyName: propertyName\n    });\n\n    if (canSetProperty === false) {\n      return;\n    }\n\n    // TODO(nikku): unclaim old IDs if ID property is copied over\n    // this._moddle.getPropertyDescriptor(parent, propertyName)\n    targetElement.set(propertyName, copiedProperty);\n  });\n\n  return targetElement;\n};\n\n/**\n * Copy model property.\n *\n * @param {any} property\n * @param {ModdleElement} parent\n * @param {string} propertyName\n * @param {boolean} [clone=false]\n *\n * @return {any}\n */\nModdleCopy.prototype.copyProperty = function(property, parent, propertyName, clone = false) {\n\n  // allow others to copy property\n  let copiedProperty = this._eventBus.fire('moddleCopy.canCopyProperty', {\n    parent: parent,\n    property: property,\n    propertyName: propertyName,\n    clone: clone\n  });\n\n  // return if copying is NOT allowed\n  if (copiedProperty === false) {\n    return;\n  }\n\n  if (copiedProperty) {\n    if (isObject(copiedProperty) && copiedProperty.$type && !copiedProperty.$parent) {\n      copiedProperty.$parent = parent;\n    }\n\n    return copiedProperty;\n  }\n\n  const propertyDescriptor = this._moddle.getPropertyDescriptor(parent, propertyName);\n\n  // do NOT copy references\n  if (propertyDescriptor.isReference) {\n    return;\n  }\n\n  // copy id\n  if (propertyDescriptor.isId) {\n    return property && this._copyId(property, parent, clone);\n  }\n\n  // copy arrays\n  if (isArray(property)) {\n    return reduce(property, (childProperties, childProperty) => {\n\n      // recursion\n      const copiedProperty = this.copyProperty(childProperty, parent, propertyName, clone);\n\n      // copying might NOT be allowed\n      if (copiedProperty) {\n        return childProperties.concat(copiedProperty);\n      }\n\n      return childProperties;\n    }, []);\n  }\n\n  // copy model elements\n  if (isObject(property) && property.$type) {\n    if (this._moddle.getElementDescriptor(property).isGeneric) {\n      return;\n    }\n\n    copiedProperty = this._bpmnFactory.create(property.$type);\n\n    copiedProperty.$parent = parent;\n\n    // recursion\n    copiedProperty = this.copyElement(property, copiedProperty, null, clone);\n\n    return copiedProperty;\n  }\n\n  // copy primitive properties\n  return property;\n};\n\nModdleCopy.prototype._copyId = function(id, element, clone = false) {\n  if (clone) {\n    return id;\n  }\n\n  // disallow if already taken\n  if (this._moddle.ids.assigned(id)) {\n    return;\n  } else {\n\n    this._moddle.ids.claim(id, element);\n    return id;\n  }\n};\n\n// helpers //////////\n\nexport function getPropertyNames(descriptor, keepDefaultProperties) {\n  return reduce(descriptor.properties, (properties, property) => {\n\n    if (keepDefaultProperties && property.default) {\n      return properties;\n    }\n\n    return properties.concat(property.name);\n  }, []);\n}"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}