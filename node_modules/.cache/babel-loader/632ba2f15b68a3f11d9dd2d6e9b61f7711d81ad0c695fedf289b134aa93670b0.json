{"ast":null,"code":"import { getChildLanes, LANE_INDENTATION } from '../util/LaneUtil';\nimport { isHorizontal } from '../../../util/DiUtil';\n\n/**\n * @typedef {import('diagram-js/lib/command/CommandHandler').default} CommandHandler\n *\n * @typedef {import('../Modeling').default} Modeling\n */\n\n/**\n * A handler that splits a lane into a number of sub-lanes,\n * creating new sub lanes, if necessary.\n *\n * @implements {CommandHandler}\n *\n * @param {Modeling} modeling\n */\nexport default function SplitLaneHandler(modeling) {\n  this._modeling = modeling;\n}\nSplitLaneHandler.$inject = ['modeling'];\nSplitLaneHandler.prototype.preExecute = function (context) {\n  var modeling = this._modeling;\n  var shape = context.shape,\n    newLanesCount = context.count;\n  var childLanes = getChildLanes(shape),\n    existingLanesCount = childLanes.length;\n  if (existingLanesCount > newLanesCount) {\n    throw new Error(`more than <${newLanesCount}> child lanes`);\n  }\n  var isHorizontalLane = isHorizontal(shape);\n  var laneBaseSize = isHorizontalLane ? shape.height : shape.width;\n  var newLanesSize = Math.round(laneBaseSize / newLanesCount);\n\n  // Iterate from first to last in child lane order,\n  // resizing existing lanes and creating new ones\n  // so that they split the parent proportionally.\n  //\n  // Due to rounding related errors, the last lane\n  // needs to take up all the remaining space.\n  var laneSize, laneBounds, newLaneAttrs, idx;\n  for (idx = 0; idx < newLanesCount; idx++) {\n    // if last lane\n    if (idx === newLanesCount - 1) {\n      laneSize = laneBaseSize - newLanesSize * idx;\n    } else {\n      laneSize = newLanesSize;\n    }\n    laneBounds = isHorizontalLane ? {\n      x: shape.x + LANE_INDENTATION,\n      y: shape.y + idx * newLanesSize,\n      width: shape.width - LANE_INDENTATION,\n      height: laneSize\n    } : {\n      x: shape.x + idx * newLanesSize,\n      y: shape.y + LANE_INDENTATION,\n      width: laneSize,\n      height: shape.height - LANE_INDENTATION\n    };\n    if (idx < existingLanesCount) {\n      // resize existing lane\n      modeling.resizeShape(childLanes[idx], laneBounds);\n    } else {\n      // create a new lane at position\n      newLaneAttrs = {\n        type: 'bpmn:Lane',\n        isHorizontal: isHorizontalLane\n      };\n      modeling.createShape(newLaneAttrs, laneBounds, shape);\n    }\n  }\n};","map":{"version":3,"names":["getChildLanes","LANE_INDENTATION","isHorizontal","SplitLaneHandler","modeling","_modeling","$inject","prototype","preExecute","context","shape","newLanesCount","count","childLanes","existingLanesCount","length","Error","isHorizontalLane","laneBaseSize","height","width","newLanesSize","Math","round","laneSize","laneBounds","newLaneAttrs","idx","x","y","resizeShape","type","createShape"],"sources":["/home/runner/work/sgex/sgex/node_modules/bpmn-js/lib/features/modeling/cmd/SplitLaneHandler.js"],"sourcesContent":["import {\n  getChildLanes,\n  LANE_INDENTATION\n} from '../util/LaneUtil';\n\nimport {\n  isHorizontal\n} from '../../../util/DiUtil';\n\n/**\n * @typedef {import('diagram-js/lib/command/CommandHandler').default} CommandHandler\n *\n * @typedef {import('../Modeling').default} Modeling\n */\n\n/**\n * A handler that splits a lane into a number of sub-lanes,\n * creating new sub lanes, if necessary.\n *\n * @implements {CommandHandler}\n *\n * @param {Modeling} modeling\n */\nexport default function SplitLaneHandler(modeling) {\n  this._modeling = modeling;\n}\n\nSplitLaneHandler.$inject = [\n  'modeling'\n];\n\n\nSplitLaneHandler.prototype.preExecute = function(context) {\n\n  var modeling = this._modeling;\n\n  var shape = context.shape,\n      newLanesCount = context.count;\n\n  var childLanes = getChildLanes(shape),\n      existingLanesCount = childLanes.length;\n\n  if (existingLanesCount > newLanesCount) {\n    throw new Error(`more than <${ newLanesCount }> child lanes`);\n  }\n\n  var isHorizontalLane = isHorizontal(shape);\n\n  var laneBaseSize = isHorizontalLane ? shape.height : shape.width;\n  var newLanesSize = Math.round(laneBaseSize / newLanesCount);\n\n  // Iterate from first to last in child lane order,\n  // resizing existing lanes and creating new ones\n  // so that they split the parent proportionally.\n  //\n  // Due to rounding related errors, the last lane\n  // needs to take up all the remaining space.\n  var laneSize,\n      laneBounds,\n      newLaneAttrs,\n      idx;\n\n  for (idx = 0; idx < newLanesCount; idx++) {\n\n    // if last lane\n    if (idx === newLanesCount - 1) {\n      laneSize = laneBaseSize - (newLanesSize * idx);\n    } else {\n      laneSize = newLanesSize;\n    }\n\n    laneBounds = isHorizontalLane ? {\n      x: shape.x + LANE_INDENTATION,\n      y: shape.y + idx * newLanesSize,\n      width: shape.width - LANE_INDENTATION,\n      height: laneSize\n    } : {\n      x: shape.x + idx * newLanesSize,\n      y: shape.y + LANE_INDENTATION,\n      width: laneSize,\n      height: shape.height - LANE_INDENTATION\n    };\n\n    if (idx < existingLanesCount) {\n\n      // resize existing lane\n      modeling.resizeShape(childLanes[idx], laneBounds);\n    } else {\n\n      // create a new lane at position\n      newLaneAttrs = {\n        type: 'bpmn:Lane',\n        isHorizontal: isHorizontalLane\n      };\n\n      modeling.createShape(newLaneAttrs, laneBounds, shape);\n    }\n  }\n};\n"],"mappings":"AAAA,SACEA,aAAa,EACbC,gBAAgB,QACX,kBAAkB;AAEzB,SACEC,YAAY,QACP,sBAAsB;;AAE7B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,SAASC,gBAAgBA,CAACC,QAAQ,EAAE;EACjD,IAAI,CAACC,SAAS,GAAGD,QAAQ;AAC3B;AAEAD,gBAAgB,CAACG,OAAO,GAAG,CACzB,UAAU,CACX;AAGDH,gBAAgB,CAACI,SAAS,CAACC,UAAU,GAAG,UAASC,OAAO,EAAE;EAExD,IAAIL,QAAQ,GAAG,IAAI,CAACC,SAAS;EAE7B,IAAIK,KAAK,GAAGD,OAAO,CAACC,KAAK;IACrBC,aAAa,GAAGF,OAAO,CAACG,KAAK;EAEjC,IAAIC,UAAU,GAAGb,aAAa,CAACU,KAAK,CAAC;IACjCI,kBAAkB,GAAGD,UAAU,CAACE,MAAM;EAE1C,IAAID,kBAAkB,GAAGH,aAAa,EAAE;IACtC,MAAM,IAAIK,KAAK,CAAC,cAAeL,aAAa,eAAgB,CAAC;EAC/D;EAEA,IAAIM,gBAAgB,GAAGf,YAAY,CAACQ,KAAK,CAAC;EAE1C,IAAIQ,YAAY,GAAGD,gBAAgB,GAAGP,KAAK,CAACS,MAAM,GAAGT,KAAK,CAACU,KAAK;EAChE,IAAIC,YAAY,GAAGC,IAAI,CAACC,KAAK,CAACL,YAAY,GAAGP,aAAa,CAAC;;EAE3D;EACA;EACA;EACA;EACA;EACA;EACA,IAAIa,QAAQ,EACRC,UAAU,EACVC,YAAY,EACZC,GAAG;EAEP,KAAKA,GAAG,GAAG,CAAC,EAAEA,GAAG,GAAGhB,aAAa,EAAEgB,GAAG,EAAE,EAAE;IAExC;IACA,IAAIA,GAAG,KAAKhB,aAAa,GAAG,CAAC,EAAE;MAC7Ba,QAAQ,GAAGN,YAAY,GAAIG,YAAY,GAAGM,GAAI;IAChD,CAAC,MAAM;MACLH,QAAQ,GAAGH,YAAY;IACzB;IAEAI,UAAU,GAAGR,gBAAgB,GAAG;MAC9BW,CAAC,EAAElB,KAAK,CAACkB,CAAC,GAAG3B,gBAAgB;MAC7B4B,CAAC,EAAEnB,KAAK,CAACmB,CAAC,GAAGF,GAAG,GAAGN,YAAY;MAC/BD,KAAK,EAAEV,KAAK,CAACU,KAAK,GAAGnB,gBAAgB;MACrCkB,MAAM,EAAEK;IACV,CAAC,GAAG;MACFI,CAAC,EAAElB,KAAK,CAACkB,CAAC,GAAGD,GAAG,GAAGN,YAAY;MAC/BQ,CAAC,EAAEnB,KAAK,CAACmB,CAAC,GAAG5B,gBAAgB;MAC7BmB,KAAK,EAAEI,QAAQ;MACfL,MAAM,EAAET,KAAK,CAACS,MAAM,GAAGlB;IACzB,CAAC;IAED,IAAI0B,GAAG,GAAGb,kBAAkB,EAAE;MAE5B;MACAV,QAAQ,CAAC0B,WAAW,CAACjB,UAAU,CAACc,GAAG,CAAC,EAAEF,UAAU,CAAC;IACnD,CAAC,MAAM;MAEL;MACAC,YAAY,GAAG;QACbK,IAAI,EAAE,WAAW;QACjB7B,YAAY,EAAEe;MAChB,CAAC;MAEDb,QAAQ,CAAC4B,WAAW,CAACN,YAAY,EAAED,UAAU,EAAEf,KAAK,CAAC;IACvD;EACF;AACF,CAAC","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}