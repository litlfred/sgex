{"ast":null,"code":"import inherits from 'inherits-browser';\nimport { getOrientation, getMid, asTRBL } from 'diagram-js/lib/layout/LayoutUtil';\nimport { substract } from 'diagram-js/lib/util/Math';\nimport { hasExternalLabel } from '../../../util/LabelUtil';\nimport CommandInterceptor from 'diagram-js/lib/command/CommandInterceptor';\nimport { isConnection } from 'diagram-js/lib/util/ModelUtil';\n\n/**\n * @typedef {import('diagram-js/lib/core/EventBus').default} EventBus\n * @typedef {import('../Modeling').default} Modeling\n *\n * @typedef {import('../../../model/Types').Element} Element\n * @typedef {import('../../../model/Types').Shape} Shape\n *\n * @typedef {import('diagram-js/lib/util/Types').DirectionTRBL} DirectionTRBL\n */\n\nvar ALIGNMENTS = ['top', 'bottom', 'left', 'right'];\nvar ELEMENT_LABEL_DISTANCE = 10;\n\n/**\n * A behavior that ensures that labels are positioned in a way that they do not\n * overlap with other elements or connections.\n *\n * @param {EventBus} eventBus\n * @param {Modeling} modeling\n */\nexport default function AdaptiveLabelPositioningBehavior(eventBus, modeling) {\n  CommandInterceptor.call(this, eventBus);\n  this.postExecuted(['connection.create', 'connection.layout', 'connection.updateWaypoints'], function (event) {\n    var context = event.context,\n      connection = context.connection,\n      source = connection.source,\n      target = connection.target,\n      hints = context.hints || {};\n    if (hints.createElementsBehavior !== false) {\n      checkLabelAdjustment(source);\n      checkLabelAdjustment(target);\n    }\n  });\n  this.postExecuted(['label.create'], function (event) {\n    var context = event.context,\n      shape = context.shape,\n      hints = context.hints || {};\n    if (hints.createElementsBehavior !== false) {\n      checkLabelAdjustment(shape.labelTarget);\n    }\n  });\n  this.postExecuted(['elements.create'], function (event) {\n    var context = event.context,\n      elements = context.elements,\n      hints = context.hints || {};\n    if (hints.createElementsBehavior !== false) {\n      elements.forEach(function (element) {\n        checkLabelAdjustment(element);\n      });\n    }\n  });\n  function checkLabelAdjustment(element) {\n    // skip non-existing labels\n    if (!hasExternalLabel(element)) {\n      return;\n    }\n    if (isConnection(element)) {\n      return;\n    }\n    var optimalPosition = getOptimalPosition(element);\n\n    // no optimal position found\n    if (!optimalPosition) {\n      return;\n    }\n    adjustLabelPosition(element, optimalPosition);\n  }\n  function adjustLabelPosition(element, orientation) {\n    var elementMid = getMid(element),\n      label = element.label,\n      labelMid = getMid(label);\n\n    // ignore labels that are being created\n    if (!label.parent) {\n      return;\n    }\n    var elementTrbl = asTRBL(element);\n    var newLabelMid;\n    switch (orientation) {\n      case 'top':\n        newLabelMid = {\n          x: elementMid.x,\n          y: elementTrbl.top - ELEMENT_LABEL_DISTANCE - label.height / 2\n        };\n        break;\n      case 'left':\n        newLabelMid = {\n          x: elementTrbl.left - ELEMENT_LABEL_DISTANCE - label.width / 2,\n          y: elementMid.y\n        };\n        break;\n      case 'bottom':\n        newLabelMid = {\n          x: elementMid.x,\n          y: elementTrbl.bottom + ELEMENT_LABEL_DISTANCE + label.height / 2\n        };\n        break;\n      case 'right':\n        newLabelMid = {\n          x: elementTrbl.right + ELEMENT_LABEL_DISTANCE + label.width / 2,\n          y: elementMid.y\n        };\n        break;\n    }\n    var delta = substract(newLabelMid, labelMid);\n    modeling.moveShape(label, delta);\n  }\n}\ninherits(AdaptiveLabelPositioningBehavior, CommandInterceptor);\nAdaptiveLabelPositioningBehavior.$inject = ['eventBus', 'modeling'];\n\n// helpers //////////////////////\n\n/**\n * Return alignments which are taken by a boundary's host element\n *\n * @param {Shape} element\n *\n * @return {DirectionTRBL[]}\n */\nfunction getTakenHostAlignments(element) {\n  var hostElement = element.host,\n    elementMid = getMid(element),\n    hostOrientation = getOrientation(elementMid, hostElement);\n  var freeAlignments;\n\n  // check whether there is a multi-orientation, e.g. 'top-left'\n  if (hostOrientation.indexOf('-') >= 0) {\n    freeAlignments = hostOrientation.split('-');\n  } else {\n    freeAlignments = [hostOrientation];\n  }\n  var takenAlignments = ALIGNMENTS.filter(function (alignment) {\n    return freeAlignments.indexOf(alignment) === -1;\n  });\n  return takenAlignments;\n}\n\n/**\n * Return alignments which are taken by related connections\n *\n * @param {Element} element\n *\n * @return {DirectionTRBL[]}\n */\nfunction getTakenConnectionAlignments(element) {\n  var elementMid = getMid(element);\n  var takenAlignments = [].concat(element.incoming.map(function (c) {\n    return c.waypoints[c.waypoints.length - 2];\n  }), element.outgoing.map(function (c) {\n    return c.waypoints[1];\n  })).map(function (point) {\n    return getApproximateOrientation(elementMid, point);\n  });\n  return takenAlignments;\n}\n\n/**\n * Return the optimal label position around an element\n * or `undefined`, if none was found.\n *\n * @param  {Element} element\n *\n * @return {DirectionTRBL|undefined}\n */\nfunction getOptimalPosition(element) {\n  var labelMid = getMid(element.label);\n  var elementMid = getMid(element);\n  var labelOrientation = getApproximateOrientation(elementMid, labelMid);\n  if (!isAligned(labelOrientation)) {\n    return;\n  }\n  var takenAlignments = getTakenConnectionAlignments(element);\n  if (element.host) {\n    var takenHostAlignments = getTakenHostAlignments(element);\n    takenAlignments = takenAlignments.concat(takenHostAlignments);\n  }\n  var freeAlignments = ALIGNMENTS.filter(function (alignment) {\n    return takenAlignments.indexOf(alignment) === -1;\n  });\n\n  // NOTHING TO DO; label already aligned a.O.K.\n  if (freeAlignments.indexOf(labelOrientation) !== -1) {\n    return;\n  }\n  return freeAlignments[0];\n}\nfunction getApproximateOrientation(p0, p1) {\n  return getOrientation(p1, p0, 5);\n}\nfunction isAligned(orientation) {\n  return ALIGNMENTS.indexOf(orientation) !== -1;\n}","map":{"version":3,"names":["inherits","getOrientation","getMid","asTRBL","substract","hasExternalLabel","CommandInterceptor","isConnection","ALIGNMENTS","ELEMENT_LABEL_DISTANCE","AdaptiveLabelPositioningBehavior","eventBus","modeling","call","postExecuted","event","context","connection","source","target","hints","createElementsBehavior","checkLabelAdjustment","shape","labelTarget","elements","forEach","element","optimalPosition","getOptimalPosition","adjustLabelPosition","orientation","elementMid","label","labelMid","parent","elementTrbl","newLabelMid","x","y","top","height","left","width","bottom","right","delta","moveShape","$inject","getTakenHostAlignments","hostElement","host","hostOrientation","freeAlignments","indexOf","split","takenAlignments","filter","alignment","getTakenConnectionAlignments","concat","incoming","map","c","waypoints","length","outgoing","point","getApproximateOrientation","labelOrientation","isAligned","takenHostAlignments","p0","p1"],"sources":["/home/runner/work/sgex/sgex/node_modules/bpmn-js/lib/features/modeling/behavior/AdaptiveLabelPositioningBehavior.js"],"sourcesContent":["import inherits from 'inherits-browser';\n\nimport {\n  getOrientation,\n  getMid,\n  asTRBL\n} from 'diagram-js/lib/layout/LayoutUtil';\n\nimport {\n  substract\n} from 'diagram-js/lib/util/Math';\n\nimport {\n  hasExternalLabel\n} from '../../../util/LabelUtil';\n\nimport CommandInterceptor from 'diagram-js/lib/command/CommandInterceptor';\nimport { isConnection } from 'diagram-js/lib/util/ModelUtil';\n\n/**\n * @typedef {import('diagram-js/lib/core/EventBus').default} EventBus\n * @typedef {import('../Modeling').default} Modeling\n *\n * @typedef {import('../../../model/Types').Element} Element\n * @typedef {import('../../../model/Types').Shape} Shape\n *\n * @typedef {import('diagram-js/lib/util/Types').DirectionTRBL} DirectionTRBL\n */\n\nvar ALIGNMENTS = [\n  'top',\n  'bottom',\n  'left',\n  'right'\n];\n\nvar ELEMENT_LABEL_DISTANCE = 10;\n\n/**\n * A behavior that ensures that labels are positioned in a way that they do not\n * overlap with other elements or connections.\n *\n * @param {EventBus} eventBus\n * @param {Modeling} modeling\n */\nexport default function AdaptiveLabelPositioningBehavior(eventBus, modeling) {\n\n  CommandInterceptor.call(this, eventBus);\n\n  this.postExecuted([\n    'connection.create',\n    'connection.layout',\n    'connection.updateWaypoints'\n  ], function(event) {\n    var context = event.context,\n        connection = context.connection,\n        source = connection.source,\n        target = connection.target,\n        hints = context.hints || {};\n\n    if (hints.createElementsBehavior !== false) {\n      checkLabelAdjustment(source);\n      checkLabelAdjustment(target);\n    }\n  });\n\n\n  this.postExecuted([\n    'label.create'\n  ], function(event) {\n    var context = event.context,\n        shape = context.shape,\n        hints = context.hints || {};\n\n    if (hints.createElementsBehavior !== false) {\n      checkLabelAdjustment(shape.labelTarget);\n    }\n  });\n\n\n  this.postExecuted([\n    'elements.create'\n  ], function(event) {\n    var context = event.context,\n        elements = context.elements,\n        hints = context.hints || {};\n\n    if (hints.createElementsBehavior !== false) {\n      elements.forEach(function(element) {\n        checkLabelAdjustment(element);\n      });\n    }\n  });\n\n  function checkLabelAdjustment(element) {\n\n    // skip non-existing labels\n    if (!hasExternalLabel(element)) {\n      return;\n    }\n\n    if (isConnection(element)) {\n      return;\n    }\n\n    var optimalPosition = getOptimalPosition(element);\n\n    // no optimal position found\n    if (!optimalPosition) {\n      return;\n    }\n\n    adjustLabelPosition(element, optimalPosition);\n  }\n\n  function adjustLabelPosition(element, orientation) {\n\n    var elementMid = getMid(element),\n        label = element.label,\n        labelMid = getMid(label);\n\n    // ignore labels that are being created\n    if (!label.parent) {\n      return;\n    }\n\n    var elementTrbl = asTRBL(element);\n\n    var newLabelMid;\n\n    switch (orientation) {\n    case 'top':\n      newLabelMid = {\n        x: elementMid.x,\n        y: elementTrbl.top - ELEMENT_LABEL_DISTANCE - label.height / 2\n      };\n\n      break;\n\n    case 'left':\n\n      newLabelMid = {\n        x: elementTrbl.left - ELEMENT_LABEL_DISTANCE - label.width / 2,\n        y: elementMid.y\n      };\n\n      break;\n\n    case 'bottom':\n\n      newLabelMid = {\n        x: elementMid.x,\n        y: elementTrbl.bottom + ELEMENT_LABEL_DISTANCE + label.height / 2\n      };\n\n      break;\n\n    case 'right':\n\n      newLabelMid = {\n        x: elementTrbl.right + ELEMENT_LABEL_DISTANCE + label.width / 2,\n        y: elementMid.y\n      };\n\n      break;\n    }\n\n    var delta = substract(newLabelMid, labelMid);\n\n    modeling.moveShape(label, delta);\n  }\n\n}\n\ninherits(AdaptiveLabelPositioningBehavior, CommandInterceptor);\n\nAdaptiveLabelPositioningBehavior.$inject = [\n  'eventBus',\n  'modeling'\n];\n\n\n// helpers //////////////////////\n\n/**\n * Return alignments which are taken by a boundary's host element\n *\n * @param {Shape} element\n *\n * @return {DirectionTRBL[]}\n */\nfunction getTakenHostAlignments(element) {\n\n  var hostElement = element.host,\n      elementMid = getMid(element),\n      hostOrientation = getOrientation(elementMid, hostElement);\n\n  var freeAlignments;\n\n  // check whether there is a multi-orientation, e.g. 'top-left'\n  if (hostOrientation.indexOf('-') >= 0) {\n    freeAlignments = hostOrientation.split('-');\n  } else {\n    freeAlignments = [ hostOrientation ];\n  }\n\n  var takenAlignments = ALIGNMENTS.filter(function(alignment) {\n\n    return freeAlignments.indexOf(alignment) === -1;\n  });\n\n  return takenAlignments;\n\n}\n\n/**\n * Return alignments which are taken by related connections\n *\n * @param {Element} element\n *\n * @return {DirectionTRBL[]}\n */\nfunction getTakenConnectionAlignments(element) {\n\n  var elementMid = getMid(element);\n\n  var takenAlignments = [].concat(\n    element.incoming.map(function(c) {\n      return c.waypoints[c.waypoints.length - 2 ];\n    }),\n    element.outgoing.map(function(c) {\n      return c.waypoints[1];\n    })\n  ).map(function(point) {\n    return getApproximateOrientation(elementMid, point);\n  });\n\n  return takenAlignments;\n}\n\n/**\n * Return the optimal label position around an element\n * or `undefined`, if none was found.\n *\n * @param  {Element} element\n *\n * @return {DirectionTRBL|undefined}\n */\nfunction getOptimalPosition(element) {\n\n  var labelMid = getMid(element.label);\n\n  var elementMid = getMid(element);\n\n  var labelOrientation = getApproximateOrientation(elementMid, labelMid);\n\n  if (!isAligned(labelOrientation)) {\n    return;\n  }\n\n  var takenAlignments = getTakenConnectionAlignments(element);\n\n  if (element.host) {\n    var takenHostAlignments = getTakenHostAlignments(element);\n\n    takenAlignments = takenAlignments.concat(takenHostAlignments);\n  }\n\n  var freeAlignments = ALIGNMENTS.filter(function(alignment) {\n\n    return takenAlignments.indexOf(alignment) === -1;\n  });\n\n  // NOTHING TO DO; label already aligned a.O.K.\n  if (freeAlignments.indexOf(labelOrientation) !== -1) {\n    return;\n  }\n\n  return freeAlignments[0];\n}\n\nfunction getApproximateOrientation(p0, p1) {\n  return getOrientation(p1, p0, 5);\n}\n\nfunction isAligned(orientation) {\n  return ALIGNMENTS.indexOf(orientation) !== -1;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}