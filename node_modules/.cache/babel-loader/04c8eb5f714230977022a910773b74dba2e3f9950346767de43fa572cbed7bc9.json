{"ast":null,"code":"\"use strict\";\n\nvar _objectSpread = require(\"/home/runner/work/sgex/sgex/node_modules/@babel/runtime/helpers/objectSpread2.js\").default;\nvar _taggedTemplateLiteral = require(\"/home/runner/work/sgex/sgex/node_modules/@babel/runtime/helpers/taggedTemplateLiteral.js\").default;\nvar _templateObject, _templateObject2, _templateObject3, _templateObject4, _templateObject5;\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ValueScope = exports.ValueScopeName = exports.Scope = exports.varKinds = exports.UsedValueState = void 0;\nconst code_1 = require(\"./code\");\nclass ValueError extends Error {\n  constructor(name) {\n    super(\"CodeGen: \\\"code\\\" for \".concat(name, \" not defined\"));\n    this.value = name.value;\n  }\n}\nvar UsedValueState;\n(function (UsedValueState) {\n  UsedValueState[UsedValueState[\"Started\"] = 0] = \"Started\";\n  UsedValueState[UsedValueState[\"Completed\"] = 1] = \"Completed\";\n})(UsedValueState || (exports.UsedValueState = UsedValueState = {}));\nexports.varKinds = {\n  const: new code_1.Name(\"const\"),\n  let: new code_1.Name(\"let\"),\n  var: new code_1.Name(\"var\")\n};\nclass Scope {\n  constructor() {\n    let {\n      prefixes,\n      parent\n    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    this._names = {};\n    this._prefixes = prefixes;\n    this._parent = parent;\n  }\n  toName(nameOrPrefix) {\n    return nameOrPrefix instanceof code_1.Name ? nameOrPrefix : this.name(nameOrPrefix);\n  }\n  name(prefix) {\n    return new code_1.Name(this._newName(prefix));\n  }\n  _newName(prefix) {\n    const ng = this._names[prefix] || this._nameGroup(prefix);\n    return \"\".concat(prefix).concat(ng.index++);\n  }\n  _nameGroup(prefix) {\n    var _a, _b;\n    if (((_b = (_a = this._parent) === null || _a === void 0 ? void 0 : _a._prefixes) === null || _b === void 0 ? void 0 : _b.has(prefix)) || this._prefixes && !this._prefixes.has(prefix)) {\n      throw new Error(\"CodeGen: prefix \\\"\".concat(prefix, \"\\\" is not allowed in this scope\"));\n    }\n    return this._names[prefix] = {\n      prefix,\n      index: 0\n    };\n  }\n}\nexports.Scope = Scope;\nclass ValueScopeName extends code_1.Name {\n  constructor(prefix, nameStr) {\n    super(nameStr);\n    this.prefix = prefix;\n  }\n  setValue(value, _ref) {\n    let {\n      property,\n      itemIndex\n    } = _ref;\n    this.value = value;\n    this.scopePath = (0, code_1._)(_templateObject || (_templateObject = _taggedTemplateLiteral([\".\", \"[\", \"]\"])), new code_1.Name(property), itemIndex);\n  }\n}\nexports.ValueScopeName = ValueScopeName;\nconst line = (0, code_1._)(_templateObject2 || (_templateObject2 = _taggedTemplateLiteral([\"\\n\"], [\"\\\\n\"])));\nclass ValueScope extends Scope {\n  constructor(opts) {\n    super(opts);\n    this._values = {};\n    this._scope = opts.scope;\n    this.opts = _objectSpread(_objectSpread({}, opts), {}, {\n      _n: opts.lines ? line : code_1.nil\n    });\n  }\n  get() {\n    return this._scope;\n  }\n  name(prefix) {\n    return new ValueScopeName(prefix, this._newName(prefix));\n  }\n  value(nameOrPrefix, value) {\n    var _a;\n    if (value.ref === undefined) throw new Error(\"CodeGen: ref must be passed in value\");\n    const name = this.toName(nameOrPrefix);\n    const {\n      prefix\n    } = name;\n    const valueKey = (_a = value.key) !== null && _a !== void 0 ? _a : value.ref;\n    let vs = this._values[prefix];\n    if (vs) {\n      const _name = vs.get(valueKey);\n      if (_name) return _name;\n    } else {\n      vs = this._values[prefix] = new Map();\n    }\n    vs.set(valueKey, name);\n    const s = this._scope[prefix] || (this._scope[prefix] = []);\n    const itemIndex = s.length;\n    s[itemIndex] = value.ref;\n    name.setValue(value, {\n      property: prefix,\n      itemIndex\n    });\n    return name;\n  }\n  getValue(prefix, keyOrRef) {\n    const vs = this._values[prefix];\n    if (!vs) return;\n    return vs.get(keyOrRef);\n  }\n  scopeRefs(scopeName) {\n    let values = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this._values;\n    return this._reduceValues(values, name => {\n      if (name.scopePath === undefined) throw new Error(\"CodeGen: name \\\"\".concat(name, \"\\\" has no value\"));\n      return (0, code_1._)(_templateObject3 || (_templateObject3 = _taggedTemplateLiteral([\"\", \"\", \"\"])), scopeName, name.scopePath);\n    });\n  }\n  scopeCode() {\n    let values = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this._values;\n    let usedValues = arguments.length > 1 ? arguments[1] : undefined;\n    let getCode = arguments.length > 2 ? arguments[2] : undefined;\n    return this._reduceValues(values, name => {\n      if (name.value === undefined) throw new Error(\"CodeGen: name \\\"\".concat(name, \"\\\" has no value\"));\n      return name.value.code;\n    }, usedValues, getCode);\n  }\n  _reduceValues(values, valueCode) {\n    let usedValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    let getCode = arguments.length > 3 ? arguments[3] : undefined;\n    let code = code_1.nil;\n    for (const prefix in values) {\n      const vs = values[prefix];\n      if (!vs) continue;\n      const nameSet = usedValues[prefix] = usedValues[prefix] || new Map();\n      vs.forEach(name => {\n        if (nameSet.has(name)) return;\n        nameSet.set(name, UsedValueState.Started);\n        let c = valueCode(name);\n        if (c) {\n          const def = this.opts.es5 ? exports.varKinds.var : exports.varKinds.const;\n          code = (0, code_1._)(_templateObject4 || (_templateObject4 = _taggedTemplateLiteral([\"\", \"\", \" \", \" = \", \";\", \"\"])), code, def, name, c, this.opts._n);\n        } else if (c = getCode === null || getCode === void 0 ? void 0 : getCode(name)) {\n          code = (0, code_1._)(_templateObject5 || (_templateObject5 = _taggedTemplateLiteral([\"\", \"\", \"\", \"\"])), code, c, this.opts._n);\n        } else {\n          throw new ValueError(name);\n        }\n        nameSet.set(name, UsedValueState.Completed);\n      });\n    }\n    return code;\n  }\n}\nexports.ValueScope = ValueScope;","map":{"version":3,"names":["code_1","require","ValueError","Error","constructor","name","concat","value","UsedValueState","exports","varKinds","const","Name","let","var","Scope","prefixes","parent","arguments","length","undefined","_names","_prefixes","_parent","toName","nameOrPrefix","prefix","_newName","ng","_nameGroup","index","_b","_a","has","ValueScopeName","nameStr","setValue","_ref","property","itemIndex","scopePath","_","_templateObject","_taggedTemplateLiteral","line","_templateObject2","ValueScope","opts","_values","_scope","scope","_objectSpread","_n","lines","nil","get","ref","valueKey","key","vs","_name","Map","set","s","getValue","keyOrRef","scopeRefs","scopeName","values","_reduceValues","_templateObject3","scopeCode","usedValues","getCode","code","valueCode","nameSet","forEach","Started","c","def","es5","_templateObject4","_templateObject5","Completed"],"sources":["/home/runner/work/sgex/sgex/node_modules/ajv/lib/compile/codegen/scope.ts"],"sourcesContent":["import {_, nil, Code, Name} from \"./code\"\n\ninterface NameGroup {\n  prefix: string\n  index: number\n}\n\nexport interface NameValue {\n  ref: ValueReference // this is the reference to any value that can be referred to from generated code via `globals` var in the closure\n  key?: unknown // any key to identify a global to avoid duplicates, if not passed ref is used\n  code?: Code // this is the code creating the value needed for standalone code wit_out closure - can be a primitive value, function or import (`require`)\n}\n\nexport type ValueReference = unknown // possibly make CodeGen parameterized type on this type\n\nclass ValueError extends Error {\n  readonly value?: NameValue\n  constructor(name: ValueScopeName) {\n    super(`CodeGen: \"code\" for ${name} not defined`)\n    this.value = name.value\n  }\n}\n\ninterface ScopeOptions {\n  prefixes?: Set<string>\n  parent?: Scope\n}\n\ninterface ValueScopeOptions extends ScopeOptions {\n  scope: ScopeStore\n  es5?: boolean\n  lines?: boolean\n}\n\nexport type ScopeStore = Record<string, ValueReference[] | undefined>\n\ntype ScopeValues = {\n  [Prefix in string]?: Map<unknown, ValueScopeName>\n}\n\nexport type ScopeValueSets = {\n  [Prefix in string]?: Set<ValueScopeName>\n}\n\nexport enum UsedValueState {\n  Started,\n  Completed,\n}\n\nexport type UsedScopeValues = {\n  [Prefix in string]?: Map<ValueScopeName, UsedValueState | undefined>\n}\n\nexport const varKinds = {\n  const: new Name(\"const\"),\n  let: new Name(\"let\"),\n  var: new Name(\"var\"),\n}\n\nexport class Scope {\n  protected readonly _names: {[Prefix in string]?: NameGroup} = {}\n  protected readonly _prefixes?: Set<string>\n  protected readonly _parent?: Scope\n\n  constructor({prefixes, parent}: ScopeOptions = {}) {\n    this._prefixes = prefixes\n    this._parent = parent\n  }\n\n  toName(nameOrPrefix: Name | string): Name {\n    return nameOrPrefix instanceof Name ? nameOrPrefix : this.name(nameOrPrefix)\n  }\n\n  name(prefix: string): Name {\n    return new Name(this._newName(prefix))\n  }\n\n  protected _newName(prefix: string): string {\n    const ng = this._names[prefix] || this._nameGroup(prefix)\n    return `${prefix}${ng.index++}`\n  }\n\n  private _nameGroup(prefix: string): NameGroup {\n    if (this._parent?._prefixes?.has(prefix) || (this._prefixes && !this._prefixes.has(prefix))) {\n      throw new Error(`CodeGen: prefix \"${prefix}\" is not allowed in this scope`)\n    }\n    return (this._names[prefix] = {prefix, index: 0})\n  }\n}\n\ninterface ScopePath {\n  property: string\n  itemIndex: number\n}\n\nexport class ValueScopeName extends Name {\n  readonly prefix: string\n  value?: NameValue\n  scopePath?: Code\n\n  constructor(prefix: string, nameStr: string) {\n    super(nameStr)\n    this.prefix = prefix\n  }\n\n  setValue(value: NameValue, {property, itemIndex}: ScopePath): void {\n    this.value = value\n    this.scopePath = _`.${new Name(property)}[${itemIndex}]`\n  }\n}\n\ninterface VSOptions extends ValueScopeOptions {\n  _n: Code\n}\n\nconst line = _`\\n`\n\nexport class ValueScope extends Scope {\n  protected readonly _values: ScopeValues = {}\n  protected readonly _scope: ScopeStore\n  readonly opts: VSOptions\n\n  constructor(opts: ValueScopeOptions) {\n    super(opts)\n    this._scope = opts.scope\n    this.opts = {...opts, _n: opts.lines ? line : nil}\n  }\n\n  get(): ScopeStore {\n    return this._scope\n  }\n\n  name(prefix: string): ValueScopeName {\n    return new ValueScopeName(prefix, this._newName(prefix))\n  }\n\n  value(nameOrPrefix: ValueScopeName | string, value: NameValue): ValueScopeName {\n    if (value.ref === undefined) throw new Error(\"CodeGen: ref must be passed in value\")\n    const name = this.toName(nameOrPrefix) as ValueScopeName\n    const {prefix} = name\n    const valueKey = value.key ?? value.ref\n    let vs = this._values[prefix]\n    if (vs) {\n      const _name = vs.get(valueKey)\n      if (_name) return _name\n    } else {\n      vs = this._values[prefix] = new Map()\n    }\n    vs.set(valueKey, name)\n\n    const s = this._scope[prefix] || (this._scope[prefix] = [])\n    const itemIndex = s.length\n    s[itemIndex] = value.ref\n    name.setValue(value, {property: prefix, itemIndex})\n    return name\n  }\n\n  getValue(prefix: string, keyOrRef: unknown): ValueScopeName | undefined {\n    const vs = this._values[prefix]\n    if (!vs) return\n    return vs.get(keyOrRef)\n  }\n\n  scopeRefs(scopeName: Name, values: ScopeValues | ScopeValueSets = this._values): Code {\n    return this._reduceValues(values, (name: ValueScopeName) => {\n      if (name.scopePath === undefined) throw new Error(`CodeGen: name \"${name}\" has no value`)\n      return _`${scopeName}${name.scopePath}`\n    })\n  }\n\n  scopeCode(\n    values: ScopeValues | ScopeValueSets = this._values,\n    usedValues?: UsedScopeValues,\n    getCode?: (n: ValueScopeName) => Code | undefined\n  ): Code {\n    return this._reduceValues(\n      values,\n      (name: ValueScopeName) => {\n        if (name.value === undefined) throw new Error(`CodeGen: name \"${name}\" has no value`)\n        return name.value.code\n      },\n      usedValues,\n      getCode\n    )\n  }\n\n  private _reduceValues(\n    values: ScopeValues | ScopeValueSets,\n    valueCode: (n: ValueScopeName) => Code | undefined,\n    usedValues: UsedScopeValues = {},\n    getCode?: (n: ValueScopeName) => Code | undefined\n  ): Code {\n    let code: Code = nil\n    for (const prefix in values) {\n      const vs = values[prefix]\n      if (!vs) continue\n      const nameSet = (usedValues[prefix] = usedValues[prefix] || new Map())\n      vs.forEach((name: ValueScopeName) => {\n        if (nameSet.has(name)) return\n        nameSet.set(name, UsedValueState.Started)\n        let c = valueCode(name)\n        if (c) {\n          const def = this.opts.es5 ? varKinds.var : varKinds.const\n          code = _`${code}${def} ${name} = ${c};${this.opts._n}`\n        } else if ((c = getCode?.(name))) {\n          code = _`${code}${c}${this.opts._n}`\n        } else {\n          throw new ValueError(name)\n        }\n        nameSet.set(name, UsedValueState.Completed)\n      })\n    }\n    return code\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}