{"ast":null,"code":"/**\n * Utility for managing concurrent async operations with rate limiting\n *//**\n * Processes items concurrently with a specified concurrency limit\n * @param {Array} items - Items to process\n * @param {Function} processor - Async function to process each item\n * @param {Object} options - Options for concurrency control\n * @param {number} options.concurrency - Maximum concurrent operations (default: 5)\n * @param {Function} options.onProgress - Progress callback (current, total, item, result)\n * @param {Function} options.onItemComplete - Callback when item completes (item, result, error)\n * @param {Function} options.onItemStart - Callback when item starts processing (item, index)\n * @returns {Promise<Array>} Array of results (in original order)\n */export async function processConcurrently(items,processor){let options=arguments.length>2&&arguments[2]!==undefined?arguments[2]:{};const{concurrency=5,onProgress=null,onItemComplete=null,onItemStart=null}=options;if(!items||items.length===0){return[];}const results=new Array(items.length);const total=items.length;let completed=0;// Create a queue of work items\nconst queue=items.map((item,index)=>({item,index}));// Worker function that processes items from the queue\nconst worker=async()=>{while(queue.length>0){const{item,index}=queue.shift();// Notify that processing is starting\nif(onItemStart){onItemStart(item,index);}try{const result=await processor(item,index);results[index]=result;completed++;// Call callbacks\nif(onProgress){onProgress(completed,total,item,result);}if(onItemComplete){onItemComplete(item,result,null);}}catch(error){// Store error as result\nresults[index]={error,item};completed++;// Call callbacks\nif(onProgress){onProgress(completed,total,item,null);}if(onItemComplete){onItemComplete(item,null,error);}}}};// Start worker promises (limited by concurrency)\nconst workers=Array(Math.min(concurrency,items.length)).fill().map(()=>worker());// Wait for all workers to complete\nawait Promise.all(workers);return results;}/**\n * Rate-limited function executor\n * Useful for API calls that need to respect rate limits\n */export class RateLimiter{constructor(){let requestsPerSecond=arguments.length>0&&arguments[0]!==undefined?arguments[0]:5;this.requestsPerSecond=requestsPerSecond;this.requests=[];this.interval=1000/requestsPerSecond;// ms between requests\n}/**\n   * Execute a function with rate limiting\n   * @param {Function} fn - Function to execute\n   * @returns {Promise} Result of the function\n   */async execute(fn){const now=Date.now();// Remove requests older than 1 second\nthis.requests=this.requests.filter(time=>now-time<1000);// If we're at the limit, wait\nif(this.requests.length>=this.requestsPerSecond){const oldestRequest=Math.min(...this.requests);const waitTime=1000-(now-oldestRequest)+10;// Add 10ms buffer\nif(waitTime>0){await new Promise(resolve=>setTimeout(resolve,waitTime));}}// Record this request\nthis.requests.push(Date.now());// Execute the function\nreturn await fn();}}","map":{"version":3,"names":["processConcurrently","items","processor","options","arguments","length","undefined","concurrency","onProgress","onItemComplete","onItemStart","results","Array","total","completed","queue","map","item","index","worker","shift","result","error","workers","Math","min","fill","Promise","all","RateLimiter","constructor","requestsPerSecond","requests","interval","execute","fn","now","Date","filter","time","oldestRequest","waitTime","resolve","setTimeout","push"],"sources":["/home/runner/work/sgex/sgex/src/utils/concurrency.js"],"sourcesContent":["/**\n * Utility for managing concurrent async operations with rate limiting\n */\n\n/**\n * Processes items concurrently with a specified concurrency limit\n * @param {Array} items - Items to process\n * @param {Function} processor - Async function to process each item\n * @param {Object} options - Options for concurrency control\n * @param {number} options.concurrency - Maximum concurrent operations (default: 5)\n * @param {Function} options.onProgress - Progress callback (current, total, item, result)\n * @param {Function} options.onItemComplete - Callback when item completes (item, result, error)\n * @param {Function} options.onItemStart - Callback when item starts processing (item, index)\n * @returns {Promise<Array>} Array of results (in original order)\n */\nexport async function processConcurrently(items, processor, options = {}) {\n  const {\n    concurrency = 5,\n    onProgress = null,\n    onItemComplete = null,\n    onItemStart = null\n  } = options;\n\n  if (!items || items.length === 0) {\n    return [];\n  }\n\n  const results = new Array(items.length);\n  const total = items.length;\n  let completed = 0;\n\n  // Create a queue of work items\n  const queue = items.map((item, index) => ({ item, index }));\n  \n  // Worker function that processes items from the queue\n  const worker = async () => {\n    while (queue.length > 0) {\n      const { item, index } = queue.shift();\n      \n      // Notify that processing is starting\n      if (onItemStart) {\n        onItemStart(item, index);\n      }\n      \n      try {\n        const result = await processor(item, index);\n        results[index] = result;\n        \n        completed++;\n        \n        // Call callbacks\n        if (onProgress) {\n          onProgress(completed, total, item, result);\n        }\n        if (onItemComplete) {\n          onItemComplete(item, result, null);\n        }\n      } catch (error) {\n        // Store error as result\n        results[index] = { error, item };\n        \n        completed++;\n        \n        // Call callbacks\n        if (onProgress) {\n          onProgress(completed, total, item, null);\n        }\n        if (onItemComplete) {\n          onItemComplete(item, null, error);\n        }\n      }\n    }\n  };\n\n  // Start worker promises (limited by concurrency)\n  const workers = Array(Math.min(concurrency, items.length))\n    .fill()\n    .map(() => worker());\n\n  // Wait for all workers to complete\n  await Promise.all(workers);\n\n  return results;\n}\n\n/**\n * Rate-limited function executor\n * Useful for API calls that need to respect rate limits\n */\nexport class RateLimiter {\n  constructor(requestsPerSecond = 5) {\n    this.requestsPerSecond = requestsPerSecond;\n    this.requests = [];\n    this.interval = 1000 / requestsPerSecond; // ms between requests\n  }\n\n  /**\n   * Execute a function with rate limiting\n   * @param {Function} fn - Function to execute\n   * @returns {Promise} Result of the function\n   */\n  async execute(fn) {\n    const now = Date.now();\n    \n    // Remove requests older than 1 second\n    this.requests = this.requests.filter(time => now - time < 1000);\n    \n    // If we're at the limit, wait\n    if (this.requests.length >= this.requestsPerSecond) {\n      const oldestRequest = Math.min(...this.requests);\n      const waitTime = 1000 - (now - oldestRequest) + 10; // Add 10ms buffer\n      if (waitTime > 0) {\n        await new Promise(resolve => setTimeout(resolve, waitTime));\n      }\n    }\n    \n    // Record this request\n    this.requests.push(Date.now());\n    \n    // Execute the function\n    return await fn();\n  }\n}"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}