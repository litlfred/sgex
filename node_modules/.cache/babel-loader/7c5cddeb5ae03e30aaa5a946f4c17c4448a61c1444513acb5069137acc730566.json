{"ast":null,"code":"import { forEach, assign, find, isString, findIndex, filter, has } from 'min-dash';\nimport { Parser } from 'saxen';\nimport { coerceType, parseNameNS, isSimpleType, Moddle } from 'moddle';\nfunction hasLowerCaseAlias(pkg) {\n  return pkg.xml && pkg.xml.tagAlias === 'lowerCase';\n}\nvar DEFAULT_NS_MAP = {\n  'xsi': 'http://www.w3.org/2001/XMLSchema-instance',\n  'xml': 'http://www.w3.org/XML/1998/namespace'\n};\nvar SERIALIZE_PROPERTY = 'property';\nfunction getSerialization(element) {\n  return element.xml && element.xml.serialize;\n}\nfunction getSerializationType(element) {\n  const type = getSerialization(element);\n  return type !== SERIALIZE_PROPERTY && (type || null);\n}\nfunction capitalize(str) {\n  return str.charAt(0).toUpperCase() + str.slice(1);\n}\nfunction aliasToName(aliasNs, pkg) {\n  if (!hasLowerCaseAlias(pkg)) {\n    return aliasNs.name;\n  }\n  return aliasNs.prefix + ':' + capitalize(aliasNs.localName);\n}\n\n/**\n * Un-prefix a potentially prefixed type name.\n *\n * @param {NsName} nameNs\n * @param {Object} [pkg]\n *\n * @return {string}\n */\nfunction prefixedToName(nameNs, pkg) {\n  var name = nameNs.name,\n    localName = nameNs.localName;\n  var typePrefix = pkg && pkg.xml && pkg.xml.typePrefix;\n  if (typePrefix && localName.indexOf(typePrefix) === 0) {\n    return nameNs.prefix + ':' + localName.slice(typePrefix.length);\n  } else {\n    return name;\n  }\n}\nfunction normalizeTypeName(name, nsMap, model) {\n  // normalize against actual NS\n  const nameNs = parseNameNS(name, nsMap.xmlns);\n  const normalizedName = `${nsMap[nameNs.prefix] || nameNs.prefix}:${nameNs.localName}`;\n  const normalizedNameNs = parseNameNS(normalizedName);\n\n  // determine actual type name, based on package-defined prefix\n  var pkg = model.getPackage(normalizedNameNs.prefix);\n  return prefixedToName(normalizedNameNs, pkg);\n}\nfunction error(message) {\n  return new Error(message);\n}\n\n/**\n * Get the moddle descriptor for a given instance or type.\n *\n * @param  {ModdleElement|Function} element\n *\n * @return {Object} the moddle descriptor\n */\nfunction getModdleDescriptor(element) {\n  return element.$descriptor;\n}\n\n/**\n * A parse context.\n *\n * @class\n *\n * @param {Object} options\n * @param {ElementHandler} options.rootHandler the root handler for parsing a document\n * @param {boolean} [options.lax=false] whether or not to ignore invalid elements\n */\nfunction Context(options) {\n  /**\n   * @property {ElementHandler} rootHandler\n   */\n\n  /**\n   * @property {Boolean} lax\n   */\n\n  assign(this, options);\n  this.elementsById = {};\n  this.references = [];\n  this.warnings = [];\n\n  /**\n   * Add an unresolved reference.\n   *\n   * @param {Object} reference\n   */\n  this.addReference = function (reference) {\n    this.references.push(reference);\n  };\n\n  /**\n   * Add a processed element.\n   *\n   * @param {ModdleElement} element\n   */\n  this.addElement = function (element) {\n    if (!element) {\n      throw error('expected element');\n    }\n    var elementsById = this.elementsById;\n    var descriptor = getModdleDescriptor(element);\n    var idProperty = descriptor.idProperty,\n      id;\n    if (idProperty) {\n      id = element.get(idProperty.name);\n      if (id) {\n        // for QName validation as per http://www.w3.org/TR/REC-xml/#NT-NameChar\n        if (!/^([a-z][\\w-.]*:)?[a-z_][\\w-.]*$/i.test(id)) {\n          throw new Error('illegal ID <' + id + '>');\n        }\n        if (elementsById[id]) {\n          throw error('duplicate ID <' + id + '>');\n        }\n        elementsById[id] = element;\n      }\n    }\n  };\n\n  /**\n   * Add an import warning.\n   *\n   * @param {Object} warning\n   * @param {String} warning.message\n   * @param {Error} [warning.error]\n   */\n  this.addWarning = function (warning) {\n    this.warnings.push(warning);\n  };\n}\nfunction BaseHandler() {}\nBaseHandler.prototype.handleEnd = function () {};\nBaseHandler.prototype.handleText = function () {};\nBaseHandler.prototype.handleNode = function () {};\n\n/**\n * A simple pass through handler that does nothing except for\n * ignoring all input it receives.\n *\n * This is used to ignore unknown elements and\n * attributes.\n */\nfunction NoopHandler() {}\nNoopHandler.prototype = Object.create(BaseHandler.prototype);\nNoopHandler.prototype.handleNode = function () {\n  return this;\n};\nfunction BodyHandler() {}\nBodyHandler.prototype = Object.create(BaseHandler.prototype);\nBodyHandler.prototype.handleText = function (text) {\n  this.body = (this.body || '') + text;\n};\nfunction ReferenceHandler(property, context) {\n  this.property = property;\n  this.context = context;\n}\nReferenceHandler.prototype = Object.create(BodyHandler.prototype);\nReferenceHandler.prototype.handleNode = function (node) {\n  if (this.element) {\n    throw error('expected no sub nodes');\n  } else {\n    this.element = this.createReference(node);\n  }\n  return this;\n};\nReferenceHandler.prototype.handleEnd = function () {\n  this.element.id = this.body;\n};\nReferenceHandler.prototype.createReference = function (node) {\n  return {\n    property: this.property.ns.name,\n    id: ''\n  };\n};\nfunction ValueHandler(propertyDesc, element) {\n  this.element = element;\n  this.propertyDesc = propertyDesc;\n}\nValueHandler.prototype = Object.create(BodyHandler.prototype);\nValueHandler.prototype.handleEnd = function () {\n  var value = this.body || '',\n    element = this.element,\n    propertyDesc = this.propertyDesc;\n  value = coerceType(propertyDesc.type, value);\n  if (propertyDesc.isMany) {\n    element.get(propertyDesc.name).push(value);\n  } else {\n    element.set(propertyDesc.name, value);\n  }\n};\nfunction BaseElementHandler() {}\nBaseElementHandler.prototype = Object.create(BodyHandler.prototype);\nBaseElementHandler.prototype.handleNode = function (node) {\n  var parser = this,\n    element = this.element;\n  if (!element) {\n    element = this.element = this.createElement(node);\n    this.context.addElement(element);\n  } else {\n    parser = this.handleChild(node);\n  }\n  return parser;\n};\n\n/**\n * @class Reader.ElementHandler\n *\n */\nfunction ElementHandler(model, typeName, context) {\n  this.model = model;\n  this.type = model.getType(typeName);\n  this.context = context;\n}\nElementHandler.prototype = Object.create(BaseElementHandler.prototype);\nElementHandler.prototype.addReference = function (reference) {\n  this.context.addReference(reference);\n};\nElementHandler.prototype.handleText = function (text) {\n  var element = this.element,\n    descriptor = getModdleDescriptor(element),\n    bodyProperty = descriptor.bodyProperty;\n  if (!bodyProperty) {\n    throw error('unexpected body text <' + text + '>');\n  }\n  BodyHandler.prototype.handleText.call(this, text);\n};\nElementHandler.prototype.handleEnd = function () {\n  var value = this.body,\n    element = this.element,\n    descriptor = getModdleDescriptor(element),\n    bodyProperty = descriptor.bodyProperty;\n  if (bodyProperty && value !== undefined) {\n    value = coerceType(bodyProperty.type, value);\n    element.set(bodyProperty.name, value);\n  }\n};\n\n/**\n * Create an instance of the model from the given node.\n *\n * @param  {Element} node the xml node\n */\nElementHandler.prototype.createElement = function (node) {\n  var attributes = node.attributes,\n    Type = this.type,\n    descriptor = getModdleDescriptor(Type),\n    context = this.context,\n    instance = new Type({}),\n    model = this.model,\n    propNameNs;\n  forEach(attributes, function (value, name) {\n    var prop = descriptor.propertiesByName[name],\n      values;\n    if (prop && prop.isReference) {\n      if (!prop.isMany) {\n        context.addReference({\n          element: instance,\n          property: prop.ns.name,\n          id: value\n        });\n      } else {\n        // IDREFS: parse references as whitespace-separated list\n        values = value.split(' ');\n        forEach(values, function (v) {\n          context.addReference({\n            element: instance,\n            property: prop.ns.name,\n            id: v\n          });\n        });\n      }\n    } else {\n      if (prop) {\n        value = coerceType(prop.type, value);\n      } else if (name === 'xmlns') {\n        name = ':' + name;\n      } else {\n        propNameNs = parseNameNS(name, descriptor.ns.prefix);\n\n        // check whether attribute is defined in a well-known namespace\n        // if that is the case we emit a warning to indicate potential misuse\n        if (model.getPackage(propNameNs.prefix)) {\n          context.addWarning({\n            message: 'unknown attribute <' + name + '>',\n            element: instance,\n            property: name,\n            value: value\n          });\n        }\n      }\n      instance.set(name, value);\n    }\n  });\n  return instance;\n};\nElementHandler.prototype.getPropertyForNode = function (node) {\n  var name = node.name;\n  var nameNs = parseNameNS(name);\n  var type = this.type,\n    model = this.model,\n    descriptor = getModdleDescriptor(type);\n  var propertyName = nameNs.name,\n    property = descriptor.propertiesByName[propertyName];\n\n  // search for properties by name first\n\n  if (property && !property.isAttr) {\n    const serializationType = getSerializationType(property);\n    if (serializationType) {\n      const elementTypeName = node.attributes[serializationType];\n\n      // type is optional, if it does not exists the\n      // default type is assumed\n      if (elementTypeName) {\n        // convert the prefix used to the mapped form, but also\n        // take possible type prefixes from XML\n        // into account, i.e.: xsi:type=\"t{ActualType}\",\n        const normalizedTypeName = normalizeTypeName(elementTypeName, node.ns, model);\n        const elementType = model.getType(normalizedTypeName);\n        return assign({}, property, {\n          effectiveType: getModdleDescriptor(elementType).name\n        });\n      }\n    }\n\n    // search for properties by name first\n    return property;\n  }\n  var pkg = model.getPackage(nameNs.prefix);\n  if (pkg) {\n    const elementTypeName = aliasToName(nameNs, pkg);\n    const elementType = model.getType(elementTypeName);\n\n    // search for collection members later\n    property = find(descriptor.properties, function (p) {\n      return !p.isVirtual && !p.isReference && !p.isAttribute && elementType.hasType(p.type);\n    });\n    if (property) {\n      return assign({}, property, {\n        effectiveType: getModdleDescriptor(elementType).name\n      });\n    }\n  } else {\n    // parse unknown element (maybe extension)\n    property = find(descriptor.properties, function (p) {\n      return !p.isReference && !p.isAttribute && p.type === 'Element';\n    });\n    if (property) {\n      return property;\n    }\n  }\n  throw error('unrecognized element <' + nameNs.name + '>');\n};\nElementHandler.prototype.toString = function () {\n  return 'ElementDescriptor[' + getModdleDescriptor(this.type).name + ']';\n};\nElementHandler.prototype.valueHandler = function (propertyDesc, element) {\n  return new ValueHandler(propertyDesc, element);\n};\nElementHandler.prototype.referenceHandler = function (propertyDesc) {\n  return new ReferenceHandler(propertyDesc, this.context);\n};\nElementHandler.prototype.handler = function (type) {\n  if (type === 'Element') {\n    return new GenericElementHandler(this.model, type, this.context);\n  } else {\n    return new ElementHandler(this.model, type, this.context);\n  }\n};\n\n/**\n * Handle the child element parsing\n *\n * @param  {Element} node the xml node\n */\nElementHandler.prototype.handleChild = function (node) {\n  var propertyDesc, type, element, childHandler;\n  propertyDesc = this.getPropertyForNode(node);\n  element = this.element;\n  type = propertyDesc.effectiveType || propertyDesc.type;\n  if (isSimpleType(type)) {\n    return this.valueHandler(propertyDesc, element);\n  }\n  if (propertyDesc.isReference) {\n    childHandler = this.referenceHandler(propertyDesc).handleNode(node);\n  } else {\n    childHandler = this.handler(type).handleNode(node);\n  }\n  var newElement = childHandler.element;\n\n  // child handles may decide to skip elements\n  // by not returning anything\n  if (newElement !== undefined) {\n    if (propertyDesc.isMany) {\n      element.get(propertyDesc.name).push(newElement);\n    } else {\n      element.set(propertyDesc.name, newElement);\n    }\n    if (propertyDesc.isReference) {\n      assign(newElement, {\n        element: element\n      });\n      this.context.addReference(newElement);\n    } else {\n      // establish child -> parent relationship\n      newElement.$parent = element;\n    }\n  }\n  return childHandler;\n};\n\n/**\n * An element handler that performs special validation\n * to ensure the node it gets initialized with matches\n * the handlers type (namespace wise).\n *\n * @param {Moddle} model\n * @param {String} typeName\n * @param {Context} context\n */\nfunction RootElementHandler(model, typeName, context) {\n  ElementHandler.call(this, model, typeName, context);\n}\nRootElementHandler.prototype = Object.create(ElementHandler.prototype);\nRootElementHandler.prototype.createElement = function (node) {\n  var name = node.name,\n    nameNs = parseNameNS(name),\n    model = this.model,\n    type = this.type,\n    pkg = model.getPackage(nameNs.prefix),\n    typeName = pkg && aliasToName(nameNs, pkg) || name;\n\n  // verify the correct namespace if we parse\n  // the first element in the handler tree\n  //\n  // this ensures we don't mistakenly import wrong namespace elements\n  if (!type.hasType(typeName)) {\n    throw error('unexpected element <' + node.originalName + '>');\n  }\n  return ElementHandler.prototype.createElement.call(this, node);\n};\nfunction GenericElementHandler(model, typeName, context) {\n  this.model = model;\n  this.context = context;\n}\nGenericElementHandler.prototype = Object.create(BaseElementHandler.prototype);\nGenericElementHandler.prototype.createElement = function (node) {\n  var name = node.name,\n    ns = parseNameNS(name),\n    prefix = ns.prefix,\n    uri = node.ns[prefix + '$uri'],\n    attributes = node.attributes;\n  return this.model.createAny(name, uri, attributes);\n};\nGenericElementHandler.prototype.handleChild = function (node) {\n  var handler = new GenericElementHandler(this.model, 'Element', this.context).handleNode(node),\n    element = this.element;\n  var newElement = handler.element,\n    children;\n  if (newElement !== undefined) {\n    children = element.$children = element.$children || [];\n    children.push(newElement);\n\n    // establish child -> parent relationship\n    newElement.$parent = element;\n  }\n  return handler;\n};\nGenericElementHandler.prototype.handleEnd = function () {\n  if (this.body) {\n    this.element.$body = this.body;\n  }\n};\n\n/**\n * A reader for a meta-model\n *\n * @param {Object} options\n * @param {Model} options.model used to read xml files\n * @param {Boolean} options.lax whether to make parse errors warnings\n */\nfunction Reader(options) {\n  if (options instanceof Moddle) {\n    options = {\n      model: options\n    };\n  }\n  assign(this, {\n    lax: false\n  }, options);\n}\n\n/**\n * The fromXML result.\n *\n * @typedef {Object} ParseResult\n *\n * @property {ModdleElement} rootElement\n * @property {Array<Object>} references\n * @property {Array<Error>} warnings\n * @property {Object} elementsById - a mapping containing each ID -> ModdleElement\n */\n\n/**\n * The fromXML result.\n *\n * @typedef {Error} ParseError\n *\n * @property {Array<Error>} warnings\n */\n\n/**\n * Parse the given XML into a moddle document tree.\n *\n * @param {String} xml\n * @param {ElementHandler|Object} options or rootHandler\n *\n * @returns {Promise<ParseResult, ParseError>}\n */\nReader.prototype.fromXML = function (xml, options, done) {\n  var rootHandler = options.rootHandler;\n  if (options instanceof ElementHandler) {\n    // root handler passed via (xml, { rootHandler: ElementHandler }, ...)\n    rootHandler = options;\n    options = {};\n  } else {\n    if (typeof options === 'string') {\n      // rootHandler passed via (xml, 'someString', ...)\n      rootHandler = this.handler(options);\n      options = {};\n    } else if (typeof rootHandler === 'string') {\n      // rootHandler passed via (xml, { rootHandler: 'someString' }, ...)\n      rootHandler = this.handler(rootHandler);\n    }\n  }\n  var model = this.model,\n    lax = this.lax;\n  var context = new Context(assign({}, options, {\n      rootHandler: rootHandler\n    })),\n    parser = new Parser({\n      proxy: true\n    }),\n    stack = createStack();\n  rootHandler.context = context;\n\n  // push root handler\n  stack.push(rootHandler);\n\n  /**\n   * Handle error.\n   *\n   * @param  {Error} err\n   * @param  {Function} getContext\n   * @param  {boolean} lax\n   *\n   * @return {boolean} true if handled\n   */\n  function handleError(err, getContext, lax) {\n    var ctx = getContext();\n    var line = ctx.line,\n      column = ctx.column,\n      data = ctx.data;\n\n    // we receive the full context data here,\n    // for elements trim down the information\n    // to the tag name, only\n    if (data.charAt(0) === '<' && data.indexOf(' ') !== -1) {\n      data = data.slice(0, data.indexOf(' ')) + '>';\n    }\n    var message = 'unparsable content ' + (data ? data + ' ' : '') + 'detected\\n\\t' + 'line: ' + line + '\\n\\t' + 'column: ' + column + '\\n\\t' + 'nested error: ' + err.message;\n    if (lax) {\n      context.addWarning({\n        message: message,\n        error: err\n      });\n      return true;\n    } else {\n      throw error(message);\n    }\n  }\n  function handleWarning(err, getContext) {\n    // just like handling errors in <lax=true> mode\n    return handleError(err, getContext, true);\n  }\n\n  /**\n   * Resolve collected references on parse end.\n   */\n  function resolveReferences() {\n    var elementsById = context.elementsById;\n    var references = context.references;\n    var i, r;\n    for (i = 0; r = references[i]; i++) {\n      var element = r.element;\n      var reference = elementsById[r.id];\n      var property = getModdleDescriptor(element).propertiesByName[r.property];\n      if (!reference) {\n        context.addWarning({\n          message: 'unresolved reference <' + r.id + '>',\n          element: r.element,\n          property: r.property,\n          value: r.id\n        });\n      }\n      if (property.isMany) {\n        var collection = element.get(property.name),\n          idx = collection.indexOf(r);\n\n        // we replace an existing place holder (idx != -1) or\n        // append to the collection instead\n        if (idx === -1) {\n          idx = collection.length;\n        }\n        if (!reference) {\n          // remove unresolvable reference\n          collection.splice(idx, 1);\n        } else {\n          // add or update reference in collection\n          collection[idx] = reference;\n        }\n      } else {\n        element.set(property.name, reference);\n      }\n    }\n  }\n  function handleClose() {\n    stack.pop().handleEnd();\n  }\n  var PREAMBLE_START_PATTERN = /^<\\?xml /i;\n  var ENCODING_PATTERN = / encoding=\"([^\"]+)\"/i;\n  var UTF_8_PATTERN = /^utf-8$/i;\n  function handleQuestion(question) {\n    if (!PREAMBLE_START_PATTERN.test(question)) {\n      return;\n    }\n    var match = ENCODING_PATTERN.exec(question);\n    var encoding = match && match[1];\n    if (!encoding || UTF_8_PATTERN.test(encoding)) {\n      return;\n    }\n    context.addWarning({\n      message: 'unsupported document encoding <' + encoding + '>, ' + 'falling back to UTF-8'\n    });\n  }\n  function handleOpen(node, getContext) {\n    var handler = stack.peek();\n    try {\n      stack.push(handler.handleNode(node));\n    } catch (err) {\n      if (handleError(err, getContext, lax)) {\n        stack.push(new NoopHandler());\n      }\n    }\n  }\n  function handleCData(text, getContext) {\n    try {\n      stack.peek().handleText(text);\n    } catch (err) {\n      handleWarning(err, getContext);\n    }\n  }\n  function handleText(text, getContext) {\n    // strip whitespace only nodes, i.e. before\n    // <!CDATA[ ... ]> sections and in between tags\n\n    if (!text.trim()) {\n      return;\n    }\n    handleCData(text, getContext);\n  }\n  var uriMap = model.getPackages().reduce(function (uriMap, p) {\n    uriMap[p.uri] = p.prefix;\n    return uriMap;\n  }, Object.entries(DEFAULT_NS_MAP).reduce(function (map, _ref) {\n    let [prefix, url] = _ref;\n    map[url] = prefix;\n    return map;\n  }, model.config && model.config.nsMap || {}));\n  parser.ns(uriMap).on('openTag', function (obj, decodeStr, selfClosing, getContext) {\n    // gracefully handle unparsable attributes (attrs=false)\n    var attrs = obj.attrs || {};\n    var decodedAttrs = Object.keys(attrs).reduce(function (d, key) {\n      var value = decodeStr(attrs[key]);\n      d[key] = value;\n      return d;\n    }, {});\n    var node = {\n      name: obj.name,\n      originalName: obj.originalName,\n      attributes: decodedAttrs,\n      ns: obj.ns\n    };\n    handleOpen(node, getContext);\n  }).on('question', handleQuestion).on('closeTag', handleClose).on('cdata', handleCData).on('text', function (text, decodeEntities, getContext) {\n    handleText(decodeEntities(text), getContext);\n  }).on('error', handleError).on('warn', handleWarning);\n\n  // async XML parsing to make sure the execution environment\n  // (node or brower) is kept responsive and that certain optimization\n  // strategies can kick in.\n  return new Promise(function (resolve, reject) {\n    var err;\n    try {\n      parser.parse(xml);\n      resolveReferences();\n    } catch (e) {\n      err = e;\n    }\n    var rootElement = rootHandler.element;\n    if (!err && !rootElement) {\n      err = error('failed to parse document as <' + rootHandler.type.$descriptor.name + '>');\n    }\n    var warnings = context.warnings;\n    var references = context.references;\n    var elementsById = context.elementsById;\n    if (err) {\n      err.warnings = warnings;\n      return reject(err);\n    } else {\n      return resolve({\n        rootElement: rootElement,\n        elementsById: elementsById,\n        references: references,\n        warnings: warnings\n      });\n    }\n  });\n};\nReader.prototype.handler = function (name) {\n  return new RootElementHandler(this.model, name);\n};\n\n// helpers //////////////////////////\n\nfunction createStack() {\n  var stack = [];\n  Object.defineProperty(stack, 'peek', {\n    value: function () {\n      return this[this.length - 1];\n    }\n  });\n  return stack;\n}\nvar XML_PREAMBLE = '<?xml version=\"1.0\" encoding=\"UTF-8\"?>\\n';\nvar ESCAPE_ATTR_CHARS = /<|>|'|\"|&|\\n\\r|\\n/g;\nvar ESCAPE_CHARS = /<|>|&/g;\nfunction Namespaces(parent) {\n  this.prefixMap = {};\n  this.uriMap = {};\n  this.used = {};\n  this.wellknown = [];\n  this.custom = [];\n  this.parent = parent;\n  this.defaultPrefixMap = parent && parent.defaultPrefixMap || {};\n}\nNamespaces.prototype.mapDefaultPrefixes = function (defaultPrefixMap) {\n  this.defaultPrefixMap = defaultPrefixMap;\n};\nNamespaces.prototype.defaultUriByPrefix = function (prefix) {\n  return this.defaultPrefixMap[prefix];\n};\nNamespaces.prototype.byUri = function (uri) {\n  return this.uriMap[uri] || this.parent && this.parent.byUri(uri);\n};\nNamespaces.prototype.add = function (ns, isWellknown) {\n  this.uriMap[ns.uri] = ns;\n  if (isWellknown) {\n    this.wellknown.push(ns);\n  } else {\n    this.custom.push(ns);\n  }\n  this.mapPrefix(ns.prefix, ns.uri);\n};\nNamespaces.prototype.uriByPrefix = function (prefix) {\n  return this.prefixMap[prefix || 'xmlns'] || this.parent && this.parent.uriByPrefix(prefix);\n};\nNamespaces.prototype.mapPrefix = function (prefix, uri) {\n  this.prefixMap[prefix || 'xmlns'] = uri;\n};\nNamespaces.prototype.getNSKey = function (ns) {\n  return ns.prefix !== undefined ? ns.uri + '|' + ns.prefix : ns.uri;\n};\nNamespaces.prototype.logUsed = function (ns) {\n  var uri = ns.uri;\n  var nsKey = this.getNSKey(ns);\n  this.used[nsKey] = this.byUri(uri);\n\n  // Inform parent recursively about the usage of this NS\n  if (this.parent) {\n    this.parent.logUsed(ns);\n  }\n};\nNamespaces.prototype.getUsed = function (ns) {\n  var allNs = [].concat(this.wellknown, this.custom);\n  return allNs.filter(ns => {\n    var nsKey = this.getNSKey(ns);\n    return this.used[nsKey];\n  });\n};\nfunction lower(string) {\n  return string.charAt(0).toLowerCase() + string.slice(1);\n}\nfunction nameToAlias(name, pkg) {\n  if (hasLowerCaseAlias(pkg)) {\n    return lower(name);\n  } else {\n    return name;\n  }\n}\nfunction inherits(ctor, superCtor) {\n  ctor.super_ = superCtor;\n  ctor.prototype = Object.create(superCtor.prototype, {\n    constructor: {\n      value: ctor,\n      enumerable: false,\n      writable: true,\n      configurable: true\n    }\n  });\n}\nfunction nsName(ns) {\n  if (isString(ns)) {\n    return ns;\n  } else {\n    return (ns.prefix ? ns.prefix + ':' : '') + ns.localName;\n  }\n}\nfunction getNsAttrs(namespaces) {\n  return namespaces.getUsed().filter(function (ns) {\n    // do not serialize built in <xml> namespace\n    return ns.prefix !== 'xml';\n  }).map(function (ns) {\n    var name = 'xmlns' + (ns.prefix ? ':' + ns.prefix : '');\n    return {\n      name: name,\n      value: ns.uri\n    };\n  });\n}\nfunction getElementNs(ns, descriptor) {\n  if (descriptor.isGeneric) {\n    return assign({\n      localName: descriptor.ns.localName\n    }, ns);\n  } else {\n    return assign({\n      localName: nameToAlias(descriptor.ns.localName, descriptor.$pkg)\n    }, ns);\n  }\n}\nfunction getPropertyNs(ns, descriptor) {\n  return assign({\n    localName: descriptor.ns.localName\n  }, ns);\n}\nfunction getSerializableProperties(element) {\n  var descriptor = element.$descriptor;\n  return filter(descriptor.properties, function (p) {\n    var name = p.name;\n    if (p.isVirtual) {\n      return false;\n    }\n\n    // do not serialize defaults\n    if (!has(element, name)) {\n      return false;\n    }\n    var value = element[name];\n\n    // do not serialize default equals\n    if (value === p.default) {\n      return false;\n    }\n\n    // do not serialize null properties\n    if (value === null) {\n      return false;\n    }\n    return p.isMany ? value.length : true;\n  });\n}\nvar ESCAPE_ATTR_MAP = {\n  '\\n': '#10',\n  '\\n\\r': '#10',\n  '\"': '#34',\n  '\\'': '#39',\n  '<': '#60',\n  '>': '#62',\n  '&': '#38'\n};\nvar ESCAPE_MAP = {\n  '<': 'lt',\n  '>': 'gt',\n  '&': 'amp'\n};\nfunction escape(str, charPattern, replaceMap) {\n  // ensure we are handling strings here\n  str = isString(str) ? str : '' + str;\n  return str.replace(charPattern, function (s) {\n    return '&' + replaceMap[s] + ';';\n  });\n}\n\n/**\n * Escape a string attribute to not contain any bad values (line breaks, '\"', ...)\n *\n * @param {String} str the string to escape\n * @return {String} the escaped string\n */\nfunction escapeAttr(str) {\n  return escape(str, ESCAPE_ATTR_CHARS, ESCAPE_ATTR_MAP);\n}\nfunction escapeBody(str) {\n  return escape(str, ESCAPE_CHARS, ESCAPE_MAP);\n}\nfunction filterAttributes(props) {\n  return filter(props, function (p) {\n    return p.isAttr;\n  });\n}\nfunction filterContained(props) {\n  return filter(props, function (p) {\n    return !p.isAttr;\n  });\n}\nfunction ReferenceSerializer(tagName) {\n  this.tagName = tagName;\n}\nReferenceSerializer.prototype.build = function (element) {\n  this.element = element;\n  return this;\n};\nReferenceSerializer.prototype.serializeTo = function (writer) {\n  writer.appendIndent().append('<' + this.tagName + '>' + this.element.id + '</' + this.tagName + '>').appendNewLine();\n};\nfunction BodySerializer() {}\nBodySerializer.prototype.serializeValue = BodySerializer.prototype.serializeTo = function (writer) {\n  writer.append(this.escape ? escapeBody(this.value) : this.value);\n};\nBodySerializer.prototype.build = function (prop, value) {\n  this.value = value;\n  if (prop.type === 'String' && value.search(ESCAPE_CHARS) !== -1) {\n    this.escape = true;\n  }\n  return this;\n};\nfunction ValueSerializer(tagName) {\n  this.tagName = tagName;\n}\ninherits(ValueSerializer, BodySerializer);\nValueSerializer.prototype.serializeTo = function (writer) {\n  writer.appendIndent().append('<' + this.tagName + '>');\n  this.serializeValue(writer);\n  writer.append('</' + this.tagName + '>').appendNewLine();\n};\nfunction ElementSerializer(parent, propertyDescriptor) {\n  this.body = [];\n  this.attrs = [];\n  this.parent = parent;\n  this.propertyDescriptor = propertyDescriptor;\n}\nElementSerializer.prototype.build = function (element) {\n  this.element = element;\n  var elementDescriptor = element.$descriptor,\n    propertyDescriptor = this.propertyDescriptor;\n  var otherAttrs, properties;\n  var isGeneric = elementDescriptor.isGeneric;\n  if (isGeneric) {\n    otherAttrs = this.parseGenericNsAttributes(element);\n  } else {\n    otherAttrs = this.parseNsAttributes(element);\n  }\n  if (propertyDescriptor) {\n    this.ns = this.nsPropertyTagName(propertyDescriptor);\n  } else {\n    this.ns = this.nsTagName(elementDescriptor);\n  }\n\n  // compute tag name\n  this.tagName = this.addTagName(this.ns);\n  if (isGeneric) {\n    this.parseGenericContainments(element);\n  } else {\n    properties = getSerializableProperties(element);\n    this.parseAttributes(filterAttributes(properties));\n    this.parseContainments(filterContained(properties));\n  }\n  this.parseGenericAttributes(element, otherAttrs);\n  return this;\n};\nElementSerializer.prototype.nsTagName = function (descriptor) {\n  var effectiveNs = this.logNamespaceUsed(descriptor.ns);\n  return getElementNs(effectiveNs, descriptor);\n};\nElementSerializer.prototype.nsPropertyTagName = function (descriptor) {\n  var effectiveNs = this.logNamespaceUsed(descriptor.ns);\n  return getPropertyNs(effectiveNs, descriptor);\n};\nElementSerializer.prototype.isLocalNs = function (ns) {\n  return ns.uri === this.ns.uri;\n};\n\n/**\n * Get the actual ns attribute name for the given element.\n *\n * @param {Object} element\n * @param {Boolean} [element.inherited=false]\n *\n * @return {Object} nsName\n */\nElementSerializer.prototype.nsAttributeName = function (element) {\n  var ns;\n  if (isString(element)) {\n    ns = parseNameNS(element);\n  } else {\n    ns = element.ns;\n  }\n\n  // return just local name for inherited attributes\n  if (element.inherited) {\n    return {\n      localName: ns.localName\n    };\n  }\n\n  // parse + log effective ns\n  var effectiveNs = this.logNamespaceUsed(ns);\n\n  // LOG ACTUAL namespace use\n  this.getNamespaces().logUsed(effectiveNs);\n\n  // strip prefix if same namespace like parent\n  if (this.isLocalNs(effectiveNs)) {\n    return {\n      localName: ns.localName\n    };\n  } else {\n    return assign({\n      localName: ns.localName\n    }, effectiveNs);\n  }\n};\nElementSerializer.prototype.parseGenericNsAttributes = function (element) {\n  return Object.entries(element).filter(_ref2 => {\n    let [key, value] = _ref2;\n    return !key.startsWith('$') && this.parseNsAttribute(element, key, value);\n  }).map(_ref3 => {\n    let [key, value] = _ref3;\n    return {\n      name: key,\n      value: value\n    };\n  });\n};\nElementSerializer.prototype.parseGenericContainments = function (element) {\n  var body = element.$body;\n  if (body) {\n    this.body.push(new BodySerializer().build({\n      type: 'String'\n    }, body));\n  }\n  var children = element.$children;\n  if (children) {\n    forEach(children, child => {\n      this.body.push(new ElementSerializer(this).build(child));\n    });\n  }\n};\nElementSerializer.prototype.parseNsAttribute = function (element, name, value) {\n  var model = element.$model;\n  var nameNs = parseNameNS(name);\n  var ns;\n\n  // parse xmlns:foo=\"http://foo.bar\"\n  if (nameNs.prefix === 'xmlns') {\n    ns = {\n      prefix: nameNs.localName,\n      uri: value\n    };\n  }\n\n  // parse xmlns=\"http://foo.bar\"\n  if (!nameNs.prefix && nameNs.localName === 'xmlns') {\n    ns = {\n      uri: value\n    };\n  }\n  if (!ns) {\n    return {\n      name: name,\n      value: value\n    };\n  }\n  if (model && model.getPackage(value)) {\n    // register well known namespace\n    this.logNamespace(ns, true, true);\n  } else {\n    // log custom namespace directly as used\n    var actualNs = this.logNamespaceUsed(ns, true);\n    this.getNamespaces().logUsed(actualNs);\n  }\n};\n\n/**\n * Parse namespaces and return a list of left over generic attributes\n *\n * @param  {Object} element\n * @return {Array<Object>}\n */\nElementSerializer.prototype.parseNsAttributes = function (element) {\n  var self = this;\n  var genericAttrs = element.$attrs;\n  var attributes = [];\n\n  // parse namespace attributes first\n  // and log them. push non namespace attributes to a list\n  // and process them later\n  forEach(genericAttrs, function (value, name) {\n    var nonNsAttr = self.parseNsAttribute(element, name, value);\n    if (nonNsAttr) {\n      attributes.push(nonNsAttr);\n    }\n  });\n  return attributes;\n};\nElementSerializer.prototype.parseGenericAttributes = function (element, attributes) {\n  var self = this;\n  forEach(attributes, function (attr) {\n    try {\n      self.addAttribute(self.nsAttributeName(attr.name), attr.value);\n    } catch (e) {\n      // eslint-disable-next-line no-undef\n      typeof console !== 'undefined' && console.warn(`missing namespace information for <${attr.name}=${attr.value}> on`, element, e);\n    }\n  });\n};\nElementSerializer.prototype.parseContainments = function (properties) {\n  var self = this,\n    body = this.body,\n    element = this.element;\n  forEach(properties, function (p) {\n    var value = element.get(p.name),\n      isReference = p.isReference,\n      isMany = p.isMany;\n    if (!isMany) {\n      value = [value];\n    }\n    if (p.isBody) {\n      body.push(new BodySerializer().build(p, value[0]));\n    } else if (isSimpleType(p.type)) {\n      forEach(value, function (v) {\n        body.push(new ValueSerializer(self.addTagName(self.nsPropertyTagName(p))).build(p, v));\n      });\n    } else if (isReference) {\n      forEach(value, function (v) {\n        body.push(new ReferenceSerializer(self.addTagName(self.nsPropertyTagName(p))).build(v));\n      });\n    } else {\n      // allow serialization via type\n      // rather than element name\n      var serialization = getSerialization(p);\n      forEach(value, function (v) {\n        var serializer;\n        if (serialization) {\n          if (serialization === SERIALIZE_PROPERTY) {\n            serializer = new ElementSerializer(self, p);\n          } else {\n            serializer = new TypeSerializer(self, p, serialization);\n          }\n        } else {\n          serializer = new ElementSerializer(self);\n        }\n        body.push(serializer.build(v));\n      });\n    }\n  });\n};\nElementSerializer.prototype.getNamespaces = function (local) {\n  var namespaces = this.namespaces,\n    parent = this.parent,\n    parentNamespaces;\n  if (!namespaces) {\n    parentNamespaces = parent && parent.getNamespaces();\n    if (local || !parentNamespaces) {\n      this.namespaces = namespaces = new Namespaces(parentNamespaces);\n    } else {\n      namespaces = parentNamespaces;\n    }\n  }\n  return namespaces;\n};\nElementSerializer.prototype.logNamespace = function (ns, wellknown, local) {\n  var namespaces = this.getNamespaces(local);\n  var nsUri = ns.uri,\n    nsPrefix = ns.prefix;\n  var existing = namespaces.byUri(nsUri);\n  if (!existing || local) {\n    namespaces.add(ns, wellknown);\n  }\n  namespaces.mapPrefix(nsPrefix, nsUri);\n  return ns;\n};\nElementSerializer.prototype.logNamespaceUsed = function (ns, local) {\n  var namespaces = this.getNamespaces(local);\n\n  // ns may be\n  //\n  //   * prefix only\n  //   * prefix:uri\n  //   * localName only\n\n  var prefix = ns.prefix,\n    uri = ns.uri,\n    newPrefix,\n    idx,\n    wellknownUri;\n\n  // handle anonymous namespaces (elementForm=unqualified), cf. #23\n  if (!prefix && !uri) {\n    return {\n      localName: ns.localName\n    };\n  }\n  wellknownUri = namespaces.defaultUriByPrefix(prefix);\n  uri = uri || wellknownUri || namespaces.uriByPrefix(prefix);\n  if (!uri) {\n    throw new Error('no namespace uri given for prefix <' + prefix + '>');\n  }\n  ns = namespaces.byUri(uri);\n\n  // register new default prefix <xmlns> in local scope\n  if (!ns && !prefix) {\n    ns = this.logNamespace({\n      uri\n    }, wellknownUri === uri, true);\n  }\n  if (!ns) {\n    newPrefix = prefix;\n    idx = 1;\n\n    // find a prefix that is not mapped yet\n    while (namespaces.uriByPrefix(newPrefix)) {\n      newPrefix = prefix + '_' + idx++;\n    }\n    ns = this.logNamespace({\n      prefix: newPrefix,\n      uri: uri\n    }, wellknownUri === uri);\n  }\n  if (prefix) {\n    namespaces.mapPrefix(prefix, uri);\n  }\n  return ns;\n};\nElementSerializer.prototype.parseAttributes = function (properties) {\n  var self = this,\n    element = this.element;\n  forEach(properties, function (p) {\n    var value = element.get(p.name);\n    if (p.isReference) {\n      if (!p.isMany) {\n        value = value.id;\n      } else {\n        var values = [];\n        forEach(value, function (v) {\n          values.push(v.id);\n        });\n\n        // IDREFS is a whitespace-separated list of references.\n        value = values.join(' ');\n      }\n    }\n    self.addAttribute(self.nsAttributeName(p), value);\n  });\n};\nElementSerializer.prototype.addTagName = function (nsTagName) {\n  var actualNs = this.logNamespaceUsed(nsTagName);\n  this.getNamespaces().logUsed(actualNs);\n  return nsName(nsTagName);\n};\nElementSerializer.prototype.addAttribute = function (name, value) {\n  var attrs = this.attrs;\n  if (isString(value)) {\n    value = escapeAttr(value);\n  }\n\n  // de-duplicate attributes\n  // https://github.com/bpmn-io/moddle-xml/issues/66\n  var idx = findIndex(attrs, function (element) {\n    return element.name.localName === name.localName && element.name.uri === name.uri && element.name.prefix === name.prefix;\n  });\n  var attr = {\n    name: name,\n    value: value\n  };\n  if (idx !== -1) {\n    attrs.splice(idx, 1, attr);\n  } else {\n    attrs.push(attr);\n  }\n};\nElementSerializer.prototype.serializeAttributes = function (writer) {\n  var attrs = this.attrs,\n    namespaces = this.namespaces;\n  if (namespaces) {\n    attrs = getNsAttrs(namespaces).concat(attrs);\n  }\n  forEach(attrs, function (a) {\n    writer.append(' ').append(nsName(a.name)).append('=\"').append(a.value).append('\"');\n  });\n};\nElementSerializer.prototype.serializeTo = function (writer) {\n  var firstBody = this.body[0],\n    indent = firstBody && firstBody.constructor !== BodySerializer;\n  writer.appendIndent().append('<' + this.tagName);\n  this.serializeAttributes(writer);\n  writer.append(firstBody ? '>' : ' />');\n  if (firstBody) {\n    if (indent) {\n      writer.appendNewLine().indent();\n    }\n    forEach(this.body, function (b) {\n      b.serializeTo(writer);\n    });\n    if (indent) {\n      writer.unindent().appendIndent();\n    }\n    writer.append('</' + this.tagName + '>');\n  }\n  writer.appendNewLine();\n};\n\n/**\n * A serializer for types that handles serialization of data types\n */\nfunction TypeSerializer(parent, propertyDescriptor, serialization) {\n  ElementSerializer.call(this, parent, propertyDescriptor);\n  this.serialization = serialization;\n}\ninherits(TypeSerializer, ElementSerializer);\nTypeSerializer.prototype.parseNsAttributes = function (element) {\n  // extracted attributes with serialization attribute\n  // <type=typeName> stripped; it may be later\n  var attributes = ElementSerializer.prototype.parseNsAttributes.call(this, element).filter(attr => attr.name !== this.serialization);\n  var descriptor = element.$descriptor;\n\n  // only serialize <type=typeName> if necessary\n  if (descriptor.name === this.propertyDescriptor.type) {\n    return attributes;\n  }\n  var typeNs = this.typeNs = this.nsTagName(descriptor);\n  this.getNamespaces().logUsed(this.typeNs);\n\n  // add xsi:type attribute to represent the elements\n  // actual type\n\n  var pkg = element.$model.getPackage(typeNs.uri),\n    typePrefix = pkg.xml && pkg.xml.typePrefix || '';\n  this.addAttribute(this.nsAttributeName(this.serialization), (typeNs.prefix ? typeNs.prefix + ':' : '') + typePrefix + descriptor.ns.localName);\n  return attributes;\n};\nTypeSerializer.prototype.isLocalNs = function (ns) {\n  return ns.uri === (this.typeNs || this.ns).uri;\n};\nfunction SavingWriter() {\n  this.value = '';\n  this.write = function (str) {\n    this.value += str;\n  };\n}\nfunction FormatingWriter(out, format) {\n  var indent = [''];\n  this.append = function (str) {\n    out.write(str);\n    return this;\n  };\n  this.appendNewLine = function () {\n    if (format) {\n      out.write('\\n');\n    }\n    return this;\n  };\n  this.appendIndent = function () {\n    if (format) {\n      out.write(indent.join('  '));\n    }\n    return this;\n  };\n  this.indent = function () {\n    indent.push('');\n    return this;\n  };\n  this.unindent = function () {\n    indent.pop();\n    return this;\n  };\n}\n\n/**\n * A writer for meta-model backed document trees\n *\n * @param {Object} options output options to pass into the writer\n */\nfunction Writer(options) {\n  options = assign({\n    format: false,\n    preamble: true\n  }, options || {});\n  function toXML(tree, writer) {\n    var internalWriter = writer || new SavingWriter();\n    var formatingWriter = new FormatingWriter(internalWriter, options.format);\n    if (options.preamble) {\n      formatingWriter.append(XML_PREAMBLE);\n    }\n    var serializer = new ElementSerializer();\n    var model = tree.$model;\n    serializer.getNamespaces().mapDefaultPrefixes(getDefaultPrefixMappings(model));\n    serializer.build(tree).serializeTo(formatingWriter);\n    if (!writer) {\n      return internalWriter.value;\n    }\n  }\n  return {\n    toXML: toXML\n  };\n}\n\n// helpers ///////////\n\n/**\n * @param {Moddle} model\n *\n * @return { Record<string, string> } map from prefix to URI\n */\nfunction getDefaultPrefixMappings(model) {\n  const nsMap = model.config && model.config.nsMap || {};\n  const prefixMap = {};\n\n  // { prefix -> uri }\n  for (const prefix in DEFAULT_NS_MAP) {\n    prefixMap[prefix] = DEFAULT_NS_MAP[prefix];\n  }\n\n  // { uri -> prefix }\n  for (const uri in nsMap) {\n    const prefix = nsMap[uri];\n    prefixMap[prefix] = uri;\n  }\n  for (const pkg of model.getPackages()) {\n    prefixMap[pkg.prefix] = pkg.uri;\n  }\n  return prefixMap;\n}\nexport { Reader, Writer };","map":{"version":3,"names":["hasLowerCaseAlias","pkg","xml","tagAlias","DEFAULT_NS_MAP","SERIALIZE_PROPERTY","getSerialization","element","serialize","getSerializationType","type","capitalize","str","charAt","toUpperCase","slice","aliasToName","aliasNs","name","prefix","localName","prefixedToName","nameNs","typePrefix","indexOf","length","normalizeTypeName","nsMap","model","parseNameNS","xmlns","normalizedName","normalizedNameNs","getPackage","error","message","Error","getModdleDescriptor","$descriptor","Context","options","assign","elementsById","references","warnings","addReference","reference","push","addElement","descriptor","idProperty","id","get","test","addWarning","warning","BaseHandler","prototype","handleEnd","handleText","handleNode","NoopHandler","Object","create","BodyHandler","text","body","ReferenceHandler","property","context","node","createReference","ns","ValueHandler","propertyDesc","value","coerceType","isMany","set","BaseElementHandler","parser","createElement","handleChild","ElementHandler","typeName","getType","bodyProperty","call","undefined","attributes","Type","instance","propNameNs","forEach","prop","propertiesByName","values","isReference","split","v","getPropertyForNode","propertyName","isAttr","serializationType","elementTypeName","normalizedTypeName","elementType","effectiveType","find","properties","p","isVirtual","isAttribute","hasType","toString","valueHandler","referenceHandler","handler","GenericElementHandler","childHandler","isSimpleType","newElement","$parent","RootElementHandler","originalName","uri","createAny","children","$children","$body","Reader","Moddle","lax","fromXML","done","rootHandler","Parser","proxy","stack","createStack","handleError","err","getContext","ctx","line","column","data","handleWarning","resolveReferences","i","r","collection","idx","splice","handleClose","pop","PREAMBLE_START_PATTERN","ENCODING_PATTERN","UTF_8_PATTERN","handleQuestion","question","match","exec","encoding","handleOpen","peek","handleCData","trim","uriMap","getPackages","reduce","entries","map","_ref","url","config","on","obj","decodeStr","selfClosing","attrs","decodedAttrs","keys","d","key","decodeEntities","Promise","resolve","reject","parse","e","rootElement","defineProperty","XML_PREAMBLE","ESCAPE_ATTR_CHARS","ESCAPE_CHARS","Namespaces","parent","prefixMap","used","wellknown","custom","defaultPrefixMap","mapDefaultPrefixes","defaultUriByPrefix","byUri","add","isWellknown","mapPrefix","uriByPrefix","getNSKey","logUsed","nsKey","getUsed","allNs","concat","filter","lower","string","toLowerCase","nameToAlias","inherits","ctor","superCtor","super_","constructor","enumerable","writable","configurable","nsName","isString","getNsAttrs","namespaces","getElementNs","isGeneric","$pkg","getPropertyNs","getSerializableProperties","has","default","ESCAPE_ATTR_MAP","ESCAPE_MAP","escape","charPattern","replaceMap","replace","s","escapeAttr","escapeBody","filterAttributes","props","filterContained","ReferenceSerializer","tagName","build","serializeTo","writer","appendIndent","append","appendNewLine","BodySerializer","serializeValue","search","ValueSerializer","ElementSerializer","propertyDescriptor","elementDescriptor","otherAttrs","parseGenericNsAttributes","parseNsAttributes","nsPropertyTagName","nsTagName","addTagName","parseGenericContainments","parseAttributes","parseContainments","parseGenericAttributes","effectiveNs","logNamespaceUsed","isLocalNs","nsAttributeName","inherited","getNamespaces","_ref2","startsWith","parseNsAttribute","_ref3","child","$model","logNamespace","actualNs","self","genericAttrs","$attrs","nonNsAttr","attr","addAttribute","console","warn","isBody","serialization","serializer","TypeSerializer","local","parentNamespaces","nsUri","nsPrefix","existing","newPrefix","wellknownUri","join","findIndex","serializeAttributes","a","firstBody","indent","b","unindent","typeNs","SavingWriter","write","FormatingWriter","out","format","Writer","preamble","toXML","tree","internalWriter","formatingWriter","getDefaultPrefixMappings"],"sources":["/home/runner/work/sgex/sgex/node_modules/moddle-xml/lib/common.js","/home/runner/work/sgex/sgex/node_modules/moddle-xml/lib/read.js","/home/runner/work/sgex/sgex/node_modules/moddle-xml/lib/write.js"],"sourcesContent":["export function hasLowerCaseAlias(pkg) {\n  return pkg.xml && pkg.xml.tagAlias === 'lowerCase';\n}\n\nexport var DEFAULT_NS_MAP = {\n  'xsi': 'http://www.w3.org/2001/XMLSchema-instance',\n  'xml': 'http://www.w3.org/XML/1998/namespace'\n};\n\nexport var SERIALIZE_PROPERTY = 'property';\n\nexport function getSerialization(element) {\n  return element.xml && element.xml.serialize;\n}\n\nexport function getSerializationType(element) {\n  const type = getSerialization(element);\n\n  return type !== SERIALIZE_PROPERTY && (type || null);\n}","import {\n  forEach,\n  find,\n  assign\n} from 'min-dash';\n\nimport {\n  Parser as SaxParser\n} from 'saxen';\n\nimport {\n  Moddle,\n  parseNameNS,\n  coerceType,\n  isSimpleType\n} from 'moddle';\n\nimport {\n  DEFAULT_NS_MAP,\n  getSerializationType,\n  hasLowerCaseAlias\n} from './common.js';\n\nfunction capitalize(str) {\n  return str.charAt(0).toUpperCase() + str.slice(1);\n}\n\nfunction aliasToName(aliasNs, pkg) {\n\n  if (!hasLowerCaseAlias(pkg)) {\n    return aliasNs.name;\n  }\n\n  return aliasNs.prefix + ':' + capitalize(aliasNs.localName);\n}\n\n/**\n * Un-prefix a potentially prefixed type name.\n *\n * @param {NsName} nameNs\n * @param {Object} [pkg]\n *\n * @return {string}\n */\nfunction prefixedToName(nameNs, pkg) {\n\n  var name = nameNs.name,\n      localName = nameNs.localName;\n\n  var typePrefix = pkg && pkg.xml && pkg.xml.typePrefix;\n\n  if (typePrefix && localName.indexOf(typePrefix) === 0) {\n    return nameNs.prefix + ':' + localName.slice(typePrefix.length);\n  } else {\n    return name;\n  }\n}\n\nfunction normalizeTypeName(name, nsMap, model) {\n\n  // normalize against actual NS\n  const nameNs = parseNameNS(name, nsMap.xmlns);\n\n  const normalizedName = `${ nsMap[nameNs.prefix] || nameNs.prefix }:${ nameNs.localName }`;\n\n  const normalizedNameNs = parseNameNS(normalizedName);\n\n  // determine actual type name, based on package-defined prefix\n  var pkg = model.getPackage(normalizedNameNs.prefix);\n\n  return prefixedToName(normalizedNameNs, pkg);\n}\n\nfunction error(message) {\n  return new Error(message);\n}\n\n/**\n * Get the moddle descriptor for a given instance or type.\n *\n * @param  {ModdleElement|Function} element\n *\n * @return {Object} the moddle descriptor\n */\nfunction getModdleDescriptor(element) {\n  return element.$descriptor;\n}\n\n\n/**\n * A parse context.\n *\n * @class\n *\n * @param {Object} options\n * @param {ElementHandler} options.rootHandler the root handler for parsing a document\n * @param {boolean} [options.lax=false] whether or not to ignore invalid elements\n */\nexport function Context(options) {\n\n  /**\n   * @property {ElementHandler} rootHandler\n   */\n\n  /**\n   * @property {Boolean} lax\n   */\n\n  assign(this, options);\n\n  this.elementsById = {};\n  this.references = [];\n  this.warnings = [];\n\n  /**\n   * Add an unresolved reference.\n   *\n   * @param {Object} reference\n   */\n  this.addReference = function(reference) {\n    this.references.push(reference);\n  };\n\n  /**\n   * Add a processed element.\n   *\n   * @param {ModdleElement} element\n   */\n  this.addElement = function(element) {\n\n    if (!element) {\n      throw error('expected element');\n    }\n\n    var elementsById = this.elementsById;\n\n    var descriptor = getModdleDescriptor(element);\n\n    var idProperty = descriptor.idProperty,\n        id;\n\n    if (idProperty) {\n      id = element.get(idProperty.name);\n\n      if (id) {\n\n        // for QName validation as per http://www.w3.org/TR/REC-xml/#NT-NameChar\n        if (!/^([a-z][\\w-.]*:)?[a-z_][\\w-.]*$/i.test(id)) {\n          throw new Error('illegal ID <' + id + '>');\n        }\n\n        if (elementsById[id]) {\n          throw error('duplicate ID <' + id + '>');\n        }\n\n        elementsById[id] = element;\n      }\n    }\n  };\n\n  /**\n   * Add an import warning.\n   *\n   * @param {Object} warning\n   * @param {String} warning.message\n   * @param {Error} [warning.error]\n   */\n  this.addWarning = function(warning) {\n    this.warnings.push(warning);\n  };\n}\n\nfunction BaseHandler() {}\n\nBaseHandler.prototype.handleEnd = function() {};\nBaseHandler.prototype.handleText = function() {};\nBaseHandler.prototype.handleNode = function() {};\n\n\n/**\n * A simple pass through handler that does nothing except for\n * ignoring all input it receives.\n *\n * This is used to ignore unknown elements and\n * attributes.\n */\nfunction NoopHandler() { }\n\nNoopHandler.prototype = Object.create(BaseHandler.prototype);\n\nNoopHandler.prototype.handleNode = function() {\n  return this;\n};\n\nfunction BodyHandler() {}\n\nBodyHandler.prototype = Object.create(BaseHandler.prototype);\n\nBodyHandler.prototype.handleText = function(text) {\n  this.body = (this.body || '') + text;\n};\n\nfunction ReferenceHandler(property, context) {\n  this.property = property;\n  this.context = context;\n}\n\nReferenceHandler.prototype = Object.create(BodyHandler.prototype);\n\nReferenceHandler.prototype.handleNode = function(node) {\n\n  if (this.element) {\n    throw error('expected no sub nodes');\n  } else {\n    this.element = this.createReference(node);\n  }\n\n  return this;\n};\n\nReferenceHandler.prototype.handleEnd = function() {\n  this.element.id = this.body;\n};\n\nReferenceHandler.prototype.createReference = function(node) {\n  return {\n    property: this.property.ns.name,\n    id: ''\n  };\n};\n\nfunction ValueHandler(propertyDesc, element) {\n  this.element = element;\n  this.propertyDesc = propertyDesc;\n}\n\nValueHandler.prototype = Object.create(BodyHandler.prototype);\n\nValueHandler.prototype.handleEnd = function() {\n\n  var value = this.body || '',\n      element = this.element,\n      propertyDesc = this.propertyDesc;\n\n  value = coerceType(propertyDesc.type, value);\n\n  if (propertyDesc.isMany) {\n    element.get(propertyDesc.name).push(value);\n  } else {\n    element.set(propertyDesc.name, value);\n  }\n};\n\n\nfunction BaseElementHandler() {}\n\nBaseElementHandler.prototype = Object.create(BodyHandler.prototype);\n\nBaseElementHandler.prototype.handleNode = function(node) {\n  var parser = this,\n      element = this.element;\n\n  if (!element) {\n    element = this.element = this.createElement(node);\n\n    this.context.addElement(element);\n  } else {\n    parser = this.handleChild(node);\n  }\n\n  return parser;\n};\n\n/**\n * @class Reader.ElementHandler\n *\n */\nexport function ElementHandler(model, typeName, context) {\n  this.model = model;\n  this.type = model.getType(typeName);\n  this.context = context;\n}\n\nElementHandler.prototype = Object.create(BaseElementHandler.prototype);\n\nElementHandler.prototype.addReference = function(reference) {\n  this.context.addReference(reference);\n};\n\nElementHandler.prototype.handleText = function(text) {\n\n  var element = this.element,\n      descriptor = getModdleDescriptor(element),\n      bodyProperty = descriptor.bodyProperty;\n\n  if (!bodyProperty) {\n    throw error('unexpected body text <' + text + '>');\n  }\n\n  BodyHandler.prototype.handleText.call(this, text);\n};\n\nElementHandler.prototype.handleEnd = function() {\n\n  var value = this.body,\n      element = this.element,\n      descriptor = getModdleDescriptor(element),\n      bodyProperty = descriptor.bodyProperty;\n\n  if (bodyProperty && value !== undefined) {\n    value = coerceType(bodyProperty.type, value);\n    element.set(bodyProperty.name, value);\n  }\n};\n\n/**\n * Create an instance of the model from the given node.\n *\n * @param  {Element} node the xml node\n */\nElementHandler.prototype.createElement = function(node) {\n  var attributes = node.attributes,\n      Type = this.type,\n      descriptor = getModdleDescriptor(Type),\n      context = this.context,\n      instance = new Type({}),\n      model = this.model,\n      propNameNs;\n\n  forEach(attributes, function(value, name) {\n\n    var prop = descriptor.propertiesByName[name],\n        values;\n\n    if (prop && prop.isReference) {\n\n      if (!prop.isMany) {\n        context.addReference({\n          element: instance,\n          property: prop.ns.name,\n          id: value\n        });\n      } else {\n\n        // IDREFS: parse references as whitespace-separated list\n        values = value.split(' ');\n\n        forEach(values, function(v) {\n          context.addReference({\n            element: instance,\n            property: prop.ns.name,\n            id: v\n          });\n        });\n      }\n\n    } else {\n      if (prop) {\n        value = coerceType(prop.type, value);\n      } else if (name === 'xmlns') {\n        name = ':' + name;\n      } else {\n        propNameNs = parseNameNS(name, descriptor.ns.prefix);\n\n        // check whether attribute is defined in a well-known namespace\n        // if that is the case we emit a warning to indicate potential misuse\n        if (model.getPackage(propNameNs.prefix)) {\n\n          context.addWarning({\n            message: 'unknown attribute <' + name + '>',\n            element: instance,\n            property: name,\n            value: value\n          });\n        }\n      }\n\n      instance.set(name, value);\n    }\n  });\n\n  return instance;\n};\n\nElementHandler.prototype.getPropertyForNode = function(node) {\n\n  var name = node.name;\n  var nameNs = parseNameNS(name);\n\n  var type = this.type,\n      model = this.model,\n      descriptor = getModdleDescriptor(type);\n\n  var propertyName = nameNs.name,\n      property = descriptor.propertiesByName[propertyName];\n\n  // search for properties by name first\n\n  if (property && !property.isAttr) {\n\n    const serializationType = getSerializationType(property);\n\n    if (serializationType) {\n      const elementTypeName = node.attributes[serializationType];\n\n      // type is optional, if it does not exists the\n      // default type is assumed\n      if (elementTypeName) {\n\n        // convert the prefix used to the mapped form, but also\n        // take possible type prefixes from XML\n        // into account, i.e.: xsi:type=\"t{ActualType}\",\n        const normalizedTypeName = normalizeTypeName(elementTypeName, node.ns, model);\n\n        const elementType = model.getType(normalizedTypeName);\n\n        return assign({}, property, {\n          effectiveType: getModdleDescriptor(elementType).name\n        });\n      }\n    }\n\n    // search for properties by name first\n    return property;\n  }\n\n  var pkg = model.getPackage(nameNs.prefix);\n\n  if (pkg) {\n    const elementTypeName = aliasToName(nameNs, pkg);\n    const elementType = model.getType(elementTypeName);\n\n    // search for collection members later\n    property = find(descriptor.properties, function(p) {\n      return !p.isVirtual && !p.isReference && !p.isAttribute && elementType.hasType(p.type);\n    });\n\n    if (property) {\n      return assign({}, property, {\n        effectiveType: getModdleDescriptor(elementType).name\n      });\n    }\n  } else {\n\n    // parse unknown element (maybe extension)\n    property = find(descriptor.properties, function(p) {\n      return !p.isReference && !p.isAttribute && p.type === 'Element';\n    });\n\n    if (property) {\n      return property;\n    }\n  }\n\n  throw error('unrecognized element <' + nameNs.name + '>');\n};\n\nElementHandler.prototype.toString = function() {\n  return 'ElementDescriptor[' + getModdleDescriptor(this.type).name + ']';\n};\n\nElementHandler.prototype.valueHandler = function(propertyDesc, element) {\n  return new ValueHandler(propertyDesc, element);\n};\n\nElementHandler.prototype.referenceHandler = function(propertyDesc) {\n  return new ReferenceHandler(propertyDesc, this.context);\n};\n\nElementHandler.prototype.handler = function(type) {\n  if (type === 'Element') {\n    return new GenericElementHandler(this.model, type, this.context);\n  } else {\n    return new ElementHandler(this.model, type, this.context);\n  }\n};\n\n/**\n * Handle the child element parsing\n *\n * @param  {Element} node the xml node\n */\nElementHandler.prototype.handleChild = function(node) {\n  var propertyDesc, type, element, childHandler;\n\n  propertyDesc = this.getPropertyForNode(node);\n  element = this.element;\n\n  type = propertyDesc.effectiveType || propertyDesc.type;\n\n  if (isSimpleType(type)) {\n    return this.valueHandler(propertyDesc, element);\n  }\n\n  if (propertyDesc.isReference) {\n    childHandler = this.referenceHandler(propertyDesc).handleNode(node);\n  } else {\n    childHandler = this.handler(type).handleNode(node);\n  }\n\n  var newElement = childHandler.element;\n\n  // child handles may decide to skip elements\n  // by not returning anything\n  if (newElement !== undefined) {\n\n    if (propertyDesc.isMany) {\n      element.get(propertyDesc.name).push(newElement);\n    } else {\n      element.set(propertyDesc.name, newElement);\n    }\n\n    if (propertyDesc.isReference) {\n      assign(newElement, {\n        element: element\n      });\n\n      this.context.addReference(newElement);\n    } else {\n\n      // establish child -> parent relationship\n      newElement.$parent = element;\n    }\n  }\n\n  return childHandler;\n};\n\n/**\n * An element handler that performs special validation\n * to ensure the node it gets initialized with matches\n * the handlers type (namespace wise).\n *\n * @param {Moddle} model\n * @param {String} typeName\n * @param {Context} context\n */\nfunction RootElementHandler(model, typeName, context) {\n  ElementHandler.call(this, model, typeName, context);\n}\n\nRootElementHandler.prototype = Object.create(ElementHandler.prototype);\n\nRootElementHandler.prototype.createElement = function(node) {\n\n  var name = node.name,\n      nameNs = parseNameNS(name),\n      model = this.model,\n      type = this.type,\n      pkg = model.getPackage(nameNs.prefix),\n      typeName = pkg && aliasToName(nameNs, pkg) || name;\n\n  // verify the correct namespace if we parse\n  // the first element in the handler tree\n  //\n  // this ensures we don't mistakenly import wrong namespace elements\n  if (!type.hasType(typeName)) {\n    throw error('unexpected element <' + node.originalName + '>');\n  }\n\n  return ElementHandler.prototype.createElement.call(this, node);\n};\n\n\nfunction GenericElementHandler(model, typeName, context) {\n  this.model = model;\n  this.context = context;\n}\n\nGenericElementHandler.prototype = Object.create(BaseElementHandler.prototype);\n\nGenericElementHandler.prototype.createElement = function(node) {\n\n  var name = node.name,\n      ns = parseNameNS(name),\n      prefix = ns.prefix,\n      uri = node.ns[prefix + '$uri'],\n      attributes = node.attributes;\n\n  return this.model.createAny(name, uri, attributes);\n};\n\nGenericElementHandler.prototype.handleChild = function(node) {\n\n  var handler = new GenericElementHandler(this.model, 'Element', this.context).handleNode(node),\n      element = this.element;\n\n  var newElement = handler.element,\n      children;\n\n  if (newElement !== undefined) {\n    children = element.$children = element.$children || [];\n    children.push(newElement);\n\n    // establish child -> parent relationship\n    newElement.$parent = element;\n  }\n\n  return handler;\n};\n\nGenericElementHandler.prototype.handleEnd = function() {\n  if (this.body) {\n    this.element.$body = this.body;\n  }\n};\n\n/**\n * A reader for a meta-model\n *\n * @param {Object} options\n * @param {Model} options.model used to read xml files\n * @param {Boolean} options.lax whether to make parse errors warnings\n */\nexport function Reader(options) {\n\n  if (options instanceof Moddle) {\n    options = {\n      model: options\n    };\n  }\n\n  assign(this, { lax: false }, options);\n}\n\n/**\n * The fromXML result.\n *\n * @typedef {Object} ParseResult\n *\n * @property {ModdleElement} rootElement\n * @property {Array<Object>} references\n * @property {Array<Error>} warnings\n * @property {Object} elementsById - a mapping containing each ID -> ModdleElement\n */\n\n/**\n * The fromXML result.\n *\n * @typedef {Error} ParseError\n *\n * @property {Array<Error>} warnings\n */\n\n/**\n * Parse the given XML into a moddle document tree.\n *\n * @param {String} xml\n * @param {ElementHandler|Object} options or rootHandler\n *\n * @returns {Promise<ParseResult, ParseError>}\n */\nReader.prototype.fromXML = function(xml, options, done) {\n\n  var rootHandler = options.rootHandler;\n\n  if (options instanceof ElementHandler) {\n\n    // root handler passed via (xml, { rootHandler: ElementHandler }, ...)\n    rootHandler = options;\n    options = {};\n  } else {\n    if (typeof options === 'string') {\n\n      // rootHandler passed via (xml, 'someString', ...)\n      rootHandler = this.handler(options);\n      options = {};\n    } else if (typeof rootHandler === 'string') {\n\n      // rootHandler passed via (xml, { rootHandler: 'someString' }, ...)\n      rootHandler = this.handler(rootHandler);\n    }\n  }\n\n  var model = this.model,\n      lax = this.lax;\n\n  var context = new Context(assign({}, options, { rootHandler: rootHandler })),\n      parser = new SaxParser({ proxy: true }),\n      stack = createStack();\n\n  rootHandler.context = context;\n\n  // push root handler\n  stack.push(rootHandler);\n\n\n  /**\n   * Handle error.\n   *\n   * @param  {Error} err\n   * @param  {Function} getContext\n   * @param  {boolean} lax\n   *\n   * @return {boolean} true if handled\n   */\n  function handleError(err, getContext, lax) {\n\n    var ctx = getContext();\n\n    var line = ctx.line,\n        column = ctx.column,\n        data = ctx.data;\n\n    // we receive the full context data here,\n    // for elements trim down the information\n    // to the tag name, only\n    if (data.charAt(0) === '<' && data.indexOf(' ') !== -1) {\n      data = data.slice(0, data.indexOf(' ')) + '>';\n    }\n\n    var message =\n      'unparsable content ' + (data ? data + ' ' : '') + 'detected\\n\\t' +\n        'line: ' + line + '\\n\\t' +\n        'column: ' + column + '\\n\\t' +\n        'nested error: ' + err.message;\n\n    if (lax) {\n      context.addWarning({\n        message: message,\n        error: err\n      });\n\n      return true;\n    } else {\n      throw error(message);\n    }\n  }\n\n  function handleWarning(err, getContext) {\n\n    // just like handling errors in <lax=true> mode\n    return handleError(err, getContext, true);\n  }\n\n  /**\n   * Resolve collected references on parse end.\n   */\n  function resolveReferences() {\n\n    var elementsById = context.elementsById;\n    var references = context.references;\n\n    var i, r;\n\n    for (i = 0; (r = references[i]); i++) {\n      var element = r.element;\n      var reference = elementsById[r.id];\n      var property = getModdleDescriptor(element).propertiesByName[r.property];\n\n      if (!reference) {\n        context.addWarning({\n          message: 'unresolved reference <' + r.id + '>',\n          element: r.element,\n          property: r.property,\n          value: r.id\n        });\n      }\n\n      if (property.isMany) {\n        var collection = element.get(property.name),\n            idx = collection.indexOf(r);\n\n        // we replace an existing place holder (idx != -1) or\n        // append to the collection instead\n        if (idx === -1) {\n          idx = collection.length;\n        }\n\n        if (!reference) {\n\n          // remove unresolvable reference\n          collection.splice(idx, 1);\n        } else {\n\n          // add or update reference in collection\n          collection[idx] = reference;\n        }\n      } else {\n        element.set(property.name, reference);\n      }\n    }\n  }\n\n  function handleClose() {\n    stack.pop().handleEnd();\n  }\n\n  var PREAMBLE_START_PATTERN = /^<\\?xml /i;\n\n  var ENCODING_PATTERN = / encoding=\"([^\"]+)\"/i;\n\n  var UTF_8_PATTERN = /^utf-8$/i;\n\n  function handleQuestion(question) {\n\n    if (!PREAMBLE_START_PATTERN.test(question)) {\n      return;\n    }\n\n    var match = ENCODING_PATTERN.exec(question);\n    var encoding = match && match[1];\n\n    if (!encoding || UTF_8_PATTERN.test(encoding)) {\n      return;\n    }\n\n    context.addWarning({\n      message:\n        'unsupported document encoding <' + encoding + '>, ' +\n        'falling back to UTF-8'\n    });\n  }\n\n  function handleOpen(node, getContext) {\n    var handler = stack.peek();\n\n    try {\n      stack.push(handler.handleNode(node));\n    } catch (err) {\n\n      if (handleError(err, getContext, lax)) {\n        stack.push(new NoopHandler());\n      }\n    }\n  }\n\n  function handleCData(text, getContext) {\n\n    try {\n      stack.peek().handleText(text);\n    } catch (err) {\n      handleWarning(err, getContext);\n    }\n  }\n\n  function handleText(text, getContext) {\n\n    // strip whitespace only nodes, i.e. before\n    // <!CDATA[ ... ]> sections and in between tags\n\n    if (!text.trim()) {\n      return;\n    }\n\n    handleCData(text, getContext);\n  }\n\n  var uriMap = model.getPackages().reduce(function(uriMap, p) {\n    uriMap[p.uri] = p.prefix;\n\n    return uriMap;\n  }, Object.entries(DEFAULT_NS_MAP).reduce(function(map, [ prefix, url ]) {\n    map[url] = prefix;\n\n    return map;\n  }, model.config && model.config.nsMap || {}));\n\n  parser\n    .ns(uriMap)\n    .on('openTag', function(obj, decodeStr, selfClosing, getContext) {\n\n      // gracefully handle unparsable attributes (attrs=false)\n      var attrs = obj.attrs || {};\n\n      var decodedAttrs = Object.keys(attrs).reduce(function(d, key) {\n        var value = decodeStr(attrs[key]);\n\n        d[key] = value;\n\n        return d;\n      }, {});\n\n      var node = {\n        name: obj.name,\n        originalName: obj.originalName,\n        attributes: decodedAttrs,\n        ns: obj.ns\n      };\n\n      handleOpen(node, getContext);\n    })\n    .on('question', handleQuestion)\n    .on('closeTag', handleClose)\n    .on('cdata', handleCData)\n    .on('text', function(text, decodeEntities, getContext) {\n      handleText(decodeEntities(text), getContext);\n    })\n    .on('error', handleError)\n    .on('warn', handleWarning);\n\n  // async XML parsing to make sure the execution environment\n  // (node or brower) is kept responsive and that certain optimization\n  // strategies can kick in.\n  return new Promise(function(resolve, reject) {\n\n    var err;\n\n    try {\n      parser.parse(xml);\n\n      resolveReferences();\n    } catch (e) {\n      err = e;\n    }\n\n    var rootElement = rootHandler.element;\n\n    if (!err && !rootElement) {\n      err = error('failed to parse document as <' + rootHandler.type.$descriptor.name + '>');\n    }\n\n    var warnings = context.warnings;\n    var references = context.references;\n    var elementsById = context.elementsById;\n\n    if (err) {\n      err.warnings = warnings;\n\n      return reject(err);\n    } else {\n      return resolve({\n        rootElement: rootElement,\n        elementsById: elementsById,\n        references: references,\n        warnings: warnings\n      });\n    }\n  });\n};\n\nReader.prototype.handler = function(name) {\n  return new RootElementHandler(this.model, name);\n};\n\n\n// helpers //////////////////////////\n\nfunction createStack() {\n  var stack = [];\n\n  Object.defineProperty(stack, 'peek', {\n    value: function() {\n      return this[this.length - 1];\n    }\n  });\n\n  return stack;\n}\n","import {\n  forEach,\n  isString,\n  filter,\n  assign,\n  has,\n  findIndex\n} from 'min-dash';\n\nimport {\n  isSimpleType,\n  parseNameNS\n} from 'moddle';\n\nimport {\n  hasLowerCaseAlias,\n  getSerialization,\n  SERIALIZE_PROPERTY,\n  DEFAULT_NS_MAP\n} from './common.js';\n\nvar XML_PREAMBLE = '<?xml version=\"1.0\" encoding=\"UTF-8\"?>\\n';\n\nvar ESCAPE_ATTR_CHARS = /<|>|'|\"|&|\\n\\r|\\n/g;\nvar ESCAPE_CHARS = /<|>|&/g;\n\n\nexport function Namespaces(parent) {\n\n  this.prefixMap = {};\n  this.uriMap = {};\n  this.used = {};\n\n  this.wellknown = [];\n  this.custom = [];\n  this.parent = parent;\n\n  this.defaultPrefixMap = parent && parent.defaultPrefixMap || {};\n}\n\nNamespaces.prototype.mapDefaultPrefixes = function(defaultPrefixMap) {\n  this.defaultPrefixMap = defaultPrefixMap;\n};\n\nNamespaces.prototype.defaultUriByPrefix = function(prefix) {\n  return this.defaultPrefixMap[prefix];\n};\n\nNamespaces.prototype.byUri = function(uri) {\n  return this.uriMap[uri] || (\n    this.parent && this.parent.byUri(uri)\n  );\n};\n\nNamespaces.prototype.add = function(ns, isWellknown) {\n\n  this.uriMap[ns.uri] = ns;\n\n  if (isWellknown) {\n    this.wellknown.push(ns);\n  } else {\n    this.custom.push(ns);\n  }\n\n  this.mapPrefix(ns.prefix, ns.uri);\n};\n\nNamespaces.prototype.uriByPrefix = function(prefix) {\n  return this.prefixMap[prefix || 'xmlns'] || (\n    this.parent && this.parent.uriByPrefix(prefix)\n  );\n};\n\nNamespaces.prototype.mapPrefix = function(prefix, uri) {\n  this.prefixMap[prefix || 'xmlns'] = uri;\n};\n\nNamespaces.prototype.getNSKey = function(ns) {\n  return (ns.prefix !== undefined) ? (ns.uri + '|' + ns.prefix) : ns.uri;\n};\n\nNamespaces.prototype.logUsed = function(ns) {\n\n  var uri = ns.uri;\n  var nsKey = this.getNSKey(ns);\n\n  this.used[nsKey] = this.byUri(uri);\n\n  // Inform parent recursively about the usage of this NS\n  if (this.parent) {\n    this.parent.logUsed(ns);\n  }\n};\n\nNamespaces.prototype.getUsed = function(ns) {\n\n  var allNs = [].concat(this.wellknown, this.custom);\n\n  return allNs.filter(ns => {\n    var nsKey = this.getNSKey(ns);\n\n    return this.used[nsKey];\n  });\n};\n\n\nfunction lower(string) {\n  return string.charAt(0).toLowerCase() + string.slice(1);\n}\n\nfunction nameToAlias(name, pkg) {\n  if (hasLowerCaseAlias(pkg)) {\n    return lower(name);\n  } else {\n    return name;\n  }\n}\n\nfunction inherits(ctor, superCtor) {\n  ctor.super_ = superCtor;\n  ctor.prototype = Object.create(superCtor.prototype, {\n    constructor: {\n      value: ctor,\n      enumerable: false,\n      writable: true,\n      configurable: true\n    }\n  });\n}\n\nfunction nsName(ns) {\n  if (isString(ns)) {\n    return ns;\n  } else {\n    return (ns.prefix ? ns.prefix + ':' : '') + ns.localName;\n  }\n}\n\nfunction getNsAttrs(namespaces) {\n\n  return namespaces.getUsed().filter(function(ns) {\n\n    // do not serialize built in <xml> namespace\n    return ns.prefix !== 'xml';\n  }).map(function(ns) {\n    var name = 'xmlns' + (ns.prefix ? ':' + ns.prefix : '');\n    return { name: name, value: ns.uri };\n  });\n\n}\n\nfunction getElementNs(ns, descriptor) {\n  if (descriptor.isGeneric) {\n    return assign({ localName: descriptor.ns.localName }, ns);\n  } else {\n    return assign({ localName: nameToAlias(descriptor.ns.localName, descriptor.$pkg) }, ns);\n  }\n}\n\nfunction getPropertyNs(ns, descriptor) {\n  return assign({ localName: descriptor.ns.localName }, ns);\n}\n\nfunction getSerializableProperties(element) {\n  var descriptor = element.$descriptor;\n\n  return filter(descriptor.properties, function(p) {\n    var name = p.name;\n\n    if (p.isVirtual) {\n      return false;\n    }\n\n    // do not serialize defaults\n    if (!has(element, name)) {\n      return false;\n    }\n\n    var value = element[name];\n\n    // do not serialize default equals\n    if (value === p.default) {\n      return false;\n    }\n\n    // do not serialize null properties\n    if (value === null) {\n      return false;\n    }\n\n    return p.isMany ? value.length : true;\n  });\n}\n\nvar ESCAPE_ATTR_MAP = {\n  '\\n': '#10',\n  '\\n\\r': '#10',\n  '\"': '#34',\n  '\\'': '#39',\n  '<': '#60',\n  '>': '#62',\n  '&': '#38'\n};\n\nvar ESCAPE_MAP = {\n  '<': 'lt',\n  '>': 'gt',\n  '&': 'amp'\n};\n\nfunction escape(str, charPattern, replaceMap) {\n\n  // ensure we are handling strings here\n  str = isString(str) ? str : '' + str;\n\n  return str.replace(charPattern, function(s) {\n    return '&' + replaceMap[s] + ';';\n  });\n}\n\n/**\n * Escape a string attribute to not contain any bad values (line breaks, '\"', ...)\n *\n * @param {String} str the string to escape\n * @return {String} the escaped string\n */\nfunction escapeAttr(str) {\n  return escape(str, ESCAPE_ATTR_CHARS, ESCAPE_ATTR_MAP);\n}\n\nfunction escapeBody(str) {\n  return escape(str, ESCAPE_CHARS, ESCAPE_MAP);\n}\n\nfunction filterAttributes(props) {\n  return filter(props, function(p) { return p.isAttr; });\n}\n\nfunction filterContained(props) {\n  return filter(props, function(p) { return !p.isAttr; });\n}\n\n\nfunction ReferenceSerializer(tagName) {\n  this.tagName = tagName;\n}\n\nReferenceSerializer.prototype.build = function(element) {\n  this.element = element;\n  return this;\n};\n\nReferenceSerializer.prototype.serializeTo = function(writer) {\n  writer\n    .appendIndent()\n    .append('<' + this.tagName + '>' + this.element.id + '</' + this.tagName + '>')\n    .appendNewLine();\n};\n\nfunction BodySerializer() {}\n\nBodySerializer.prototype.serializeValue =\nBodySerializer.prototype.serializeTo = function(writer) {\n  writer.append(\n    this.escape\n      ? escapeBody(this.value)\n      : this.value\n  );\n};\n\nBodySerializer.prototype.build = function(prop, value) {\n  this.value = value;\n\n  if (prop.type === 'String' && value.search(ESCAPE_CHARS) !== -1) {\n    this.escape = true;\n  }\n\n  return this;\n};\n\nfunction ValueSerializer(tagName) {\n  this.tagName = tagName;\n}\n\ninherits(ValueSerializer, BodySerializer);\n\nValueSerializer.prototype.serializeTo = function(writer) {\n\n  writer\n    .appendIndent()\n    .append('<' + this.tagName + '>');\n\n  this.serializeValue(writer);\n\n  writer\n    .append('</' + this.tagName + '>')\n    .appendNewLine();\n};\n\nfunction ElementSerializer(parent, propertyDescriptor) {\n  this.body = [];\n  this.attrs = [];\n\n  this.parent = parent;\n  this.propertyDescriptor = propertyDescriptor;\n}\n\nElementSerializer.prototype.build = function(element) {\n  this.element = element;\n\n  var elementDescriptor = element.$descriptor,\n      propertyDescriptor = this.propertyDescriptor;\n\n  var otherAttrs,\n      properties;\n\n  var isGeneric = elementDescriptor.isGeneric;\n\n  if (isGeneric) {\n    otherAttrs = this.parseGenericNsAttributes(element);\n  } else {\n    otherAttrs = this.parseNsAttributes(element);\n  }\n\n  if (propertyDescriptor) {\n    this.ns = this.nsPropertyTagName(propertyDescriptor);\n  } else {\n    this.ns = this.nsTagName(elementDescriptor);\n  }\n\n  // compute tag name\n  this.tagName = this.addTagName(this.ns);\n\n  if (isGeneric) {\n    this.parseGenericContainments(element);\n  } else {\n    properties = getSerializableProperties(element);\n\n    this.parseAttributes(filterAttributes(properties));\n    this.parseContainments(filterContained(properties));\n  }\n\n  this.parseGenericAttributes(element, otherAttrs);\n\n  return this;\n};\n\nElementSerializer.prototype.nsTagName = function(descriptor) {\n  var effectiveNs = this.logNamespaceUsed(descriptor.ns);\n  return getElementNs(effectiveNs, descriptor);\n};\n\nElementSerializer.prototype.nsPropertyTagName = function(descriptor) {\n  var effectiveNs = this.logNamespaceUsed(descriptor.ns);\n  return getPropertyNs(effectiveNs, descriptor);\n};\n\nElementSerializer.prototype.isLocalNs = function(ns) {\n  return ns.uri === this.ns.uri;\n};\n\n/**\n * Get the actual ns attribute name for the given element.\n *\n * @param {Object} element\n * @param {Boolean} [element.inherited=false]\n *\n * @return {Object} nsName\n */\nElementSerializer.prototype.nsAttributeName = function(element) {\n\n  var ns;\n\n  if (isString(element)) {\n    ns = parseNameNS(element);\n  } else {\n    ns = element.ns;\n  }\n\n  // return just local name for inherited attributes\n  if (element.inherited) {\n    return { localName: ns.localName };\n  }\n\n  // parse + log effective ns\n  var effectiveNs = this.logNamespaceUsed(ns);\n\n  // LOG ACTUAL namespace use\n  this.getNamespaces().logUsed(effectiveNs);\n\n  // strip prefix if same namespace like parent\n  if (this.isLocalNs(effectiveNs)) {\n    return { localName: ns.localName };\n  } else {\n    return assign({ localName: ns.localName }, effectiveNs);\n  }\n};\n\nElementSerializer.prototype.parseGenericNsAttributes = function(element) {\n\n  return Object.entries(element).filter(\n    ([ key, value ]) => !key.startsWith('$') && this.parseNsAttribute(element, key, value)\n  ).map(\n    ([ key, value ]) => ({ name: key, value: value })\n  );\n};\n\nElementSerializer.prototype.parseGenericContainments = function(element) {\n  var body = element.$body;\n\n  if (body) {\n    this.body.push(new BodySerializer().build({ type: 'String' }, body));\n  }\n\n  var children = element.$children;\n\n  if (children) {\n    forEach(children, child => {\n      this.body.push(new ElementSerializer(this).build(child));\n    });\n  }\n};\n\nElementSerializer.prototype.parseNsAttribute = function(element, name, value) {\n  var model = element.$model;\n\n  var nameNs = parseNameNS(name);\n\n  var ns;\n\n  // parse xmlns:foo=\"http://foo.bar\"\n  if (nameNs.prefix === 'xmlns') {\n    ns = { prefix: nameNs.localName, uri: value };\n  }\n\n  // parse xmlns=\"http://foo.bar\"\n  if (!nameNs.prefix && nameNs.localName === 'xmlns') {\n    ns = { uri: value };\n  }\n\n  if (!ns) {\n    return {\n      name: name,\n      value: value\n    };\n  }\n\n  if (model && model.getPackage(value)) {\n\n    // register well known namespace\n    this.logNamespace(ns, true, true);\n  } else {\n\n    // log custom namespace directly as used\n    var actualNs = this.logNamespaceUsed(ns, true);\n\n    this.getNamespaces().logUsed(actualNs);\n  }\n};\n\n\n/**\n * Parse namespaces and return a list of left over generic attributes\n *\n * @param  {Object} element\n * @return {Array<Object>}\n */\nElementSerializer.prototype.parseNsAttributes = function(element) {\n  var self = this;\n\n  var genericAttrs = element.$attrs;\n\n  var attributes = [];\n\n  // parse namespace attributes first\n  // and log them. push non namespace attributes to a list\n  // and process them later\n  forEach(genericAttrs, function(value, name) {\n\n    var nonNsAttr = self.parseNsAttribute(element, name, value);\n\n    if (nonNsAttr) {\n      attributes.push(nonNsAttr);\n    }\n  });\n\n  return attributes;\n};\n\nElementSerializer.prototype.parseGenericAttributes = function(element, attributes) {\n\n  var self = this;\n\n  forEach(attributes, function(attr) {\n\n    try {\n      self.addAttribute(self.nsAttributeName(attr.name), attr.value);\n    } catch (e) {\n\n      // eslint-disable-next-line no-undef\n      typeof console !== 'undefined' && console.warn(\n        `missing namespace information for <${\n          attr.name\n        }=${ attr.value }> on`, element, e\n      );\n    }\n  });\n};\n\nElementSerializer.prototype.parseContainments = function(properties) {\n\n  var self = this,\n      body = this.body,\n      element = this.element;\n\n  forEach(properties, function(p) {\n    var value = element.get(p.name),\n        isReference = p.isReference,\n        isMany = p.isMany;\n\n    if (!isMany) {\n      value = [ value ];\n    }\n\n    if (p.isBody) {\n      body.push(new BodySerializer().build(p, value[0]));\n    } else if (isSimpleType(p.type)) {\n      forEach(value, function(v) {\n        body.push(new ValueSerializer(self.addTagName(self.nsPropertyTagName(p))).build(p, v));\n      });\n    } else if (isReference) {\n      forEach(value, function(v) {\n        body.push(new ReferenceSerializer(self.addTagName(self.nsPropertyTagName(p))).build(v));\n      });\n    } else {\n\n      // allow serialization via type\n      // rather than element name\n      var serialization = getSerialization(p);\n\n      forEach(value, function(v) {\n        var serializer;\n\n        if (serialization) {\n          if (serialization === SERIALIZE_PROPERTY) {\n            serializer = new ElementSerializer(self, p);\n          } else {\n            serializer = new TypeSerializer(self, p, serialization);\n          }\n        } else {\n          serializer = new ElementSerializer(self);\n        }\n\n        body.push(serializer.build(v));\n      });\n    }\n  });\n};\n\nElementSerializer.prototype.getNamespaces = function(local) {\n\n  var namespaces = this.namespaces,\n      parent = this.parent,\n      parentNamespaces;\n\n  if (!namespaces) {\n    parentNamespaces = parent && parent.getNamespaces();\n\n    if (local || !parentNamespaces) {\n      this.namespaces = namespaces = new Namespaces(parentNamespaces);\n    } else {\n      namespaces = parentNamespaces;\n    }\n  }\n\n  return namespaces;\n};\n\nElementSerializer.prototype.logNamespace = function(ns, wellknown, local) {\n  var namespaces = this.getNamespaces(local);\n\n  var nsUri = ns.uri,\n      nsPrefix = ns.prefix;\n\n  var existing = namespaces.byUri(nsUri);\n\n  if (!existing || local) {\n    namespaces.add(ns, wellknown);\n  }\n\n  namespaces.mapPrefix(nsPrefix, nsUri);\n\n  return ns;\n};\n\nElementSerializer.prototype.logNamespaceUsed = function(ns, local) {\n  var namespaces = this.getNamespaces(local);\n\n  // ns may be\n  //\n  //   * prefix only\n  //   * prefix:uri\n  //   * localName only\n\n  var prefix = ns.prefix,\n      uri = ns.uri,\n      newPrefix, idx,\n      wellknownUri;\n\n  // handle anonymous namespaces (elementForm=unqualified), cf. #23\n  if (!prefix && !uri) {\n    return { localName: ns.localName };\n  }\n\n  wellknownUri = namespaces.defaultUriByPrefix(prefix);\n\n  uri = uri || wellknownUri || namespaces.uriByPrefix(prefix);\n\n  if (!uri) {\n    throw new Error('no namespace uri given for prefix <' + prefix + '>');\n  }\n\n  ns = namespaces.byUri(uri);\n\n  // register new default prefix <xmlns> in local scope\n  if (!ns && !prefix) {\n    ns = this.logNamespace({ uri }, wellknownUri === uri, true);\n  }\n\n  if (!ns) {\n    newPrefix = prefix;\n    idx = 1;\n\n    // find a prefix that is not mapped yet\n    while (namespaces.uriByPrefix(newPrefix)) {\n      newPrefix = prefix + '_' + idx++;\n    }\n\n    ns = this.logNamespace({ prefix: newPrefix, uri: uri }, wellknownUri === uri);\n  }\n\n  if (prefix) {\n    namespaces.mapPrefix(prefix, uri);\n  }\n\n  return ns;\n};\n\nElementSerializer.prototype.parseAttributes = function(properties) {\n  var self = this,\n      element = this.element;\n\n  forEach(properties, function(p) {\n\n    var value = element.get(p.name);\n\n    if (p.isReference) {\n\n      if (!p.isMany) {\n        value = value.id;\n      } else {\n        var values = [];\n        forEach(value, function(v) {\n          values.push(v.id);\n        });\n\n        // IDREFS is a whitespace-separated list of references.\n        value = values.join(' ');\n      }\n\n    }\n\n    self.addAttribute(self.nsAttributeName(p), value);\n  });\n};\n\nElementSerializer.prototype.addTagName = function(nsTagName) {\n  var actualNs = this.logNamespaceUsed(nsTagName);\n\n  this.getNamespaces().logUsed(actualNs);\n\n  return nsName(nsTagName);\n};\n\nElementSerializer.prototype.addAttribute = function(name, value) {\n  var attrs = this.attrs;\n\n  if (isString(value)) {\n    value = escapeAttr(value);\n  }\n\n  // de-duplicate attributes\n  // https://github.com/bpmn-io/moddle-xml/issues/66\n  var idx = findIndex(attrs, function(element) {\n    return (\n      element.name.localName === name.localName &&\n      element.name.uri === name.uri &&\n      element.name.prefix === name.prefix\n    );\n  });\n\n  var attr = { name: name, value: value };\n\n  if (idx !== -1) {\n    attrs.splice(idx, 1, attr);\n  } else {\n    attrs.push(attr);\n  }\n};\n\nElementSerializer.prototype.serializeAttributes = function(writer) {\n  var attrs = this.attrs,\n      namespaces = this.namespaces;\n\n  if (namespaces) {\n    attrs = getNsAttrs(namespaces).concat(attrs);\n  }\n\n  forEach(attrs, function(a) {\n    writer\n      .append(' ')\n      .append(nsName(a.name)).append('=\"').append(a.value).append('\"');\n  });\n};\n\nElementSerializer.prototype.serializeTo = function(writer) {\n  var firstBody = this.body[0],\n      indent = firstBody && firstBody.constructor !== BodySerializer;\n\n  writer\n    .appendIndent()\n    .append('<' + this.tagName);\n\n  this.serializeAttributes(writer);\n\n  writer.append(firstBody ? '>' : ' />');\n\n  if (firstBody) {\n\n    if (indent) {\n      writer\n        .appendNewLine()\n        .indent();\n    }\n\n    forEach(this.body, function(b) {\n      b.serializeTo(writer);\n    });\n\n    if (indent) {\n      writer\n        .unindent()\n        .appendIndent();\n    }\n\n    writer.append('</' + this.tagName + '>');\n  }\n\n  writer.appendNewLine();\n};\n\n/**\n * A serializer for types that handles serialization of data types\n */\nfunction TypeSerializer(parent, propertyDescriptor, serialization) {\n  ElementSerializer.call(this, parent, propertyDescriptor);\n\n  this.serialization = serialization;\n}\n\ninherits(TypeSerializer, ElementSerializer);\n\nTypeSerializer.prototype.parseNsAttributes = function(element) {\n\n  // extracted attributes with serialization attribute\n  // <type=typeName> stripped; it may be later\n  var attributes = ElementSerializer.prototype.parseNsAttributes.call(this, element).filter(\n    attr => attr.name !== this.serialization\n  );\n\n  var descriptor = element.$descriptor;\n\n  // only serialize <type=typeName> if necessary\n  if (descriptor.name === this.propertyDescriptor.type) {\n    return attributes;\n  }\n\n  var typeNs = this.typeNs = this.nsTagName(descriptor);\n  this.getNamespaces().logUsed(this.typeNs);\n\n  // add xsi:type attribute to represent the elements\n  // actual type\n\n  var pkg = element.$model.getPackage(typeNs.uri),\n      typePrefix = (pkg.xml && pkg.xml.typePrefix) || '';\n\n  this.addAttribute(\n    this.nsAttributeName(this.serialization),\n    (typeNs.prefix ? typeNs.prefix + ':' : '') + typePrefix + descriptor.ns.localName\n  );\n\n  return attributes;\n};\n\nTypeSerializer.prototype.isLocalNs = function(ns) {\n  return ns.uri === (this.typeNs || this.ns).uri;\n};\n\nfunction SavingWriter() {\n  this.value = '';\n\n  this.write = function(str) {\n    this.value += str;\n  };\n}\n\nfunction FormatingWriter(out, format) {\n\n  var indent = [ '' ];\n\n  this.append = function(str) {\n    out.write(str);\n\n    return this;\n  };\n\n  this.appendNewLine = function() {\n    if (format) {\n      out.write('\\n');\n    }\n\n    return this;\n  };\n\n  this.appendIndent = function() {\n    if (format) {\n      out.write(indent.join('  '));\n    }\n\n    return this;\n  };\n\n  this.indent = function() {\n    indent.push('');\n    return this;\n  };\n\n  this.unindent = function() {\n    indent.pop();\n    return this;\n  };\n}\n\n/**\n * A writer for meta-model backed document trees\n *\n * @param {Object} options output options to pass into the writer\n */\nexport function Writer(options) {\n\n  options = assign({ format: false, preamble: true }, options || {});\n\n  function toXML(tree, writer) {\n    var internalWriter = writer || new SavingWriter();\n    var formatingWriter = new FormatingWriter(internalWriter, options.format);\n\n    if (options.preamble) {\n      formatingWriter.append(XML_PREAMBLE);\n    }\n\n    var serializer = new ElementSerializer();\n\n    var model = tree.$model;\n\n    serializer.getNamespaces().mapDefaultPrefixes(getDefaultPrefixMappings(model));\n\n    serializer.build(tree).serializeTo(formatingWriter);\n\n    if (!writer) {\n      return internalWriter.value;\n    }\n  }\n\n  return {\n    toXML: toXML\n  };\n}\n\n\n// helpers ///////////\n\n/**\n * @param {Moddle} model\n *\n * @return { Record<string, string> } map from prefix to URI\n */\nfunction getDefaultPrefixMappings(model) {\n\n  const nsMap = model.config && model.config.nsMap || {};\n\n  const prefixMap = {};\n\n  // { prefix -> uri }\n  for (const prefix in DEFAULT_NS_MAP) {\n    prefixMap[prefix] = DEFAULT_NS_MAP[prefix];\n  }\n\n  // { uri -> prefix }\n  for (const uri in nsMap) {\n    const prefix = nsMap[uri];\n\n    prefixMap[prefix] = uri;\n  }\n\n  for (const pkg of model.getPackages()) {\n    prefixMap[pkg.prefix] = pkg.uri;\n  }\n\n  return prefixMap;\n}"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}