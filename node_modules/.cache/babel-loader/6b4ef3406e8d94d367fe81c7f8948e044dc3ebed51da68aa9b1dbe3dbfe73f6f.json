{"ast":null,"code":"import { uniqueBy, isArray } from 'min-dash';\n\n/**\n * @typedef {import('didi').Injector} Injector\n *\n * @typedef {import('../core/Types').ElementLike} ElementLike\n *\n * @typedef {import('../core/EventBus').default} EventBus\n * @typedef {import('./CommandHandler').default} CommandHandler\n *\n * @typedef { any } CommandContext\n * @typedef { {\n *   new (...args: any[]) : CommandHandler\n * } } CommandHandlerConstructor\n * @typedef { {\n *   [key: string]: CommandHandler;\n * } } CommandHandlerMap\n * @typedef { {\n *   command: string;\n *   context: any;\n *   id?: any;\n * } } CommandStackAction\n * @typedef { {\n *   actions: CommandStackAction[];\n *   dirty: ElementLike[];\n *   trigger: 'execute' | 'undo' | 'redo' | 'clear' | null;\n *   atomic?: boolean;\n * } } CurrentExecution\n */\n\n/**\n * A service that offers un- and redoable execution of commands.\n *\n * The command stack is responsible for executing modeling actions\n * in a un- and redoable manner. To do this it delegates the actual\n * command execution to {@link CommandHandler}s.\n *\n * Command handlers provide {@link CommandHandler#execute(ctx)} and\n * {@link CommandHandler#revert(ctx)} methods to un- and redo a command\n * identified by a command context.\n *\n *\n * ## Life-Cycle events\n *\n * In the process the command stack fires a number of life-cycle events\n * that other components to participate in the command execution.\n *\n *    * preExecute\n *    * preExecuted\n *    * execute\n *    * executed\n *    * postExecute\n *    * postExecuted\n *    * revert\n *    * reverted\n *\n * A special event is used for validating, whether a command can be\n * performed prior to its execution.\n *\n *    * canExecute\n *\n * Each of the events is fired as `commandStack.{eventName}` and\n * `commandStack.{commandName}.{eventName}`, respectively. This gives\n * components fine grained control on where to hook into.\n *\n * The event object fired transports `command`, the name of the\n * command and `context`, the command context.\n *\n *\n * ## Creating Command Handlers\n *\n * Command handlers should provide the {@link CommandHandler#execute(ctx)}\n * and {@link CommandHandler#revert(ctx)} methods to implement\n * redoing and undoing of a command.\n *\n * A command handler _must_ ensure undo is performed properly in order\n * not to break the undo chain. It must also return the shapes that\n * got changed during the `execute` and `revert` operations.\n *\n * Command handlers may execute other modeling operations (and thus\n * commands) in their `preExecute(d)` and `postExecute(d)` phases. The command\n * stack will properly group all commands together into a logical unit\n * that may be re- and undone atomically.\n *\n * Command handlers must not execute other commands from within their\n * core implementation (`execute`, `revert`).\n *\n *\n * ## Change Tracking\n *\n * During the execution of the CommandStack it will keep track of all\n * elements that have been touched during the command's execution.\n *\n * At the end of the CommandStack execution it will notify interested\n * components via an 'elements.changed' event with all the dirty\n * elements.\n *\n * The event can be picked up by components that are interested in the fact\n * that elements have been changed. One use case for this is updating\n * their graphical representation after moving / resizing or deletion.\n *\n * @see CommandHandler\n *\n * @param {EventBus} eventBus\n * @param {Injector} injector\n */\nexport default function CommandStack(eventBus, injector) {\n  /**\n   * A map of all registered command handlers.\n   *\n   * @type {CommandHandlerMap}\n   */\n  this._handlerMap = {};\n\n  /**\n   * A stack containing all re/undoable actions on the diagram\n   *\n   * @type {CommandStackAction[]}\n   */\n  this._stack = [];\n\n  /**\n   * The current index on the stack\n   *\n   * @type {number}\n   */\n  this._stackIdx = -1;\n\n  /**\n   * Current active commandStack execution\n   *\n   * @type {CurrentExecution}\n   */\n  this._currentExecution = {\n    actions: [],\n    dirty: [],\n    trigger: null\n  };\n\n  /**\n   * @type {Injector}\n   */\n  this._injector = injector;\n\n  /**\n   * @type EventBus\n   */\n  this._eventBus = eventBus;\n\n  /**\n   * @type { number }\n   */\n  this._uid = 1;\n  eventBus.on(['diagram.destroy', 'diagram.clear'], function () {\n    this.clear(false);\n  }, this);\n}\nCommandStack.$inject = ['eventBus', 'injector'];\n\n/**\n * Execute a command.\n *\n * @param {string} command The command to execute.\n * @param {CommandContext} context The context with which to execute the command.\n */\nCommandStack.prototype.execute = function (command, context) {\n  if (!command) {\n    throw new Error('command required');\n  }\n  this._currentExecution.trigger = 'execute';\n  const action = {\n    command: command,\n    context: context\n  };\n  this._pushAction(action);\n  this._internalExecute(action);\n  this._popAction();\n};\n\n/**\n * Check whether a command can be executed.\n *\n * Implementors may hook into the mechanism on two ways:\n *\n *   * in event listeners:\n *\n *     Users may prevent the execution via an event listener.\n *     It must prevent the default action for `commandStack.(<command>.)canExecute` events.\n *\n *   * in command handlers:\n *\n *     If the method {@link CommandHandler#canExecute} is implemented in a handler\n *     it will be called to figure out whether the execution is allowed.\n *\n * @param {string} command The command to execute.\n * @param {CommandContext} context The context with which to execute the command.\n *\n * @return {boolean} Whether the command can be executed with the given context.\n */\nCommandStack.prototype.canExecute = function (command, context) {\n  const action = {\n    command: command,\n    context: context\n  };\n  const handler = this._getHandler(command);\n  let result = this._fire(command, 'canExecute', action);\n\n  // handler#canExecute will only be called if no listener\n  // decided on a result already\n  if (result === undefined) {\n    if (!handler) {\n      return false;\n    }\n    if (handler.canExecute) {\n      result = handler.canExecute(context);\n    }\n  }\n  return result;\n};\n\n/**\n * Clear the command stack, erasing all undo / redo history.\n *\n * @param {boolean} [emit=true] Whether to fire an event. Defaults to `true`.\n */\nCommandStack.prototype.clear = function (emit) {\n  this._stack.length = 0;\n  this._stackIdx = -1;\n  if (emit !== false) {\n    this._fire('changed', {\n      trigger: 'clear'\n    });\n  }\n};\n\n/**\n * Undo last command(s)\n */\nCommandStack.prototype.undo = function () {\n  let action = this._getUndoAction(),\n    next;\n  if (action) {\n    this._currentExecution.trigger = 'undo';\n    this._pushAction(action);\n    while (action) {\n      this._internalUndo(action);\n      next = this._getUndoAction();\n      if (!next || next.id !== action.id) {\n        break;\n      }\n      action = next;\n    }\n    this._popAction();\n  }\n};\n\n/**\n * Redo last command(s)\n */\nCommandStack.prototype.redo = function () {\n  let action = this._getRedoAction(),\n    next;\n  if (action) {\n    this._currentExecution.trigger = 'redo';\n    this._pushAction(action);\n    while (action) {\n      this._internalExecute(action, true);\n      next = this._getRedoAction();\n      if (!next || next.id !== action.id) {\n        break;\n      }\n      action = next;\n    }\n    this._popAction();\n  }\n};\n\n/**\n * Register a handler instance with the command stack.\n *\n * @param {string} command Command to be executed.\n * @param {CommandHandler} handler Handler to execute the command.\n */\nCommandStack.prototype.register = function (command, handler) {\n  this._setHandler(command, handler);\n};\n\n/**\n * Register a handler type with the command stack  by instantiating it and\n * injecting its dependencies.\n *\n * @param {string} command Command to be executed.\n * @param {CommandHandlerConstructor} handlerCls Constructor to instantiate a {@link CommandHandler}.\n */\nCommandStack.prototype.registerHandler = function (command, handlerCls) {\n  if (!command || !handlerCls) {\n    throw new Error('command and handlerCls must be defined');\n  }\n  const handler = this._injector.instantiate(handlerCls);\n  this.register(command, handler);\n};\n\n/**\n * @return {boolean}\n */\nCommandStack.prototype.canUndo = function () {\n  return !!this._getUndoAction();\n};\n\n/**\n * @return {boolean}\n */\nCommandStack.prototype.canRedo = function () {\n  return !!this._getRedoAction();\n};\n\n// stack access  //////////////////////\n\nCommandStack.prototype._getRedoAction = function () {\n  return this._stack[this._stackIdx + 1];\n};\nCommandStack.prototype._getUndoAction = function () {\n  return this._stack[this._stackIdx];\n};\n\n// internal functionality //////////////////////\n\nCommandStack.prototype._internalUndo = function (action) {\n  const command = action.command,\n    context = action.context;\n  const handler = this._getHandler(command);\n\n  // guard against illegal nested command stack invocations\n  this._atomicDo(() => {\n    this._fire(command, 'revert', action);\n    if (handler.revert) {\n      this._markDirty(handler.revert(context));\n    }\n    this._revertedAction(action);\n    this._fire(command, 'reverted', action);\n  });\n};\nCommandStack.prototype._fire = function (command, qualifier, event) {\n  if (arguments.length < 3) {\n    event = qualifier;\n    qualifier = null;\n  }\n  const names = qualifier ? [command + '.' + qualifier, qualifier] : [command];\n  let result;\n  event = this._eventBus.createEvent(event);\n  for (const name of names) {\n    result = this._eventBus.fire('commandStack.' + name, event);\n    if (event.cancelBubble) {\n      break;\n    }\n  }\n  return result;\n};\nCommandStack.prototype._createId = function () {\n  return this._uid++;\n};\nCommandStack.prototype._atomicDo = function (fn) {\n  const execution = this._currentExecution;\n  execution.atomic = true;\n  try {\n    fn();\n  } finally {\n    execution.atomic = false;\n  }\n};\nCommandStack.prototype._internalExecute = function (action, redo) {\n  const command = action.command,\n    context = action.context;\n  const handler = this._getHandler(command);\n  if (!handler) {\n    throw new Error('no command handler registered for <' + command + '>');\n  }\n  this._pushAction(action);\n  if (!redo) {\n    this._fire(command, 'preExecute', action);\n    if (handler.preExecute) {\n      handler.preExecute(context);\n    }\n    this._fire(command, 'preExecuted', action);\n  }\n\n  // guard against illegal nested command stack invocations\n  this._atomicDo(() => {\n    this._fire(command, 'execute', action);\n    if (handler.execute) {\n      // actual execute + mark return results as dirty\n      this._markDirty(handler.execute(context));\n    }\n\n    // log to stack\n    this._executedAction(action, redo);\n    this._fire(command, 'executed', action);\n  });\n  if (!redo) {\n    this._fire(command, 'postExecute', action);\n    if (handler.postExecute) {\n      handler.postExecute(context);\n    }\n    this._fire(command, 'postExecuted', action);\n  }\n  this._popAction();\n};\nCommandStack.prototype._pushAction = function (action) {\n  const execution = this._currentExecution,\n    actions = execution.actions;\n  const baseAction = actions[0];\n  if (execution.atomic) {\n    throw new Error('illegal invocation in <execute> or <revert> phase (action: ' + action.command + ')');\n  }\n  if (!action.id) {\n    action.id = baseAction && baseAction.id || this._createId();\n  }\n  actions.push(action);\n};\nCommandStack.prototype._popAction = function () {\n  const execution = this._currentExecution,\n    trigger = execution.trigger,\n    actions = execution.actions,\n    dirty = execution.dirty;\n  actions.pop();\n  if (!actions.length) {\n    this._eventBus.fire('elements.changed', {\n      elements: uniqueBy('id', dirty.reverse())\n    });\n    dirty.length = 0;\n    this._fire('changed', {\n      trigger: trigger\n    });\n    execution.trigger = null;\n  }\n};\nCommandStack.prototype._markDirty = function (elements) {\n  const execution = this._currentExecution;\n  if (!elements) {\n    return;\n  }\n  elements = isArray(elements) ? elements : [elements];\n  execution.dirty = execution.dirty.concat(elements);\n};\nCommandStack.prototype._executedAction = function (action, redo) {\n  const stackIdx = ++this._stackIdx;\n  if (!redo) {\n    this._stack.splice(stackIdx, this._stack.length, action);\n  }\n};\nCommandStack.prototype._revertedAction = function (action) {\n  this._stackIdx--;\n};\nCommandStack.prototype._getHandler = function (command) {\n  return this._handlerMap[command];\n};\nCommandStack.prototype._setHandler = function (command, handler) {\n  if (!command || !handler) {\n    throw new Error('command and handler required');\n  }\n  if (this._handlerMap[command]) {\n    throw new Error('overriding handler for command <' + command + '>');\n  }\n  this._handlerMap[command] = handler;\n};","map":{"version":3,"names":["uniqueBy","isArray","CommandStack","eventBus","injector","_handlerMap","_stack","_stackIdx","_currentExecution","actions","dirty","trigger","_injector","_eventBus","_uid","on","clear","$inject","prototype","execute","command","context","Error","action","_pushAction","_internalExecute","_popAction","canExecute","handler","_getHandler","result","_fire","undefined","emit","length","undo","_getUndoAction","next","_internalUndo","id","redo","_getRedoAction","register","_setHandler","registerHandler","handlerCls","instantiate","canUndo","canRedo","_atomicDo","revert","_markDirty","_revertedAction","qualifier","event","arguments","names","createEvent","name","fire","cancelBubble","_createId","fn","execution","atomic","preExecute","_executedAction","postExecute","baseAction","push","pop","elements","reverse","concat","stackIdx","splice"],"sources":["/home/runner/work/sgex/sgex/node_modules/diagram-js/lib/command/CommandStack.js"],"sourcesContent":["import {\n  uniqueBy,\n  isArray\n} from 'min-dash';\n\n/**\n * @typedef {import('didi').Injector} Injector\n *\n * @typedef {import('../core/Types').ElementLike} ElementLike\n *\n * @typedef {import('../core/EventBus').default} EventBus\n * @typedef {import('./CommandHandler').default} CommandHandler\n *\n * @typedef { any } CommandContext\n * @typedef { {\n *   new (...args: any[]) : CommandHandler\n * } } CommandHandlerConstructor\n * @typedef { {\n *   [key: string]: CommandHandler;\n * } } CommandHandlerMap\n * @typedef { {\n *   command: string;\n *   context: any;\n *   id?: any;\n * } } CommandStackAction\n * @typedef { {\n *   actions: CommandStackAction[];\n *   dirty: ElementLike[];\n *   trigger: 'execute' | 'undo' | 'redo' | 'clear' | null;\n *   atomic?: boolean;\n * } } CurrentExecution\n */\n\n/**\n * A service that offers un- and redoable execution of commands.\n *\n * The command stack is responsible for executing modeling actions\n * in a un- and redoable manner. To do this it delegates the actual\n * command execution to {@link CommandHandler}s.\n *\n * Command handlers provide {@link CommandHandler#execute(ctx)} and\n * {@link CommandHandler#revert(ctx)} methods to un- and redo a command\n * identified by a command context.\n *\n *\n * ## Life-Cycle events\n *\n * In the process the command stack fires a number of life-cycle events\n * that other components to participate in the command execution.\n *\n *    * preExecute\n *    * preExecuted\n *    * execute\n *    * executed\n *    * postExecute\n *    * postExecuted\n *    * revert\n *    * reverted\n *\n * A special event is used for validating, whether a command can be\n * performed prior to its execution.\n *\n *    * canExecute\n *\n * Each of the events is fired as `commandStack.{eventName}` and\n * `commandStack.{commandName}.{eventName}`, respectively. This gives\n * components fine grained control on where to hook into.\n *\n * The event object fired transports `command`, the name of the\n * command and `context`, the command context.\n *\n *\n * ## Creating Command Handlers\n *\n * Command handlers should provide the {@link CommandHandler#execute(ctx)}\n * and {@link CommandHandler#revert(ctx)} methods to implement\n * redoing and undoing of a command.\n *\n * A command handler _must_ ensure undo is performed properly in order\n * not to break the undo chain. It must also return the shapes that\n * got changed during the `execute` and `revert` operations.\n *\n * Command handlers may execute other modeling operations (and thus\n * commands) in their `preExecute(d)` and `postExecute(d)` phases. The command\n * stack will properly group all commands together into a logical unit\n * that may be re- and undone atomically.\n *\n * Command handlers must not execute other commands from within their\n * core implementation (`execute`, `revert`).\n *\n *\n * ## Change Tracking\n *\n * During the execution of the CommandStack it will keep track of all\n * elements that have been touched during the command's execution.\n *\n * At the end of the CommandStack execution it will notify interested\n * components via an 'elements.changed' event with all the dirty\n * elements.\n *\n * The event can be picked up by components that are interested in the fact\n * that elements have been changed. One use case for this is updating\n * their graphical representation after moving / resizing or deletion.\n *\n * @see CommandHandler\n *\n * @param {EventBus} eventBus\n * @param {Injector} injector\n */\nexport default function CommandStack(eventBus, injector) {\n\n  /**\n   * A map of all registered command handlers.\n   *\n   * @type {CommandHandlerMap}\n   */\n  this._handlerMap = {};\n\n  /**\n   * A stack containing all re/undoable actions on the diagram\n   *\n   * @type {CommandStackAction[]}\n   */\n  this._stack = [];\n\n  /**\n   * The current index on the stack\n   *\n   * @type {number}\n   */\n  this._stackIdx = -1;\n\n  /**\n   * Current active commandStack execution\n   *\n   * @type {CurrentExecution}\n   */\n  this._currentExecution = {\n    actions: [],\n    dirty: [],\n    trigger: null\n  };\n\n  /**\n   * @type {Injector}\n   */\n  this._injector = injector;\n\n  /**\n   * @type EventBus\n   */\n  this._eventBus = eventBus;\n\n  /**\n   * @type { number }\n   */\n  this._uid = 1;\n\n  eventBus.on([\n    'diagram.destroy',\n    'diagram.clear'\n  ], function() {\n    this.clear(false);\n  }, this);\n}\n\nCommandStack.$inject = [ 'eventBus', 'injector' ];\n\n\n/**\n * Execute a command.\n *\n * @param {string} command The command to execute.\n * @param {CommandContext} context The context with which to execute the command.\n */\nCommandStack.prototype.execute = function(command, context) {\n  if (!command) {\n    throw new Error('command required');\n  }\n\n  this._currentExecution.trigger = 'execute';\n\n  const action = { command: command, context: context };\n\n  this._pushAction(action);\n  this._internalExecute(action);\n  this._popAction();\n};\n\n\n/**\n * Check whether a command can be executed.\n *\n * Implementors may hook into the mechanism on two ways:\n *\n *   * in event listeners:\n *\n *     Users may prevent the execution via an event listener.\n *     It must prevent the default action for `commandStack.(<command>.)canExecute` events.\n *\n *   * in command handlers:\n *\n *     If the method {@link CommandHandler#canExecute} is implemented in a handler\n *     it will be called to figure out whether the execution is allowed.\n *\n * @param {string} command The command to execute.\n * @param {CommandContext} context The context with which to execute the command.\n *\n * @return {boolean} Whether the command can be executed with the given context.\n */\nCommandStack.prototype.canExecute = function(command, context) {\n\n  const action = { command: command, context: context };\n\n  const handler = this._getHandler(command);\n\n  let result = this._fire(command, 'canExecute', action);\n\n  // handler#canExecute will only be called if no listener\n  // decided on a result already\n  if (result === undefined) {\n    if (!handler) {\n      return false;\n    }\n\n    if (handler.canExecute) {\n      result = handler.canExecute(context);\n    }\n  }\n\n  return result;\n};\n\n\n/**\n * Clear the command stack, erasing all undo / redo history.\n *\n * @param {boolean} [emit=true] Whether to fire an event. Defaults to `true`.\n */\nCommandStack.prototype.clear = function(emit) {\n  this._stack.length = 0;\n  this._stackIdx = -1;\n\n  if (emit !== false) {\n    this._fire('changed', { trigger: 'clear' });\n  }\n};\n\n\n/**\n * Undo last command(s)\n */\nCommandStack.prototype.undo = function() {\n  let action = this._getUndoAction(),\n      next;\n\n  if (action) {\n    this._currentExecution.trigger = 'undo';\n\n    this._pushAction(action);\n\n    while (action) {\n      this._internalUndo(action);\n      next = this._getUndoAction();\n\n      if (!next || next.id !== action.id) {\n        break;\n      }\n\n      action = next;\n    }\n\n    this._popAction();\n  }\n};\n\n\n/**\n * Redo last command(s)\n */\nCommandStack.prototype.redo = function() {\n  let action = this._getRedoAction(),\n      next;\n\n  if (action) {\n    this._currentExecution.trigger = 'redo';\n\n    this._pushAction(action);\n\n    while (action) {\n      this._internalExecute(action, true);\n      next = this._getRedoAction();\n\n      if (!next || next.id !== action.id) {\n        break;\n      }\n\n      action = next;\n    }\n\n    this._popAction();\n  }\n};\n\n\n/**\n * Register a handler instance with the command stack.\n *\n * @param {string} command Command to be executed.\n * @param {CommandHandler} handler Handler to execute the command.\n */\nCommandStack.prototype.register = function(command, handler) {\n  this._setHandler(command, handler);\n};\n\n\n/**\n * Register a handler type with the command stack  by instantiating it and\n * injecting its dependencies.\n *\n * @param {string} command Command to be executed.\n * @param {CommandHandlerConstructor} handlerCls Constructor to instantiate a {@link CommandHandler}.\n */\nCommandStack.prototype.registerHandler = function(command, handlerCls) {\n\n  if (!command || !handlerCls) {\n    throw new Error('command and handlerCls must be defined');\n  }\n\n  const handler = this._injector.instantiate(handlerCls);\n  this.register(command, handler);\n};\n\n/**\n * @return {boolean}\n */\nCommandStack.prototype.canUndo = function() {\n  return !!this._getUndoAction();\n};\n\n/**\n * @return {boolean}\n */\nCommandStack.prototype.canRedo = function() {\n  return !!this._getRedoAction();\n};\n\n// stack access  //////////////////////\n\nCommandStack.prototype._getRedoAction = function() {\n  return this._stack[this._stackIdx + 1];\n};\n\n\nCommandStack.prototype._getUndoAction = function() {\n  return this._stack[this._stackIdx];\n};\n\n\n// internal functionality //////////////////////\n\nCommandStack.prototype._internalUndo = function(action) {\n  const command = action.command,\n        context = action.context;\n\n  const handler = this._getHandler(command);\n\n  // guard against illegal nested command stack invocations\n  this._atomicDo(() => {\n    this._fire(command, 'revert', action);\n\n    if (handler.revert) {\n      this._markDirty(handler.revert(context));\n    }\n\n    this._revertedAction(action);\n\n    this._fire(command, 'reverted', action);\n  });\n};\n\n\nCommandStack.prototype._fire = function(command, qualifier, event) {\n  if (arguments.length < 3) {\n    event = qualifier;\n    qualifier = null;\n  }\n\n  const names = qualifier ? [ command + '.' + qualifier, qualifier ] : [ command ];\n  let result;\n\n  event = this._eventBus.createEvent(event);\n\n  for (const name of names) {\n    result = this._eventBus.fire('commandStack.' + name, event);\n\n    if (event.cancelBubble) {\n      break;\n    }\n  }\n\n  return result;\n};\n\nCommandStack.prototype._createId = function() {\n  return this._uid++;\n};\n\nCommandStack.prototype._atomicDo = function(fn) {\n\n  const execution = this._currentExecution;\n\n  execution.atomic = true;\n\n  try {\n    fn();\n  } finally {\n    execution.atomic = false;\n  }\n};\n\nCommandStack.prototype._internalExecute = function(action, redo) {\n  const command = action.command,\n        context = action.context;\n\n  const handler = this._getHandler(command);\n\n  if (!handler) {\n    throw new Error('no command handler registered for <' + command + '>');\n  }\n\n  this._pushAction(action);\n\n  if (!redo) {\n    this._fire(command, 'preExecute', action);\n\n    if (handler.preExecute) {\n      handler.preExecute(context);\n    }\n\n    this._fire(command, 'preExecuted', action);\n  }\n\n  // guard against illegal nested command stack invocations\n  this._atomicDo(() => {\n\n    this._fire(command, 'execute', action);\n\n    if (handler.execute) {\n\n      // actual execute + mark return results as dirty\n      this._markDirty(handler.execute(context));\n    }\n\n    // log to stack\n    this._executedAction(action, redo);\n\n    this._fire(command, 'executed', action);\n  });\n\n  if (!redo) {\n    this._fire(command, 'postExecute', action);\n\n    if (handler.postExecute) {\n      handler.postExecute(context);\n    }\n\n    this._fire(command, 'postExecuted', action);\n  }\n\n  this._popAction();\n};\n\n\nCommandStack.prototype._pushAction = function(action) {\n\n  const execution = this._currentExecution,\n        actions = execution.actions;\n\n  const baseAction = actions[0];\n\n  if (execution.atomic) {\n    throw new Error('illegal invocation in <execute> or <revert> phase (action: ' + action.command + ')');\n  }\n\n  if (!action.id) {\n    action.id = (baseAction && baseAction.id) || this._createId();\n  }\n\n  actions.push(action);\n};\n\n\nCommandStack.prototype._popAction = function() {\n  const execution = this._currentExecution,\n        trigger = execution.trigger,\n        actions = execution.actions,\n        dirty = execution.dirty;\n\n  actions.pop();\n\n  if (!actions.length) {\n    this._eventBus.fire('elements.changed', { elements: uniqueBy('id', dirty.reverse()) });\n\n    dirty.length = 0;\n\n    this._fire('changed', { trigger: trigger });\n\n    execution.trigger = null;\n  }\n};\n\n\nCommandStack.prototype._markDirty = function(elements) {\n  const execution = this._currentExecution;\n\n  if (!elements) {\n    return;\n  }\n\n  elements = isArray(elements) ? elements : [ elements ];\n\n  execution.dirty = execution.dirty.concat(elements);\n};\n\n\nCommandStack.prototype._executedAction = function(action, redo) {\n  const stackIdx = ++this._stackIdx;\n\n  if (!redo) {\n    this._stack.splice(stackIdx, this._stack.length, action);\n  }\n};\n\n\nCommandStack.prototype._revertedAction = function(action) {\n  this._stackIdx--;\n};\n\n\nCommandStack.prototype._getHandler = function(command) {\n  return this._handlerMap[command];\n};\n\nCommandStack.prototype._setHandler = function(command, handler) {\n  if (!command || !handler) {\n    throw new Error('command and handler required');\n  }\n\n  if (this._handlerMap[command]) {\n    throw new Error('overriding handler for command <' + command + '>');\n  }\n\n  this._handlerMap[command] = handler;\n};\n"],"mappings":"AAAA,SACEA,QAAQ,EACRC,OAAO,QACF,UAAU;;AAEjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,SAASC,YAAYA,CAACC,QAAQ,EAAEC,QAAQ,EAAE;EAEvD;AACF;AACA;AACA;AACA;EACE,IAAI,CAACC,WAAW,GAAG,CAAC,CAAC;;EAErB;AACF;AACA;AACA;AACA;EACE,IAAI,CAACC,MAAM,GAAG,EAAE;;EAEhB;AACF;AACA;AACA;AACA;EACE,IAAI,CAACC,SAAS,GAAG,CAAC,CAAC;;EAEnB;AACF;AACA;AACA;AACA;EACE,IAAI,CAACC,iBAAiB,GAAG;IACvBC,OAAO,EAAE,EAAE;IACXC,KAAK,EAAE,EAAE;IACTC,OAAO,EAAE;EACX,CAAC;;EAED;AACF;AACA;EACE,IAAI,CAACC,SAAS,GAAGR,QAAQ;;EAEzB;AACF;AACA;EACE,IAAI,CAACS,SAAS,GAAGV,QAAQ;;EAEzB;AACF;AACA;EACE,IAAI,CAACW,IAAI,GAAG,CAAC;EAEbX,QAAQ,CAACY,EAAE,CAAC,CACV,iBAAiB,EACjB,eAAe,CAChB,EAAE,YAAW;IACZ,IAAI,CAACC,KAAK,CAAC,KAAK,CAAC;EACnB,CAAC,EAAE,IAAI,CAAC;AACV;AAEAd,YAAY,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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}