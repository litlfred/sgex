{"ast":null,"code":"import { forEach } from 'min-dash';\nimport { is } from '../../../util/ModelUtil';\nimport { isExpanded, isHorizontal } from '../../../util/DiUtil';\nimport { GROUP_MIN_DIMENSIONS, LANE_MIN_DIMENSIONS, VERTICAL_LANE_MIN_DIMENSIONS, PARTICIPANT_MIN_DIMENSIONS, VERTICAL_PARTICIPANT_MIN_DIMENSIONS, SUB_PROCESS_MIN_DIMENSIONS, TEXT_ANNOTATION_MIN_DIMENSIONS } from './ResizeBehavior';\nimport { getChildLanes } from '../util/LaneUtil';\n\n/**\n * @typedef {import('diagram-js/lib/core/EventBus').default} EventBus\n *\n * @typedef {import('../../../model/Types').Shape} Shape\n */\n\nvar max = Math.max;\n\n/**\n * @param {EventBus} eventBus\n */\nexport default function SpaceToolBehavior(eventBus) {\n  eventBus.on('spaceTool.getMinDimensions', function (context) {\n    var shapes = context.shapes,\n      axis = context.axis,\n      start = context.start,\n      minDimensions = {};\n    forEach(shapes, function (shape) {\n      var id = shape.id;\n      if (is(shape, 'bpmn:Participant')) {\n        minDimensions[id] = getParticipantMinDimensions(shape, axis, start);\n      }\n      if (is(shape, 'bpmn:Lane')) {\n        minDimensions[id] = isHorizontal(shape) ? LANE_MIN_DIMENSIONS : VERTICAL_LANE_MIN_DIMENSIONS;\n      }\n      if (is(shape, 'bpmn:SubProcess') && isExpanded(shape)) {\n        minDimensions[id] = SUB_PROCESS_MIN_DIMENSIONS;\n      }\n      if (is(shape, 'bpmn:TextAnnotation')) {\n        minDimensions[id] = TEXT_ANNOTATION_MIN_DIMENSIONS;\n      }\n      if (is(shape, 'bpmn:Group')) {\n        minDimensions[id] = GROUP_MIN_DIMENSIONS;\n      }\n    });\n    return minDimensions;\n  });\n}\nSpaceToolBehavior.$inject = ['eventBus'];\n\n// helpers //////////\nfunction isHorizontalAxis(axis) {\n  return axis === 'x';\n}\n\n/**\n * Get minimum dimensions for participant taking lanes into account.\n *\n * @param {Shape} participant\n * @param {Axis} axis\n * @param {number} start\n *\n * @return {number}\n */\nfunction getParticipantMinDimensions(participant, axis, start) {\n  var isHorizontalLane = isHorizontal(participant);\n  if (!hasChildLanes(participant)) {\n    return isHorizontalLane ? PARTICIPANT_MIN_DIMENSIONS : VERTICAL_PARTICIPANT_MIN_DIMENSIONS;\n  }\n  var isHorizontalResize = isHorizontalAxis(axis);\n  var minDimensions = {};\n  if (isHorizontalResize) {\n    if (isHorizontalLane) {\n      minDimensions = PARTICIPANT_MIN_DIMENSIONS;\n    } else {\n      minDimensions = {\n        width: getParticipantMinWidth(participant, start, isHorizontalResize),\n        height: VERTICAL_PARTICIPANT_MIN_DIMENSIONS.height\n      };\n    }\n  } else {\n    if (isHorizontalLane) {\n      minDimensions = {\n        width: PARTICIPANT_MIN_DIMENSIONS.width,\n        height: getParticipantMinHeight(participant, start, isHorizontalResize)\n      };\n    } else {\n      minDimensions = VERTICAL_PARTICIPANT_MIN_DIMENSIONS;\n    }\n  }\n  return minDimensions;\n}\n\n/**\n * Get minimum height for participant taking lanes into account.\n *\n * @param {Shape} participant\n * @param {number} start\n * @param {boolean} isHorizontalResize\n *\n * @return {number}\n */\nfunction getParticipantMinHeight(participant, start, isHorizontalResize) {\n  var lanesMinHeight;\n  lanesMinHeight = getLanesMinHeight(participant, start, isHorizontalResize);\n  return max(PARTICIPANT_MIN_DIMENSIONS.height, lanesMinHeight);\n}\n\n/**\n * Get minimum width for participant taking lanes into account.\n *\n * @param {Shape} participant\n * @param {number} start\n * @param {boolean} isHorizontalResize\n *\n * @return {number}\n */\nfunction getParticipantMinWidth(participant, start, isHorizontalResize) {\n  var lanesMinWidth;\n  lanesMinWidth = getLanesMinWidth(participant, start, isHorizontalResize);\n  return max(VERTICAL_PARTICIPANT_MIN_DIMENSIONS.width, lanesMinWidth);\n}\nfunction hasChildLanes(element) {\n  return !!getChildLanes(element).length;\n}\nfunction getLanesMinHeight(participant, resizeStart, isHorizontalResize) {\n  var lanes = getChildLanes(participant),\n    resizedLane;\n\n  // find the nested lane which is currently resized\n  resizedLane = findResizedLane(lanes, resizeStart, isHorizontalResize);\n\n  // resized lane cannot shrink below the minimum height\n  // but remaining lanes' dimensions are kept intact\n  return participant.height - resizedLane.height + LANE_MIN_DIMENSIONS.height;\n}\nfunction getLanesMinWidth(participant, resizeStart, isHorizontalResize) {\n  var lanes = getChildLanes(participant),\n    resizedLane;\n\n  // find the nested lane which is currently resized\n  resizedLane = findResizedLane(lanes, resizeStart, isHorizontalResize);\n\n  // resized lane cannot shrink below the minimum width\n  // but remaining lanes' dimensions are kept intact\n  return participant.width - resizedLane.width + VERTICAL_LANE_MIN_DIMENSIONS.width;\n}\n\n/**\n * Find nested lane which is currently resized.\n *\n * @param {Shape[]} lanes\n * @param {number} resizeStart\n * @param {boolean} isHorizontalResize\n *\n * @return {Shape}\n */\nfunction findResizedLane(lanes, resizeStart, isHorizontalResize) {\n  var i, lane, childLanes;\n  for (i = 0; i < lanes.length; i++) {\n    lane = lanes[i];\n\n    // resizing current lane or a lane nested\n    if (!isHorizontalResize && resizeStart >= lane.y && resizeStart <= lane.y + lane.height || isHorizontalResize && resizeStart >= lane.x && resizeStart <= lane.x + lane.width) {\n      childLanes = getChildLanes(lane);\n\n      // a nested lane is resized\n      if (childLanes.length) {\n        return findResizedLane(childLanes, resizeStart, isHorizontalResize);\n      }\n\n      // current lane is the resized one\n      return lane;\n    }\n  }\n}","map":{"version":3,"names":["forEach","is","isExpanded","isHorizontal","GROUP_MIN_DIMENSIONS","LANE_MIN_DIMENSIONS","VERTICAL_LANE_MIN_DIMENSIONS","PARTICIPANT_MIN_DIMENSIONS","VERTICAL_PARTICIPANT_MIN_DIMENSIONS","SUB_PROCESS_MIN_DIMENSIONS","TEXT_ANNOTATION_MIN_DIMENSIONS","getChildLanes","max","Math","SpaceToolBehavior","eventBus","on","context","shapes","axis","start","minDimensions","shape","id","getParticipantMinDimensions","$inject","isHorizontalAxis","participant","isHorizontalLane","hasChildLanes","isHorizontalResize","width","getParticipantMinWidth","height","getParticipantMinHeight","lanesMinHeight","getLanesMinHeight","lanesMinWidth","getLanesMinWidth","element","length","resizeStart","lanes","resizedLane","findResizedLane","i","lane","childLanes","y","x"],"sources":["/home/runner/work/sgex/sgex/node_modules/bpmn-js/lib/features/modeling/behavior/SpaceToolBehavior.js"],"sourcesContent":["import { forEach } from 'min-dash';\n\nimport { is } from '../../../util/ModelUtil';\n\nimport {\n  isExpanded,\n  isHorizontal\n} from '../../../util/DiUtil';\n\nimport {\n  GROUP_MIN_DIMENSIONS,\n  LANE_MIN_DIMENSIONS,\n  VERTICAL_LANE_MIN_DIMENSIONS,\n  PARTICIPANT_MIN_DIMENSIONS,\n  VERTICAL_PARTICIPANT_MIN_DIMENSIONS,\n  SUB_PROCESS_MIN_DIMENSIONS,\n  TEXT_ANNOTATION_MIN_DIMENSIONS\n} from './ResizeBehavior';\n\nimport { getChildLanes } from '../util/LaneUtil';\n\n/**\n * @typedef {import('diagram-js/lib/core/EventBus').default} EventBus\n *\n * @typedef {import('../../../model/Types').Shape} Shape\n */\n\nvar max = Math.max;\n\n/**\n * @param {EventBus} eventBus\n */\nexport default function SpaceToolBehavior(eventBus) {\n  eventBus.on('spaceTool.getMinDimensions', function(context) {\n    var shapes = context.shapes,\n        axis = context.axis,\n        start = context.start,\n        minDimensions = {};\n\n    forEach(shapes, function(shape) {\n      var id = shape.id;\n\n      if (is(shape, 'bpmn:Participant')) {\n        minDimensions[ id ] = getParticipantMinDimensions(shape, axis, start);\n      }\n\n      if (is(shape, 'bpmn:Lane')) {\n        minDimensions[ id ] = isHorizontal(shape) ? LANE_MIN_DIMENSIONS : VERTICAL_LANE_MIN_DIMENSIONS;\n      }\n\n      if (is(shape, 'bpmn:SubProcess') && isExpanded(shape)) {\n        minDimensions[ id ] = SUB_PROCESS_MIN_DIMENSIONS;\n      }\n\n      if (is(shape, 'bpmn:TextAnnotation')) {\n        minDimensions[ id ] = TEXT_ANNOTATION_MIN_DIMENSIONS;\n      }\n\n      if (is(shape, 'bpmn:Group')) {\n        minDimensions[ id ] = GROUP_MIN_DIMENSIONS;\n      }\n    });\n\n    return minDimensions;\n  });\n}\n\nSpaceToolBehavior.$inject = [ 'eventBus' ];\n\n\n// helpers //////////\nfunction isHorizontalAxis(axis) {\n  return axis === 'x';\n}\n\n/**\n * Get minimum dimensions for participant taking lanes into account.\n *\n * @param {Shape} participant\n * @param {Axis} axis\n * @param {number} start\n *\n * @return {number}\n */\nfunction getParticipantMinDimensions(participant, axis, start) {\n  var isHorizontalLane = isHorizontal(participant);\n\n  if (!hasChildLanes(participant)) {\n    return isHorizontalLane ? PARTICIPANT_MIN_DIMENSIONS : VERTICAL_PARTICIPANT_MIN_DIMENSIONS;\n  }\n\n  var isHorizontalResize = isHorizontalAxis(axis);\n  var minDimensions = {};\n\n  if (isHorizontalResize) {\n    if (isHorizontalLane) {\n      minDimensions = PARTICIPANT_MIN_DIMENSIONS;\n    } else {\n      minDimensions = {\n        width: getParticipantMinWidth(participant, start, isHorizontalResize),\n        height: VERTICAL_PARTICIPANT_MIN_DIMENSIONS.height\n      };\n    }\n\n  } else {\n    if (isHorizontalLane) {\n      minDimensions = {\n        width: PARTICIPANT_MIN_DIMENSIONS.width,\n        height: getParticipantMinHeight(participant, start, isHorizontalResize)\n      };\n    } else {\n      minDimensions = VERTICAL_PARTICIPANT_MIN_DIMENSIONS;\n    }\n  }\n\n  return minDimensions;\n}\n\n/**\n * Get minimum height for participant taking lanes into account.\n *\n * @param {Shape} participant\n * @param {number} start\n * @param {boolean} isHorizontalResize\n *\n * @return {number}\n */\nfunction getParticipantMinHeight(participant, start, isHorizontalResize) {\n  var lanesMinHeight;\n  lanesMinHeight = getLanesMinHeight(participant, start, isHorizontalResize);\n  return max(PARTICIPANT_MIN_DIMENSIONS.height, lanesMinHeight);\n}\n\n/**\n * Get minimum width for participant taking lanes into account.\n *\n * @param {Shape} participant\n * @param {number} start\n * @param {boolean} isHorizontalResize\n *\n * @return {number}\n */\nfunction getParticipantMinWidth(participant, start, isHorizontalResize) {\n  var lanesMinWidth;\n  lanesMinWidth = getLanesMinWidth(participant, start, isHorizontalResize);\n  return max(VERTICAL_PARTICIPANT_MIN_DIMENSIONS.width, lanesMinWidth);\n}\n\nfunction hasChildLanes(element) {\n  return !!getChildLanes(element).length;\n}\n\nfunction getLanesMinHeight(participant, resizeStart, isHorizontalResize) {\n  var lanes = getChildLanes(participant),\n      resizedLane;\n\n  // find the nested lane which is currently resized\n  resizedLane = findResizedLane(lanes, resizeStart, isHorizontalResize);\n\n  // resized lane cannot shrink below the minimum height\n  // but remaining lanes' dimensions are kept intact\n  return participant.height - resizedLane.height + LANE_MIN_DIMENSIONS.height;\n}\n\nfunction getLanesMinWidth(participant, resizeStart, isHorizontalResize) {\n  var lanes = getChildLanes(participant),\n      resizedLane;\n\n  // find the nested lane which is currently resized\n  resizedLane = findResizedLane(lanes, resizeStart, isHorizontalResize);\n\n  // resized lane cannot shrink below the minimum width\n  // but remaining lanes' dimensions are kept intact\n  return participant.width - resizedLane.width + VERTICAL_LANE_MIN_DIMENSIONS.width;\n}\n\n/**\n * Find nested lane which is currently resized.\n *\n * @param {Shape[]} lanes\n * @param {number} resizeStart\n * @param {boolean} isHorizontalResize\n *\n * @return {Shape}\n */\nfunction findResizedLane(lanes, resizeStart, isHorizontalResize) {\n  var i, lane, childLanes;\n\n  for (i = 0; i < lanes.length; i++) {\n    lane = lanes[i];\n\n    // resizing current lane or a lane nested\n    if (!isHorizontalResize && resizeStart >= lane.y && resizeStart <= lane.y + lane.height ||\n        isHorizontalResize && resizeStart >= lane.x && resizeStart <= lane.x + lane.width) {\n\n      childLanes = getChildLanes(lane);\n\n      // a nested lane is resized\n      if (childLanes.length) {\n        return findResizedLane(childLanes, resizeStart, isHorizontalResize);\n      }\n\n      // current lane is the resized one\n      return lane;\n    }\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}