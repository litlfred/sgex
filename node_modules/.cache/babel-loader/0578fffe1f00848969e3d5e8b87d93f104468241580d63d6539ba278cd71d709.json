{"ast":null,"code":"import { assign, find, forEach, isArray, isNumber, map, matchPattern, omit, sortBy } from 'min-dash';\nimport { getBBox, getParents } from '../../util/Elements';\nimport { eachElement } from '../../util/Elements';\nimport { isConnection, isLabel } from '../../util/ModelUtil';\n\n/**\n * @typedef {import('../../core/Types').ElementLike} Element\n * @typedef {import('../../core/Types').ShapeLike} Shape\n *\n * @typedef {import('../../util/Types').Point} Point\n *\n * @typedef {import('../../core/Canvas').default} Canvas\n * @typedef {import('../clipboard/Clipboard').default} Clipboard\n * @typedef {import('../create/Create').default} Create\n * @typedef {import('../../core/ElementFactory').default} ElementFactory\n * @typedef {import('../../core/EventBus').default} EventBus\n * @typedef {import('../modeling/Modeling').default} Modeling\n * @typedef {import('../mouse/Mouse').default} Mouse\n * @typedef {import('../rules/Rules').default} Rules\n */\n\n/**\n * @typedef { (event: { elements: Element[] }) => Element[]|boolean } CopyPasteCanCopyElementsListener\n */\n\n/**\n * @typedef { (event: { descriptor: any, element: Element, elements: Element[] }) => void } CopyPasteCopyElementListener\n */\n\n/**\n * @typedef { (event: { element: Element, children: Element[] }) => void } CopyPasteCreateTreeListener\n */\n\n/**\n * @typedef { (event: { elements: any, tree: any }) => void } CopyPasteElementsCopiedListener\n */\n\n/**\n * @typedef { (event: { cache: any, descriptor: any }) => void } CopyPastePasteElementListener\n */\n\n/**\n * @typedef { (event: { hints: any }) => void } CopyPastePasteElementsListener\n */\n\n/**\n * Copy and paste elements.\n *\n * @param {Canvas} canvas\n * @param {Create} create\n * @param {Clipboard} clipboard\n * @param {ElementFactory} elementFactory\n * @param {EventBus} eventBus\n * @param {Modeling} modeling\n * @param {Mouse} mouse\n * @param {Rules} rules\n */\nexport default function CopyPaste(canvas, create, clipboard, elementFactory, eventBus, modeling, mouse, rules) {\n  this._canvas = canvas;\n  this._create = create;\n  this._clipboard = clipboard;\n  this._elementFactory = elementFactory;\n  this._eventBus = eventBus;\n  this._modeling = modeling;\n  this._mouse = mouse;\n  this._rules = rules;\n  eventBus.on('copyPaste.copyElement', function (context) {\n    var descriptor = context.descriptor,\n      element = context.element,\n      elements = context.elements;\n\n    // default priority (priority = 1)\n    descriptor.priority = 1;\n    descriptor.id = element.id;\n    var parentCopied = find(elements, function (e) {\n      return e === element.parent;\n    });\n\n    // do NOT reference parent if parent wasn't copied\n    if (parentCopied) {\n      descriptor.parent = element.parent.id;\n    }\n\n    // attachers (priority = 2)\n    if (isAttacher(element)) {\n      descriptor.priority = 2;\n      descriptor.host = element.host.id;\n    }\n\n    // connections (priority = 3)\n    if (isConnection(element)) {\n      descriptor.priority = 3;\n      descriptor.source = element.source.id;\n      descriptor.target = element.target.id;\n      descriptor.waypoints = copyWaypoints(element);\n    }\n\n    // labels (priority = 4)\n    if (isLabel(element)) {\n      descriptor.priority = 4;\n      descriptor.labelTarget = element.labelTarget.id;\n    }\n    forEach(['x', 'y', 'width', 'height'], function (property) {\n      if (isNumber(element[property])) {\n        descriptor[property] = element[property];\n      }\n    });\n    descriptor.hidden = element.hidden;\n    descriptor.collapsed = element.collapsed;\n  });\n  eventBus.on('copyPaste.pasteElements', function (context) {\n    var hints = context.hints;\n    assign(hints, {\n      createElementsBehavior: false\n    });\n  });\n}\nCopyPaste.$inject = ['canvas', 'create', 'clipboard', 'elementFactory', 'eventBus', 'modeling', 'mouse', 'rules'];\n\n/**\n * Copy elements.\n *\n * @param {Element[]} elements\n *\n * @return {Object}\n */\nCopyPaste.prototype.copy = function (elements) {\n  var allowed, tree;\n  if (!isArray(elements)) {\n    elements = elements ? [elements] : [];\n  }\n  allowed = this._eventBus.fire('copyPaste.canCopyElements', {\n    elements: elements\n  });\n  if (allowed === false) {\n    tree = {};\n  } else {\n    tree = this.createTree(isArray(allowed) ? allowed : elements);\n  }\n\n  // we set an empty tree, selection of elements\n  // to copy was empty.\n  this._clipboard.set(tree);\n  this._eventBus.fire('copyPaste.elementsCopied', {\n    elements: elements,\n    tree: tree\n  });\n  return tree;\n};\n\n/**\n * Paste elements.\n *\n * @param {Object} [context]\n * @param {Shape} [context.element] The optional parent.\n * @param {Point} [context.point] The optional position.\n * @param {Object} [context.hints] The optional hints.\n */\nCopyPaste.prototype.paste = function (context) {\n  var tree = this._clipboard.get();\n  if (this._clipboard.isEmpty()) {\n    return;\n  }\n  var hints = context && context.hints || {};\n  this._eventBus.fire('copyPaste.pasteElements', {\n    hints: hints\n  });\n  var elements = this._createElements(tree);\n\n  // paste directly\n  if (context && context.element && context.point) {\n    return this._paste(elements, context.element, context.point, hints);\n  }\n  this._create.start(this._mouse.getLastMoveEvent(), elements, {\n    hints: hints || {}\n  });\n};\n\n/**\n * Paste elements directly.\n *\n * @param {Element[]} elements\n * @param {Shape} target\n * @param {Point} position\n * @param {Object} [hints]\n */\nCopyPaste.prototype._paste = function (elements, target, position, hints) {\n  // make sure each element has x and y\n  forEach(elements, function (element) {\n    if (!isNumber(element.x)) {\n      element.x = 0;\n    }\n    if (!isNumber(element.y)) {\n      element.y = 0;\n    }\n  });\n  var bbox = getBBox(elements);\n\n  // center elements around cursor\n  forEach(elements, function (element) {\n    if (isConnection(element)) {\n      element.waypoints = map(element.waypoints, function (waypoint) {\n        return {\n          x: waypoint.x - bbox.x - bbox.width / 2,\n          y: waypoint.y - bbox.y - bbox.height / 2\n        };\n      });\n    }\n    assign(element, {\n      x: element.x - bbox.x - bbox.width / 2,\n      y: element.y - bbox.y - bbox.height / 2\n    });\n  });\n  return this._modeling.createElements(elements, position, target, assign({}, hints));\n};\n\n/**\n * Create elements from tree.\n */\nCopyPaste.prototype._createElements = function (tree) {\n  var self = this;\n  var eventBus = this._eventBus;\n  var cache = {};\n  var elements = [];\n  forEach(tree, function (branch, depth) {\n    depth = parseInt(depth, 10);\n\n    // sort by priority\n    branch = sortBy(branch, 'priority');\n    forEach(branch, function (descriptor) {\n      // remove priority\n      var attrs = assign({}, omit(descriptor, ['priority']));\n      if (cache[descriptor.parent]) {\n        attrs.parent = cache[descriptor.parent];\n      } else {\n        delete attrs.parent;\n      }\n      eventBus.fire('copyPaste.pasteElement', {\n        cache: cache,\n        descriptor: attrs\n      });\n      var element;\n      if (isConnection(attrs)) {\n        attrs.source = cache[descriptor.source];\n        attrs.target = cache[descriptor.target];\n        element = cache[descriptor.id] = self.createConnection(attrs);\n        elements.push(element);\n        return;\n      }\n      if (isLabel(attrs)) {\n        attrs.labelTarget = cache[attrs.labelTarget];\n        element = cache[descriptor.id] = self.createLabel(attrs);\n        elements.push(element);\n        return;\n      }\n      if (attrs.host) {\n        attrs.host = cache[attrs.host];\n      }\n      element = cache[descriptor.id] = self.createShape(attrs);\n      elements.push(element);\n    });\n  });\n  return elements;\n};\nCopyPaste.prototype.createConnection = function (attrs) {\n  var connection = this._elementFactory.createConnection(omit(attrs, ['id']));\n  return connection;\n};\nCopyPaste.prototype.createLabel = function (attrs) {\n  var label = this._elementFactory.createLabel(omit(attrs, ['id']));\n  return label;\n};\nCopyPaste.prototype.createShape = function (attrs) {\n  var shape = this._elementFactory.createShape(omit(attrs, ['id']));\n  return shape;\n};\n\n/**\n * Check wether element has relations to other elements e.g. attachers, labels and connections.\n *\n * @param {Object} element\n * @param {Element[]} elements\n *\n * @return {boolean}\n */\nCopyPaste.prototype.hasRelations = function (element, elements) {\n  var labelTarget, source, target;\n  if (isConnection(element)) {\n    source = find(elements, matchPattern({\n      id: element.source.id\n    }));\n    target = find(elements, matchPattern({\n      id: element.target.id\n    }));\n    if (!source || !target) {\n      return false;\n    }\n  }\n  if (isLabel(element)) {\n    labelTarget = find(elements, matchPattern({\n      id: element.labelTarget.id\n    }));\n    if (!labelTarget) {\n      return false;\n    }\n  }\n  return true;\n};\n\n/**\n * Create a tree-like structure from elements.\n *\n * @example\n *\n * ```javascript\n * tree: {\n *  0: [\n *    { id: 'Shape_1', priority: 1, ... },\n *    { id: 'Shape_2', priority: 1, ... },\n *    { id: 'Connection_1', source: 'Shape_1', target: 'Shape_2', priority: 3, ... },\n *    ...\n *  ],\n *  1: [\n *    { id: 'Shape_3', parent: 'Shape1', priority: 1, ... },\n *    ...\n *  ]\n * };\n * ```\n *\n * @param {Element[]} elements\n *\n * @return {Object}\n */\nCopyPaste.prototype.createTree = function (elements) {\n  var rules = this._rules,\n    self = this;\n  var tree = {},\n    elementsData = [];\n  var parents = getParents(elements);\n  function canCopy(element, elements) {\n    return rules.allowed('element.copy', {\n      element: element,\n      elements: elements\n    });\n  }\n  function addElementData(element, depth) {\n    // (1) check wether element has already been added\n    var foundElementData = find(elementsData, function (elementsData) {\n      return element === elementsData.element;\n    });\n\n    // (2) add element if not already added\n    if (!foundElementData) {\n      elementsData.push({\n        element: element,\n        depth: depth\n      });\n      return;\n    }\n\n    // (3) update depth\n    if (foundElementData.depth < depth) {\n      elementsData = removeElementData(foundElementData, elementsData);\n      elementsData.push({\n        element: foundElementData.element,\n        depth: depth\n      });\n    }\n  }\n  function removeElementData(elementData, elementsData) {\n    var index = elementsData.indexOf(elementData);\n    if (index !== -1) {\n      elementsData.splice(index, 1);\n    }\n    return elementsData;\n  }\n\n  // (1) add elements\n  eachElement(parents, function (element, _index, depth) {\n    // do NOT add external labels directly\n    if (isLabel(element)) {\n      return;\n    }\n\n    // always copy external labels\n    forEach(element.labels, function (label) {\n      addElementData(label, depth);\n    });\n    function addRelatedElements(elements) {\n      elements && elements.length && forEach(elements, function (element) {\n        // add external labels\n        forEach(element.labels, function (label) {\n          addElementData(label, depth);\n        });\n        addElementData(element, depth);\n      });\n    }\n    forEach([element.attachers, element.incoming, element.outgoing], addRelatedElements);\n    addElementData(element, depth);\n    var children = [];\n    if (element.children) {\n      children = element.children.slice();\n    }\n\n    // allow others to add children to tree\n    self._eventBus.fire('copyPaste.createTree', {\n      element: element,\n      children: children\n    });\n    return children;\n  });\n  elements = map(elementsData, function (elementData) {\n    return elementData.element;\n  });\n\n  // (2) copy elements\n  elementsData = map(elementsData, function (elementData) {\n    elementData.descriptor = {};\n    self._eventBus.fire('copyPaste.copyElement', {\n      descriptor: elementData.descriptor,\n      element: elementData.element,\n      elements: elements\n    });\n    return elementData;\n  });\n\n  // (3) sort elements by priority\n  elementsData = sortBy(elementsData, function (elementData) {\n    return elementData.descriptor.priority;\n  });\n  elements = map(elementsData, function (elementData) {\n    return elementData.element;\n  });\n\n  // (4) create tree\n  forEach(elementsData, function (elementData) {\n    var depth = elementData.depth;\n    if (!self.hasRelations(elementData.element, elements)) {\n      removeElement(elementData.element, elements);\n      return;\n    }\n    if (!canCopy(elementData.element, elements)) {\n      removeElement(elementData.element, elements);\n      return;\n    }\n    if (!tree[depth]) {\n      tree[depth] = [];\n    }\n    tree[depth].push(elementData.descriptor);\n  });\n  return tree;\n};\n\n// helpers //////////\n\nfunction isAttacher(element) {\n  return !!element.host;\n}\nfunction copyWaypoints(element) {\n  return map(element.waypoints, function (waypoint) {\n    waypoint = copyWaypoint(waypoint);\n    if (waypoint.original) {\n      waypoint.original = copyWaypoint(waypoint.original);\n    }\n    return waypoint;\n  });\n}\nfunction copyWaypoint(waypoint) {\n  return assign({}, waypoint);\n}\nfunction removeElement(element, elements) {\n  var index = elements.indexOf(element);\n  if (index === -1) {\n    return elements;\n  }\n  return elements.splice(index, 1);\n}","map":{"version":3,"names":["assign","find","forEach","isArray","isNumber","map","matchPattern","omit","sortBy","getBBox","getParents","eachElement","isConnection","isLabel","CopyPaste","canvas","create","clipboard","elementFactory","eventBus","modeling","mouse","rules","_canvas","_create","_clipboard","_elementFactory","_eventBus","_modeling","_mouse","_rules","on","context","descriptor","element","elements","priority","id","parentCopied","e","parent","isAttacher","host","source","target","waypoints","copyWaypoints","labelTarget","property","hidden","collapsed","hints","createElementsBehavior","$inject","prototype","copy","allowed","tree","fire","createTree","set","paste","get","isEmpty","_createElements","point","_paste","start","getLastMoveEvent","position","x","y","bbox","waypoint","width","height","createElements","self","cache","branch","depth","parseInt","attrs","createConnection","push","createLabel","createShape","connection","label","shape","hasRelations","elementsData","parents","canCopy","addElementData","foundElementData","removeElementData","elementData","index","indexOf","splice","_index","labels","addRelatedElements","length","attachers","incoming","outgoing","children","slice","removeElement","copyWaypoint","original"],"sources":["/home/runner/work/sgex/sgex/node_modules/diagram-js/lib/features/copy-paste/CopyPaste.js"],"sourcesContent":["import {\n  assign,\n  find,\n  forEach,\n  isArray,\n  isNumber,\n  map,\n  matchPattern,\n  omit,\n  sortBy\n} from 'min-dash';\n\nimport {\n  getBBox,\n  getParents\n} from '../../util/Elements';\n\nimport { eachElement } from '../../util/Elements';\n\nimport {\n  isConnection,\n  isLabel\n} from '../../util/ModelUtil';\n\n/**\n * @typedef {import('../../core/Types').ElementLike} Element\n * @typedef {import('../../core/Types').ShapeLike} Shape\n *\n * @typedef {import('../../util/Types').Point} Point\n *\n * @typedef {import('../../core/Canvas').default} Canvas\n * @typedef {import('../clipboard/Clipboard').default} Clipboard\n * @typedef {import('../create/Create').default} Create\n * @typedef {import('../../core/ElementFactory').default} ElementFactory\n * @typedef {import('../../core/EventBus').default} EventBus\n * @typedef {import('../modeling/Modeling').default} Modeling\n * @typedef {import('../mouse/Mouse').default} Mouse\n * @typedef {import('../rules/Rules').default} Rules\n */\n\n/**\n * @typedef { (event: { elements: Element[] }) => Element[]|boolean } CopyPasteCanCopyElementsListener\n */\n\n/**\n * @typedef { (event: { descriptor: any, element: Element, elements: Element[] }) => void } CopyPasteCopyElementListener\n */\n\n/**\n * @typedef { (event: { element: Element, children: Element[] }) => void } CopyPasteCreateTreeListener\n */\n\n/**\n * @typedef { (event: { elements: any, tree: any }) => void } CopyPasteElementsCopiedListener\n */\n\n/**\n * @typedef { (event: { cache: any, descriptor: any }) => void } CopyPastePasteElementListener\n */\n\n/**\n * @typedef { (event: { hints: any }) => void } CopyPastePasteElementsListener\n */\n\n/**\n * Copy and paste elements.\n *\n * @param {Canvas} canvas\n * @param {Create} create\n * @param {Clipboard} clipboard\n * @param {ElementFactory} elementFactory\n * @param {EventBus} eventBus\n * @param {Modeling} modeling\n * @param {Mouse} mouse\n * @param {Rules} rules\n */\nexport default function CopyPaste(\n    canvas,\n    create,\n    clipboard,\n    elementFactory,\n    eventBus,\n    modeling,\n    mouse,\n    rules\n) {\n\n  this._canvas = canvas;\n  this._create = create;\n  this._clipboard = clipboard;\n  this._elementFactory = elementFactory;\n  this._eventBus = eventBus;\n  this._modeling = modeling;\n  this._mouse = mouse;\n  this._rules = rules;\n\n  eventBus.on('copyPaste.copyElement', function(context) {\n    var descriptor = context.descriptor,\n        element = context.element,\n        elements = context.elements;\n\n    // default priority (priority = 1)\n    descriptor.priority = 1;\n\n    descriptor.id = element.id;\n\n    var parentCopied = find(elements, function(e) {\n      return e === element.parent;\n    });\n\n    // do NOT reference parent if parent wasn't copied\n    if (parentCopied) {\n      descriptor.parent = element.parent.id;\n    }\n\n    // attachers (priority = 2)\n    if (isAttacher(element)) {\n      descriptor.priority = 2;\n\n      descriptor.host = element.host.id;\n    }\n\n    // connections (priority = 3)\n    if (isConnection(element)) {\n      descriptor.priority = 3;\n\n      descriptor.source = element.source.id;\n      descriptor.target = element.target.id;\n\n      descriptor.waypoints = copyWaypoints(element);\n    }\n\n    // labels (priority = 4)\n    if (isLabel(element)) {\n      descriptor.priority = 4;\n\n      descriptor.labelTarget = element.labelTarget.id;\n    }\n\n    forEach([ 'x', 'y', 'width', 'height' ], function(property) {\n      if (isNumber(element[ property ])) {\n        descriptor[ property ] = element[ property ];\n      }\n    });\n\n    descriptor.hidden = element.hidden;\n    descriptor.collapsed = element.collapsed;\n\n  });\n\n  eventBus.on('copyPaste.pasteElements', function(context) {\n    var hints = context.hints;\n\n    assign(hints, {\n      createElementsBehavior: false\n    });\n  });\n}\n\nCopyPaste.$inject = [\n  'canvas',\n  'create',\n  'clipboard',\n  'elementFactory',\n  'eventBus',\n  'modeling',\n  'mouse',\n  'rules'\n];\n\n\n/**\n * Copy elements.\n *\n * @param {Element[]} elements\n *\n * @return {Object}\n */\nCopyPaste.prototype.copy = function(elements) {\n  var allowed,\n      tree;\n\n  if (!isArray(elements)) {\n    elements = elements ? [ elements ] : [];\n  }\n\n  allowed = this._eventBus.fire('copyPaste.canCopyElements', {\n    elements: elements\n  });\n\n  if (allowed === false) {\n    tree = {};\n  } else {\n    tree = this.createTree(isArray(allowed) ? allowed : elements);\n  }\n\n  // we set an empty tree, selection of elements\n  // to copy was empty.\n  this._clipboard.set(tree);\n\n  this._eventBus.fire('copyPaste.elementsCopied', {\n    elements: elements,\n    tree: tree\n  });\n\n  return tree;\n};\n\n/**\n * Paste elements.\n *\n * @param {Object} [context]\n * @param {Shape} [context.element] The optional parent.\n * @param {Point} [context.point] The optional position.\n * @param {Object} [context.hints] The optional hints.\n */\nCopyPaste.prototype.paste = function(context) {\n  var tree = this._clipboard.get();\n\n  if (this._clipboard.isEmpty()) {\n    return;\n  }\n\n  var hints = context && context.hints || {};\n\n  this._eventBus.fire('copyPaste.pasteElements', {\n    hints: hints\n  });\n\n  var elements = this._createElements(tree);\n\n  // paste directly\n  if (context && context.element && context.point) {\n    return this._paste(elements, context.element, context.point, hints);\n  }\n\n  this._create.start(this._mouse.getLastMoveEvent(), elements, {\n    hints: hints || {}\n  });\n};\n\n/**\n * Paste elements directly.\n *\n * @param {Element[]} elements\n * @param {Shape} target\n * @param {Point} position\n * @param {Object} [hints]\n */\nCopyPaste.prototype._paste = function(elements, target, position, hints) {\n\n  // make sure each element has x and y\n  forEach(elements, function(element) {\n    if (!isNumber(element.x)) {\n      element.x = 0;\n    }\n\n    if (!isNumber(element.y)) {\n      element.y = 0;\n    }\n  });\n\n  var bbox = getBBox(elements);\n\n  // center elements around cursor\n  forEach(elements, function(element) {\n    if (isConnection(element)) {\n      element.waypoints = map(element.waypoints, function(waypoint) {\n        return {\n          x: waypoint.x - bbox.x - bbox.width / 2,\n          y: waypoint.y - bbox.y - bbox.height / 2\n        };\n      });\n    }\n\n    assign(element, {\n      x: element.x - bbox.x - bbox.width / 2,\n      y: element.y - bbox.y - bbox.height / 2\n    });\n  });\n\n  return this._modeling.createElements(elements, position, target, assign({}, hints));\n};\n\n/**\n * Create elements from tree.\n */\nCopyPaste.prototype._createElements = function(tree) {\n  var self = this;\n\n  var eventBus = this._eventBus;\n\n  var cache = {};\n\n  var elements = [];\n\n  forEach(tree, function(branch, depth) {\n\n    depth = parseInt(depth, 10);\n\n    // sort by priority\n    branch = sortBy(branch, 'priority');\n\n    forEach(branch, function(descriptor) {\n\n      // remove priority\n      var attrs = assign({}, omit(descriptor, [ 'priority' ]));\n\n      if (cache[ descriptor.parent ]) {\n        attrs.parent = cache[ descriptor.parent ];\n      } else {\n        delete attrs.parent;\n      }\n\n      eventBus.fire('copyPaste.pasteElement', {\n        cache: cache,\n        descriptor: attrs\n      });\n\n      var element;\n\n      if (isConnection(attrs)) {\n        attrs.source = cache[ descriptor.source ];\n        attrs.target = cache[ descriptor.target ];\n\n        element = cache[ descriptor.id ] = self.createConnection(attrs);\n\n        elements.push(element);\n\n        return;\n      }\n\n      if (isLabel(attrs)) {\n        attrs.labelTarget = cache[ attrs.labelTarget ];\n\n        element = cache[ descriptor.id ] = self.createLabel(attrs);\n\n        elements.push(element);\n\n        return;\n      }\n\n      if (attrs.host) {\n        attrs.host = cache[ attrs.host ];\n      }\n\n      element = cache[ descriptor.id ] = self.createShape(attrs);\n\n      elements.push(element);\n    });\n\n  });\n\n  return elements;\n};\n\nCopyPaste.prototype.createConnection = function(attrs) {\n  var connection = this._elementFactory.createConnection(omit(attrs, [ 'id' ]));\n\n  return connection;\n};\n\nCopyPaste.prototype.createLabel = function(attrs) {\n  var label = this._elementFactory.createLabel(omit(attrs, [ 'id' ]));\n\n  return label;\n};\n\nCopyPaste.prototype.createShape = function(attrs) {\n  var shape = this._elementFactory.createShape(omit(attrs, [ 'id' ]));\n\n  return shape;\n};\n\n/**\n * Check wether element has relations to other elements e.g. attachers, labels and connections.\n *\n * @param {Object} element\n * @param {Element[]} elements\n *\n * @return {boolean}\n */\nCopyPaste.prototype.hasRelations = function(element, elements) {\n  var labelTarget,\n      source,\n      target;\n\n  if (isConnection(element)) {\n    source = find(elements, matchPattern({ id: element.source.id }));\n    target = find(elements, matchPattern({ id: element.target.id }));\n\n    if (!source || !target) {\n      return false;\n    }\n  }\n\n  if (isLabel(element)) {\n    labelTarget = find(elements, matchPattern({ id: element.labelTarget.id }));\n\n    if (!labelTarget) {\n      return false;\n    }\n  }\n\n  return true;\n};\n\n/**\n * Create a tree-like structure from elements.\n *\n * @example\n *\n * ```javascript\n * tree: {\n *  0: [\n *    { id: 'Shape_1', priority: 1, ... },\n *    { id: 'Shape_2', priority: 1, ... },\n *    { id: 'Connection_1', source: 'Shape_1', target: 'Shape_2', priority: 3, ... },\n *    ...\n *  ],\n *  1: [\n *    { id: 'Shape_3', parent: 'Shape1', priority: 1, ... },\n *    ...\n *  ]\n * };\n * ```\n *\n * @param {Element[]} elements\n *\n * @return {Object}\n */\nCopyPaste.prototype.createTree = function(elements) {\n  var rules = this._rules,\n      self = this;\n\n  var tree = {},\n      elementsData = [];\n\n  var parents = getParents(elements);\n\n  function canCopy(element, elements) {\n    return rules.allowed('element.copy', {\n      element: element,\n      elements: elements\n    });\n  }\n\n  function addElementData(element, depth) {\n\n    // (1) check wether element has already been added\n    var foundElementData = find(elementsData, function(elementsData) {\n      return element === elementsData.element;\n    });\n\n    // (2) add element if not already added\n    if (!foundElementData) {\n      elementsData.push({\n        element: element,\n        depth: depth\n      });\n\n      return;\n    }\n\n    // (3) update depth\n    if (foundElementData.depth < depth) {\n      elementsData = removeElementData(foundElementData, elementsData);\n\n      elementsData.push({\n        element: foundElementData.element,\n        depth: depth\n      });\n    }\n  }\n\n  function removeElementData(elementData, elementsData) {\n    var index = elementsData.indexOf(elementData);\n\n    if (index !== -1) {\n      elementsData.splice(index, 1);\n    }\n\n    return elementsData;\n  }\n\n  // (1) add elements\n  eachElement(parents, function(element, _index, depth) {\n\n    // do NOT add external labels directly\n    if (isLabel(element)) {\n      return;\n    }\n\n    // always copy external labels\n    forEach(element.labels, function(label) {\n      addElementData(label, depth);\n    });\n\n    function addRelatedElements(elements) {\n      elements && elements.length && forEach(elements, function(element) {\n\n        // add external labels\n        forEach(element.labels, function(label) {\n          addElementData(label, depth);\n        });\n\n        addElementData(element, depth);\n      });\n    }\n\n    forEach([ element.attachers, element.incoming, element.outgoing ], addRelatedElements);\n\n    addElementData(element, depth);\n\n    var children = [];\n\n    if (element.children) {\n      children = element.children.slice();\n    }\n\n    // allow others to add children to tree\n    self._eventBus.fire('copyPaste.createTree', {\n      element: element,\n      children: children\n    });\n\n    return children;\n  });\n\n  elements = map(elementsData, function(elementData) {\n    return elementData.element;\n  });\n\n  // (2) copy elements\n  elementsData = map(elementsData, function(elementData) {\n    elementData.descriptor = {};\n\n    self._eventBus.fire('copyPaste.copyElement', {\n      descriptor: elementData.descriptor,\n      element: elementData.element,\n      elements: elements\n    });\n\n    return elementData;\n  });\n\n  // (3) sort elements by priority\n  elementsData = sortBy(elementsData, function(elementData) {\n    return elementData.descriptor.priority;\n  });\n\n  elements = map(elementsData, function(elementData) {\n    return elementData.element;\n  });\n\n  // (4) create tree\n  forEach(elementsData, function(elementData) {\n    var depth = elementData.depth;\n\n    if (!self.hasRelations(elementData.element, elements)) {\n      removeElement(elementData.element, elements);\n\n      return;\n    }\n\n    if (!canCopy(elementData.element, elements)) {\n      removeElement(elementData.element, elements);\n\n      return;\n    }\n\n    if (!tree[depth]) {\n      tree[depth] = [];\n    }\n\n    tree[depth].push(elementData.descriptor);\n  });\n\n  return tree;\n};\n\n// helpers //////////\n\nfunction isAttacher(element) {\n  return !!element.host;\n}\n\nfunction copyWaypoints(element) {\n  return map(element.waypoints, function(waypoint) {\n\n    waypoint = copyWaypoint(waypoint);\n\n    if (waypoint.original) {\n      waypoint.original = copyWaypoint(waypoint.original);\n    }\n\n    return waypoint;\n  });\n}\n\nfunction copyWaypoint(waypoint) {\n  return assign({}, waypoint);\n}\n\nfunction removeElement(element, elements) {\n  var index = elements.indexOf(element);\n\n  if (index === -1) {\n    return elements;\n  }\n\n  return elements.splice(index, 1);\n}"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}