{"ast":null,"code":"'use strict';\n\nconst NullObject = function NullObject() {};\nNullObject.prototype = Object.create(null);\n\n/**\n * RegExp to match *( \";\" parameter ) in RFC 7231 sec 3.1.1.1\n *\n * parameter     = token \"=\" ( token / quoted-string )\n * token         = 1*tchar\n * tchar         = \"!\" / \"#\" / \"$\" / \"%\" / \"&\" / \"'\" / \"*\"\n *               / \"+\" / \"-\" / \".\" / \"^\" / \"_\" / \"`\" / \"|\" / \"~\"\n *               / DIGIT / ALPHA\n *               ; any VCHAR, except delimiters\n * quoted-string = DQUOTE *( qdtext / quoted-pair ) DQUOTE\n * qdtext        = HTAB / SP / %x21 / %x23-5B / %x5D-7E / obs-text\n * obs-text      = %x80-FF\n * quoted-pair   = \"\\\" ( HTAB / SP / VCHAR / obs-text )\n */\nconst paramRE = /; *([!#$%&'*+.^\\w`|~-]+)=(\"(?:[\\v\\u0020\\u0021\\u0023-\\u005b\\u005d-\\u007e\\u0080-\\u00ff]|\\\\[\\v\\u0020-\\u00ff])*\"|[!#$%&'*+.^\\w`|~-]+) */gu;\n\n/**\n * RegExp to match quoted-pair in RFC 7230 sec 3.2.6\n *\n * quoted-pair = \"\\\" ( HTAB / SP / VCHAR / obs-text )\n * obs-text    = %x80-FF\n */\nconst quotedPairRE = /\\\\([\\v\\u0020-\\u00ff])/gu;\n\n/**\n * RegExp to match type in RFC 7231 sec 3.1.1.1\n *\n * media-type = type \"/\" subtype\n * type       = token\n * subtype    = token\n */\nconst mediaTypeRE = /^[!#$%&'*+.^\\w|~-]+\\/[!#$%&'*+.^\\w|~-]+$/u;\n\n// default ContentType to prevent repeated object creation\nconst defaultContentType = {\n  type: '',\n  parameters: new NullObject()\n};\nObject.freeze(defaultContentType.parameters);\nObject.freeze(defaultContentType);\n\n/**\n * Parse media type to object.\n *\n * @param {string|object} header\n * @return {Object}\n * @public\n */\n\nfunction parse(header) {\n  if (typeof header !== 'string') {\n    throw new TypeError('argument header is required and must be a string');\n  }\n  let index = header.indexOf(';');\n  const type = index !== -1 ? header.slice(0, index).trim() : header.trim();\n  if (mediaTypeRE.test(type) === false) {\n    throw new TypeError('invalid media type');\n  }\n  const result = {\n    type: type.toLowerCase(),\n    parameters: new NullObject()\n  };\n\n  // parse parameters\n  if (index === -1) {\n    return result;\n  }\n  let key;\n  let match;\n  let value;\n  paramRE.lastIndex = index;\n  while (match = paramRE.exec(header)) {\n    if (match.index !== index) {\n      throw new TypeError('invalid parameter format');\n    }\n    index += match[0].length;\n    key = match[1].toLowerCase();\n    value = match[2];\n    if (value[0] === '\"') {\n      // remove quotes and escapes\n      value = value.slice(1, value.length - 1);\n      quotedPairRE.test(value) && (value = value.replace(quotedPairRE, '$1'));\n    }\n    result.parameters[key] = value;\n  }\n  if (index !== header.length) {\n    throw new TypeError('invalid parameter format');\n  }\n  return result;\n}\nfunction safeParse(header) {\n  if (typeof header !== 'string') {\n    return defaultContentType;\n  }\n  let index = header.indexOf(';');\n  const type = index !== -1 ? header.slice(0, index).trim() : header.trim();\n  if (mediaTypeRE.test(type) === false) {\n    return defaultContentType;\n  }\n  const result = {\n    type: type.toLowerCase(),\n    parameters: new NullObject()\n  };\n\n  // parse parameters\n  if (index === -1) {\n    return result;\n  }\n  let key;\n  let match;\n  let value;\n  paramRE.lastIndex = index;\n  while (match = paramRE.exec(header)) {\n    if (match.index !== index) {\n      return defaultContentType;\n    }\n    index += match[0].length;\n    key = match[1].toLowerCase();\n    value = match[2];\n    if (value[0] === '\"') {\n      // remove quotes and escapes\n      value = value.slice(1, value.length - 1);\n      quotedPairRE.test(value) && (value = value.replace(quotedPairRE, '$1'));\n    }\n    result.parameters[key] = value;\n  }\n  if (index !== header.length) {\n    return defaultContentType;\n  }\n  return result;\n}\nmodule.exports.default = {\n  parse,\n  safeParse\n};\nmodule.exports.parse = parse;\nmodule.exports.safeParse = safeParse;\nmodule.exports.defaultContentType = defaultContentType;","map":{"version":3,"names":["NullObject","prototype","Object","create","paramRE","quotedPairRE","mediaTypeRE","defaultContentType","type","parameters","freeze","parse","header","TypeError","index","indexOf","slice","trim","test","result","toLowerCase","key","match","value","lastIndex","exec","length","replace","safeParse","module","exports","default"],"sources":["/home/runner/work/sgex/sgex/node_modules/fast-content-type-parse/index.js"],"sourcesContent":["'use strict'\n\nconst NullObject = function NullObject () { }\nNullObject.prototype = Object.create(null)\n\n/**\n * RegExp to match *( \";\" parameter ) in RFC 7231 sec 3.1.1.1\n *\n * parameter     = token \"=\" ( token / quoted-string )\n * token         = 1*tchar\n * tchar         = \"!\" / \"#\" / \"$\" / \"%\" / \"&\" / \"'\" / \"*\"\n *               / \"+\" / \"-\" / \".\" / \"^\" / \"_\" / \"`\" / \"|\" / \"~\"\n *               / DIGIT / ALPHA\n *               ; any VCHAR, except delimiters\n * quoted-string = DQUOTE *( qdtext / quoted-pair ) DQUOTE\n * qdtext        = HTAB / SP / %x21 / %x23-5B / %x5D-7E / obs-text\n * obs-text      = %x80-FF\n * quoted-pair   = \"\\\" ( HTAB / SP / VCHAR / obs-text )\n */\nconst paramRE = /; *([!#$%&'*+.^\\w`|~-]+)=(\"(?:[\\v\\u0020\\u0021\\u0023-\\u005b\\u005d-\\u007e\\u0080-\\u00ff]|\\\\[\\v\\u0020-\\u00ff])*\"|[!#$%&'*+.^\\w`|~-]+) */gu\n\n/**\n * RegExp to match quoted-pair in RFC 7230 sec 3.2.6\n *\n * quoted-pair = \"\\\" ( HTAB / SP / VCHAR / obs-text )\n * obs-text    = %x80-FF\n */\nconst quotedPairRE = /\\\\([\\v\\u0020-\\u00ff])/gu\n\n/**\n * RegExp to match type in RFC 7231 sec 3.1.1.1\n *\n * media-type = type \"/\" subtype\n * type       = token\n * subtype    = token\n */\nconst mediaTypeRE = /^[!#$%&'*+.^\\w|~-]+\\/[!#$%&'*+.^\\w|~-]+$/u\n\n// default ContentType to prevent repeated object creation\nconst defaultContentType = { type: '', parameters: new NullObject() }\nObject.freeze(defaultContentType.parameters)\nObject.freeze(defaultContentType)\n\n/**\n * Parse media type to object.\n *\n * @param {string|object} header\n * @return {Object}\n * @public\n */\n\nfunction parse (header) {\n  if (typeof header !== 'string') {\n    throw new TypeError('argument header is required and must be a string')\n  }\n\n  let index = header.indexOf(';')\n  const type = index !== -1\n    ? header.slice(0, index).trim()\n    : header.trim()\n\n  if (mediaTypeRE.test(type) === false) {\n    throw new TypeError('invalid media type')\n  }\n\n  const result = {\n    type: type.toLowerCase(),\n    parameters: new NullObject()\n  }\n\n  // parse parameters\n  if (index === -1) {\n    return result\n  }\n\n  let key\n  let match\n  let value\n\n  paramRE.lastIndex = index\n\n  while ((match = paramRE.exec(header))) {\n    if (match.index !== index) {\n      throw new TypeError('invalid parameter format')\n    }\n\n    index += match[0].length\n    key = match[1].toLowerCase()\n    value = match[2]\n\n    if (value[0] === '\"') {\n      // remove quotes and escapes\n      value = value\n        .slice(1, value.length - 1)\n\n      quotedPairRE.test(value) && (value = value.replace(quotedPairRE, '$1'))\n    }\n\n    result.parameters[key] = value\n  }\n\n  if (index !== header.length) {\n    throw new TypeError('invalid parameter format')\n  }\n\n  return result\n}\n\nfunction safeParse (header) {\n  if (typeof header !== 'string') {\n    return defaultContentType\n  }\n\n  let index = header.indexOf(';')\n  const type = index !== -1\n    ? header.slice(0, index).trim()\n    : header.trim()\n\n  if (mediaTypeRE.test(type) === false) {\n    return defaultContentType\n  }\n\n  const result = {\n    type: type.toLowerCase(),\n    parameters: new NullObject()\n  }\n\n  // parse parameters\n  if (index === -1) {\n    return result\n  }\n\n  let key\n  let match\n  let value\n\n  paramRE.lastIndex = index\n\n  while ((match = paramRE.exec(header))) {\n    if (match.index !== index) {\n      return defaultContentType\n    }\n\n    index += match[0].length\n    key = match[1].toLowerCase()\n    value = match[2]\n\n    if (value[0] === '\"') {\n      // remove quotes and escapes\n      value = value\n        .slice(1, value.length - 1)\n\n      quotedPairRE.test(value) && (value = value.replace(quotedPairRE, '$1'))\n    }\n\n    result.parameters[key] = value\n  }\n\n  if (index !== header.length) {\n    return defaultContentType\n  }\n\n  return result\n}\n\nmodule.exports.default = { parse, safeParse }\nmodule.exports.parse = parse\nmodule.exports.safeParse = safeParse\nmodule.exports.defaultContentType = defaultContentType\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}