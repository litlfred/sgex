{"ast":null,"code":"import inherits from 'inherits-browser';\nimport CommandInterceptor from '../../command/CommandInterceptor';\n\n/**\n * @typedef {import('../../core/Types').ElementLike} Element\n * @typedef {import('../../core/Types').ShapeLike} Shape\n *\n * @typedef {import('../../core/EventBus').default} EventBus\n */\n\n/**\n * An abstract provider that allows modelers to implement a custom\n * ordering of diagram elements on the canvas.\n *\n * It makes sure that the order is always preserved during element\n * creation and move operations.\n *\n * In order to use this behavior, inherit from it and override\n * the method {@link OrderingProvider#getOrdering}.\n *\n * @example\n *\n * ```javascript\n * function CustomOrderingProvider(eventBus) {\n *   OrderingProvider.call(this, eventBus);\n *\n *   this.getOrdering = function(element, newParent) {\n *     // always insert elements at the front\n *     // when moving\n *     return {\n *       index: 0,\n *       parent: newParent\n *     };\n *   };\n * }\n * ```\n *\n * @param {EventBus} eventBus\n */\nexport default function OrderingProvider(eventBus) {\n  CommandInterceptor.call(this, eventBus);\n  var self = this;\n  this.preExecute(['shape.create', 'connection.create'], function (event) {\n    var context = event.context,\n      element = context.shape || context.connection,\n      parent = context.parent;\n    var ordering = self.getOrdering(element, parent);\n    if (ordering) {\n      if (ordering.parent !== undefined) {\n        context.parent = ordering.parent;\n      }\n      context.parentIndex = ordering.index;\n    }\n  });\n  this.preExecute(['shape.move', 'connection.move'], function (event) {\n    var context = event.context,\n      element = context.shape || context.connection,\n      parent = context.newParent || element.parent;\n    var ordering = self.getOrdering(element, parent);\n    if (ordering) {\n      if (ordering.parent !== undefined) {\n        context.newParent = ordering.parent;\n      }\n      context.newParentIndex = ordering.index;\n    }\n  });\n}\n\n/**\n * Return a custom ordering of the element, both in terms\n * of parent element and index in the new parent.\n *\n * Implementors of this method must return an object with\n * `parent` _and_ `index` in it.\n *\n * @param {Element} element\n * @param {Shape} newParent\n *\n * @return {Object} ordering descriptor\n */\nOrderingProvider.prototype.getOrdering = function (element, newParent) {\n  return null;\n};\ninherits(OrderingProvider, CommandInterceptor);","map":{"version":3,"names":["inherits","CommandInterceptor","OrderingProvider","eventBus","call","self","preExecute","event","context","element","shape","connection","parent","ordering","getOrdering","undefined","parentIndex","index","newParent","newParentIndex","prototype"],"sources":["/home/runner/work/sgex/sgex/node_modules/diagram-js/lib/features/ordering/OrderingProvider.js"],"sourcesContent":["import inherits from 'inherits-browser';\n\nimport CommandInterceptor from '../../command/CommandInterceptor';\n\n/**\n * @typedef {import('../../core/Types').ElementLike} Element\n * @typedef {import('../../core/Types').ShapeLike} Shape\n *\n * @typedef {import('../../core/EventBus').default} EventBus\n */\n\n/**\n * An abstract provider that allows modelers to implement a custom\n * ordering of diagram elements on the canvas.\n *\n * It makes sure that the order is always preserved during element\n * creation and move operations.\n *\n * In order to use this behavior, inherit from it and override\n * the method {@link OrderingProvider#getOrdering}.\n *\n * @example\n *\n * ```javascript\n * function CustomOrderingProvider(eventBus) {\n *   OrderingProvider.call(this, eventBus);\n *\n *   this.getOrdering = function(element, newParent) {\n *     // always insert elements at the front\n *     // when moving\n *     return {\n *       index: 0,\n *       parent: newParent\n *     };\n *   };\n * }\n * ```\n *\n * @param {EventBus} eventBus\n */\nexport default function OrderingProvider(eventBus) {\n\n  CommandInterceptor.call(this, eventBus);\n\n\n  var self = this;\n\n  this.preExecute([ 'shape.create', 'connection.create' ], function(event) {\n\n    var context = event.context,\n        element = context.shape || context.connection,\n        parent = context.parent;\n\n    var ordering = self.getOrdering(element, parent);\n\n    if (ordering) {\n\n      if (ordering.parent !== undefined) {\n        context.parent = ordering.parent;\n      }\n\n      context.parentIndex = ordering.index;\n    }\n  });\n\n  this.preExecute([ 'shape.move', 'connection.move' ], function(event) {\n\n    var context = event.context,\n        element = context.shape || context.connection,\n        parent = context.newParent || element.parent;\n\n    var ordering = self.getOrdering(element, parent);\n\n    if (ordering) {\n\n      if (ordering.parent !== undefined) {\n        context.newParent = ordering.parent;\n      }\n\n      context.newParentIndex = ordering.index;\n    }\n  });\n}\n\n/**\n * Return a custom ordering of the element, both in terms\n * of parent element and index in the new parent.\n *\n * Implementors of this method must return an object with\n * `parent` _and_ `index` in it.\n *\n * @param {Element} element\n * @param {Shape} newParent\n *\n * @return {Object} ordering descriptor\n */\nOrderingProvider.prototype.getOrdering = function(element, newParent) {\n  return null;\n};\n\ninherits(OrderingProvider, CommandInterceptor);"],"mappings":"AAAA,OAAOA,QAAQ,MAAM,kBAAkB;AAEvC,OAAOC,kBAAkB,MAAM,kCAAkC;;AAEjE;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,SAASC,gBAAgBA,CAACC,QAAQ,EAAE;EAEjDF,kBAAkB,CAACG,IAAI,CAAC,IAAI,EAAED,QAAQ,CAAC;EAGvC,IAAIE,IAAI,GAAG,IAAI;EAEf,IAAI,CAACC,UAAU,CAAC,CAAE,cAAc,EAAE,mBAAmB,CAAE,EAAE,UAASC,KAAK,EAAE;IAEvE,IAAIC,OAAO,GAAGD,KAAK,CAACC,OAAO;MACvBC,OAAO,GAAGD,OAAO,CAACE,KAAK,IAAIF,OAAO,CAACG,UAAU;MAC7CC,MAAM,GAAGJ,OAAO,CAACI,MAAM;IAE3B,IAAIC,QAAQ,GAAGR,IAAI,CAACS,WAAW,CAACL,OAAO,EAAEG,MAAM,CAAC;IAEhD,IAAIC,QAAQ,EAAE;MAEZ,IAAIA,QAAQ,CAACD,MAAM,KAAKG,SAAS,EAAE;QACjCP,OAAO,CAACI,MAAM,GAAGC,QAAQ,CAACD,MAAM;MAClC;MAEAJ,OAAO,CAACQ,WAAW,GAAGH,QAAQ,CAACI,KAAK;IACtC;EACF,CAAC,CAAC;EAEF,IAAI,CAACX,UAAU,CAAC,CAAE,YAAY,EAAE,iBAAiB,CAAE,EAAE,UAASC,KAAK,EAAE;IAEnE,IAAIC,OAAO,GAAGD,KAAK,CAACC,OAAO;MACvBC,OAAO,GAAGD,OAAO,CAACE,KAAK,IAAIF,OAAO,CAACG,UAAU;MAC7CC,MAAM,GAAGJ,OAAO,CAACU,SAAS,IAAIT,OAAO,CAACG,MAAM;IAEhD,IAAIC,QAAQ,GAAGR,IAAI,CAACS,WAAW,CAACL,OAAO,EAAEG,MAAM,CAAC;IAEhD,IAAIC,QAAQ,EAAE;MAEZ,IAAIA,QAAQ,CAACD,MAAM,KAAKG,SAAS,EAAE;QACjCP,OAAO,CAACU,SAAS,GAAGL,QAAQ,CAACD,MAAM;MACrC;MAEAJ,OAAO,CAACW,cAAc,GAAGN,QAAQ,CAACI,KAAK;IACzC;EACF,CAAC,CAAC;AACJ;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACAf,gBAAgB,CAACkB,SAAS,CAACN,WAAW,GAAG,UAASL,OAAO,EAAES,SAAS,EAAE;EACpE,OAAO,IAAI;AACb,CAAC;AAEDlB,QAAQ,CAACE,gBAAgB,EAAED,kBAAkB,CAAC","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}