{"ast":null,"code":"\"use strict\";\n\nvar _taggedTemplateLiteral = require(\"/home/runner/work/sgex/sgex/node_modules/@babel/runtime/helpers/taggedTemplateLiteral.js\").default;\nvar _templateObject, _templateObject2, _templateObject3, _templateObject4;\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nconst codegen_1 = require(\"../../compile/codegen\");\nconst util_1 = require(\"../../compile/util\");\nconst equal_1 = require(\"../../runtime/equal\");\nconst error = {\n  message: \"must be equal to one of the allowed values\",\n  params: _ref => {\n    let {\n      schemaCode\n    } = _ref;\n    return (0, codegen_1._)(_templateObject || (_templateObject = _taggedTemplateLiteral([\"{allowedValues: \", \"}\"])), schemaCode);\n  }\n};\nconst def = {\n  keyword: \"enum\",\n  schemaType: \"array\",\n  $data: true,\n  error,\n  code(cxt) {\n    const {\n      gen,\n      data,\n      $data,\n      schema,\n      schemaCode,\n      it\n    } = cxt;\n    if (!$data && schema.length === 0) throw new Error(\"enum must have non-empty array\");\n    const useLoop = schema.length >= it.opts.loopEnum;\n    let eql;\n    const getEql = () => eql !== null && eql !== void 0 ? eql : eql = (0, util_1.useFunc)(gen, equal_1.default);\n    let valid;\n    if (useLoop || $data) {\n      valid = gen.let(\"valid\");\n      cxt.block$data(valid, loopEnum);\n    } else {\n      /* istanbul ignore if */\n      if (!Array.isArray(schema)) throw new Error(\"ajv implementation error\");\n      const vSchema = gen.const(\"vSchema\", schemaCode);\n      valid = (0, codegen_1.or)(...schema.map((_x, i) => equalCode(vSchema, i)));\n    }\n    cxt.pass(valid);\n    function loopEnum() {\n      gen.assign(valid, false);\n      gen.forOf(\"v\", schemaCode, v => gen.if((0, codegen_1._)(_templateObject2 || (_templateObject2 = _taggedTemplateLiteral([\"\", \"(\", \", \", \")\"])), getEql(), data, v), () => gen.assign(valid, true).break()));\n    }\n    function equalCode(vSchema, i) {\n      const sch = schema[i];\n      return typeof sch === \"object\" && sch !== null ? (0, codegen_1._)(_templateObject3 || (_templateObject3 = _taggedTemplateLiteral([\"\", \"(\", \", \", \"[\", \"])\"])), getEql(), data, vSchema, i) : (0, codegen_1._)(_templateObject4 || (_templateObject4 = _taggedTemplateLiteral([\"\", \" === \", \"\"])), data, sch);\n    }\n  }\n};\nexports.default = def;","map":{"version":3,"names":["codegen_1","require","util_1","equal_1","error","message","params","_ref","schemaCode","_","_templateObject","_taggedTemplateLiteral","def","keyword","schemaType","$data","code","cxt","gen","data","schema","it","length","Error","useLoop","opts","loopEnum","eql","getEql","useFunc","default","valid","let","block$data","Array","isArray","vSchema","const","or","map","_x","i","equalCode","pass","assign","forOf","v","if","_templateObject2","break","sch","_templateObject3","_templateObject4","exports"],"sources":["/home/runner/work/sgex/sgex/node_modules/ajv/lib/vocabularies/validation/enum.ts"],"sourcesContent":["import type {CodeKeywordDefinition, ErrorObject, KeywordErrorDefinition} from \"../../types\"\nimport type {KeywordCxt} from \"../../compile/validate\"\nimport {_, or, Name, Code} from \"../../compile/codegen\"\nimport {useFunc} from \"../../compile/util\"\nimport equal from \"../../runtime/equal\"\n\nexport type EnumError = ErrorObject<\"enum\", {allowedValues: any[]}, any[] | {$data: string}>\n\nconst error: KeywordErrorDefinition = {\n  message: \"must be equal to one of the allowed values\",\n  params: ({schemaCode}) => _`{allowedValues: ${schemaCode}}`,\n}\n\nconst def: CodeKeywordDefinition = {\n  keyword: \"enum\",\n  schemaType: \"array\",\n  $data: true,\n  error,\n  code(cxt: KeywordCxt) {\n    const {gen, data, $data, schema, schemaCode, it} = cxt\n    if (!$data && schema.length === 0) throw new Error(\"enum must have non-empty array\")\n    const useLoop = schema.length >= it.opts.loopEnum\n    let eql: Name | undefined\n    const getEql = (): Name => (eql ??= useFunc(gen, equal))\n\n    let valid: Code\n    if (useLoop || $data) {\n      valid = gen.let(\"valid\")\n      cxt.block$data(valid, loopEnum)\n    } else {\n      /* istanbul ignore if */\n      if (!Array.isArray(schema)) throw new Error(\"ajv implementation error\")\n      const vSchema = gen.const(\"vSchema\", schemaCode)\n      valid = or(...schema.map((_x: unknown, i: number) => equalCode(vSchema, i)))\n    }\n    cxt.pass(valid)\n\n    function loopEnum(): void {\n      gen.assign(valid, false)\n      gen.forOf(\"v\", schemaCode as Code, (v) =>\n        gen.if(_`${getEql()}(${data}, ${v})`, () => gen.assign(valid, true).break())\n      )\n    }\n\n    function equalCode(vSchema: Name, i: number): Code {\n      const sch = schema[i]\n      return typeof sch === \"object\" && sch !== null\n        ? _`${getEql()}(${data}, ${vSchema}[${i}])`\n        : _`${data} === ${sch}`\n    }\n  },\n}\n\nexport default def\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}