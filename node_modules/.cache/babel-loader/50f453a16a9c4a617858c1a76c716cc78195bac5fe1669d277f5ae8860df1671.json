{"ast":null,"code":"\"use strict\";\n\nvar _objectSpread = require(\"/home/runner/work/sgex/sgex/node_modules/@babel/runtime/helpers/objectSpread2.js\").default;\nvar _taggedTemplateLiteral = require(\"/home/runner/work/sgex/sgex/node_modules/@babel/runtime/helpers/taggedTemplateLiteral.js\").default;\nvar _templateObject, _templateObject2, _templateObject3, _templateObject4, _templateObject5, _templateObject6, _templateObject7, _templateObject8, _templateObject9, _templateObject0, _templateObject1, _templateObject10, _templateObject11, _templateObject12, _templateObject13, _templateObject14, _templateObject15, _templateObject16, _templateObject17, _templateObject18, _templateObject19, _templateObject20, _templateObject21, _templateObject22, _templateObject23, _templateObject24, _templateObject25, _templateObject26, _templateObject27, _templateObject28, _templateObject29, _templateObject30, _templateObject31, _templateObject32, _templateObject33, _templateObject34, _templateObject35, _templateObject36, _templateObject37;\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.getData = exports.KeywordCxt = exports.validateFunctionCode = void 0;\nconst boolSchema_1 = require(\"./boolSchema\");\nconst dataType_1 = require(\"./dataType\");\nconst applicability_1 = require(\"./applicability\");\nconst dataType_2 = require(\"./dataType\");\nconst defaults_1 = require(\"./defaults\");\nconst keyword_1 = require(\"./keyword\");\nconst subschema_1 = require(\"./subschema\");\nconst codegen_1 = require(\"../codegen\");\nconst names_1 = require(\"../names\");\nconst resolve_1 = require(\"../resolve\");\nconst util_1 = require(\"../util\");\nconst errors_1 = require(\"../errors\");\n// schema compilation - generates validation function, subschemaCode (below) is used for subschemas\nfunction validateFunctionCode(it) {\n  if (isSchemaObj(it)) {\n    checkKeywords(it);\n    if (schemaCxtHasRules(it)) {\n      topSchemaObjCode(it);\n      return;\n    }\n  }\n  validateFunction(it, () => (0, boolSchema_1.topBoolOrEmptySchema)(it));\n}\nexports.validateFunctionCode = validateFunctionCode;\nfunction validateFunction(_ref, body) {\n  let {\n    gen,\n    validateName,\n    schema,\n    schemaEnv,\n    opts\n  } = _ref;\n  if (opts.code.es5) {\n    gen.func(validateName, (0, codegen_1._)(_templateObject || (_templateObject = _taggedTemplateLiteral([\"\", \", \", \"\"])), names_1.default.data, names_1.default.valCxt), schemaEnv.$async, () => {\n      gen.code((0, codegen_1._)(_templateObject2 || (_templateObject2 = _taggedTemplateLiteral([\"\\\"use strict\\\"; \", \"\"])), funcSourceUrl(schema, opts)));\n      destructureValCxtES5(gen, opts);\n      gen.code(body);\n    });\n  } else {\n    gen.func(validateName, (0, codegen_1._)(_templateObject3 || (_templateObject3 = _taggedTemplateLiteral([\"\", \", \", \"\"])), names_1.default.data, destructureValCxt(opts)), schemaEnv.$async, () => gen.code(funcSourceUrl(schema, opts)).code(body));\n  }\n}\nfunction destructureValCxt(opts) {\n  return (0, codegen_1._)(_templateObject4 || (_templateObject4 = _taggedTemplateLiteral([\"{\", \"=\\\"\\\", \", \", \", \", \", \"=\", \"\", \"}={}\"])), names_1.default.instancePath, names_1.default.parentData, names_1.default.parentDataProperty, names_1.default.rootData, names_1.default.data, opts.dynamicRef ? (0, codegen_1._)(_templateObject5 || (_templateObject5 = _taggedTemplateLiteral([\", \", \"={}\"])), names_1.default.dynamicAnchors) : codegen_1.nil);\n}\nfunction destructureValCxtES5(gen, opts) {\n  gen.if(names_1.default.valCxt, () => {\n    gen.var(names_1.default.instancePath, (0, codegen_1._)(_templateObject6 || (_templateObject6 = _taggedTemplateLiteral([\"\", \".\", \"\"])), names_1.default.valCxt, names_1.default.instancePath));\n    gen.var(names_1.default.parentData, (0, codegen_1._)(_templateObject7 || (_templateObject7 = _taggedTemplateLiteral([\"\", \".\", \"\"])), names_1.default.valCxt, names_1.default.parentData));\n    gen.var(names_1.default.parentDataProperty, (0, codegen_1._)(_templateObject8 || (_templateObject8 = _taggedTemplateLiteral([\"\", \".\", \"\"])), names_1.default.valCxt, names_1.default.parentDataProperty));\n    gen.var(names_1.default.rootData, (0, codegen_1._)(_templateObject9 || (_templateObject9 = _taggedTemplateLiteral([\"\", \".\", \"\"])), names_1.default.valCxt, names_1.default.rootData));\n    if (opts.dynamicRef) gen.var(names_1.default.dynamicAnchors, (0, codegen_1._)(_templateObject0 || (_templateObject0 = _taggedTemplateLiteral([\"\", \".\", \"\"])), names_1.default.valCxt, names_1.default.dynamicAnchors));\n  }, () => {\n    gen.var(names_1.default.instancePath, (0, codegen_1._)(_templateObject1 || (_templateObject1 = _taggedTemplateLiteral([\"\\\"\\\"\"]))));\n    gen.var(names_1.default.parentData, (0, codegen_1._)(_templateObject10 || (_templateObject10 = _taggedTemplateLiteral([\"undefined\"]))));\n    gen.var(names_1.default.parentDataProperty, (0, codegen_1._)(_templateObject11 || (_templateObject11 = _taggedTemplateLiteral([\"undefined\"]))));\n    gen.var(names_1.default.rootData, names_1.default.data);\n    if (opts.dynamicRef) gen.var(names_1.default.dynamicAnchors, (0, codegen_1._)(_templateObject12 || (_templateObject12 = _taggedTemplateLiteral([\"{}\"]))));\n  });\n}\nfunction topSchemaObjCode(it) {\n  const {\n    schema,\n    opts,\n    gen\n  } = it;\n  validateFunction(it, () => {\n    if (opts.$comment && schema.$comment) commentKeyword(it);\n    checkNoDefault(it);\n    gen.let(names_1.default.vErrors, null);\n    gen.let(names_1.default.errors, 0);\n    if (opts.unevaluated) resetEvaluated(it);\n    typeAndKeywords(it);\n    returnResults(it);\n  });\n  return;\n}\nfunction resetEvaluated(it) {\n  // TODO maybe some hook to execute it in the end to check whether props/items are Name, as in assignEvaluated\n  const {\n    gen,\n    validateName\n  } = it;\n  it.evaluated = gen.const(\"evaluated\", (0, codegen_1._)(_templateObject13 || (_templateObject13 = _taggedTemplateLiteral([\"\", \".evaluated\"])), validateName));\n  gen.if((0, codegen_1._)(_templateObject14 || (_templateObject14 = _taggedTemplateLiteral([\"\", \".dynamicProps\"])), it.evaluated), () => gen.assign((0, codegen_1._)(_templateObject15 || (_templateObject15 = _taggedTemplateLiteral([\"\", \".props\"])), it.evaluated), (0, codegen_1._)(_templateObject16 || (_templateObject16 = _taggedTemplateLiteral([\"undefined\"])))));\n  gen.if((0, codegen_1._)(_templateObject17 || (_templateObject17 = _taggedTemplateLiteral([\"\", \".dynamicItems\"])), it.evaluated), () => gen.assign((0, codegen_1._)(_templateObject18 || (_templateObject18 = _taggedTemplateLiteral([\"\", \".items\"])), it.evaluated), (0, codegen_1._)(_templateObject19 || (_templateObject19 = _taggedTemplateLiteral([\"undefined\"])))));\n}\nfunction funcSourceUrl(schema, opts) {\n  const schId = typeof schema == \"object\" && schema[opts.schemaId];\n  return schId && (opts.code.source || opts.code.process) ? (0, codegen_1._)(_templateObject20 || (_templateObject20 = _taggedTemplateLiteral([\"/*# sourceURL=\", \" */\"])), schId) : codegen_1.nil;\n}\n// schema compilation - this function is used recursively to generate code for sub-schemas\nfunction subschemaCode(it, valid) {\n  if (isSchemaObj(it)) {\n    checkKeywords(it);\n    if (schemaCxtHasRules(it)) {\n      subSchemaObjCode(it, valid);\n      return;\n    }\n  }\n  (0, boolSchema_1.boolOrEmptySchema)(it, valid);\n}\nfunction schemaCxtHasRules(_ref2) {\n  let {\n    schema,\n    self\n  } = _ref2;\n  if (typeof schema == \"boolean\") return !schema;\n  for (const key in schema) if (self.RULES.all[key]) return true;\n  return false;\n}\nfunction isSchemaObj(it) {\n  return typeof it.schema != \"boolean\";\n}\nfunction subSchemaObjCode(it, valid) {\n  const {\n    schema,\n    gen,\n    opts\n  } = it;\n  if (opts.$comment && schema.$comment) commentKeyword(it);\n  updateContext(it);\n  checkAsyncSchema(it);\n  const errsCount = gen.const(\"_errs\", names_1.default.errors);\n  typeAndKeywords(it, errsCount);\n  // TODO var\n  gen.var(valid, (0, codegen_1._)(_templateObject21 || (_templateObject21 = _taggedTemplateLiteral([\"\", \" === \", \"\"])), errsCount, names_1.default.errors));\n}\nfunction checkKeywords(it) {\n  (0, util_1.checkUnknownRules)(it);\n  checkRefsAndKeywords(it);\n}\nfunction typeAndKeywords(it, errsCount) {\n  if (it.opts.jtd) return schemaKeywords(it, [], false, errsCount);\n  const types = (0, dataType_1.getSchemaTypes)(it.schema);\n  const checkedTypes = (0, dataType_1.coerceAndCheckDataType)(it, types);\n  schemaKeywords(it, types, !checkedTypes, errsCount);\n}\nfunction checkRefsAndKeywords(it) {\n  const {\n    schema,\n    errSchemaPath,\n    opts,\n    self\n  } = it;\n  if (schema.$ref && opts.ignoreKeywordsWithRef && (0, util_1.schemaHasRulesButRef)(schema, self.RULES)) {\n    self.logger.warn(\"$ref: keywords ignored in schema at path \\\"\".concat(errSchemaPath, \"\\\"\"));\n  }\n}\nfunction checkNoDefault(it) {\n  const {\n    schema,\n    opts\n  } = it;\n  if (schema.default !== undefined && opts.useDefaults && opts.strictSchema) {\n    (0, util_1.checkStrictMode)(it, \"default is ignored in the schema root\");\n  }\n}\nfunction updateContext(it) {\n  const schId = it.schema[it.opts.schemaId];\n  if (schId) it.baseId = (0, resolve_1.resolveUrl)(it.opts.uriResolver, it.baseId, schId);\n}\nfunction checkAsyncSchema(it) {\n  if (it.schema.$async && !it.schemaEnv.$async) throw new Error(\"async schema in sync schema\");\n}\nfunction commentKeyword(_ref3) {\n  let {\n    gen,\n    schemaEnv,\n    schema,\n    errSchemaPath,\n    opts\n  } = _ref3;\n  const msg = schema.$comment;\n  if (opts.$comment === true) {\n    gen.code((0, codegen_1._)(_templateObject22 || (_templateObject22 = _taggedTemplateLiteral([\"\", \".logger.log(\", \")\"])), names_1.default.self, msg));\n  } else if (typeof opts.$comment == \"function\") {\n    const schemaPath = (0, codegen_1.str)(_templateObject23 || (_templateObject23 = _taggedTemplateLiteral([\"\", \"/$comment\"])), errSchemaPath);\n    const rootName = gen.scopeValue(\"root\", {\n      ref: schemaEnv.root\n    });\n    gen.code((0, codegen_1._)(_templateObject24 || (_templateObject24 = _taggedTemplateLiteral([\"\", \".opts.$comment(\", \", \", \", \", \".schema)\"])), names_1.default.self, msg, schemaPath, rootName));\n  }\n}\nfunction returnResults(it) {\n  const {\n    gen,\n    schemaEnv,\n    validateName,\n    ValidationError,\n    opts\n  } = it;\n  if (schemaEnv.$async) {\n    // TODO assign unevaluated\n    gen.if((0, codegen_1._)(_templateObject25 || (_templateObject25 = _taggedTemplateLiteral([\"\", \" === 0\"])), names_1.default.errors), () => gen.return(names_1.default.data), () => gen.throw((0, codegen_1._)(_templateObject26 || (_templateObject26 = _taggedTemplateLiteral([\"new \", \"(\", \")\"])), ValidationError, names_1.default.vErrors)));\n  } else {\n    gen.assign((0, codegen_1._)(_templateObject27 || (_templateObject27 = _taggedTemplateLiteral([\"\", \".errors\"])), validateName), names_1.default.vErrors);\n    if (opts.unevaluated) assignEvaluated(it);\n    gen.return((0, codegen_1._)(_templateObject28 || (_templateObject28 = _taggedTemplateLiteral([\"\", \" === 0\"])), names_1.default.errors));\n  }\n}\nfunction assignEvaluated(_ref4) {\n  let {\n    gen,\n    evaluated,\n    props,\n    items\n  } = _ref4;\n  if (props instanceof codegen_1.Name) gen.assign((0, codegen_1._)(_templateObject29 || (_templateObject29 = _taggedTemplateLiteral([\"\", \".props\"])), evaluated), props);\n  if (items instanceof codegen_1.Name) gen.assign((0, codegen_1._)(_templateObject30 || (_templateObject30 = _taggedTemplateLiteral([\"\", \".items\"])), evaluated), items);\n}\nfunction schemaKeywords(it, types, typeErrors, errsCount) {\n  const {\n    gen,\n    schema,\n    data,\n    allErrors,\n    opts,\n    self\n  } = it;\n  const {\n    RULES\n  } = self;\n  if (schema.$ref && (opts.ignoreKeywordsWithRef || !(0, util_1.schemaHasRulesButRef)(schema, RULES))) {\n    gen.block(() => keywordCode(it, \"$ref\", RULES.all.$ref.definition)); // TODO typecast\n    return;\n  }\n  if (!opts.jtd) checkStrictTypes(it, types);\n  gen.block(() => {\n    for (const group of RULES.rules) groupKeywords(group);\n    groupKeywords(RULES.post);\n  });\n  function groupKeywords(group) {\n    if (!(0, applicability_1.shouldUseGroup)(schema, group)) return;\n    if (group.type) {\n      gen.if((0, dataType_2.checkDataType)(group.type, data, opts.strictNumbers));\n      iterateKeywords(it, group);\n      if (types.length === 1 && types[0] === group.type && typeErrors) {\n        gen.else();\n        (0, dataType_2.reportTypeError)(it);\n      }\n      gen.endIf();\n    } else {\n      iterateKeywords(it, group);\n    }\n    // TODO make it \"ok\" call?\n    if (!allErrors) gen.if((0, codegen_1._)(_templateObject31 || (_templateObject31 = _taggedTemplateLiteral([\"\", \" === \", \"\"])), names_1.default.errors, errsCount || 0));\n  }\n}\nfunction iterateKeywords(it, group) {\n  const {\n    gen,\n    schema,\n    opts: {\n      useDefaults\n    }\n  } = it;\n  if (useDefaults) (0, defaults_1.assignDefaults)(it, group.type);\n  gen.block(() => {\n    for (const rule of group.rules) {\n      if ((0, applicability_1.shouldUseRule)(schema, rule)) {\n        keywordCode(it, rule.keyword, rule.definition, group.type);\n      }\n    }\n  });\n}\nfunction checkStrictTypes(it, types) {\n  if (it.schemaEnv.meta || !it.opts.strictTypes) return;\n  checkContextTypes(it, types);\n  if (!it.opts.allowUnionTypes) checkMultipleTypes(it, types);\n  checkKeywordTypes(it, it.dataTypes);\n}\nfunction checkContextTypes(it, types) {\n  if (!types.length) return;\n  if (!it.dataTypes.length) {\n    it.dataTypes = types;\n    return;\n  }\n  types.forEach(t => {\n    if (!includesType(it.dataTypes, t)) {\n      strictTypesError(it, \"type \\\"\".concat(t, \"\\\" not allowed by context \\\"\").concat(it.dataTypes.join(\",\"), \"\\\"\"));\n    }\n  });\n  narrowSchemaTypes(it, types);\n}\nfunction checkMultipleTypes(it, ts) {\n  if (ts.length > 1 && !(ts.length === 2 && ts.includes(\"null\"))) {\n    strictTypesError(it, \"use allowUnionTypes to allow union type keyword\");\n  }\n}\nfunction checkKeywordTypes(it, ts) {\n  const rules = it.self.RULES.all;\n  for (const keyword in rules) {\n    const rule = rules[keyword];\n    if (typeof rule == \"object\" && (0, applicability_1.shouldUseRule)(it.schema, rule)) {\n      const {\n        type\n      } = rule.definition;\n      if (type.length && !type.some(t => hasApplicableType(ts, t))) {\n        strictTypesError(it, \"missing type \\\"\".concat(type.join(\",\"), \"\\\" for keyword \\\"\").concat(keyword, \"\\\"\"));\n      }\n    }\n  }\n}\nfunction hasApplicableType(schTs, kwdT) {\n  return schTs.includes(kwdT) || kwdT === \"number\" && schTs.includes(\"integer\");\n}\nfunction includesType(ts, t) {\n  return ts.includes(t) || t === \"integer\" && ts.includes(\"number\");\n}\nfunction narrowSchemaTypes(it, withTypes) {\n  const ts = [];\n  for (const t of it.dataTypes) {\n    if (includesType(withTypes, t)) ts.push(t);else if (withTypes.includes(\"integer\") && t === \"number\") ts.push(\"integer\");\n  }\n  it.dataTypes = ts;\n}\nfunction strictTypesError(it, msg) {\n  const schemaPath = it.schemaEnv.baseId + it.errSchemaPath;\n  msg += \" at \\\"\".concat(schemaPath, \"\\\" (strictTypes)\");\n  (0, util_1.checkStrictMode)(it, msg, it.opts.strictTypes);\n}\nclass KeywordCxt {\n  constructor(it, def, keyword) {\n    (0, keyword_1.validateKeywordUsage)(it, def, keyword);\n    this.gen = it.gen;\n    this.allErrors = it.allErrors;\n    this.keyword = keyword;\n    this.data = it.data;\n    this.schema = it.schema[keyword];\n    this.$data = def.$data && it.opts.$data && this.schema && this.schema.$data;\n    this.schemaValue = (0, util_1.schemaRefOrVal)(it, this.schema, keyword, this.$data);\n    this.schemaType = def.schemaType;\n    this.parentSchema = it.schema;\n    this.params = {};\n    this.it = it;\n    this.def = def;\n    if (this.$data) {\n      this.schemaCode = it.gen.const(\"vSchema\", getData(this.$data, it));\n    } else {\n      this.schemaCode = this.schemaValue;\n      if (!(0, keyword_1.validSchemaType)(this.schema, def.schemaType, def.allowUndefined)) {\n        throw new Error(\"\".concat(keyword, \" value must be \").concat(JSON.stringify(def.schemaType)));\n      }\n    }\n    if (\"code\" in def ? def.trackErrors : def.errors !== false) {\n      this.errsCount = it.gen.const(\"_errs\", names_1.default.errors);\n    }\n  }\n  result(condition, successAction, failAction) {\n    this.failResult((0, codegen_1.not)(condition), successAction, failAction);\n  }\n  failResult(condition, successAction, failAction) {\n    this.gen.if(condition);\n    if (failAction) failAction();else this.error();\n    if (successAction) {\n      this.gen.else();\n      successAction();\n      if (this.allErrors) this.gen.endIf();\n    } else {\n      if (this.allErrors) this.gen.endIf();else this.gen.else();\n    }\n  }\n  pass(condition, failAction) {\n    this.failResult((0, codegen_1.not)(condition), undefined, failAction);\n  }\n  fail(condition) {\n    if (condition === undefined) {\n      this.error();\n      if (!this.allErrors) this.gen.if(false); // this branch will be removed by gen.optimize\n      return;\n    }\n    this.gen.if(condition);\n    this.error();\n    if (this.allErrors) this.gen.endIf();else this.gen.else();\n  }\n  fail$data(condition) {\n    if (!this.$data) return this.fail(condition);\n    const {\n      schemaCode\n    } = this;\n    this.fail((0, codegen_1._)(_templateObject32 || (_templateObject32 = _taggedTemplateLiteral([\"\", \" !== undefined && (\", \")\"])), schemaCode, (0, codegen_1.or)(this.invalid$data(), condition)));\n  }\n  error(append, errorParams, errorPaths) {\n    if (errorParams) {\n      this.setParams(errorParams);\n      this._error(append, errorPaths);\n      this.setParams({});\n      return;\n    }\n    this._error(append, errorPaths);\n  }\n  _error(append, errorPaths) {\n    ;\n    (append ? errors_1.reportExtraError : errors_1.reportError)(this, this.def.error, errorPaths);\n  }\n  $dataError() {\n    (0, errors_1.reportError)(this, this.def.$dataError || errors_1.keyword$DataError);\n  }\n  reset() {\n    if (this.errsCount === undefined) throw new Error('add \"trackErrors\" to keyword definition');\n    (0, errors_1.resetErrorsCount)(this.gen, this.errsCount);\n  }\n  ok(cond) {\n    if (!this.allErrors) this.gen.if(cond);\n  }\n  setParams(obj, assign) {\n    if (assign) Object.assign(this.params, obj);else this.params = obj;\n  }\n  block$data(valid, codeBlock) {\n    let $dataValid = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : codegen_1.nil;\n    this.gen.block(() => {\n      this.check$data(valid, $dataValid);\n      codeBlock();\n    });\n  }\n  check$data() {\n    let valid = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : codegen_1.nil;\n    let $dataValid = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : codegen_1.nil;\n    if (!this.$data) return;\n    const {\n      gen,\n      schemaCode,\n      schemaType,\n      def\n    } = this;\n    gen.if((0, codegen_1.or)((0, codegen_1._)(_templateObject33 || (_templateObject33 = _taggedTemplateLiteral([\"\", \" === undefined\"])), schemaCode), $dataValid));\n    if (valid !== codegen_1.nil) gen.assign(valid, true);\n    if (schemaType.length || def.validateSchema) {\n      gen.elseIf(this.invalid$data());\n      this.$dataError();\n      if (valid !== codegen_1.nil) gen.assign(valid, false);\n    }\n    gen.else();\n  }\n  invalid$data() {\n    const {\n      gen,\n      schemaCode,\n      schemaType,\n      def,\n      it\n    } = this;\n    return (0, codegen_1.or)(wrong$DataType(), invalid$DataSchema());\n    function wrong$DataType() {\n      if (schemaType.length) {\n        /* istanbul ignore if */\n        if (!(schemaCode instanceof codegen_1.Name)) throw new Error(\"ajv implementation error\");\n        const st = Array.isArray(schemaType) ? schemaType : [schemaType];\n        return (0, codegen_1._)(_templateObject34 || (_templateObject34 = _taggedTemplateLiteral([\"\", \"\"])), (0, dataType_2.checkDataTypes)(st, schemaCode, it.opts.strictNumbers, dataType_2.DataType.Wrong));\n      }\n      return codegen_1.nil;\n    }\n    function invalid$DataSchema() {\n      if (def.validateSchema) {\n        const validateSchemaRef = gen.scopeValue(\"validate$data\", {\n          ref: def.validateSchema\n        }); // TODO value.code for standalone\n        return (0, codegen_1._)(_templateObject35 || (_templateObject35 = _taggedTemplateLiteral([\"!\", \"(\", \")\"])), validateSchemaRef, schemaCode);\n      }\n      return codegen_1.nil;\n    }\n  }\n  subschema(appl, valid) {\n    const subschema = (0, subschema_1.getSubschema)(this.it, appl);\n    (0, subschema_1.extendSubschemaData)(subschema, this.it, appl);\n    (0, subschema_1.extendSubschemaMode)(subschema, appl);\n    const nextContext = _objectSpread(_objectSpread(_objectSpread({}, this.it), subschema), {}, {\n      items: undefined,\n      props: undefined\n    });\n    subschemaCode(nextContext, valid);\n    return nextContext;\n  }\n  mergeEvaluated(schemaCxt, toName) {\n    const {\n      it,\n      gen\n    } = this;\n    if (!it.opts.unevaluated) return;\n    if (it.props !== true && schemaCxt.props !== undefined) {\n      it.props = util_1.mergeEvaluated.props(gen, schemaCxt.props, it.props, toName);\n    }\n    if (it.items !== true && schemaCxt.items !== undefined) {\n      it.items = util_1.mergeEvaluated.items(gen, schemaCxt.items, it.items, toName);\n    }\n  }\n  mergeValidEvaluated(schemaCxt, valid) {\n    const {\n      it,\n      gen\n    } = this;\n    if (it.opts.unevaluated && (it.props !== true || it.items !== true)) {\n      gen.if(valid, () => this.mergeEvaluated(schemaCxt, codegen_1.Name));\n      return true;\n    }\n  }\n}\nexports.KeywordCxt = KeywordCxt;\nfunction keywordCode(it, keyword, def, ruleType) {\n  const cxt = new KeywordCxt(it, def, keyword);\n  if (\"code\" in def) {\n    def.code(cxt, ruleType);\n  } else if (cxt.$data && def.validate) {\n    (0, keyword_1.funcKeywordCode)(cxt, def);\n  } else if (\"macro\" in def) {\n    (0, keyword_1.macroKeywordCode)(cxt, def);\n  } else if (def.compile || def.validate) {\n    (0, keyword_1.funcKeywordCode)(cxt, def);\n  }\n}\nconst JSON_POINTER = /^\\/(?:[^~]|~0|~1)*$/;\nconst RELATIVE_JSON_POINTER = /^([0-9]+)(#|\\/(?:[^~]|~0|~1)*)?$/;\nfunction getData($data, _ref5) {\n  let {\n    dataLevel,\n    dataNames,\n    dataPathArr\n  } = _ref5;\n  let jsonPointer;\n  let data;\n  if ($data === \"\") return names_1.default.rootData;\n  if ($data[0] === \"/\") {\n    if (!JSON_POINTER.test($data)) throw new Error(\"Invalid JSON-pointer: \".concat($data));\n    jsonPointer = $data;\n    data = names_1.default.rootData;\n  } else {\n    const matches = RELATIVE_JSON_POINTER.exec($data);\n    if (!matches) throw new Error(\"Invalid JSON-pointer: \".concat($data));\n    const up = +matches[1];\n    jsonPointer = matches[2];\n    if (jsonPointer === \"#\") {\n      if (up >= dataLevel) throw new Error(errorMsg(\"property/index\", up));\n      return dataPathArr[dataLevel - up];\n    }\n    if (up > dataLevel) throw new Error(errorMsg(\"data\", up));\n    data = dataNames[dataLevel - up];\n    if (!jsonPointer) return data;\n  }\n  let expr = data;\n  const segments = jsonPointer.split(\"/\");\n  for (const segment of segments) {\n    if (segment) {\n      data = (0, codegen_1._)(_templateObject36 || (_templateObject36 = _taggedTemplateLiteral([\"\", \"\", \"\"])), data, (0, codegen_1.getProperty)((0, util_1.unescapeJsonPointer)(segment)));\n      expr = (0, codegen_1._)(_templateObject37 || (_templateObject37 = _taggedTemplateLiteral([\"\", \" && \", \"\"])), expr, data);\n    }\n  }\n  return expr;\n  function errorMsg(pointerType, up) {\n    return \"Cannot access \".concat(pointerType, \" \").concat(up, \" levels up, current level is \").concat(dataLevel);\n  }\n}\nexports.getData = getData;","map":{"version":3,"names":["boolSchema_1","require","dataType_1","applicability_1","dataType_2","defaults_1","keyword_1","subschema_1","codegen_1","names_1","resolve_1","util_1","errors_1","validateFunctionCode","it","isSchemaObj","checkKeywords","schemaCxtHasRules","topSchemaObjCode","validateFunction","topBoolOrEmptySchema","exports","_ref","body","gen","validateName","schema","schemaEnv","opts","code","es5","func","_","_templateObject","_taggedTemplateLiteral","default","data","valCxt","$async","_templateObject2","funcSourceUrl","destructureValCxtES5","_templateObject3","destructureValCxt","_templateObject4","instancePath","parentData","parentDataProperty","rootData","dynamicRef","_templateObject5","dynamicAnchors","nil","if","var","_templateObject6","_templateObject7","_templateObject8","_templateObject9","_templateObject0","_templateObject1","_templateObject10","_templateObject11","_templateObject12","$comment","commentKeyword","checkNoDefault","let","vErrors","errors","unevaluated","resetEvaluated","typeAndKeywords","returnResults","evaluated","const","_templateObject13","_templateObject14","assign","_templateObject15","_templateObject16","_templateObject17","_templateObject18","_templateObject19","schId","schemaId","source","process","_templateObject20","subschemaCode","valid","subSchemaObjCode","boolOrEmptySchema","_ref2","self","key","RULES","all","updateContext","checkAsyncSchema","errsCount","_templateObject21","checkUnknownRules","checkRefsAndKeywords","jtd","schemaKeywords","types","getSchemaTypes","checkedTypes","coerceAndCheckDataType","errSchemaPath","$ref","ignoreKeywordsWithRef","schemaHasRulesButRef","logger","warn","concat","undefined","useDefaults","strictSchema","checkStrictMode","baseId","resolveUrl","uriResolver","Error","_ref3","msg","_templateObject22","schemaPath","str","_templateObject23","rootName","scopeValue","ref","root","_templateObject24","ValidationError","_templateObject25","return","throw","_templateObject26","_templateObject27","assignEvaluated","_templateObject28","_ref4","props","items","Name","_templateObject29","_templateObject30","typeErrors","allErrors","block","keywordCode","definition","checkStrictTypes","group","rules","groupKeywords","post","shouldUseGroup","type","checkDataType","strictNumbers","iterateKeywords","length","else","reportTypeError","endIf","_templateObject31","assignDefaults","rule","shouldUseRule","keyword","meta","strictTypes","checkContextTypes","allowUnionTypes","checkMultipleTypes","checkKeywordTypes","dataTypes","forEach","t","includesType","strictTypesError","join","narrowSchemaTypes","ts","includes","some","hasApplicableType","schTs","kwdT","withTypes","push","KeywordCxt","constructor","def","validateKeywordUsage","$data","schemaValue","schemaRefOrVal","schemaType","parentSchema","params","schemaCode","getData","validSchemaType","allowUndefined","JSON","stringify","trackErrors","result","condition","successAction","failAction","failResult","not","error","pass","fail","fail$data","_templateObject32","or","invalid$data","append","errorParams","errorPaths","setParams","_error","reportExtraError","reportError","$dataError","keyword$DataError","reset","resetErrorsCount","ok","cond","obj","Object","block$data","codeBlock","$dataValid","arguments","check$data","_templateObject33","validateSchema","elseIf","wrong$DataType","invalid$DataSchema","st","Array","isArray","_templateObject34","checkDataTypes","DataType","Wrong","validateSchemaRef","_templateObject35","subschema","appl","getSubschema","extendSubschemaData","extendSubschemaMode","nextContext","_objectSpread","mergeEvaluated","schemaCxt","toName","mergeValidEvaluated","ruleType","cxt","validate","funcKeywordCode","macroKeywordCode","compile","JSON_POINTER","RELATIVE_JSON_POINTER","_ref5","dataLevel","dataNames","dataPathArr","jsonPointer","test","matches","exec","up","errorMsg","expr","segments","split","segment","_templateObject36","getProperty","unescapeJsonPointer","_templateObject37","pointerType"],"sources":["/home/runner/work/sgex/sgex/node_modules/ajv/lib/compile/validate/index.ts"],"sourcesContent":["import type {\n  AddedKeywordDefinition,\n  AnySchema,\n  AnySchemaObject,\n  KeywordErrorCxt,\n  KeywordCxtParams,\n} from \"../../types\"\nimport type {SchemaCxt, SchemaObjCxt} from \"..\"\nimport type {InstanceOptions} from \"../../core\"\nimport {boolOrEmptySchema, topBoolOrEmptySchema} from \"./boolSchema\"\nimport {coerceAndCheckDataType, getSchemaTypes} from \"./dataType\"\nimport {shouldUseGroup, shouldUseRule} from \"./applicability\"\nimport {checkDataType, checkDataTypes, reportTypeError, DataType} from \"./dataType\"\nimport {assignDefaults} from \"./defaults\"\nimport {funcKeywordCode, macroKeywordCode, validateKeywordUsage, validSchemaType} from \"./keyword\"\nimport {getSubschema, extendSubschemaData, SubschemaArgs, extendSubschemaMode} from \"./subschema\"\nimport {_, nil, str, or, not, getProperty, Block, Code, Name, CodeGen} from \"../codegen\"\nimport N from \"../names\"\nimport {resolveUrl} from \"../resolve\"\nimport {\n  schemaRefOrVal,\n  schemaHasRulesButRef,\n  checkUnknownRules,\n  checkStrictMode,\n  unescapeJsonPointer,\n  mergeEvaluated,\n} from \"../util\"\nimport type {JSONType, Rule, RuleGroup} from \"../rules\"\nimport {\n  ErrorPaths,\n  reportError,\n  reportExtraError,\n  resetErrorsCount,\n  keyword$DataError,\n} from \"../errors\"\n\n// schema compilation - generates validation function, subschemaCode (below) is used for subschemas\nexport function validateFunctionCode(it: SchemaCxt): void {\n  if (isSchemaObj(it)) {\n    checkKeywords(it)\n    if (schemaCxtHasRules(it)) {\n      topSchemaObjCode(it)\n      return\n    }\n  }\n  validateFunction(it, () => topBoolOrEmptySchema(it))\n}\n\nfunction validateFunction(\n  {gen, validateName, schema, schemaEnv, opts}: SchemaCxt,\n  body: Block\n): void {\n  if (opts.code.es5) {\n    gen.func(validateName, _`${N.data}, ${N.valCxt}`, schemaEnv.$async, () => {\n      gen.code(_`\"use strict\"; ${funcSourceUrl(schema, opts)}`)\n      destructureValCxtES5(gen, opts)\n      gen.code(body)\n    })\n  } else {\n    gen.func(validateName, _`${N.data}, ${destructureValCxt(opts)}`, schemaEnv.$async, () =>\n      gen.code(funcSourceUrl(schema, opts)).code(body)\n    )\n  }\n}\n\nfunction destructureValCxt(opts: InstanceOptions): Code {\n  return _`{${N.instancePath}=\"\", ${N.parentData}, ${N.parentDataProperty}, ${N.rootData}=${\n    N.data\n  }${opts.dynamicRef ? _`, ${N.dynamicAnchors}={}` : nil}}={}`\n}\n\nfunction destructureValCxtES5(gen: CodeGen, opts: InstanceOptions): void {\n  gen.if(\n    N.valCxt,\n    () => {\n      gen.var(N.instancePath, _`${N.valCxt}.${N.instancePath}`)\n      gen.var(N.parentData, _`${N.valCxt}.${N.parentData}`)\n      gen.var(N.parentDataProperty, _`${N.valCxt}.${N.parentDataProperty}`)\n      gen.var(N.rootData, _`${N.valCxt}.${N.rootData}`)\n      if (opts.dynamicRef) gen.var(N.dynamicAnchors, _`${N.valCxt}.${N.dynamicAnchors}`)\n    },\n    () => {\n      gen.var(N.instancePath, _`\"\"`)\n      gen.var(N.parentData, _`undefined`)\n      gen.var(N.parentDataProperty, _`undefined`)\n      gen.var(N.rootData, N.data)\n      if (opts.dynamicRef) gen.var(N.dynamicAnchors, _`{}`)\n    }\n  )\n}\n\nfunction topSchemaObjCode(it: SchemaObjCxt): void {\n  const {schema, opts, gen} = it\n  validateFunction(it, () => {\n    if (opts.$comment && schema.$comment) commentKeyword(it)\n    checkNoDefault(it)\n    gen.let(N.vErrors, null)\n    gen.let(N.errors, 0)\n    if (opts.unevaluated) resetEvaluated(it)\n    typeAndKeywords(it)\n    returnResults(it)\n  })\n  return\n}\n\nfunction resetEvaluated(it: SchemaObjCxt): void {\n  // TODO maybe some hook to execute it in the end to check whether props/items are Name, as in assignEvaluated\n  const {gen, validateName} = it\n  it.evaluated = gen.const(\"evaluated\", _`${validateName}.evaluated`)\n  gen.if(_`${it.evaluated}.dynamicProps`, () => gen.assign(_`${it.evaluated}.props`, _`undefined`))\n  gen.if(_`${it.evaluated}.dynamicItems`, () => gen.assign(_`${it.evaluated}.items`, _`undefined`))\n}\n\nfunction funcSourceUrl(schema: AnySchema, opts: InstanceOptions): Code {\n  const schId = typeof schema == \"object\" && schema[opts.schemaId]\n  return schId && (opts.code.source || opts.code.process) ? _`/*# sourceURL=${schId} */` : nil\n}\n\n// schema compilation - this function is used recursively to generate code for sub-schemas\nfunction subschemaCode(it: SchemaCxt, valid: Name): void {\n  if (isSchemaObj(it)) {\n    checkKeywords(it)\n    if (schemaCxtHasRules(it)) {\n      subSchemaObjCode(it, valid)\n      return\n    }\n  }\n  boolOrEmptySchema(it, valid)\n}\n\nfunction schemaCxtHasRules({schema, self}: SchemaCxt): boolean {\n  if (typeof schema == \"boolean\") return !schema\n  for (const key in schema) if (self.RULES.all[key]) return true\n  return false\n}\n\nfunction isSchemaObj(it: SchemaCxt): it is SchemaObjCxt {\n  return typeof it.schema != \"boolean\"\n}\n\nfunction subSchemaObjCode(it: SchemaObjCxt, valid: Name): void {\n  const {schema, gen, opts} = it\n  if (opts.$comment && schema.$comment) commentKeyword(it)\n  updateContext(it)\n  checkAsyncSchema(it)\n  const errsCount = gen.const(\"_errs\", N.errors)\n  typeAndKeywords(it, errsCount)\n  // TODO var\n  gen.var(valid, _`${errsCount} === ${N.errors}`)\n}\n\nfunction checkKeywords(it: SchemaObjCxt): void {\n  checkUnknownRules(it)\n  checkRefsAndKeywords(it)\n}\n\nfunction typeAndKeywords(it: SchemaObjCxt, errsCount?: Name): void {\n  if (it.opts.jtd) return schemaKeywords(it, [], false, errsCount)\n  const types = getSchemaTypes(it.schema)\n  const checkedTypes = coerceAndCheckDataType(it, types)\n  schemaKeywords(it, types, !checkedTypes, errsCount)\n}\n\nfunction checkRefsAndKeywords(it: SchemaObjCxt): void {\n  const {schema, errSchemaPath, opts, self} = it\n  if (schema.$ref && opts.ignoreKeywordsWithRef && schemaHasRulesButRef(schema, self.RULES)) {\n    self.logger.warn(`$ref: keywords ignored in schema at path \"${errSchemaPath}\"`)\n  }\n}\n\nfunction checkNoDefault(it: SchemaObjCxt): void {\n  const {schema, opts} = it\n  if (schema.default !== undefined && opts.useDefaults && opts.strictSchema) {\n    checkStrictMode(it, \"default is ignored in the schema root\")\n  }\n}\n\nfunction updateContext(it: SchemaObjCxt): void {\n  const schId = it.schema[it.opts.schemaId]\n  if (schId) it.baseId = resolveUrl(it.opts.uriResolver, it.baseId, schId)\n}\n\nfunction checkAsyncSchema(it: SchemaObjCxt): void {\n  if (it.schema.$async && !it.schemaEnv.$async) throw new Error(\"async schema in sync schema\")\n}\n\nfunction commentKeyword({gen, schemaEnv, schema, errSchemaPath, opts}: SchemaObjCxt): void {\n  const msg = schema.$comment\n  if (opts.$comment === true) {\n    gen.code(_`${N.self}.logger.log(${msg})`)\n  } else if (typeof opts.$comment == \"function\") {\n    const schemaPath = str`${errSchemaPath}/$comment`\n    const rootName = gen.scopeValue(\"root\", {ref: schemaEnv.root})\n    gen.code(_`${N.self}.opts.$comment(${msg}, ${schemaPath}, ${rootName}.schema)`)\n  }\n}\n\nfunction returnResults(it: SchemaCxt): void {\n  const {gen, schemaEnv, validateName, ValidationError, opts} = it\n  if (schemaEnv.$async) {\n    // TODO assign unevaluated\n    gen.if(\n      _`${N.errors} === 0`,\n      () => gen.return(N.data),\n      () => gen.throw(_`new ${ValidationError as Name}(${N.vErrors})`)\n    )\n  } else {\n    gen.assign(_`${validateName}.errors`, N.vErrors)\n    if (opts.unevaluated) assignEvaluated(it)\n    gen.return(_`${N.errors} === 0`)\n  }\n}\n\nfunction assignEvaluated({gen, evaluated, props, items}: SchemaCxt): void {\n  if (props instanceof Name) gen.assign(_`${evaluated}.props`, props)\n  if (items instanceof Name) gen.assign(_`${evaluated}.items`, items)\n}\n\nfunction schemaKeywords(\n  it: SchemaObjCxt,\n  types: JSONType[],\n  typeErrors: boolean,\n  errsCount?: Name\n): void {\n  const {gen, schema, data, allErrors, opts, self} = it\n  const {RULES} = self\n  if (schema.$ref && (opts.ignoreKeywordsWithRef || !schemaHasRulesButRef(schema, RULES))) {\n    gen.block(() => keywordCode(it, \"$ref\", (RULES.all.$ref as Rule).definition)) // TODO typecast\n    return\n  }\n  if (!opts.jtd) checkStrictTypes(it, types)\n  gen.block(() => {\n    for (const group of RULES.rules) groupKeywords(group)\n    groupKeywords(RULES.post)\n  })\n\n  function groupKeywords(group: RuleGroup): void {\n    if (!shouldUseGroup(schema, group)) return\n    if (group.type) {\n      gen.if(checkDataType(group.type, data, opts.strictNumbers))\n      iterateKeywords(it, group)\n      if (types.length === 1 && types[0] === group.type && typeErrors) {\n        gen.else()\n        reportTypeError(it)\n      }\n      gen.endIf()\n    } else {\n      iterateKeywords(it, group)\n    }\n    // TODO make it \"ok\" call?\n    if (!allErrors) gen.if(_`${N.errors} === ${errsCount || 0}`)\n  }\n}\n\nfunction iterateKeywords(it: SchemaObjCxt, group: RuleGroup): void {\n  const {\n    gen,\n    schema,\n    opts: {useDefaults},\n  } = it\n  if (useDefaults) assignDefaults(it, group.type)\n  gen.block(() => {\n    for (const rule of group.rules) {\n      if (shouldUseRule(schema, rule)) {\n        keywordCode(it, rule.keyword, rule.definition, group.type)\n      }\n    }\n  })\n}\n\nfunction checkStrictTypes(it: SchemaObjCxt, types: JSONType[]): void {\n  if (it.schemaEnv.meta || !it.opts.strictTypes) return\n  checkContextTypes(it, types)\n  if (!it.opts.allowUnionTypes) checkMultipleTypes(it, types)\n  checkKeywordTypes(it, it.dataTypes)\n}\n\nfunction checkContextTypes(it: SchemaObjCxt, types: JSONType[]): void {\n  if (!types.length) return\n  if (!it.dataTypes.length) {\n    it.dataTypes = types\n    return\n  }\n  types.forEach((t) => {\n    if (!includesType(it.dataTypes, t)) {\n      strictTypesError(it, `type \"${t}\" not allowed by context \"${it.dataTypes.join(\",\")}\"`)\n    }\n  })\n  narrowSchemaTypes(it, types)\n}\n\nfunction checkMultipleTypes(it: SchemaObjCxt, ts: JSONType[]): void {\n  if (ts.length > 1 && !(ts.length === 2 && ts.includes(\"null\"))) {\n    strictTypesError(it, \"use allowUnionTypes to allow union type keyword\")\n  }\n}\n\nfunction checkKeywordTypes(it: SchemaObjCxt, ts: JSONType[]): void {\n  const rules = it.self.RULES.all\n  for (const keyword in rules) {\n    const rule = rules[keyword]\n    if (typeof rule == \"object\" && shouldUseRule(it.schema, rule)) {\n      const {type} = rule.definition\n      if (type.length && !type.some((t) => hasApplicableType(ts, t))) {\n        strictTypesError(it, `missing type \"${type.join(\",\")}\" for keyword \"${keyword}\"`)\n      }\n    }\n  }\n}\n\nfunction hasApplicableType(schTs: JSONType[], kwdT: JSONType): boolean {\n  return schTs.includes(kwdT) || (kwdT === \"number\" && schTs.includes(\"integer\"))\n}\n\nfunction includesType(ts: JSONType[], t: JSONType): boolean {\n  return ts.includes(t) || (t === \"integer\" && ts.includes(\"number\"))\n}\n\nfunction narrowSchemaTypes(it: SchemaObjCxt, withTypes: JSONType[]): void {\n  const ts: JSONType[] = []\n  for (const t of it.dataTypes) {\n    if (includesType(withTypes, t)) ts.push(t)\n    else if (withTypes.includes(\"integer\") && t === \"number\") ts.push(\"integer\")\n  }\n  it.dataTypes = ts\n}\n\nfunction strictTypesError(it: SchemaObjCxt, msg: string): void {\n  const schemaPath = it.schemaEnv.baseId + it.errSchemaPath\n  msg += ` at \"${schemaPath}\" (strictTypes)`\n  checkStrictMode(it, msg, it.opts.strictTypes)\n}\n\nexport class KeywordCxt implements KeywordErrorCxt {\n  readonly gen: CodeGen\n  readonly allErrors?: boolean\n  readonly keyword: string\n  readonly data: Name // Name referencing the current level of the data instance\n  readonly $data?: string | false\n  schema: any // keyword value in the schema\n  readonly schemaValue: Code | number | boolean // Code reference to keyword schema value or primitive value\n  readonly schemaCode: Code | number | boolean // Code reference to resolved schema value (different if schema is $data)\n  readonly schemaType: JSONType[] // allowed type(s) of keyword value in the schema\n  readonly parentSchema: AnySchemaObject\n  readonly errsCount?: Name // Name reference to the number of validation errors collected before this keyword,\n  // requires option trackErrors in keyword definition\n  params: KeywordCxtParams // object to pass parameters to error messages from keyword code\n  readonly it: SchemaObjCxt // schema compilation context (schema is guaranteed to be an object, not boolean)\n  readonly def: AddedKeywordDefinition\n\n  constructor(it: SchemaObjCxt, def: AddedKeywordDefinition, keyword: string) {\n    validateKeywordUsage(it, def, keyword)\n    this.gen = it.gen\n    this.allErrors = it.allErrors\n    this.keyword = keyword\n    this.data = it.data\n    this.schema = it.schema[keyword]\n    this.$data = def.$data && it.opts.$data && this.schema && this.schema.$data\n    this.schemaValue = schemaRefOrVal(it, this.schema, keyword, this.$data)\n    this.schemaType = def.schemaType\n    this.parentSchema = it.schema\n    this.params = {}\n    this.it = it\n    this.def = def\n\n    if (this.$data) {\n      this.schemaCode = it.gen.const(\"vSchema\", getData(this.$data, it))\n    } else {\n      this.schemaCode = this.schemaValue\n      if (!validSchemaType(this.schema, def.schemaType, def.allowUndefined)) {\n        throw new Error(`${keyword} value must be ${JSON.stringify(def.schemaType)}`)\n      }\n    }\n\n    if (\"code\" in def ? def.trackErrors : def.errors !== false) {\n      this.errsCount = it.gen.const(\"_errs\", N.errors)\n    }\n  }\n\n  result(condition: Code, successAction?: () => void, failAction?: () => void): void {\n    this.failResult(not(condition), successAction, failAction)\n  }\n\n  failResult(condition: Code, successAction?: () => void, failAction?: () => void): void {\n    this.gen.if(condition)\n    if (failAction) failAction()\n    else this.error()\n    if (successAction) {\n      this.gen.else()\n      successAction()\n      if (this.allErrors) this.gen.endIf()\n    } else {\n      if (this.allErrors) this.gen.endIf()\n      else this.gen.else()\n    }\n  }\n\n  pass(condition: Code, failAction?: () => void): void {\n    this.failResult(not(condition), undefined, failAction)\n  }\n\n  fail(condition?: Code): void {\n    if (condition === undefined) {\n      this.error()\n      if (!this.allErrors) this.gen.if(false) // this branch will be removed by gen.optimize\n      return\n    }\n    this.gen.if(condition)\n    this.error()\n    if (this.allErrors) this.gen.endIf()\n    else this.gen.else()\n  }\n\n  fail$data(condition: Code): void {\n    if (!this.$data) return this.fail(condition)\n    const {schemaCode} = this\n    this.fail(_`${schemaCode} !== undefined && (${or(this.invalid$data(), condition)})`)\n  }\n\n  error(append?: boolean, errorParams?: KeywordCxtParams, errorPaths?: ErrorPaths): void {\n    if (errorParams) {\n      this.setParams(errorParams)\n      this._error(append, errorPaths)\n      this.setParams({})\n      return\n    }\n    this._error(append, errorPaths)\n  }\n\n  private _error(append?: boolean, errorPaths?: ErrorPaths): void {\n    ;(append ? reportExtraError : reportError)(this, this.def.error, errorPaths)\n  }\n\n  $dataError(): void {\n    reportError(this, this.def.$dataError || keyword$DataError)\n  }\n\n  reset(): void {\n    if (this.errsCount === undefined) throw new Error('add \"trackErrors\" to keyword definition')\n    resetErrorsCount(this.gen, this.errsCount)\n  }\n\n  ok(cond: Code | boolean): void {\n    if (!this.allErrors) this.gen.if(cond)\n  }\n\n  setParams(obj: KeywordCxtParams, assign?: true): void {\n    if (assign) Object.assign(this.params, obj)\n    else this.params = obj\n  }\n\n  block$data(valid: Name, codeBlock: () => void, $dataValid: Code = nil): void {\n    this.gen.block(() => {\n      this.check$data(valid, $dataValid)\n      codeBlock()\n    })\n  }\n\n  check$data(valid: Name = nil, $dataValid: Code = nil): void {\n    if (!this.$data) return\n    const {gen, schemaCode, schemaType, def} = this\n    gen.if(or(_`${schemaCode} === undefined`, $dataValid))\n    if (valid !== nil) gen.assign(valid, true)\n    if (schemaType.length || def.validateSchema) {\n      gen.elseIf(this.invalid$data())\n      this.$dataError()\n      if (valid !== nil) gen.assign(valid, false)\n    }\n    gen.else()\n  }\n\n  invalid$data(): Code {\n    const {gen, schemaCode, schemaType, def, it} = this\n    return or(wrong$DataType(), invalid$DataSchema())\n\n    function wrong$DataType(): Code {\n      if (schemaType.length) {\n        /* istanbul ignore if */\n        if (!(schemaCode instanceof Name)) throw new Error(\"ajv implementation error\")\n        const st = Array.isArray(schemaType) ? schemaType : [schemaType]\n        return _`${checkDataTypes(st, schemaCode, it.opts.strictNumbers, DataType.Wrong)}`\n      }\n      return nil\n    }\n\n    function invalid$DataSchema(): Code {\n      if (def.validateSchema) {\n        const validateSchemaRef = gen.scopeValue(\"validate$data\", {ref: def.validateSchema}) // TODO value.code for standalone\n        return _`!${validateSchemaRef}(${schemaCode})`\n      }\n      return nil\n    }\n  }\n\n  subschema(appl: SubschemaArgs, valid: Name): SchemaCxt {\n    const subschema = getSubschema(this.it, appl)\n    extendSubschemaData(subschema, this.it, appl)\n    extendSubschemaMode(subschema, appl)\n    const nextContext = {...this.it, ...subschema, items: undefined, props: undefined}\n    subschemaCode(nextContext, valid)\n    return nextContext\n  }\n\n  mergeEvaluated(schemaCxt: SchemaCxt, toName?: typeof Name): void {\n    const {it, gen} = this\n    if (!it.opts.unevaluated) return\n    if (it.props !== true && schemaCxt.props !== undefined) {\n      it.props = mergeEvaluated.props(gen, schemaCxt.props, it.props, toName)\n    }\n    if (it.items !== true && schemaCxt.items !== undefined) {\n      it.items = mergeEvaluated.items(gen, schemaCxt.items, it.items, toName)\n    }\n  }\n\n  mergeValidEvaluated(schemaCxt: SchemaCxt, valid: Name): boolean | void {\n    const {it, gen} = this\n    if (it.opts.unevaluated && (it.props !== true || it.items !== true)) {\n      gen.if(valid, () => this.mergeEvaluated(schemaCxt, Name))\n      return true\n    }\n  }\n}\n\nfunction keywordCode(\n  it: SchemaObjCxt,\n  keyword: string,\n  def: AddedKeywordDefinition,\n  ruleType?: JSONType\n): void {\n  const cxt = new KeywordCxt(it, def, keyword)\n  if (\"code\" in def) {\n    def.code(cxt, ruleType)\n  } else if (cxt.$data && def.validate) {\n    funcKeywordCode(cxt, def)\n  } else if (\"macro\" in def) {\n    macroKeywordCode(cxt, def)\n  } else if (def.compile || def.validate) {\n    funcKeywordCode(cxt, def)\n  }\n}\n\nconst JSON_POINTER = /^\\/(?:[^~]|~0|~1)*$/\nconst RELATIVE_JSON_POINTER = /^([0-9]+)(#|\\/(?:[^~]|~0|~1)*)?$/\nexport function getData(\n  $data: string,\n  {dataLevel, dataNames, dataPathArr}: SchemaCxt\n): Code | number {\n  let jsonPointer\n  let data: Code\n  if ($data === \"\") return N.rootData\n  if ($data[0] === \"/\") {\n    if (!JSON_POINTER.test($data)) throw new Error(`Invalid JSON-pointer: ${$data}`)\n    jsonPointer = $data\n    data = N.rootData\n  } else {\n    const matches = RELATIVE_JSON_POINTER.exec($data)\n    if (!matches) throw new Error(`Invalid JSON-pointer: ${$data}`)\n    const up: number = +matches[1]\n    jsonPointer = matches[2]\n    if (jsonPointer === \"#\") {\n      if (up >= dataLevel) throw new Error(errorMsg(\"property/index\", up))\n      return dataPathArr[dataLevel - up]\n    }\n    if (up > dataLevel) throw new Error(errorMsg(\"data\", up))\n    data = dataNames[dataLevel - up]\n    if (!jsonPointer) return data\n  }\n\n  let expr = data\n  const segments = jsonPointer.split(\"/\")\n  for (const segment of segments) {\n    if (segment) {\n      data = _`${data}${getProperty(unescapeJsonPointer(segment))}`\n      expr = _`${expr} && ${data}`\n    }\n  }\n  return expr\n\n  function errorMsg(pointerType: string, up: number): string {\n    return `Cannot access ${pointerType} ${up} levels up, current level is ${dataLevel}`\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}