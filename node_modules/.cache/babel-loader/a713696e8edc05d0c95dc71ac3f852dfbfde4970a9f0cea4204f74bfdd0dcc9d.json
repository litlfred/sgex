{"ast":null,"code":"import { getDistancePointPoint, rotateVector, getAngle } from './GeometricUtil';\nimport { getAttachment } from './LineAttachmentUtil';\nimport { roundPoint } from 'diagram-js/lib/layout/LayoutUtil';\n\n/**\n * @typedef {import('diagram-js/lib/util/Types').Point} Point\n *\n * @typedef {import('./LineAttachmentUtil').Attachment} Attachment\n *\n * @typedef { {\n *   point: Point;\n *   delta: Point;\n * } } AnchorPointAdjustment\n *\n * @typedef { {\n *   segmentMove?: {\n*     segmentStartIndex: number;\n*     newSegmentStartIndex: number;\n*   };\n*   bendpointMove?: {\n*     insert: boolean;\n*     bendpointIndex: number;\n*   };\n*   connectionStart: boolean;\n*   connectionEnd: boolean;\n* } } FindNewLineStartIndexHints\n */\n\n/**\n * @param {Point[]} oldWaypoints\n * @param {Point[]} newWaypoints\n * @param {Attachment} attachment\n * @param {FindNewLineStartIndexHints} hints\n *\n * @return {number}\n */\nexport function findNewLineStartIndex(oldWaypoints, newWaypoints, attachment, hints) {\n  var index = attachment.segmentIndex;\n  var offset = newWaypoints.length - oldWaypoints.length;\n\n  // segmentMove happened\n  if (hints.segmentMove) {\n    var oldSegmentStartIndex = hints.segmentMove.segmentStartIndex,\n      newSegmentStartIndex = hints.segmentMove.newSegmentStartIndex;\n\n    // if point was on moved segment return new segment index\n    if (index === oldSegmentStartIndex) {\n      return newSegmentStartIndex;\n    }\n\n    // point is after new segment index\n    if (index >= newSegmentStartIndex) {\n      return index + offset < newSegmentStartIndex ? newSegmentStartIndex : index + offset;\n    }\n\n    // if point is before new segment index\n    return index;\n  }\n\n  // bendpointMove happened\n  if (hints.bendpointMove) {\n    var insert = hints.bendpointMove.insert,\n      bendpointIndex = hints.bendpointMove.bendpointIndex,\n      newIndex;\n\n    // waypoints length didnt change\n    if (offset === 0) {\n      return index;\n    }\n\n    // point behind new/removed bendpoint\n    if (index >= bendpointIndex) {\n      newIndex = insert ? index + 1 : index - 1;\n    }\n\n    // point before new/removed bendpoint\n    if (index < bendpointIndex) {\n      newIndex = index;\n\n      // decide point should take right or left segment\n      if (insert && attachment.type !== 'bendpoint' && bendpointIndex - 1 === index) {\n        var rel = relativePositionMidWaypoint(newWaypoints, bendpointIndex);\n        if (rel < attachment.relativeLocation) {\n          newIndex++;\n        }\n      }\n    }\n    return newIndex;\n  }\n\n  // start/end changed\n  if (offset === 0) {\n    return index;\n  }\n  if (hints.connectionStart && index === 0) {\n    return 0;\n  }\n  if (hints.connectionEnd && index === oldWaypoints.length - 2) {\n    return newWaypoints.length - 2;\n  }\n\n  // if nothing fits, take the middle segment\n  return Math.floor((newWaypoints.length - 2) / 2);\n}\n\n/**\n * Calculate the required adjustment (move delta) for the given point\n * after the connection waypoints got updated.\n *\n * @param {Point} position\n * @param {Point[]} newWaypoints\n * @param {Point[]} oldWaypoints\n * @param {FindNewLineStartIndexHints} hints\n *\n * @return {AnchorPointAdjustment} result\n */\nexport function getAnchorPointAdjustment(position, newWaypoints, oldWaypoints, hints) {\n  var dx = 0,\n    dy = 0;\n  var oldPosition = {\n    point: position,\n    delta: {\n      x: 0,\n      y: 0\n    }\n  };\n\n  // get closest attachment\n  var attachment = getAttachment(position, oldWaypoints),\n    oldLabelLineIndex = attachment.segmentIndex,\n    newLabelLineIndex = findNewLineStartIndex(oldWaypoints, newWaypoints, attachment, hints);\n\n  // should never happen\n  // TODO(@janstuemmel): throw an error here when connectionSegmentMove is refactored\n  if (newLabelLineIndex < 0 || newLabelLineIndex > newWaypoints.length - 2 || newLabelLineIndex === null) {\n    return oldPosition;\n  }\n  var oldLabelLine = getLine(oldWaypoints, oldLabelLineIndex),\n    newLabelLine = getLine(newWaypoints, newLabelLineIndex),\n    oldFoot = attachment.position;\n  var relativeFootPosition = getRelativeFootPosition(oldLabelLine, oldFoot),\n    angleDelta = getAngleDelta(oldLabelLine, newLabelLine);\n\n  // special rule if label on bendpoint\n  if (attachment.type === 'bendpoint') {\n    var offset = newWaypoints.length - oldWaypoints.length,\n      oldBendpointIndex = attachment.bendpointIndex,\n      oldBendpoint = oldWaypoints[oldBendpointIndex];\n\n    // bendpoint position hasn't changed, return same position\n    if (newWaypoints.indexOf(oldBendpoint) !== -1) {\n      return oldPosition;\n    }\n\n    // new bendpoint and old bendpoint have same index, then just return the offset\n    if (offset === 0) {\n      var newBendpoint = newWaypoints[oldBendpointIndex];\n      dx = newBendpoint.x - attachment.position.x, dy = newBendpoint.y - attachment.position.y;\n      return {\n        delta: {\n          x: dx,\n          y: dy\n        },\n        point: {\n          x: position.x + dx,\n          y: position.y + dy\n        }\n      };\n    }\n\n    // if bendpoints get removed\n    if (offset < 0 && oldBendpointIndex !== 0 && oldBendpointIndex < oldWaypoints.length - 1) {\n      relativeFootPosition = relativePositionMidWaypoint(oldWaypoints, oldBendpointIndex);\n    }\n  }\n  var newFoot = {\n    x: (newLabelLine[1].x - newLabelLine[0].x) * relativeFootPosition + newLabelLine[0].x,\n    y: (newLabelLine[1].y - newLabelLine[0].y) * relativeFootPosition + newLabelLine[0].y\n  };\n\n  // the rotated vector to label\n  var newLabelVector = rotateVector({\n    x: position.x - oldFoot.x,\n    y: position.y - oldFoot.y\n  }, angleDelta);\n\n  // the new relative position\n  dx = newFoot.x + newLabelVector.x - position.x;\n  dy = newFoot.y + newLabelVector.y - position.y;\n  return {\n    point: roundPoint(newFoot),\n    delta: roundPoint({\n      x: dx,\n      y: dy\n    })\n  };\n}\n\n// HELPERS //////////////////////\n\nfunction relativePositionMidWaypoint(waypoints, idx) {\n  var distanceSegment1 = getDistancePointPoint(waypoints[idx - 1], waypoints[idx]),\n    distanceSegment2 = getDistancePointPoint(waypoints[idx], waypoints[idx + 1]);\n  var relativePosition = distanceSegment1 / (distanceSegment1 + distanceSegment2);\n  return relativePosition;\n}\nfunction getAngleDelta(l1, l2) {\n  var a1 = getAngle(l1),\n    a2 = getAngle(l2);\n  return a2 - a1;\n}\nfunction getLine(waypoints, idx) {\n  return [waypoints[idx], waypoints[idx + 1]];\n}\nfunction getRelativeFootPosition(line, foot) {\n  var length = getDistancePointPoint(line[0], line[1]),\n    lengthToFoot = getDistancePointPoint(line[0], foot);\n  return length === 0 ? 0 : lengthToFoot / length;\n}","map":{"version":3,"names":["getDistancePointPoint","rotateVector","getAngle","getAttachment","roundPoint","findNewLineStartIndex","oldWaypoints","newWaypoints","attachment","hints","index","segmentIndex","offset","length","segmentMove","oldSegmentStartIndex","segmentStartIndex","newSegmentStartIndex","bendpointMove","insert","bendpointIndex","newIndex","type","rel","relativePositionMidWaypoint","relativeLocation","connectionStart","connectionEnd","Math","floor","getAnchorPointAdjustment","position","dx","dy","oldPosition","point","delta","x","y","oldLabelLineIndex","newLabelLineIndex","oldLabelLine","getLine","newLabelLine","oldFoot","relativeFootPosition","getRelativeFootPosition","angleDelta","getAngleDelta","oldBendpointIndex","oldBendpoint","indexOf","newBendpoint","newFoot","newLabelVector","waypoints","idx","distanceSegment1","distanceSegment2","relativePosition","l1","l2","a1","a2","line","foot","lengthToFoot"],"sources":["/home/runner/work/sgex/sgex/node_modules/bpmn-js/lib/features/modeling/behavior/util/LayoutUtil.js"],"sourcesContent":["import {\n  getDistancePointPoint,\n  rotateVector,\n  getAngle\n} from './GeometricUtil';\n\nimport {\n  getAttachment\n} from './LineAttachmentUtil';\n\nimport {\n  roundPoint\n} from 'diagram-js/lib/layout/LayoutUtil';\n\n/**\n * @typedef {import('diagram-js/lib/util/Types').Point} Point\n *\n * @typedef {import('./LineAttachmentUtil').Attachment} Attachment\n *\n * @typedef { {\n *   point: Point;\n *   delta: Point;\n * } } AnchorPointAdjustment\n *\n * @typedef { {\n *   segmentMove?: {\n*     segmentStartIndex: number;\n*     newSegmentStartIndex: number;\n*   };\n*   bendpointMove?: {\n*     insert: boolean;\n*     bendpointIndex: number;\n*   };\n*   connectionStart: boolean;\n*   connectionEnd: boolean;\n* } } FindNewLineStartIndexHints\n */\n\n/**\n * @param {Point[]} oldWaypoints\n * @param {Point[]} newWaypoints\n * @param {Attachment} attachment\n * @param {FindNewLineStartIndexHints} hints\n *\n * @return {number}\n */\nexport function findNewLineStartIndex(oldWaypoints, newWaypoints, attachment, hints) {\n\n  var index = attachment.segmentIndex;\n\n  var offset = newWaypoints.length - oldWaypoints.length;\n\n  // segmentMove happened\n  if (hints.segmentMove) {\n\n    var oldSegmentStartIndex = hints.segmentMove.segmentStartIndex,\n        newSegmentStartIndex = hints.segmentMove.newSegmentStartIndex;\n\n    // if point was on moved segment return new segment index\n    if (index === oldSegmentStartIndex) {\n      return newSegmentStartIndex;\n    }\n\n    // point is after new segment index\n    if (index >= newSegmentStartIndex) {\n      return (index + offset < newSegmentStartIndex) ? newSegmentStartIndex : index + offset;\n    }\n\n    // if point is before new segment index\n    return index;\n  }\n\n  // bendpointMove happened\n  if (hints.bendpointMove) {\n\n    var insert = hints.bendpointMove.insert,\n        bendpointIndex = hints.bendpointMove.bendpointIndex,\n        newIndex;\n\n    // waypoints length didnt change\n    if (offset === 0) {\n      return index;\n    }\n\n    // point behind new/removed bendpoint\n    if (index >= bendpointIndex) {\n      newIndex = insert ? index + 1 : index - 1;\n    }\n\n    // point before new/removed bendpoint\n    if (index < bendpointIndex) {\n\n      newIndex = index;\n\n      // decide point should take right or left segment\n      if (insert && attachment.type !== 'bendpoint' && bendpointIndex - 1 === index) {\n\n        var rel = relativePositionMidWaypoint(newWaypoints, bendpointIndex);\n\n        if (rel < attachment.relativeLocation) {\n          newIndex++;\n        }\n      }\n    }\n\n    return newIndex;\n  }\n\n  // start/end changed\n  if (offset === 0) {\n    return index;\n  }\n\n  if (hints.connectionStart && index === 0) {\n    return 0;\n  }\n\n  if (hints.connectionEnd && index === oldWaypoints.length - 2) {\n    return newWaypoints.length - 2;\n  }\n\n  // if nothing fits, take the middle segment\n  return Math.floor((newWaypoints.length - 2) / 2);\n}\n\n\n/**\n * Calculate the required adjustment (move delta) for the given point\n * after the connection waypoints got updated.\n *\n * @param {Point} position\n * @param {Point[]} newWaypoints\n * @param {Point[]} oldWaypoints\n * @param {FindNewLineStartIndexHints} hints\n *\n * @return {AnchorPointAdjustment} result\n */\nexport function getAnchorPointAdjustment(position, newWaypoints, oldWaypoints, hints) {\n\n  var dx = 0,\n      dy = 0;\n\n  var oldPosition = {\n    point: position,\n    delta: { x: 0, y: 0 }\n  };\n\n  // get closest attachment\n  var attachment = getAttachment(position, oldWaypoints),\n      oldLabelLineIndex = attachment.segmentIndex,\n      newLabelLineIndex = findNewLineStartIndex(oldWaypoints, newWaypoints, attachment, hints);\n\n\n  // should never happen\n  // TODO(@janstuemmel): throw an error here when connectionSegmentMove is refactored\n  if (newLabelLineIndex < 0 ||\n      newLabelLineIndex > newWaypoints.length - 2 ||\n      newLabelLineIndex === null) {\n    return oldPosition;\n  }\n\n  var oldLabelLine = getLine(oldWaypoints, oldLabelLineIndex),\n      newLabelLine = getLine(newWaypoints, newLabelLineIndex),\n      oldFoot = attachment.position;\n\n  var relativeFootPosition = getRelativeFootPosition(oldLabelLine, oldFoot),\n      angleDelta = getAngleDelta(oldLabelLine, newLabelLine);\n\n  // special rule if label on bendpoint\n  if (attachment.type === 'bendpoint') {\n\n    var offset = newWaypoints.length - oldWaypoints.length,\n        oldBendpointIndex = attachment.bendpointIndex,\n        oldBendpoint = oldWaypoints[oldBendpointIndex];\n\n    // bendpoint position hasn't changed, return same position\n    if (newWaypoints.indexOf(oldBendpoint) !== -1) {\n      return oldPosition;\n    }\n\n    // new bendpoint and old bendpoint have same index, then just return the offset\n    if (offset === 0) {\n      var newBendpoint = newWaypoints[oldBendpointIndex];\n\n      dx = newBendpoint.x - attachment.position.x,\n      dy = newBendpoint.y - attachment.position.y;\n\n      return {\n        delta: {\n          x: dx,\n          y: dy\n        },\n        point: {\n          x: position.x + dx,\n          y: position.y + dy\n        }\n      };\n    }\n\n    // if bendpoints get removed\n    if (offset < 0 && oldBendpointIndex !== 0 && oldBendpointIndex < oldWaypoints.length - 1) {\n      relativeFootPosition = relativePositionMidWaypoint(oldWaypoints, oldBendpointIndex);\n    }\n  }\n\n  var newFoot = {\n    x: (newLabelLine[1].x - newLabelLine[0].x) * relativeFootPosition + newLabelLine[0].x,\n    y: (newLabelLine[1].y - newLabelLine[0].y) * relativeFootPosition + newLabelLine[0].y\n  };\n\n  // the rotated vector to label\n  var newLabelVector = rotateVector({\n    x: position.x - oldFoot.x,\n    y: position.y - oldFoot.y\n  }, angleDelta);\n\n  // the new relative position\n  dx = newFoot.x + newLabelVector.x - position.x;\n  dy = newFoot.y + newLabelVector.y - position.y;\n\n  return {\n    point: roundPoint(newFoot),\n    delta: roundPoint({\n      x: dx,\n      y: dy\n    })\n  };\n}\n\n\n// HELPERS //////////////////////\n\nfunction relativePositionMidWaypoint(waypoints, idx) {\n\n  var distanceSegment1 = getDistancePointPoint(waypoints[idx - 1], waypoints[idx]),\n      distanceSegment2 = getDistancePointPoint(waypoints[idx], waypoints[idx + 1]);\n\n  var relativePosition = distanceSegment1 / (distanceSegment1 + distanceSegment2);\n\n  return relativePosition;\n}\n\nfunction getAngleDelta(l1, l2) {\n  var a1 = getAngle(l1),\n      a2 = getAngle(l2);\n  return a2 - a1;\n}\n\nfunction getLine(waypoints, idx) {\n  return [ waypoints[idx], waypoints[idx + 1] ];\n}\n\nfunction getRelativeFootPosition(line, foot) {\n\n  var length = getDistancePointPoint(line[0], line[1]),\n      lengthToFoot = getDistancePointPoint(line[0], foot);\n\n  return length === 0 ? 0 : lengthToFoot / length;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}