{"ast":null,"code":"import { assign, forEach } from 'min-dash';\nimport inherits from 'inherits-browser';\nimport { add as collectionAdd, remove as collectionRemove } from 'diagram-js/lib/util/Collections';\nimport { getBusinessObject, getDi, is } from '../../util/ModelUtil';\nimport { isAny } from './util/ModelingUtil';\nimport { getLabel, isLabel, isLabelExternal } from '../../util/LabelUtil';\nimport { isPlane } from '../../util/DrilldownUtil';\nimport { delta } from 'diagram-js/lib/util/PositionUtil';\nimport CommandInterceptor from 'diagram-js/lib/command/CommandInterceptor';\n\n/**\n * @typedef {import('diagram-js/lib/core/EventBus').default} EventBus\n * @typedef {import('./BpmnFactory').default} BpmnFactory\n * @typedef {import('diagram-js/lib/layout/CroppingConnectionDocking').default} CroppingConnectionDocking\n *\n * @typedef {import('../../model/Types').Connection} Connection\n * @typedef {import('../../model/Types').Element} Element\n * @typedef {import('../../model/Types').Shape} Shape\n * @typedef {import('../../model/Types').Parent} Parent\n * @typedef {import('../../model/Types').ModdleElement} ModdleElement\n */\n\n/**\n * A handler responsible for updating the underlying BPMN 2.0 XML & DI\n * once changes on the diagram happen.\n *\n * @param {EventBus} eventBus\n * @param {BpmnFactory} bpmnFactory\n * @param {CroppingConnectionDocking} connectionDocking\n */\nexport default function BpmnUpdater(eventBus, bpmnFactory, connectionDocking) {\n  CommandInterceptor.call(this, eventBus);\n  this._bpmnFactory = bpmnFactory;\n  var self = this;\n\n  // connection cropping //////////////////////\n\n  // crop connection ends during create/update\n  function cropConnection(e) {\n    var context = e.context,\n      hints = context.hints || {},\n      connection;\n    if (!context.cropped && hints.createElementsBehavior !== false) {\n      connection = context.connection;\n      connection.waypoints = connectionDocking.getCroppedWaypoints(connection);\n      context.cropped = true;\n    }\n  }\n  this.executed(['connection.layout', 'connection.create'], cropConnection);\n  this.reverted(['connection.layout'], function (e) {\n    delete e.context.cropped;\n  });\n\n  // BPMN + DI update //////////////////////\n\n  // update parent\n  function updateParent(e) {\n    var context = e.context;\n    self.updateParent(context.shape || context.connection, context.oldParent);\n  }\n  function reverseUpdateParent(e) {\n    var context = e.context;\n    var element = context.shape || context.connection,\n      // oldParent is the (old) new parent, because we are undoing\n      oldParent = context.parent || context.newParent;\n    self.updateParent(element, oldParent);\n  }\n  this.executed(['shape.move', 'shape.create', 'shape.delete', 'connection.create', 'connection.move', 'connection.delete'], ifBpmn(updateParent));\n  this.reverted(['shape.move', 'shape.create', 'shape.delete', 'connection.create', 'connection.move', 'connection.delete'], ifBpmn(reverseUpdateParent));\n\n  /*\n   * ## Updating Parent\n   *\n   * When morphing a Process into a Collaboration or vice-versa,\n   * make sure that both the *semantic* and *di* parent of each element\n   * is updated.\n   *\n   */\n  function updateRoot(event) {\n    var context = event.context,\n      oldRoot = context.oldRoot,\n      children = oldRoot.children;\n    forEach(children, function (child) {\n      if (is(child, 'bpmn:BaseElement')) {\n        self.updateParent(child);\n      }\n    });\n  }\n  this.executed(['canvas.updateRoot'], updateRoot);\n  this.reverted(['canvas.updateRoot'], updateRoot);\n\n  // update bounds\n  function updateBounds(e) {\n    var shape = e.context.shape;\n    if (!is(shape, 'bpmn:BaseElement')) {\n      return;\n    }\n    self.updateBounds(shape);\n  }\n  this.executed(['shape.move', 'shape.create', 'shape.resize'], ifBpmn(function (event) {\n    // exclude labels because they're handled separately during shape.changed\n    if (event.context.shape.type === 'label') {\n      return;\n    }\n    updateBounds(event);\n  }));\n  this.reverted(['shape.move', 'shape.create', 'shape.resize'], ifBpmn(function (event) {\n    // exclude labels because they're handled separately during shape.changed\n    if (event.context.shape.type === 'label') {\n      return;\n    }\n    updateBounds(event);\n  }));\n\n  // Handle labels separately. This is necessary, because the label bounds have to be updated\n  // every time its shape changes, not only on move, create and resize.\n  eventBus.on('shape.changed', function (event) {\n    if (event.element.type === 'label') {\n      updateBounds({\n        context: {\n          shape: event.element\n        }\n      });\n    }\n  });\n\n  // attach / detach connection\n  function updateConnection(e) {\n    self.updateConnection(e.context);\n  }\n  this.executed(['connection.create', 'connection.move', 'connection.delete', 'connection.reconnect'], ifBpmn(updateConnection));\n  this.reverted(['connection.create', 'connection.move', 'connection.delete', 'connection.reconnect'], ifBpmn(updateConnection));\n\n  // update waypoints\n  function updateConnectionWaypoints(e) {\n    self.updateConnectionWaypoints(e.context.connection);\n  }\n  this.executed(['connection.layout', 'connection.move', 'connection.updateWaypoints'], ifBpmn(updateConnectionWaypoints));\n  this.reverted(['connection.layout', 'connection.move', 'connection.updateWaypoints'], ifBpmn(updateConnectionWaypoints));\n\n  // update conditional/default flows\n  this.executed('connection.reconnect', ifBpmn(function (event) {\n    var context = event.context,\n      connection = context.connection,\n      oldSource = context.oldSource,\n      newSource = context.newSource,\n      connectionBo = getBusinessObject(connection),\n      oldSourceBo = getBusinessObject(oldSource),\n      newSourceBo = getBusinessObject(newSource);\n\n    // remove condition from connection on reconnect to new source\n    // if new source can NOT have condional sequence flow\n    if (connectionBo.conditionExpression && !isAny(newSourceBo, ['bpmn:Activity', 'bpmn:ExclusiveGateway', 'bpmn:InclusiveGateway'])) {\n      context.oldConditionExpression = connectionBo.conditionExpression;\n      delete connectionBo.conditionExpression;\n    }\n\n    // remove default from old source flow on reconnect to new source\n    // if source changed\n    if (oldSource !== newSource && oldSourceBo.default === connectionBo) {\n      context.oldDefault = oldSourceBo.default;\n      delete oldSourceBo.default;\n    }\n  }));\n  this.reverted('connection.reconnect', ifBpmn(function (event) {\n    var context = event.context,\n      connection = context.connection,\n      oldSource = context.oldSource,\n      newSource = context.newSource,\n      connectionBo = getBusinessObject(connection),\n      oldSourceBo = getBusinessObject(oldSource),\n      newSourceBo = getBusinessObject(newSource);\n\n    // add condition to connection on revert reconnect to new source\n    if (context.oldConditionExpression) {\n      connectionBo.conditionExpression = context.oldConditionExpression;\n    }\n\n    // add default to old source on revert reconnect to new source\n    if (context.oldDefault) {\n      oldSourceBo.default = context.oldDefault;\n      delete newSourceBo.default;\n    }\n  }));\n\n  // update attachments\n  function updateAttachment(e) {\n    self.updateAttachment(e.context);\n  }\n  this.executed(['element.updateAttachment'], ifBpmn(updateAttachment));\n  this.reverted(['element.updateAttachment'], ifBpmn(updateAttachment));\n\n  // update BPMNLabel\n  this.executed('element.updateLabel', ifBpmn(updateBPMNLabel));\n  this.reverted('element.updateLabel', ifBpmn(updateBPMNLabel));\n  function updateBPMNLabel(event) {\n    const {\n        element\n      } = event.context,\n      label = getLabel(element);\n    const di = getDi(element),\n      diLabel = di && di.get('label');\n    if (isLabelExternal(element) || isPlane(element)) {\n      return;\n    }\n    if (label && !diLabel) {\n      di.set('label', bpmnFactory.create('bpmndi:BPMNLabel'));\n    } else if (!label && diLabel) {\n      di.set('label', undefined);\n    }\n  }\n}\ninherits(BpmnUpdater, CommandInterceptor);\nBpmnUpdater.$inject = ['eventBus', 'bpmnFactory', 'connectionDocking'];\n\n// implementation //////////////////////\n\n/**\n * @param { {\n *   shape: Shape;\n *   host: Shape;\n * } } context\n */\nBpmnUpdater.prototype.updateAttachment = function (context) {\n  var shape = context.shape,\n    businessObject = shape.businessObject,\n    host = shape.host;\n  businessObject.attachedToRef = host && host.businessObject;\n};\n\n/**\n * @param {Element} element\n * @param {Parent} oldParent\n */\nBpmnUpdater.prototype.updateParent = function (element, oldParent) {\n  // do not update BPMN 2.0 label parent\n  if (isLabel(element)) {\n    return;\n  }\n\n  // data stores in collaborations are handled separately by DataStoreBehavior\n  if (is(element, 'bpmn:DataStoreReference') && element.parent && is(element.parent, 'bpmn:Collaboration')) {\n    return;\n  }\n  var parentShape = element.parent;\n  var businessObject = element.businessObject,\n    di = getDi(element),\n    parentBusinessObject = parentShape && parentShape.businessObject,\n    parentDi = getDi(parentShape);\n  if (is(element, 'bpmn:FlowNode')) {\n    this.updateFlowNodeRefs(businessObject, parentBusinessObject, oldParent && oldParent.businessObject);\n  }\n  if (is(element, 'bpmn:DataOutputAssociation')) {\n    if (element.source) {\n      parentBusinessObject = element.source.businessObject;\n    } else {\n      parentBusinessObject = null;\n    }\n  }\n  if (is(element, 'bpmn:DataInputAssociation')) {\n    if (element.target) {\n      parentBusinessObject = element.target.businessObject;\n    } else {\n      parentBusinessObject = null;\n    }\n  }\n  this.updateSemanticParent(businessObject, parentBusinessObject);\n  if (is(element, 'bpmn:DataObjectReference') && businessObject.dataObjectRef) {\n    this.updateSemanticParent(businessObject.dataObjectRef, parentBusinessObject);\n  }\n  this.updateDiParent(di, parentDi);\n};\n\n/**\n * @param {Shape} shape\n */\nBpmnUpdater.prototype.updateBounds = function (shape) {\n  var di = getDi(shape),\n    embeddedLabelBounds = getEmbeddedLabelBounds(shape);\n\n  // update embedded label bounds if possible\n  if (embeddedLabelBounds) {\n    var embeddedLabelBoundsDelta = delta(embeddedLabelBounds, di.get('bounds'));\n    assign(embeddedLabelBounds, {\n      x: shape.x + embeddedLabelBoundsDelta.x,\n      y: shape.y + embeddedLabelBoundsDelta.y\n    });\n  }\n  var target = isLabel(shape) ? this._getLabel(di) : di;\n  var bounds = target.bounds;\n  if (!bounds) {\n    bounds = this._bpmnFactory.createDiBounds();\n    target.set('bounds', bounds);\n  }\n  assign(bounds, {\n    x: shape.x,\n    y: shape.y,\n    width: shape.width,\n    height: shape.height\n  });\n};\n\n/**\n * @param {ModdleElement} businessObject\n * @param {ModdleElement} newContainment\n * @param {ModdleElement} oldContainment\n */\nBpmnUpdater.prototype.updateFlowNodeRefs = function (businessObject, newContainment, oldContainment) {\n  if (oldContainment === newContainment) {\n    return;\n  }\n  var oldRefs, newRefs;\n  if (is(oldContainment, 'bpmn:Lane')) {\n    oldRefs = oldContainment.get('flowNodeRef');\n    collectionRemove(oldRefs, businessObject);\n  }\n  if (is(newContainment, 'bpmn:Lane')) {\n    newRefs = newContainment.get('flowNodeRef');\n    collectionAdd(newRefs, businessObject);\n  }\n};\n\n/**\n * @param {Connection} connection\n * @param {Element} newSource\n * @param {Element} newTarget\n */\nBpmnUpdater.prototype.updateDiConnection = function (connection, newSource, newTarget) {\n  var connectionDi = getDi(connection),\n    newSourceDi = getDi(newSource),\n    newTargetDi = getDi(newTarget);\n  if (connectionDi.sourceElement && connectionDi.sourceElement.bpmnElement !== getBusinessObject(newSource)) {\n    connectionDi.sourceElement = newSource && newSourceDi;\n  }\n  if (connectionDi.targetElement && connectionDi.targetElement.bpmnElement !== getBusinessObject(newTarget)) {\n    connectionDi.targetElement = newTarget && newTargetDi;\n  }\n};\n\n/**\n * @param {ModdleElement} di\n * @param {ModdleElement} parentDi\n */\nBpmnUpdater.prototype.updateDiParent = function (di, parentDi) {\n  if (parentDi && !is(parentDi, 'bpmndi:BPMNPlane')) {\n    parentDi = parentDi.$parent;\n  }\n  if (di.$parent === parentDi) {\n    return;\n  }\n  var planeElements = (parentDi || di.$parent).get('planeElement');\n  if (parentDi) {\n    planeElements.push(di);\n    di.$parent = parentDi;\n  } else {\n    collectionRemove(planeElements, di);\n    di.$parent = null;\n  }\n};\n\n/**\n * @param {ModdleElement} element\n *\n * @return {ModdleElement}\n */\nfunction getDefinitions(element) {\n  while (element && !is(element, 'bpmn:Definitions')) {\n    element = element.$parent;\n  }\n  return element;\n}\n\n/**\n * @param {ModdleElement} container\n *\n * @return {ModdleElement}\n */\nBpmnUpdater.prototype.getLaneSet = function (container) {\n  var laneSet, laneSets;\n\n  // bpmn:Lane\n  if (is(container, 'bpmn:Lane')) {\n    laneSet = container.childLaneSet;\n    if (!laneSet) {\n      laneSet = this._bpmnFactory.create('bpmn:LaneSet');\n      container.childLaneSet = laneSet;\n      laneSet.$parent = container;\n    }\n    return laneSet;\n  }\n\n  // bpmn:Participant\n  if (is(container, 'bpmn:Participant')) {\n    container = container.processRef;\n  }\n\n  // bpmn:FlowElementsContainer\n  laneSets = container.get('laneSets');\n  laneSet = laneSets[0];\n  if (!laneSet) {\n    laneSet = this._bpmnFactory.create('bpmn:LaneSet');\n    laneSet.$parent = container;\n    laneSets.push(laneSet);\n  }\n  return laneSet;\n};\n\n/**\n * @param {ModdleElement} businessObject\n * @param {ModdleElement} newParent\n * @param {ModdleElement} visualParent\n */\nBpmnUpdater.prototype.updateSemanticParent = function (businessObject, newParent, visualParent) {\n  var containment;\n  if (businessObject.$parent === newParent) {\n    return;\n  }\n  if (is(businessObject, 'bpmn:DataInput') || is(businessObject, 'bpmn:DataOutput')) {\n    if (is(newParent, 'bpmn:Participant') && 'processRef' in newParent) {\n      newParent = newParent.processRef;\n    }\n\n    // already in correct ioSpecification\n    if ('ioSpecification' in newParent && newParent.ioSpecification === businessObject.$parent) {\n      return;\n    }\n  }\n  if (is(businessObject, 'bpmn:Lane')) {\n    if (newParent) {\n      newParent = this.getLaneSet(newParent);\n    }\n    containment = 'lanes';\n  } else if (is(businessObject, 'bpmn:FlowElement')) {\n    if (newParent) {\n      if (is(newParent, 'bpmn:Participant')) {\n        newParent = newParent.processRef;\n      } else if (is(newParent, 'bpmn:Lane')) {\n        do {\n          // unwrap Lane -> LaneSet -> (Lane | FlowElementsContainer)\n          newParent = newParent.$parent.$parent;\n        } while (is(newParent, 'bpmn:Lane'));\n      }\n    }\n    containment = 'flowElements';\n  } else if (is(businessObject, 'bpmn:Artifact')) {\n    while (newParent && !is(newParent, 'bpmn:Process') && !is(newParent, 'bpmn:SubProcess') && !is(newParent, 'bpmn:Collaboration')) {\n      if (is(newParent, 'bpmn:Participant')) {\n        newParent = newParent.processRef;\n        break;\n      } else {\n        newParent = newParent.$parent;\n      }\n    }\n    containment = 'artifacts';\n  } else if (is(businessObject, 'bpmn:MessageFlow')) {\n    containment = 'messageFlows';\n  } else if (is(businessObject, 'bpmn:Participant')) {\n    containment = 'participants';\n\n    // make sure the participants process is properly attached / detached\n    // from the XML document\n\n    var process = businessObject.processRef,\n      definitions;\n    if (process) {\n      definitions = getDefinitions(businessObject.$parent || newParent);\n      if (businessObject.$parent) {\n        collectionRemove(definitions.get('rootElements'), process);\n        process.$parent = null;\n      }\n      if (newParent) {\n        collectionAdd(definitions.get('rootElements'), process);\n        process.$parent = definitions;\n      }\n    }\n  } else if (is(businessObject, 'bpmn:DataOutputAssociation')) {\n    containment = 'dataOutputAssociations';\n  } else if (is(businessObject, 'bpmn:DataInputAssociation')) {\n    containment = 'dataInputAssociations';\n  }\n  if (!containment) {\n    throw new Error(\"no parent for <\".concat(businessObject.id, \"> in <\").concat(newParent.id, \">\"));\n  }\n  var children;\n  if (businessObject.$parent) {\n    // remove from old parent\n    children = businessObject.$parent.get(containment);\n    collectionRemove(children, businessObject);\n  }\n  if (!newParent) {\n    businessObject.$parent = null;\n  } else {\n    // add to new parent\n    children = newParent.get(containment);\n    children.push(businessObject);\n    businessObject.$parent = newParent;\n  }\n  if (visualParent) {\n    var diChildren = visualParent.get(containment);\n    collectionRemove(children, businessObject);\n    if (newParent) {\n      if (!diChildren) {\n        diChildren = [];\n        newParent.set(containment, diChildren);\n      }\n      diChildren.push(businessObject);\n    }\n  }\n};\n\n/**\n * @param {Connection} connection\n */\nBpmnUpdater.prototype.updateConnectionWaypoints = function (connection) {\n  var di = getDi(connection);\n  di.set('waypoint', this._bpmnFactory.createDiWaypoints(connection.waypoints));\n};\n\n/**\n * @param { {\n *   connection: Connection;\n *   parent: Parent;\n *   newParent: Parent;\n * } } context\n */\nBpmnUpdater.prototype.updateConnection = function (context) {\n  var connection = context.connection,\n    businessObject = getBusinessObject(connection),\n    newSource = connection.source,\n    newSourceBo = getBusinessObject(newSource),\n    newTarget = connection.target,\n    newTargetBo = getBusinessObject(connection.target),\n    visualParent;\n  if (!is(businessObject, 'bpmn:DataAssociation')) {\n    var inverseSet = is(businessObject, 'bpmn:SequenceFlow');\n    if (businessObject.sourceRef !== newSourceBo) {\n      if (inverseSet) {\n        collectionRemove(businessObject.sourceRef && businessObject.sourceRef.get('outgoing'), businessObject);\n        if (newSourceBo && newSourceBo.get('outgoing')) {\n          newSourceBo.get('outgoing').push(businessObject);\n        }\n      }\n      businessObject.sourceRef = newSourceBo;\n    }\n    if (businessObject.targetRef !== newTargetBo) {\n      if (inverseSet) {\n        collectionRemove(businessObject.targetRef && businessObject.targetRef.get('incoming'), businessObject);\n        if (newTargetBo && newTargetBo.get('incoming')) {\n          newTargetBo.get('incoming').push(businessObject);\n        }\n      }\n      businessObject.targetRef = newTargetBo;\n    }\n  } else if (is(businessObject, 'bpmn:DataInputAssociation')) {\n    // handle obnoxious isMsome sourceRef\n    businessObject.get('sourceRef')[0] = newSourceBo;\n    visualParent = context.parent || context.newParent || newTargetBo;\n    this.updateSemanticParent(businessObject, newTargetBo, visualParent);\n  } else if (is(businessObject, 'bpmn:DataOutputAssociation')) {\n    visualParent = context.parent || context.newParent || newSourceBo;\n    this.updateSemanticParent(businessObject, newSourceBo, visualParent);\n\n    // targetRef = new target\n    businessObject.targetRef = newTargetBo;\n  }\n  this.updateConnectionWaypoints(connection);\n  this.updateDiConnection(connection, newSource, newTarget);\n};\n\n// helpers //////////////////////\n\nBpmnUpdater.prototype._getLabel = function (di) {\n  if (!di.label) {\n    di.label = this._bpmnFactory.createDiLabel();\n  }\n  return di.label;\n};\n\n/**\n * Call function if shape or connection is BPMN element.\n *\n * @param  {Function} fn\n *\n * @return {Function}\n */\nfunction ifBpmn(fn) {\n  return function (event) {\n    var context = event.context,\n      element = context.shape || context.connection || context.element;\n    if (is(element, 'bpmn:BaseElement')) {\n      fn(event);\n    }\n  };\n}\n\n/**\n * Return dc:Bounds of bpmndi:BPMNLabel if exists.\n *\n * @param {Shape} shape\n *\n * @return {ModdleElement|undefined}\n */\nfunction getEmbeddedLabelBounds(shape) {\n  if (!is(shape, 'bpmn:Activity')) {\n    return;\n  }\n  var di = getDi(shape);\n  if (!di) {\n    return;\n  }\n  var label = di.get('label');\n  if (!label) {\n    return;\n  }\n  return label.get('bounds');\n}","map":{"version":3,"names":["assign","forEach","inherits","add","collectionAdd","remove","collectionRemove","getBusinessObject","getDi","is","isAny","getLabel","isLabel","isLabelExternal","isPlane","delta","CommandInterceptor","BpmnUpdater","eventBus","bpmnFactory","connectionDocking","call","_bpmnFactory","self","cropConnection","e","context","hints","connection","cropped","createElementsBehavior","waypoints","getCroppedWaypoints","executed","reverted","updateParent","shape","oldParent","reverseUpdateParent","element","parent","newParent","ifBpmn","updateRoot","event","oldRoot","children","child","updateBounds","type","on","updateConnection","updateConnectionWaypoints","oldSource","newSource","connectionBo","oldSourceBo","newSourceBo","conditionExpression","oldConditionExpression","default","oldDefault","updateAttachment","updateBPMNLabel","label","di","diLabel","get","set","create","undefined","$inject","prototype","businessObject","host","attachedToRef","parentShape","parentBusinessObject","parentDi","updateFlowNodeRefs","source","target","updateSemanticParent","dataObjectRef","updateDiParent","embeddedLabelBounds","getEmbeddedLabelBounds","embeddedLabelBoundsDelta","x","y","_getLabel","bounds","createDiBounds","width","height","newContainment","oldContainment","oldRefs","newRefs","updateDiConnection","newTarget","connectionDi","newSourceDi","newTargetDi","sourceElement","bpmnElement","targetElement","$parent","planeElements","push","getDefinitions","getLaneSet","container","laneSet","laneSets","childLaneSet","processRef","visualParent","containment","ioSpecification","process","definitions","Error","concat","id","diChildren","createDiWaypoints","newTargetBo","inverseSet","sourceRef","targetRef","createDiLabel","fn"],"sources":["/home/runner/work/sgex/sgex/node_modules/bpmn-js/lib/features/modeling/BpmnUpdater.js"],"sourcesContent":["import {\n  assign,\n  forEach\n} from 'min-dash';\n\nimport inherits from 'inherits-browser';\n\nimport {\n  add as collectionAdd,\n  remove as collectionRemove\n} from 'diagram-js/lib/util/Collections';\n\nimport {\n  getBusinessObject,\n  getDi,\n  is\n} from '../../util/ModelUtil';\n\nimport { isAny } from './util/ModelingUtil';\n\nimport {\n  getLabel,\n  isLabel,\n  isLabelExternal\n} from '../../util/LabelUtil';\n\nimport { isPlane } from '../../util/DrilldownUtil';\n\nimport { delta } from 'diagram-js/lib/util/PositionUtil';\n\nimport CommandInterceptor from 'diagram-js/lib/command/CommandInterceptor';\n\n/**\n * @typedef {import('diagram-js/lib/core/EventBus').default} EventBus\n * @typedef {import('./BpmnFactory').default} BpmnFactory\n * @typedef {import('diagram-js/lib/layout/CroppingConnectionDocking').default} CroppingConnectionDocking\n *\n * @typedef {import('../../model/Types').Connection} Connection\n * @typedef {import('../../model/Types').Element} Element\n * @typedef {import('../../model/Types').Shape} Shape\n * @typedef {import('../../model/Types').Parent} Parent\n * @typedef {import('../../model/Types').ModdleElement} ModdleElement\n */\n\n/**\n * A handler responsible for updating the underlying BPMN 2.0 XML & DI\n * once changes on the diagram happen.\n *\n * @param {EventBus} eventBus\n * @param {BpmnFactory} bpmnFactory\n * @param {CroppingConnectionDocking} connectionDocking\n */\nexport default function BpmnUpdater(\n    eventBus,\n    bpmnFactory,\n    connectionDocking\n) {\n\n  CommandInterceptor.call(this, eventBus);\n\n  this._bpmnFactory = bpmnFactory;\n\n  var self = this;\n\n\n  // connection cropping //////////////////////\n\n  // crop connection ends during create/update\n  function cropConnection(e) {\n    var context = e.context,\n        hints = context.hints || {},\n        connection;\n\n    if (!context.cropped && hints.createElementsBehavior !== false) {\n      connection = context.connection;\n      connection.waypoints = connectionDocking.getCroppedWaypoints(connection);\n      context.cropped = true;\n    }\n  }\n\n  this.executed([\n    'connection.layout',\n    'connection.create'\n  ], cropConnection);\n\n  this.reverted([ 'connection.layout' ], function(e) {\n    delete e.context.cropped;\n  });\n\n\n\n  // BPMN + DI update //////////////////////\n\n\n  // update parent\n  function updateParent(e) {\n    var context = e.context;\n\n    self.updateParent(context.shape || context.connection, context.oldParent);\n  }\n\n  function reverseUpdateParent(e) {\n    var context = e.context;\n\n    var element = context.shape || context.connection,\n\n        // oldParent is the (old) new parent, because we are undoing\n        oldParent = context.parent || context.newParent;\n\n    self.updateParent(element, oldParent);\n  }\n\n  this.executed([\n    'shape.move',\n    'shape.create',\n    'shape.delete',\n    'connection.create',\n    'connection.move',\n    'connection.delete'\n  ], ifBpmn(updateParent));\n\n  this.reverted([\n    'shape.move',\n    'shape.create',\n    'shape.delete',\n    'connection.create',\n    'connection.move',\n    'connection.delete'\n  ], ifBpmn(reverseUpdateParent));\n\n  /*\n   * ## Updating Parent\n   *\n   * When morphing a Process into a Collaboration or vice-versa,\n   * make sure that both the *semantic* and *di* parent of each element\n   * is updated.\n   *\n   */\n  function updateRoot(event) {\n    var context = event.context,\n        oldRoot = context.oldRoot,\n        children = oldRoot.children;\n\n    forEach(children, function(child) {\n      if (is(child, 'bpmn:BaseElement')) {\n        self.updateParent(child);\n      }\n    });\n  }\n\n  this.executed([ 'canvas.updateRoot' ], updateRoot);\n  this.reverted([ 'canvas.updateRoot' ], updateRoot);\n\n\n  // update bounds\n  function updateBounds(e) {\n    var shape = e.context.shape;\n\n    if (!is(shape, 'bpmn:BaseElement')) {\n      return;\n    }\n\n    self.updateBounds(shape);\n  }\n\n  this.executed([ 'shape.move', 'shape.create', 'shape.resize' ], ifBpmn(function(event) {\n\n    // exclude labels because they're handled separately during shape.changed\n    if (event.context.shape.type === 'label') {\n      return;\n    }\n\n    updateBounds(event);\n  }));\n\n  this.reverted([ 'shape.move', 'shape.create', 'shape.resize' ], ifBpmn(function(event) {\n\n    // exclude labels because they're handled separately during shape.changed\n    if (event.context.shape.type === 'label') {\n      return;\n    }\n\n    updateBounds(event);\n  }));\n\n  // Handle labels separately. This is necessary, because the label bounds have to be updated\n  // every time its shape changes, not only on move, create and resize.\n  eventBus.on('shape.changed', function(event) {\n    if (event.element.type === 'label') {\n      updateBounds({ context: { shape: event.element } });\n    }\n  });\n\n  // attach / detach connection\n  function updateConnection(e) {\n    self.updateConnection(e.context);\n  }\n\n  this.executed([\n    'connection.create',\n    'connection.move',\n    'connection.delete',\n    'connection.reconnect'\n  ], ifBpmn(updateConnection));\n\n  this.reverted([\n    'connection.create',\n    'connection.move',\n    'connection.delete',\n    'connection.reconnect'\n  ], ifBpmn(updateConnection));\n\n\n  // update waypoints\n  function updateConnectionWaypoints(e) {\n    self.updateConnectionWaypoints(e.context.connection);\n  }\n\n  this.executed([\n    'connection.layout',\n    'connection.move',\n    'connection.updateWaypoints',\n  ], ifBpmn(updateConnectionWaypoints));\n\n  this.reverted([\n    'connection.layout',\n    'connection.move',\n    'connection.updateWaypoints',\n  ], ifBpmn(updateConnectionWaypoints));\n\n  // update conditional/default flows\n  this.executed('connection.reconnect', ifBpmn(function(event) {\n    var context = event.context,\n        connection = context.connection,\n        oldSource = context.oldSource,\n        newSource = context.newSource,\n        connectionBo = getBusinessObject(connection),\n        oldSourceBo = getBusinessObject(oldSource),\n        newSourceBo = getBusinessObject(newSource);\n\n    // remove condition from connection on reconnect to new source\n    // if new source can NOT have condional sequence flow\n    if (connectionBo.conditionExpression && !isAny(newSourceBo, [\n      'bpmn:Activity',\n      'bpmn:ExclusiveGateway',\n      'bpmn:InclusiveGateway'\n    ])) {\n      context.oldConditionExpression = connectionBo.conditionExpression;\n\n      delete connectionBo.conditionExpression;\n    }\n\n    // remove default from old source flow on reconnect to new source\n    // if source changed\n    if (oldSource !== newSource && oldSourceBo.default === connectionBo) {\n      context.oldDefault = oldSourceBo.default;\n\n      delete oldSourceBo.default;\n    }\n  }));\n\n  this.reverted('connection.reconnect', ifBpmn(function(event) {\n    var context = event.context,\n        connection = context.connection,\n        oldSource = context.oldSource,\n        newSource = context.newSource,\n        connectionBo = getBusinessObject(connection),\n        oldSourceBo = getBusinessObject(oldSource),\n        newSourceBo = getBusinessObject(newSource);\n\n    // add condition to connection on revert reconnect to new source\n    if (context.oldConditionExpression) {\n      connectionBo.conditionExpression = context.oldConditionExpression;\n    }\n\n    // add default to old source on revert reconnect to new source\n    if (context.oldDefault) {\n      oldSourceBo.default = context.oldDefault;\n\n      delete newSourceBo.default;\n    }\n  }));\n\n  // update attachments\n  function updateAttachment(e) {\n    self.updateAttachment(e.context);\n  }\n\n  this.executed([ 'element.updateAttachment' ], ifBpmn(updateAttachment));\n  this.reverted([ 'element.updateAttachment' ], ifBpmn(updateAttachment));\n\n\n  // update BPMNLabel\n  this.executed('element.updateLabel', ifBpmn(updateBPMNLabel));\n  this.reverted('element.updateLabel', ifBpmn(updateBPMNLabel));\n\n  function updateBPMNLabel(event) {\n    const { element } = event.context,\n          label = getLabel(element);\n    const di = getDi(element),\n          diLabel = di && di.get('label');\n\n    if (isLabelExternal(element) || isPlane(element)) {\n      return;\n    }\n\n    if (label && !diLabel) {\n      di.set('label', bpmnFactory.create('bpmndi:BPMNLabel'));\n    } else if (!label && diLabel) {\n      di.set('label', undefined);\n    }\n  }\n}\n\ninherits(BpmnUpdater, CommandInterceptor);\n\nBpmnUpdater.$inject = [\n  'eventBus',\n  'bpmnFactory',\n  'connectionDocking'\n];\n\n\n// implementation //////////////////////\n\n/**\n * @param { {\n *   shape: Shape;\n *   host: Shape;\n * } } context\n */\nBpmnUpdater.prototype.updateAttachment = function(context) {\n\n  var shape = context.shape,\n      businessObject = shape.businessObject,\n      host = shape.host;\n\n  businessObject.attachedToRef = host && host.businessObject;\n};\n\n/**\n * @param {Element} element\n * @param {Parent} oldParent\n */\nBpmnUpdater.prototype.updateParent = function(element, oldParent) {\n\n  // do not update BPMN 2.0 label parent\n  if (isLabel(element)) {\n    return;\n  }\n\n  // data stores in collaborations are handled separately by DataStoreBehavior\n  if (is(element, 'bpmn:DataStoreReference') &&\n      element.parent &&\n      is(element.parent, 'bpmn:Collaboration')) {\n    return;\n  }\n\n  var parentShape = element.parent;\n\n  var businessObject = element.businessObject,\n      di = getDi(element),\n      parentBusinessObject = parentShape && parentShape.businessObject,\n      parentDi = getDi(parentShape);\n\n  if (is(element, 'bpmn:FlowNode')) {\n    this.updateFlowNodeRefs(businessObject, parentBusinessObject, oldParent && oldParent.businessObject);\n  }\n\n  if (is(element, 'bpmn:DataOutputAssociation')) {\n    if (element.source) {\n      parentBusinessObject = element.source.businessObject;\n    } else {\n      parentBusinessObject = null;\n    }\n  }\n\n  if (is(element, 'bpmn:DataInputAssociation')) {\n    if (element.target) {\n      parentBusinessObject = element.target.businessObject;\n    } else {\n      parentBusinessObject = null;\n    }\n  }\n\n  this.updateSemanticParent(businessObject, parentBusinessObject);\n\n  if (is(element, 'bpmn:DataObjectReference') && businessObject.dataObjectRef) {\n    this.updateSemanticParent(businessObject.dataObjectRef, parentBusinessObject);\n  }\n\n  this.updateDiParent(di, parentDi);\n};\n\n/**\n * @param {Shape} shape\n */\nBpmnUpdater.prototype.updateBounds = function(shape) {\n\n  var di = getDi(shape),\n      embeddedLabelBounds = getEmbeddedLabelBounds(shape);\n\n  // update embedded label bounds if possible\n  if (embeddedLabelBounds) {\n    var embeddedLabelBoundsDelta = delta(embeddedLabelBounds, di.get('bounds'));\n\n    assign(embeddedLabelBounds, {\n      x: shape.x + embeddedLabelBoundsDelta.x,\n      y: shape.y + embeddedLabelBoundsDelta.y\n    });\n  }\n\n  var target = isLabel(shape) ? this._getLabel(di) : di;\n\n  var bounds = target.bounds;\n\n  if (!bounds) {\n    bounds = this._bpmnFactory.createDiBounds();\n    target.set('bounds', bounds);\n  }\n\n  assign(bounds, {\n    x: shape.x,\n    y: shape.y,\n    width: shape.width,\n    height: shape.height\n  });\n};\n\n/**\n * @param {ModdleElement} businessObject\n * @param {ModdleElement} newContainment\n * @param {ModdleElement} oldContainment\n */\nBpmnUpdater.prototype.updateFlowNodeRefs = function(businessObject, newContainment, oldContainment) {\n\n  if (oldContainment === newContainment) {\n    return;\n  }\n\n  var oldRefs, newRefs;\n\n  if (is (oldContainment, 'bpmn:Lane')) {\n    oldRefs = oldContainment.get('flowNodeRef');\n    collectionRemove(oldRefs, businessObject);\n  }\n\n  if (is(newContainment, 'bpmn:Lane')) {\n    newRefs = newContainment.get('flowNodeRef');\n    collectionAdd(newRefs, businessObject);\n  }\n};\n\n/**\n * @param {Connection} connection\n * @param {Element} newSource\n * @param {Element} newTarget\n */\nBpmnUpdater.prototype.updateDiConnection = function(connection, newSource, newTarget) {\n  var connectionDi = getDi(connection),\n      newSourceDi = getDi(newSource),\n      newTargetDi = getDi(newTarget);\n\n  if (connectionDi.sourceElement && connectionDi.sourceElement.bpmnElement !== getBusinessObject(newSource)) {\n    connectionDi.sourceElement = newSource && newSourceDi;\n  }\n\n  if (connectionDi.targetElement && connectionDi.targetElement.bpmnElement !== getBusinessObject(newTarget)) {\n    connectionDi.targetElement = newTarget && newTargetDi;\n  }\n\n};\n\n/**\n * @param {ModdleElement} di\n * @param {ModdleElement} parentDi\n */\nBpmnUpdater.prototype.updateDiParent = function(di, parentDi) {\n\n  if (parentDi && !is(parentDi, 'bpmndi:BPMNPlane')) {\n    parentDi = parentDi.$parent;\n  }\n\n  if (di.$parent === parentDi) {\n    return;\n  }\n\n  var planeElements = (parentDi || di.$parent).get('planeElement');\n\n  if (parentDi) {\n    planeElements.push(di);\n    di.$parent = parentDi;\n  } else {\n    collectionRemove(planeElements, di);\n    di.$parent = null;\n  }\n};\n\n/**\n * @param {ModdleElement} element\n *\n * @return {ModdleElement}\n */\nfunction getDefinitions(element) {\n  while (element && !is(element, 'bpmn:Definitions')) {\n    element = element.$parent;\n  }\n\n  return element;\n}\n\n/**\n * @param {ModdleElement} container\n *\n * @return {ModdleElement}\n */\nBpmnUpdater.prototype.getLaneSet = function(container) {\n\n  var laneSet, laneSets;\n\n  // bpmn:Lane\n  if (is(container, 'bpmn:Lane')) {\n    laneSet = container.childLaneSet;\n\n    if (!laneSet) {\n      laneSet = this._bpmnFactory.create('bpmn:LaneSet');\n      container.childLaneSet = laneSet;\n      laneSet.$parent = container;\n    }\n\n    return laneSet;\n  }\n\n  // bpmn:Participant\n  if (is(container, 'bpmn:Participant')) {\n    container = container.processRef;\n  }\n\n  // bpmn:FlowElementsContainer\n  laneSets = container.get('laneSets');\n  laneSet = laneSets[0];\n\n  if (!laneSet) {\n    laneSet = this._bpmnFactory.create('bpmn:LaneSet');\n    laneSet.$parent = container;\n    laneSets.push(laneSet);\n  }\n\n  return laneSet;\n};\n\n/**\n * @param {ModdleElement} businessObject\n * @param {ModdleElement} newParent\n * @param {ModdleElement} visualParent\n */\nBpmnUpdater.prototype.updateSemanticParent = function(businessObject, newParent, visualParent) {\n\n  var containment;\n\n  if (businessObject.$parent === newParent) {\n    return;\n  }\n\n  if (is(businessObject, 'bpmn:DataInput') || is(businessObject, 'bpmn:DataOutput')) {\n\n    if (is(newParent, 'bpmn:Participant') && 'processRef' in newParent) {\n      newParent = newParent.processRef;\n    }\n\n    // already in correct ioSpecification\n    if ('ioSpecification' in newParent && newParent.ioSpecification === businessObject.$parent) {\n      return;\n    }\n  }\n\n  if (is(businessObject, 'bpmn:Lane')) {\n\n    if (newParent) {\n      newParent = this.getLaneSet(newParent);\n    }\n\n    containment = 'lanes';\n  } else if (is(businessObject, 'bpmn:FlowElement')) {\n\n    if (newParent) {\n\n      if (is(newParent, 'bpmn:Participant')) {\n        newParent = newParent.processRef;\n      } else if (is(newParent, 'bpmn:Lane')) {\n        do {\n\n          // unwrap Lane -> LaneSet -> (Lane | FlowElementsContainer)\n          newParent = newParent.$parent.$parent;\n        } while (is(newParent, 'bpmn:Lane'));\n\n      }\n    }\n\n    containment = 'flowElements';\n\n  } else if (is(businessObject, 'bpmn:Artifact')) {\n\n    while (newParent &&\n           !is(newParent, 'bpmn:Process') &&\n           !is(newParent, 'bpmn:SubProcess') &&\n           !is(newParent, 'bpmn:Collaboration')) {\n\n      if (is(newParent, 'bpmn:Participant')) {\n        newParent = newParent.processRef;\n        break;\n      } else {\n        newParent = newParent.$parent;\n      }\n    }\n\n    containment = 'artifacts';\n  } else if (is(businessObject, 'bpmn:MessageFlow')) {\n    containment = 'messageFlows';\n  } else if (is(businessObject, 'bpmn:Participant')) {\n    containment = 'participants';\n\n    // make sure the participants process is properly attached / detached\n    // from the XML document\n\n    var process = businessObject.processRef,\n        definitions;\n\n    if (process) {\n      definitions = getDefinitions(businessObject.$parent || newParent);\n\n      if (businessObject.$parent) {\n        collectionRemove(definitions.get('rootElements'), process);\n        process.$parent = null;\n      }\n\n      if (newParent) {\n        collectionAdd(definitions.get('rootElements'), process);\n        process.$parent = definitions;\n      }\n    }\n  } else if (is(businessObject, 'bpmn:DataOutputAssociation')) {\n    containment = 'dataOutputAssociations';\n  } else if (is(businessObject, 'bpmn:DataInputAssociation')) {\n    containment = 'dataInputAssociations';\n  }\n\n  if (!containment) {\n    throw new Error(`no parent for <${ businessObject.id }> in <${ newParent.id }>`);\n  }\n\n  var children;\n\n  if (businessObject.$parent) {\n\n    // remove from old parent\n    children = businessObject.$parent.get(containment);\n    collectionRemove(children, businessObject);\n  }\n\n  if (!newParent) {\n    businessObject.$parent = null;\n  } else {\n\n    // add to new parent\n    children = newParent.get(containment);\n    children.push(businessObject);\n    businessObject.$parent = newParent;\n  }\n\n  if (visualParent) {\n    var diChildren = visualParent.get(containment);\n\n    collectionRemove(children, businessObject);\n\n    if (newParent) {\n\n      if (!diChildren) {\n        diChildren = [];\n        newParent.set(containment, diChildren);\n      }\n\n      diChildren.push(businessObject);\n    }\n  }\n};\n\n/**\n * @param {Connection} connection\n */\nBpmnUpdater.prototype.updateConnectionWaypoints = function(connection) {\n  var di = getDi(connection);\n\n  di.set('waypoint', this._bpmnFactory.createDiWaypoints(connection.waypoints));\n};\n\n/**\n * @param { {\n *   connection: Connection;\n *   parent: Parent;\n *   newParent: Parent;\n * } } context\n */\nBpmnUpdater.prototype.updateConnection = function(context) {\n  var connection = context.connection,\n      businessObject = getBusinessObject(connection),\n      newSource = connection.source,\n      newSourceBo = getBusinessObject(newSource),\n      newTarget = connection.target,\n      newTargetBo = getBusinessObject(connection.target),\n      visualParent;\n\n  if (!is(businessObject, 'bpmn:DataAssociation')) {\n\n    var inverseSet = is(businessObject, 'bpmn:SequenceFlow');\n\n    if (businessObject.sourceRef !== newSourceBo) {\n      if (inverseSet) {\n        collectionRemove(businessObject.sourceRef && businessObject.sourceRef.get('outgoing'), businessObject);\n\n        if (newSourceBo && newSourceBo.get('outgoing')) {\n          newSourceBo.get('outgoing').push(businessObject);\n        }\n      }\n\n      businessObject.sourceRef = newSourceBo;\n    }\n\n    if (businessObject.targetRef !== newTargetBo) {\n      if (inverseSet) {\n        collectionRemove(businessObject.targetRef && businessObject.targetRef.get('incoming'), businessObject);\n\n        if (newTargetBo && newTargetBo.get('incoming')) {\n          newTargetBo.get('incoming').push(businessObject);\n        }\n      }\n\n      businessObject.targetRef = newTargetBo;\n    }\n  } else if (is(businessObject, 'bpmn:DataInputAssociation')) {\n\n    // handle obnoxious isMsome sourceRef\n    businessObject.get('sourceRef')[0] = newSourceBo;\n\n    visualParent = context.parent || context.newParent || newTargetBo;\n\n    this.updateSemanticParent(businessObject, newTargetBo, visualParent);\n  } else if (is(businessObject, 'bpmn:DataOutputAssociation')) {\n    visualParent = context.parent || context.newParent || newSourceBo;\n\n    this.updateSemanticParent(businessObject, newSourceBo, visualParent);\n\n    // targetRef = new target\n    businessObject.targetRef = newTargetBo;\n  }\n\n  this.updateConnectionWaypoints(connection);\n\n  this.updateDiConnection(connection, newSource, newTarget);\n};\n\n\n// helpers //////////////////////\n\nBpmnUpdater.prototype._getLabel = function(di) {\n  if (!di.label) {\n    di.label = this._bpmnFactory.createDiLabel();\n  }\n\n  return di.label;\n};\n\n\n/**\n * Call function if shape or connection is BPMN element.\n *\n * @param  {Function} fn\n *\n * @return {Function}\n */\nfunction ifBpmn(fn) {\n\n  return function(event) {\n\n    var context = event.context,\n        element = context.shape || context.connection || context.element;\n\n    if (is(element, 'bpmn:BaseElement')) {\n      fn(event);\n    }\n  };\n}\n\n/**\n * Return dc:Bounds of bpmndi:BPMNLabel if exists.\n *\n * @param {Shape} shape\n *\n * @return {ModdleElement|undefined}\n */\nfunction getEmbeddedLabelBounds(shape) {\n  if (!is(shape, 'bpmn:Activity')) {\n    return;\n  }\n\n  var di = getDi(shape);\n\n  if (!di) {\n    return;\n  }\n\n  var label = di.get('label');\n\n  if (!label) {\n    return;\n  }\n\n  return label.get('bounds');\n}"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}