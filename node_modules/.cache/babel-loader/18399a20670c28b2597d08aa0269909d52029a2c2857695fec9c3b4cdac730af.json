{"ast":null,"code":"/**\n * Extends a collection with {@link Refs} aware methods\n *\n * @param {Array<Object>} collection\n * @param {Refs} refs instance\n * @param {Object} property represented by the collection\n * @param {Object} target object the collection is attached to\n *\n * @return {RefsCollection<Object>} the extended array\n */\nfunction extend(collection, refs, property, target) {\n  var inverseProperty = property.inverse;\n\n  /**\n   * Removes the given element from the array and returns it.\n   *\n   * @method RefsCollection#remove\n   *\n   * @param {Object} element the element to remove\n   */\n  Object.defineProperty(collection, 'remove', {\n    value: function (element) {\n      var idx = this.indexOf(element);\n      if (idx !== -1) {\n        this.splice(idx, 1);\n\n        // unset inverse\n        refs.unset(element, inverseProperty, target);\n      }\n      return element;\n    }\n  });\n\n  /**\n   * Returns true if the collection contains the given element\n   *\n   * @method RefsCollection#contains\n   *\n   * @param {Object} element the element to check for\n   */\n  Object.defineProperty(collection, 'contains', {\n    value: function (element) {\n      return this.indexOf(element) !== -1;\n    }\n  });\n\n  /**\n   * Adds an element to the array, unless it exists already (set semantics).\n   *\n   * @method RefsCollection#add\n   *\n   * @param {Object} element the element to add\n   * @param {Number} optional index to add element to\n   *                 (possibly moving other elements around)\n   */\n  Object.defineProperty(collection, 'add', {\n    value: function (element, idx) {\n      var currentIdx = this.indexOf(element);\n      if (typeof idx === 'undefined') {\n        if (currentIdx !== -1) {\n          // element already in collection (!)\n          return;\n        }\n\n        // add to end of array, as no idx is specified\n        idx = this.length;\n      }\n\n      // handle already in collection\n      if (currentIdx !== -1) {\n        // remove element from currentIdx\n        this.splice(currentIdx, 1);\n      }\n\n      // add element at idx\n      this.splice(idx, 0, element);\n      if (currentIdx === -1) {\n        // set inverse, unless element was\n        // in collection already\n        refs.set(element, inverseProperty, target);\n      }\n    }\n  });\n\n  // a simple marker, identifying this element\n  // as being a refs collection\n  Object.defineProperty(collection, '__refs_collection', {\n    value: true\n  });\n  return collection;\n}\n\n/**\n * Checks if a given collection is extended\n *\n * @param {Array<Object>} collection\n *\n * @return {boolean}\n */\nfunction isExtended(collection) {\n  return collection.__refs_collection === true;\n}\nvar collection = {\n  __proto__: null,\n  extend: extend,\n  isExtended: isExtended\n};\nfunction hasOwnProperty(e, property) {\n  return Object.prototype.hasOwnProperty.call(e, property.name || property);\n}\nfunction defineCollectionProperty(ref, property, target) {\n  var collection = extend(target[property.name] || [], ref, property, target);\n  Object.defineProperty(target, property.name, {\n    enumerable: property.enumerable,\n    value: collection\n  });\n  if (collection.length) {\n    collection.forEach(function (o) {\n      ref.set(o, property.inverse, target);\n    });\n  }\n}\nfunction defineProperty(ref, property, target) {\n  var inverseProperty = property.inverse;\n  var _value = target[property.name];\n  Object.defineProperty(target, property.name, {\n    configurable: property.configurable,\n    enumerable: property.enumerable,\n    get: function () {\n      return _value;\n    },\n    set: function (value) {\n      // return if we already performed all changes\n      if (value === _value) {\n        return;\n      }\n      var old = _value;\n\n      // temporary set null\n      _value = null;\n      if (old) {\n        ref.unset(old, inverseProperty, target);\n      }\n\n      // set new value\n      _value = value;\n\n      // set inverse value\n      ref.set(_value, inverseProperty, target);\n    }\n  });\n}\n\n/**\n * Creates a new references object defining two inversly related\n * attribute descriptors a and b.\n *\n * <p>\n *   When bound to an object using {@link Refs#bind} the references\n *   get activated and ensure that add and remove operations are applied\n *   reversely, too.\n * </p>\n *\n * <p>\n *   For attributes represented as collections {@link Refs} provides the\n *   {@link RefsCollection#add}, {@link RefsCollection#remove} and {@link RefsCollection#contains} extensions\n *   that must be used to properly hook into the inverse change mechanism.\n * </p>\n *\n * @class Refs\n *\n * @classdesc A bi-directional reference between two attributes.\n *\n * @param {Refs.AttributeDescriptor} a property descriptor\n * @param {Refs.AttributeDescriptor} b property descriptor\n *\n * @example\n *\n * var refs = Refs({ name: 'wheels', collection: true, enumerable: true }, { name: 'car' });\n *\n * var car = { name: 'toyota' };\n * var wheels = [{ pos: 'front-left' }, { pos: 'front-right' }];\n *\n * refs.bind(car, 'wheels');\n *\n * car.wheels // []\n * car.wheels.add(wheels[0]);\n * car.wheels.add(wheels[1]);\n *\n * car.wheels // [{ pos: 'front-left' }, { pos: 'front-right' }]\n *\n * wheels[0].car // { name: 'toyota' };\n * car.wheels.remove(wheels[0]);\n *\n * wheels[0].car // undefined\n */\nfunction Refs(a, b) {\n  if (!(this instanceof Refs)) {\n    return new Refs(a, b);\n  }\n\n  // link\n  a.inverse = b;\n  b.inverse = a;\n  this.props = {};\n  this.props[a.name] = a;\n  this.props[b.name] = b;\n}\n\n/**\n * Binds one side of a bi-directional reference to a\n * target object.\n *\n * @memberOf Refs\n *\n * @param  {Object} target\n * @param  {String} property\n */\nRefs.prototype.bind = function (target, property) {\n  if (typeof property === 'string') {\n    if (!this.props[property]) {\n      throw new Error('no property <' + property + '> in ref');\n    }\n    property = this.props[property];\n  }\n  if (property.collection) {\n    defineCollectionProperty(this, property, target);\n  } else {\n    defineProperty(this, property, target);\n  }\n};\nRefs.prototype.ensureRefsCollection = function (target, property) {\n  var collection = target[property.name];\n  if (!isExtended(collection)) {\n    defineCollectionProperty(this, property, target);\n  }\n  return collection;\n};\nRefs.prototype.ensureBound = function (target, property) {\n  if (!hasOwnProperty(target, property)) {\n    this.bind(target, property);\n  }\n};\nRefs.prototype.unset = function (target, property, value) {\n  if (target) {\n    this.ensureBound(target, property);\n    if (property.collection) {\n      this.ensureRefsCollection(target, property).remove(value);\n    } else {\n      target[property.name] = undefined;\n    }\n  }\n};\nRefs.prototype.set = function (target, property, value) {\n  if (target) {\n    this.ensureBound(target, property);\n    if (property.collection) {\n      this.ensureRefsCollection(target, property).add(value);\n    } else {\n      target[property.name] = value;\n    }\n  }\n};\n\n/**\n * An attribute descriptor to be used specify an attribute in a {@link Refs} instance\n *\n * @typedef {Object} Refs.AttributeDescriptor\n * @property {String} name\n * @property {boolean} [collection=false]\n * @property {boolean} [enumerable=false]\n */\n\nexport { collection as Collection, Refs };","map":{"version":3,"names":["extend","collection","refs","property","target","inverseProperty","inverse","Object","defineProperty","value","element","idx","indexOf","splice","unset","currentIdx","length","set","isExtended","__refs_collection","__proto__","hasOwnProperty","e","prototype","call","name","defineCollectionProperty","ref","enumerable","forEach","o","_value","configurable","get","old","Refs","a","b","props","bind","Error","ensureRefsCollection","ensureBound","remove","undefined","add","Collection"],"sources":["/home/runner/work/sgex/sgex/node_modules/object-refs/dist/index.js"],"sourcesContent":["/**\n * Extends a collection with {@link Refs} aware methods\n *\n * @param {Array<Object>} collection\n * @param {Refs} refs instance\n * @param {Object} property represented by the collection\n * @param {Object} target object the collection is attached to\n *\n * @return {RefsCollection<Object>} the extended array\n */\nfunction extend(collection, refs, property, target) {\n  var inverseProperty = property.inverse;\n\n  /**\n   * Removes the given element from the array and returns it.\n   *\n   * @method RefsCollection#remove\n   *\n   * @param {Object} element the element to remove\n   */\n  Object.defineProperty(collection, 'remove', {\n    value: function (element) {\n      var idx = this.indexOf(element);\n      if (idx !== -1) {\n        this.splice(idx, 1);\n\n        // unset inverse\n        refs.unset(element, inverseProperty, target);\n      }\n      return element;\n    }\n  });\n\n  /**\n   * Returns true if the collection contains the given element\n   *\n   * @method RefsCollection#contains\n   *\n   * @param {Object} element the element to check for\n   */\n  Object.defineProperty(collection, 'contains', {\n    value: function (element) {\n      return this.indexOf(element) !== -1;\n    }\n  });\n\n  /**\n   * Adds an element to the array, unless it exists already (set semantics).\n   *\n   * @method RefsCollection#add\n   *\n   * @param {Object} element the element to add\n   * @param {Number} optional index to add element to\n   *                 (possibly moving other elements around)\n   */\n  Object.defineProperty(collection, 'add', {\n    value: function (element, idx) {\n      var currentIdx = this.indexOf(element);\n      if (typeof idx === 'undefined') {\n        if (currentIdx !== -1) {\n          // element already in collection (!)\n          return;\n        }\n\n        // add to end of array, as no idx is specified\n        idx = this.length;\n      }\n\n      // handle already in collection\n      if (currentIdx !== -1) {\n        // remove element from currentIdx\n        this.splice(currentIdx, 1);\n      }\n\n      // add element at idx\n      this.splice(idx, 0, element);\n      if (currentIdx === -1) {\n        // set inverse, unless element was\n        // in collection already\n        refs.set(element, inverseProperty, target);\n      }\n    }\n  });\n\n  // a simple marker, identifying this element\n  // as being a refs collection\n  Object.defineProperty(collection, '__refs_collection', {\n    value: true\n  });\n  return collection;\n}\n\n/**\n * Checks if a given collection is extended\n *\n * @param {Array<Object>} collection\n *\n * @return {boolean}\n */\nfunction isExtended(collection) {\n  return collection.__refs_collection === true;\n}\n\nvar collection = {\n  __proto__: null,\n  extend: extend,\n  isExtended: isExtended\n};\n\nfunction hasOwnProperty(e, property) {\n  return Object.prototype.hasOwnProperty.call(e, property.name || property);\n}\nfunction defineCollectionProperty(ref, property, target) {\n  var collection = extend(target[property.name] || [], ref, property, target);\n  Object.defineProperty(target, property.name, {\n    enumerable: property.enumerable,\n    value: collection\n  });\n  if (collection.length) {\n    collection.forEach(function (o) {\n      ref.set(o, property.inverse, target);\n    });\n  }\n}\nfunction defineProperty(ref, property, target) {\n  var inverseProperty = property.inverse;\n  var _value = target[property.name];\n  Object.defineProperty(target, property.name, {\n    configurable: property.configurable,\n    enumerable: property.enumerable,\n    get: function () {\n      return _value;\n    },\n    set: function (value) {\n      // return if we already performed all changes\n      if (value === _value) {\n        return;\n      }\n      var old = _value;\n\n      // temporary set null\n      _value = null;\n      if (old) {\n        ref.unset(old, inverseProperty, target);\n      }\n\n      // set new value\n      _value = value;\n\n      // set inverse value\n      ref.set(_value, inverseProperty, target);\n    }\n  });\n}\n\n/**\n * Creates a new references object defining two inversly related\n * attribute descriptors a and b.\n *\n * <p>\n *   When bound to an object using {@link Refs#bind} the references\n *   get activated and ensure that add and remove operations are applied\n *   reversely, too.\n * </p>\n *\n * <p>\n *   For attributes represented as collections {@link Refs} provides the\n *   {@link RefsCollection#add}, {@link RefsCollection#remove} and {@link RefsCollection#contains} extensions\n *   that must be used to properly hook into the inverse change mechanism.\n * </p>\n *\n * @class Refs\n *\n * @classdesc A bi-directional reference between two attributes.\n *\n * @param {Refs.AttributeDescriptor} a property descriptor\n * @param {Refs.AttributeDescriptor} b property descriptor\n *\n * @example\n *\n * var refs = Refs({ name: 'wheels', collection: true, enumerable: true }, { name: 'car' });\n *\n * var car = { name: 'toyota' };\n * var wheels = [{ pos: 'front-left' }, { pos: 'front-right' }];\n *\n * refs.bind(car, 'wheels');\n *\n * car.wheels // []\n * car.wheels.add(wheels[0]);\n * car.wheels.add(wheels[1]);\n *\n * car.wheels // [{ pos: 'front-left' }, { pos: 'front-right' }]\n *\n * wheels[0].car // { name: 'toyota' };\n * car.wheels.remove(wheels[0]);\n *\n * wheels[0].car // undefined\n */\nfunction Refs(a, b) {\n  if (!(this instanceof Refs)) {\n    return new Refs(a, b);\n  }\n\n  // link\n  a.inverse = b;\n  b.inverse = a;\n  this.props = {};\n  this.props[a.name] = a;\n  this.props[b.name] = b;\n}\n\n/**\n * Binds one side of a bi-directional reference to a\n * target object.\n *\n * @memberOf Refs\n *\n * @param  {Object} target\n * @param  {String} property\n */\nRefs.prototype.bind = function (target, property) {\n  if (typeof property === 'string') {\n    if (!this.props[property]) {\n      throw new Error('no property <' + property + '> in ref');\n    }\n    property = this.props[property];\n  }\n  if (property.collection) {\n    defineCollectionProperty(this, property, target);\n  } else {\n    defineProperty(this, property, target);\n  }\n};\nRefs.prototype.ensureRefsCollection = function (target, property) {\n  var collection = target[property.name];\n  if (!isExtended(collection)) {\n    defineCollectionProperty(this, property, target);\n  }\n  return collection;\n};\nRefs.prototype.ensureBound = function (target, property) {\n  if (!hasOwnProperty(target, property)) {\n    this.bind(target, property);\n  }\n};\nRefs.prototype.unset = function (target, property, value) {\n  if (target) {\n    this.ensureBound(target, property);\n    if (property.collection) {\n      this.ensureRefsCollection(target, property).remove(value);\n    } else {\n      target[property.name] = undefined;\n    }\n  }\n};\nRefs.prototype.set = function (target, property, value) {\n  if (target) {\n    this.ensureBound(target, property);\n    if (property.collection) {\n      this.ensureRefsCollection(target, property).add(value);\n    } else {\n      target[property.name] = value;\n    }\n  }\n};\n\n/**\n * An attribute descriptor to be used specify an attribute in a {@link Refs} instance\n *\n * @typedef {Object} Refs.AttributeDescriptor\n * @property {String} name\n * @property {boolean} [collection=false]\n * @property {boolean} [enumerable=false]\n */\n\nexport { collection as Collection, Refs };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}