{"ast":null,"code":"\"use strict\";\n\nvar _taggedTemplateLiteral = require(\"/home/runner/work/sgex/sgex/node_modules/@babel/runtime/helpers/taggedTemplateLiteral.js\").default;\nvar _templateObject, _templateObject2, _templateObject3, _templateObject4, _templateObject5, _templateObject6, _templateObject7, _templateObject8, _templateObject9, _templateObject0, _templateObject1, _templateObject10, _templateObject11, _templateObject12, _templateObject13, _templateObject14, _templateObject15, _templateObject16, _templateObject17, _templateObject18, _templateObject19, _templateObject20, _templateObject21, _templateObject22, _templateObject23, _templateObject24, _templateObject25, _templateObject26, _templateObject27, _templateObject28, _templateObject29, _templateObject30, _templateObject31;\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.reportTypeError = exports.checkDataTypes = exports.checkDataType = exports.coerceAndCheckDataType = exports.getJSONTypes = exports.getSchemaTypes = exports.DataType = void 0;\nconst rules_1 = require(\"../rules\");\nconst applicability_1 = require(\"./applicability\");\nconst errors_1 = require(\"../errors\");\nconst codegen_1 = require(\"../codegen\");\nconst util_1 = require(\"../util\");\nvar DataType;\n(function (DataType) {\n  DataType[DataType[\"Correct\"] = 0] = \"Correct\";\n  DataType[DataType[\"Wrong\"] = 1] = \"Wrong\";\n})(DataType || (exports.DataType = DataType = {}));\nfunction getSchemaTypes(schema) {\n  const types = getJSONTypes(schema.type);\n  const hasNull = types.includes(\"null\");\n  if (hasNull) {\n    if (schema.nullable === false) throw new Error(\"type: null contradicts nullable: false\");\n  } else {\n    if (!types.length && schema.nullable !== undefined) {\n      throw new Error('\"nullable\" cannot be used without \"type\"');\n    }\n    if (schema.nullable === true) types.push(\"null\");\n  }\n  return types;\n}\nexports.getSchemaTypes = getSchemaTypes;\n// eslint-disable-next-line @typescript-eslint/no-redundant-type-constituents\nfunction getJSONTypes(ts) {\n  const types = Array.isArray(ts) ? ts : ts ? [ts] : [];\n  if (types.every(rules_1.isJSONType)) return types;\n  throw new Error(\"type must be JSONType or JSONType[]: \" + types.join(\",\"));\n}\nexports.getJSONTypes = getJSONTypes;\nfunction coerceAndCheckDataType(it, types) {\n  const {\n    gen,\n    data,\n    opts\n  } = it;\n  const coerceTo = coerceToTypes(types, opts.coerceTypes);\n  const checkTypes = types.length > 0 && !(coerceTo.length === 0 && types.length === 1 && (0, applicability_1.schemaHasRulesForType)(it, types[0]));\n  if (checkTypes) {\n    const wrongType = checkDataTypes(types, data, opts.strictNumbers, DataType.Wrong);\n    gen.if(wrongType, () => {\n      if (coerceTo.length) coerceData(it, types, coerceTo);else reportTypeError(it);\n    });\n  }\n  return checkTypes;\n}\nexports.coerceAndCheckDataType = coerceAndCheckDataType;\nconst COERCIBLE = new Set([\"string\", \"number\", \"integer\", \"boolean\", \"null\"]);\nfunction coerceToTypes(types, coerceTypes) {\n  return coerceTypes ? types.filter(t => COERCIBLE.has(t) || coerceTypes === \"array\" && t === \"array\") : [];\n}\nfunction coerceData(it, types, coerceTo) {\n  const {\n    gen,\n    data,\n    opts\n  } = it;\n  const dataType = gen.let(\"dataType\", (0, codegen_1._)(_templateObject || (_templateObject = _taggedTemplateLiteral([\"typeof \", \"\"])), data));\n  const coerced = gen.let(\"coerced\", (0, codegen_1._)(_templateObject2 || (_templateObject2 = _taggedTemplateLiteral([\"undefined\"]))));\n  if (opts.coerceTypes === \"array\") {\n    gen.if((0, codegen_1._)(_templateObject3 || (_templateObject3 = _taggedTemplateLiteral([\"\", \" == 'object' && Array.isArray(\", \") && \", \".length == 1\"])), dataType, data, data), () => gen.assign(data, (0, codegen_1._)(_templateObject4 || (_templateObject4 = _taggedTemplateLiteral([\"\", \"[0]\"])), data)).assign(dataType, (0, codegen_1._)(_templateObject5 || (_templateObject5 = _taggedTemplateLiteral([\"typeof \", \"\"])), data)).if(checkDataTypes(types, data, opts.strictNumbers), () => gen.assign(coerced, data)));\n  }\n  gen.if((0, codegen_1._)(_templateObject6 || (_templateObject6 = _taggedTemplateLiteral([\"\", \" !== undefined\"])), coerced));\n  for (const t of coerceTo) {\n    if (COERCIBLE.has(t) || t === \"array\" && opts.coerceTypes === \"array\") {\n      coerceSpecificType(t);\n    }\n  }\n  gen.else();\n  reportTypeError(it);\n  gen.endIf();\n  gen.if((0, codegen_1._)(_templateObject7 || (_templateObject7 = _taggedTemplateLiteral([\"\", \" !== undefined\"])), coerced), () => {\n    gen.assign(data, coerced);\n    assignParentData(it, coerced);\n  });\n  function coerceSpecificType(t) {\n    switch (t) {\n      case \"string\":\n        gen.elseIf((0, codegen_1._)(_templateObject8 || (_templateObject8 = _taggedTemplateLiteral([\"\", \" == \\\"number\\\" || \", \" == \\\"boolean\\\"\"])), dataType, dataType)).assign(coerced, (0, codegen_1._)(_templateObject9 || (_templateObject9 = _taggedTemplateLiteral([\"\\\"\\\" + \", \"\"])), data)).elseIf((0, codegen_1._)(_templateObject0 || (_templateObject0 = _taggedTemplateLiteral([\"\", \" === null\"])), data)).assign(coerced, (0, codegen_1._)(_templateObject1 || (_templateObject1 = _taggedTemplateLiteral([\"\\\"\\\"\"]))));\n        return;\n      case \"number\":\n        gen.elseIf((0, codegen_1._)(_templateObject10 || (_templateObject10 = _taggedTemplateLiteral([\"\", \" == \\\"boolean\\\" || \", \" === null\\n              || (\", \" == \\\"string\\\" && \", \" && \", \" == +\", \")\"])), dataType, data, dataType, data, data, data)).assign(coerced, (0, codegen_1._)(_templateObject11 || (_templateObject11 = _taggedTemplateLiteral([\"+\", \"\"])), data));\n        return;\n      case \"integer\":\n        gen.elseIf((0, codegen_1._)(_templateObject12 || (_templateObject12 = _taggedTemplateLiteral([\"\", \" === \\\"boolean\\\" || \", \" === null\\n              || (\", \" === \\\"string\\\" && \", \" && \", \" == +\", \" && !(\", \" % 1))\"])), dataType, data, dataType, data, data, data, data)).assign(coerced, (0, codegen_1._)(_templateObject13 || (_templateObject13 = _taggedTemplateLiteral([\"+\", \"\"])), data));\n        return;\n      case \"boolean\":\n        gen.elseIf((0, codegen_1._)(_templateObject14 || (_templateObject14 = _taggedTemplateLiteral([\"\", \" === \\\"false\\\" || \", \" === 0 || \", \" === null\"])), data, data, data)).assign(coerced, false).elseIf((0, codegen_1._)(_templateObject15 || (_templateObject15 = _taggedTemplateLiteral([\"\", \" === \\\"true\\\" || \", \" === 1\"])), data, data)).assign(coerced, true);\n        return;\n      case \"null\":\n        gen.elseIf((0, codegen_1._)(_templateObject16 || (_templateObject16 = _taggedTemplateLiteral([\"\", \" === \\\"\\\" || \", \" === 0 || \", \" === false\"])), data, data, data));\n        gen.assign(coerced, null);\n        return;\n      case \"array\":\n        gen.elseIf((0, codegen_1._)(_templateObject17 || (_templateObject17 = _taggedTemplateLiteral([\"\", \" === \\\"string\\\" || \", \" === \\\"number\\\"\\n              || \", \" === \\\"boolean\\\" || \", \" === null\"])), dataType, dataType, dataType, data)).assign(coerced, (0, codegen_1._)(_templateObject18 || (_templateObject18 = _taggedTemplateLiteral([\"[\", \"]\"])), data));\n    }\n  }\n}\nfunction assignParentData(_ref, expr) {\n  let {\n    gen,\n    parentData,\n    parentDataProperty\n  } = _ref;\n  // TODO use gen.property\n  gen.if((0, codegen_1._)(_templateObject19 || (_templateObject19 = _taggedTemplateLiteral([\"\", \" !== undefined\"])), parentData), () => gen.assign((0, codegen_1._)(_templateObject20 || (_templateObject20 = _taggedTemplateLiteral([\"\", \"[\", \"]\"])), parentData, parentDataProperty), expr));\n}\nfunction checkDataType(dataType, data, strictNums) {\n  let correct = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : DataType.Correct;\n  const EQ = correct === DataType.Correct ? codegen_1.operators.EQ : codegen_1.operators.NEQ;\n  let cond;\n  switch (dataType) {\n    case \"null\":\n      return (0, codegen_1._)(_templateObject21 || (_templateObject21 = _taggedTemplateLiteral([\"\", \" \", \" null\"])), data, EQ);\n    case \"array\":\n      cond = (0, codegen_1._)(_templateObject22 || (_templateObject22 = _taggedTemplateLiteral([\"Array.isArray(\", \")\"])), data);\n      break;\n    case \"object\":\n      cond = (0, codegen_1._)(_templateObject23 || (_templateObject23 = _taggedTemplateLiteral([\"\", \" && typeof \", \" == \\\"object\\\" && !Array.isArray(\", \")\"])), data, data, data);\n      break;\n    case \"integer\":\n      cond = numCond((0, codegen_1._)(_templateObject24 || (_templateObject24 = _taggedTemplateLiteral([\"!(\", \" % 1) && !isNaN(\", \")\"])), data, data));\n      break;\n    case \"number\":\n      cond = numCond();\n      break;\n    default:\n      return (0, codegen_1._)(_templateObject25 || (_templateObject25 = _taggedTemplateLiteral([\"typeof \", \" \", \" \", \"\"])), data, EQ, dataType);\n  }\n  return correct === DataType.Correct ? cond : (0, codegen_1.not)(cond);\n  function numCond() {\n    let _cond = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : codegen_1.nil;\n    return (0, codegen_1.and)((0, codegen_1._)(_templateObject26 || (_templateObject26 = _taggedTemplateLiteral([\"typeof \", \" == \\\"number\\\"\"])), data), _cond, strictNums ? (0, codegen_1._)(_templateObject27 || (_templateObject27 = _taggedTemplateLiteral([\"isFinite(\", \")\"])), data) : codegen_1.nil);\n  }\n}\nexports.checkDataType = checkDataType;\nfunction checkDataTypes(dataTypes, data, strictNums, correct) {\n  if (dataTypes.length === 1) {\n    return checkDataType(dataTypes[0], data, strictNums, correct);\n  }\n  let cond;\n  const types = (0, util_1.toHash)(dataTypes);\n  if (types.array && types.object) {\n    const notObj = (0, codegen_1._)(_templateObject28 || (_templateObject28 = _taggedTemplateLiteral([\"typeof \", \" != \\\"object\\\"\"])), data);\n    cond = types.null ? notObj : (0, codegen_1._)(_templateObject29 || (_templateObject29 = _taggedTemplateLiteral([\"!\", \" || \", \"\"])), data, notObj);\n    delete types.null;\n    delete types.array;\n    delete types.object;\n  } else {\n    cond = codegen_1.nil;\n  }\n  if (types.number) delete types.integer;\n  for (const t in types) cond = (0, codegen_1.and)(cond, checkDataType(t, data, strictNums, correct));\n  return cond;\n}\nexports.checkDataTypes = checkDataTypes;\nconst typeError = {\n  message: _ref2 => {\n    let {\n      schema\n    } = _ref2;\n    return \"must be \".concat(schema);\n  },\n  params: _ref3 => {\n    let {\n      schema,\n      schemaValue\n    } = _ref3;\n    return typeof schema == \"string\" ? (0, codegen_1._)(_templateObject30 || (_templateObject30 = _taggedTemplateLiteral([\"{type: \", \"}\"])), schema) : (0, codegen_1._)(_templateObject31 || (_templateObject31 = _taggedTemplateLiteral([\"{type: \", \"}\"])), schemaValue);\n  }\n};\nfunction reportTypeError(it) {\n  const cxt = getTypeErrorContext(it);\n  (0, errors_1.reportError)(cxt, typeError);\n}\nexports.reportTypeError = reportTypeError;\nfunction getTypeErrorContext(it) {\n  const {\n    gen,\n    data,\n    schema\n  } = it;\n  const schemaCode = (0, util_1.schemaRefOrVal)(it, schema, \"type\");\n  return {\n    gen,\n    keyword: \"type\",\n    data,\n    schema: schema.type,\n    schemaCode,\n    schemaValue: schemaCode,\n    parentSchema: schema,\n    params: {},\n    it\n  };\n}","map":{"version":3,"names":["rules_1","require","applicability_1","errors_1","codegen_1","util_1","DataType","exports","getSchemaTypes","schema","types","getJSONTypes","type","hasNull","includes","nullable","Error","length","undefined","push","ts","Array","isArray","every","isJSONType","join","coerceAndCheckDataType","it","gen","data","opts","coerceTo","coerceToTypes","coerceTypes","checkTypes","schemaHasRulesForType","wrongType","checkDataTypes","strictNumbers","Wrong","if","coerceData","reportTypeError","COERCIBLE","Set","filter","t","has","dataType","let","_","_templateObject","_taggedTemplateLiteral","coerced","_templateObject2","_templateObject3","assign","_templateObject4","_templateObject5","_templateObject6","coerceSpecificType","else","endIf","_templateObject7","assignParentData","elseIf","_templateObject8","_templateObject9","_templateObject0","_templateObject1","_templateObject10","_templateObject11","_templateObject12","_templateObject13","_templateObject14","_templateObject15","_templateObject16","_templateObject17","_templateObject18","_ref","expr","parentData","parentDataProperty","_templateObject19","_templateObject20","checkDataType","strictNums","correct","arguments","Correct","EQ","operators","NEQ","cond","_templateObject21","_templateObject22","_templateObject23","numCond","_templateObject24","_templateObject25","not","_cond","nil","and","_templateObject26","_templateObject27","dataTypes","toHash","array","object","notObj","_templateObject28","null","_templateObject29","number","integer","typeError","message","_ref2","concat","params","_ref3","schemaValue","_templateObject30","_templateObject31","cxt","getTypeErrorContext","reportError","schemaCode","schemaRefOrVal","keyword","parentSchema"],"sources":["/home/runner/work/sgex/sgex/node_modules/ajv/lib/compile/validate/dataType.ts"],"sourcesContent":["import type {\n  KeywordErrorDefinition,\n  KeywordErrorCxt,\n  ErrorObject,\n  AnySchemaObject,\n} from \"../../types\"\nimport type {SchemaObjCxt} from \"..\"\nimport {isJSONType, JSONType} from \"../rules\"\nimport {schemaHasRulesForType} from \"./applicability\"\nimport {reportError} from \"../errors\"\nimport {_, nil, and, not, operators, Code, Name} from \"../codegen\"\nimport {toHash, schemaRefOrVal} from \"../util\"\n\nexport enum DataType {\n  Correct,\n  Wrong,\n}\n\nexport function getSchemaTypes(schema: AnySchemaObject): JSONType[] {\n  const types = getJSONTypes(schema.type)\n  const hasNull = types.includes(\"null\")\n  if (hasNull) {\n    if (schema.nullable === false) throw new Error(\"type: null contradicts nullable: false\")\n  } else {\n    if (!types.length && schema.nullable !== undefined) {\n      throw new Error('\"nullable\" cannot be used without \"type\"')\n    }\n    if (schema.nullable === true) types.push(\"null\")\n  }\n  return types\n}\n\n// eslint-disable-next-line @typescript-eslint/no-redundant-type-constituents\nexport function getJSONTypes(ts: unknown | unknown[]): JSONType[] {\n  const types: unknown[] = Array.isArray(ts) ? ts : ts ? [ts] : []\n  if (types.every(isJSONType)) return types\n  throw new Error(\"type must be JSONType or JSONType[]: \" + types.join(\",\"))\n}\n\nexport function coerceAndCheckDataType(it: SchemaObjCxt, types: JSONType[]): boolean {\n  const {gen, data, opts} = it\n  const coerceTo = coerceToTypes(types, opts.coerceTypes)\n  const checkTypes =\n    types.length > 0 &&\n    !(coerceTo.length === 0 && types.length === 1 && schemaHasRulesForType(it, types[0]))\n  if (checkTypes) {\n    const wrongType = checkDataTypes(types, data, opts.strictNumbers, DataType.Wrong)\n    gen.if(wrongType, () => {\n      if (coerceTo.length) coerceData(it, types, coerceTo)\n      else reportTypeError(it)\n    })\n  }\n  return checkTypes\n}\n\nconst COERCIBLE: Set<JSONType> = new Set([\"string\", \"number\", \"integer\", \"boolean\", \"null\"])\nfunction coerceToTypes(types: JSONType[], coerceTypes?: boolean | \"array\"): JSONType[] {\n  return coerceTypes\n    ? types.filter((t) => COERCIBLE.has(t) || (coerceTypes === \"array\" && t === \"array\"))\n    : []\n}\n\nfunction coerceData(it: SchemaObjCxt, types: JSONType[], coerceTo: JSONType[]): void {\n  const {gen, data, opts} = it\n  const dataType = gen.let(\"dataType\", _`typeof ${data}`)\n  const coerced = gen.let(\"coerced\", _`undefined`)\n  if (opts.coerceTypes === \"array\") {\n    gen.if(_`${dataType} == 'object' && Array.isArray(${data}) && ${data}.length == 1`, () =>\n      gen\n        .assign(data, _`${data}[0]`)\n        .assign(dataType, _`typeof ${data}`)\n        .if(checkDataTypes(types, data, opts.strictNumbers), () => gen.assign(coerced, data))\n    )\n  }\n  gen.if(_`${coerced} !== undefined`)\n  for (const t of coerceTo) {\n    if (COERCIBLE.has(t) || (t === \"array\" && opts.coerceTypes === \"array\")) {\n      coerceSpecificType(t)\n    }\n  }\n  gen.else()\n  reportTypeError(it)\n  gen.endIf()\n\n  gen.if(_`${coerced} !== undefined`, () => {\n    gen.assign(data, coerced)\n    assignParentData(it, coerced)\n  })\n\n  function coerceSpecificType(t: string): void {\n    switch (t) {\n      case \"string\":\n        gen\n          .elseIf(_`${dataType} == \"number\" || ${dataType} == \"boolean\"`)\n          .assign(coerced, _`\"\" + ${data}`)\n          .elseIf(_`${data} === null`)\n          .assign(coerced, _`\"\"`)\n        return\n      case \"number\":\n        gen\n          .elseIf(\n            _`${dataType} == \"boolean\" || ${data} === null\n              || (${dataType} == \"string\" && ${data} && ${data} == +${data})`\n          )\n          .assign(coerced, _`+${data}`)\n        return\n      case \"integer\":\n        gen\n          .elseIf(\n            _`${dataType} === \"boolean\" || ${data} === null\n              || (${dataType} === \"string\" && ${data} && ${data} == +${data} && !(${data} % 1))`\n          )\n          .assign(coerced, _`+${data}`)\n        return\n      case \"boolean\":\n        gen\n          .elseIf(_`${data} === \"false\" || ${data} === 0 || ${data} === null`)\n          .assign(coerced, false)\n          .elseIf(_`${data} === \"true\" || ${data} === 1`)\n          .assign(coerced, true)\n        return\n      case \"null\":\n        gen.elseIf(_`${data} === \"\" || ${data} === 0 || ${data} === false`)\n        gen.assign(coerced, null)\n        return\n\n      case \"array\":\n        gen\n          .elseIf(\n            _`${dataType} === \"string\" || ${dataType} === \"number\"\n              || ${dataType} === \"boolean\" || ${data} === null`\n          )\n          .assign(coerced, _`[${data}]`)\n    }\n  }\n}\n\nfunction assignParentData({gen, parentData, parentDataProperty}: SchemaObjCxt, expr: Name): void {\n  // TODO use gen.property\n  gen.if(_`${parentData} !== undefined`, () =>\n    gen.assign(_`${parentData}[${parentDataProperty}]`, expr)\n  )\n}\n\nexport function checkDataType(\n  dataType: JSONType,\n  data: Name,\n  strictNums?: boolean | \"log\",\n  correct = DataType.Correct\n): Code {\n  const EQ = correct === DataType.Correct ? operators.EQ : operators.NEQ\n  let cond: Code\n  switch (dataType) {\n    case \"null\":\n      return _`${data} ${EQ} null`\n    case \"array\":\n      cond = _`Array.isArray(${data})`\n      break\n    case \"object\":\n      cond = _`${data} && typeof ${data} == \"object\" && !Array.isArray(${data})`\n      break\n    case \"integer\":\n      cond = numCond(_`!(${data} % 1) && !isNaN(${data})`)\n      break\n    case \"number\":\n      cond = numCond()\n      break\n    default:\n      return _`typeof ${data} ${EQ} ${dataType}`\n  }\n  return correct === DataType.Correct ? cond : not(cond)\n\n  function numCond(_cond: Code = nil): Code {\n    return and(_`typeof ${data} == \"number\"`, _cond, strictNums ? _`isFinite(${data})` : nil)\n  }\n}\n\nexport function checkDataTypes(\n  dataTypes: JSONType[],\n  data: Name,\n  strictNums?: boolean | \"log\",\n  correct?: DataType\n): Code {\n  if (dataTypes.length === 1) {\n    return checkDataType(dataTypes[0], data, strictNums, correct)\n  }\n  let cond: Code\n  const types = toHash(dataTypes)\n  if (types.array && types.object) {\n    const notObj = _`typeof ${data} != \"object\"`\n    cond = types.null ? notObj : _`!${data} || ${notObj}`\n    delete types.null\n    delete types.array\n    delete types.object\n  } else {\n    cond = nil\n  }\n  if (types.number) delete types.integer\n  for (const t in types) cond = and(cond, checkDataType(t as JSONType, data, strictNums, correct))\n  return cond\n}\n\nexport type TypeError = ErrorObject<\"type\", {type: string}>\n\nconst typeError: KeywordErrorDefinition = {\n  message: ({schema}) => `must be ${schema}`,\n  params: ({schema, schemaValue}) =>\n    typeof schema == \"string\" ? _`{type: ${schema}}` : _`{type: ${schemaValue}}`,\n}\n\nexport function reportTypeError(it: SchemaObjCxt): void {\n  const cxt = getTypeErrorContext(it)\n  reportError(cxt, typeError)\n}\n\nfunction getTypeErrorContext(it: SchemaObjCxt): KeywordErrorCxt {\n  const {gen, data, schema} = it\n  const schemaCode = schemaRefOrVal(it, schema, \"type\")\n  return {\n    gen,\n    keyword: \"type\",\n    data,\n    schema: schema.type,\n    schemaCode,\n    schemaValue: schemaCode,\n    parentSchema: schema,\n    params: {},\n    it,\n  }\n}\n"],"mappings":";;;;;;;;AAOA,MAAAA,OAAA,GAAAC,OAAA;AACA,MAAAC,eAAA,GAAAD,OAAA;AACA,MAAAE,QAAA,GAAAF,OAAA;AACA,MAAAG,SAAA,GAAAH,OAAA;AACA,MAAAI,MAAA,GAAAJ,OAAA;AAEA,IAAYK,QAGX;AAHD,WAAYA,QAAQ;EAClBA,QAAA,CAAAA,QAAA,4BAAO;EACPA,QAAA,CAAAA,QAAA,wBAAK;AACP,CAAC,EAHWA,QAAQ,KAAAC,OAAA,CAAAD,QAAA,GAARA,QAAQ;AAKpB,SAAgBE,cAAcA,CAACC,MAAuB;EACpD,MAAMC,KAAK,GAAGC,YAAY,CAACF,MAAM,CAACG,IAAI,CAAC;EACvC,MAAMC,OAAO,GAAGH,KAAK,CAACI,QAAQ,CAAC,MAAM,CAAC;EACtC,IAAID,OAAO,EAAE;IACX,IAAIJ,MAAM,CAACM,QAAQ,KAAK,KAAK,EAAE,MAAM,IAAIC,KAAK,CAAC,wCAAwC,CAAC;EAC1F,CAAC,MAAM;IACL,IAAI,CAACN,KAAK,CAACO,MAAM,IAAIR,MAAM,CAACM,QAAQ,KAAKG,SAAS,EAAE;MAClD,MAAM,IAAIF,KAAK,CAAC,0CAA0C,CAAC;IAC7D;IACA,IAAIP,MAAM,CAACM,QAAQ,KAAK,IAAI,EAAEL,KAAK,CAACS,IAAI,CAAC,MAAM,CAAC;EAClD;EACA,OAAOT,KAAK;AACd;AAZAH,OAAA,CAAAC,cAAA,GAAAA,cAAA;AAcA;AACA,SAAgBG,YAAYA,CAACS,EAAuB;EAClD,MAAMV,KAAK,GAAcW,KAAK,CAACC,OAAO,CAACF,EAAE,CAAC,GAAGA,EAAE,GAAGA,EAAE,GAAG,CAACA,EAAE,CAAC,GAAG,EAAE;EAChE,IAAIV,KAAK,CAACa,KAAK,CAACvB,OAAA,CAAAwB,UAAU,CAAC,EAAE,OAAOd,KAAK;EACzC,MAAM,IAAIM,KAAK,CAAC,uCAAuC,GAAGN,KAAK,CAACe,IAAI,CAAC,GAAG,CAAC,CAAC;AAC5E;AAJAlB,OAAA,CAAAI,YAAA,GAAAA,YAAA;AAMA,SAAgBe,sBAAsBA,CAACC,EAAgB,EAAEjB,KAAiB;EACxE,MAAM;IAACkB,GAAG;IAAEC,IAAI;IAAEC;EAAI,CAAC,GAAGH,EAAE;EAC5B,MAAMI,QAAQ,GAAGC,aAAa,CAACtB,KAAK,EAAEoB,IAAI,CAACG,WAAW,CAAC;EACvD,MAAMC,UAAU,GACdxB,KAAK,CAACO,MAAM,GAAG,CAAC,IAChB,EAAEc,QAAQ,CAACd,MAAM,KAAK,CAAC,IAAIP,KAAK,CAACO,MAAM,KAAK,CAAC,IAAI,IAAAf,eAAA,CAAAiC,qBAAqB,EAACR,EAAE,EAAEjB,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC;EACvF,IAAIwB,UAAU,EAAE;IACd,MAAME,SAAS,GAAGC,cAAc,CAAC3B,KAAK,EAAEmB,IAAI,EAAEC,IAAI,CAACQ,aAAa,EAAEhC,QAAQ,CAACiC,KAAK,CAAC;IACjFX,GAAG,CAACY,EAAE,CAACJ,SAAS,EAAE,MAAK;MACrB,IAAIL,QAAQ,CAACd,MAAM,EAAEwB,UAAU,CAACd,EAAE,EAAEjB,KAAK,EAAEqB,QAAQ,CAAC,MAC/CW,eAAe,CAACf,EAAE,CAAC;IAC1B,CAAC,CAAC;EACJ;EACA,OAAOO,UAAU;AACnB;AAdA3B,OAAA,CAAAmB,sBAAA,GAAAA,sBAAA;AAgBA,MAAMiB,SAAS,GAAkB,IAAIC,GAAG,CAAC,CAAC,QAAQ,EAAE,QAAQ,EAAE,SAAS,EAAE,SAAS,EAAE,MAAM,CAAC,CAAC;AAC5F,SAASZ,aAAaA,CAACtB,KAAiB,EAAEuB,WAA+B;EACvE,OAAOA,WAAW,GACdvB,KAAK,CAACmC,MAAM,CAAEC,CAAC,IAAKH,SAAS,CAACI,GAAG,CAACD,CAAC,CAAC,IAAKb,WAAW,KAAK,OAAO,IAAIa,CAAC,KAAK,OAAQ,CAAC,GACnF,EAAE;AACR;AAEA,SAASL,UAAUA,CAACd,EAAgB,EAAEjB,KAAiB,EAAEqB,QAAoB;EAC3E,MAAM;IAACH,GAAG;IAAEC,IAAI;IAAEC;EAAI,CAAC,GAAGH,EAAE;EAC5B,MAAMqB,QAAQ,GAAGpB,GAAG,CAACqB,GAAG,CAAC,UAAU,GAAE,GAAA7C,SAAA,CAAA8C,CAAC,EAAAC,eAAA,KAAAA,eAAA,GAAAC,sBAAA,oBAAUvB,IAAI,CAAE,CAAC;EACvD,MAAMwB,OAAO,GAAGzB,GAAG,CAACqB,GAAG,CAAC,SAAS,GAAE,GAAA7C,SAAA,CAAA8C,CAAC,EAAAI,gBAAA,KAAAA,gBAAA,GAAAF,sBAAA,iBAAW,CAAC;EAChD,IAAItB,IAAI,CAACG,WAAW,KAAK,OAAO,EAAE;IAChCL,GAAG,CAACY,EAAE,EAAC,GAAApC,SAAA,CAAA8C,CAAC,EAAAK,gBAAA,KAAAA,gBAAA,GAAAH,sBAAA,oEAAGJ,QAAQ,EAAiCnB,IAAI,EAAQA,IAAI,GAAgB,MAClFD,GAAG,CACA4B,MAAM,CAAC3B,IAAI,GAAE,GAAAzB,SAAA,CAAA8C,CAAC,EAAAO,gBAAA,KAAAA,gBAAA,GAAAL,sBAAA,gBAAGvB,IAAI,CAAK,CAAC,CAC3B2B,MAAM,CAACR,QAAQ,GAAE,GAAA5C,SAAA,CAAA8C,CAAC,EAAAQ,gBAAA,KAAAA,gBAAA,GAAAN,sBAAA,oBAAUvB,IAAI,CAAE,CAAC,CACnCW,EAAE,CAACH,cAAc,CAAC3B,KAAK,EAAEmB,IAAI,EAAEC,IAAI,CAACQ,aAAa,CAAC,EAAE,MAAMV,GAAG,CAAC4B,MAAM,CAACH,OAAO,EAAExB,IAAI,CAAC,CAAC,CACxF;EACH;EACAD,GAAG,CAACY,EAAE,EAAC,GAAApC,SAAA,CAAA8C,CAAC,EAAAS,gBAAA,KAAAA,gBAAA,GAAAP,sBAAA,2BAAGC,OAAO,CAAgB,CAAC;EACnC,KAAK,MAAMP,CAAC,IAAIf,QAAQ,EAAE;IACxB,IAAIY,SAAS,CAACI,GAAG,CAACD,CAAC,CAAC,IAAKA,CAAC,KAAK,OAAO,IAAIhB,IAAI,CAACG,WAAW,KAAK,OAAQ,EAAE;MACvE2B,kBAAkB,CAACd,CAAC,CAAC;IACvB;EACF;EACAlB,GAAG,CAACiC,IAAI,EAAE;EACVnB,eAAe,CAACf,EAAE,CAAC;EACnBC,GAAG,CAACkC,KAAK,EAAE;EAEXlC,GAAG,CAACY,EAAE,EAAC,GAAApC,SAAA,CAAA8C,CAAC,EAAAa,gBAAA,KAAAA,gBAAA,GAAAX,sBAAA,2BAAGC,OAAO,GAAkB,MAAK;IACvCzB,GAAG,CAAC4B,MAAM,CAAC3B,IAAI,EAAEwB,OAAO,CAAC;IACzBW,gBAAgB,CAACrC,EAAE,EAAE0B,OAAO,CAAC;EAC/B,CAAC,CAAC;EAEF,SAASO,kBAAkBA,CAACd,CAAS;IACnC,QAAQA,CAAC;MACP,KAAK,QAAQ;QACXlB,GAAG,CACAqC,MAAM,EAAC,GAAA7D,SAAA,CAAA8C,CAAC,EAAAgB,gBAAA,KAAAA,gBAAA,GAAAd,sBAAA,kDAAGJ,QAAQ,EAAmBA,QAAQ,CAAe,CAAC,CAC9DQ,MAAM,CAACH,OAAO,GAAE,GAAAjD,SAAA,CAAA8C,CAAC,EAAAiB,gBAAA,KAAAA,gBAAA,GAAAf,sBAAA,oBAAQvB,IAAI,CAAE,CAAC,CAChCoC,MAAM,EAAC,GAAA7D,SAAA,CAAA8C,CAAC,EAAAkB,gBAAA,KAAAA,gBAAA,GAAAhB,sBAAA,sBAAGvB,IAAI,CAAW,CAAC,CAC3B2B,MAAM,CAACH,OAAO,GAAE,GAAAjD,SAAA,CAAA8C,CAAC,EAAAmB,gBAAA,KAAAA,gBAAA,GAAAjB,sBAAA,YAAI,CAAC;QACzB;MACF,KAAK,QAAQ;QACXxB,GAAG,CACAqC,MAAM,EACL,GAAA7D,SAAA,CAAA8C,CAAC,EAAAoB,iBAAA,KAAAA,iBAAA,GAAAlB,sBAAA,6GAAGJ,QAAQ,EAAoBnB,IAAI,EAC5BmB,QAAQ,EAAmBnB,IAAI,EAAOA,IAAI,EAAQA,IAAI,CAAG,CAClE,CACA2B,MAAM,CAACH,OAAO,GAAE,GAAAjD,SAAA,CAAA8C,CAAC,EAAAqB,iBAAA,KAAAA,iBAAA,GAAAnB,sBAAA,cAAIvB,IAAI,CAAE,CAAC;QAC/B;MACF,KAAK,SAAS;QACZD,GAAG,CACAqC,MAAM,EACL,GAAA7D,SAAA,CAAA8C,CAAC,EAAAsB,iBAAA,KAAAA,iBAAA,GAAApB,sBAAA,8HAAGJ,QAAQ,EAAqBnB,IAAI,EAC7BmB,QAAQ,EAAoBnB,IAAI,EAAOA,IAAI,EAAQA,IAAI,EAASA,IAAI,CAAQ,CACrF,CACA2B,MAAM,CAACH,OAAO,GAAE,GAAAjD,SAAA,CAAA8C,CAAC,EAAAuB,iBAAA,KAAAA,iBAAA,GAAArB,sBAAA,cAAIvB,IAAI,CAAE,CAAC;QAC/B;MACF,KAAK,SAAS;QACZD,GAAG,CACAqC,MAAM,EAAC,GAAA7D,SAAA,CAAA8C,CAAC,EAAAwB,iBAAA,KAAAA,iBAAA,GAAAtB,sBAAA,0DAAGvB,IAAI,EAAmBA,IAAI,EAAaA,IAAI,CAAW,CAAC,CACnE2B,MAAM,CAACH,OAAO,EAAE,KAAK,CAAC,CACtBY,MAAM,EAAC,GAAA7D,SAAA,CAAA8C,CAAC,EAAAyB,iBAAA,KAAAA,iBAAA,GAAAvB,sBAAA,wCAAGvB,IAAI,EAAkBA,IAAI,CAAQ,CAAC,CAC9C2B,MAAM,CAACH,OAAO,EAAE,IAAI,CAAC;QACxB;MACF,KAAK,MAAM;QACTzB,GAAG,CAACqC,MAAM,EAAC,GAAA7D,SAAA,CAAA8C,CAAC,EAAA0B,iBAAA,KAAAA,iBAAA,GAAAxB,sBAAA,sDAAGvB,IAAI,EAAcA,IAAI,EAAaA,IAAI,CAAY,CAAC;QACnED,GAAG,CAAC4B,MAAM,CAACH,OAAO,EAAE,IAAI,CAAC;QACzB;MAEF,KAAK,OAAO;QACVzB,GAAG,CACAqC,MAAM,EACL,GAAA7D,SAAA,CAAA8C,CAAC,EAAA2B,iBAAA,KAAAA,iBAAA,GAAAzB,sBAAA,2GAAGJ,QAAQ,EAAoBA,QAAQ,EACjCA,QAAQ,EAAqBnB,IAAI,CAAW,CACpD,CACA2B,MAAM,CAACH,OAAO,GAAE,GAAAjD,SAAA,CAAA8C,CAAC,EAAA4B,iBAAA,KAAAA,iBAAA,GAAA1B,sBAAA,eAAIvB,IAAI,CAAG,CAAC;IACpC;EACF;AACF;AAEA,SAASmC,gBAAgBA,CAAAe,IAAA,EAAsDC,IAAU;EAAA,IAA/D;IAACpD,GAAG;IAAEqD,UAAU;IAAEC;EAAkB,CAAe,GAAAH,IAAA;EAC3E;EACAnD,GAAG,CAACY,EAAE,EAAC,GAAApC,SAAA,CAAA8C,CAAC,EAAAiC,iBAAA,KAAAA,iBAAA,GAAA/B,sBAAA,2BAAG6B,UAAU,GAAkB,MACrCrD,GAAG,CAAC4B,MAAM,EAAC,GAAApD,SAAA,CAAA8C,CAAC,EAAAkC,iBAAA,KAAAA,iBAAA,GAAAhC,sBAAA,mBAAG6B,UAAU,EAAIC,kBAAkB,GAAKF,IAAI,CAAC,CAC1D;AACH;AAEA,SAAgBK,aAAaA,CAC3BrC,QAAkB,EAClBnB,IAAU,EACVyD,UAA4B,EACF;EAAA,IAA1BC,OAAO,GAAAC,SAAA,CAAAvE,MAAA,QAAAuE,SAAA,QAAAtE,SAAA,GAAAsE,SAAA,MAAGlF,QAAQ,CAACmF,OAAO;EAE1B,MAAMC,EAAE,GAAGH,OAAO,KAAKjF,QAAQ,CAACmF,OAAO,GAAGrF,SAAA,CAAAuF,SAAS,CAACD,EAAE,GAAGtF,SAAA,CAAAuF,SAAS,CAACC,GAAG;EACtE,IAAIC,IAAU;EACd,QAAQ7C,QAAQ;IACd,KAAK,MAAM;MACT,QAAO,GAAA5C,SAAA,CAAA8C,CAAC,EAAA4C,iBAAA,KAAAA,iBAAA,GAAA1C,sBAAA,uBAAGvB,IAAI,EAAI6D,EAAE;IACvB,KAAK,OAAO;MACVG,IAAI,IAAG,GAAAzF,SAAA,CAAA8C,CAAC,EAAA6C,iBAAA,KAAAA,iBAAA,GAAA3C,sBAAA,4BAAiBvB,IAAI,CAAG;MAChC;IACF,KAAK,QAAQ;MACXgE,IAAI,IAAG,GAAAzF,SAAA,CAAA8C,CAAC,EAAA8C,iBAAA,KAAAA,iBAAA,GAAA5C,sBAAA,kEAAGvB,IAAI,EAAcA,IAAI,EAAkCA,IAAI,CAAG;MAC1E;IACF,KAAK,SAAS;MACZgE,IAAI,GAAGI,OAAO,EAAC,GAAA7F,SAAA,CAAA8C,CAAC,EAAAgD,iBAAA,KAAAA,iBAAA,GAAA9C,sBAAA,oCAAKvB,IAAI,EAAmBA,IAAI,CAAG,CAAC;MACpD;IACF,KAAK,QAAQ;MACXgE,IAAI,GAAGI,OAAO,EAAE;MAChB;IACF;MACE,QAAO,GAAA7F,SAAA,CAAA8C,CAAC,EAAAiD,iBAAA,KAAAA,iBAAA,GAAA/C,sBAAA,8BAAUvB,IAAI,EAAI6D,EAAE,EAAI1C,QAAQ;EAC5C;EACA,OAAOuC,OAAO,KAAKjF,QAAQ,CAACmF,OAAO,GAAGI,IAAI,GAAG,IAAAzF,SAAA,CAAAgG,GAAG,EAACP,IAAI,CAAC;EAEtD,SAASI,OAAOA,CAAA,EAAkB;IAAA,IAAjBI,KAAA,GAAAb,SAAA,CAAAvE,MAAA,QAAAuE,SAAA,QAAAtE,SAAA,GAAAsE,SAAA,MAAcpF,SAAA,CAAAkG,GAAG;IAChC,OAAO,IAAAlG,SAAA,CAAAmG,GAAG,GAAC,GAAAnG,SAAA,CAAA8C,CAAC,EAAAsD,iBAAA,KAAAA,iBAAA,GAAApD,sBAAA,kCAAUvB,IAAI,GAAgBwE,KAAK,EAAEf,UAAU,IAAG,GAAAlF,SAAA,CAAA8C,CAAC,EAAAuD,iBAAA,KAAAA,iBAAA,GAAArD,sBAAA,uBAAYvB,IAAI,IAAMzB,SAAA,CAAAkG,GAAG,CAAC;EAC3F;AACF;AA/BA/F,OAAA,CAAA8E,aAAA,GAAAA,aAAA;AAiCA,SAAgBhD,cAAcA,CAC5BqE,SAAqB,EACrB7E,IAAU,EACVyD,UAA4B,EAC5BC,OAAkB;EAElB,IAAImB,SAAS,CAACzF,MAAM,KAAK,CAAC,EAAE;IAC1B,OAAOoE,aAAa,CAACqB,SAAS,CAAC,CAAC,CAAC,EAAE7E,IAAI,EAAEyD,UAAU,EAAEC,OAAO,CAAC;EAC/D;EACA,IAAIM,IAAU;EACd,MAAMnF,KAAK,GAAG,IAAAL,MAAA,CAAAsG,MAAM,EAACD,SAAS,CAAC;EAC/B,IAAIhG,KAAK,CAACkG,KAAK,IAAIlG,KAAK,CAACmG,MAAM,EAAE;IAC/B,MAAMC,MAAM,IAAG,GAAA1G,SAAA,CAAA8C,CAAC,EAAA6D,iBAAA,KAAAA,iBAAA,GAAA3D,sBAAA,kCAAUvB,IAAI,CAAc;IAC5CgE,IAAI,GAAGnF,KAAK,CAACsG,IAAI,GAAGF,MAAM,IAAG,GAAA1G,SAAA,CAAA8C,CAAC,EAAA+D,iBAAA,KAAAA,iBAAA,GAAA7D,sBAAA,sBAAIvB,IAAI,EAAOiF,MAAM,CAAE;IACrD,OAAOpG,KAAK,CAACsG,IAAI;IACjB,OAAOtG,KAAK,CAACkG,KAAK;IAClB,OAAOlG,KAAK,CAACmG,MAAM;EACrB,CAAC,MAAM;IACLhB,IAAI,GAAGzF,SAAA,CAAAkG,GAAG;EACZ;EACA,IAAI5F,KAAK,CAACwG,MAAM,EAAE,OAAOxG,KAAK,CAACyG,OAAO;EACtC,KAAK,MAAMrE,CAAC,IAAIpC,KAAK,EAAEmF,IAAI,GAAG,IAAAzF,SAAA,CAAAmG,GAAG,EAACV,IAAI,EAAER,aAAa,CAACvC,CAAa,EAAEjB,IAAI,EAAEyD,UAAU,EAAEC,OAAO,CAAC,CAAC;EAChG,OAAOM,IAAI;AACb;AAvBAtF,OAAA,CAAA8B,cAAA,GAAAA,cAAA;AA2BA,MAAM+E,SAAS,GAA2B;EACxCC,OAAO,EAAEC,KAAA;IAAA,IAAC;MAAC7G;IAAM,CAAC,GAAA6G,KAAA;IAAA,kBAAAC,MAAA,CAAgB9G,MAAM;EAAA,CAAE;EAC1C+G,MAAM,EAAEC,KAAA;IAAA,IAAC;MAAChH,MAAM;MAAEiH;IAAW,CAAC,GAAAD,KAAA;IAAA,OAC5B,OAAOhH,MAAM,IAAI,QAAQ,IAAG,GAAAL,SAAA,CAAA8C,CAAC,EAAAyE,iBAAA,KAAAA,iBAAA,GAAAvE,sBAAA,qBAAU3C,MAAM,KAAM,GAAAL,SAAA,CAAA8C,CAAC,EAAA0E,iBAAA,KAAAA,iBAAA,GAAAxE,sBAAA,qBAAUsE,WAAW,CAAG;EAAA;CAC/E;AAED,SAAgBhF,eAAeA,CAACf,EAAgB;EAC9C,MAAMkG,GAAG,GAAGC,mBAAmB,CAACnG,EAAE,CAAC;EACnC,IAAAxB,QAAA,CAAA4H,WAAW,EAACF,GAAG,EAAET,SAAS,CAAC;AAC7B;AAHA7G,OAAA,CAAAmC,eAAA,GAAAA,eAAA;AAKA,SAASoF,mBAAmBA,CAACnG,EAAgB;EAC3C,MAAM;IAACC,GAAG;IAAEC,IAAI;IAAEpB;EAAM,CAAC,GAAGkB,EAAE;EAC9B,MAAMqG,UAAU,GAAG,IAAA3H,MAAA,CAAA4H,cAAc,EAACtG,EAAE,EAAElB,MAAM,EAAE,MAAM,CAAC;EACrD,OAAO;IACLmB,GAAG;IACHsG,OAAO,EAAE,MAAM;IACfrG,IAAI;IACJpB,MAAM,EAAEA,MAAM,CAACG,IAAI;IACnBoH,UAAU;IACVN,WAAW,EAAEM,UAAU;IACvBG,YAAY,EAAE1H,MAAM;IACpB+G,MAAM,EAAE,EAAE;IACV7F;GACD;AACH","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}