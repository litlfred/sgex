{"ast":null,"code":"import { forEach, bind, pick, assign, isString, isObject, set } from 'min-dash';\n\n/**\n * Moddle base element.\n */\nfunction Base() {}\nBase.prototype.get = function (name) {\n  return this.$model.properties.get(this, name);\n};\nBase.prototype.set = function (name, value) {\n  this.$model.properties.set(this, name, value);\n};\n\n/**\n * A model element factory.\n *\n * @param {Moddle} model\n * @param {Properties} properties\n */\nfunction Factory(model, properties) {\n  this.model = model;\n  this.properties = properties;\n}\nFactory.prototype.createType = function (descriptor) {\n  var model = this.model;\n  var props = this.properties,\n    prototype = Object.create(Base.prototype);\n\n  // initialize default values\n  forEach(descriptor.properties, function (p) {\n    if (!p.isMany && p.default !== undefined) {\n      prototype[p.name] = p.default;\n    }\n  });\n  props.defineModel(prototype, model);\n  props.defineDescriptor(prototype, descriptor);\n  var name = descriptor.ns.name;\n\n  /**\n   * The new type constructor\n   */\n  function ModdleElement(attrs) {\n    props.define(this, '$type', {\n      value: name,\n      enumerable: true\n    });\n    props.define(this, '$attrs', {\n      value: {}\n    });\n    props.define(this, '$parent', {\n      writable: true\n    });\n    forEach(attrs, bind(function (val, key) {\n      this.set(key, val);\n    }, this));\n  }\n  ModdleElement.prototype = prototype;\n  ModdleElement.hasType = prototype.$instanceOf = this.model.hasType;\n\n  // static links\n  props.defineModel(ModdleElement, model);\n  props.defineDescriptor(ModdleElement, descriptor);\n  return ModdleElement;\n};\n\n/**\n * Built-in moddle types\n */\nvar BUILTINS = {\n  String: true,\n  Boolean: true,\n  Integer: true,\n  Real: true,\n  Element: true\n};\n\n/**\n * Converters for built in types from string representations\n */\nvar TYPE_CONVERTERS = {\n  String: function (s) {\n    return s;\n  },\n  Boolean: function (s) {\n    return s === 'true';\n  },\n  Integer: function (s) {\n    return parseInt(s, 10);\n  },\n  Real: function (s) {\n    return parseFloat(s);\n  }\n};\n\n/**\n * Convert a type to its real representation\n */\nfunction coerceType(type, value) {\n  var converter = TYPE_CONVERTERS[type];\n  if (converter) {\n    return converter(value);\n  } else {\n    return value;\n  }\n}\n\n/**\n * Return whether the given type is built-in\n */\nfunction isBuiltIn(type) {\n  return !!BUILTINS[type];\n}\n\n/**\n * Return whether the given type is simple\n */\nfunction isSimple(type) {\n  return !!TYPE_CONVERTERS[type];\n}\n\n/**\n * Parses a namespaced attribute name of the form (ns:)localName to an object,\n * given a default prefix to assume in case no explicit namespace is given.\n *\n * @param {String} name\n * @param {String} [defaultPrefix] the default prefix to take, if none is present.\n *\n * @return {Object} the parsed name\n */\nfunction parseName(name, defaultPrefix) {\n  var parts = name.split(/:/),\n    localName,\n    prefix;\n\n  // no prefix (i.e. only local name)\n  if (parts.length === 1) {\n    localName = name;\n    prefix = defaultPrefix;\n  }\n\n  // prefix + local name\n  else if (parts.length === 2) {\n    localName = parts[1];\n    prefix = parts[0];\n  } else {\n    throw new Error('expected <prefix:localName> or <localName>, got ' + name);\n  }\n  name = (prefix ? prefix + ':' : '') + localName;\n  return {\n    name: name,\n    prefix: prefix,\n    localName: localName\n  };\n}\n\n/**\n * A utility to build element descriptors.\n */\nfunction DescriptorBuilder(nameNs) {\n  this.ns = nameNs;\n  this.name = nameNs.name;\n  this.allTypes = [];\n  this.allTypesByName = {};\n  this.properties = [];\n  this.propertiesByName = {};\n}\nDescriptorBuilder.prototype.build = function () {\n  return pick(this, ['ns', 'name', 'allTypes', 'allTypesByName', 'properties', 'propertiesByName', 'bodyProperty', 'idProperty']);\n};\n\n/**\n * Add property at given index.\n *\n * @param {Object} p\n * @param {Number} [idx]\n * @param {Boolean} [validate=true]\n */\nDescriptorBuilder.prototype.addProperty = function (p, idx, validate) {\n  if (typeof idx === 'boolean') {\n    validate = idx;\n    idx = undefined;\n  }\n  this.addNamedProperty(p, validate !== false);\n  var properties = this.properties;\n  if (idx !== undefined) {\n    properties.splice(idx, 0, p);\n  } else {\n    properties.push(p);\n  }\n};\nDescriptorBuilder.prototype.replaceProperty = function (oldProperty, newProperty, replace) {\n  var oldNameNs = oldProperty.ns;\n  var props = this.properties,\n    propertiesByName = this.propertiesByName,\n    rename = oldProperty.name !== newProperty.name;\n  if (oldProperty.isId) {\n    if (!newProperty.isId) {\n      throw new Error('property <' + newProperty.ns.name + '> must be id property ' + 'to refine <' + oldProperty.ns.name + '>');\n    }\n    this.setIdProperty(newProperty, false);\n  }\n  if (oldProperty.isBody) {\n    if (!newProperty.isBody) {\n      throw new Error('property <' + newProperty.ns.name + '> must be body property ' + 'to refine <' + oldProperty.ns.name + '>');\n    }\n\n    // TODO: Check compatibility\n    this.setBodyProperty(newProperty, false);\n  }\n\n  // validate existence and get location of old property\n  var idx = props.indexOf(oldProperty);\n  if (idx === -1) {\n    throw new Error('property <' + oldNameNs.name + '> not found in property list');\n  }\n\n  // remove old property\n  props.splice(idx, 1);\n\n  // replacing the named property is intentional\n  //\n  //  * validate only if this is a \"rename\" operation\n  //  * add at specific index unless we \"replace\"\n  //\n  this.addProperty(newProperty, replace ? undefined : idx, rename);\n\n  // make new property available under old name\n  propertiesByName[oldNameNs.name] = propertiesByName[oldNameNs.localName] = newProperty;\n};\nDescriptorBuilder.prototype.redefineProperty = function (p, targetPropertyName, replace) {\n  var nsPrefix = p.ns.prefix;\n  var parts = targetPropertyName.split('#');\n  var name = parseName(parts[0], nsPrefix);\n  var attrName = parseName(parts[1], name.prefix).name;\n  var redefinedProperty = this.propertiesByName[attrName];\n  if (!redefinedProperty) {\n    throw new Error('refined property <' + attrName + '> not found');\n  } else {\n    this.replaceProperty(redefinedProperty, p, replace);\n  }\n  delete p.redefines;\n};\nDescriptorBuilder.prototype.addNamedProperty = function (p, validate) {\n  var ns = p.ns,\n    propsByName = this.propertiesByName;\n  if (validate) {\n    this.assertNotDefined(p, ns.name);\n    this.assertNotDefined(p, ns.localName);\n  }\n  propsByName[ns.name] = propsByName[ns.localName] = p;\n};\nDescriptorBuilder.prototype.removeNamedProperty = function (p) {\n  var ns = p.ns,\n    propsByName = this.propertiesByName;\n  delete propsByName[ns.name];\n  delete propsByName[ns.localName];\n};\nDescriptorBuilder.prototype.setBodyProperty = function (p, validate) {\n  if (validate && this.bodyProperty) {\n    throw new Error('body property defined multiple times ' + '(<' + this.bodyProperty.ns.name + '>, <' + p.ns.name + '>)');\n  }\n  this.bodyProperty = p;\n};\nDescriptorBuilder.prototype.setIdProperty = function (p, validate) {\n  if (validate && this.idProperty) {\n    throw new Error('id property defined multiple times ' + '(<' + this.idProperty.ns.name + '>, <' + p.ns.name + '>)');\n  }\n  this.idProperty = p;\n};\nDescriptorBuilder.prototype.assertNotTrait = function (typeDescriptor) {\n  const _extends = typeDescriptor.extends || [];\n  if (_extends.length) {\n    throw new Error(\"cannot create <\".concat(typeDescriptor.name, \"> extending <\").concat(typeDescriptor.extends, \">\"));\n  }\n};\nDescriptorBuilder.prototype.assertNotDefined = function (p, name) {\n  var propertyName = p.name,\n    definedProperty = this.propertiesByName[propertyName];\n  if (definedProperty) {\n    throw new Error('property <' + propertyName + '> already defined; ' + 'override of <' + definedProperty.definedBy.ns.name + '#' + definedProperty.ns.name + '> by ' + '<' + p.definedBy.ns.name + '#' + p.ns.name + '> not allowed without redefines');\n  }\n};\nDescriptorBuilder.prototype.hasProperty = function (name) {\n  return this.propertiesByName[name];\n};\nDescriptorBuilder.prototype.addTrait = function (t, inherited) {\n  if (inherited) {\n    this.assertNotTrait(t);\n  }\n  var typesByName = this.allTypesByName,\n    types = this.allTypes;\n  var typeName = t.name;\n  if (typeName in typesByName) {\n    return;\n  }\n  forEach(t.properties, bind(function (p) {\n    // clone property to allow extensions\n    p = assign({}, p, {\n      name: p.ns.localName,\n      inherited: inherited\n    });\n    Object.defineProperty(p, 'definedBy', {\n      value: t\n    });\n    var replaces = p.replaces,\n      redefines = p.redefines;\n\n    // add replace/redefine support\n    if (replaces || redefines) {\n      this.redefineProperty(p, replaces || redefines, replaces);\n    } else {\n      if (p.isBody) {\n        this.setBodyProperty(p);\n      }\n      if (p.isId) {\n        this.setIdProperty(p);\n      }\n      this.addProperty(p);\n    }\n  }, this));\n  types.push(t);\n  typesByName[typeName] = t;\n};\n\n/**\n * A registry of Moddle packages.\n *\n * @param {Array<Package>} packages\n * @param {Properties} properties\n */\nfunction Registry(packages, properties) {\n  this.packageMap = {};\n  this.typeMap = {};\n  this.packages = [];\n  this.properties = properties;\n  forEach(packages, bind(this.registerPackage, this));\n}\nRegistry.prototype.getPackage = function (uriOrPrefix) {\n  return this.packageMap[uriOrPrefix];\n};\nRegistry.prototype.getPackages = function () {\n  return this.packages;\n};\nRegistry.prototype.registerPackage = function (pkg) {\n  // copy package\n  pkg = assign({}, pkg);\n  var pkgMap = this.packageMap;\n  ensureAvailable(pkgMap, pkg, 'prefix');\n  ensureAvailable(pkgMap, pkg, 'uri');\n\n  // register types\n  forEach(pkg.types, bind(function (descriptor) {\n    this.registerType(descriptor, pkg);\n  }, this));\n  pkgMap[pkg.uri] = pkgMap[pkg.prefix] = pkg;\n  this.packages.push(pkg);\n};\n\n/**\n * Register a type from a specific package with us\n */\nRegistry.prototype.registerType = function (type, pkg) {\n  type = assign({}, type, {\n    superClass: (type.superClass || []).slice(),\n    extends: (type.extends || []).slice(),\n    properties: (type.properties || []).slice(),\n    meta: assign(type.meta || {})\n  });\n  var ns = parseName(type.name, pkg.prefix),\n    name = ns.name,\n    propertiesByName = {};\n\n  // parse properties\n  forEach(type.properties, bind(function (p) {\n    // namespace property names\n    var propertyNs = parseName(p.name, ns.prefix),\n      propertyName = propertyNs.name;\n\n    // namespace property types\n    if (!isBuiltIn(p.type)) {\n      p.type = parseName(p.type, propertyNs.prefix).name;\n    }\n    assign(p, {\n      ns: propertyNs,\n      name: propertyName\n    });\n    propertiesByName[propertyName] = p;\n  }, this));\n\n  // update ns + name\n  assign(type, {\n    ns: ns,\n    name: name,\n    propertiesByName: propertiesByName\n  });\n  forEach(type.extends, bind(function (extendsName) {\n    var extendsNameNs = parseName(extendsName, ns.prefix);\n    var extended = this.typeMap[extendsNameNs.name];\n    extended.traits = extended.traits || [];\n    extended.traits.push(name);\n  }, this));\n\n  // link to package\n  this.definePackage(type, pkg);\n\n  // register\n  this.typeMap[name] = type;\n};\n\n/**\n * Traverse the type hierarchy from bottom to top,\n * calling iterator with (type, inherited) for all elements in\n * the inheritance chain.\n *\n * @param {Object} nsName\n * @param {Function} iterator\n * @param {Boolean} [trait=false]\n */\nRegistry.prototype.mapTypes = function (nsName, iterator, trait) {\n  var type = isBuiltIn(nsName.name) ? {\n    name: nsName.name\n  } : this.typeMap[nsName.name];\n  var self = this;\n\n  /**\n   * Traverse the selected super type or trait\n   *\n   * @param {String} cls\n   * @param {Boolean} [trait=false]\n   */\n  function traverse(cls, trait) {\n    var parentNs = parseName(cls, isBuiltIn(cls) ? '' : nsName.prefix);\n    self.mapTypes(parentNs, iterator, trait);\n  }\n\n  /**\n   * Traverse the selected trait.\n   *\n   * @param {String} cls\n   */\n  function traverseTrait(cls) {\n    return traverse(cls, true);\n  }\n\n  /**\n   * Traverse the selected super type\n   *\n   * @param {String} cls\n   */\n  function traverseSuper(cls) {\n    return traverse(cls, false);\n  }\n  if (!type) {\n    throw new Error('unknown type <' + nsName.name + '>');\n  }\n  forEach(type.superClass, trait ? traverseTrait : traverseSuper);\n\n  // call iterator with (type, inherited=!trait)\n  iterator(type, !trait);\n  forEach(type.traits, traverseTrait);\n};\n\n/**\n * Returns the effective descriptor for a type.\n *\n * @param  {String} type the namespaced name (ns:localName) of the type\n *\n * @return {Descriptor} the resulting effective descriptor\n */\nRegistry.prototype.getEffectiveDescriptor = function (name) {\n  var nsName = parseName(name);\n  var builder = new DescriptorBuilder(nsName);\n  this.mapTypes(nsName, function (type, inherited) {\n    builder.addTrait(type, inherited);\n  });\n  var descriptor = builder.build();\n\n  // define package link\n  this.definePackage(descriptor, descriptor.allTypes[descriptor.allTypes.length - 1].$pkg);\n  return descriptor;\n};\nRegistry.prototype.definePackage = function (target, pkg) {\n  this.properties.define(target, '$pkg', {\n    value: pkg\n  });\n};\n\n// helpers ////////////////////////////\n\nfunction ensureAvailable(packageMap, pkg, identifierKey) {\n  var value = pkg[identifierKey];\n  if (value in packageMap) {\n    throw new Error('package with ' + identifierKey + ' <' + value + '> already defined');\n  }\n}\n\n/**\n * A utility that gets and sets properties of model elements.\n *\n * @param {Model} model\n */\nfunction Properties(model) {\n  this.model = model;\n}\n\n/**\n * Sets a named property on the target element.\n * If the value is undefined, the property gets deleted.\n *\n * @param {Object} target\n * @param {String} name\n * @param {Object} value\n */\nProperties.prototype.set = function (target, name, value) {\n  if (!isString(name) || !name.length) {\n    throw new TypeError('property name must be a non-empty string');\n  }\n  var property = this.getProperty(target, name);\n  var propertyName = property && property.name;\n  if (isUndefined(value)) {\n    // unset the property, if the specified value is undefined;\n    // delete from $attrs (for extensions) or the target itself\n    if (property) {\n      delete target[propertyName];\n    } else {\n      delete target.$attrs[stripGlobal(name)];\n    }\n  } else {\n    // set the property, defining well defined properties on the fly\n    // or simply updating them in target.$attrs (for extensions)\n    if (property) {\n      if (propertyName in target) {\n        target[propertyName] = value;\n      } else {\n        defineProperty(target, property, value);\n      }\n    } else {\n      target.$attrs[stripGlobal(name)] = value;\n    }\n  }\n};\n\n/**\n * Returns the named property of the given element\n *\n * @param  {Object} target\n * @param  {String} name\n *\n * @return {Object}\n */\nProperties.prototype.get = function (target, name) {\n  var property = this.getProperty(target, name);\n  if (!property) {\n    return target.$attrs[stripGlobal(name)];\n  }\n  var propertyName = property.name;\n\n  // check if access to collection property and lazily initialize it\n  if (!target[propertyName] && property.isMany) {\n    defineProperty(target, property, []);\n  }\n  return target[propertyName];\n};\n\n/**\n * Define a property on the target element\n *\n * @param  {Object} target\n * @param  {String} name\n * @param  {Object} options\n */\nProperties.prototype.define = function (target, name, options) {\n  if (!options.writable) {\n    var value = options.value;\n\n    // use getters for read-only variables to support ES6 proxies\n    // cf. https://github.com/bpmn-io/internal-docs/issues/386\n    options = assign({}, options, {\n      get: function () {\n        return value;\n      }\n    });\n    delete options.value;\n  }\n  Object.defineProperty(target, name, options);\n};\n\n/**\n * Define the descriptor for an element\n */\nProperties.prototype.defineDescriptor = function (target, descriptor) {\n  this.define(target, '$descriptor', {\n    value: descriptor\n  });\n};\n\n/**\n * Define the model for an element\n */\nProperties.prototype.defineModel = function (target, model) {\n  this.define(target, '$model', {\n    value: model\n  });\n};\n\n/**\n * Return property with the given name on the element.\n *\n * @param {any} target\n * @param {string} name\n *\n * @return {object | null} property\n */\nProperties.prototype.getProperty = function (target, name) {\n  var model = this.model;\n  var property = model.getPropertyDescriptor(target, name);\n  if (property) {\n    return property;\n  }\n  if (name.includes(':')) {\n    return null;\n  }\n  const strict = model.config.strict;\n  if (typeof strict !== 'undefined') {\n    const error = new TypeError(\"unknown property <\".concat(name, \"> on <\").concat(target.$type, \">\"));\n    if (strict) {\n      throw error;\n    } else {\n      // eslint-disable-next-line no-undef\n      typeof console !== 'undefined' && console.warn(error);\n    }\n  }\n  return null;\n};\nfunction isUndefined(val) {\n  return typeof val === 'undefined';\n}\nfunction defineProperty(target, property, value) {\n  Object.defineProperty(target, property.name, {\n    enumerable: !property.isReference,\n    writable: true,\n    value: value,\n    configurable: true\n  });\n}\nfunction stripGlobal(name) {\n  return name.replace(/^:/, '');\n}\n\n// Moddle implementation /////////////////////////////////////////////////\n\n/**\n * @class Moddle\n *\n * A model that can be used to create elements of a specific type.\n *\n * @example\n *\n * var Moddle = require('moddle');\n *\n * var pkg = {\n *   name: 'mypackage',\n *   prefix: 'my',\n *   types: [\n *     { name: 'Root' }\n *   ]\n * };\n *\n * var moddle = new Moddle([pkg]);\n *\n * @param {Array<Package>} packages the packages to contain\n *\n * @param { { strict?: boolean } } [config] moddle configuration\n */\nfunction Moddle(packages) {\n  let config = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  this.properties = new Properties(this);\n  this.factory = new Factory(this, this.properties);\n  this.registry = new Registry(packages, this.properties);\n  this.typeCache = {};\n  this.config = config;\n}\n\n/**\n * Create an instance of the specified type.\n *\n * @method Moddle#create\n *\n * @example\n *\n * var foo = moddle.create('my:Foo');\n * var bar = moddle.create('my:Bar', { id: 'BAR_1' });\n *\n * @param  {String|Object} descriptor the type descriptor or name know to the model\n * @param  {Object} attrs   a number of attributes to initialize the model instance with\n * @return {Object}         model instance\n */\nModdle.prototype.create = function (descriptor, attrs) {\n  var Type = this.getType(descriptor);\n  if (!Type) {\n    throw new Error('unknown type <' + descriptor + '>');\n  }\n  return new Type(attrs);\n};\n\n/**\n * Returns the type representing a given descriptor\n *\n * @method Moddle#getType\n *\n * @example\n *\n * var Foo = moddle.getType('my:Foo');\n * var foo = new Foo({ 'id' : 'FOO_1' });\n *\n * @param  {String|Object} descriptor the type descriptor or name know to the model\n * @return {Object}         the type representing the descriptor\n */\nModdle.prototype.getType = function (descriptor) {\n  var cache = this.typeCache;\n  var name = isString(descriptor) ? descriptor : descriptor.ns.name;\n  var type = cache[name];\n  if (!type) {\n    descriptor = this.registry.getEffectiveDescriptor(name);\n    type = cache[name] = this.factory.createType(descriptor);\n  }\n  return type;\n};\n\n/**\n * Creates an any-element type to be used within model instances.\n *\n * This can be used to create custom elements that lie outside the meta-model.\n * The created element contains all the meta-data required to serialize it\n * as part of meta-model elements.\n *\n * @method Moddle#createAny\n *\n * @example\n *\n * var foo = moddle.createAny('vendor:Foo', 'http://vendor', {\n *   value: 'bar'\n * });\n *\n * var container = moddle.create('my:Container', 'http://my', {\n *   any: [ foo ]\n * });\n *\n * // go ahead and serialize the stuff\n *\n *\n * @param  {String} name  the name of the element\n * @param  {String} nsUri the namespace uri of the element\n * @param  {Object} [properties] a map of properties to initialize the instance with\n * @return {Object} the any type instance\n */\nModdle.prototype.createAny = function (name, nsUri, properties) {\n  var nameNs = parseName(name);\n  var element = {\n    $type: name,\n    $instanceOf: function (type) {\n      return type === this.$type;\n    },\n    get: function (key) {\n      return this[key];\n    },\n    set: function (key, value) {\n      set(this, [key], value);\n    }\n  };\n  var descriptor = {\n    name: name,\n    isGeneric: true,\n    ns: {\n      prefix: nameNs.prefix,\n      localName: nameNs.localName,\n      uri: nsUri\n    }\n  };\n  this.properties.defineDescriptor(element, descriptor);\n  this.properties.defineModel(element, this);\n  this.properties.define(element, 'get', {\n    enumerable: false,\n    writable: true\n  });\n  this.properties.define(element, 'set', {\n    enumerable: false,\n    writable: true\n  });\n  this.properties.define(element, '$parent', {\n    enumerable: false,\n    writable: true\n  });\n  this.properties.define(element, '$instanceOf', {\n    enumerable: false,\n    writable: true\n  });\n  forEach(properties, function (a, key) {\n    if (isObject(a) && a.value !== undefined) {\n      element[a.name] = a.value;\n    } else {\n      element[key] = a;\n    }\n  });\n  return element;\n};\n\n/**\n * Returns a registered package by uri or prefix\n *\n * @return {Object} the package\n */\nModdle.prototype.getPackage = function (uriOrPrefix) {\n  return this.registry.getPackage(uriOrPrefix);\n};\n\n/**\n * Returns a snapshot of all known packages\n *\n * @return {Object} the package\n */\nModdle.prototype.getPackages = function () {\n  return this.registry.getPackages();\n};\n\n/**\n * Returns the descriptor for an element\n */\nModdle.prototype.getElementDescriptor = function (element) {\n  return element.$descriptor;\n};\n\n/**\n * Returns true if the given descriptor or instance\n * represents the given type.\n *\n * May be applied to this, if element is omitted.\n */\nModdle.prototype.hasType = function (element, type) {\n  if (type === undefined) {\n    type = element;\n    element = this;\n  }\n  var descriptor = element.$model.getElementDescriptor(element);\n  return type in descriptor.allTypesByName;\n};\n\n/**\n * Returns the descriptor of an elements named property\n */\nModdle.prototype.getPropertyDescriptor = function (element, property) {\n  return this.getElementDescriptor(element).propertiesByName[property];\n};\n\n/**\n * Returns a mapped type's descriptor\n */\nModdle.prototype.getTypeDescriptor = function (type) {\n  return this.registry.typeMap[type];\n};\nexport { Moddle, coerceType, isBuiltIn as isBuiltInType, isSimple as isSimpleType, parseName as parseNameNS };","map":{"version":3,"names":["Base","prototype","get","name","$model","properties","set","value","Factory","model","createType","descriptor","props","Object","create","forEach","p","isMany","default","undefined","defineModel","defineDescriptor","ns","ModdleElement","attrs","define","enumerable","writable","bind","val","key","hasType","$instanceOf","BUILTINS","String","Boolean","Integer","Real","Element","TYPE_CONVERTERS","s","parseInt","parseFloat","coerceType","type","converter","isBuiltIn","isSimple","parseName","defaultPrefix","parts","split","localName","prefix","length","Error","DescriptorBuilder","nameNs","allTypes","allTypesByName","propertiesByName","build","pick","addProperty","idx","validate","addNamedProperty","splice","push","replaceProperty","oldProperty","newProperty","replace","oldNameNs","rename","isId","setIdProperty","isBody","setBodyProperty","indexOf","redefineProperty","targetPropertyName","nsPrefix","attrName","redefinedProperty","redefines","propsByName","assertNotDefined","removeNamedProperty","bodyProperty","idProperty","assertNotTrait","typeDescriptor","_extends","extends","concat","propertyName","definedProperty","definedBy","hasProperty","addTrait","t","inherited","typesByName","types","typeName","assign","defineProperty","replaces","Registry","packages","packageMap","typeMap","registerPackage","getPackage","uriOrPrefix","getPackages","pkg","pkgMap","ensureAvailable","registerType","uri","superClass","slice","meta","propertyNs","extendsName","extendsNameNs","extended","traits","definePackage","mapTypes","nsName","iterator","trait","self","traverse","cls","parentNs","traverseTrait","traverseSuper","getEffectiveDescriptor","builder","$pkg","target","identifierKey","Properties","isString","TypeError","property","getProperty","isUndefined","$attrs","stripGlobal","options","getPropertyDescriptor","includes","strict","config","error","$type","console","warn","isReference","configurable","Moddle","arguments","factory","registry","typeCache","Type","getType","cache","createAny","nsUri","element","isGeneric","a","isObject","getElementDescriptor","$descriptor","getTypeDescriptor"],"sources":["/home/runner/work/sgex/sgex/node_modules/moddle/lib/base.js","/home/runner/work/sgex/sgex/node_modules/moddle/lib/factory.js","/home/runner/work/sgex/sgex/node_modules/moddle/lib/types.js","/home/runner/work/sgex/sgex/node_modules/moddle/lib/ns.js","/home/runner/work/sgex/sgex/node_modules/moddle/lib/descriptor-builder.js","/home/runner/work/sgex/sgex/node_modules/moddle/lib/registry.js","/home/runner/work/sgex/sgex/node_modules/moddle/lib/properties.js","/home/runner/work/sgex/sgex/node_modules/moddle/lib/moddle.js"],"sourcesContent":["/**\n * Moddle base element.\n */\nexport default function Base() { }\n\nBase.prototype.get = function(name) {\n  return this.$model.properties.get(this, name);\n};\n\nBase.prototype.set = function(name, value) {\n  this.$model.properties.set(this, name, value);\n};","import {\n  forEach,\n  bind\n} from 'min-dash';\n\nimport Base from './base.js';\n\n/**\n * A model element factory.\n *\n * @param {Moddle} model\n * @param {Properties} properties\n */\nexport default function Factory(model, properties) {\n  this.model = model;\n  this.properties = properties;\n}\n\n\nFactory.prototype.createType = function(descriptor) {\n\n  var model = this.model;\n\n  var props = this.properties,\n      prototype = Object.create(Base.prototype);\n\n  // initialize default values\n  forEach(descriptor.properties, function(p) {\n    if (!p.isMany && p.default !== undefined) {\n      prototype[p.name] = p.default;\n    }\n  });\n\n  props.defineModel(prototype, model);\n  props.defineDescriptor(prototype, descriptor);\n\n  var name = descriptor.ns.name;\n\n  /**\n   * The new type constructor\n   */\n  function ModdleElement(attrs) {\n    props.define(this, '$type', { value: name, enumerable: true });\n    props.define(this, '$attrs', { value: {} });\n    props.define(this, '$parent', { writable: true });\n\n    forEach(attrs, bind(function(val, key) {\n      this.set(key, val);\n    }, this));\n  }\n\n  ModdleElement.prototype = prototype;\n\n  ModdleElement.hasType = prototype.$instanceOf = this.model.hasType;\n\n  // static links\n  props.defineModel(ModdleElement, model);\n  props.defineDescriptor(ModdleElement, descriptor);\n\n  return ModdleElement;\n};","/**\n * Built-in moddle types\n */\nvar BUILTINS = {\n  String: true,\n  Boolean: true,\n  Integer: true,\n  Real: true,\n  Element: true\n};\n\n/**\n * Converters for built in types from string representations\n */\nvar TYPE_CONVERTERS = {\n  String: function(s) { return s; },\n  Boolean: function(s) { return s === 'true'; },\n  Integer: function(s) { return parseInt(s, 10); },\n  Real: function(s) { return parseFloat(s); }\n};\n\n/**\n * Convert a type to its real representation\n */\nexport function coerceType(type, value) {\n\n  var converter = TYPE_CONVERTERS[type];\n\n  if (converter) {\n    return converter(value);\n  } else {\n    return value;\n  }\n}\n\n/**\n * Return whether the given type is built-in\n */\nexport function isBuiltIn(type) {\n  return !!BUILTINS[type];\n}\n\n/**\n * Return whether the given type is simple\n */\nexport function isSimple(type) {\n  return !!TYPE_CONVERTERS[type];\n}","/**\n * Parses a namespaced attribute name of the form (ns:)localName to an object,\n * given a default prefix to assume in case no explicit namespace is given.\n *\n * @param {String} name\n * @param {String} [defaultPrefix] the default prefix to take, if none is present.\n *\n * @return {Object} the parsed name\n */\nexport function parseName(name, defaultPrefix) {\n  var parts = name.split(/:/),\n      localName, prefix;\n\n  // no prefix (i.e. only local name)\n  if (parts.length === 1) {\n    localName = name;\n    prefix = defaultPrefix;\n  }\n\n  // prefix + local name\n  else if (parts.length === 2) {\n    localName = parts[1];\n    prefix = parts[0];\n  }\n\n  else {\n    throw new Error('expected <prefix:localName> or <localName>, got ' + name);\n  }\n\n  name = (prefix ? prefix + ':' : '') + localName;\n\n  return {\n    name: name,\n    prefix: prefix,\n    localName: localName\n  };\n}","import {\n  pick,\n  assign,\n  forEach,\n  bind\n} from 'min-dash';\n\nimport {\n  parseName as parseNameNs\n} from './ns.js';\n\n\n/**\n * A utility to build element descriptors.\n */\nexport default function DescriptorBuilder(nameNs) {\n  this.ns = nameNs;\n  this.name = nameNs.name;\n  this.allTypes = [];\n  this.allTypesByName = {};\n  this.properties = [];\n  this.propertiesByName = {};\n}\n\n\nDescriptorBuilder.prototype.build = function() {\n  return pick(this, [\n    'ns',\n    'name',\n    'allTypes',\n    'allTypesByName',\n    'properties',\n    'propertiesByName',\n    'bodyProperty',\n    'idProperty'\n  ]);\n};\n\n/**\n * Add property at given index.\n *\n * @param {Object} p\n * @param {Number} [idx]\n * @param {Boolean} [validate=true]\n */\nDescriptorBuilder.prototype.addProperty = function(p, idx, validate) {\n\n  if (typeof idx === 'boolean') {\n    validate = idx;\n    idx = undefined;\n  }\n\n  this.addNamedProperty(p, validate !== false);\n\n  var properties = this.properties;\n\n  if (idx !== undefined) {\n    properties.splice(idx, 0, p);\n  } else {\n    properties.push(p);\n  }\n};\n\n\nDescriptorBuilder.prototype.replaceProperty = function(oldProperty, newProperty, replace) {\n  var oldNameNs = oldProperty.ns;\n\n  var props = this.properties,\n      propertiesByName = this.propertiesByName,\n      rename = oldProperty.name !== newProperty.name;\n\n  if (oldProperty.isId) {\n    if (!newProperty.isId) {\n      throw new Error(\n        'property <' + newProperty.ns.name + '> must be id property ' +\n        'to refine <' + oldProperty.ns.name + '>');\n    }\n\n    this.setIdProperty(newProperty, false);\n  }\n\n  if (oldProperty.isBody) {\n\n    if (!newProperty.isBody) {\n      throw new Error(\n        'property <' + newProperty.ns.name + '> must be body property ' +\n        'to refine <' + oldProperty.ns.name + '>');\n    }\n\n    // TODO: Check compatibility\n    this.setBodyProperty(newProperty, false);\n  }\n\n  // validate existence and get location of old property\n  var idx = props.indexOf(oldProperty);\n  if (idx === -1) {\n    throw new Error('property <' + oldNameNs.name + '> not found in property list');\n  }\n\n  // remove old property\n  props.splice(idx, 1);\n\n  // replacing the named property is intentional\n  //\n  //  * validate only if this is a \"rename\" operation\n  //  * add at specific index unless we \"replace\"\n  //\n  this.addProperty(newProperty, replace ? undefined : idx, rename);\n\n  // make new property available under old name\n  propertiesByName[oldNameNs.name] = propertiesByName[oldNameNs.localName] = newProperty;\n};\n\n\nDescriptorBuilder.prototype.redefineProperty = function(p, targetPropertyName, replace) {\n\n  var nsPrefix = p.ns.prefix;\n  var parts = targetPropertyName.split('#');\n\n  var name = parseNameNs(parts[0], nsPrefix);\n  var attrName = parseNameNs(parts[1], name.prefix).name;\n\n  var redefinedProperty = this.propertiesByName[attrName];\n  if (!redefinedProperty) {\n    throw new Error('refined property <' + attrName + '> not found');\n  } else {\n    this.replaceProperty(redefinedProperty, p, replace);\n  }\n\n  delete p.redefines;\n};\n\nDescriptorBuilder.prototype.addNamedProperty = function(p, validate) {\n  var ns = p.ns,\n      propsByName = this.propertiesByName;\n\n  if (validate) {\n    this.assertNotDefined(p, ns.name);\n    this.assertNotDefined(p, ns.localName);\n  }\n\n  propsByName[ns.name] = propsByName[ns.localName] = p;\n};\n\nDescriptorBuilder.prototype.removeNamedProperty = function(p) {\n  var ns = p.ns,\n      propsByName = this.propertiesByName;\n\n  delete propsByName[ns.name];\n  delete propsByName[ns.localName];\n};\n\nDescriptorBuilder.prototype.setBodyProperty = function(p, validate) {\n\n  if (validate && this.bodyProperty) {\n    throw new Error(\n      'body property defined multiple times ' +\n      '(<' + this.bodyProperty.ns.name + '>, <' + p.ns.name + '>)');\n  }\n\n  this.bodyProperty = p;\n};\n\nDescriptorBuilder.prototype.setIdProperty = function(p, validate) {\n\n  if (validate && this.idProperty) {\n    throw new Error(\n      'id property defined multiple times ' +\n      '(<' + this.idProperty.ns.name + '>, <' + p.ns.name + '>)');\n  }\n\n  this.idProperty = p;\n};\n\nDescriptorBuilder.prototype.assertNotTrait = function(typeDescriptor) {\n\n  const _extends = typeDescriptor.extends || [];\n\n  if (_extends.length) {\n    throw new Error(\n      `cannot create <${ typeDescriptor.name }> extending <${ typeDescriptor.extends }>`\n    );\n  }\n};\n\nDescriptorBuilder.prototype.assertNotDefined = function(p, name) {\n  var propertyName = p.name,\n      definedProperty = this.propertiesByName[propertyName];\n\n  if (definedProperty) {\n    throw new Error(\n      'property <' + propertyName + '> already defined; ' +\n      'override of <' + definedProperty.definedBy.ns.name + '#' + definedProperty.ns.name + '> by ' +\n      '<' + p.definedBy.ns.name + '#' + p.ns.name + '> not allowed without redefines');\n  }\n};\n\nDescriptorBuilder.prototype.hasProperty = function(name) {\n  return this.propertiesByName[name];\n};\n\nDescriptorBuilder.prototype.addTrait = function(t, inherited) {\n\n  if (inherited) {\n    this.assertNotTrait(t);\n  }\n\n  var typesByName = this.allTypesByName,\n      types = this.allTypes;\n\n  var typeName = t.name;\n\n  if (typeName in typesByName) {\n    return;\n  }\n\n  forEach(t.properties, bind(function(p) {\n\n    // clone property to allow extensions\n    p = assign({}, p, {\n      name: p.ns.localName,\n      inherited: inherited\n    });\n\n    Object.defineProperty(p, 'definedBy', {\n      value: t\n    });\n\n    var replaces = p.replaces,\n        redefines = p.redefines;\n\n    // add replace/redefine support\n    if (replaces || redefines) {\n      this.redefineProperty(p, replaces || redefines, replaces);\n    } else {\n      if (p.isBody) {\n        this.setBodyProperty(p);\n      }\n      if (p.isId) {\n        this.setIdProperty(p);\n      }\n      this.addProperty(p);\n    }\n  }, this));\n\n  types.push(t);\n  typesByName[typeName] = t;\n};","import {\n  assign,\n  forEach,\n  bind\n} from 'min-dash';\n\nimport {\n  isBuiltIn as isBuiltInType\n} from './types.js';\n\nimport DescriptorBuilder from './descriptor-builder.js';\n\nimport {\n  parseName as parseNameNs\n} from './ns.js';\n\n\n/**\n * A registry of Moddle packages.\n *\n * @param {Array<Package>} packages\n * @param {Properties} properties\n */\nexport default function Registry(packages, properties) {\n  this.packageMap = {};\n  this.typeMap = {};\n\n  this.packages = [];\n\n  this.properties = properties;\n\n  forEach(packages, bind(this.registerPackage, this));\n}\n\n\nRegistry.prototype.getPackage = function(uriOrPrefix) {\n  return this.packageMap[uriOrPrefix];\n};\n\nRegistry.prototype.getPackages = function() {\n  return this.packages;\n};\n\n\nRegistry.prototype.registerPackage = function(pkg) {\n\n  // copy package\n  pkg = assign({}, pkg);\n\n  var pkgMap = this.packageMap;\n\n  ensureAvailable(pkgMap, pkg, 'prefix');\n  ensureAvailable(pkgMap, pkg, 'uri');\n\n  // register types\n  forEach(pkg.types, bind(function(descriptor) {\n    this.registerType(descriptor, pkg);\n  }, this));\n\n  pkgMap[pkg.uri] = pkgMap[pkg.prefix] = pkg;\n  this.packages.push(pkg);\n};\n\n\n/**\n * Register a type from a specific package with us\n */\nRegistry.prototype.registerType = function(type, pkg) {\n\n  type = assign({}, type, {\n    superClass: (type.superClass || []).slice(),\n    extends: (type.extends || []).slice(),\n    properties: (type.properties || []).slice(),\n    meta: assign(({}, type.meta || {}))\n  });\n\n  var ns = parseNameNs(type.name, pkg.prefix),\n      name = ns.name,\n      propertiesByName = {};\n\n  // parse properties\n  forEach(type.properties, bind(function(p) {\n\n    // namespace property names\n    var propertyNs = parseNameNs(p.name, ns.prefix),\n        propertyName = propertyNs.name;\n\n    // namespace property types\n    if (!isBuiltInType(p.type)) {\n      p.type = parseNameNs(p.type, propertyNs.prefix).name;\n    }\n\n    assign(p, {\n      ns: propertyNs,\n      name: propertyName\n    });\n\n    propertiesByName[propertyName] = p;\n  }, this));\n\n  // update ns + name\n  assign(type, {\n    ns: ns,\n    name: name,\n    propertiesByName: propertiesByName\n  });\n\n  forEach(type.extends, bind(function(extendsName) {\n    var extendsNameNs = parseNameNs(extendsName, ns.prefix);\n\n    var extended = this.typeMap[extendsNameNs.name];\n\n    extended.traits = extended.traits || [];\n    extended.traits.push(name);\n  }, this));\n\n  // link to package\n  this.definePackage(type, pkg);\n\n  // register\n  this.typeMap[name] = type;\n};\n\n\n/**\n * Traverse the type hierarchy from bottom to top,\n * calling iterator with (type, inherited) for all elements in\n * the inheritance chain.\n *\n * @param {Object} nsName\n * @param {Function} iterator\n * @param {Boolean} [trait=false]\n */\nRegistry.prototype.mapTypes = function(nsName, iterator, trait) {\n\n  var type = isBuiltInType(nsName.name) ? { name: nsName.name } : this.typeMap[nsName.name];\n\n  var self = this;\n\n  /**\n   * Traverse the selected super type or trait\n   *\n   * @param {String} cls\n   * @param {Boolean} [trait=false]\n   */\n  function traverse(cls, trait) {\n    var parentNs = parseNameNs(cls, isBuiltInType(cls) ? '' : nsName.prefix);\n    self.mapTypes(parentNs, iterator, trait);\n  }\n\n  /**\n   * Traverse the selected trait.\n   *\n   * @param {String} cls\n   */\n  function traverseTrait(cls) {\n    return traverse(cls, true);\n  }\n\n  /**\n   * Traverse the selected super type\n   *\n   * @param {String} cls\n   */\n  function traverseSuper(cls) {\n    return traverse(cls, false);\n  }\n\n  if (!type) {\n    throw new Error('unknown type <' + nsName.name + '>');\n  }\n\n  forEach(type.superClass, trait ? traverseTrait : traverseSuper);\n\n  // call iterator with (type, inherited=!trait)\n  iterator(type, !trait);\n\n  forEach(type.traits, traverseTrait);\n};\n\n\n/**\n * Returns the effective descriptor for a type.\n *\n * @param  {String} type the namespaced name (ns:localName) of the type\n *\n * @return {Descriptor} the resulting effective descriptor\n */\nRegistry.prototype.getEffectiveDescriptor = function(name) {\n\n  var nsName = parseNameNs(name);\n\n  var builder = new DescriptorBuilder(nsName);\n\n  this.mapTypes(nsName, function(type, inherited) {\n    builder.addTrait(type, inherited);\n  });\n\n  var descriptor = builder.build();\n\n  // define package link\n  this.definePackage(descriptor, descriptor.allTypes[descriptor.allTypes.length - 1].$pkg);\n\n  return descriptor;\n};\n\n\nRegistry.prototype.definePackage = function(target, pkg) {\n  this.properties.define(target, '$pkg', { value: pkg });\n};\n\n\n\n// helpers ////////////////////////////\n\nfunction ensureAvailable(packageMap, pkg, identifierKey) {\n\n  var value = pkg[identifierKey];\n\n  if (value in packageMap) {\n    throw new Error('package with ' + identifierKey + ' <' + value + '> already defined');\n  }\n}\n","import {\n  assign,\n  isString\n} from 'min-dash';\n\n/**\n * A utility that gets and sets properties of model elements.\n *\n * @param {Model} model\n */\nexport default function Properties(model) {\n  this.model = model;\n}\n\n\n/**\n * Sets a named property on the target element.\n * If the value is undefined, the property gets deleted.\n *\n * @param {Object} target\n * @param {String} name\n * @param {Object} value\n */\nProperties.prototype.set = function(target, name, value) {\n\n  if (!isString(name) || !name.length) {\n    throw new TypeError('property name must be a non-empty string');\n  }\n\n  var property = this.getProperty(target, name);\n\n  var propertyName = property && property.name;\n\n  if (isUndefined(value)) {\n\n    // unset the property, if the specified value is undefined;\n    // delete from $attrs (for extensions) or the target itself\n    if (property) {\n      delete target[propertyName];\n    } else {\n      delete target.$attrs[stripGlobal(name)];\n    }\n  } else {\n\n    // set the property, defining well defined properties on the fly\n    // or simply updating them in target.$attrs (for extensions)\n    if (property) {\n      if (propertyName in target) {\n        target[propertyName] = value;\n      } else {\n        defineProperty(target, property, value);\n      }\n    } else {\n      target.$attrs[stripGlobal(name)] = value;\n    }\n  }\n};\n\n/**\n * Returns the named property of the given element\n *\n * @param  {Object} target\n * @param  {String} name\n *\n * @return {Object}\n */\nProperties.prototype.get = function(target, name) {\n\n  var property = this.getProperty(target, name);\n\n  if (!property) {\n    return target.$attrs[stripGlobal(name)];\n  }\n\n  var propertyName = property.name;\n\n  // check if access to collection property and lazily initialize it\n  if (!target[propertyName] && property.isMany) {\n    defineProperty(target, property, []);\n  }\n\n  return target[propertyName];\n};\n\n\n/**\n * Define a property on the target element\n *\n * @param  {Object} target\n * @param  {String} name\n * @param  {Object} options\n */\nProperties.prototype.define = function(target, name, options) {\n\n  if (!options.writable) {\n\n    var value = options.value;\n\n    // use getters for read-only variables to support ES6 proxies\n    // cf. https://github.com/bpmn-io/internal-docs/issues/386\n    options = assign({}, options, {\n      get: function() { return value; }\n    });\n\n    delete options.value;\n  }\n\n  Object.defineProperty(target, name, options);\n};\n\n\n/**\n * Define the descriptor for an element\n */\nProperties.prototype.defineDescriptor = function(target, descriptor) {\n  this.define(target, '$descriptor', { value: descriptor });\n};\n\n/**\n * Define the model for an element\n */\nProperties.prototype.defineModel = function(target, model) {\n  this.define(target, '$model', { value: model });\n};\n\n/**\n * Return property with the given name on the element.\n *\n * @param {any} target\n * @param {string} name\n *\n * @return {object | null} property\n */\nProperties.prototype.getProperty = function(target, name) {\n\n  var model = this.model;\n\n  var property = model.getPropertyDescriptor(target, name);\n\n  if (property) {\n    return property;\n  }\n\n  if (name.includes(':')) {\n    return null;\n  }\n\n  const strict = model.config.strict;\n\n  if (typeof strict !== 'undefined') {\n    const error = new TypeError(`unknown property <${ name }> on <${ target.$type }>`);\n\n    if (strict) {\n      throw error;\n    } else {\n\n      // eslint-disable-next-line no-undef\n      typeof console !== 'undefined' && console.warn(error);\n    }\n  }\n\n  return null;\n};\n\nfunction isUndefined(val) {\n  return typeof val === 'undefined';\n}\n\nfunction defineProperty(target, property, value) {\n  Object.defineProperty(target, property.name, {\n    enumerable: !property.isReference,\n    writable: true,\n    value: value,\n    configurable: true\n  });\n}\n\nfunction stripGlobal(name) {\n  return name.replace(/^:/, '');\n}","import {\n  isString,\n  isObject,\n  forEach,\n  set\n} from 'min-dash';\n\nimport Factory from './factory.js';\nimport Registry from './registry.js';\nimport Properties from './properties.js';\n\nimport {\n  parseName as parseNameNs\n} from './ns.js';\n\n\n// Moddle implementation /////////////////////////////////////////////////\n\n/**\n * @class Moddle\n *\n * A model that can be used to create elements of a specific type.\n *\n * @example\n *\n * var Moddle = require('moddle');\n *\n * var pkg = {\n *   name: 'mypackage',\n *   prefix: 'my',\n *   types: [\n *     { name: 'Root' }\n *   ]\n * };\n *\n * var moddle = new Moddle([pkg]);\n *\n * @param {Array<Package>} packages the packages to contain\n *\n * @param { { strict?: boolean } } [config] moddle configuration\n */\nexport default function Moddle(packages, config = {}) {\n\n  this.properties = new Properties(this);\n\n  this.factory = new Factory(this, this.properties);\n  this.registry = new Registry(packages, this.properties);\n\n  this.typeCache = {};\n\n  this.config = config;\n}\n\n\n/**\n * Create an instance of the specified type.\n *\n * @method Moddle#create\n *\n * @example\n *\n * var foo = moddle.create('my:Foo');\n * var bar = moddle.create('my:Bar', { id: 'BAR_1' });\n *\n * @param  {String|Object} descriptor the type descriptor or name know to the model\n * @param  {Object} attrs   a number of attributes to initialize the model instance with\n * @return {Object}         model instance\n */\nModdle.prototype.create = function(descriptor, attrs) {\n  var Type = this.getType(descriptor);\n\n  if (!Type) {\n    throw new Error('unknown type <' + descriptor + '>');\n  }\n\n  return new Type(attrs);\n};\n\n\n/**\n * Returns the type representing a given descriptor\n *\n * @method Moddle#getType\n *\n * @example\n *\n * var Foo = moddle.getType('my:Foo');\n * var foo = new Foo({ 'id' : 'FOO_1' });\n *\n * @param  {String|Object} descriptor the type descriptor or name know to the model\n * @return {Object}         the type representing the descriptor\n */\nModdle.prototype.getType = function(descriptor) {\n\n  var cache = this.typeCache;\n\n  var name = isString(descriptor) ? descriptor : descriptor.ns.name;\n\n  var type = cache[name];\n\n  if (!type) {\n    descriptor = this.registry.getEffectiveDescriptor(name);\n    type = cache[name] = this.factory.createType(descriptor);\n  }\n\n  return type;\n};\n\n\n/**\n * Creates an any-element type to be used within model instances.\n *\n * This can be used to create custom elements that lie outside the meta-model.\n * The created element contains all the meta-data required to serialize it\n * as part of meta-model elements.\n *\n * @method Moddle#createAny\n *\n * @example\n *\n * var foo = moddle.createAny('vendor:Foo', 'http://vendor', {\n *   value: 'bar'\n * });\n *\n * var container = moddle.create('my:Container', 'http://my', {\n *   any: [ foo ]\n * });\n *\n * // go ahead and serialize the stuff\n *\n *\n * @param  {String} name  the name of the element\n * @param  {String} nsUri the namespace uri of the element\n * @param  {Object} [properties] a map of properties to initialize the instance with\n * @return {Object} the any type instance\n */\nModdle.prototype.createAny = function(name, nsUri, properties) {\n\n  var nameNs = parseNameNs(name);\n\n  var element = {\n    $type: name,\n    $instanceOf: function(type) {\n      return type === this.$type;\n    },\n    get: function(key) {\n      return this[key];\n    },\n    set: function(key, value) {\n      set(this, [ key ], value);\n    }\n  };\n\n  var descriptor = {\n    name: name,\n    isGeneric: true,\n    ns: {\n      prefix: nameNs.prefix,\n      localName: nameNs.localName,\n      uri: nsUri\n    }\n  };\n\n  this.properties.defineDescriptor(element, descriptor);\n  this.properties.defineModel(element, this);\n  this.properties.define(element, 'get', { enumerable: false, writable: true });\n  this.properties.define(element, 'set', { enumerable: false, writable: true });\n  this.properties.define(element, '$parent', { enumerable: false, writable: true });\n  this.properties.define(element, '$instanceOf', { enumerable: false, writable: true });\n\n  forEach(properties, function(a, key) {\n    if (isObject(a) && a.value !== undefined) {\n      element[a.name] = a.value;\n    } else {\n      element[key] = a;\n    }\n  });\n\n  return element;\n};\n\n/**\n * Returns a registered package by uri or prefix\n *\n * @return {Object} the package\n */\nModdle.prototype.getPackage = function(uriOrPrefix) {\n  return this.registry.getPackage(uriOrPrefix);\n};\n\n/**\n * Returns a snapshot of all known packages\n *\n * @return {Object} the package\n */\nModdle.prototype.getPackages = function() {\n  return this.registry.getPackages();\n};\n\n/**\n * Returns the descriptor for an element\n */\nModdle.prototype.getElementDescriptor = function(element) {\n  return element.$descriptor;\n};\n\n/**\n * Returns true if the given descriptor or instance\n * represents the given type.\n *\n * May be applied to this, if element is omitted.\n */\nModdle.prototype.hasType = function(element, type) {\n  if (type === undefined) {\n    type = element;\n    element = this;\n  }\n\n  var descriptor = element.$model.getElementDescriptor(element);\n\n  return (type in descriptor.allTypesByName);\n};\n\n/**\n * Returns the descriptor of an elements named property\n */\nModdle.prototype.getPropertyDescriptor = function(element, property) {\n  return this.getElementDescriptor(element).propertiesByName[property];\n};\n\n/**\n * Returns a mapped type's descriptor\n */\nModdle.prototype.getTypeDescriptor = function(type) {\n  return this.registry.typeMap[type];\n};"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}