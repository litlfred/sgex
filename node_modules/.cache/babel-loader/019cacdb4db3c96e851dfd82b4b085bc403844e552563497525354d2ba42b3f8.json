{"ast":null,"code":"\"use strict\";\n\nvar _taggedTemplateLiteral = require(\"/home/runner/work/sgex/sgex/node_modules/@babel/runtime/helpers/taggedTemplateLiteral.js\").default;\nvar _templateObject, _templateObject2, _templateObject3, _templateObject4;\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nconst codegen_1 = require(\"../../compile/codegen\");\nconst types_1 = require(\"../discriminator/types\");\nconst compile_1 = require(\"../../compile\");\nconst ref_error_1 = require(\"../../compile/ref_error\");\nconst util_1 = require(\"../../compile/util\");\nconst error = {\n  message: _ref => {\n    let {\n      params: {\n        discrError,\n        tagName\n      }\n    } = _ref;\n    return discrError === types_1.DiscrError.Tag ? \"tag \\\"\".concat(tagName, \"\\\" must be string\") : \"value of tag \\\"\".concat(tagName, \"\\\" must be in oneOf\");\n  },\n  params: _ref2 => {\n    let {\n      params: {\n        discrError,\n        tag,\n        tagName\n      }\n    } = _ref2;\n    return (0, codegen_1._)(_templateObject || (_templateObject = _taggedTemplateLiteral([\"{error: \", \", tag: \", \", tagValue: \", \"}\"])), discrError, tagName, tag);\n  }\n};\nconst def = {\n  keyword: \"discriminator\",\n  type: \"object\",\n  schemaType: \"object\",\n  error,\n  code(cxt) {\n    const {\n      gen,\n      data,\n      schema,\n      parentSchema,\n      it\n    } = cxt;\n    const {\n      oneOf\n    } = parentSchema;\n    if (!it.opts.discriminator) {\n      throw new Error(\"discriminator: requires discriminator option\");\n    }\n    const tagName = schema.propertyName;\n    if (typeof tagName != \"string\") throw new Error(\"discriminator: requires propertyName\");\n    if (schema.mapping) throw new Error(\"discriminator: mapping is not supported\");\n    if (!oneOf) throw new Error(\"discriminator: requires oneOf keyword\");\n    const valid = gen.let(\"valid\", false);\n    const tag = gen.const(\"tag\", (0, codegen_1._)(_templateObject2 || (_templateObject2 = _taggedTemplateLiteral([\"\", \"\", \"\"])), data, (0, codegen_1.getProperty)(tagName)));\n    gen.if((0, codegen_1._)(_templateObject3 || (_templateObject3 = _taggedTemplateLiteral([\"typeof \", \" == \\\"string\\\"\"])), tag), () => validateMapping(), () => cxt.error(false, {\n      discrError: types_1.DiscrError.Tag,\n      tag,\n      tagName\n    }));\n    cxt.ok(valid);\n    function validateMapping() {\n      const mapping = getMapping();\n      gen.if(false);\n      for (const tagValue in mapping) {\n        gen.elseIf((0, codegen_1._)(_templateObject4 || (_templateObject4 = _taggedTemplateLiteral([\"\", \" === \", \"\"])), tag, tagValue));\n        gen.assign(valid, applyTagSchema(mapping[tagValue]));\n      }\n      gen.else();\n      cxt.error(false, {\n        discrError: types_1.DiscrError.Mapping,\n        tag,\n        tagName\n      });\n      gen.endIf();\n    }\n    function applyTagSchema(schemaProp) {\n      const _valid = gen.name(\"valid\");\n      const schCxt = cxt.subschema({\n        keyword: \"oneOf\",\n        schemaProp\n      }, _valid);\n      cxt.mergeEvaluated(schCxt, codegen_1.Name);\n      return _valid;\n    }\n    function getMapping() {\n      var _a;\n      const oneOfMapping = {};\n      const topRequired = hasRequired(parentSchema);\n      let tagRequired = true;\n      for (let i = 0; i < oneOf.length; i++) {\n        let sch = oneOf[i];\n        if ((sch === null || sch === void 0 ? void 0 : sch.$ref) && !(0, util_1.schemaHasRulesButRef)(sch, it.self.RULES)) {\n          const ref = sch.$ref;\n          sch = compile_1.resolveRef.call(it.self, it.schemaEnv.root, it.baseId, ref);\n          if (sch instanceof compile_1.SchemaEnv) sch = sch.schema;\n          if (sch === undefined) throw new ref_error_1.default(it.opts.uriResolver, it.baseId, ref);\n        }\n        const propSch = (_a = sch === null || sch === void 0 ? void 0 : sch.properties) === null || _a === void 0 ? void 0 : _a[tagName];\n        if (typeof propSch != \"object\") {\n          throw new Error(\"discriminator: oneOf subschemas (or referenced schemas) must have \\\"properties/\".concat(tagName, \"\\\"\"));\n        }\n        tagRequired = tagRequired && (topRequired || hasRequired(sch));\n        addMappings(propSch, i);\n      }\n      if (!tagRequired) throw new Error(\"discriminator: \\\"\".concat(tagName, \"\\\" must be required\"));\n      return oneOfMapping;\n      function hasRequired(_ref3) {\n        let {\n          required\n        } = _ref3;\n        return Array.isArray(required) && required.includes(tagName);\n      }\n      function addMappings(sch, i) {\n        if (sch.const) {\n          addMapping(sch.const, i);\n        } else if (sch.enum) {\n          for (const tagValue of sch.enum) {\n            addMapping(tagValue, i);\n          }\n        } else {\n          throw new Error(\"discriminator: \\\"properties/\".concat(tagName, \"\\\" must have \\\"const\\\" or \\\"enum\\\"\"));\n        }\n      }\n      function addMapping(tagValue, i) {\n        if (typeof tagValue != \"string\" || tagValue in oneOfMapping) {\n          throw new Error(\"discriminator: \\\"\".concat(tagName, \"\\\" values must be unique strings\"));\n        }\n        oneOfMapping[tagValue] = i;\n      }\n    }\n  }\n};\nexports.default = def;","map":{"version":3,"names":["codegen_1","require","types_1","compile_1","ref_error_1","util_1","error","message","_ref","params","discrError","tagName","DiscrError","Tag","concat","_ref2","tag","_","_templateObject","_taggedTemplateLiteral","def","keyword","type","schemaType","code","cxt","gen","data","schema","parentSchema","it","oneOf","opts","discriminator","Error","propertyName","mapping","valid","let","const","_templateObject2","getProperty","if","_templateObject3","validateMapping","ok","getMapping","tagValue","elseIf","_templateObject4","assign","applyTagSchema","else","Mapping","endIf","schemaProp","_valid","name","schCxt","subschema","mergeEvaluated","Name","oneOfMapping","topRequired","hasRequired","tagRequired","i","length","sch","$ref","schemaHasRulesButRef","self","RULES","ref","resolveRef","call","schemaEnv","root","baseId","SchemaEnv","undefined","default","uriResolver","propSch","_a","properties","addMappings","_ref3","required","Array","isArray","includes","addMapping","enum","exports"],"sources":["/home/runner/work/sgex/sgex/node_modules/ajv/lib/vocabularies/discriminator/index.ts"],"sourcesContent":["import type {CodeKeywordDefinition, AnySchemaObject, KeywordErrorDefinition} from \"../../types\"\nimport type {KeywordCxt} from \"../../compile/validate\"\nimport {_, getProperty, Name} from \"../../compile/codegen\"\nimport {DiscrError, DiscrErrorObj} from \"../discriminator/types\"\nimport {resolveRef, SchemaEnv} from \"../../compile\"\nimport MissingRefError from \"../../compile/ref_error\"\nimport {schemaHasRulesButRef} from \"../../compile/util\"\n\nexport type DiscriminatorError = DiscrErrorObj<DiscrError.Tag> | DiscrErrorObj<DiscrError.Mapping>\n\nconst error: KeywordErrorDefinition = {\n  message: ({params: {discrError, tagName}}) =>\n    discrError === DiscrError.Tag\n      ? `tag \"${tagName}\" must be string`\n      : `value of tag \"${tagName}\" must be in oneOf`,\n  params: ({params: {discrError, tag, tagName}}) =>\n    _`{error: ${discrError}, tag: ${tagName}, tagValue: ${tag}}`,\n}\n\nconst def: CodeKeywordDefinition = {\n  keyword: \"discriminator\",\n  type: \"object\",\n  schemaType: \"object\",\n  error,\n  code(cxt: KeywordCxt) {\n    const {gen, data, schema, parentSchema, it} = cxt\n    const {oneOf} = parentSchema\n    if (!it.opts.discriminator) {\n      throw new Error(\"discriminator: requires discriminator option\")\n    }\n    const tagName = schema.propertyName\n    if (typeof tagName != \"string\") throw new Error(\"discriminator: requires propertyName\")\n    if (schema.mapping) throw new Error(\"discriminator: mapping is not supported\")\n    if (!oneOf) throw new Error(\"discriminator: requires oneOf keyword\")\n    const valid = gen.let(\"valid\", false)\n    const tag = gen.const(\"tag\", _`${data}${getProperty(tagName)}`)\n    gen.if(\n      _`typeof ${tag} == \"string\"`,\n      () => validateMapping(),\n      () => cxt.error(false, {discrError: DiscrError.Tag, tag, tagName})\n    )\n    cxt.ok(valid)\n\n    function validateMapping(): void {\n      const mapping = getMapping()\n      gen.if(false)\n      for (const tagValue in mapping) {\n        gen.elseIf(_`${tag} === ${tagValue}`)\n        gen.assign(valid, applyTagSchema(mapping[tagValue]))\n      }\n      gen.else()\n      cxt.error(false, {discrError: DiscrError.Mapping, tag, tagName})\n      gen.endIf()\n    }\n\n    function applyTagSchema(schemaProp?: number): Name {\n      const _valid = gen.name(\"valid\")\n      const schCxt = cxt.subschema({keyword: \"oneOf\", schemaProp}, _valid)\n      cxt.mergeEvaluated(schCxt, Name)\n      return _valid\n    }\n\n    function getMapping(): {[T in string]?: number} {\n      const oneOfMapping: {[T in string]?: number} = {}\n      const topRequired = hasRequired(parentSchema)\n      let tagRequired = true\n      for (let i = 0; i < oneOf.length; i++) {\n        let sch = oneOf[i]\n        if (sch?.$ref && !schemaHasRulesButRef(sch, it.self.RULES)) {\n          const ref = sch.$ref\n          sch = resolveRef.call(it.self, it.schemaEnv.root, it.baseId, ref)\n          if (sch instanceof SchemaEnv) sch = sch.schema\n          if (sch === undefined) throw new MissingRefError(it.opts.uriResolver, it.baseId, ref)\n        }\n        const propSch = sch?.properties?.[tagName]\n        if (typeof propSch != \"object\") {\n          throw new Error(\n            `discriminator: oneOf subschemas (or referenced schemas) must have \"properties/${tagName}\"`\n          )\n        }\n        tagRequired = tagRequired && (topRequired || hasRequired(sch))\n        addMappings(propSch, i)\n      }\n      if (!tagRequired) throw new Error(`discriminator: \"${tagName}\" must be required`)\n      return oneOfMapping\n\n      function hasRequired({required}: AnySchemaObject): boolean {\n        return Array.isArray(required) && required.includes(tagName)\n      }\n\n      function addMappings(sch: AnySchemaObject, i: number): void {\n        if (sch.const) {\n          addMapping(sch.const, i)\n        } else if (sch.enum) {\n          for (const tagValue of sch.enum) {\n            addMapping(tagValue, i)\n          }\n        } else {\n          throw new Error(`discriminator: \"properties/${tagName}\" must have \"const\" or \"enum\"`)\n        }\n      }\n\n      function addMapping(tagValue: unknown, i: number): void {\n        if (typeof tagValue != \"string\" || tagValue in oneOfMapping) {\n          throw new Error(`discriminator: \"${tagName}\" values must be unique strings`)\n        }\n        oneOfMapping[tagValue] = i\n      }\n    }\n  },\n}\n\nexport default def\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}