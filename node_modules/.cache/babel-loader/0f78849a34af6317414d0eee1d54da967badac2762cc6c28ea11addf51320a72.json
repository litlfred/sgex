{"ast":null,"code":"\"use strict\";\n\nvar _taggedTemplateLiteral = require(\"/home/runner/work/sgex/sgex/node_modules/@babel/runtime/helpers/taggedTemplateLiteral.js\").default;\nvar _templateObject, _templateObject2, _templateObject3, _templateObject4, _templateObject5, _templateObject6, _templateObject7, _templateObject8, _templateObject9, _templateObject0, _templateObject1, _templateObject10;\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nconst codegen_1 = require(\"../../compile/codegen\");\nconst util_1 = require(\"../../compile/util\");\nconst error = {\n  message: _ref => {\n    let {\n      params: {\n        min,\n        max\n      }\n    } = _ref;\n    return max === undefined ? (0, codegen_1.str)(_templateObject || (_templateObject = _taggedTemplateLiteral([\"must contain at least \", \" valid item(s)\"])), min) : (0, codegen_1.str)(_templateObject2 || (_templateObject2 = _taggedTemplateLiteral([\"must contain at least \", \" and no more than \", \" valid item(s)\"])), min, max);\n  },\n  params: _ref2 => {\n    let {\n      params: {\n        min,\n        max\n      }\n    } = _ref2;\n    return max === undefined ? (0, codegen_1._)(_templateObject3 || (_templateObject3 = _taggedTemplateLiteral([\"{minContains: \", \"}\"])), min) : (0, codegen_1._)(_templateObject4 || (_templateObject4 = _taggedTemplateLiteral([\"{minContains: \", \", maxContains: \", \"}\"])), min, max);\n  }\n};\nconst def = {\n  keyword: \"contains\",\n  type: \"array\",\n  schemaType: [\"object\", \"boolean\"],\n  before: \"uniqueItems\",\n  trackErrors: true,\n  error,\n  code(cxt) {\n    const {\n      gen,\n      schema,\n      parentSchema,\n      data,\n      it\n    } = cxt;\n    let min;\n    let max;\n    const {\n      minContains,\n      maxContains\n    } = parentSchema;\n    if (it.opts.next) {\n      min = minContains === undefined ? 1 : minContains;\n      max = maxContains;\n    } else {\n      min = 1;\n    }\n    const len = gen.const(\"len\", (0, codegen_1._)(_templateObject5 || (_templateObject5 = _taggedTemplateLiteral([\"\", \".length\"])), data));\n    cxt.setParams({\n      min,\n      max\n    });\n    if (max === undefined && min === 0) {\n      (0, util_1.checkStrictMode)(it, \"\\\"minContains\\\" == 0 without \\\"maxContains\\\": \\\"contains\\\" keyword ignored\");\n      return;\n    }\n    if (max !== undefined && min > max) {\n      (0, util_1.checkStrictMode)(it, \"\\\"minContains\\\" > \\\"maxContains\\\" is always invalid\");\n      cxt.fail();\n      return;\n    }\n    if ((0, util_1.alwaysValidSchema)(it, schema)) {\n      let cond = (0, codegen_1._)(_templateObject6 || (_templateObject6 = _taggedTemplateLiteral([\"\", \" >= \", \"\"])), len, min);\n      if (max !== undefined) cond = (0, codegen_1._)(_templateObject7 || (_templateObject7 = _taggedTemplateLiteral([\"\", \" && \", \" <= \", \"\"])), cond, len, max);\n      cxt.pass(cond);\n      return;\n    }\n    it.items = true;\n    const valid = gen.name(\"valid\");\n    if (max === undefined && min === 1) {\n      validateItems(valid, () => gen.if(valid, () => gen.break()));\n    } else if (min === 0) {\n      gen.let(valid, true);\n      if (max !== undefined) gen.if((0, codegen_1._)(_templateObject8 || (_templateObject8 = _taggedTemplateLiteral([\"\", \".length > 0\"])), data), validateItemsWithCount);\n    } else {\n      gen.let(valid, false);\n      validateItemsWithCount();\n    }\n    cxt.result(valid, () => cxt.reset());\n    function validateItemsWithCount() {\n      const schValid = gen.name(\"_valid\");\n      const count = gen.let(\"count\", 0);\n      validateItems(schValid, () => gen.if(schValid, () => checkLimits(count)));\n    }\n    function validateItems(_valid, block) {\n      gen.forRange(\"i\", 0, len, i => {\n        cxt.subschema({\n          keyword: \"contains\",\n          dataProp: i,\n          dataPropType: util_1.Type.Num,\n          compositeRule: true\n        }, _valid);\n        block();\n      });\n    }\n    function checkLimits(count) {\n      gen.code((0, codegen_1._)(_templateObject9 || (_templateObject9 = _taggedTemplateLiteral([\"\", \"++\"])), count));\n      if (max === undefined) {\n        gen.if((0, codegen_1._)(_templateObject0 || (_templateObject0 = _taggedTemplateLiteral([\"\", \" >= \", \"\"])), count, min), () => gen.assign(valid, true).break());\n      } else {\n        gen.if((0, codegen_1._)(_templateObject1 || (_templateObject1 = _taggedTemplateLiteral([\"\", \" > \", \"\"])), count, max), () => gen.assign(valid, false).break());\n        if (min === 1) gen.assign(valid, true);else gen.if((0, codegen_1._)(_templateObject10 || (_templateObject10 = _taggedTemplateLiteral([\"\", \" >= \", \"\"])), count, min), () => gen.assign(valid, true));\n      }\n    }\n  }\n};\nexports.default = def;","map":{"version":3,"names":["codegen_1","require","util_1","error","message","_ref","params","min","max","undefined","str","_templateObject","_taggedTemplateLiteral","_templateObject2","_ref2","_","_templateObject3","_templateObject4","def","keyword","type","schemaType","before","trackErrors","code","cxt","gen","schema","parentSchema","data","it","minContains","maxContains","opts","next","len","const","_templateObject5","setParams","checkStrictMode","fail","alwaysValidSchema","cond","_templateObject6","_templateObject7","pass","items","valid","name","validateItems","if","break","let","_templateObject8","validateItemsWithCount","result","reset","schValid","count","checkLimits","_valid","block","forRange","i","subschema","dataProp","dataPropType","Type","Num","compositeRule","_templateObject9","_templateObject0","assign","_templateObject1","_templateObject10","exports","default"],"sources":["/home/runner/work/sgex/sgex/node_modules/ajv/lib/vocabularies/applicator/contains.ts"],"sourcesContent":["import type {\n  CodeKeywordDefinition,\n  KeywordErrorDefinition,\n  ErrorObject,\n  AnySchema,\n} from \"../../types\"\nimport type {KeywordCxt} from \"../../compile/validate\"\nimport {_, str, Name} from \"../../compile/codegen\"\nimport {alwaysValidSchema, checkStrictMode, Type} from \"../../compile/util\"\n\nexport type ContainsError = ErrorObject<\n  \"contains\",\n  {minContains: number; maxContains?: number},\n  AnySchema\n>\n\nconst error: KeywordErrorDefinition = {\n  message: ({params: {min, max}}) =>\n    max === undefined\n      ? str`must contain at least ${min} valid item(s)`\n      : str`must contain at least ${min} and no more than ${max} valid item(s)`,\n  params: ({params: {min, max}}) =>\n    max === undefined ? _`{minContains: ${min}}` : _`{minContains: ${min}, maxContains: ${max}}`,\n}\n\nconst def: CodeKeywordDefinition = {\n  keyword: \"contains\",\n  type: \"array\",\n  schemaType: [\"object\", \"boolean\"],\n  before: \"uniqueItems\",\n  trackErrors: true,\n  error,\n  code(cxt: KeywordCxt) {\n    const {gen, schema, parentSchema, data, it} = cxt\n    let min: number\n    let max: number | undefined\n    const {minContains, maxContains} = parentSchema\n    if (it.opts.next) {\n      min = minContains === undefined ? 1 : minContains\n      max = maxContains\n    } else {\n      min = 1\n    }\n    const len = gen.const(\"len\", _`${data}.length`)\n    cxt.setParams({min, max})\n    if (max === undefined && min === 0) {\n      checkStrictMode(it, `\"minContains\" == 0 without \"maxContains\": \"contains\" keyword ignored`)\n      return\n    }\n    if (max !== undefined && min > max) {\n      checkStrictMode(it, `\"minContains\" > \"maxContains\" is always invalid`)\n      cxt.fail()\n      return\n    }\n    if (alwaysValidSchema(it, schema)) {\n      let cond = _`${len} >= ${min}`\n      if (max !== undefined) cond = _`${cond} && ${len} <= ${max}`\n      cxt.pass(cond)\n      return\n    }\n\n    it.items = true\n    const valid = gen.name(\"valid\")\n    if (max === undefined && min === 1) {\n      validateItems(valid, () => gen.if(valid, () => gen.break()))\n    } else if (min === 0) {\n      gen.let(valid, true)\n      if (max !== undefined) gen.if(_`${data}.length > 0`, validateItemsWithCount)\n    } else {\n      gen.let(valid, false)\n      validateItemsWithCount()\n    }\n    cxt.result(valid, () => cxt.reset())\n\n    function validateItemsWithCount(): void {\n      const schValid = gen.name(\"_valid\")\n      const count = gen.let(\"count\", 0)\n      validateItems(schValid, () => gen.if(schValid, () => checkLimits(count)))\n    }\n\n    function validateItems(_valid: Name, block: () => void): void {\n      gen.forRange(\"i\", 0, len, (i) => {\n        cxt.subschema(\n          {\n            keyword: \"contains\",\n            dataProp: i,\n            dataPropType: Type.Num,\n            compositeRule: true,\n          },\n          _valid\n        )\n        block()\n      })\n    }\n\n    function checkLimits(count: Name): void {\n      gen.code(_`${count}++`)\n      if (max === undefined) {\n        gen.if(_`${count} >= ${min}`, () => gen.assign(valid, true).break())\n      } else {\n        gen.if(_`${count} > ${max}`, () => gen.assign(valid, false).break())\n        if (min === 1) gen.assign(valid, true)\n        else gen.if(_`${count} >= ${min}`, () => gen.assign(valid, true))\n      }\n    }\n  },\n}\n\nexport default def\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}