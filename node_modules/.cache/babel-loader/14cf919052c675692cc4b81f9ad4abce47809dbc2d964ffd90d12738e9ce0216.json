{"ast":null,"code":"import { flatten, filter, forEach, groupBy, map, unionBy } from 'min-dash';\nimport { saveClear } from '../../util/Removal';\nimport { getNewAttachShapeDelta } from '../../util/AttachUtil';\nimport inherits from 'inherits-browser';\nimport CommandInterceptor from '../../command/CommandInterceptor';\n\n/**\n * @typedef {import('didi').Injector} Injector\n *\n * @typedef {import('../../model/Types').Element} Element\n *\n * @typedef {import('../../core/Canvas').default} Canvas\n * @typedef {import('../../core/EventBus').default} EventBus\n * @typedef {import('../rules/Rules').default} Rules\n * @typedef {import('../modeling/Modeling').default} Modeling\n */\n\nvar LOW_PRIORITY = 251,\n  HIGH_PRIORITY = 1401;\nvar MARKER_ATTACH = 'attach-ok';\n\n/**\n * Adds the notion of attached elements to the modeler.\n *\n * Optionally depends on `diagram-js/lib/features/move` to render\n * the attached elements during move preview.\n *\n * Optionally depends on `diagram-js/lib/features/label-support`\n * to render attached labels during move preview.\n *\n * @param {Injector} injector\n * @param {EventBus} eventBus\n * @param {Canvas} canvas\n * @param {Rules} rules\n * @param {Modeling} modeling\n */\nexport default function AttachSupport(injector, eventBus, canvas, rules, modeling) {\n  CommandInterceptor.call(this, eventBus);\n  var movePreview = injector.get('movePreview', false);\n\n  // remove all the attached elements from the shapes to be validated\n  // add all the attached shapes to the overall list of moved shapes\n  eventBus.on('shape.move.start', HIGH_PRIORITY, function (e) {\n    var context = e.context,\n      shapes = context.shapes,\n      validatedShapes = context.validatedShapes;\n    context.shapes = addAttached(shapes);\n    context.validatedShapes = removeAttached(validatedShapes);\n  });\n\n  // add attachers to the visual's group\n  movePreview && eventBus.on('shape.move.start', LOW_PRIORITY, function (e) {\n    var context = e.context,\n      shapes = context.shapes,\n      attachers = getAttachers(shapes);\n    forEach(attachers, function (attacher) {\n      movePreview.makeDraggable(context, attacher, true);\n      forEach(attacher.labels, function (label) {\n        movePreview.makeDraggable(context, label, true);\n      });\n    });\n  });\n\n  // add attach-ok marker to current host\n  movePreview && eventBus.on('shape.move.start', function (event) {\n    var context = event.context,\n      shapes = context.shapes;\n    if (shapes.length !== 1) {\n      return;\n    }\n    var shape = shapes[0];\n    var host = shape.host;\n    if (host) {\n      canvas.addMarker(host, MARKER_ATTACH);\n      eventBus.once(['shape.move.out', 'shape.move.cleanup'], function () {\n        canvas.removeMarker(host, MARKER_ATTACH);\n      });\n    }\n  });\n\n  // add all attachers to move closure\n  this.preExecuted('elements.move', HIGH_PRIORITY, function (e) {\n    var context = e.context,\n      closure = context.closure,\n      shapes = context.shapes,\n      attachers = getAttachers(shapes);\n    forEach(attachers, function (attacher) {\n      closure.add(attacher, closure.topLevel[attacher.host.id]);\n    });\n  });\n\n  // perform the attaching after shapes are done moving\n  this.postExecuted('elements.move', function (e) {\n    var context = e.context,\n      shapes = context.shapes,\n      newHost = context.newHost,\n      attachers;\n\n    // only single elements can be attached\n    // multiply elements can be detached\n    if (newHost && shapes.length !== 1) {\n      return;\n    }\n    if (newHost) {\n      attachers = shapes;\n    } else {\n      // find attachers moved without host\n      attachers = filter(shapes, function (shape) {\n        var host = shape.host;\n        return isAttacher(shape) && !includes(shapes, host);\n      });\n    }\n    forEach(attachers, function (attacher) {\n      modeling.updateAttachment(attacher, newHost);\n    });\n  });\n\n  // ensure invalid attachment connections are removed\n  this.postExecuted('elements.move', function (e) {\n    var shapes = e.context.shapes;\n    forEach(shapes, function (shape) {\n      forEach(shape.attachers, function (attacher) {\n        // remove invalid outgoing connections\n        forEach(attacher.outgoing.slice(), function (connection) {\n          var allowed = rules.allowed('connection.reconnect', {\n            connection: connection,\n            source: connection.source,\n            target: connection.target\n          });\n          if (!allowed) {\n            modeling.removeConnection(connection);\n          }\n        });\n\n        // remove invalid incoming connections\n        forEach(attacher.incoming.slice(), function (connection) {\n          var allowed = rules.allowed('connection.reconnect', {\n            connection: connection,\n            source: connection.source,\n            target: connection.target\n          });\n          if (!allowed) {\n            modeling.removeConnection(connection);\n          }\n        });\n      });\n    });\n  });\n  this.postExecute('shape.create', function (e) {\n    var context = e.context,\n      shape = context.shape,\n      host = context.host;\n    if (host) {\n      modeling.updateAttachment(shape, host);\n    }\n  });\n\n  // update attachments if the host is replaced\n  this.postExecute('shape.replace', function (e) {\n    var context = e.context,\n      oldShape = context.oldShape,\n      newShape = context.newShape;\n\n    // move the attachers to the new host\n    saveClear(oldShape.attachers, function (attacher) {\n      var allowed = rules.allowed('elements.move', {\n        target: newShape,\n        shapes: [attacher]\n      });\n      if (allowed === 'attach') {\n        modeling.updateAttachment(attacher, newShape);\n      } else {\n        modeling.removeShape(attacher);\n      }\n    });\n\n    // move attachers if new host has different size\n    if (newShape.attachers.length) {\n      forEach(newShape.attachers, function (attacher) {\n        var delta = getNewAttachShapeDelta(attacher, oldShape, newShape);\n        modeling.moveShape(attacher, delta, attacher.parent);\n      });\n    }\n  });\n\n  // move shape on host resize\n  this.postExecute('shape.resize', function (event) {\n    var context = event.context,\n      shape = context.shape,\n      oldBounds = context.oldBounds,\n      newBounds = context.newBounds,\n      attachers = shape.attachers,\n      hints = context.hints || {};\n    if (hints.attachSupport === false) {\n      return;\n    }\n    forEach(attachers, function (attacher) {\n      var delta = getNewAttachShapeDelta(attacher, oldBounds, newBounds);\n      modeling.moveShape(attacher, delta, attacher.parent);\n      forEach(attacher.labels, function (label) {\n        modeling.moveShape(label, delta, label.parent);\n      });\n    });\n  });\n\n  // remove attachments\n  this.preExecute('shape.delete', function (event) {\n    var shape = event.context.shape;\n    saveClear(shape.attachers, function (attacher) {\n      modeling.removeShape(attacher);\n    });\n    if (shape.host) {\n      modeling.updateAttachment(shape, null);\n    }\n  });\n}\ninherits(AttachSupport, CommandInterceptor);\nAttachSupport.$inject = ['injector', 'eventBus', 'canvas', 'rules', 'modeling'];\n\n/**\n * Return attachers of the given shapes\n *\n * @param {Element[]} shapes\n * @return {Element[]}\n */\nfunction getAttachers(shapes) {\n  return flatten(map(shapes, function (s) {\n    return s.attachers || [];\n  }));\n}\n\n/**\n * Return a combined list of elements and\n * attachers.\n *\n * @param {Element[]} elements\n * @return {Element[]} filtered\n */\nfunction addAttached(elements) {\n  var attachers = getAttachers(elements);\n  return unionBy('id', elements, attachers);\n}\n\n/**\n * Return a filtered list of elements that do not\n * contain attached elements with hosts being part\n * of the selection.\n *\n * @param {Element[]} elements\n *\n * @return {Element[]} filtered\n */\nfunction removeAttached(elements) {\n  var ids = groupBy(elements, 'id');\n  return filter(elements, function (element) {\n    while (element) {\n      // host in selection\n      if (element.host && ids[element.host.id]) {\n        return false;\n      }\n      element = element.parent;\n    }\n    return true;\n  });\n}\nfunction isAttacher(shape) {\n  return !!shape.host;\n}\nfunction includes(array, item) {\n  return array.indexOf(item) !== -1;\n}","map":{"version":3,"names":["flatten","filter","forEach","groupBy","map","unionBy","saveClear","getNewAttachShapeDelta","inherits","CommandInterceptor","LOW_PRIORITY","HIGH_PRIORITY","MARKER_ATTACH","AttachSupport","injector","eventBus","canvas","rules","modeling","call","movePreview","get","on","e","context","shapes","validatedShapes","addAttached","removeAttached","attachers","getAttachers","attacher","makeDraggable","labels","label","event","length","shape","host","addMarker","once","removeMarker","preExecuted","closure","add","topLevel","id","postExecuted","newHost","isAttacher","includes","updateAttachment","outgoing","slice","connection","allowed","source","target","removeConnection","incoming","postExecute","oldShape","newShape","removeShape","delta","moveShape","parent","oldBounds","newBounds","hints","attachSupport","preExecute","$inject","s","elements","ids","element","array","item","indexOf"],"sources":["/home/runner/work/sgex/sgex/node_modules/diagram-js/lib/features/attach-support/AttachSupport.js"],"sourcesContent":["import {\n  flatten,\n  filter,\n  forEach,\n  groupBy,\n  map,\n  unionBy\n} from 'min-dash';\n\nimport { saveClear } from '../../util/Removal';\n\nimport { getNewAttachShapeDelta } from '../../util/AttachUtil';\n\nimport inherits from 'inherits-browser';\n\nimport CommandInterceptor from '../../command/CommandInterceptor';\n\n/**\n * @typedef {import('didi').Injector} Injector\n *\n * @typedef {import('../../model/Types').Element} Element\n *\n * @typedef {import('../../core/Canvas').default} Canvas\n * @typedef {import('../../core/EventBus').default} EventBus\n * @typedef {import('../rules/Rules').default} Rules\n * @typedef {import('../modeling/Modeling').default} Modeling\n */\n\nvar LOW_PRIORITY = 251,\n    HIGH_PRIORITY = 1401;\n\nvar MARKER_ATTACH = 'attach-ok';\n\n\n/**\n * Adds the notion of attached elements to the modeler.\n *\n * Optionally depends on `diagram-js/lib/features/move` to render\n * the attached elements during move preview.\n *\n * Optionally depends on `diagram-js/lib/features/label-support`\n * to render attached labels during move preview.\n *\n * @param {Injector} injector\n * @param {EventBus} eventBus\n * @param {Canvas} canvas\n * @param {Rules} rules\n * @param {Modeling} modeling\n */\nexport default function AttachSupport(injector, eventBus, canvas, rules, modeling) {\n\n  CommandInterceptor.call(this, eventBus);\n\n  var movePreview = injector.get('movePreview', false);\n\n\n  // remove all the attached elements from the shapes to be validated\n  // add all the attached shapes to the overall list of moved shapes\n  eventBus.on('shape.move.start', HIGH_PRIORITY, function(e) {\n\n    var context = e.context,\n        shapes = context.shapes,\n        validatedShapes = context.validatedShapes;\n\n    context.shapes = addAttached(shapes);\n\n    context.validatedShapes = removeAttached(validatedShapes);\n  });\n\n  // add attachers to the visual's group\n  movePreview && eventBus.on('shape.move.start', LOW_PRIORITY, function(e) {\n\n    var context = e.context,\n        shapes = context.shapes,\n        attachers = getAttachers(shapes);\n\n    forEach(attachers, function(attacher) {\n      movePreview.makeDraggable(context, attacher, true);\n\n      forEach(attacher.labels, function(label) {\n        movePreview.makeDraggable(context, label, true);\n      });\n    });\n  });\n\n  // add attach-ok marker to current host\n  movePreview && eventBus.on('shape.move.start', function(event) {\n    var context = event.context,\n        shapes = context.shapes;\n\n    if (shapes.length !== 1) {\n      return;\n    }\n\n    var shape = shapes[0];\n\n    var host = shape.host;\n\n    if (host) {\n      canvas.addMarker(host, MARKER_ATTACH);\n\n      eventBus.once([\n        'shape.move.out',\n        'shape.move.cleanup'\n      ], function() {\n        canvas.removeMarker(host, MARKER_ATTACH);\n      });\n    }\n  });\n\n  // add all attachers to move closure\n  this.preExecuted('elements.move', HIGH_PRIORITY, function(e) {\n    var context = e.context,\n        closure = context.closure,\n        shapes = context.shapes,\n        attachers = getAttachers(shapes);\n\n    forEach(attachers, function(attacher) {\n      closure.add(attacher, closure.topLevel[attacher.host.id]);\n    });\n  });\n\n  // perform the attaching after shapes are done moving\n  this.postExecuted('elements.move', function(e) {\n\n    var context = e.context,\n        shapes = context.shapes,\n        newHost = context.newHost,\n        attachers;\n\n    // only single elements can be attached\n    // multiply elements can be detached\n    if (newHost && shapes.length !== 1) {\n      return;\n    }\n\n    if (newHost) {\n      attachers = shapes;\n    } else {\n\n      // find attachers moved without host\n      attachers = filter(shapes, function(shape) {\n        var host = shape.host;\n\n        return isAttacher(shape) && !includes(shapes, host);\n      });\n    }\n\n    forEach(attachers, function(attacher) {\n      modeling.updateAttachment(attacher, newHost);\n    });\n  });\n\n  // ensure invalid attachment connections are removed\n  this.postExecuted('elements.move', function(e) {\n\n    var shapes = e.context.shapes;\n\n    forEach(shapes, function(shape) {\n\n      forEach(shape.attachers, function(attacher) {\n\n        // remove invalid outgoing connections\n        forEach(attacher.outgoing.slice(), function(connection) {\n          var allowed = rules.allowed('connection.reconnect', {\n            connection: connection,\n            source: connection.source,\n            target: connection.target\n          });\n\n          if (!allowed) {\n            modeling.removeConnection(connection);\n          }\n        });\n\n        // remove invalid incoming connections\n        forEach(attacher.incoming.slice(), function(connection) {\n          var allowed = rules.allowed('connection.reconnect', {\n            connection: connection,\n            source: connection.source,\n            target: connection.target\n          });\n\n          if (!allowed) {\n            modeling.removeConnection(connection);\n          }\n        });\n      });\n    });\n  });\n\n  this.postExecute('shape.create', function(e) {\n    var context = e.context,\n        shape = context.shape,\n        host = context.host;\n\n    if (host) {\n      modeling.updateAttachment(shape, host);\n    }\n  });\n\n  // update attachments if the host is replaced\n  this.postExecute('shape.replace', function(e) {\n\n    var context = e.context,\n        oldShape = context.oldShape,\n        newShape = context.newShape;\n\n    // move the attachers to the new host\n    saveClear(oldShape.attachers, function(attacher) {\n      var allowed = rules.allowed('elements.move', {\n        target: newShape,\n        shapes: [ attacher ]\n      });\n\n      if (allowed === 'attach') {\n        modeling.updateAttachment(attacher, newShape);\n      } else {\n        modeling.removeShape(attacher);\n      }\n    });\n\n    // move attachers if new host has different size\n    if (newShape.attachers.length) {\n\n      forEach(newShape.attachers, function(attacher) {\n        var delta = getNewAttachShapeDelta(attacher, oldShape, newShape);\n        modeling.moveShape(attacher, delta, attacher.parent);\n      });\n    }\n\n  });\n\n  // move shape on host resize\n  this.postExecute('shape.resize', function(event) {\n    var context = event.context,\n        shape = context.shape,\n        oldBounds = context.oldBounds,\n        newBounds = context.newBounds,\n        attachers = shape.attachers,\n        hints = context.hints || {};\n\n    if (hints.attachSupport === false) {\n      return;\n    }\n\n    forEach(attachers, function(attacher) {\n      var delta = getNewAttachShapeDelta(attacher, oldBounds, newBounds);\n\n      modeling.moveShape(attacher, delta, attacher.parent);\n\n      forEach(attacher.labels, function(label) {\n        modeling.moveShape(label, delta, label.parent);\n      });\n    });\n  });\n\n  // remove attachments\n  this.preExecute('shape.delete', function(event) {\n\n    var shape = event.context.shape;\n\n    saveClear(shape.attachers, function(attacher) {\n      modeling.removeShape(attacher);\n    });\n\n    if (shape.host) {\n      modeling.updateAttachment(shape, null);\n    }\n  });\n}\n\ninherits(AttachSupport, CommandInterceptor);\n\nAttachSupport.$inject = [\n  'injector',\n  'eventBus',\n  'canvas',\n  'rules',\n  'modeling'\n];\n\n\n/**\n * Return attachers of the given shapes\n *\n * @param {Element[]} shapes\n * @return {Element[]}\n */\nfunction getAttachers(shapes) {\n  return flatten(map(shapes, function(s) {\n    return s.attachers || [];\n  }));\n}\n\n/**\n * Return a combined list of elements and\n * attachers.\n *\n * @param {Element[]} elements\n * @return {Element[]} filtered\n */\nfunction addAttached(elements) {\n  var attachers = getAttachers(elements);\n\n  return unionBy('id', elements, attachers);\n}\n\n/**\n * Return a filtered list of elements that do not\n * contain attached elements with hosts being part\n * of the selection.\n *\n * @param {Element[]} elements\n *\n * @return {Element[]} filtered\n */\nfunction removeAttached(elements) {\n\n  var ids = groupBy(elements, 'id');\n\n  return filter(elements, function(element) {\n    while (element) {\n\n      // host in selection\n      if (element.host && ids[element.host.id]) {\n        return false;\n      }\n\n      element = element.parent;\n    }\n\n    return true;\n  });\n}\n\nfunction isAttacher(shape) {\n  return !!shape.host;\n}\n\nfunction includes(array, item) {\n  return array.indexOf(item) !== -1;\n}"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}