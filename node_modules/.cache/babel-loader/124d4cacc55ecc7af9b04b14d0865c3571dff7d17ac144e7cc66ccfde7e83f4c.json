{"ast":null,"code":"import { isObject, assign, forEach, reduce } from 'min-dash';\nimport { append as svgAppend, attr as svgAttr, create as svgCreate, remove as svgRemove } from 'tiny-svg';\nimport { assignStyle } from 'min-dom';\n\n/**\n * @typedef {import('../util/Types').Dimensions} Dimensions\n *\n * @typedef { {\n *   top: number;\n *   left: number;\n *   right: number;\n *   bottom: number;\n * } } Padding\n *\n * @typedef { number | Partial<Padding> } PaddingConfig\n *\n * @typedef { {\n *   horizontal: 'center' | 'left' | 'right';\n *   vertical: 'top' | 'middle';\n * } } Alignment\n *\n *  @typedef { 'center-middle' | 'center-top' } AlignmentConfig\n *\n * @typedef { Partial<{\n *   align: AlignmentConfig;\n *   style: Record<string, number | string>;\n *   padding: PaddingConfig;\n * }> } BaseTextConfig\n *\n * @typedef { BaseTextConfig & Partial<{\n *   size: Dimensions;\n * }> } TextConfig\n *\n * @typedef { BaseTextConfig & Partial<{\n *   box: Dimensions;\n *   fitBox: boolean;\n * }> } TextLayoutConfig\n *\n *  @typedef { Dimensions & {\n *  text: string;\n * } } LineDescriptor\n */\n\nvar DEFAULT_BOX_PADDING = 0;\nvar DEFAULT_LABEL_SIZE = {\n  width: 150,\n  height: 50\n};\n\n/**\n * @param {AlignmentConfig} align\n * @return {Alignment}\n */\nfunction parseAlign(align) {\n  var parts = align.split('-');\n  return {\n    horizontal: parts[0] || 'center',\n    vertical: parts[1] || 'top'\n  };\n}\n\n/**\n * @param {PaddingConfig} padding\n *\n * @return {Padding}\n */\nfunction parsePadding(padding) {\n  if (isObject(padding)) {\n    return assign({\n      top: 0,\n      left: 0,\n      right: 0,\n      bottom: 0\n    }, padding);\n  } else {\n    return {\n      top: padding,\n      left: padding,\n      right: padding,\n      bottom: padding\n    };\n  }\n}\n\n/**\n * @param {string} text\n * @param {SVGTextElement} fakeText\n *\n * @return {import('../util/Types').Dimensions}\n */\nfunction getTextBBox(text, fakeText) {\n  fakeText.textContent = text;\n  var textBBox;\n  try {\n    var bbox,\n      emptyLine = text === '';\n\n    // add dummy text, when line is empty to\n    // determine correct height\n    fakeText.textContent = emptyLine ? 'dummy' : text;\n    textBBox = fakeText.getBBox();\n\n    // take text rendering related horizontal\n    // padding into account\n    bbox = {\n      width: textBBox.width + textBBox.x * 2,\n      height: textBBox.height\n    };\n    if (emptyLine) {\n      // correct width\n      bbox.width = 0;\n    }\n    return bbox;\n  } catch (e) {\n    console.log(e);\n    return {\n      width: 0,\n      height: 0\n    };\n  }\n}\n\n/**\n * Layout the next line and return the layouted element.\n *\n * Alters the lines passed.\n *\n * @param {string[]} lines\n * @param {number} maxWidth\n * @param {SVGTextElement} fakeText\n *\n * @return {LineDescriptor} the line descriptor\n */\nfunction layoutNext(lines, maxWidth, fakeText) {\n  var originalLine = lines.shift(),\n    fitLine = originalLine;\n  var textBBox;\n  for (;;) {\n    textBBox = getTextBBox(fitLine, fakeText);\n    textBBox.width = fitLine ? textBBox.width : 0;\n\n    // try to fit\n    if (fitLine === ' ' || fitLine === '' || textBBox.width < Math.round(maxWidth) || fitLine.length < 2) {\n      return fit(lines, fitLine, originalLine, textBBox);\n    }\n    fitLine = shortenLine(fitLine, textBBox.width, maxWidth);\n  }\n}\n\n/**\n * @param {string[]} lines\n * @param {string} fitLine\n * @param {string} originalLine\n * @param {Dimensions} textBBox\n *\n * @return {LineDescriptor}\n */\nfunction fit(lines, fitLine, originalLine, textBBox) {\n  if (fitLine.length < originalLine.length) {\n    var remainder = originalLine.slice(fitLine.length).trim();\n    lines.unshift(remainder);\n  }\n  return {\n    width: textBBox.width,\n    height: textBBox.height,\n    text: fitLine\n  };\n}\nvar SOFT_BREAK = '\\u00AD';\n\n/**\n * Shortens a line based on spacing and hyphens.\n * Returns the shortened result on success.\n *\n * @param {string} line\n * @param {number} maxLength the maximum characters of the string\n *\n * @return {string} the shortened string\n */\nfunction semanticShorten(line, maxLength) {\n  var parts = line.split(/(\\s|-|\\u00AD)/g),\n    part,\n    shortenedParts = [],\n    length = 0;\n\n  // try to shorten via break chars\n  if (parts.length > 1) {\n    while (part = parts.shift()) {\n      if (part.length + length < maxLength) {\n        shortenedParts.push(part);\n        length += part.length;\n      } else {\n        // remove previous part, too if hyphen does not fit anymore\n        if (part === '-' || part === SOFT_BREAK) {\n          shortenedParts.pop();\n        }\n        break;\n      }\n    }\n  }\n  var last = shortenedParts[shortenedParts.length - 1];\n\n  // translate trailing soft break to actual hyphen\n  if (last && last === SOFT_BREAK) {\n    shortenedParts[shortenedParts.length - 1] = '-';\n  }\n  return shortenedParts.join('');\n}\n\n/**\n * @param {string} line\n * @param {number} width\n * @param {number} maxWidth\n *\n * @return {string}\n */\nfunction shortenLine(line, width, maxWidth) {\n  var length = Math.max(line.length * (maxWidth / width), 1);\n\n  // try to shorten semantically (i.e. based on spaces and hyphens)\n  var shortenedLine = semanticShorten(line, length);\n  if (!shortenedLine) {\n    // force shorten by cutting the long word\n    shortenedLine = line.slice(0, Math.max(Math.round(length - 1), 1));\n  }\n  return shortenedLine;\n}\n\n/**\n * @return {SVGSVGElement}\n */\nfunction getHelperSvg() {\n  var helperSvg = document.getElementById('helper-svg');\n  if (!helperSvg) {\n    helperSvg = svgCreate('svg');\n    svgAttr(helperSvg, {\n      id: 'helper-svg'\n    });\n    assignStyle(helperSvg, {\n      visibility: 'hidden',\n      position: 'fixed',\n      width: 0,\n      height: 0\n    });\n    document.body.appendChild(helperSvg);\n  }\n  return helperSvg;\n}\n\n/**\n * Creates a new label utility\n *\n * @param {TextConfig} [config]\n */\nexport default function Text(config) {\n  this._config = assign({}, {\n    size: DEFAULT_LABEL_SIZE,\n    padding: DEFAULT_BOX_PADDING,\n    style: {},\n    align: 'center-top'\n  }, config || {});\n}\n\n/**\n * Returns the layouted text as an SVG element.\n *\n * @param {string} text\n * @param {TextLayoutConfig} options\n *\n * @return {SVGElement}\n */\nText.prototype.createText = function (text, options) {\n  return this.layoutText(text, options).element;\n};\n\n/**\n * Returns a labels layouted dimensions.\n *\n * @param {string} text to layout\n * @param {TextLayoutConfig} options\n *\n * @return {Dimensions}\n */\nText.prototype.getDimensions = function (text, options) {\n  return this.layoutText(text, options).dimensions;\n};\n\n/**\n * Creates and returns a label and its bounding box.\n *\n * @param {string} text the text to render on the label\n * @param {TextLayoutConfig} options\n *\n * @return { {\n *   element: SVGElement,\n *   dimensions: Dimensions\n * } }\n */\nText.prototype.layoutText = function (text, options) {\n  var box = assign({}, this._config.size, options.box),\n    style = assign({}, this._config.style, options.style),\n    align = parseAlign(options.align || this._config.align),\n    padding = parsePadding(options.padding !== undefined ? options.padding : this._config.padding),\n    fitBox = options.fitBox || false;\n  var lineHeight = getLineHeight(style);\n\n  // we split text by lines and normalize\n  // {soft break} + {line break} => { line break }\n  var lines = text.split(/\\u00AD?\\r?\\n/),\n    layouted = [];\n  var maxWidth = box.width - padding.left - padding.right;\n\n  // ensure correct rendering by attaching helper text node to invisible SVG\n  var helperText = svgCreate('text');\n  svgAttr(helperText, {\n    x: 0,\n    y: 0\n  });\n  svgAttr(helperText, style);\n  var helperSvg = getHelperSvg();\n  svgAppend(helperSvg, helperText);\n  while (lines.length) {\n    layouted.push(layoutNext(lines, maxWidth, helperText));\n  }\n  if (align.vertical === 'middle') {\n    padding.top = padding.bottom = 0;\n  }\n  var totalHeight = reduce(layouted, function (sum, line, idx) {\n    return sum + (lineHeight || line.height);\n  }, 0) + padding.top + padding.bottom;\n  var maxLineWidth = reduce(layouted, function (sum, line, idx) {\n    return line.width > sum ? line.width : sum;\n  }, 0);\n\n  // the y position of the next line\n  var y = padding.top;\n  if (align.vertical === 'middle') {\n    y += (box.height - totalHeight) / 2;\n  }\n\n  // magic number initial offset\n  y -= (lineHeight || layouted[0].height) / 4;\n  var textElement = svgCreate('text');\n  svgAttr(textElement, style);\n\n  // layout each line taking into account that parent\n  // shape might resize to fit text size\n  forEach(layouted, function (line) {\n    var x;\n    y += lineHeight || line.height;\n    switch (align.horizontal) {\n      case 'left':\n        x = padding.left;\n        break;\n      case 'right':\n        x = (fitBox ? maxLineWidth : maxWidth) - padding.right - line.width;\n        break;\n      default:\n        // aka center\n        x = Math.max(((fitBox ? maxLineWidth : maxWidth) - line.width) / 2 + padding.left, 0);\n    }\n    var tspan = svgCreate('tspan');\n    svgAttr(tspan, {\n      x: x,\n      y: y\n    });\n    tspan.textContent = line.text;\n    svgAppend(textElement, tspan);\n  });\n  svgRemove(helperText);\n  var dimensions = {\n    width: maxLineWidth,\n    height: totalHeight\n  };\n  return {\n    dimensions: dimensions,\n    element: textElement\n  };\n};\nfunction getLineHeight(style) {\n  if ('fontSize' in style && 'lineHeight' in style) {\n    return style.lineHeight * parseInt(style.fontSize, 10);\n  }\n}","map":{"version":3,"names":["isObject","assign","forEach","reduce","append","svgAppend","attr","svgAttr","create","svgCreate","remove","svgRemove","assignStyle","DEFAULT_BOX_PADDING","DEFAULT_LABEL_SIZE","width","height","parseAlign","align","parts","split","horizontal","vertical","parsePadding","padding","top","left","right","bottom","getTextBBox","text","fakeText","textContent","textBBox","bbox","emptyLine","getBBox","x","e","console","log","layoutNext","lines","maxWidth","originalLine","shift","fitLine","Math","round","length","fit","shortenLine","remainder","slice","trim","unshift","SOFT_BREAK","semanticShorten","line","maxLength","part","shortenedParts","push","pop","last","join","max","shortenedLine","getHelperSvg","helperSvg","document","getElementById","id","visibility","position","body","appendChild","Text","config","_config","size","style","prototype","createText","options","layoutText","element","getDimensions","dimensions","box","undefined","fitBox","lineHeight","getLineHeight","layouted","helperText","y","totalHeight","sum","idx","maxLineWidth","textElement","tspan","parseInt","fontSize"],"sources":["/home/runner/work/sgex/sgex/node_modules/diagram-js/lib/util/Text.js"],"sourcesContent":["import {\n  isObject,\n  assign,\n  forEach,\n  reduce\n} from 'min-dash';\n\nimport {\n  append as svgAppend,\n  attr as svgAttr,\n  create as svgCreate,\n  remove as svgRemove\n} from 'tiny-svg';\n\nimport {\n  assignStyle\n} from 'min-dom';\n\n\n/**\n * @typedef {import('../util/Types').Dimensions} Dimensions\n *\n * @typedef { {\n *   top: number;\n *   left: number;\n *   right: number;\n *   bottom: number;\n * } } Padding\n *\n * @typedef { number | Partial<Padding> } PaddingConfig\n *\n * @typedef { {\n *   horizontal: 'center' | 'left' | 'right';\n *   vertical: 'top' | 'middle';\n * } } Alignment\n *\n *  @typedef { 'center-middle' | 'center-top' } AlignmentConfig\n *\n * @typedef { Partial<{\n *   align: AlignmentConfig;\n *   style: Record<string, number | string>;\n *   padding: PaddingConfig;\n * }> } BaseTextConfig\n *\n * @typedef { BaseTextConfig & Partial<{\n *   size: Dimensions;\n * }> } TextConfig\n *\n * @typedef { BaseTextConfig & Partial<{\n *   box: Dimensions;\n *   fitBox: boolean;\n * }> } TextLayoutConfig\n *\n *  @typedef { Dimensions & {\n *  text: string;\n * } } LineDescriptor\n */\n\nvar DEFAULT_BOX_PADDING = 0;\n\nvar DEFAULT_LABEL_SIZE = {\n  width: 150,\n  height: 50\n};\n\n\n/**\n * @param {AlignmentConfig} align\n * @return {Alignment}\n */\nfunction parseAlign(align) {\n\n  var parts = align.split('-');\n\n  return {\n    horizontal: parts[0] || 'center',\n    vertical: parts[1] || 'top'\n  };\n}\n\n/**\n * @param {PaddingConfig} padding\n *\n * @return {Padding}\n */\nfunction parsePadding(padding) {\n\n  if (isObject(padding)) {\n    return assign({ top: 0, left: 0, right: 0, bottom: 0 }, padding);\n  } else {\n    return {\n      top: padding,\n      left: padding,\n      right: padding,\n      bottom: padding\n    };\n  }\n}\n\n/**\n * @param {string} text\n * @param {SVGTextElement} fakeText\n *\n * @return {import('../util/Types').Dimensions}\n */\nfunction getTextBBox(text, fakeText) {\n\n  fakeText.textContent = text;\n\n  var textBBox;\n\n  try {\n    var bbox,\n        emptyLine = text === '';\n\n    // add dummy text, when line is empty to\n    // determine correct height\n    fakeText.textContent = emptyLine ? 'dummy' : text;\n\n    textBBox = fakeText.getBBox();\n\n    // take text rendering related horizontal\n    // padding into account\n    bbox = {\n      width: textBBox.width + textBBox.x * 2,\n      height: textBBox.height\n    };\n\n    if (emptyLine) {\n\n      // correct width\n      bbox.width = 0;\n    }\n\n    return bbox;\n  } catch (e) {\n    console.log(e);\n\n    return { width: 0, height: 0 };\n  }\n}\n\n\n/**\n * Layout the next line and return the layouted element.\n *\n * Alters the lines passed.\n *\n * @param {string[]} lines\n * @param {number} maxWidth\n * @param {SVGTextElement} fakeText\n *\n * @return {LineDescriptor} the line descriptor\n */\nfunction layoutNext(lines, maxWidth, fakeText) {\n\n  var originalLine = lines.shift(),\n      fitLine = originalLine;\n\n  var textBBox;\n\n  for (;;) {\n    textBBox = getTextBBox(fitLine, fakeText);\n\n    textBBox.width = fitLine ? textBBox.width : 0;\n\n    // try to fit\n    if (fitLine === ' ' || fitLine === '' || textBBox.width < Math.round(maxWidth) || fitLine.length < 2) {\n      return fit(lines, fitLine, originalLine, textBBox);\n    }\n\n    fitLine = shortenLine(fitLine, textBBox.width, maxWidth);\n  }\n}\n\n/**\n * @param {string[]} lines\n * @param {string} fitLine\n * @param {string} originalLine\n * @param {Dimensions} textBBox\n *\n * @return {LineDescriptor}\n */\nfunction fit(lines, fitLine, originalLine, textBBox) {\n  if (fitLine.length < originalLine.length) {\n    var remainder = originalLine.slice(fitLine.length).trim();\n\n    lines.unshift(remainder);\n  }\n\n  return {\n    width: textBBox.width,\n    height: textBBox.height,\n    text: fitLine\n  };\n}\n\nvar SOFT_BREAK = '\\u00AD';\n\n\n/**\n * Shortens a line based on spacing and hyphens.\n * Returns the shortened result on success.\n *\n * @param {string} line\n * @param {number} maxLength the maximum characters of the string\n *\n * @return {string} the shortened string\n */\nfunction semanticShorten(line, maxLength) {\n\n  var parts = line.split(/(\\s|-|\\u00AD)/g),\n      part,\n      shortenedParts = [],\n      length = 0;\n\n  // try to shorten via break chars\n  if (parts.length > 1) {\n\n    while ((part = parts.shift())) {\n      if (part.length + length < maxLength) {\n        shortenedParts.push(part);\n        length += part.length;\n      } else {\n\n        // remove previous part, too if hyphen does not fit anymore\n        if (part === '-' || part === SOFT_BREAK) {\n          shortenedParts.pop();\n        }\n\n        break;\n      }\n    }\n  }\n\n  var last = shortenedParts[shortenedParts.length - 1];\n\n  // translate trailing soft break to actual hyphen\n  if (last && last === SOFT_BREAK) {\n    shortenedParts[shortenedParts.length - 1] = '-';\n  }\n\n  return shortenedParts.join('');\n}\n\n\n/**\n * @param {string} line\n * @param {number} width\n * @param {number} maxWidth\n *\n * @return {string}\n */\nfunction shortenLine(line, width, maxWidth) {\n  var length = Math.max(line.length * (maxWidth / width), 1);\n\n  // try to shorten semantically (i.e. based on spaces and hyphens)\n  var shortenedLine = semanticShorten(line, length);\n\n  if (!shortenedLine) {\n\n    // force shorten by cutting the long word\n    shortenedLine = line.slice(0, Math.max(Math.round(length - 1), 1));\n  }\n\n  return shortenedLine;\n}\n\n\n/**\n * @return {SVGSVGElement}\n */\nfunction getHelperSvg() {\n  var helperSvg = document.getElementById('helper-svg');\n\n  if (!helperSvg) {\n    helperSvg = svgCreate('svg');\n\n    svgAttr(helperSvg, {\n      id: 'helper-svg'\n    });\n\n    assignStyle(helperSvg, {\n      visibility: 'hidden',\n      position: 'fixed',\n      width: 0,\n      height: 0\n    });\n\n    document.body.appendChild(helperSvg);\n  }\n\n  return helperSvg;\n}\n\n\n/**\n * Creates a new label utility\n *\n * @param {TextConfig} [config]\n */\nexport default function Text(config) {\n\n  this._config = assign({}, {\n    size: DEFAULT_LABEL_SIZE,\n    padding: DEFAULT_BOX_PADDING,\n    style: {},\n    align: 'center-top'\n  }, config || {});\n}\n\n/**\n * Returns the layouted text as an SVG element.\n *\n * @param {string} text\n * @param {TextLayoutConfig} options\n *\n * @return {SVGElement}\n */\nText.prototype.createText = function(text, options) {\n  return this.layoutText(text, options).element;\n};\n\n/**\n * Returns a labels layouted dimensions.\n *\n * @param {string} text to layout\n * @param {TextLayoutConfig} options\n *\n * @return {Dimensions}\n */\nText.prototype.getDimensions = function(text, options) {\n  return this.layoutText(text, options).dimensions;\n};\n\n/**\n * Creates and returns a label and its bounding box.\n *\n * @param {string} text the text to render on the label\n * @param {TextLayoutConfig} options\n *\n * @return { {\n *   element: SVGElement,\n *   dimensions: Dimensions\n * } }\n */\nText.prototype.layoutText = function(text, options) {\n  var box = assign({}, this._config.size, options.box),\n      style = assign({}, this._config.style, options.style),\n      align = parseAlign(options.align || this._config.align),\n      padding = parsePadding(options.padding !== undefined ? options.padding : this._config.padding),\n      fitBox = options.fitBox || false;\n\n  var lineHeight = getLineHeight(style);\n\n  // we split text by lines and normalize\n  // {soft break} + {line break} => { line break }\n  var lines = text.split(/\\u00AD?\\r?\\n/),\n      layouted = [];\n\n  var maxWidth = box.width - padding.left - padding.right;\n\n  // ensure correct rendering by attaching helper text node to invisible SVG\n  var helperText = svgCreate('text');\n  svgAttr(helperText, { x: 0, y: 0 });\n  svgAttr(helperText, style);\n\n  var helperSvg = getHelperSvg();\n\n  svgAppend(helperSvg, helperText);\n\n  while (lines.length) {\n    layouted.push(layoutNext(lines, maxWidth, helperText));\n  }\n\n  if (align.vertical === 'middle') {\n    padding.top = padding.bottom = 0;\n  }\n\n  var totalHeight = reduce(layouted, function(sum, line, idx) {\n    return sum + (lineHeight || line.height);\n  }, 0) + padding.top + padding.bottom;\n\n  var maxLineWidth = reduce(layouted, function(sum, line, idx) {\n    return line.width > sum ? line.width : sum;\n  }, 0);\n\n  // the y position of the next line\n  var y = padding.top;\n\n  if (align.vertical === 'middle') {\n    y += (box.height - totalHeight) / 2;\n  }\n\n  // magic number initial offset\n  y -= (lineHeight || layouted[0].height) / 4;\n\n\n  var textElement = svgCreate('text');\n\n  svgAttr(textElement, style);\n\n  // layout each line taking into account that parent\n  // shape might resize to fit text size\n  forEach(layouted, function(line) {\n\n    var x;\n\n    y += (lineHeight || line.height);\n\n    switch (align.horizontal) {\n    case 'left':\n      x = padding.left;\n      break;\n\n    case 'right':\n      x = ((fitBox ? maxLineWidth : maxWidth)\n        - padding.right - line.width);\n      break;\n\n    default:\n\n      // aka center\n      x = Math.max((((fitBox ? maxLineWidth : maxWidth)\n        - line.width) / 2 + padding.left), 0);\n    }\n\n    var tspan = svgCreate('tspan');\n    svgAttr(tspan, { x: x, y: y });\n\n    tspan.textContent = line.text;\n\n    svgAppend(textElement, tspan);\n  });\n\n  svgRemove(helperText);\n\n  var dimensions = {\n    width: maxLineWidth,\n    height: totalHeight\n  };\n\n  return {\n    dimensions: dimensions,\n    element: textElement\n  };\n};\n\n\nfunction getLineHeight(style) {\n  if ('fontSize' in style && 'lineHeight' in style) {\n    return style.lineHeight * parseInt(style.fontSize, 10);\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}