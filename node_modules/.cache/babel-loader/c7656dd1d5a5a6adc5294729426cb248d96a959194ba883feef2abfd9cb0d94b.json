{"ast":null,"code":"import { forEach } from 'min-dash';\nimport { getResizedSourceAnchor, getResizedTargetAnchor } from './helper/AnchorsHelper';\n\n/**\n * @typedef {import('../../model/Types').Shape} Shape\n *\n * @typedef {import('../Modeling').default} Modeling\n * @typedef {import('../../rules/Rules').default} Rules\n */\n\n/**\n * Replace shape by adding new shape and removing old shape. Incoming and outgoing connections will\n * be kept if possible.\n *\n * @class\n * @constructor\n *\n * @param {Modeling} modeling\n * @param {Rules} rules\n */\nexport default function ReplaceShapeHandler(modeling, rules) {\n  this._modeling = modeling;\n  this._rules = rules;\n}\nReplaceShapeHandler.$inject = ['modeling', 'rules'];\n\n/**\n * Add new shape.\n *\n * @param {Object} context\n * @param {Shape} context.oldShape\n * @param {Object} context.newData\n * @param {string} context.newData.type\n * @param {number} context.newData.x\n * @param {number} context.newData.y\n * @param {Object} [context.hints]\n */\nReplaceShapeHandler.prototype.preExecute = function (context) {\n  var self = this,\n    modeling = this._modeling,\n    rules = this._rules;\n  var oldShape = context.oldShape,\n    newData = context.newData,\n    hints = context.hints || {},\n    newShape;\n  function canReconnect(source, target, connection) {\n    return rules.allowed('connection.reconnect', {\n      connection: connection,\n      source: source,\n      target: target\n    });\n  }\n\n  // (1) add new shape at given position\n  var position = {\n    x: newData.x,\n    y: newData.y\n  };\n  var oldBounds = {\n    x: oldShape.x,\n    y: oldShape.y,\n    width: oldShape.width,\n    height: oldShape.height\n  };\n  newShape = context.newShape = context.newShape || self.createShape(newData, position, oldShape.parent, hints);\n\n  // (2) update host\n  if (oldShape.host) {\n    modeling.updateAttachment(newShape, oldShape.host);\n  }\n\n  // (3) adopt all children from old shape\n  var children;\n  if (hints.moveChildren !== false) {\n    children = oldShape.children.slice();\n    modeling.moveElements(children, {\n      x: 0,\n      y: 0\n    }, newShape, hints);\n  }\n\n  // (4) reconnect connections to new shape if possible\n  var incoming = oldShape.incoming.slice(),\n    outgoing = oldShape.outgoing.slice();\n  forEach(incoming, function (connection) {\n    var source = connection.source,\n      allowed = canReconnect(source, newShape, connection);\n    if (allowed) {\n      self.reconnectEnd(connection, newShape, getResizedTargetAnchor(connection, newShape, oldBounds), hints);\n    }\n  });\n  forEach(outgoing, function (connection) {\n    var target = connection.target,\n      allowed = canReconnect(newShape, target, connection);\n    if (allowed) {\n      self.reconnectStart(connection, newShape, getResizedSourceAnchor(connection, newShape, oldBounds), hints);\n    }\n  });\n};\n\n/**\n * Remove old shape.\n */\nReplaceShapeHandler.prototype.postExecute = function (context) {\n  var oldShape = context.oldShape;\n  this._modeling.removeShape(oldShape);\n};\nReplaceShapeHandler.prototype.execute = function (context) {};\nReplaceShapeHandler.prototype.revert = function (context) {};\nReplaceShapeHandler.prototype.createShape = function (shape, position, target, hints) {\n  return this._modeling.createShape(shape, position, target, hints);\n};\nReplaceShapeHandler.prototype.reconnectStart = function (connection, newSource, dockingPoint, hints) {\n  this._modeling.reconnectStart(connection, newSource, dockingPoint, hints);\n};\nReplaceShapeHandler.prototype.reconnectEnd = function (connection, newTarget, dockingPoint, hints) {\n  this._modeling.reconnectEnd(connection, newTarget, dockingPoint, hints);\n};","map":{"version":3,"names":["forEach","getResizedSourceAnchor","getResizedTargetAnchor","ReplaceShapeHandler","modeling","rules","_modeling","_rules","$inject","prototype","preExecute","context","self","oldShape","newData","hints","newShape","canReconnect","source","target","connection","allowed","position","x","y","oldBounds","width","height","createShape","parent","host","updateAttachment","children","moveChildren","slice","moveElements","incoming","outgoing","reconnectEnd","reconnectStart","postExecute","removeShape","execute","revert","shape","newSource","dockingPoint","newTarget"],"sources":["/home/runner/work/sgex/sgex/node_modules/diagram-js/lib/features/modeling/cmd/ReplaceShapeHandler.js"],"sourcesContent":["import { forEach } from 'min-dash';\n\nimport {\n  getResizedSourceAnchor,\n  getResizedTargetAnchor\n} from './helper/AnchorsHelper';\n\n/**\n * @typedef {import('../../model/Types').Shape} Shape\n *\n * @typedef {import('../Modeling').default} Modeling\n * @typedef {import('../../rules/Rules').default} Rules\n */\n\n/**\n * Replace shape by adding new shape and removing old shape. Incoming and outgoing connections will\n * be kept if possible.\n *\n * @class\n * @constructor\n *\n * @param {Modeling} modeling\n * @param {Rules} rules\n */\nexport default function ReplaceShapeHandler(modeling, rules) {\n  this._modeling = modeling;\n  this._rules = rules;\n}\n\nReplaceShapeHandler.$inject = [ 'modeling', 'rules' ];\n\n\n/**\n * Add new shape.\n *\n * @param {Object} context\n * @param {Shape} context.oldShape\n * @param {Object} context.newData\n * @param {string} context.newData.type\n * @param {number} context.newData.x\n * @param {number} context.newData.y\n * @param {Object} [context.hints]\n */\nReplaceShapeHandler.prototype.preExecute = function(context) {\n  var self = this,\n      modeling = this._modeling,\n      rules = this._rules;\n\n  var oldShape = context.oldShape,\n      newData = context.newData,\n      hints = context.hints || {},\n      newShape;\n\n  function canReconnect(source, target, connection) {\n    return rules.allowed('connection.reconnect', {\n      connection: connection,\n      source: source,\n      target: target\n    });\n  }\n\n  // (1) add new shape at given position\n  var position = {\n    x: newData.x,\n    y: newData.y\n  };\n\n  var oldBounds = {\n    x: oldShape.x,\n    y: oldShape.y,\n    width: oldShape.width,\n    height: oldShape.height\n  };\n\n  newShape = context.newShape =\n    context.newShape ||\n    self.createShape(newData, position, oldShape.parent, hints);\n\n  // (2) update host\n  if (oldShape.host) {\n    modeling.updateAttachment(newShape, oldShape.host);\n  }\n\n  // (3) adopt all children from old shape\n  var children;\n\n  if (hints.moveChildren !== false) {\n    children = oldShape.children.slice();\n\n    modeling.moveElements(children, { x: 0, y: 0 }, newShape, hints);\n  }\n\n  // (4) reconnect connections to new shape if possible\n  var incoming = oldShape.incoming.slice(),\n      outgoing = oldShape.outgoing.slice();\n\n  forEach(incoming, function(connection) {\n    var source = connection.source,\n        allowed = canReconnect(source, newShape, connection);\n\n    if (allowed) {\n      self.reconnectEnd(\n        connection, newShape,\n        getResizedTargetAnchor(connection, newShape, oldBounds),\n        hints\n      );\n    }\n  });\n\n  forEach(outgoing, function(connection) {\n    var target = connection.target,\n        allowed = canReconnect(newShape, target, connection);\n\n    if (allowed) {\n      self.reconnectStart(\n        connection, newShape,\n        getResizedSourceAnchor(connection, newShape, oldBounds),\n        hints\n      );\n    }\n  });\n};\n\n\n/**\n * Remove old shape.\n */\nReplaceShapeHandler.prototype.postExecute = function(context) {\n  var oldShape = context.oldShape;\n\n  this._modeling.removeShape(oldShape);\n};\n\n\nReplaceShapeHandler.prototype.execute = function(context) {};\n\n\nReplaceShapeHandler.prototype.revert = function(context) {};\n\n\nReplaceShapeHandler.prototype.createShape = function(shape, position, target, hints) {\n  return this._modeling.createShape(shape, position, target, hints);\n};\n\n\nReplaceShapeHandler.prototype.reconnectStart = function(connection, newSource, dockingPoint, hints) {\n  this._modeling.reconnectStart(connection, newSource, dockingPoint, hints);\n};\n\n\nReplaceShapeHandler.prototype.reconnectEnd = function(connection, newTarget, dockingPoint, hints) {\n  this._modeling.reconnectEnd(connection, newTarget, dockingPoint, hints);\n};\n"],"mappings":"AAAA,SAASA,OAAO,QAAQ,UAAU;AAElC,SACEC,sBAAsB,EACtBC,sBAAsB,QACjB,wBAAwB;;AAE/B;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,SAASC,mBAAmBA,CAACC,QAAQ,EAAEC,KAAK,EAAE;EAC3D,IAAI,CAACC,SAAS,GAAGF,QAAQ;EACzB,IAAI,CAACG,MAAM,GAAGF,KAAK;AACrB;AAEAF,mBAAmB,CAACK,OAAO,GAAG,CAAE,UAAU,EAAE,OAAO,CAAE;;AAGrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACAL,mBAAmB,CAACM,SAAS,CAACC,UAAU,GAAG,UAASC,OAAO,EAAE;EAC3D,IAAIC,IAAI,GAAG,IAAI;IACXR,QAAQ,GAAG,IAAI,CAACE,SAAS;IACzBD,KAAK,GAAG,IAAI,CAACE,MAAM;EAEvB,IAAIM,QAAQ,GAAGF,OAAO,CAACE,QAAQ;IAC3BC,OAAO,GAAGH,OAAO,CAACG,OAAO;IACzBC,KAAK,GAAGJ,OAAO,CAACI,KAAK,IAAI,CAAC,CAAC;IAC3BC,QAAQ;EAEZ,SAASC,YAAYA,CAACC,MAAM,EAAEC,MAAM,EAAEC,UAAU,EAAE;IAChD,OAAOf,KAAK,CAACgB,OAAO,CAAC,sBAAsB,EAAE;MAC3CD,UAAU,EAAEA,UAAU;MACtBF,MAAM,EAAEA,MAAM;MACdC,MAAM,EAAEA;IACV,CAAC,CAAC;EACJ;;EAEA;EACA,IAAIG,QAAQ,GAAG;IACbC,CAAC,EAAET,OAAO,CAACS,CAAC;IACZC,CAAC,EAAEV,OAAO,CAACU;EACb,CAAC;EAED,IAAIC,SAAS,GAAG;IACdF,CAAC,EAAEV,QAAQ,CAACU,CAAC;IACbC,CAAC,EAAEX,QAAQ,CAACW,CAAC;IACbE,KAAK,EAAEb,QAAQ,CAACa,KAAK;IACrBC,MAAM,EAAEd,QAAQ,CAACc;EACnB,CAAC;EAEDX,QAAQ,GAAGL,OAAO,CAACK,QAAQ,GACzBL,OAAO,CAACK,QAAQ,IAChBJ,IAAI,CAACgB,WAAW,CAACd,OAAO,EAAEQ,QAAQ,EAAET,QAAQ,CAACgB,MAAM,EAAEd,KAAK,CAAC;;EAE7D;EACA,IAAIF,QAAQ,CAACiB,IAAI,EAAE;IACjB1B,QAAQ,CAAC2B,gBAAgB,CAACf,QAAQ,EAAEH,QAAQ,CAACiB,IAAI,CAAC;EACpD;;EAEA;EACA,IAAIE,QAAQ;EAEZ,IAAIjB,KAAK,CAACkB,YAAY,KAAK,KAAK,EAAE;IAChCD,QAAQ,GAAGnB,QAAQ,CAACmB,QAAQ,CAACE,KAAK,CAAC,CAAC;IAEpC9B,QAAQ,CAAC+B,YAAY,CAACH,QAAQ,EAAE;MAAET,CAAC,EAAE,CAAC;MAAEC,CAAC,EAAE;IAAE,CAAC,EAAER,QAAQ,EAAED,KAAK,CAAC;EAClE;;EAEA;EACA,IAAIqB,QAAQ,GAAGvB,QAAQ,CAACuB,QAAQ,CAACF,KAAK,CAAC,CAAC;IACpCG,QAAQ,GAAGxB,QAAQ,CAACwB,QAAQ,CAACH,KAAK,CAAC,CAAC;EAExClC,OAAO,CAACoC,QAAQ,EAAE,UAAShB,UAAU,EAAE;IACrC,IAAIF,MAAM,GAAGE,UAAU,CAACF,MAAM;MAC1BG,OAAO,GAAGJ,YAAY,CAACC,MAAM,EAAEF,QAAQ,EAAEI,UAAU,CAAC;IAExD,IAAIC,OAAO,EAAE;MACXT,IAAI,CAAC0B,YAAY,CACflB,UAAU,EAAEJ,QAAQ,EACpBd,sBAAsB,CAACkB,UAAU,EAAEJ,QAAQ,EAAES,SAAS,CAAC,EACvDV,KACF,CAAC;IACH;EACF,CAAC,CAAC;EAEFf,OAAO,CAACqC,QAAQ,EAAE,UAASjB,UAAU,EAAE;IACrC,IAAID,MAAM,GAAGC,UAAU,CAACD,MAAM;MAC1BE,OAAO,GAAGJ,YAAY,CAACD,QAAQ,EAAEG,MAAM,EAAEC,UAAU,CAAC;IAExD,IAAIC,OAAO,EAAE;MACXT,IAAI,CAAC2B,cAAc,CACjBnB,UAAU,EAAEJ,QAAQ,EACpBf,sBAAsB,CAACmB,UAAU,EAAEJ,QAAQ,EAAES,SAAS,CAAC,EACvDV,KACF,CAAC;IACH;EACF,CAAC,CAAC;AACJ,CAAC;;AAGD;AACA;AACA;AACAZ,mBAAmB,CAACM,SAAS,CAAC+B,WAAW,GAAG,UAAS7B,OAAO,EAAE;EAC5D,IAAIE,QAAQ,GAAGF,OAAO,CAACE,QAAQ;EAE/B,IAAI,CAACP,SAAS,CAACmC,WAAW,CAAC5B,QAAQ,CAAC;AACtC,CAAC;AAGDV,mBAAmB,CAACM,SAAS,CAACiC,OAAO,GAAG,UAAS/B,OAAO,EAAE,CAAC,CAAC;AAG5DR,mBAAmB,CAACM,SAAS,CAACkC,MAAM,GAAG,UAAShC,OAAO,EAAE,CAAC,CAAC;AAG3DR,mBAAmB,CAACM,SAAS,CAACmB,WAAW,GAAG,UAASgB,KAAK,EAAEtB,QAAQ,EAAEH,MAAM,EAAEJ,KAAK,EAAE;EACnF,OAAO,IAAI,CAACT,SAAS,CAACsB,WAAW,CAACgB,KAAK,EAAEtB,QAAQ,EAAEH,MAAM,EAAEJ,KAAK,CAAC;AACnE,CAAC;AAGDZ,mBAAmB,CAACM,SAAS,CAAC8B,cAAc,GAAG,UAASnB,UAAU,EAAEyB,SAAS,EAAEC,YAAY,EAAE/B,KAAK,EAAE;EAClG,IAAI,CAACT,SAAS,CAACiC,cAAc,CAACnB,UAAU,EAAEyB,SAAS,EAAEC,YAAY,EAAE/B,KAAK,CAAC;AAC3E,CAAC;AAGDZ,mBAAmB,CAACM,SAAS,CAAC6B,YAAY,GAAG,UAASlB,UAAU,EAAE2B,SAAS,EAAED,YAAY,EAAE/B,KAAK,EAAE;EAChG,IAAI,CAACT,SAAS,CAACgC,YAAY,CAAClB,UAAU,EAAE2B,SAAS,EAAED,YAAY,EAAE/B,KAAK,CAAC;AACzE,CAAC","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}