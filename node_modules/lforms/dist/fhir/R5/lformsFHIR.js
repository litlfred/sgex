/******/ (function() { // webpackBootstrap
/******/ 	var __webpack_modules__ = ([
/* 0 */,
/* 1 */
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   LOINC_URI: function() { return /* binding */ LOINC_URI; }
/* harmony export */ });
// Definitions for things needed by both importing and exporting.

let LOINC_URI = 'http://loinc.org';

/***/ }),
/* 2 */
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

// This is fhirpath interpreter
// everything starts at evaluate function,
// which is passed  fhirpath AST and resource.
//
// We reduce/eval recursively each node in AST
// passing the context and current data
//
// each AST node has eval function, which should be registered in evalTable
// and named after node type
// if node needs to eval father it's children it has to call `doEval` function
//
// most of nodes do function or operator invocation at the end
//
// For invocation's and operator's there is one lookup table -
// invocationTable and two helper functions doInvoke and infixInvoke for
// operators
// 1. operator or function is looked up in table
// 2. using signature (in  .arity property) unpack parameters
// 3. check params types
// 4. do call function
// 5. wrap result by util.arraify
//
// if function is nullable
// and one of parameters is empty/null - function will not be invoked and empty
// result returned
//
// Not solved problem is overloading functions by types - for example + operator defined
// for strings and numbers
// we can make dispatching params type dependent - let see

const {
  version
} = __webpack_require__(3);
const parser = __webpack_require__(4);
const util = __webpack_require__(53);
__webpack_require__(69);
const constants = __webpack_require__(70);
let engine = {}; // the object with all FHIRPath functions and operations
let existence = __webpack_require__(71);
let filtering = __webpack_require__(72);
let aggregate = __webpack_require__(76);
let supplements = __webpack_require__(79);
let combining = __webpack_require__(80);
let misc = __webpack_require__(75);
let equality = __webpack_require__(78);
let collections = __webpack_require__(81);
let math = __webpack_require__(77);
let strings = __webpack_require__(82);
let navigation = __webpack_require__(83);
let datetime = __webpack_require__(84);
let additional = __webpack_require__(85);
let logic = __webpack_require__(87);
const types = __webpack_require__(54);
const {
  FP_Date,
  FP_DateTime,
  FP_Time,
  FP_Quantity,
  FP_Type,
  ResourceNode,
  TypeInfo
} = types;
let makeResNode = ResourceNode.makeResNode;
const Terminologies = __webpack_require__(86);
const Factory = __webpack_require__(88);

// * fn: handler
// * arity: is index map with type signature
//   if type is in array (like [Boolean]) - this means
//   function accepts value of this type or empty value {}
// * nullable:  means propagate empty result, i.e. instead
//   calling function if one of params is  empty return empty

engine.invocationTable = {
  memberOf: {
    fn: additional.memberOf,
    arity: {
      1: ['String']
    }
  },
  empty: {
    fn: existence.emptyFn
  },
  not: {
    fn: existence.notFn
  },
  exists: {
    fn: existence.existsMacro,
    arity: {
      0: [],
      1: ["Expr"]
    }
  },
  all: {
    fn: existence.allMacro,
    arity: {
      1: ["Expr"]
    }
  },
  allTrue: {
    fn: existence.allTrueFn
  },
  anyTrue: {
    fn: existence.anyTrueFn
  },
  allFalse: {
    fn: existence.allFalseFn
  },
  anyFalse: {
    fn: existence.anyFalseFn
  },
  subsetOf: {
    fn: existence.subsetOfFn,
    arity: {
      1: ["AnyAtRoot"]
    }
  },
  supersetOf: {
    fn: existence.supersetOfFn,
    arity: {
      1: ["AnyAtRoot"]
    }
  },
  isDistinct: {
    fn: existence.isDistinctFn
  },
  distinct: {
    fn: filtering.distinctFn
  },
  count: {
    fn: aggregate.countFn
  },
  where: {
    fn: filtering.whereMacro,
    arity: {
      1: ["Expr"]
    }
  },
  extension: {
    fn: filtering.extension,
    arity: {
      1: ["String"]
    }
  },
  select: {
    fn: filtering.selectMacro,
    arity: {
      1: ["Expr"]
    }
  },
  aggregate: {
    fn: aggregate.aggregateMacro,
    arity: {
      1: ["Expr"],
      2: ["Expr", "AnyAtRoot"]
    }
  },
  sum: {
    fn: aggregate.sumFn
  },
  min: {
    fn: aggregate.minFn
  },
  max: {
    fn: aggregate.maxFn
  },
  avg: {
    fn: aggregate.avgFn
  },
  weight: {
    fn: supplements.weight
  },
  ordinal: {
    fn: supplements.weight
  },
  single: {
    fn: filtering.singleFn
  },
  first: {
    fn: filtering.firstFn
  },
  last: {
    fn: filtering.lastFn
  },
  type: {
    fn: types.typeFn,
    arity: {
      0: []
    }
  },
  ofType: {
    fn: filtering.ofTypeFn,
    arity: {
      1: ["TypeSpecifier"]
    }
  },
  is: {
    fn: types.isFn,
    arity: {
      1: ["TypeSpecifier"]
    }
  },
  as: {
    fn: types.asFn,
    arity: {
      1: ["TypeSpecifier"]
    }
  },
  tail: {
    fn: filtering.tailFn
  },
  take: {
    fn: filtering.takeFn,
    arity: {
      1: ["Integer"]
    }
  },
  skip: {
    fn: filtering.skipFn,
    arity: {
      1: ["Integer"]
    }
  },
  combine: {
    fn: combining.combineFn,
    arity: {
      1: ["AnyAtRoot"]
    }
  },
  union: {
    fn: combining.union,
    arity: {
      1: ["AnyAtRoot"]
    }
  },
  intersect: {
    fn: combining.intersect,
    arity: {
      1: ["AnyAtRoot"]
    }
  },
  exclude: {
    fn: combining.exclude,
    arity: {
      1: ["AnyAtRoot"]
    }
  },
  iif: {
    fn: misc.iifMacro,
    arity: {
      2: ["Expr", "Expr"],
      3: ["Expr", "Expr", "Expr"]
    }
  },
  trace: {
    fn: misc.traceFn,
    arity: {
      1: ["String"],
      2: ["String", "Expr"]
    }
  },
  defineVariable: {
    fn: misc.defineVariable,
    arity: {
      1: ["String"],
      2: ["String", "Expr"]
    }
  },
  toInteger: {
    fn: misc.toInteger
  },
  toDecimal: {
    fn: misc.toDecimal
  },
  toString: {
    fn: misc.toString
  },
  toDate: {
    fn: misc.toDate
  },
  toDateTime: {
    fn: misc.toDateTime
  },
  toTime: {
    fn: misc.toTime
  },
  toBoolean: {
    fn: misc.toBoolean
  },
  toQuantity: {
    fn: misc.toQuantity,
    arity: {
      0: [],
      1: ["String"]
    }
  },
  hasValue: {
    fn: misc.hasValueFn
  },
  getValue: {
    fn: misc.getValueFn
  },
  convertsToBoolean: {
    fn: misc.createConvertsToFn(misc.toBoolean, 'boolean')
  },
  convertsToInteger: {
    fn: misc.createConvertsToFn(misc.toInteger, 'number')
  },
  convertsToDecimal: {
    fn: misc.createConvertsToFn(misc.toDecimal, 'number')
  },
  convertsToString: {
    fn: misc.createConvertsToFn(misc.toString, 'string')
  },
  convertsToDate: {
    fn: misc.createConvertsToFn(misc.toDate, FP_Date)
  },
  convertsToDateTime: {
    fn: misc.createConvertsToFn(misc.toDateTime, FP_DateTime)
  },
  convertsToTime: {
    fn: misc.createConvertsToFn(misc.toTime, FP_Time)
  },
  convertsToQuantity: {
    fn: misc.createConvertsToFn(misc.toQuantity, FP_Quantity)
  },
  indexOf: {
    fn: strings.indexOf,
    arity: {
      1: ["String"]
    }
  },
  substring: {
    fn: strings.substring,
    arity: {
      1: ["Integer"],
      2: ["Integer", "Integer"]
    }
  },
  startsWith: {
    fn: strings.startsWith,
    arity: {
      1: ["String"]
    }
  },
  endsWith: {
    fn: strings.endsWith,
    arity: {
      1: ["String"]
    }
  },
  contains: {
    fn: strings.containsFn,
    arity: {
      1: ["String"]
    }
  },
  upper: {
    fn: strings.upper
  },
  lower: {
    fn: strings.lower
  },
  replace: {
    fn: strings.replace,
    arity: {
      2: ["String", "String"]
    }
  },
  matches: {
    fn: strings.matches,
    arity: {
      1: ["String"]
    }
  },
  replaceMatches: {
    fn: strings.replaceMatches,
    arity: {
      2: ["String", "String"]
    }
  },
  length: {
    fn: strings.length
  },
  toChars: {
    fn: strings.toChars
  },
  join: {
    fn: strings.joinFn,
    arity: {
      0: [],
      1: ["String"]
    }
  },
  split: {
    fn: strings.splitFn,
    arity: {
      1: ["String"]
    }
  },
  trim: {
    fn: strings.trimFn
  },
  encode: {
    fn: strings.encodeFn,
    arity: {
      1: ["String"]
    }
  },
  decode: {
    fn: strings.decodeFn,
    arity: {
      1: ["String"]
    }
  },
  abs: {
    fn: math.abs
  },
  ceiling: {
    fn: math.ceiling
  },
  exp: {
    fn: math.exp
  },
  floor: {
    fn: math.floor
  },
  ln: {
    fn: math.ln
  },
  log: {
    fn: math.log,
    arity: {
      1: ["Number"]
    },
    nullable: true
  },
  power: {
    fn: math.power,
    arity: {
      1: ["Number"]
    },
    nullable: true
  },
  round: {
    fn: math.round,
    arity: {
      0: [],
      1: ["Number"]
    }
  },
  sqrt: {
    fn: math.sqrt
  },
  truncate: {
    fn: math.truncate
  },
  now: {
    fn: datetime.now
  },
  today: {
    fn: datetime.today
  },
  timeOfDay: {
    fn: datetime.timeOfDay
  },
  repeat: {
    fn: filtering.repeatMacro,
    arity: {
      1: ["Expr"]
    }
  },
  children: {
    fn: navigation.children
  },
  descendants: {
    fn: navigation.descendants
  },
  "|": {
    fn: combining.union,
    arity: {
      2: ["Any", "Any"]
    }
  },
  "=": {
    fn: equality.equal,
    arity: {
      2: ["Any", "Any"]
    },
    nullable: true
  },
  "!=": {
    fn: equality.unequal,
    arity: {
      2: ["Any", "Any"]
    },
    nullable: true
  },
  "~": {
    fn: equality.equival,
    arity: {
      2: ["Any", "Any"]
    }
  },
  "!~": {
    fn: equality.unequival,
    arity: {
      2: ["Any", "Any"]
    }
  },
  "<": {
    fn: equality.lt,
    arity: {
      2: ["Any", "Any"]
    },
    nullable: true
  },
  ">": {
    fn: equality.gt,
    arity: {
      2: ["Any", "Any"]
    },
    nullable: true
  },
  "<=": {
    fn: equality.lte,
    arity: {
      2: ["Any", "Any"]
    },
    nullable: true
  },
  ">=": {
    fn: equality.gte,
    arity: {
      2: ["Any", "Any"]
    },
    nullable: true
  },
  "containsOp": {
    fn: collections.contains,
    arity: {
      2: ["Any", "Any"]
    }
  },
  "inOp": {
    fn: collections.in,
    arity: {
      2: ["Any", "Any"]
    }
  },
  "isOp": {
    fn: types.isFn,
    arity: {
      2: ["Any", "TypeSpecifier"]
    }
  },
  "asOp": {
    fn: types.asFn,
    arity: {
      2: ["Any", "TypeSpecifier"]
    }
  },
  "&": {
    fn: math.amp,
    arity: {
      2: ["String", "String"]
    }
  },
  "+": {
    fn: math.plus,
    arity: {
      2: ["Any", "Any"]
    },
    nullable: true
  },
  "-": {
    fn: math.minus,
    arity: {
      2: ["Any", "Any"]
    },
    nullable: true
  },
  "*": {
    fn: math.mul,
    arity: {
      2: ["Any", "Any"]
    },
    nullable: true
  },
  "/": {
    fn: math.div,
    arity: {
      2: ["Any", "Any"]
    },
    nullable: true
  },
  "mod": {
    fn: math.mod,
    arity: {
      2: ["Number", "Number"]
    },
    nullable: true
  },
  "div": {
    fn: math.intdiv,
    arity: {
      2: ["Number", "Number"]
    },
    nullable: true
  },
  "or": {
    fn: logic.orOp,
    arity: {
      2: [["Boolean"], ["Boolean"]]
    }
  },
  "and": {
    fn: logic.andOp,
    arity: {
      2: [["Boolean"], ["Boolean"]]
    }
  },
  "xor": {
    fn: logic.xorOp,
    arity: {
      2: [["Boolean"], ["Boolean"]]
    }
  },
  "implies": {
    fn: logic.impliesOp,
    arity: {
      2: [["Boolean"], ["Boolean"]]
    }
  }
};
engine.InvocationExpression = function (ctx, parentData, node) {
  return node.children.reduce(function (acc, ch) {
    return engine.doEval(ctx, acc, ch);
  }, parentData);
};
engine.TermExpression = function (ctx, parentData, node) {
  if (parentData) {
    parentData = parentData.map(x => {
      if (x instanceof Object && x.resourceType) {
        return makeResNode(x, null, null, null, null, ctx.model);
      }
      return x;
    });
  }
  return engine.doEval(ctx, parentData, node.children[0]);
};
engine.PolarityExpression = function (ctx, parentData, node) {
  var sign = node.terminalNodeText[0]; // either - or + per grammar
  var rtn = engine.doEval(ctx, parentData, node.children[0]);
  if (rtn.length !== 1) {
    // not yet in spec, but per Bryn Rhodes
    throw new Error('Unary ' + sign + ' can only be applied to an individual number or Quantity.');
  }
  if (rtn[0] instanceof FP_Quantity) {
    if (sign === '-') {
      rtn[0] = new FP_Quantity(-rtn[0].value, rtn[0].unit);
    }
  } else if (typeof rtn[0] === 'number' && !isNaN(rtn[0])) {
    if (sign === '-') {
      rtn[0] = -rtn[0];
    }
  } else {
    throw new Error('Unary ' + sign + ' can only be applied to a number or Quantity.');
  }
  return rtn;
};
engine.TypeSpecifier = function (ctx, parentData, node) {
  let namespace, name;
  const identifiers = node.text.split('.').map(i => i.replace(/(^`|`$)/g, ""));
  switch (identifiers.length) {
    case 2:
      [namespace, name] = identifiers;
      break;
    case 1:
      [name] = identifiers;
      break;
    default:
      throw new Error("Expected TypeSpecifier node, got " + JSON.stringify(node));
  }
  const typeInfo = new TypeInfo({
    namespace,
    name
  });
  if (!typeInfo.isValid(ctx.model)) {
    throw new Error('"' + typeInfo + '" cannot be resolved to a valid type identifier');
  }
  return typeInfo;
};
engine.ExternalConstantTerm = function (ctx, parentData, node) {
  let varName;
  const extConstant = node.children[0];
  // externalConstant(variable name) is defined in the grammar as:
  // '%' ( identifier | STRING )
  if (extConstant.terminalNodeText.length === 2) {
    // if the variable name is a STRING
    varName = getStringLiteralVal(extConstant.terminalNodeText[1]);
  } else {
    // otherwise, it is an identifier
    varName = getIdentifierVal(extConstant.children[0].text);
  }
  let value;
  // Check the user-defined environment variables first as the user can override
  // the "context" variable like we do in unit tests. In this case, the user
  // environment variable can replace the system environment variable in "processedVars".
  // If the user-defined environment variable has been processed, we don't need to process it again.
  if (varName in ctx.vars && !ctx.processedUserVarNames.has(varName)) {
    // Restore the ResourceNodes for the top-level objects of the environment
    // variables. The nested objects will be converted to ResourceNodes
    // in the MemberInvocation method.
    value = ctx.vars[varName];
    if (Array.isArray(value)) {
      value = value.map(i => i?.__path__ ? makeResNode(i, i.__path__.parentResNode, i.__path__.path, null, i.__path__.fhirNodeDataType, i.__path__.model) : i?.resourceType ? makeResNode(i, null, null, null, null, ctx.model) : i);
    } else {
      value = value?.__path__ ? makeResNode(value, value.__path__.parentResNode, value.__path__.path, null, value.__path__.fhirNodeDataType, value.__path__.model) : value?.resourceType ? makeResNode(value, null, null, null, null, ctx.model) : value;
    }
    ctx.processedVars[varName] = value;
    ctx.processedUserVarNames.add(varName);
  } else if (varName in ctx.processedVars) {
    // "processedVars" are variables with ready-to-use values that have already
    // been converted to ResourceNodes if necessary.
    value = ctx.processedVars[varName];
  } else if (ctx.definedVars && varName in ctx.definedVars) {
    // "definedVars" are variables defined with the "defineVariable" function.
    value = ctx.definedVars[varName];
  } else {
    throw new Error("Attempting to access an undefined environment variable: " + varName);
  }
  // For convenience, all variable values could be passed in without their array
  // wrapper.  However, when evaluating, we need to put the array back in.
  return value === undefined || value === null ? [] : value instanceof Array ? value : [value];
};
engine.LiteralTerm = function (ctx, parentData, node) {
  var term = node.children[0];
  if (term) {
    return engine.doEval(ctx, parentData, term);
  } else {
    return [node.text];
  }
};
engine.StringLiteral = function (ctx, parentData, node) {
  return [getStringLiteralVal(node.text)];
};

/**
 * Removes the beginning and ending single-quotes and replaces string escape
 * sequences.
 * @param {string} str - string literal
 * @return {string}
 */
function getStringLiteralVal(str) {
  return str.replace(/(^'|'$)/g, "").replace(/\\(u\d{4}|.)/g, function (match, submatch) {
    switch (match) {
      case '\\r':
        return '\r';
      case '\\n':
        return "\n";
      case '\\t':
        return '\t';
      case '\\f':
        return '\f';
      default:
        if (submatch.length > 1) return String.fromCharCode('0x' + submatch.slice(1));else return submatch;
    }
  });
}
engine.BooleanLiteral = function (ctx, parentData, node) {
  if (node.text === "true") {
    return [true];
  } else {
    return [false];
  }
};
engine.QuantityLiteral = function (ctx, parentData, node) {
  var valueNode = node.children[0];
  var value = Number(valueNode.terminalNodeText[0]);
  var unitNode = valueNode.children[0];
  var unit = unitNode.terminalNodeText[0];
  // Sometimes the unit is in a child node of the child
  if (!unit && unitNode.children) unit = unitNode.children[0].terminalNodeText[0];
  return [new FP_Quantity(value, unit)];
};
engine.DateTimeLiteral = function (ctx, parentData, node) {
  var dateStr = node.text.slice(1); // Remove the @
  return [new FP_DateTime(dateStr)];
};
engine.TimeLiteral = function (ctx, parentData, node) {
  var timeStr = node.text.slice(1); // Remove the @
  return [new FP_Time(timeStr)];
};
engine.NumberLiteral = function (ctx, parentData, node) {
  return [Number(node.text)];
};
engine.Identifier = function (ctx, parentData, node) {
  return [getIdentifierVal(node.text)];
};

/**
 * Removes the beginning and ending back-quotes.
 * @param {string} str - identifier string
 * @return {string}
 */
function getIdentifierVal(str) {
  return str.replace(/(^`|`$)/g, "");
}
engine.InvocationTerm = function (ctx, parentData, node) {
  return engine.doEval(ctx, parentData, node.children[0]);
};
engine.MemberInvocation = function (ctx, parentData, node) {
  const key = engine.doEval(ctx, parentData, node.children[0])[0];
  const model = ctx.model;
  if (parentData) {
    return parentData.reduce(function (acc, res) {
      res = makeResNode(res, null, res.__path__?.path, null, res.__path__?.fhirNodeDataType, model);
      if (res.data?.resourceType === key) {
        acc.push(res);
      } else {
        util.pushFn(acc, util.makeChildResNodes(res, key, model));
      }
      return acc;
    }, []);
  } else {
    return [];
  }
};
engine.IndexerExpression = function (ctx, parentData, node) {
  const coll_node = node.children[0];
  const idx_node = node.children[1];
  var coll = engine.doEval(ctx, parentData, coll_node);
  var idx = engine.doEval(ctx, parentData, idx_node);
  if (util.isEmpty(idx)) {
    return [];
  }
  var idxNum = parseInt(idx[0]);
  if (coll && util.isSome(idxNum) && coll.length > idxNum && idxNum >= 0) {
    return [coll[idxNum]];
  } else {
    return [];
  }
};
engine.Functn = function (ctx, parentData, node) {
  return node.children.map(function (x) {
    return engine.doEval(ctx, parentData, x);
  });
};
engine.realizeParams = function (ctx, parentData, args) {
  if (args && args[0] && args[0].children) {
    return args[0].children.map(function (x) {
      return engine.doEval(ctx, parentData, x);
    });
  } else {
    return [];
  }
};
function makeParam(ctx, parentData, type, param) {
  if (type === "Expr") {
    return function (data) {
      const $this = util.arraify(data);
      let ctxExpr = {
        ...ctx,
        $this
      };
      if (ctx.definedVars) {
        // Each parameter subexpression needs its own set of defined variables
        // (cloned from the parent context). This way, the changes to the variables
        // are isolated in the subexpression.
        ctxExpr.definedVars = {
          ...ctx.definedVars
        };
      }
      return engine.doEval(ctxExpr, $this, param);
    };
  }
  if (type === "AnyAtRoot") {
    const $this = ctx.$this || ctx.dataRoot;
    let ctxExpr = {
      ...ctx,
      $this
    };
    if (ctx.definedVars) {
      // Each parameter subexpression needs its own set of defined variables
      // (cloned from the parent context). This way, the changes to the variables
      // are isolated in the subexpression.
      ctxExpr.definedVars = {
        ...ctx.definedVars
      };
    }
    return engine.doEval(ctxExpr, $this, param);
  }
  if (type === "Identifier") {
    if (param.type === "TermExpression") {
      return param.text;
    } else {
      throw new Error("Expected identifier node, got " + JSON.stringify(param));
    }
  }
  if (type === "TypeSpecifier") {
    return engine.TypeSpecifier(ctx, parentData, param);
  }
  let res;
  if (type === 'AnySingletonAtRoot') {
    const $this = ctx.$this || ctx.dataRoot;
    let ctxExpr = {
      ...ctx,
      $this
    };
    if (ctx.definedVars) {
      // Each parameter subexpression needs its own set of defined variables
      // (cloned from the parent context). This way, the changes to the variables
      // are isolated in the subexpression.
      ctxExpr.definedVars = {
        ...ctx.definedVars
      };
    }
    res = engine.doEval(ctxExpr, $this, param);
  } else {
    let ctxExpr = {
      ...ctx
    };
    if (ctx.definedVars) {
      // Each parameter subexpression needs its own set of defined variables
      // (cloned from the parent context). This way, the changes to the variables
      // are isolated in the subexpression.
      ctxExpr.definedVars = {
        ...ctx.definedVars
      };
    }
    res = engine.doEval(ctxExpr, parentData, param);
    if (type === "Any") {
      return res;
    }
    if (Array.isArray(type)) {
      if (res.length === 0) {
        return [];
      } else {
        type = type[0];
      }
    }
  }
  return res instanceof Promise ? res.then(r => misc.singleton(r, type)) : misc.singleton(res, type);
}
function doInvoke(ctx, fnName, data, rawParams) {
  var invoc = ctx.userInvocationTable && Object.prototype.hasOwnProperty.call(ctx.userInvocationTable, fnName) && ctx.userInvocationTable?.[fnName] || engine.invocationTable[fnName] || data.length === 1 && data[0]?.invocationTable?.[fnName];
  var res;
  if (invoc) {
    if (!invoc.arity) {
      if (!rawParams) {
        res = invoc.fn.call(ctx, data);
        return util.resolveAndArraify(res);
      } else {
        throw new Error(fnName + " expects no params");
      }
    } else {
      var paramsNumber = rawParams ? rawParams.length : 0;
      var argTypes = invoc.arity[paramsNumber];
      if (argTypes) {
        var params = [];
        for (var i = 0; i < paramsNumber; i++) {
          var tp = argTypes[i];
          var pr = rawParams[i];
          params.push(makeParam(ctx, data, tp, pr));
        }
        params.unshift(data);
        if (invoc.nullable) {
          if (params.some(isNullable)) {
            return [];
          }
        }
        if (params.some(p => p instanceof Promise)) {
          return Promise.all(params).then(p => {
            res = invoc.fn.apply(ctx, p);
            return util.resolveAndArraify(res);
          });
        }
        res = invoc.fn.apply(ctx, params);
        return util.resolveAndArraify(res);
      } else {
        console.log(fnName + " wrong arity: got " + paramsNumber);
        return [];
      }
    }
  } else {
    throw new Error("Not implemented: " + fnName);
  }
}
function isNullable(x) {
  return x === null || x === undefined || util.isEmpty(x);
}
function infixInvoke(ctx, fnName, data, rawParams) {
  var invoc = engine.invocationTable[fnName];
  if (invoc && invoc.fn) {
    var paramsNumber = rawParams ? rawParams.length : 0;
    if (paramsNumber !== 2) {
      throw new Error("Infix invoke should have arity 2");
    }
    var argTypes = invoc.arity[paramsNumber];
    if (argTypes) {
      var params = [];
      for (var i = 0; i < paramsNumber; i++) {
        var tp = argTypes[i];
        var pr = rawParams[i];
        params.push(makeParam(ctx, data, tp, pr));
      }
      if (invoc.nullable) {
        if (params.some(isNullable)) {
          return [];
        }
      }
      if (params.some(p => p instanceof Promise)) {
        return Promise.all(params).then(p => {
          var res = invoc.fn.apply(ctx, p);
          return util.arraify(res);
        });
      }
      var res = invoc.fn.apply(ctx, params);
      return util.arraify(res);
    } else {
      console.log(fnName + " wrong arity: got " + paramsNumber);
      return [];
    }
  } else {
    throw new Error("Not impl " + fnName);
  }
}
engine.FunctionInvocation = function (ctx, parentData, node) {
  var args = engine.doEval(ctx, parentData, node.children[0]);
  const fnName = args[0];
  args.shift();
  var rawParams = args && args[0] && args[0].children;
  return doInvoke(ctx, fnName, parentData, rawParams);
};
engine.ParamList = function (ctx, parentData, node) {
  // we do not eval param list because sometimes it should be passed as
  // lambda/macro (for example in case of where(...)
  return node;
};
engine.UnionExpression = function (ctx, parentData, node) {
  return infixInvoke(ctx, '|', parentData, node.children);
};
engine.ThisInvocation = function (ctx) {
  return ctx.$this;
};
engine.TotalInvocation = function (ctx) {
  return util.arraify(ctx.$total);
};
engine.IndexInvocation = function (ctx) {
  return util.arraify(ctx.$index);
};
engine.OpExpression = function (ctx, parentData, node) {
  var op = node.terminalNodeText[0];
  return infixInvoke(ctx, op, parentData, node.children);
};
engine.AliasOpExpression = function (map) {
  return function (ctx, parentData, node) {
    var op = node.terminalNodeText[0];
    var alias = map[op];
    if (!alias) {
      throw new Error("Do not know how to alias " + op + " by " + JSON.stringify(map));
    }
    return infixInvoke(ctx, alias, parentData, node.children);
  };
};
engine.NullLiteral = function () {
  return [];
};
engine.ParenthesizedTerm = function (ctx, parentData, node) {
  return engine.doEval(ctx, parentData, node.children[0]);
};
engine.evalTable = {
  // not every evaluator is listed if they are defined on engine
  BooleanLiteral: engine.BooleanLiteral,
  EqualityExpression: engine.OpExpression,
  FunctionInvocation: engine.FunctionInvocation,
  Functn: engine.Functn,
  Identifier: engine.Identifier,
  IndexerExpression: engine.IndexerExpression,
  InequalityExpression: engine.OpExpression,
  InvocationExpression: engine.InvocationExpression,
  AdditiveExpression: engine.OpExpression,
  MultiplicativeExpression: engine.OpExpression,
  TypeExpression: engine.AliasOpExpression({
    "is": "isOp",
    "as": "asOp"
  }),
  MembershipExpression: engine.AliasOpExpression({
    "contains": "containsOp",
    "in": "inOp"
  }),
  NullLiteral: engine.NullLiteral,
  EntireExpression: engine.InvocationTerm,
  InvocationTerm: engine.InvocationTerm,
  LiteralTerm: engine.LiteralTerm,
  MemberInvocation: engine.MemberInvocation,
  NumberLiteral: engine.NumberLiteral,
  ParamList: engine.ParamList,
  ParenthesizedTerm: engine.ParenthesizedTerm,
  StringLiteral: engine.StringLiteral,
  TermExpression: engine.TermExpression,
  ThisInvocation: engine.ThisInvocation,
  TotalInvocation: engine.TotalInvocation,
  IndexInvocation: engine.IndexInvocation,
  UnionExpression: engine.UnionExpression,
  OrExpression: engine.OpExpression,
  ImpliesExpression: engine.OpExpression,
  AndExpression: engine.OpExpression,
  XorExpression: engine.OpExpression
};
engine.doEval = function (ctx, parentData, node) {
  if (parentData instanceof Promise) {
    return parentData.then(p => engine.doEvalSync(ctx, p, node));
  } else {
    return engine.doEvalSync(ctx, parentData, node);
  }
};
engine.doEvalSync = function (ctx, parentData, node) {
  const evaluator = engine.evalTable[node.type] || engine[node.type];
  if (evaluator) {
    return evaluator.call(engine, ctx, parentData, node);
  } else {
    throw new Error("No " + node.type + " evaluator ");
  }
};
function parse(path) {
  return parser.parse(path);
}

/**
 *  Applies the given parsed FHIRPath expression to the given resource,
 *  returning the result of doEval.
 * @param {(object|object[])} resource -  FHIR resource, bundle as js object or array of resources
 *  This resource will be modified by this function to add type information.
 * @param {object} parsedPath - a special object created by the parser that describes the structure of a fhirpath expression.
 * @param {object} envVars - a hash of variable name/value pairs.
 * @param {object} model - The "model" data object specific to a domain, e.g. R4.
 *  For example, you could pass in the result of require("fhirpath/fhir-context/r4");
 * @param {object} options - additional options:
 * @param {boolean} [options.resolveInternalTypes] - whether values of internal
 *  types should be converted to strings, true by default.
 * @param {function} [options.traceFn] - An optional trace function to call when tracing.
 * @param {object} [options.userInvocationTable] - a user invocation table used
 *  to replace any existing or define new functions.
 * @param {boolean|string} [options.async] - defines how to support asynchronous functions:
 *  false or similar to false, e.g. undefined, null, or 0 (default) - throw an exception;
 *  true or similar to true - return Promise only for asynchronous functions;
 *  "always" - return Promise always.
 * @param {string} [options.terminologyUrl] - a URL that points to a FHIR
 *   RESTful API that is used to create %terminologies that implements
 *   the Terminology Service API.
 * @param {AbortSignal} [options.signal] - an AbortSignal object that allows you
 *   to abort the asynchronous FHIRPath expression evaluation.
 */
function applyParsedPath(resource, parsedPath, envVars, model, options) {
  constants.reset();
  let dataRoot = util.arraify(resource).map(i => i?.__path__ ? makeResNode(i, i.__path__.parentResNode, i.__path__.path, null, i.__path__.fhirNodeDataType, model) : i?.resourceType ? makeResNode(i, null, null, null, null, model) : i);
  // doEval takes a "ctx" object, and we store things in that as we parse, so we
  // need to put user-provided variable data in a sub-object, ctx.vars.
  // Set up default standard variables, and allow override from the variables.
  // However, we'll keep our own copy of dataRoot for internal processing.
  let ctx = {
    dataRoot,
    processedVars: {
      ucum: 'http://unitsofmeasure.org',
      context: dataRoot
    },
    processedUserVarNames: new Set(),
    vars: envVars || {},
    model
  };
  if (options.traceFn) {
    ctx.customTraceFn = options.traceFn;
  }
  if (options.userInvocationTable) {
    ctx.userInvocationTable = options.userInvocationTable;
  }
  if (options.async) {
    ctx.async = options.async;
  }
  if (options.terminologyUrl) {
    ctx.processedVars.terminologies = new Terminologies(options.terminologyUrl);
  }
  ctx.processedVars.factory = Factory;
  if (options.signal) {
    ctx.signal = options.signal;
    if (!ctx.async) {
      throw new Error('The "signal" option is only supported for asynchronous functions.');
    }
    if (ctx.signal.aborted) {
      throw new Error('Evaluation of the expression was aborted before it started.');
    }
  }
  const res = engine.doEval(ctx, dataRoot, parsedPath.children[0]);
  return res instanceof Promise ? res.then(r => {
    if (ctx.signal?.aborted) {
      return Promise.reject(new DOMException('Evaluation of the expression was aborted.', 'AbortError'));
    } else {
      return prepareEvalResult(r, model, options);
    }
  }) : options.async === 'always' ? Promise.resolve(prepareEvalResult(res, model, options)) : prepareEvalResult(res, model, options);
}

/**
 * Prepares the result after evaluating an expression.
 * engine.doEval returns array of "ResourceNode" and/or "FP_Type" instances.
 * "ResourceNode" or "FP_Type" instances are not created for sub-items.
 * Resolves any internal "ResourceNode" instances to plain objects and if
 * options.resolveInternalTypes is true, resolve any internal "FP_Type"
 * instances to strings.
 * @param {Array} result - result of expression evaluation.
 * @param {object} model - The "model" data object specific to a domain, e.g. R4.
 * @param {object} options - additional options (see function "applyParsedPath").
 * @return {Array}
 */
function prepareEvalResult(result, model, options) {
  return result.reduce((acc, n) => {
    // Path for the data extracted from the resource.
    let path;
    let fhirNodeDataType;
    let parentResNode;
    if (n instanceof ResourceNode) {
      path = n.path;
      fhirNodeDataType = n.fhirNodeDataType;
      parentResNode = n.parentResNode;
    }
    n = util.valData(n);
    if (n instanceof FP_Type) {
      if (options.resolveInternalTypes) {
        n = n.toString();
      }
    }
    // Exclude nulls
    if (n != null) {
      // Add a hidden (non-enumerable) property with the path to the data extracted
      // from the resource.
      if (path && typeof n === 'object' && !n.__path__) {
        Object.defineProperty(n, '__path__', {
          value: {
            path,
            fhirNodeDataType,
            parentResNode,
            model
          }
        });
      }
      acc.push(n);
    }
    return acc;
  }, []);
}

/**
 * Resolves any internal "FP_Type" instances in a result of FHIRPath expression
 * evaluation to standard JavaScript types.
 * @param {any} val - a result of FHIRPath expression evaluation
 * @returns {any} a new object with resolved values.
 */
function resolveInternalTypes(val) {
  if (Array.isArray(val)) {
    for (let i = 0, len = val.length; i < len; ++i) val[i] = resolveInternalTypes(val[i]);
  } else if (val instanceof FP_Type) {
    val = val.toString();
  } else if (typeof val === 'object') {
    for (let k of Object.keys(val)) val[k] = resolveInternalTypes(val[k]);
  }
  return val;
}

/**
 *  Evaluates the "path" FHIRPath expression on the given resource or part of the resource,
 *  using data from "context" for variables mentioned in the "path" expression.
 * @param {(object|object[])} fhirData -  FHIR resource, part of a resource (in this case
 *  path.base should be provided), bundle as js object or array of resources.
 *  This object/array will be modified by this function to add type information.
 * @param {string|object} path - string with FHIRPath expression, sample 'Patient.name.given',
 *  or object, if fhirData represents the part of the FHIR resource:
 * @param {string} path.base - base path in resource from which fhirData was extracted
 * @param {string} path.expression - FHIRPath expression relative to path.base
 * @param {object} [envVars] - a hash of variable name/value pairs.
 * @param {object} [model] - The "model" data object specific to a domain, e.g. R4.
 *  For example, you could pass in the result of require("fhirpath/fhir-context/r4");
 * @param {object} [options] - additional options:
 * @param {boolean} [options.resolveInternalTypes] - whether values of internal
 *  types should be converted to standard JavaScript types (true by default).
 *  If false is passed, this conversion can be done later by calling
 *  resolveInternalTypes().
 * @param {function} [options.traceFn] - An optional trace function to call when tracing.
 * @param {object} [options.userInvocationTable] - a user invocation table used
 *  to replace any existing or define new functions.
 * @param {boolean|string} [options.async] - defines how to support asynchronous functions:
 *  false or similar to false, e.g. undefined, null, or 0 (default) - throw an exception,
 *  true or similar to true - return Promise, only for asynchronous functions,
 *  "always" - return Promise always.
 * @param {string} [options.terminologyUrl] - a URL that points to a FHIR
 *   RESTful API that is used to create %terminologies that implements
 *   the Terminology Service API.
 * @param {AbortSignal} [options.signal] - an AbortSignal object that allows you
 *   to abort the asynchronous FHIRPath expression evaluation.
 */
function evaluate(fhirData, path, envVars, model, options) {
  return compile(path, model, options)(fhirData, envVars);
}

/**
 *  Returns a function that takes a resource or part of the resource and an
 *  optional context hash (see "evaluate"), and returns the result of evaluating
 *  the given FHIRPath expression on that resource.  The advantage of this
 *  function over "evaluate" is that if you have multiple resources, the given
 *  FHIRPath expression will only be parsed once.
 * @param {string|object} path - string with FHIRPath expression to be parsed or object:
 * @param {string} path.base - base path in resource from which a part of
 *   the resource was extracted
 * @param {string} path.expression - FHIRPath expression relative to path.base
 * @param {object} [model] - The "model" data object specific to a domain, e.g. R4.
 *  For example, you could pass in the result of require("fhirpath/fhir-context/r4");
 * @param {object} [options] - additional options:
 * @param {boolean} [options.resolveInternalTypes] - whether values of internal
 *  types should be converted to strings, true by default.
 * @param {function} [options.traceFn] - An optional trace function to call when tracing.
 * @param {object} [options.userInvocationTable] - a user invocation table used
 *  to replace any existing or define new functions.
 * @param {boolean|string} [options.async] - defines how to support asynchronous functions:
 *  false or similar to false, e.g. undefined, null, or 0 (default) - throw an exception,
 *  true or similar to true - return Promise, only for asynchronous functions,
 *  "always" - return Promise always.
 * @param {string} [options.terminologyUrl] - a URL that points to a FHIR
 *   RESTful API that is used to create %terminologies that implements
 *   the Terminology Service API.
 * @param {AbortSignal} [options.signal] - an AbortSignal object that allows you
 *   to abort the asynchronous FHIRPath expression evaluation. Passing a signal
 *   to compile() whose result is used more than once will cause abortion
 *   problems.
 */
function compile(path, model, options) {
  options = {
    resolveInternalTypes: true,
    ...options
  };
  const userInvocationTable = options.userInvocationTable;
  if (userInvocationTable) {
    options.userInvocationTable = Object.keys(userInvocationTable).reduce((invocationTable, fnName) => {
      if (userInvocationTable[fnName].internalStructures) {
        invocationTable[fnName] = userInvocationTable[fnName];
      } else {
        invocationTable[fnName] = {
          ...userInvocationTable[fnName],
          fn: (...args) => {
            return userInvocationTable[fnName].fn.apply(
            // When we check Array.isArray(arg), we are checking if the
            // singleton function has been called. An alternative to this is
            // to check that the type of the argument is Integer, Boolean,
            // Number, or String.
            this, args.map(arg => Array.isArray(arg) ? arg.map(item => util.valData(item)) : arg));
          }
        };
      }
      return invocationTable;
    }, {});
  }
  if (typeof path === 'object') {
    const node = parse(path.expression);
    return function (fhirData, envVars, additionalOptions) {
      if (path.base) {
        let basePath = model.pathsDefinedElsewhere[path.base] || path.base;
        const baseFhirNodeDataType = model && model.path2Type[basePath];
        basePath = baseFhirNodeDataType === 'BackboneElement' || baseFhirNodeDataType === 'Element' ? basePath : baseFhirNodeDataType || basePath;
        fhirData = makeResNode(fhirData, null, basePath, null, baseFhirNodeDataType, model);
      }
      const actualOptions = additionalOptions ? {
        ...options,
        ...additionalOptions
      } : options;
      return applyParsedPath(fhirData, node, envVars, model, actualOptions);
    };
  } else {
    const node = parse(path);
    return function (fhirData, envVars, additionalOptions) {
      const actualOptions = additionalOptions ? {
        ...options,
        ...additionalOptions
      } : options;
      return applyParsedPath(fhirData, node, envVars, model, actualOptions);
    };
  }
}

/**
 * Returns the type of each element in fhirpathResult array which was obtained
 * from evaluate() with option resolveInternalTypes=false.
 * @param {any} fhirpathResult - a result of FHIRPath expression evaluation.
 * @returns {string[]} an array of types, e.g. ['FHIR.Quantity', 'FHIR.date', 'System.String'].
 */
function typesFn(fhirpathResult) {
  return util.arraify(fhirpathResult).map(value => {
    const ti = TypeInfo.fromValue(value?.__path__ ? new ResourceNode(value, value.__path__?.parentResNode, value.__path__?.path, null, value.__path__?.fhirNodeDataType, value.__path__.model) : value);
    return `${ti.namespace}.${ti.name}`;
  });
}
module.exports = {
  version,
  parse,
  compile,
  evaluate,
  resolveInternalTypes,
  types: typesFn,
  // Might as well export the UCUM library, since we are using it.
  ucumUtils: (__webpack_require__(60).UcumLhcUtils).getInstance(),
  // Utility functions that can be used to implement custom functions
  util
};

/***/ }),
/* 3 */
/***/ (function(module) {

"use strict";
module.exports = /*#__PURE__*/JSON.parse('{"name":"fhirpath","version":"3.18.0","description":"A FHIRPath engine","main":"src/fhirpath.js","types":"src/fhirpath.d.ts","dependencies":{"@lhncbc/ucum-lhc":"^5.0.0","antlr4":"~4.9.3","commander":"^2.18.0","date-fns":"^1.30.1","js-yaml":"^3.13.1"},"devDependencies":{"@babel/core":"^7.21.4","@babel/eslint-parser":"^7.17.0","@babel/preset-env":"^7.16.11","babel-loader":"^8.2.3","benny":"github:caderek/benny#0ad058d3c7ef0b488a8fe9ae3519159fc7f36bb6","bestzip":"^2.2.0","copy-webpack-plugin":"^12.0.2","cypress":"^13.7.2","eslint":"^8.10.0","fhir":"^4.10.3","grunt":"^1.5.2","grunt-cli":"^1.4.3","grunt-text-replace":"^0.4.0","jasmine-spec-reporter":"^4.2.1","jest":"^29.7.0","jit-grunt":"^0.10.0","lodash":"^4.17.21","open":"^8.4.0","rimraf":"^3.0.0","tmp":"0.0.33","tsd":"^0.31.1","webpack":"^5.11.1","webpack-bundle-analyzer":"^4.4.2","webpack-cli":"^4.9.1","xml2js":"^0.5.0","yargs":"^15.1.0"},"engines":{"node":">=8.9.0"},"tsd":{"directory":"test/typescript"},"scripts":{"preinstall":"node bin/install-demo.js","postinstall":"echo \\"Building the Benny package based on a pull request which fixes an issue with \'statusShift\'... \\" && (cd node_modules/benny && npm i && npm run build > /dev/null) || echo \\"Building the Benny package is completed.\\"","generateParser":"cd src/parser; rimraf ./generated/*; java -Xmx500M -cp \\"../../antlr-4.9.3-complete.jar:$CLASSPATH\\" org.antlr.v4.Tool -o generated -Dlanguage=JavaScript FHIRPath.g4; grunt updateParserRequirements","build":"cd browser-build && webpack && rimraf fhirpath.zip && bestzip fhirpath.zip LICENSE.md fhirpath.min.js fhirpath.r5.min.js fhirpath.r4.min.js fhirpath.stu3.min.js fhirpath.dstu2.min.js && rimraf  LICENSE.md","test:unit":"node --use_strict node_modules/.bin/jest && TZ=America/New_York node --use_strict node_modules/.bin/jest && TZ=Europe/Paris node --use_strict node_modules/.bin/jest","test:unit:debug":"echo \'open chrome chrome://inspect/\' && node --inspect node_modules/.bin/jest --runInBand","build:demo":"npm run build && cd demo && npm run build","test:e2e":"npm run build:demo && cypress run","test:tsd":"tsd","test":"npm run lint && npm run test:tsd && npm run test:unit && npm run test:e2e && echo \\"For tests specific to IE 11, open browser-build/test/index.html in IE 11, and confirm that the tests on that page pass.\\"","lint":"eslint src/parser/index.js src/*.js converter/","compare-performance":"node ./test/benchmark.js"},"bin":{"fhirpath":"bin/fhirpath"},"files":["CHANGELOG.md","bin","fhir-context","src"],"repository":"github:HL7/fhirpath.js","license":"SEE LICENSE in LICENSE.md"}');

/***/ }),
/* 4 */
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

const antlr4 = __webpack_require__(5);
const Lexer = __webpack_require__(50);
const Parser = __webpack_require__(51);
const Listener = __webpack_require__(52);
class ErrorListener extends antlr4.error.ErrorListener {
  constructor(errors) {
    super();
    this.errors = errors;
  }
  syntaxError(rec, sym, line, col, msg, e) {
    this.errors.push([rec, sym, line, col, msg, e]);
  }
}
var parse = function (path) {
  var chars = new antlr4.InputStream(path);
  var lexer = new Lexer(chars);
  var tokens = new antlr4.CommonTokenStream(lexer);
  var parser = new Parser(tokens);
  parser.buildParseTrees = true;
  var errors = [];
  var listener = new ErrorListener(errors);
  lexer.removeErrorListeners();
  lexer.addErrorListener(listener);
  parser.removeErrorListeners();
  parser.addErrorListener(listener);
  var tree = parser.entireExpression();
  class PathListener extends Listener {
    constructor() {
      super();
    }
  }
  var ast = {};
  var node;
  var parentStack = [ast];
  for (let p of Object.getOwnPropertyNames(Listener.prototype)) {
    if (p.startsWith("enter")) {
      PathListener.prototype[p] = function (ctx) {
        let parentNode = parentStack[parentStack.length - 1];
        let nodeType = p.slice(5); // remove "enter"
        node = {
          type: nodeType
        };
        node.text = ctx.getText();
        if (!parentNode.children) parentNode.children = [];
        parentNode.children.push(node);
        parentStack.push(node);
        // Also collect this node's terminal nodes, if any.  Terminal nodes are
        // not walked with the rest of the tree, but include things like "+" and
        // "-", which we need.
        node.terminalNodeText = [];
        for (let c of ctx.children) {
          // Test for node type "TerminalNodeImpl".  Minimized code no longer
          // has the original function names, so we can't rely on
          // c.constructor.name.  It appears the TerminalNodeImpl is the only
          // node with a "symbol" property, so test for that.
          if (c.symbol) node.terminalNodeText.push(c.getText());
        }
      };
    } else if (p.startsWith("exit")) {
      PathListener.prototype[p] = function () {
        parentStack.pop();
      };
    }
  }
  var printer = new PathListener();
  antlr4.tree.ParseTreeWalker.DEFAULT.walk(printer, tree);
  if (errors.length > 0) {
    let errMsgs = [];
    for (let i = 0, len = errors.length; i < len; ++i) {
      let err = errors[i];
      let msg = "line: " + err[2] + "; column: " + err[3] + "; message: " + err[4];
      errMsgs.push(msg);
    }
    var e = new Error(errMsgs.join("\n"));
    e.errors = errors;
    throw e;
  }
  return ast;
};
module.exports = {
  parse: parse
};

/***/ }),
/* 5 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

// This is a modified version of antr4's index.js, in which
// the "require" statements of two unused classes are commented out
// to avoid introducing a dependency on Node.js' "fs" package.

/* Copyright (c) 2012-2017 The ANTLR Project. All rights reserved.
 * Use of this file is governed by the BSD 3-clause license that
 * can be found in the LICENSE.txt file in the project root.
 */
exports.atn = __webpack_require__(6);
exports.codepointat = __webpack_require__(37);
exports.dfa = __webpack_require__(38);
exports.fromcodepoint = __webpack_require__(41);
exports.tree = __webpack_require__(42);
exports.error = __webpack_require__(43);
exports.Token = __webpack_require__(10).Token;
// Commented out to avoid the problem with 'fs' during the webpack build
// exports.CharStreams = require('antlr4/src/antlr4/CharStreams');
exports.CommonToken = __webpack_require__(10).CommonToken;
exports.InputStream = __webpack_require__(46);
// Commented out to avoid the problem with 'fs' during the webpack build
// exports.FileStream = require('antlr4/src/antlr4/FileStream');
exports.CommonTokenStream = __webpack_require__(47);
exports.Lexer = __webpack_require__(25);
exports.Parser = __webpack_require__(49);
var pc = __webpack_require__(16);
exports.PredictionContextCache = pc.PredictionContextCache;
exports.ParserRuleContext = __webpack_require__(36);
exports.Interval = __webpack_require__(14).Interval;
exports.IntervalSet = __webpack_require__(14).IntervalSet;
exports.Utils = __webpack_require__(9);
exports.LL1Analyzer = __webpack_require__(8).LL1Analyzer;

/***/ }),
/* 6 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

/* Copyright (c) 2012-2017 The ANTLR Project. All rights reserved.
 * Use of this file is governed by the BSD 3-clause license that
 * can be found in the LICENSE.txt file in the project root.
 */

exports.ATN = __webpack_require__(7);
exports.ATNDeserializer = __webpack_require__(20);
exports.LexerATNSimulator = __webpack_require__(24);
exports.ParserATNSimulator = __webpack_require__(34);
exports.PredictionMode = __webpack_require__(35);

/***/ }),
/* 7 */
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

/* Copyright (c) 2012-2017 The ANTLR Project. All rights reserved.
 * Use of this file is governed by the BSD 3-clause license that
 * can be found in the LICENSE.txt file in the project root.
 */

const LL1Analyzer = __webpack_require__(8);
const {
  IntervalSet
} = __webpack_require__(14);
const {
  Token
} = __webpack_require__(10);
class ATN {
  constructor(grammarType, maxTokenType) {
    /**
     * Used for runtime deserialization of ATNs from strings
     * The type of the ATN.
    */
    this.grammarType = grammarType;
    // The maximum value for any symbol recognized by a transition in the ATN.
    this.maxTokenType = maxTokenType;
    this.states = [];
    /**
     * Each subrule/rule is a decision point and we must track them so we
     * can go back later and build DFA predictors for them.  This includes
     * all the rules, subrules, optional blocks, ()+, ()* etc...
     */
    this.decisionToState = [];
    // Maps from rule index to starting state number.
    this.ruleToStartState = [];
    // Maps from rule index to stop state number.
    this.ruleToStopState = null;
    this.modeNameToStartState = {};
    /**
     * For lexer ATNs, this maps the rule index to the resulting token type.
     * For parser ATNs, this maps the rule index to the generated bypass token
     * type if the {@link ATNDeserializationOptions//isGenerateRuleBypassTransitions}
     * deserialization option was specified; otherwise, this is {@code null}
     */
    this.ruleToTokenType = null;
    /**
     * For lexer ATNs, this is an array of {@link LexerAction} objects which may
     * be referenced by action transitions in the ATN
     */
    this.lexerActions = null;
    this.modeToStartState = [];
  }

  /**
   * Compute the set of valid tokens that can occur starting in state {@code s}.
   * If {@code ctx} is null, the set of tokens will not include what can follow
   * the rule surrounding {@code s}. In other words, the set will be
   * restricted to tokens reachable staying within {@code s}'s rule
   */
  nextTokensInContext(s, ctx) {
    const anal = new LL1Analyzer(this);
    return anal.LOOK(s, null, ctx);
  }

  /**
   * Compute the set of valid tokens that can occur starting in {@code s} and
   * staying in same rule. {@link Token//EPSILON} is in set if we reach end of
   * rule
   */
  nextTokensNoContext(s) {
    if (s.nextTokenWithinRule !== null) {
      return s.nextTokenWithinRule;
    }
    s.nextTokenWithinRule = this.nextTokensInContext(s, null);
    s.nextTokenWithinRule.readOnly = true;
    return s.nextTokenWithinRule;
  }
  nextTokens(s, ctx) {
    if (ctx === undefined) {
      return this.nextTokensNoContext(s);
    } else {
      return this.nextTokensInContext(s, ctx);
    }
  }
  addState(state) {
    if (state !== null) {
      state.atn = this;
      state.stateNumber = this.states.length;
    }
    this.states.push(state);
  }
  removeState(state) {
    this.states[state.stateNumber] = null; // just free mem, don't shift states in list
  }
  defineDecisionState(s) {
    this.decisionToState.push(s);
    s.decision = this.decisionToState.length - 1;
    return s.decision;
  }
  getDecisionState(decision) {
    if (this.decisionToState.length === 0) {
      return null;
    } else {
      return this.decisionToState[decision];
    }
  }

  /**
   * Computes the set of input symbols which could follow ATN state number
   * {@code stateNumber} in the specified full {@code context}. This method
   * considers the complete parser context, but does not evaluate semantic
   * predicates (i.e. all predicates encountered during the calculation are
   * assumed true). If a path in the ATN exists from the starting state to the
   * {@link RuleStopState} of the outermost context without matching any
   * symbols, {@link Token//EOF} is added to the returned set.
   *
   * <p>If {@code context} is {@code null}, it is treated as
   * {@link ParserRuleContext//EMPTY}.</p>
   *
   * @param stateNumber the ATN state number
   * @param ctx the full parse context
   *
   * @return {IntervalSet} The set of potentially valid input symbols which could follow the
   * specified state in the specified context.
   *
   * @throws IllegalArgumentException if the ATN does not contain a state with
   * number {@code stateNumber}
   */
  getExpectedTokens(stateNumber, ctx) {
    if (stateNumber < 0 || stateNumber >= this.states.length) {
      throw "Invalid state number.";
    }
    const s = this.states[stateNumber];
    let following = this.nextTokens(s);
    if (!following.contains(Token.EPSILON)) {
      return following;
    }
    const expected = new IntervalSet();
    expected.addSet(following);
    expected.removeOne(Token.EPSILON);
    while (ctx !== null && ctx.invokingState >= 0 && following.contains(Token.EPSILON)) {
      const invokingState = this.states[ctx.invokingState];
      const rt = invokingState.transitions[0];
      following = this.nextTokens(rt.followState);
      expected.addSet(following);
      expected.removeOne(Token.EPSILON);
      ctx = ctx.parentCtx;
    }
    if (following.contains(Token.EPSILON)) {
      expected.addOne(Token.EOF);
    }
    return expected;
  }
}
ATN.INVALID_ALT_NUMBER = 0;
module.exports = ATN;

/***/ }),
/* 8 */
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

/* Copyright (c) 2012-2017 The ANTLR Project. All rights reserved.
 * Use of this file is governed by the BSD 3-clause license that
 * can be found in the LICENSE.txt file in the project root.
 */

const {
  Set,
  BitSet
} = __webpack_require__(9);
const {
  Token
} = __webpack_require__(10);
const {
  ATNConfig
} = __webpack_require__(11);
const {
  IntervalSet
} = __webpack_require__(14);
const {
  RuleStopState
} = __webpack_require__(12);
const {
  RuleTransition,
  NotSetTransition,
  WildcardTransition,
  AbstractPredicateTransition
} = __webpack_require__(15);
const {
  predictionContextFromRuleContext,
  PredictionContext,
  SingletonPredictionContext
} = __webpack_require__(16);
class LL1Analyzer {
  constructor(atn) {
    this.atn = atn;
  }

  /**
   * Calculates the SLL(1) expected lookahead set for each outgoing transition
   * of an {@link ATNState}. The returned array has one element for each
   * outgoing transition in {@code s}. If the closure from transition
   * <em>i</em> leads to a semantic predicate before matching a symbol, the
   * element at index <em>i</em> of the result will be {@code null}.
   *
   * @param s the ATN state
   * @return the expected symbols for each outgoing transition of {@code s}.
   */
  getDecisionLookahead(s) {
    if (s === null) {
      return null;
    }
    const count = s.transitions.length;
    const look = [];
    for (let alt = 0; alt < count; alt++) {
      look[alt] = new IntervalSet();
      const lookBusy = new Set();
      const seeThruPreds = false; // fail to get lookahead upon pred
      this._LOOK(s.transition(alt).target, null, PredictionContext.EMPTY, look[alt], lookBusy, new BitSet(), seeThruPreds, false);
      // Wipe out lookahead for this alternative if we found nothing
      // or we had a predicate when we !seeThruPreds
      if (look[alt].length === 0 || look[alt].contains(LL1Analyzer.HIT_PRED)) {
        look[alt] = null;
      }
    }
    return look;
  }

  /**
   * Compute set of tokens that can follow {@code s} in the ATN in the
   * specified {@code ctx}.
   *
   * <p>If {@code ctx} is {@code null} and the end of the rule containing
   * {@code s} is reached, {@link Token//EPSILON} is added to the result set.
   * If {@code ctx} is not {@code null} and the end of the outermost rule is
   * reached, {@link Token//EOF} is added to the result set.</p>
   *
   * @param s the ATN state
   * @param stopState the ATN state to stop at. This can be a
   * {@link BlockEndState} to detect epsilon paths through a closure.
   * @param ctx the complete parser context, or {@code null} if the context
   * should be ignored
   *
   * @return The set of tokens that can follow {@code s} in the ATN in the
   * specified {@code ctx}.
   */
  LOOK(s, stopState, ctx) {
    const r = new IntervalSet();
    const seeThruPreds = true; // ignore preds; get all lookahead
    ctx = ctx || null;
    const lookContext = ctx !== null ? predictionContextFromRuleContext(s.atn, ctx) : null;
    this._LOOK(s, stopState, lookContext, r, new Set(), new BitSet(), seeThruPreds, true);
    return r;
  }

  /**
   * Compute set of tokens that can follow {@code s} in the ATN in the
   * specified {@code ctx}.
   *
   * <p>If {@code ctx} is {@code null} and {@code stopState} or the end of the
   * rule containing {@code s} is reached, {@link Token//EPSILON} is added to
   * the result set. If {@code ctx} is not {@code null} and {@code addEOF} is
   * {@code true} and {@code stopState} or the end of the outermost rule is
   * reached, {@link Token//EOF} is added to the result set.</p>
   *
   * @param s the ATN state.
   * @param stopState the ATN state to stop at. This can be a
   * {@link BlockEndState} to detect epsilon paths through a closure.
   * @param ctx The outer context, or {@code null} if the outer context should
   * not be used.
   * @param look The result lookahead set.
   * @param lookBusy A set used for preventing epsilon closures in the ATN
   * from causing a stack overflow. Outside code should pass
   * {@code new Set<ATNConfig>} for this argument.
   * @param calledRuleStack A set used for preventing left recursion in the
   * ATN from causing a stack overflow. Outside code should pass
   * {@code new BitSet()} for this argument.
   * @param seeThruPreds {@code true} to true semantic predicates as
   * implicitly {@code true} and "see through them", otherwise {@code false}
   * to treat semantic predicates as opaque and add {@link //HIT_PRED} to the
   * result if one is encountered.
   * @param addEOF Add {@link Token//EOF} to the result if the end of the
   * outermost context is reached. This parameter has no effect if {@code ctx}
   * is {@code null}.
   */
  _LOOK(s, stopState, ctx, look, lookBusy, calledRuleStack, seeThruPreds, addEOF) {
    const c = new ATNConfig({
      state: s,
      alt: 0,
      context: ctx
    }, null);
    if (lookBusy.contains(c)) {
      return;
    }
    lookBusy.add(c);
    if (s === stopState) {
      if (ctx === null) {
        look.addOne(Token.EPSILON);
        return;
      } else if (ctx.isEmpty() && addEOF) {
        look.addOne(Token.EOF);
        return;
      }
    }
    if (s instanceof RuleStopState) {
      if (ctx === null) {
        look.addOne(Token.EPSILON);
        return;
      } else if (ctx.isEmpty() && addEOF) {
        look.addOne(Token.EOF);
        return;
      }
      if (ctx !== PredictionContext.EMPTY) {
        const removed = calledRuleStack.contains(s.ruleIndex);
        try {
          calledRuleStack.remove(s.ruleIndex);
          // run thru all possible stack tops in ctx
          for (let i = 0; i < ctx.length; i++) {
            const returnState = this.atn.states[ctx.getReturnState(i)];
            this._LOOK(returnState, stopState, ctx.getParent(i), look, lookBusy, calledRuleStack, seeThruPreds, addEOF);
          }
        } finally {
          if (removed) {
            calledRuleStack.add(s.ruleIndex);
          }
        }
        return;
      }
    }
    for (let j = 0; j < s.transitions.length; j++) {
      const t = s.transitions[j];
      if (t.constructor === RuleTransition) {
        if (calledRuleStack.contains(t.target.ruleIndex)) {
          continue;
        }
        const newContext = SingletonPredictionContext.create(ctx, t.followState.stateNumber);
        try {
          calledRuleStack.add(t.target.ruleIndex);
          this._LOOK(t.target, stopState, newContext, look, lookBusy, calledRuleStack, seeThruPreds, addEOF);
        } finally {
          calledRuleStack.remove(t.target.ruleIndex);
        }
      } else if (t instanceof AbstractPredicateTransition) {
        if (seeThruPreds) {
          this._LOOK(t.target, stopState, ctx, look, lookBusy, calledRuleStack, seeThruPreds, addEOF);
        } else {
          look.addOne(LL1Analyzer.HIT_PRED);
        }
      } else if (t.isEpsilon) {
        this._LOOK(t.target, stopState, ctx, look, lookBusy, calledRuleStack, seeThruPreds, addEOF);
      } else if (t.constructor === WildcardTransition) {
        look.addRange(Token.MIN_USER_TOKEN_TYPE, this.atn.maxTokenType);
      } else {
        let set = t.label;
        if (set !== null) {
          if (t instanceof NotSetTransition) {
            set = set.complement(Token.MIN_USER_TOKEN_TYPE, this.atn.maxTokenType);
          }
          look.addSet(set);
        }
      }
    }
  }
}

/**
 * Special value added to the lookahead sets to indicate that we hit
 * a predicate during analysis if {@code seeThruPreds==false}.
 */
LL1Analyzer.HIT_PRED = Token.INVALID_TYPE;
module.exports = LL1Analyzer;

/***/ }),
/* 9 */
/***/ (function(module) {

/* Copyright (c) 2012-2017 The ANTLR Project. All rights reserved.
 * Use of this file is governed by the BSD 3-clause license that
 * can be found in the LICENSE.txt file in the project root.
 */

function valueToString(v) {
  return v === null ? "null" : v;
}
function arrayToString(a) {
  return Array.isArray(a) ? "[" + a.map(valueToString).join(", ") + "]" : "null";
}
String.prototype.seed = String.prototype.seed || Math.round(Math.random() * Math.pow(2, 32));
String.prototype.hashCode = function () {
  const key = this.toString();
  let h1b, k1;
  const remainder = key.length & 3; // key.length % 4
  const bytes = key.length - remainder;
  let h1 = String.prototype.seed;
  const c1 = 0xcc9e2d51;
  const c2 = 0x1b873593;
  let i = 0;
  while (i < bytes) {
    k1 = key.charCodeAt(i) & 0xff | (key.charCodeAt(++i) & 0xff) << 8 | (key.charCodeAt(++i) & 0xff) << 16 | (key.charCodeAt(++i) & 0xff) << 24;
    ++i;
    k1 = (k1 & 0xffff) * c1 + (((k1 >>> 16) * c1 & 0xffff) << 16) & 0xffffffff;
    k1 = k1 << 15 | k1 >>> 17;
    k1 = (k1 & 0xffff) * c2 + (((k1 >>> 16) * c2 & 0xffff) << 16) & 0xffffffff;
    h1 ^= k1;
    h1 = h1 << 13 | h1 >>> 19;
    h1b = (h1 & 0xffff) * 5 + (((h1 >>> 16) * 5 & 0xffff) << 16) & 0xffffffff;
    h1 = (h1b & 0xffff) + 0x6b64 + (((h1b >>> 16) + 0xe654 & 0xffff) << 16);
  }
  k1 = 0;
  switch (remainder) {
    case 3:
      k1 ^= (key.charCodeAt(i + 2) & 0xff) << 16;
    case 2:
      k1 ^= (key.charCodeAt(i + 1) & 0xff) << 8;
    case 1:
      k1 ^= key.charCodeAt(i) & 0xff;
      k1 = (k1 & 0xffff) * c1 + (((k1 >>> 16) * c1 & 0xffff) << 16) & 0xffffffff;
      k1 = k1 << 15 | k1 >>> 17;
      k1 = (k1 & 0xffff) * c2 + (((k1 >>> 16) * c2 & 0xffff) << 16) & 0xffffffff;
      h1 ^= k1;
  }
  h1 ^= key.length;
  h1 ^= h1 >>> 16;
  h1 = (h1 & 0xffff) * 0x85ebca6b + (((h1 >>> 16) * 0x85ebca6b & 0xffff) << 16) & 0xffffffff;
  h1 ^= h1 >>> 13;
  h1 = (h1 & 0xffff) * 0xc2b2ae35 + (((h1 >>> 16) * 0xc2b2ae35 & 0xffff) << 16) & 0xffffffff;
  h1 ^= h1 >>> 16;
  return h1 >>> 0;
};
function standardEqualsFunction(a, b) {
  return a ? a.equals(b) : a == b;
}
function standardHashCodeFunction(a) {
  return a ? a.hashCode() : -1;
}
class Set {
  constructor(hashFunction, equalsFunction) {
    this.data = {};
    this.hashFunction = hashFunction || standardHashCodeFunction;
    this.equalsFunction = equalsFunction || standardEqualsFunction;
  }
  add(value) {
    const hash = this.hashFunction(value);
    const key = "hash_" + hash;
    if (key in this.data) {
      const values = this.data[key];
      for (let i = 0; i < values.length; i++) {
        if (this.equalsFunction(value, values[i])) {
          return values[i];
        }
      }
      values.push(value);
      return value;
    } else {
      this.data[key] = [value];
      return value;
    }
  }
  contains(value) {
    return this.get(value) != null;
  }
  get(value) {
    const hash = this.hashFunction(value);
    const key = "hash_" + hash;
    if (key in this.data) {
      const values = this.data[key];
      for (let i = 0; i < values.length; i++) {
        if (this.equalsFunction(value, values[i])) {
          return values[i];
        }
      }
    }
    return null;
  }
  values() {
    let l = [];
    for (const key in this.data) {
      if (key.indexOf("hash_") === 0) {
        l = l.concat(this.data[key]);
      }
    }
    return l;
  }
  toString() {
    return arrayToString(this.values());
  }
  get length() {
    let l = 0;
    for (const key in this.data) {
      if (key.indexOf("hash_") === 0) {
        l = l + this.data[key].length;
      }
    }
    return l;
  }
}
class BitSet {
  constructor() {
    this.data = [];
  }
  add(value) {
    this.data[value] = true;
  }
  or(set) {
    const bits = this;
    Object.keys(set.data).map(function (alt) {
      bits.add(alt);
    });
  }
  remove(value) {
    delete this.data[value];
  }
  contains(value) {
    return this.data[value] === true;
  }
  values() {
    return Object.keys(this.data);
  }
  minValue() {
    return Math.min.apply(null, this.values());
  }
  hashCode() {
    const hash = new Hash();
    hash.update(this.values());
    return hash.finish();
  }
  equals(other) {
    if (!(other instanceof BitSet)) {
      return false;
    }
    return this.hashCode() === other.hashCode();
  }
  toString() {
    return "{" + this.values().join(", ") + "}";
  }
  get length() {
    return this.values().length;
  }
}
class Map {
  constructor(hashFunction, equalsFunction) {
    this.data = {};
    this.hashFunction = hashFunction || standardHashCodeFunction;
    this.equalsFunction = equalsFunction || standardEqualsFunction;
  }
  put(key, value) {
    const hashKey = "hash_" + this.hashFunction(key);
    if (hashKey in this.data) {
      const entries = this.data[hashKey];
      for (let i = 0; i < entries.length; i++) {
        const entry = entries[i];
        if (this.equalsFunction(key, entry.key)) {
          const oldValue = entry.value;
          entry.value = value;
          return oldValue;
        }
      }
      entries.push({
        key: key,
        value: value
      });
      return value;
    } else {
      this.data[hashKey] = [{
        key: key,
        value: value
      }];
      return value;
    }
  }
  containsKey(key) {
    const hashKey = "hash_" + this.hashFunction(key);
    if (hashKey in this.data) {
      const entries = this.data[hashKey];
      for (let i = 0; i < entries.length; i++) {
        const entry = entries[i];
        if (this.equalsFunction(key, entry.key)) return true;
      }
    }
    return false;
  }
  get(key) {
    const hashKey = "hash_" + this.hashFunction(key);
    if (hashKey in this.data) {
      const entries = this.data[hashKey];
      for (let i = 0; i < entries.length; i++) {
        const entry = entries[i];
        if (this.equalsFunction(key, entry.key)) return entry.value;
      }
    }
    return null;
  }
  entries() {
    let l = [];
    for (const key in this.data) {
      if (key.indexOf("hash_") === 0) {
        l = l.concat(this.data[key]);
      }
    }
    return l;
  }
  getKeys() {
    return this.entries().map(function (e) {
      return e.key;
    });
  }
  getValues() {
    return this.entries().map(function (e) {
      return e.value;
    });
  }
  toString() {
    const ss = this.entries().map(function (entry) {
      return '{' + entry.key + ':' + entry.value + '}';
    });
    return '[' + ss.join(", ") + ']';
  }
  get length() {
    let l = 0;
    for (const hashKey in this.data) {
      if (hashKey.indexOf("hash_") === 0) {
        l = l + this.data[hashKey].length;
      }
    }
    return l;
  }
}
class AltDict {
  constructor() {
    this.data = {};
  }
  get(key) {
    key = "k-" + key;
    if (key in this.data) {
      return this.data[key];
    } else {
      return null;
    }
  }
  put(key, value) {
    key = "k-" + key;
    this.data[key] = value;
  }
  values() {
    const data = this.data;
    const keys = Object.keys(this.data);
    return keys.map(function (key) {
      return data[key];
    });
  }
}
class DoubleDict {
  constructor(defaultMapCtor) {
    this.defaultMapCtor = defaultMapCtor || Map;
    this.cacheMap = new this.defaultMapCtor();
  }
  get(a, b) {
    const d = this.cacheMap.get(a) || null;
    return d === null ? null : d.get(b) || null;
  }
  set(a, b, o) {
    let d = this.cacheMap.get(a) || null;
    if (d === null) {
      d = new this.defaultMapCtor();
      this.cacheMap.put(a, d);
    }
    d.put(b, o);
  }
}
class Hash {
  constructor() {
    this.count = 0;
    this.hash = 0;
  }
  update() {
    for (let i = 0; i < arguments.length; i++) {
      const value = arguments[i];
      if (value == null) continue;
      if (Array.isArray(value)) this.update.apply(this, value);else {
        let k = 0;
        switch (typeof value) {
          case 'undefined':
          case 'function':
            continue;
          case 'number':
          case 'boolean':
            k = value;
            break;
          case 'string':
            k = value.hashCode();
            break;
          default:
            if (value.updateHashCode) value.updateHashCode(this);else console.log("No updateHashCode for " + value.toString());
            continue;
        }
        k = k * 0xCC9E2D51;
        k = k << 15 | k >>> 32 - 15;
        k = k * 0x1B873593;
        this.count = this.count + 1;
        let hash = this.hash ^ k;
        hash = hash << 13 | hash >>> 32 - 13;
        hash = hash * 5 + 0xE6546B64;
        this.hash = hash;
      }
    }
  }
  finish() {
    let hash = this.hash ^ this.count * 4;
    hash = hash ^ hash >>> 16;
    hash = hash * 0x85EBCA6B;
    hash = hash ^ hash >>> 13;
    hash = hash * 0xC2B2AE35;
    hash = hash ^ hash >>> 16;
    return hash;
  }
}
function hashStuff() {
  const hash = new Hash();
  hash.update.apply(hash, arguments);
  return hash.finish();
}
function escapeWhitespace(s, escapeSpaces) {
  s = s.replace(/\t/g, "\\t").replace(/\n/g, "\\n").replace(/\r/g, "\\r");
  if (escapeSpaces) {
    s = s.replace(/ /g, "\u00B7");
  }
  return s;
}
function titleCase(str) {
  return str.replace(/\w\S*/g, function (txt) {
    return txt.charAt(0).toUpperCase() + txt.substr(1);
  });
}
function equalArrays(a, b) {
  if (!Array.isArray(a) || !Array.isArray(b)) return false;
  if (a === b) return true;
  if (a.length !== b.length) return false;
  for (let i = 0; i < a.length; i++) {
    if (a[i] === b[i]) continue;
    if (!a[i].equals || !a[i].equals(b[i])) return false;
  }
  return true;
}
module.exports = {
  Hash,
  Set,
  Map,
  BitSet,
  AltDict,
  DoubleDict,
  hashStuff,
  escapeWhitespace,
  arrayToString,
  titleCase,
  equalArrays
};

/***/ }),
/* 10 */
/***/ (function(module) {

/* Copyright (c) 2012-2017 The ANTLR Project. All rights reserved.
 * Use of this file is governed by the BSD 3-clause license that
 * can be found in the LICENSE.txt file in the project root.
 */

/**
 * A token has properties: text, type, line, character position in the line
 * (so we can ignore tabs), token channel, index, and source from which
 * we obtained this token.
 */
class Token {
  constructor() {
    this.source = null;
    this.type = null; // token type of the token
    this.channel = null; // The parser ignores everything not on DEFAULT_CHANNEL
    this.start = null; // optional; return -1 if not implemented.
    this.stop = null; // optional; return -1 if not implemented.
    this.tokenIndex = null; // from 0..n-1 of the token object in the input stream
    this.line = null; // line=1..n of the 1st character
    this.column = null; // beginning of the line at which it occurs, 0..n-1
    this._text = null; // text of the token.
  }
  getTokenSource() {
    return this.source[0];
  }
  getInputStream() {
    return this.source[1];
  }
  get text() {
    return this._text;
  }
  set text(text) {
    this._text = text;
  }
}
Token.INVALID_TYPE = 0;

/**
 * During lookahead operations, this "token" signifies we hit rule end ATN state
 * and did not follow it despite needing to.
 */
Token.EPSILON = -2;
Token.MIN_USER_TOKEN_TYPE = 1;
Token.EOF = -1;

/**
 * All tokens go to the parser (unless skip() is called in that rule)
 * on a particular "channel". The parser tunes to a particular channel
 * so that whitespace etc... can go to the parser on a "hidden" channel.
 */
Token.DEFAULT_CHANNEL = 0;

/**
 * Anything on different channel than DEFAULT_CHANNEL is not parsed
 * by parser.
 */
Token.HIDDEN_CHANNEL = 1;
class CommonToken extends Token {
  constructor(source, type, channel, start, stop) {
    super();
    this.source = source !== undefined ? source : CommonToken.EMPTY_SOURCE;
    this.type = type !== undefined ? type : null;
    this.channel = channel !== undefined ? channel : Token.DEFAULT_CHANNEL;
    this.start = start !== undefined ? start : -1;
    this.stop = stop !== undefined ? stop : -1;
    this.tokenIndex = -1;
    if (this.source[0] !== null) {
      this.line = source[0].line;
      this.column = source[0].column;
    } else {
      this.column = -1;
    }
  }

  /**
   * Constructs a new {@link CommonToken} as a copy of another {@link Token}.
   *
   * <p>
   * If {@code oldToken} is also a {@link CommonToken} instance, the newly
   * constructed token will share a reference to the {@link //text} field and
   * the {@link Pair} stored in {@link //source}. Otherwise, {@link //text} will
   * be assigned the result of calling {@link //getText}, and {@link //source}
   * will be constructed from the result of {@link Token//getTokenSource} and
   * {@link Token//getInputStream}.</p>
   *
   * @param oldToken The token to copy.
   */
  clone() {
    const t = new CommonToken(this.source, this.type, this.channel, this.start, this.stop);
    t.tokenIndex = this.tokenIndex;
    t.line = this.line;
    t.column = this.column;
    t.text = this.text;
    return t;
  }
  toString() {
    let txt = this.text;
    if (txt !== null) {
      txt = txt.replace(/\n/g, "\\n").replace(/\r/g, "\\r").replace(/\t/g, "\\t");
    } else {
      txt = "<no text>";
    }
    return "[@" + this.tokenIndex + "," + this.start + ":" + this.stop + "='" + txt + "',<" + this.type + ">" + (this.channel > 0 ? ",channel=" + this.channel : "") + "," + this.line + ":" + this.column + "]";
  }
  get text() {
    if (this._text !== null) {
      return this._text;
    }
    const input = this.getInputStream();
    if (input === null) {
      return null;
    }
    const n = input.size;
    if (this.start < n && this.stop < n) {
      return input.getText(this.start, this.stop);
    } else {
      return "<EOF>";
    }
  }
  set text(text) {
    this._text = text;
  }
}

/**
 * An empty {@link Pair} which is used as the default value of
 * {@link //source} for tokens that do not have a source.
 */
CommonToken.EMPTY_SOURCE = [null, null];
module.exports = {
  Token,
  CommonToken
};

/***/ }),
/* 11 */
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

/* Copyright (c) 2012-2017 The ANTLR Project. All rights reserved.
 * Use of this file is governed by the BSD 3-clause license that
 * can be found in the LICENSE.txt file in the project root.
 */

const {
  DecisionState
} = __webpack_require__(12);
const {
  SemanticContext
} = __webpack_require__(13);
const {
  Hash
} = __webpack_require__(9);
function checkParams(params, isCfg) {
  if (params === null) {
    const result = {
      state: null,
      alt: null,
      context: null,
      semanticContext: null
    };
    if (isCfg) {
      result.reachesIntoOuterContext = 0;
    }
    return result;
  } else {
    const props = {};
    props.state = params.state || null;
    props.alt = params.alt === undefined ? null : params.alt;
    props.context = params.context || null;
    props.semanticContext = params.semanticContext || null;
    if (isCfg) {
      props.reachesIntoOuterContext = params.reachesIntoOuterContext || 0;
      props.precedenceFilterSuppressed = params.precedenceFilterSuppressed || false;
    }
    return props;
  }
}
class ATNConfig {
  /**
   * @param {Object} params A tuple: (ATN state, predicted alt, syntactic, semantic context).
   * The syntactic context is a graph-structured stack node whose
   * path(s) to the root is the rule invocation(s)
   * chain used to arrive at the state.  The semantic context is
   * the tree of semantic predicates encountered before reaching
   * an ATN state
   */
  constructor(params, config) {
    this.checkContext(params, config);
    params = checkParams(params);
    config = checkParams(config, true);
    // The ATN state associated with this configuration///
    this.state = params.state !== null ? params.state : config.state;
    // What alt (or lexer rule) is predicted by this configuration///
    this.alt = params.alt !== null ? params.alt : config.alt;
    /**
     * The stack of invoking states leading to the rule/states associated
     * with this config.  We track only those contexts pushed during
     * execution of the ATN simulator
     */
    this.context = params.context !== null ? params.context : config.context;
    this.semanticContext = params.semanticContext !== null ? params.semanticContext : config.semanticContext !== null ? config.semanticContext : SemanticContext.NONE;
    // TODO: make it a boolean then
    /**
     * We cannot execute predicates dependent upon local context unless
     * we know for sure we are in the correct context. Because there is
     * no way to do this efficiently, we simply cannot evaluate
     * dependent predicates unless we are in the rule that initially
     * invokes the ATN simulator.
     * closure() tracks the depth of how far we dip into the
     * outer context: depth &gt; 0.  Note that it may not be totally
     * accurate depth since I don't ever decrement
     */
    this.reachesIntoOuterContext = config.reachesIntoOuterContext;
    this.precedenceFilterSuppressed = config.precedenceFilterSuppressed;
  }
  checkContext(params, config) {
    if ((params.context === null || params.context === undefined) && (config === null || config.context === null || config.context === undefined)) {
      this.context = null;
    }
  }
  hashCode() {
    const hash = new Hash();
    this.updateHashCode(hash);
    return hash.finish();
  }
  updateHashCode(hash) {
    hash.update(this.state.stateNumber, this.alt, this.context, this.semanticContext);
  }

  /**
   * An ATN configuration is equal to another if both have
   * the same state, they predict the same alternative, and
   * syntactic/semantic contexts are the same
   */
  equals(other) {
    if (this === other) {
      return true;
    } else if (!(other instanceof ATNConfig)) {
      return false;
    } else {
      return this.state.stateNumber === other.state.stateNumber && this.alt === other.alt && (this.context === null ? other.context === null : this.context.equals(other.context)) && this.semanticContext.equals(other.semanticContext) && this.precedenceFilterSuppressed === other.precedenceFilterSuppressed;
    }
  }
  hashCodeForConfigSet() {
    const hash = new Hash();
    hash.update(this.state.stateNumber, this.alt, this.semanticContext);
    return hash.finish();
  }
  equalsForConfigSet(other) {
    if (this === other) {
      return true;
    } else if (!(other instanceof ATNConfig)) {
      return false;
    } else {
      return this.state.stateNumber === other.state.stateNumber && this.alt === other.alt && this.semanticContext.equals(other.semanticContext);
    }
  }
  toString() {
    return "(" + this.state + "," + this.alt + (this.context !== null ? ",[" + this.context.toString() + "]" : "") + (this.semanticContext !== SemanticContext.NONE ? "," + this.semanticContext.toString() : "") + (this.reachesIntoOuterContext > 0 ? ",up=" + this.reachesIntoOuterContext : "") + ")";
  }
}
class LexerATNConfig extends ATNConfig {
  constructor(params, config) {
    super(params, config);

    // This is the backing field for {@link //getLexerActionExecutor}.
    const lexerActionExecutor = params.lexerActionExecutor || null;
    this.lexerActionExecutor = lexerActionExecutor || (config !== null ? config.lexerActionExecutor : null);
    this.passedThroughNonGreedyDecision = config !== null ? this.checkNonGreedyDecision(config, this.state) : false;
    this.hashCodeForConfigSet = LexerATNConfig.prototype.hashCode;
    this.equalsForConfigSet = LexerATNConfig.prototype.equals;
    return this;
  }
  updateHashCode(hash) {
    hash.update(this.state.stateNumber, this.alt, this.context, this.semanticContext, this.passedThroughNonGreedyDecision, this.lexerActionExecutor);
  }
  equals(other) {
    return this === other || other instanceof LexerATNConfig && this.passedThroughNonGreedyDecision === other.passedThroughNonGreedyDecision && (this.lexerActionExecutor ? this.lexerActionExecutor.equals(other.lexerActionExecutor) : !other.lexerActionExecutor) && super.equals(other);
  }
  checkNonGreedyDecision(source, target) {
    return source.passedThroughNonGreedyDecision || target instanceof DecisionState && target.nonGreedy;
  }
}
module.exports.ATNConfig = ATNConfig;
module.exports.LexerATNConfig = LexerATNConfig;

/***/ }),
/* 12 */
/***/ (function(module) {

/* Copyright (c) 2012-2017 The ANTLR Project. All rights reserved.
 * Use of this file is governed by the BSD 3-clause license that
 * can be found in the LICENSE.txt file in the project root.
 */

const INITIAL_NUM_TRANSITIONS = 4;

/**
 * The following images show the relation of states and
 * {@link ATNState//transitions} for various grammar constructs.
 *
 * <ul>
 *
 * <li>Solid edges marked with an &//0949; indicate a required
 * {@link EpsilonTransition}.</li>
 *
 * <li>Dashed edges indicate locations where any transition derived from
 * {@link Transition} might appear.</li>
 *
 * <li>Dashed nodes are place holders for either a sequence of linked
 * {@link BasicState} states or the inclusion of a block representing a nested
 * construct in one of the forms below.</li>
 *
 * <li>Nodes showing multiple outgoing alternatives with a {@code ...} support
 * any number of alternatives (one or more). Nodes without the {@code ...} only
 * support the exact number of alternatives shown in the diagram.</li>
 *
 * </ul>
 *
 * <h2>Basic Blocks</h2>
 *
 * <h3>Rule</h3>
 *
 * <embed src="images/Rule.svg" type="image/svg+xml"/>
 *
 * <h3>Block of 1 or more alternatives</h3>
 *
 * <embed src="images/Block.svg" type="image/svg+xml"/>
 *
 * <h2>Greedy Loops</h2>
 *
 * <h3>Greedy Closure: {@code (...)*}</h3>
 *
 * <embed src="images/ClosureGreedy.svg" type="image/svg+xml"/>
 *
 * <h3>Greedy Positive Closure: {@code (...)+}</h3>
 *
 * <embed src="images/PositiveClosureGreedy.svg" type="image/svg+xml"/>
 *
 * <h3>Greedy Optional: {@code (...)?}</h3>
 *
 * <embed src="images/OptionalGreedy.svg" type="image/svg+xml"/>
 *
 * <h2>Non-Greedy Loops</h2>
 *
 * <h3>Non-Greedy Closure: {@code (...)*?}</h3>
 *
 * <embed src="images/ClosureNonGreedy.svg" type="image/svg+xml"/>
 *
 * <h3>Non-Greedy Positive Closure: {@code (...)+?}</h3>
 *
 * <embed src="images/PositiveClosureNonGreedy.svg" type="image/svg+xml"/>
 *
 * <h3>Non-Greedy Optional: {@code (...)??}</h3>
 *
 * <embed src="images/OptionalNonGreedy.svg" type="image/svg+xml"/>
 */
class ATNState {
  constructor() {
    // Which ATN are we in?
    this.atn = null;
    this.stateNumber = ATNState.INVALID_STATE_NUMBER;
    this.stateType = null;
    this.ruleIndex = 0; // at runtime, we don't have Rule objects
    this.epsilonOnlyTransitions = false;
    // Track the transitions emanating from this ATN state.
    this.transitions = [];
    // Used to cache lookahead during parsing, not used during construction
    this.nextTokenWithinRule = null;
  }
  toString() {
    return this.stateNumber;
  }
  equals(other) {
    if (other instanceof ATNState) {
      return this.stateNumber === other.stateNumber;
    } else {
      return false;
    }
  }
  isNonGreedyExitState() {
    return false;
  }
  addTransition(trans, index) {
    if (index === undefined) {
      index = -1;
    }
    if (this.transitions.length === 0) {
      this.epsilonOnlyTransitions = trans.isEpsilon;
    } else if (this.epsilonOnlyTransitions !== trans.isEpsilon) {
      this.epsilonOnlyTransitions = false;
    }
    if (index === -1) {
      this.transitions.push(trans);
    } else {
      this.transitions.splice(index, 1, trans);
    }
  }
}

// constants for serialization
ATNState.INVALID_TYPE = 0;
ATNState.BASIC = 1;
ATNState.RULE_START = 2;
ATNState.BLOCK_START = 3;
ATNState.PLUS_BLOCK_START = 4;
ATNState.STAR_BLOCK_START = 5;
ATNState.TOKEN_START = 6;
ATNState.RULE_STOP = 7;
ATNState.BLOCK_END = 8;
ATNState.STAR_LOOP_BACK = 9;
ATNState.STAR_LOOP_ENTRY = 10;
ATNState.PLUS_LOOP_BACK = 11;
ATNState.LOOP_END = 12;
ATNState.serializationNames = ["INVALID", "BASIC", "RULE_START", "BLOCK_START", "PLUS_BLOCK_START", "STAR_BLOCK_START", "TOKEN_START", "RULE_STOP", "BLOCK_END", "STAR_LOOP_BACK", "STAR_LOOP_ENTRY", "PLUS_LOOP_BACK", "LOOP_END"];
ATNState.INVALID_STATE_NUMBER = -1;
class BasicState extends ATNState {
  constructor() {
    super();
    this.stateType = ATNState.BASIC;
  }
}
class DecisionState extends ATNState {
  constructor() {
    super();
    this.decision = -1;
    this.nonGreedy = false;
    return this;
  }
}

/**
 *  The start of a regular {@code (...)} block
 */
class BlockStartState extends DecisionState {
  constructor() {
    super();
    this.endState = null;
    return this;
  }
}
class BasicBlockStartState extends BlockStartState {
  constructor() {
    super();
    this.stateType = ATNState.BLOCK_START;
    return this;
  }
}

/**
 * Terminal node of a simple {@code (a|b|c)} block
 */
class BlockEndState extends ATNState {
  constructor() {
    super();
    this.stateType = ATNState.BLOCK_END;
    this.startState = null;
    return this;
  }
}

/**
 * The last node in the ATN for a rule, unless that rule is the start symbol.
 * In that case, there is one transition to EOF. Later, we might encode
 * references to all calls to this rule to compute FOLLOW sets for
 * error handling
 */
class RuleStopState extends ATNState {
  constructor() {
    super();
    this.stateType = ATNState.RULE_STOP;
    return this;
  }
}
class RuleStartState extends ATNState {
  constructor() {
    super();
    this.stateType = ATNState.RULE_START;
    this.stopState = null;
    this.isPrecedenceRule = false;
    return this;
  }
}

/**
 * Decision state for {@code A+} and {@code (A|B)+}.  It has two transitions:
 * one to the loop back to start of the block and one to exit.
 */
class PlusLoopbackState extends DecisionState {
  constructor() {
    super();
    this.stateType = ATNState.PLUS_LOOP_BACK;
    return this;
  }
}

/**
 * Start of {@code (A|B|...)+} loop. Technically a decision state, but
 * we don't use for code generation; somebody might need it, so I'm defining
 * it for completeness. In reality, the {@link PlusLoopbackState} node is the
 * real decision-making note for {@code A+}
 */
class PlusBlockStartState extends BlockStartState {
  constructor() {
    super();
    this.stateType = ATNState.PLUS_BLOCK_START;
    this.loopBackState = null;
    return this;
  }
}

/**
 * The block that begins a closure loop
 */
class StarBlockStartState extends BlockStartState {
  constructor() {
    super();
    this.stateType = ATNState.STAR_BLOCK_START;
    return this;
  }
}
class StarLoopbackState extends ATNState {
  constructor() {
    super();
    this.stateType = ATNState.STAR_LOOP_BACK;
    return this;
  }
}
class StarLoopEntryState extends DecisionState {
  constructor() {
    super();
    this.stateType = ATNState.STAR_LOOP_ENTRY;
    this.loopBackState = null;
    // Indicates whether this state can benefit from a precedence DFA during SLL decision making.
    this.isPrecedenceDecision = null;
    return this;
  }
}

/**
 * Mark the end of a * or + loop
 */
class LoopEndState extends ATNState {
  constructor() {
    super();
    this.stateType = ATNState.LOOP_END;
    this.loopBackState = null;
    return this;
  }
}

/**
 * The Tokens rule start state linking to each lexer rule start state
 */
class TokensStartState extends DecisionState {
  constructor() {
    super();
    this.stateType = ATNState.TOKEN_START;
    return this;
  }
}
module.exports = {
  ATNState,
  BasicState,
  DecisionState,
  BlockStartState,
  BlockEndState,
  LoopEndState,
  RuleStartState,
  RuleStopState,
  TokensStartState,
  PlusLoopbackState,
  StarLoopbackState,
  StarLoopEntryState,
  PlusBlockStartState,
  StarBlockStartState,
  BasicBlockStartState
};

/***/ }),
/* 13 */
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

/* Copyright (c) 2012-2017 The ANTLR Project. All rights reserved.
 * Use of this file is governed by the BSD 3-clause license that
 * can be found in the LICENSE.txt file in the project root.
 */

const {
  Set,
  Hash,
  equalArrays
} = __webpack_require__(9);

/**
 * A tree structure used to record the semantic context in which
 * an ATN configuration is valid.  It's either a single predicate,
 * a conjunction {@code p1&&p2}, or a sum of products {@code p1||p2}.
 *
 * <p>I have scoped the {@link AND}, {@link OR}, and {@link Predicate} subclasses of
 * {@link SemanticContext} within the scope of this outer class.</p>
 */
class SemanticContext {
  hashCode() {
    const hash = new Hash();
    this.updateHashCode(hash);
    return hash.finish();
  }

  /**
   * For context independent predicates, we evaluate them without a local
   * context (i.e., null context). That way, we can evaluate them without
   * having to create proper rule-specific context during prediction (as
   * opposed to the parser, which creates them naturally). In a practical
   * sense, this avoids a cast exception from RuleContext to myruleContext.
   *
   * <p>For context dependent predicates, we must pass in a local context so that
   * references such as $arg evaluate properly as _localctx.arg. We only
   * capture context dependent predicates in the context in which we begin
   * prediction, so we passed in the outer context here in case of context
   * dependent predicate evaluation.</p>
   */
  evaluate(parser, outerContext) {}

  /**
   * Evaluate the precedence predicates for the context and reduce the result.
   *
   * @param parser The parser instance.
   * @param outerContext The current parser context object.
   * @return The simplified semantic context after precedence predicates are
   * evaluated, which will be one of the following values.
   * <ul>
   * <li>{@link //NONE}: if the predicate simplifies to {@code true} after
   * precedence predicates are evaluated.</li>
   * <li>{@code null}: if the predicate simplifies to {@code false} after
   * precedence predicates are evaluated.</li>
   * <li>{@code this}: if the semantic context is not changed as a result of
   * precedence predicate evaluation.</li>
   * <li>A non-{@code null} {@link SemanticContext}: the new simplified
   * semantic context after precedence predicates are evaluated.</li>
   * </ul>
   */
  evalPrecedence(parser, outerContext) {
    return this;
  }
  static andContext(a, b) {
    if (a === null || a === SemanticContext.NONE) {
      return b;
    }
    if (b === null || b === SemanticContext.NONE) {
      return a;
    }
    const result = new AND(a, b);
    if (result.opnds.length === 1) {
      return result.opnds[0];
    } else {
      return result;
    }
  }
  static orContext(a, b) {
    if (a === null) {
      return b;
    }
    if (b === null) {
      return a;
    }
    if (a === SemanticContext.NONE || b === SemanticContext.NONE) {
      return SemanticContext.NONE;
    }
    const result = new OR(a, b);
    if (result.opnds.length === 1) {
      return result.opnds[0];
    } else {
      return result;
    }
  }
}
class Predicate extends SemanticContext {
  constructor(ruleIndex, predIndex, isCtxDependent) {
    super();
    this.ruleIndex = ruleIndex === undefined ? -1 : ruleIndex;
    this.predIndex = predIndex === undefined ? -1 : predIndex;
    this.isCtxDependent = isCtxDependent === undefined ? false : isCtxDependent; // e.g., $i ref in pred
  }
  evaluate(parser, outerContext) {
    const localctx = this.isCtxDependent ? outerContext : null;
    return parser.sempred(localctx, this.ruleIndex, this.predIndex);
  }
  updateHashCode(hash) {
    hash.update(this.ruleIndex, this.predIndex, this.isCtxDependent);
  }
  equals(other) {
    if (this === other) {
      return true;
    } else if (!(other instanceof Predicate)) {
      return false;
    } else {
      return this.ruleIndex === other.ruleIndex && this.predIndex === other.predIndex && this.isCtxDependent === other.isCtxDependent;
    }
  }
  toString() {
    return "{" + this.ruleIndex + ":" + this.predIndex + "}?";
  }
}

/**
 * The default {@link SemanticContext}, which is semantically equivalent to
 * a predicate of the form {@code {true}?}
 */
SemanticContext.NONE = new Predicate();
class PrecedencePredicate extends SemanticContext {
  constructor(precedence) {
    super();
    this.precedence = precedence === undefined ? 0 : precedence;
  }
  evaluate(parser, outerContext) {
    return parser.precpred(outerContext, this.precedence);
  }
  evalPrecedence(parser, outerContext) {
    if (parser.precpred(outerContext, this.precedence)) {
      return SemanticContext.NONE;
    } else {
      return null;
    }
  }
  compareTo(other) {
    return this.precedence - other.precedence;
  }
  updateHashCode(hash) {
    hash.update(this.precedence);
  }
  equals(other) {
    if (this === other) {
      return true;
    } else if (!(other instanceof PrecedencePredicate)) {
      return false;
    } else {
      return this.precedence === other.precedence;
    }
  }
  toString() {
    return "{" + this.precedence + ">=prec}?";
  }
  static filterPrecedencePredicates(set) {
    const result = [];
    set.values().map(function (context) {
      if (context instanceof PrecedencePredicate) {
        result.push(context);
      }
    });
    return result;
  }
}
class AND extends SemanticContext {
  /**
   * A semantic context which is true whenever none of the contained contexts
   * is false
   */
  constructor(a, b) {
    super();
    const operands = new Set();
    if (a instanceof AND) {
      a.opnds.map(function (o) {
        operands.add(o);
      });
    } else {
      operands.add(a);
    }
    if (b instanceof AND) {
      b.opnds.map(function (o) {
        operands.add(o);
      });
    } else {
      operands.add(b);
    }
    const precedencePredicates = PrecedencePredicate.filterPrecedencePredicates(operands);
    if (precedencePredicates.length > 0) {
      // interested in the transition with the lowest precedence
      let reduced = null;
      precedencePredicates.map(function (p) {
        if (reduced === null || p.precedence < reduced.precedence) {
          reduced = p;
        }
      });
      operands.add(reduced);
    }
    this.opnds = Array.from(operands.values());
  }
  equals(other) {
    if (this === other) {
      return true;
    } else if (!(other instanceof AND)) {
      return false;
    } else {
      return equalArrays(this.opnds, other.opnds);
    }
  }
  updateHashCode(hash) {
    hash.update(this.opnds, "AND");
  }

  /**
   * {@inheritDoc}
   *
   * <p>
   * The evaluation of predicates by this context is short-circuiting, but
   * unordered.</p>
   */
  evaluate(parser, outerContext) {
    for (let i = 0; i < this.opnds.length; i++) {
      if (!this.opnds[i].evaluate(parser, outerContext)) {
        return false;
      }
    }
    return true;
  }
  evalPrecedence(parser, outerContext) {
    let differs = false;
    const operands = [];
    for (let i = 0; i < this.opnds.length; i++) {
      const context = this.opnds[i];
      const evaluated = context.evalPrecedence(parser, outerContext);
      differs |= evaluated !== context;
      if (evaluated === null) {
        // The AND context is false if any element is false
        return null;
      } else if (evaluated !== SemanticContext.NONE) {
        // Reduce the result by skipping true elements
        operands.push(evaluated);
      }
    }
    if (!differs) {
      return this;
    }
    if (operands.length === 0) {
      // all elements were true, so the AND context is true
      return SemanticContext.NONE;
    }
    let result = null;
    operands.map(function (o) {
      result = result === null ? o : SemanticContext.andContext(result, o);
    });
    return result;
  }
  toString() {
    const s = this.opnds.map(o => o.toString());
    return (s.length > 3 ? s.slice(3) : s).join("&&");
  }
}
class OR extends SemanticContext {
  /**
   * A semantic context which is true whenever at least one of the contained
   * contexts is true
   */
  constructor(a, b) {
    super();
    const operands = new Set();
    if (a instanceof OR) {
      a.opnds.map(function (o) {
        operands.add(o);
      });
    } else {
      operands.add(a);
    }
    if (b instanceof OR) {
      b.opnds.map(function (o) {
        operands.add(o);
      });
    } else {
      operands.add(b);
    }
    const precedencePredicates = PrecedencePredicate.filterPrecedencePredicates(operands);
    if (precedencePredicates.length > 0) {
      // interested in the transition with the highest precedence
      const s = precedencePredicates.sort(function (a, b) {
        return a.compareTo(b);
      });
      const reduced = s[s.length - 1];
      operands.add(reduced);
    }
    this.opnds = Array.from(operands.values());
  }
  equals(other) {
    if (this === other) {
      return true;
    } else if (!(other instanceof OR)) {
      return false;
    } else {
      return equalArrays(this.opnds, other.opnds);
    }
  }
  updateHashCode(hash) {
    hash.update(this.opnds, "OR");
  }

  /**
   * <p>
   * The evaluation of predicates by this context is short-circuiting, but
   * unordered.</p>
   */
  evaluate(parser, outerContext) {
    for (let i = 0; i < this.opnds.length; i++) {
      if (this.opnds[i].evaluate(parser, outerContext)) {
        return true;
      }
    }
    return false;
  }
  evalPrecedence(parser, outerContext) {
    let differs = false;
    const operands = [];
    for (let i = 0; i < this.opnds.length; i++) {
      const context = this.opnds[i];
      const evaluated = context.evalPrecedence(parser, outerContext);
      differs |= evaluated !== context;
      if (evaluated === SemanticContext.NONE) {
        // The OR context is true if any element is true
        return SemanticContext.NONE;
      } else if (evaluated !== null) {
        // Reduce the result by skipping false elements
        operands.push(evaluated);
      }
    }
    if (!differs) {
      return this;
    }
    if (operands.length === 0) {
      // all elements were false, so the OR context is false
      return null;
    }
    const result = null;
    operands.map(function (o) {
      return result === null ? o : SemanticContext.orContext(result, o);
    });
    return result;
  }
  toString() {
    const s = this.opnds.map(o => o.toString());
    return (s.length > 3 ? s.slice(3) : s).join("||");
  }
}
module.exports = {
  SemanticContext,
  PrecedencePredicate,
  Predicate
};

/***/ }),
/* 14 */
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

/* Copyright (c) 2012-2017 The ANTLR Project. All rights reserved.
 * Use of this file is governed by the BSD 3-clause license that
 * can be found in the LICENSE.txt file in the project root.
 */

const {
  Token
} = __webpack_require__(10);

/* stop is not included! */
class Interval {
  constructor(start, stop) {
    this.start = start;
    this.stop = stop;
  }
  clone() {
    return new Interval(this.start, this.stop);
  }
  contains(item) {
    return item >= this.start && item < this.stop;
  }
  toString() {
    if (this.start === this.stop - 1) {
      return this.start.toString();
    } else {
      return this.start.toString() + ".." + (this.stop - 1).toString();
    }
  }
  get length() {
    return this.stop - this.start;
  }
}
class IntervalSet {
  constructor() {
    this.intervals = null;
    this.readOnly = false;
  }
  first(v) {
    if (this.intervals === null || this.intervals.length === 0) {
      return Token.INVALID_TYPE;
    } else {
      return this.intervals[0].start;
    }
  }
  addOne(v) {
    this.addInterval(new Interval(v, v + 1));
  }
  addRange(l, h) {
    this.addInterval(new Interval(l, h + 1));
  }
  addInterval(toAdd) {
    if (this.intervals === null) {
      this.intervals = [];
      this.intervals.push(toAdd.clone());
    } else {
      // find insert pos
      for (let pos = 0; pos < this.intervals.length; pos++) {
        const existing = this.intervals[pos];
        // distinct range -> insert
        if (toAdd.stop < existing.start) {
          this.intervals.splice(pos, 0, toAdd);
          return;
        }
        // contiguous range -> adjust
        else if (toAdd.stop === existing.start) {
          this.intervals[pos] = new Interval(toAdd.start, existing.stop);
          return;
        }
        // overlapping range -> adjust and reduce
        else if (toAdd.start <= existing.stop) {
          this.intervals[pos] = new Interval(Math.min(existing.start, toAdd.start), Math.max(existing.stop, toAdd.stop));
          this.reduce(pos);
          return;
        }
      }
      // greater than any existing
      this.intervals.push(toAdd.clone());
    }
  }
  addSet(other) {
    if (other.intervals !== null) {
      other.intervals.forEach(toAdd => this.addInterval(toAdd), this);
    }
    return this;
  }
  reduce(pos) {
    // only need to reduce if pos is not the last
    if (pos < this.intervals.length - 1) {
      const current = this.intervals[pos];
      const next = this.intervals[pos + 1];
      // if next contained in current
      if (current.stop >= next.stop) {
        this.intervals.splice(pos + 1, 1);
        this.reduce(pos);
      } else if (current.stop >= next.start) {
        this.intervals[pos] = new Interval(current.start, next.stop);
        this.intervals.splice(pos + 1, 1);
      }
    }
  }
  complement(start, stop) {
    const result = new IntervalSet();
    result.addInterval(new Interval(start, stop + 1));
    if (this.intervals !== null) this.intervals.forEach(toRemove => result.removeRange(toRemove));
    return result;
  }
  contains(item) {
    if (this.intervals === null) {
      return false;
    } else {
      for (let k = 0; k < this.intervals.length; k++) {
        if (this.intervals[k].contains(item)) {
          return true;
        }
      }
      return false;
    }
  }
  removeRange(toRemove) {
    if (toRemove.start === toRemove.stop - 1) {
      this.removeOne(toRemove.start);
    } else if (this.intervals !== null) {
      let pos = 0;
      for (let n = 0; n < this.intervals.length; n++) {
        const existing = this.intervals[pos];
        // intervals are ordered
        if (toRemove.stop <= existing.start) {
          return;
        }
        // check for including range, split it
        else if (toRemove.start > existing.start && toRemove.stop < existing.stop) {
          this.intervals[pos] = new Interval(existing.start, toRemove.start);
          const x = new Interval(toRemove.stop, existing.stop);
          this.intervals.splice(pos, 0, x);
          return;
        }
        // check for included range, remove it
        else if (toRemove.start <= existing.start && toRemove.stop >= existing.stop) {
          this.intervals.splice(pos, 1);
          pos = pos - 1; // need another pass
        }
        // check for lower boundary
        else if (toRemove.start < existing.stop) {
          this.intervals[pos] = new Interval(existing.start, toRemove.start);
        }
        // check for upper boundary
        else if (toRemove.stop < existing.stop) {
          this.intervals[pos] = new Interval(toRemove.stop, existing.stop);
        }
        pos += 1;
      }
    }
  }
  removeOne(value) {
    if (this.intervals !== null) {
      for (let i = 0; i < this.intervals.length; i++) {
        const existing = this.intervals[i];
        // intervals are ordered
        if (value < existing.start) {
          return;
        }
        // check for single value range
        else if (value === existing.start && value === existing.stop - 1) {
          this.intervals.splice(i, 1);
          return;
        }
        // check for lower boundary
        else if (value === existing.start) {
          this.intervals[i] = new Interval(existing.start + 1, existing.stop);
          return;
        }
        // check for upper boundary
        else if (value === existing.stop - 1) {
          this.intervals[i] = new Interval(existing.start, existing.stop - 1);
          return;
        }
        // split existing range
        else if (value < existing.stop - 1) {
          const replace = new Interval(existing.start, value);
          existing.start = value + 1;
          this.intervals.splice(i, 0, replace);
          return;
        }
      }
    }
  }
  toString(literalNames, symbolicNames, elemsAreChar) {
    literalNames = literalNames || null;
    symbolicNames = symbolicNames || null;
    elemsAreChar = elemsAreChar || false;
    if (this.intervals === null) {
      return "{}";
    } else if (literalNames !== null || symbolicNames !== null) {
      return this.toTokenString(literalNames, symbolicNames);
    } else if (elemsAreChar) {
      return this.toCharString();
    } else {
      return this.toIndexString();
    }
  }
  toCharString() {
    const names = [];
    for (let i = 0; i < this.intervals.length; i++) {
      const existing = this.intervals[i];
      if (existing.stop === existing.start + 1) {
        if (existing.start === Token.EOF) {
          names.push("<EOF>");
        } else {
          names.push("'" + String.fromCharCode(existing.start) + "'");
        }
      } else {
        names.push("'" + String.fromCharCode(existing.start) + "'..'" + String.fromCharCode(existing.stop - 1) + "'");
      }
    }
    if (names.length > 1) {
      return "{" + names.join(", ") + "}";
    } else {
      return names[0];
    }
  }
  toIndexString() {
    const names = [];
    for (let i = 0; i < this.intervals.length; i++) {
      const existing = this.intervals[i];
      if (existing.stop === existing.start + 1) {
        if (existing.start === Token.EOF) {
          names.push("<EOF>");
        } else {
          names.push(existing.start.toString());
        }
      } else {
        names.push(existing.start.toString() + ".." + (existing.stop - 1).toString());
      }
    }
    if (names.length > 1) {
      return "{" + names.join(", ") + "}";
    } else {
      return names[0];
    }
  }
  toTokenString(literalNames, symbolicNames) {
    const names = [];
    for (let i = 0; i < this.intervals.length; i++) {
      const existing = this.intervals[i];
      for (let j = existing.start; j < existing.stop; j++) {
        names.push(this.elementName(literalNames, symbolicNames, j));
      }
    }
    if (names.length > 1) {
      return "{" + names.join(", ") + "}";
    } else {
      return names[0];
    }
  }
  elementName(literalNames, symbolicNames, token) {
    if (token === Token.EOF) {
      return "<EOF>";
    } else if (token === Token.EPSILON) {
      return "<EPSILON>";
    } else {
      return literalNames[token] || symbolicNames[token];
    }
  }
  get length() {
    return this.intervals.map(interval => interval.length).reduce((acc, val) => acc + val);
  }
}
module.exports = {
  Interval,
  IntervalSet
};

/***/ }),
/* 15 */
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

/* Copyright (c) 2012-2017 The ANTLR Project. All rights reserved.
 * Use of this file is governed by the BSD 3-clause license that
 * can be found in the LICENSE.txt file in the project root.
 */

const {
  Token
} = __webpack_require__(10);
const {
  IntervalSet
} = __webpack_require__(14);
const {
  Predicate,
  PrecedencePredicate
} = __webpack_require__(13);

/**
 * An ATN transition between any two ATN states.  Subclasses define
 * atom, set, epsilon, action, predicate, rule transitions.
 *
 * <p>This is a one way link.  It emanates from a state (usually via a list of
 * transitions) and has a target state.</p>
 *
 * <p>Since we never have to change the ATN transitions once we construct it,
 * we can fix these transitions as specific classes. The DFA transitions
 * on the other hand need to update the labels as it adds transitions to
 * the states. We'll use the term Edge for the DFA to distinguish them from
 * ATN transitions.</p>
 */
class Transition {
  constructor(target) {
    // The target of this transition.
    if (target === undefined || target === null) {
      throw "target cannot be null.";
    }
    this.target = target;
    // Are we epsilon, action, sempred?
    this.isEpsilon = false;
    this.label = null;
  }
}

// constants for serialization

Transition.EPSILON = 1;
Transition.RANGE = 2;
Transition.RULE = 3;
// e.g., {isType(input.LT(1))}?
Transition.PREDICATE = 4;
Transition.ATOM = 5;
Transition.ACTION = 6;
// ~(A|B) or ~atom, wildcard, which convert to next 2
Transition.SET = 7;
Transition.NOT_SET = 8;
Transition.WILDCARD = 9;
Transition.PRECEDENCE = 10;
Transition.serializationNames = ["INVALID", "EPSILON", "RANGE", "RULE", "PREDICATE", "ATOM", "ACTION", "SET", "NOT_SET", "WILDCARD", "PRECEDENCE"];
Transition.serializationTypes = {
  EpsilonTransition: Transition.EPSILON,
  RangeTransition: Transition.RANGE,
  RuleTransition: Transition.RULE,
  PredicateTransition: Transition.PREDICATE,
  AtomTransition: Transition.ATOM,
  ActionTransition: Transition.ACTION,
  SetTransition: Transition.SET,
  NotSetTransition: Transition.NOT_SET,
  WildcardTransition: Transition.WILDCARD,
  PrecedencePredicateTransition: Transition.PRECEDENCE
};

// TODO: make all transitions sets? no, should remove set edges

class AtomTransition extends Transition {
  constructor(target, label) {
    super(target);
    // The token type or character value; or, signifies special label.
    this.label_ = label;
    this.label = this.makeLabel();
    this.serializationType = Transition.ATOM;
  }
  makeLabel() {
    const s = new IntervalSet();
    s.addOne(this.label_);
    return s;
  }
  matches(symbol, minVocabSymbol, maxVocabSymbol) {
    return this.label_ === symbol;
  }
  toString() {
    return this.label_;
  }
}
class RuleTransition extends Transition {
  constructor(ruleStart, ruleIndex, precedence, followState) {
    super(ruleStart);
    // ptr to the rule definition object for this rule ref
    this.ruleIndex = ruleIndex;
    this.precedence = precedence;
    // what node to begin computations following ref to rule
    this.followState = followState;
    this.serializationType = Transition.RULE;
    this.isEpsilon = true;
  }
  matches(symbol, minVocabSymbol, maxVocabSymbol) {
    return false;
  }
}
class EpsilonTransition extends Transition {
  constructor(target, outermostPrecedenceReturn) {
    super(target);
    this.serializationType = Transition.EPSILON;
    this.isEpsilon = true;
    this.outermostPrecedenceReturn = outermostPrecedenceReturn;
  }
  matches(symbol, minVocabSymbol, maxVocabSymbol) {
    return false;
  }
  toString() {
    return "epsilon";
  }
}
class RangeTransition extends Transition {
  constructor(target, start, stop) {
    super(target);
    this.serializationType = Transition.RANGE;
    this.start = start;
    this.stop = stop;
    this.label = this.makeLabel();
  }
  makeLabel() {
    const s = new IntervalSet();
    s.addRange(this.start, this.stop);
    return s;
  }
  matches(symbol, minVocabSymbol, maxVocabSymbol) {
    return symbol >= this.start && symbol <= this.stop;
  }
  toString() {
    return "'" + String.fromCharCode(this.start) + "'..'" + String.fromCharCode(this.stop) + "'";
  }
}
class AbstractPredicateTransition extends Transition {
  constructor(target) {
    super(target);
  }
}
class PredicateTransition extends AbstractPredicateTransition {
  constructor(target, ruleIndex, predIndex, isCtxDependent) {
    super(target);
    this.serializationType = Transition.PREDICATE;
    this.ruleIndex = ruleIndex;
    this.predIndex = predIndex;
    this.isCtxDependent = isCtxDependent; // e.g., $i ref in pred
    this.isEpsilon = true;
  }
  matches(symbol, minVocabSymbol, maxVocabSymbol) {
    return false;
  }
  getPredicate() {
    return new Predicate(this.ruleIndex, this.predIndex, this.isCtxDependent);
  }
  toString() {
    return "pred_" + this.ruleIndex + ":" + this.predIndex;
  }
}
class ActionTransition extends Transition {
  constructor(target, ruleIndex, actionIndex, isCtxDependent) {
    super(target);
    this.serializationType = Transition.ACTION;
    this.ruleIndex = ruleIndex;
    this.actionIndex = actionIndex === undefined ? -1 : actionIndex;
    this.isCtxDependent = isCtxDependent === undefined ? false : isCtxDependent; // e.g., $i ref in pred
    this.isEpsilon = true;
  }
  matches(symbol, minVocabSymbol, maxVocabSymbol) {
    return false;
  }
  toString() {
    return "action_" + this.ruleIndex + ":" + this.actionIndex;
  }
}

// A transition containing a set of values.
class SetTransition extends Transition {
  constructor(target, set) {
    super(target);
    this.serializationType = Transition.SET;
    if (set !== undefined && set !== null) {
      this.label = set;
    } else {
      this.label = new IntervalSet();
      this.label.addOne(Token.INVALID_TYPE);
    }
  }
  matches(symbol, minVocabSymbol, maxVocabSymbol) {
    return this.label.contains(symbol);
  }
  toString() {
    return this.label.toString();
  }
}
class NotSetTransition extends SetTransition {
  constructor(target, set) {
    super(target, set);
    this.serializationType = Transition.NOT_SET;
  }
  matches(symbol, minVocabSymbol, maxVocabSymbol) {
    return symbol >= minVocabSymbol && symbol <= maxVocabSymbol && !super.matches(symbol, minVocabSymbol, maxVocabSymbol);
  }
  toString() {
    return '~' + super.toString();
  }
}
class WildcardTransition extends Transition {
  constructor(target) {
    super(target);
    this.serializationType = Transition.WILDCARD;
  }
  matches(symbol, minVocabSymbol, maxVocabSymbol) {
    return symbol >= minVocabSymbol && symbol <= maxVocabSymbol;
  }
  toString() {
    return ".";
  }
}
class PrecedencePredicateTransition extends AbstractPredicateTransition {
  constructor(target, precedence) {
    super(target);
    this.serializationType = Transition.PRECEDENCE;
    this.precedence = precedence;
    this.isEpsilon = true;
  }
  matches(symbol, minVocabSymbol, maxVocabSymbol) {
    return false;
  }
  getPredicate() {
    return new PrecedencePredicate(this.precedence);
  }
  toString() {
    return this.precedence + " >= _p";
  }
}
module.exports = {
  Transition,
  AtomTransition,
  SetTransition,
  NotSetTransition,
  RuleTransition,
  ActionTransition,
  EpsilonTransition,
  RangeTransition,
  WildcardTransition,
  PredicateTransition,
  PrecedencePredicateTransition,
  AbstractPredicateTransition
};

/***/ }),
/* 16 */
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

/* Copyright (c) 2012-2017 The ANTLR Project. All rights reserved.
 * Use of this file is governed by the BSD 3-clause license that
 * can be found in the LICENSE.txt file in the project root.
 */

const RuleContext = __webpack_require__(17);
const {
  Hash,
  Map,
  equalArrays
} = __webpack_require__(9);
class PredictionContext {
  constructor(cachedHashCode) {
    this.cachedHashCode = cachedHashCode;
  }

  /**
   * Stores the computed hash code of this {@link PredictionContext}. The hash
   * code is computed in parts to match the following reference algorithm.
   *
   * <pre>
   * private int referenceHashCode() {
   * int hash = {@link MurmurHash//initialize MurmurHash.initialize}({@link
   * //INITIAL_HASH});
   *
   * for (int i = 0; i &lt; {@link //size()}; i++) {
   * hash = {@link MurmurHash//update MurmurHash.update}(hash, {@link //getParent
   * getParent}(i));
   * }
   *
   * for (int i = 0; i &lt; {@link //size()}; i++) {
   * hash = {@link MurmurHash//update MurmurHash.update}(hash, {@link
   * //getReturnState getReturnState}(i));
   * }
   *
   * hash = {@link MurmurHash//finish MurmurHash.finish}(hash, 2// {@link
   * //size()});
   * return hash;
   * }
   * </pre>
   * This means only the {@link //EMPTY} context is in set.
   */
  isEmpty() {
    return this === PredictionContext.EMPTY;
  }
  hasEmptyPath() {
    return this.getReturnState(this.length - 1) === PredictionContext.EMPTY_RETURN_STATE;
  }
  hashCode() {
    return this.cachedHashCode;
  }
  updateHashCode(hash) {
    hash.update(this.cachedHashCode);
  }
}

/**
 * Represents {@code $} in local context prediction, which means wildcard.
 * {@code//+x =//}.
 */
PredictionContext.EMPTY = null;

/**
 * Represents {@code $} in an array in full context mode, when {@code $}
 * doesn't mean wildcard: {@code $ + x = [$,x]}. Here,
 * {@code $} = {@link //EMPTY_RETURN_STATE}.
 */
PredictionContext.EMPTY_RETURN_STATE = 0x7FFFFFFF;
PredictionContext.globalNodeCount = 1;
PredictionContext.id = PredictionContext.globalNodeCount;

/*
function calculateHashString(parent, returnState) {
	return "" + parent + returnState;
}
*/

/**
 * Used to cache {@link PredictionContext} objects. Its used for the shared
 * context cash associated with contexts in DFA states. This cache
 * can be used for both lexers and parsers.
 */
class PredictionContextCache {
  constructor() {
    this.cache = new Map();
  }

  /**
   * Add a context to the cache and return it. If the context already exists,
   * return that one instead and do not add a new context to the cache.
   * Protect shared cache from unsafe thread access.
   */
  add(ctx) {
    if (ctx === PredictionContext.EMPTY) {
      return PredictionContext.EMPTY;
    }
    const existing = this.cache.get(ctx) || null;
    if (existing !== null) {
      return existing;
    }
    this.cache.put(ctx, ctx);
    return ctx;
  }
  get(ctx) {
    return this.cache.get(ctx) || null;
  }
  get length() {
    return this.cache.length;
  }
}
class SingletonPredictionContext extends PredictionContext {
  constructor(parent, returnState) {
    let hashCode = 0;
    const hash = new Hash();
    if (parent !== null) {
      hash.update(parent, returnState);
    } else {
      hash.update(1);
    }
    hashCode = hash.finish();
    super(hashCode);
    this.parentCtx = parent;
    this.returnState = returnState;
  }
  getParent(index) {
    return this.parentCtx;
  }
  getReturnState(index) {
    return this.returnState;
  }
  equals(other) {
    if (this === other) {
      return true;
    } else if (!(other instanceof SingletonPredictionContext)) {
      return false;
    } else if (this.hashCode() !== other.hashCode()) {
      return false; // can't be same if hash is different
    } else {
      if (this.returnState !== other.returnState) return false;else if (this.parentCtx == null) return other.parentCtx == null;else return this.parentCtx.equals(other.parentCtx);
    }
  }
  toString() {
    const up = this.parentCtx === null ? "" : this.parentCtx.toString();
    if (up.length === 0) {
      if (this.returnState === PredictionContext.EMPTY_RETURN_STATE) {
        return "$";
      } else {
        return "" + this.returnState;
      }
    } else {
      return "" + this.returnState + " " + up;
    }
  }
  get length() {
    return 1;
  }
  static create(parent, returnState) {
    if (returnState === PredictionContext.EMPTY_RETURN_STATE && parent === null) {
      // someone can pass in the bits of an array ctx that mean $
      return PredictionContext.EMPTY;
    } else {
      return new SingletonPredictionContext(parent, returnState);
    }
  }
}
class EmptyPredictionContext extends SingletonPredictionContext {
  constructor() {
    super(null, PredictionContext.EMPTY_RETURN_STATE);
  }
  isEmpty() {
    return true;
  }
  getParent(index) {
    return null;
  }
  getReturnState(index) {
    return this.returnState;
  }
  equals(other) {
    return this === other;
  }
  toString() {
    return "$";
  }
}
PredictionContext.EMPTY = new EmptyPredictionContext();
class ArrayPredictionContext extends PredictionContext {
  constructor(parents, returnStates) {
    /**
     * Parent can be null only if full ctx mode and we make an array
     * from {@link //EMPTY} and non-empty. We merge {@link //EMPTY} by using
     * null parent and
     * returnState == {@link //EMPTY_RETURN_STATE}.
     */
    const h = new Hash();
    h.update(parents, returnStates);
    const hashCode = h.finish();
    super(hashCode);
    this.parents = parents;
    this.returnStates = returnStates;
    return this;
  }
  isEmpty() {
    // since EMPTY_RETURN_STATE can only appear in the last position, we
    // don't need to verify that size==1
    return this.returnStates[0] === PredictionContext.EMPTY_RETURN_STATE;
  }
  getParent(index) {
    return this.parents[index];
  }
  getReturnState(index) {
    return this.returnStates[index];
  }
  equals(other) {
    if (this === other) {
      return true;
    } else if (!(other instanceof ArrayPredictionContext)) {
      return false;
    } else if (this.hashCode() !== other.hashCode()) {
      return false; // can't be same if hash is different
    } else {
      return equalArrays(this.returnStates, other.returnStates) && equalArrays(this.parents, other.parents);
    }
  }
  toString() {
    if (this.isEmpty()) {
      return "[]";
    } else {
      let s = "[";
      for (let i = 0; i < this.returnStates.length; i++) {
        if (i > 0) {
          s = s + ", ";
        }
        if (this.returnStates[i] === PredictionContext.EMPTY_RETURN_STATE) {
          s = s + "$";
          continue;
        }
        s = s + this.returnStates[i];
        if (this.parents[i] !== null) {
          s = s + " " + this.parents[i];
        } else {
          s = s + "null";
        }
      }
      return s + "]";
    }
  }
  get length() {
    return this.returnStates.length;
  }
}

/**
 * Convert a {@link RuleContext} tree to a {@link PredictionContext} graph.
 * Return {@link //EMPTY} if {@code outerContext} is empty or null.
 */
function predictionContextFromRuleContext(atn, outerContext) {
  if (outerContext === undefined || outerContext === null) {
    outerContext = RuleContext.EMPTY;
  }
  // if we are in RuleContext of start rule, s, then PredictionContext
  // is EMPTY. Nobody called us. (if we are empty, return empty)
  if (outerContext.parentCtx === null || outerContext === RuleContext.EMPTY) {
    return PredictionContext.EMPTY;
  }
  // If we have a parent, convert it to a PredictionContext graph
  const parent = predictionContextFromRuleContext(atn, outerContext.parentCtx);
  const state = atn.states[outerContext.invokingState];
  const transition = state.transitions[0];
  return SingletonPredictionContext.create(parent, transition.followState.stateNumber);
}
/*
function calculateListsHashString(parents, returnStates) {
	const s = "";
	parents.map(function(p) {
		s = s + p;
	});
	returnStates.map(function(r) {
		s = s + r;
	});
	return s;
}
*/
function merge(a, b, rootIsWildcard, mergeCache) {
  // share same graph if both same
  if (a === b) {
    return a;
  }
  if (a instanceof SingletonPredictionContext && b instanceof SingletonPredictionContext) {
    return mergeSingletons(a, b, rootIsWildcard, mergeCache);
  }
  // At least one of a or b is array
  // If one is $ and rootIsWildcard, return $ as// wildcard
  if (rootIsWildcard) {
    if (a instanceof EmptyPredictionContext) {
      return a;
    }
    if (b instanceof EmptyPredictionContext) {
      return b;
    }
  }
  // convert singleton so both are arrays to normalize
  if (a instanceof SingletonPredictionContext) {
    a = new ArrayPredictionContext([a.getParent()], [a.returnState]);
  }
  if (b instanceof SingletonPredictionContext) {
    b = new ArrayPredictionContext([b.getParent()], [b.returnState]);
  }
  return mergeArrays(a, b, rootIsWildcard, mergeCache);
}

/**
 * Merge two {@link SingletonPredictionContext} instances.
 *
 * <p>Stack tops equal, parents merge is same; return left graph.<br>
 * <embed src="images/SingletonMerge_SameRootSamePar.svg"
 * type="image/svg+xml"/></p>
 *
 * <p>Same stack top, parents differ; merge parents giving array node, then
 * remainders of those graphs. A new root node is created to point to the
 * merged parents.<br>
 * <embed src="images/SingletonMerge_SameRootDiffPar.svg"
 * type="image/svg+xml"/></p>
 *
 * <p>Different stack tops pointing to same parent. Make array node for the
 * root where both element in the root point to the same (original)
 * parent.<br>
 * <embed src="images/SingletonMerge_DiffRootSamePar.svg"
 * type="image/svg+xml"/></p>
 *
 * <p>Different stack tops pointing to different parents. Make array node for
 * the root where each element points to the corresponding original
 * parent.<br>
 * <embed src="images/SingletonMerge_DiffRootDiffPar.svg"
 * type="image/svg+xml"/></p>
 *
 * @param a the first {@link SingletonPredictionContext}
 * @param b the second {@link SingletonPredictionContext}
 * @param rootIsWildcard {@code true} if this is a local-context merge,
 * otherwise false to indicate a full-context merge
 * @param mergeCache
 */
function mergeSingletons(a, b, rootIsWildcard, mergeCache) {
  if (mergeCache !== null) {
    let previous = mergeCache.get(a, b);
    if (previous !== null) {
      return previous;
    }
    previous = mergeCache.get(b, a);
    if (previous !== null) {
      return previous;
    }
  }
  const rootMerge = mergeRoot(a, b, rootIsWildcard);
  if (rootMerge !== null) {
    if (mergeCache !== null) {
      mergeCache.set(a, b, rootMerge);
    }
    return rootMerge;
  }
  if (a.returnState === b.returnState) {
    const parent = merge(a.parentCtx, b.parentCtx, rootIsWildcard, mergeCache);
    // if parent is same as existing a or b parent or reduced to a parent,
    // return it
    if (parent === a.parentCtx) {
      return a; // ax + bx = ax, if a=b
    }
    if (parent === b.parentCtx) {
      return b; // ax + bx = bx, if a=b
    }
    // else: ax + ay = a'[x,y]
    // merge parents x and y, giving array node with x,y then remainders
    // of those graphs. dup a, a' points at merged array
    // new joined parent so create new singleton pointing to it, a'
    const spc = SingletonPredictionContext.create(parent, a.returnState);
    if (mergeCache !== null) {
      mergeCache.set(a, b, spc);
    }
    return spc;
  } else {
    // a != b payloads differ
    // see if we can collapse parents due to $+x parents if local ctx
    let singleParent = null;
    if (a === b || a.parentCtx !== null && a.parentCtx === b.parentCtx) {
      // ax +
      // bx =
      // [a,b]x
      singleParent = a.parentCtx;
    }
    if (singleParent !== null) {
      // parents are same
      // sort payloads and use same parent
      const payloads = [a.returnState, b.returnState];
      if (a.returnState > b.returnState) {
        payloads[0] = b.returnState;
        payloads[1] = a.returnState;
      }
      const parents = [singleParent, singleParent];
      const apc = new ArrayPredictionContext(parents, payloads);
      if (mergeCache !== null) {
        mergeCache.set(a, b, apc);
      }
      return apc;
    }
    // parents differ and can't merge them. Just pack together
    // into array; can't merge.
    // ax + by = [ax,by]
    const payloads = [a.returnState, b.returnState];
    let parents = [a.parentCtx, b.parentCtx];
    if (a.returnState > b.returnState) {
      // sort by payload
      payloads[0] = b.returnState;
      payloads[1] = a.returnState;
      parents = [b.parentCtx, a.parentCtx];
    }
    const a_ = new ArrayPredictionContext(parents, payloads);
    if (mergeCache !== null) {
      mergeCache.set(a, b, a_);
    }
    return a_;
  }
}

/**
 * Handle case where at least one of {@code a} or {@code b} is
 * {@link //EMPTY}. In the following diagrams, the symbol {@code $} is used
 * to represent {@link //EMPTY}.
 *
 * <h2>Local-Context Merges</h2>
 *
 * <p>These local-context merge operations are used when {@code rootIsWildcard}
 * is true.</p>
 *
 * <p>{@link //EMPTY} is superset of any graph; return {@link //EMPTY}.<br>
 * <embed src="images/LocalMerge_EmptyRoot.svg" type="image/svg+xml"/></p>
 *
 * <p>{@link //EMPTY} and anything is {@code //EMPTY}, so merged parent is
 * {@code //EMPTY}; return left graph.<br>
 * <embed src="images/LocalMerge_EmptyParent.svg" type="image/svg+xml"/></p>
 *
 * <p>Special case of last merge if local context.<br>
 * <embed src="images/LocalMerge_DiffRoots.svg" type="image/svg+xml"/></p>
 *
 * <h2>Full-Context Merges</h2>
 *
 * <p>These full-context merge operations are used when {@code rootIsWildcard}
 * is false.</p>
 *
 * <p><embed src="images/FullMerge_EmptyRoots.svg" type="image/svg+xml"/></p>
 *
 * <p>Must keep all contexts; {@link //EMPTY} in array is a special value (and
 * null parent).<br>
 * <embed src="images/FullMerge_EmptyRoot.svg" type="image/svg+xml"/></p>
 *
 * <p><embed src="images/FullMerge_SameRoot.svg" type="image/svg+xml"/></p>
 *
 * @param a the first {@link SingletonPredictionContext}
 * @param b the second {@link SingletonPredictionContext}
 * @param rootIsWildcard {@code true} if this is a local-context merge,
 * otherwise false to indicate a full-context merge
 */
function mergeRoot(a, b, rootIsWildcard) {
  if (rootIsWildcard) {
    if (a === PredictionContext.EMPTY) {
      return PredictionContext.EMPTY; // // + b =//
    }
    if (b === PredictionContext.EMPTY) {
      return PredictionContext.EMPTY; // a +// =//
    }
  } else {
    if (a === PredictionContext.EMPTY && b === PredictionContext.EMPTY) {
      return PredictionContext.EMPTY; // $ + $ = $
    } else if (a === PredictionContext.EMPTY) {
      // $ + x = [$,x]
      const payloads = [b.returnState, PredictionContext.EMPTY_RETURN_STATE];
      const parents = [b.parentCtx, null];
      return new ArrayPredictionContext(parents, payloads);
    } else if (b === PredictionContext.EMPTY) {
      // x + $ = [$,x] ($ is always first if present)
      const payloads = [a.returnState, PredictionContext.EMPTY_RETURN_STATE];
      const parents = [a.parentCtx, null];
      return new ArrayPredictionContext(parents, payloads);
    }
  }
  return null;
}

/**
 * Merge two {@link ArrayPredictionContext} instances.
 *
 * <p>Different tops, different parents.<br>
 * <embed src="images/ArrayMerge_DiffTopDiffPar.svg" type="image/svg+xml"/></p>
 *
 * <p>Shared top, same parents.<br>
 * <embed src="images/ArrayMerge_ShareTopSamePar.svg" type="image/svg+xml"/></p>
 *
 * <p>Shared top, different parents.<br>
 * <embed src="images/ArrayMerge_ShareTopDiffPar.svg" type="image/svg+xml"/></p>
 *
 * <p>Shared top, all shared parents.<br>
 * <embed src="images/ArrayMerge_ShareTopSharePar.svg"
 * type="image/svg+xml"/></p>
 *
 * <p>Equal tops, merge parents and reduce top to
 * {@link SingletonPredictionContext}.<br>
 * <embed src="images/ArrayMerge_EqualTop.svg" type="image/svg+xml"/></p>
 */
function mergeArrays(a, b, rootIsWildcard, mergeCache) {
  if (mergeCache !== null) {
    let previous = mergeCache.get(a, b);
    if (previous !== null) {
      return previous;
    }
    previous = mergeCache.get(b, a);
    if (previous !== null) {
      return previous;
    }
  }
  // merge sorted payloads a + b => M
  let i = 0; // walks a
  let j = 0; // walks b
  let k = 0; // walks target M array

  let mergedReturnStates = [];
  let mergedParents = [];
  // walk and merge to yield mergedParents, mergedReturnStates
  while (i < a.returnStates.length && j < b.returnStates.length) {
    const a_parent = a.parents[i];
    const b_parent = b.parents[j];
    if (a.returnStates[i] === b.returnStates[j]) {
      // same payload (stack tops are equal), must yield merged singleton
      const payload = a.returnStates[i];
      // $+$ = $
      const bothDollars = payload === PredictionContext.EMPTY_RETURN_STATE && a_parent === null && b_parent === null;
      const ax_ax = a_parent !== null && b_parent !== null && a_parent === b_parent; // ax+ax
      // ->
      // ax
      if (bothDollars || ax_ax) {
        mergedParents[k] = a_parent; // choose left
        mergedReturnStates[k] = payload;
      } else {
        // ax+ay -> a'[x,y]
        mergedParents[k] = merge(a_parent, b_parent, rootIsWildcard, mergeCache);
        mergedReturnStates[k] = payload;
      }
      i += 1; // hop over left one as usual
      j += 1; // but also skip one in right side since we merge
    } else if (a.returnStates[i] < b.returnStates[j]) {
      // copy a[i] to M
      mergedParents[k] = a_parent;
      mergedReturnStates[k] = a.returnStates[i];
      i += 1;
    } else {
      // b > a, copy b[j] to M
      mergedParents[k] = b_parent;
      mergedReturnStates[k] = b.returnStates[j];
      j += 1;
    }
    k += 1;
  }
  // copy over any payloads remaining in either array
  if (i < a.returnStates.length) {
    for (let p = i; p < a.returnStates.length; p++) {
      mergedParents[k] = a.parents[p];
      mergedReturnStates[k] = a.returnStates[p];
      k += 1;
    }
  } else {
    for (let p = j; p < b.returnStates.length; p++) {
      mergedParents[k] = b.parents[p];
      mergedReturnStates[k] = b.returnStates[p];
      k += 1;
    }
  }
  // trim merged if we combined a few that had same stack tops
  if (k < mergedParents.length) {
    // write index < last position; trim
    if (k === 1) {
      // for just one merged element, return singleton top
      const a_ = SingletonPredictionContext.create(mergedParents[0], mergedReturnStates[0]);
      if (mergeCache !== null) {
        mergeCache.set(a, b, a_);
      }
      return a_;
    }
    mergedParents = mergedParents.slice(0, k);
    mergedReturnStates = mergedReturnStates.slice(0, k);
  }
  const M = new ArrayPredictionContext(mergedParents, mergedReturnStates);

  // if we created same array as a or b, return that instead
  // TODO: track whether this is possible above during merge sort for speed
  if (M === a) {
    if (mergeCache !== null) {
      mergeCache.set(a, b, a);
    }
    return a;
  }
  if (M === b) {
    if (mergeCache !== null) {
      mergeCache.set(a, b, b);
    }
    return b;
  }
  combineCommonParents(mergedParents);
  if (mergeCache !== null) {
    mergeCache.set(a, b, M);
  }
  return M;
}

/**
 * Make pass over all <em>M</em> {@code parents}; merge any {@code equals()}
 * ones.
 */
function combineCommonParents(parents) {
  const uniqueParents = new Map();
  for (let p = 0; p < parents.length; p++) {
    const parent = parents[p];
    if (!uniqueParents.containsKey(parent)) {
      uniqueParents.put(parent, parent);
    }
  }
  for (let q = 0; q < parents.length; q++) {
    parents[q] = uniqueParents.get(parents[q]);
  }
}
function getCachedPredictionContext(context, contextCache, visited) {
  if (context.isEmpty()) {
    return context;
  }
  let existing = visited.get(context) || null;
  if (existing !== null) {
    return existing;
  }
  existing = contextCache.get(context);
  if (existing !== null) {
    visited.put(context, existing);
    return existing;
  }
  let changed = false;
  let parents = [];
  for (let i = 0; i < parents.length; i++) {
    const parent = getCachedPredictionContext(context.getParent(i), contextCache, visited);
    if (changed || parent !== context.getParent(i)) {
      if (!changed) {
        parents = [];
        for (let j = 0; j < context.length; j++) {
          parents[j] = context.getParent(j);
        }
        changed = true;
      }
      parents[i] = parent;
    }
  }
  if (!changed) {
    contextCache.add(context);
    visited.put(context, context);
    return context;
  }
  let updated = null;
  if (parents.length === 0) {
    updated = PredictionContext.EMPTY;
  } else if (parents.length === 1) {
    updated = SingletonPredictionContext.create(parents[0], context.getReturnState(0));
  } else {
    updated = new ArrayPredictionContext(parents, context.returnStates);
  }
  contextCache.add(updated);
  visited.put(updated, updated);
  visited.put(context, updated);
  return updated;
}

// ter's recursive version of Sam's getAllNodes()
function getAllContextNodes(context, nodes, visited) {
  if (nodes === null) {
    nodes = [];
    return getAllContextNodes(context, nodes, visited);
  } else if (visited === null) {
    visited = new Map();
    return getAllContextNodes(context, nodes, visited);
  } else {
    if (context === null || visited.containsKey(context)) {
      return nodes;
    }
    visited.put(context, context);
    nodes.push(context);
    for (let i = 0; i < context.length; i++) {
      getAllContextNodes(context.getParent(i), nodes, visited);
    }
    return nodes;
  }
}
module.exports = {
  merge,
  PredictionContext,
  PredictionContextCache,
  SingletonPredictionContext,
  predictionContextFromRuleContext,
  getCachedPredictionContext
};

/***/ }),
/* 17 */
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

/* Copyright (c) 2012-2017 The ANTLR Project. All rights reserved.
 * Use of this file is governed by the BSD 3-clause license that
 * can be found in the LICENSE.txt file in the project root.
 */

const {
  RuleNode
} = __webpack_require__(18);
const {
  INVALID_INTERVAL
} = __webpack_require__(18);
const Trees = __webpack_require__(19);
class RuleContext extends RuleNode {
  /** A rule context is a record of a single rule invocation. It knows
   * which context invoked it, if any. If there is no parent context, then
   * naturally the invoking state is not valid.  The parent link
   * provides a chain upwards from the current rule invocation to the root
   * of the invocation tree, forming a stack. We actually carry no
   * information about the rule associated with this context (except
   * when parsing). We keep only the state number of the invoking state from
   * the ATN submachine that invoked this. Contrast this with the s
   * pointer inside ParserRuleContext that tracks the current state
   * being "executed" for the current rule.
   *
   * The parent contexts are useful for computing lookahead sets and
   * getting error information.
   *
   * These objects are used during parsing and prediction.
   * For the special case of parsers, we use the subclass
   * ParserRuleContext.
   *
   * @see ParserRuleContext
   */
  constructor(parent, invokingState) {
    // What context invoked this rule?
    super();
    this.parentCtx = parent || null;
    /**
     * What state invoked the rule associated with this context?
     * The "return address" is the followState of invokingState
     * If parent is null, this should be -1.
     */
    this.invokingState = invokingState || -1;
  }
  depth() {
    let n = 0;
    let p = this;
    while (p !== null) {
      p = p.parentCtx;
      n += 1;
    }
    return n;
  }

  /**
   * A context is empty if there is no invoking state; meaning nobody call
   * current context.
   */
  isEmpty() {
    return this.invokingState === -1;
  }

  // satisfy the ParseTree / SyntaxTree interface
  getSourceInterval() {
    return INVALID_INTERVAL;
  }
  getRuleContext() {
    return this;
  }
  getPayload() {
    return this;
  }

  /**
   * Return the combined text of all child nodes. This method only considers
   * tokens which have been added to the parse tree.
   * <p>
   * Since tokens on hidden channels (e.g. whitespace or comments) are not
   * added to the parse trees, they will not appear in the output of this
   * method.
   */
  getText() {
    if (this.getChildCount() === 0) {
      return "";
    } else {
      return this.children.map(function (child) {
        return child.getText();
      }).join("");
    }
  }

  /**
   * For rule associated with this parse tree internal node, return
   * the outer alternative number used to match the input. Default
   * implementation does not compute nor store this alt num. Create
   * a subclass of ParserRuleContext with backing field and set
   * option contextSuperClass.
   * to set it.
   */
  getAltNumber() {
    // use constant value of ATN.INVALID_ALT_NUMBER to avoid circular dependency
    return 0;
  }

  /**
   * Set the outer alternative number for this context node. Default
   * implementation does nothing to avoid backing field overhead for
   * trees that don't need it.  Create
   * a subclass of ParserRuleContext with backing field and set
   * option contextSuperClass.
   */
  setAltNumber(altNumber) {}
  getChild(i) {
    return null;
  }
  getChildCount() {
    return 0;
  }
  accept(visitor) {
    return visitor.visitChildren(this);
  }

  /**
   * Print out a whole tree, not just a node, in LISP format
   * (root child1 .. childN). Print just a node if this is a leaf.
   */
  toStringTree(ruleNames, recog) {
    return Trees.toStringTree(this, ruleNames, recog);
  }
  toString(ruleNames, stop) {
    ruleNames = ruleNames || null;
    stop = stop || null;
    let p = this;
    let s = "[";
    while (p !== null && p !== stop) {
      if (ruleNames === null) {
        if (!p.isEmpty()) {
          s += p.invokingState;
        }
      } else {
        const ri = p.ruleIndex;
        const ruleName = ri >= 0 && ri < ruleNames.length ? ruleNames[ri] : "" + ri;
        s += ruleName;
      }
      if (p.parentCtx !== null && (ruleNames !== null || !p.parentCtx.isEmpty())) {
        s += " ";
      }
      p = p.parentCtx;
    }
    s += "]";
    return s;
  }
}
module.exports = RuleContext;

/***/ }),
/* 18 */
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

/* Copyright (c) 2012-2017 The ANTLR Project. All rights reserved.
 * Use of this file is governed by the BSD 3-clause license that
 * can be found in the LICENSE.txt file in the project root.
 */

const {
  Token
} = __webpack_require__(10);
const {
  Interval
} = __webpack_require__(14);
const INVALID_INTERVAL = new Interval(-1, -2);

/**
 * The basic notion of a tree has a parent, a payload, and a list of children.
 * It is the most abstract interface for all the trees used by ANTLR.
 */
class Tree {}
class SyntaxTree extends Tree {
  constructor() {
    super();
  }
}
class ParseTree extends SyntaxTree {
  constructor() {
    super();
  }
}
class RuleNode extends ParseTree {
  constructor() {
    super();
  }
  getRuleContext() {
    throw new Error("missing interface implementation");
  }
}
class TerminalNode extends ParseTree {
  constructor() {
    super();
  }
}
class ErrorNode extends TerminalNode {
  constructor() {
    super();
  }
}
class ParseTreeVisitor {
  visit(ctx) {
    if (Array.isArray(ctx)) {
      return ctx.map(function (child) {
        return child.accept(this);
      }, this);
    } else {
      return ctx.accept(this);
    }
  }
  visitChildren(ctx) {
    if (ctx.children) {
      return this.visit(ctx.children);
    } else {
      return null;
    }
  }
  visitTerminal(node) {}
  visitErrorNode(node) {}
}
class ParseTreeListener {
  visitTerminal(node) {}
  visitErrorNode(node) {}
  enterEveryRule(node) {}
  exitEveryRule(node) {}
}
class TerminalNodeImpl extends TerminalNode {
  constructor(symbol) {
    super();
    this.parentCtx = null;
    this.symbol = symbol;
  }
  getChild(i) {
    return null;
  }
  getSymbol() {
    return this.symbol;
  }
  getParent() {
    return this.parentCtx;
  }
  getPayload() {
    return this.symbol;
  }
  getSourceInterval() {
    if (this.symbol === null) {
      return INVALID_INTERVAL;
    }
    const tokenIndex = this.symbol.tokenIndex;
    return new Interval(tokenIndex, tokenIndex);
  }
  getChildCount() {
    return 0;
  }
  accept(visitor) {
    return visitor.visitTerminal(this);
  }
  getText() {
    return this.symbol.text;
  }
  toString() {
    if (this.symbol.type === Token.EOF) {
      return "<EOF>";
    } else {
      return this.symbol.text;
    }
  }
}

/**
 * Represents a token that was consumed during resynchronization
 * rather than during a valid match operation. For example,
 * we will create this kind of a node during single token insertion
 * and deletion as well as during "consume until error recovery set"
 * upon no viable alternative exceptions.
 */
class ErrorNodeImpl extends TerminalNodeImpl {
  constructor(token) {
    super(token);
  }
  isErrorNode() {
    return true;
  }
  accept(visitor) {
    return visitor.visitErrorNode(this);
  }
}
class ParseTreeWalker {
  /**
   * Performs a walk on the given parse tree starting at the root and going down recursively
   * with depth-first search. On each node, {@link ParseTreeWalker//enterRule} is called before
   * recursively walking down into child nodes, then
   * {@link ParseTreeWalker//exitRule} is called after the recursive call to wind up.
   * @param listener The listener used by the walker to process grammar rules
   * @param t The parse tree to be walked on
   */
  walk(listener, t) {
    const errorNode = t instanceof ErrorNode || t.isErrorNode !== undefined && t.isErrorNode();
    if (errorNode) {
      listener.visitErrorNode(t);
    } else if (t instanceof TerminalNode) {
      listener.visitTerminal(t);
    } else {
      this.enterRule(listener, t);
      for (let i = 0; i < t.getChildCount(); i++) {
        const child = t.getChild(i);
        this.walk(listener, child);
      }
      this.exitRule(listener, t);
    }
  }

  /**
   * Enters a grammar rule by first triggering the generic event {@link ParseTreeListener//enterEveryRule}
   * then by triggering the event specific to the given parse tree node
   * @param listener The listener responding to the trigger events
   * @param r The grammar rule containing the rule context
   */
  enterRule(listener, r) {
    const ctx = r.getRuleContext();
    listener.enterEveryRule(ctx);
    ctx.enterRule(listener);
  }

  /**
   * Exits a grammar rule by first triggering the event specific to the given parse tree node
   * then by triggering the generic event {@link ParseTreeListener//exitEveryRule}
   * @param listener The listener responding to the trigger events
   * @param r The grammar rule containing the rule context
   */
  exitRule(listener, r) {
    const ctx = r.getRuleContext();
    ctx.exitRule(listener);
    listener.exitEveryRule(ctx);
  }
}
ParseTreeWalker.DEFAULT = new ParseTreeWalker();
module.exports = {
  RuleNode,
  ErrorNode,
  TerminalNode,
  ErrorNodeImpl,
  TerminalNodeImpl,
  ParseTreeListener,
  ParseTreeVisitor,
  ParseTreeWalker,
  INVALID_INTERVAL
};

/***/ }),
/* 19 */
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

/* Copyright (c) 2012-2017 The ANTLR Project. All rights reserved.
 * Use of this file is governed by the BSD 3-clause license that
 * can be found in the LICENSE.txt file in the project root.
 */

const Utils = __webpack_require__(9);
const {
  Token
} = __webpack_require__(10);
const {
  ErrorNode,
  TerminalNode,
  RuleNode
} = __webpack_require__(18);

/** A set of utility routines useful for all kinds of ANTLR trees. */
const Trees = {
  /**
   * Print out a whole tree in LISP form. {@link //getNodeText} is used on the
   *  node payloads to get the text for the nodes.  Detect
   *  parse trees and extract data appropriately.
   */
  toStringTree: function (tree, ruleNames, recog) {
    ruleNames = ruleNames || null;
    recog = recog || null;
    if (recog !== null) {
      ruleNames = recog.ruleNames;
    }
    let s = Trees.getNodeText(tree, ruleNames);
    s = Utils.escapeWhitespace(s, false);
    const c = tree.getChildCount();
    if (c === 0) {
      return s;
    }
    let res = "(" + s + ' ';
    if (c > 0) {
      s = Trees.toStringTree(tree.getChild(0), ruleNames);
      res = res.concat(s);
    }
    for (let i = 1; i < c; i++) {
      s = Trees.toStringTree(tree.getChild(i), ruleNames);
      res = res.concat(' ' + s);
    }
    res = res.concat(")");
    return res;
  },
  getNodeText: function (t, ruleNames, recog) {
    ruleNames = ruleNames || null;
    recog = recog || null;
    if (recog !== null) {
      ruleNames = recog.ruleNames;
    }
    if (ruleNames !== null) {
      if (t instanceof RuleNode) {
        const context = t.getRuleContext();
        const altNumber = context.getAltNumber();
        // use const value of ATN.INVALID_ALT_NUMBER to avoid circular dependency
        if (altNumber != 0) {
          return ruleNames[t.ruleIndex] + ":" + altNumber;
        }
        return ruleNames[t.ruleIndex];
      } else if (t instanceof ErrorNode) {
        return t.toString();
      } else if (t instanceof TerminalNode) {
        if (t.symbol !== null) {
          return t.symbol.text;
        }
      }
    }
    // no recog for rule names
    const payload = t.getPayload();
    if (payload instanceof Token) {
      return payload.text;
    }
    return t.getPayload().toString();
  },
  /**
   * Return ordered list of all children of this node
   */
  getChildren: function (t) {
    const list = [];
    for (let i = 0; i < t.getChildCount(); i++) {
      list.push(t.getChild(i));
    }
    return list;
  },
  /**
   * Return a list of all ancestors of this node.  The first node of
   * list is the root and the last is the parent of this node.
   */
  getAncestors: function (t) {
    let ancestors = [];
    t = t.getParent();
    while (t !== null) {
      ancestors = [t].concat(ancestors);
      t = t.getParent();
    }
    return ancestors;
  },
  findAllTokenNodes: function (t, ttype) {
    return Trees.findAllNodes(t, ttype, true);
  },
  findAllRuleNodes: function (t, ruleIndex) {
    return Trees.findAllNodes(t, ruleIndex, false);
  },
  findAllNodes: function (t, index, findTokens) {
    const nodes = [];
    Trees._findAllNodes(t, index, findTokens, nodes);
    return nodes;
  },
  _findAllNodes: function (t, index, findTokens, nodes) {
    // check this node (the root) first
    if (findTokens && t instanceof TerminalNode) {
      if (t.symbol.type === index) {
        nodes.push(t);
      }
    } else if (!findTokens && t instanceof RuleNode) {
      if (t.ruleIndex === index) {
        nodes.push(t);
      }
    }
    // check children
    for (let i = 0; i < t.getChildCount(); i++) {
      Trees._findAllNodes(t.getChild(i), index, findTokens, nodes);
    }
  },
  descendants: function (t) {
    let nodes = [t];
    for (let i = 0; i < t.getChildCount(); i++) {
      nodes = nodes.concat(Trees.descendants(t.getChild(i)));
    }
    return nodes;
  }
};
module.exports = Trees;

/***/ }),
/* 20 */
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

/* Copyright (c) 2012-2017 The ANTLR Project. All rights reserved.
 * Use of this file is governed by the BSD 3-clause license that
 * can be found in the LICENSE.txt file in the project root.
 */

const {
  Token
} = __webpack_require__(10);
const ATN = __webpack_require__(7);
const ATNType = __webpack_require__(21);
const {
  ATNState,
  BasicState,
  DecisionState,
  BlockStartState,
  BlockEndState,
  LoopEndState,
  RuleStartState,
  RuleStopState,
  TokensStartState,
  PlusLoopbackState,
  StarLoopbackState,
  StarLoopEntryState,
  PlusBlockStartState,
  StarBlockStartState,
  BasicBlockStartState
} = __webpack_require__(12);
const {
  Transition,
  AtomTransition,
  SetTransition,
  NotSetTransition,
  RuleTransition,
  RangeTransition,
  ActionTransition,
  EpsilonTransition,
  WildcardTransition,
  PredicateTransition,
  PrecedencePredicateTransition
} = __webpack_require__(15);
const {
  IntervalSet
} = __webpack_require__(14);
const ATNDeserializationOptions = __webpack_require__(22);
const {
  LexerActionType,
  LexerSkipAction,
  LexerChannelAction,
  LexerCustomAction,
  LexerMoreAction,
  LexerTypeAction,
  LexerPushModeAction,
  LexerPopModeAction,
  LexerModeAction
} = __webpack_require__(23);

// This is the earliest supported serialized UUID.
// stick to serialized version for now, we don't need a UUID instance
const BASE_SERIALIZED_UUID = "AADB8D7E-AEEF-4415-AD2B-8204D6CF042E";

//
// This UUID indicates the serialized ATN contains two sets of
// IntervalSets, where the second set's values are encoded as
// 32-bit integers to support the full Unicode SMP range up to U+10FFFF.
//
const ADDED_UNICODE_SMP = "59627784-3BE5-417A-B9EB-8131A7286089";

// This list contains all of the currently supported UUIDs, ordered by when
// the feature first appeared in this branch.
const SUPPORTED_UUIDS = [BASE_SERIALIZED_UUID, ADDED_UNICODE_SMP];
const SERIALIZED_VERSION = 3;

// This is the current serialized UUID.
const SERIALIZED_UUID = ADDED_UNICODE_SMP;
function initArray(length, value) {
  const tmp = [];
  tmp[length - 1] = value;
  return tmp.map(function (i) {
    return value;
  });
}
class ATNDeserializer {
  constructor(options) {
    if (options === undefined || options === null) {
      options = ATNDeserializationOptions.defaultOptions;
    }
    this.deserializationOptions = options;
    this.stateFactories = null;
    this.actionFactories = null;
  }

  /**
   * Determines if a particular serialized representation of an ATN supports
   * a particular feature, identified by the {@link UUID} used for serializing
   * the ATN at the time the feature was first introduced.
   *
   * @param feature The {@link UUID} marking the first time the feature was
   * supported in the serialized ATN.
   * @param actualUuid The {@link UUID} of the actual serialized ATN which is
   * currently being deserialized.
   * @return {@code true} if the {@code actualUuid} value represents a
   * serialized ATN at or after the feature identified by {@code feature} was
   * introduced; otherwise, {@code false}.
  */
  isFeatureSupported(feature, actualUuid) {
    const idx1 = SUPPORTED_UUIDS.indexOf(feature);
    if (idx1 < 0) {
      return false;
    }
    const idx2 = SUPPORTED_UUIDS.indexOf(actualUuid);
    return idx2 >= idx1;
  }
  deserialize(data) {
    this.reset(data);
    this.checkVersion();
    this.checkUUID();
    const atn = this.readATN();
    this.readStates(atn);
    this.readRules(atn);
    this.readModes(atn);
    const sets = [];
    // First, deserialize sets with 16-bit arguments <= U+FFFF.
    this.readSets(atn, sets, this.readInt.bind(this));
    // Next, if the ATN was serialized with the Unicode SMP feature,
    // deserialize sets with 32-bit arguments <= U+10FFFF.
    if (this.isFeatureSupported(ADDED_UNICODE_SMP, this.uuid)) {
      this.readSets(atn, sets, this.readInt32.bind(this));
    }
    this.readEdges(atn, sets);
    this.readDecisions(atn);
    this.readLexerActions(atn);
    this.markPrecedenceDecisions(atn);
    this.verifyATN(atn);
    if (this.deserializationOptions.generateRuleBypassTransitions && atn.grammarType === ATNType.PARSER) {
      this.generateRuleBypassTransitions(atn);
      // re-verify after modification
      this.verifyATN(atn);
    }
    return atn;
  }
  reset(data) {
    const adjust = function (c) {
      const v = c.charCodeAt(0);
      return v > 1 ? v - 2 : v + 65534;
    };
    const temp = data.split("").map(adjust);
    // don't adjust the first value since that's the version number
    temp[0] = data.charCodeAt(0);
    this.data = temp;
    this.pos = 0;
  }
  checkVersion() {
    const version = this.readInt();
    if (version !== SERIALIZED_VERSION) {
      throw "Could not deserialize ATN with version " + version + " (expected " + SERIALIZED_VERSION + ").";
    }
  }
  checkUUID() {
    const uuid = this.readUUID();
    if (SUPPORTED_UUIDS.indexOf(uuid) < 0) {
      throw "Could not deserialize ATN with UUID: " + uuid + " (expected " + SERIALIZED_UUID + " or a legacy UUID).", uuid, SERIALIZED_UUID;
    }
    this.uuid = uuid;
  }
  readATN() {
    const grammarType = this.readInt();
    const maxTokenType = this.readInt();
    return new ATN(grammarType, maxTokenType);
  }
  readStates(atn) {
    let j, pair, stateNumber;
    const loopBackStateNumbers = [];
    const endStateNumbers = [];
    const nstates = this.readInt();
    for (let i = 0; i < nstates; i++) {
      const stype = this.readInt();
      // ignore bad type of states
      if (stype === ATNState.INVALID_TYPE) {
        atn.addState(null);
        continue;
      }
      let ruleIndex = this.readInt();
      if (ruleIndex === 0xFFFF) {
        ruleIndex = -1;
      }
      const s = this.stateFactory(stype, ruleIndex);
      if (stype === ATNState.LOOP_END) {
        // special case
        const loopBackStateNumber = this.readInt();
        loopBackStateNumbers.push([s, loopBackStateNumber]);
      } else if (s instanceof BlockStartState) {
        const endStateNumber = this.readInt();
        endStateNumbers.push([s, endStateNumber]);
      }
      atn.addState(s);
    }
    // delay the assignment of loop back and end states until we know all the
    // state instances have been initialized
    for (j = 0; j < loopBackStateNumbers.length; j++) {
      pair = loopBackStateNumbers[j];
      pair[0].loopBackState = atn.states[pair[1]];
    }
    for (j = 0; j < endStateNumbers.length; j++) {
      pair = endStateNumbers[j];
      pair[0].endState = atn.states[pair[1]];
    }
    let numNonGreedyStates = this.readInt();
    for (j = 0; j < numNonGreedyStates; j++) {
      stateNumber = this.readInt();
      atn.states[stateNumber].nonGreedy = true;
    }
    let numPrecedenceStates = this.readInt();
    for (j = 0; j < numPrecedenceStates; j++) {
      stateNumber = this.readInt();
      atn.states[stateNumber].isPrecedenceRule = true;
    }
  }
  readRules(atn) {
    let i;
    const nrules = this.readInt();
    if (atn.grammarType === ATNType.LEXER) {
      atn.ruleToTokenType = initArray(nrules, 0);
    }
    atn.ruleToStartState = initArray(nrules, 0);
    for (i = 0; i < nrules; i++) {
      const s = this.readInt();
      atn.ruleToStartState[i] = atn.states[s];
      if (atn.grammarType === ATNType.LEXER) {
        let tokenType = this.readInt();
        if (tokenType === 0xFFFF) {
          tokenType = Token.EOF;
        }
        atn.ruleToTokenType[i] = tokenType;
      }
    }
    atn.ruleToStopState = initArray(nrules, 0);
    for (i = 0; i < atn.states.length; i++) {
      const state = atn.states[i];
      if (!(state instanceof RuleStopState)) {
        continue;
      }
      atn.ruleToStopState[state.ruleIndex] = state;
      atn.ruleToStartState[state.ruleIndex].stopState = state;
    }
  }
  readModes(atn) {
    const nmodes = this.readInt();
    for (let i = 0; i < nmodes; i++) {
      let s = this.readInt();
      atn.modeToStartState.push(atn.states[s]);
    }
  }
  readSets(atn, sets, readUnicode) {
    const m = this.readInt();
    for (let i = 0; i < m; i++) {
      const iset = new IntervalSet();
      sets.push(iset);
      const n = this.readInt();
      const containsEof = this.readInt();
      if (containsEof !== 0) {
        iset.addOne(-1);
      }
      for (let j = 0; j < n; j++) {
        const i1 = readUnicode();
        const i2 = readUnicode();
        iset.addRange(i1, i2);
      }
    }
  }
  readEdges(atn, sets) {
    let i, j, state, trans, target;
    const nedges = this.readInt();
    for (i = 0; i < nedges; i++) {
      const src = this.readInt();
      const trg = this.readInt();
      const ttype = this.readInt();
      const arg1 = this.readInt();
      const arg2 = this.readInt();
      const arg3 = this.readInt();
      trans = this.edgeFactory(atn, ttype, src, trg, arg1, arg2, arg3, sets);
      const srcState = atn.states[src];
      srcState.addTransition(trans);
    }
    // edges for rule stop states can be derived, so they aren't serialized
    for (i = 0; i < atn.states.length; i++) {
      state = atn.states[i];
      for (j = 0; j < state.transitions.length; j++) {
        const t = state.transitions[j];
        if (!(t instanceof RuleTransition)) {
          continue;
        }
        let outermostPrecedenceReturn = -1;
        if (atn.ruleToStartState[t.target.ruleIndex].isPrecedenceRule) {
          if (t.precedence === 0) {
            outermostPrecedenceReturn = t.target.ruleIndex;
          }
        }
        trans = new EpsilonTransition(t.followState, outermostPrecedenceReturn);
        atn.ruleToStopState[t.target.ruleIndex].addTransition(trans);
      }
    }
    for (i = 0; i < atn.states.length; i++) {
      state = atn.states[i];
      if (state instanceof BlockStartState) {
        // we need to know the end state to set its start state
        if (state.endState === null) {
          throw "IllegalState";
        }
        // block end states can only be associated to a single block start
        // state
        if (state.endState.startState !== null) {
          throw "IllegalState";
        }
        state.endState.startState = state;
      }
      if (state instanceof PlusLoopbackState) {
        for (j = 0; j < state.transitions.length; j++) {
          target = state.transitions[j].target;
          if (target instanceof PlusBlockStartState) {
            target.loopBackState = state;
          }
        }
      } else if (state instanceof StarLoopbackState) {
        for (j = 0; j < state.transitions.length; j++) {
          target = state.transitions[j].target;
          if (target instanceof StarLoopEntryState) {
            target.loopBackState = state;
          }
        }
      }
    }
  }
  readDecisions(atn) {
    const ndecisions = this.readInt();
    for (let i = 0; i < ndecisions; i++) {
      const s = this.readInt();
      const decState = atn.states[s];
      atn.decisionToState.push(decState);
      decState.decision = i;
    }
  }
  readLexerActions(atn) {
    if (atn.grammarType === ATNType.LEXER) {
      const count = this.readInt();
      atn.lexerActions = initArray(count, null);
      for (let i = 0; i < count; i++) {
        const actionType = this.readInt();
        let data1 = this.readInt();
        if (data1 === 0xFFFF) {
          data1 = -1;
        }
        let data2 = this.readInt();
        if (data2 === 0xFFFF) {
          data2 = -1;
        }
        atn.lexerActions[i] = this.lexerActionFactory(actionType, data1, data2);
      }
    }
  }
  generateRuleBypassTransitions(atn) {
    let i;
    const count = atn.ruleToStartState.length;
    for (i = 0; i < count; i++) {
      atn.ruleToTokenType[i] = atn.maxTokenType + i + 1;
    }
    for (i = 0; i < count; i++) {
      this.generateRuleBypassTransition(atn, i);
    }
  }
  generateRuleBypassTransition(atn, idx) {
    let i, state;
    const bypassStart = new BasicBlockStartState();
    bypassStart.ruleIndex = idx;
    atn.addState(bypassStart);
    const bypassStop = new BlockEndState();
    bypassStop.ruleIndex = idx;
    atn.addState(bypassStop);
    bypassStart.endState = bypassStop;
    atn.defineDecisionState(bypassStart);
    bypassStop.startState = bypassStart;
    let excludeTransition = null;
    let endState = null;
    if (atn.ruleToStartState[idx].isPrecedenceRule) {
      // wrap from the beginning of the rule to the StarLoopEntryState
      endState = null;
      for (i = 0; i < atn.states.length; i++) {
        state = atn.states[i];
        if (this.stateIsEndStateFor(state, idx)) {
          endState = state;
          excludeTransition = state.loopBackState.transitions[0];
          break;
        }
      }
      if (excludeTransition === null) {
        throw "Couldn't identify final state of the precedence rule prefix section.";
      }
    } else {
      endState = atn.ruleToStopState[idx];
    }

    // all non-excluded transitions that currently target end state need to
    // target blockEnd instead
    for (i = 0; i < atn.states.length; i++) {
      state = atn.states[i];
      for (let j = 0; j < state.transitions.length; j++) {
        const transition = state.transitions[j];
        if (transition === excludeTransition) {
          continue;
        }
        if (transition.target === endState) {
          transition.target = bypassStop;
        }
      }
    }

    // all transitions leaving the rule start state need to leave blockStart
    // instead
    const ruleToStartState = atn.ruleToStartState[idx];
    const count = ruleToStartState.transitions.length;
    while (count > 0) {
      bypassStart.addTransition(ruleToStartState.transitions[count - 1]);
      ruleToStartState.transitions = ruleToStartState.transitions.slice(-1);
    }
    // link the new states
    atn.ruleToStartState[idx].addTransition(new EpsilonTransition(bypassStart));
    bypassStop.addTransition(new EpsilonTransition(endState));
    const matchState = new BasicState();
    atn.addState(matchState);
    matchState.addTransition(new AtomTransition(bypassStop, atn.ruleToTokenType[idx]));
    bypassStart.addTransition(new EpsilonTransition(matchState));
  }
  stateIsEndStateFor(state, idx) {
    if (state.ruleIndex !== idx) {
      return null;
    }
    if (!(state instanceof StarLoopEntryState)) {
      return null;
    }
    const maybeLoopEndState = state.transitions[state.transitions.length - 1].target;
    if (!(maybeLoopEndState instanceof LoopEndState)) {
      return null;
    }
    if (maybeLoopEndState.epsilonOnlyTransitions && maybeLoopEndState.transitions[0].target instanceof RuleStopState) {
      return state;
    } else {
      return null;
    }
  }

  /**
   * Analyze the {@link StarLoopEntryState} states in the specified ATN to set
   * the {@link StarLoopEntryState//isPrecedenceDecision} field to the
   * correct value.
   * @param atn The ATN.
   */
  markPrecedenceDecisions(atn) {
    for (let i = 0; i < atn.states.length; i++) {
      const state = atn.states[i];
      if (!(state instanceof StarLoopEntryState)) {
        continue;
      }
      // We analyze the ATN to determine if this ATN decision state is the
      // decision for the closure block that determines whether a
      // precedence rule should continue or complete.
      if (atn.ruleToStartState[state.ruleIndex].isPrecedenceRule) {
        const maybeLoopEndState = state.transitions[state.transitions.length - 1].target;
        if (maybeLoopEndState instanceof LoopEndState) {
          if (maybeLoopEndState.epsilonOnlyTransitions && maybeLoopEndState.transitions[0].target instanceof RuleStopState) {
            state.isPrecedenceDecision = true;
          }
        }
      }
    }
  }
  verifyATN(atn) {
    if (!this.deserializationOptions.verifyATN) {
      return;
    }
    // verify assumptions
    for (let i = 0; i < atn.states.length; i++) {
      const state = atn.states[i];
      if (state === null) {
        continue;
      }
      this.checkCondition(state.epsilonOnlyTransitions || state.transitions.length <= 1);
      if (state instanceof PlusBlockStartState) {
        this.checkCondition(state.loopBackState !== null);
      } else if (state instanceof StarLoopEntryState) {
        this.checkCondition(state.loopBackState !== null);
        this.checkCondition(state.transitions.length === 2);
        if (state.transitions[0].target instanceof StarBlockStartState) {
          this.checkCondition(state.transitions[1].target instanceof LoopEndState);
          this.checkCondition(!state.nonGreedy);
        } else if (state.transitions[0].target instanceof LoopEndState) {
          this.checkCondition(state.transitions[1].target instanceof StarBlockStartState);
          this.checkCondition(state.nonGreedy);
        } else {
          throw "IllegalState";
        }
      } else if (state instanceof StarLoopbackState) {
        this.checkCondition(state.transitions.length === 1);
        this.checkCondition(state.transitions[0].target instanceof StarLoopEntryState);
      } else if (state instanceof LoopEndState) {
        this.checkCondition(state.loopBackState !== null);
      } else if (state instanceof RuleStartState) {
        this.checkCondition(state.stopState !== null);
      } else if (state instanceof BlockStartState) {
        this.checkCondition(state.endState !== null);
      } else if (state instanceof BlockEndState) {
        this.checkCondition(state.startState !== null);
      } else if (state instanceof DecisionState) {
        this.checkCondition(state.transitions.length <= 1 || state.decision >= 0);
      } else {
        this.checkCondition(state.transitions.length <= 1 || state instanceof RuleStopState);
      }
    }
  }
  checkCondition(condition, message) {
    if (!condition) {
      if (message === undefined || message === null) {
        message = "IllegalState";
      }
      throw message;
    }
  }
  readInt() {
    return this.data[this.pos++];
  }
  readInt32() {
    const low = this.readInt();
    const high = this.readInt();
    return low | high << 16;
  }
  readLong() {
    const low = this.readInt32();
    const high = this.readInt32();
    return low & 0x00000000FFFFFFFF | high << 32;
  }
  readUUID() {
    const bb = [];
    for (let i = 7; i >= 0; i--) {
      const int = this.readInt();
      /* jshint bitwise: false */
      bb[2 * i + 1] = int & 0xFF;
      bb[2 * i] = int >> 8 & 0xFF;
    }
    return byteToHex[bb[0]] + byteToHex[bb[1]] + byteToHex[bb[2]] + byteToHex[bb[3]] + '-' + byteToHex[bb[4]] + byteToHex[bb[5]] + '-' + byteToHex[bb[6]] + byteToHex[bb[7]] + '-' + byteToHex[bb[8]] + byteToHex[bb[9]] + '-' + byteToHex[bb[10]] + byteToHex[bb[11]] + byteToHex[bb[12]] + byteToHex[bb[13]] + byteToHex[bb[14]] + byteToHex[bb[15]];
  }
  edgeFactory(atn, type, src, trg, arg1, arg2, arg3, sets) {
    const target = atn.states[trg];
    switch (type) {
      case Transition.EPSILON:
        return new EpsilonTransition(target);
      case Transition.RANGE:
        return arg3 !== 0 ? new RangeTransition(target, Token.EOF, arg2) : new RangeTransition(target, arg1, arg2);
      case Transition.RULE:
        return new RuleTransition(atn.states[arg1], arg2, arg3, target);
      case Transition.PREDICATE:
        return new PredicateTransition(target, arg1, arg2, arg3 !== 0);
      case Transition.PRECEDENCE:
        return new PrecedencePredicateTransition(target, arg1);
      case Transition.ATOM:
        return arg3 !== 0 ? new AtomTransition(target, Token.EOF) : new AtomTransition(target, arg1);
      case Transition.ACTION:
        return new ActionTransition(target, arg1, arg2, arg3 !== 0);
      case Transition.SET:
        return new SetTransition(target, sets[arg1]);
      case Transition.NOT_SET:
        return new NotSetTransition(target, sets[arg1]);
      case Transition.WILDCARD:
        return new WildcardTransition(target);
      default:
        throw "The specified transition type: " + type + " is not valid.";
    }
  }
  stateFactory(type, ruleIndex) {
    if (this.stateFactories === null) {
      const sf = [];
      sf[ATNState.INVALID_TYPE] = null;
      sf[ATNState.BASIC] = () => new BasicState();
      sf[ATNState.RULE_START] = () => new RuleStartState();
      sf[ATNState.BLOCK_START] = () => new BasicBlockStartState();
      sf[ATNState.PLUS_BLOCK_START] = () => new PlusBlockStartState();
      sf[ATNState.STAR_BLOCK_START] = () => new StarBlockStartState();
      sf[ATNState.TOKEN_START] = () => new TokensStartState();
      sf[ATNState.RULE_STOP] = () => new RuleStopState();
      sf[ATNState.BLOCK_END] = () => new BlockEndState();
      sf[ATNState.STAR_LOOP_BACK] = () => new StarLoopbackState();
      sf[ATNState.STAR_LOOP_ENTRY] = () => new StarLoopEntryState();
      sf[ATNState.PLUS_LOOP_BACK] = () => new PlusLoopbackState();
      sf[ATNState.LOOP_END] = () => new LoopEndState();
      this.stateFactories = sf;
    }
    if (type > this.stateFactories.length || this.stateFactories[type] === null) {
      throw "The specified state type " + type + " is not valid.";
    } else {
      const s = this.stateFactories[type]();
      if (s !== null) {
        s.ruleIndex = ruleIndex;
        return s;
      }
    }
  }
  lexerActionFactory(type, data1, data2) {
    if (this.actionFactories === null) {
      const af = [];
      af[LexerActionType.CHANNEL] = (data1, data2) => new LexerChannelAction(data1);
      af[LexerActionType.CUSTOM] = (data1, data2) => new LexerCustomAction(data1, data2);
      af[LexerActionType.MODE] = (data1, data2) => new LexerModeAction(data1);
      af[LexerActionType.MORE] = (data1, data2) => LexerMoreAction.INSTANCE;
      af[LexerActionType.POP_MODE] = (data1, data2) => LexerPopModeAction.INSTANCE;
      af[LexerActionType.PUSH_MODE] = (data1, data2) => new LexerPushModeAction(data1);
      af[LexerActionType.SKIP] = (data1, data2) => LexerSkipAction.INSTANCE;
      af[LexerActionType.TYPE] = (data1, data2) => new LexerTypeAction(data1);
      this.actionFactories = af;
    }
    if (type > this.actionFactories.length || this.actionFactories[type] === null) {
      throw "The specified lexer action type " + type + " is not valid.";
    } else {
      return this.actionFactories[type](data1, data2);
    }
  }
}
function createByteToHex() {
  const bth = [];
  for (let i = 0; i < 256; i++) {
    bth[i] = (i + 0x100).toString(16).substr(1).toUpperCase();
  }
  return bth;
}
const byteToHex = createByteToHex();
module.exports = ATNDeserializer;

/***/ }),
/* 21 */
/***/ (function(module) {

/* Copyright (c) 2012-2017 The ANTLR Project. All rights reserved.
 * Use of this file is governed by the BSD 3-clause license that
 * can be found in the LICENSE.txt file in the project root.
 */

/**
 * Represents the type of recognizer an ATN applies to
 */
module.exports = {
  LEXER: 0,
  PARSER: 1
};

/***/ }),
/* 22 */
/***/ (function(module) {

/* Copyright (c) 2012-2017 The ANTLR Project. All rights reserved.
 * Use of this file is governed by the BSD 3-clause license that
 * can be found in the LICENSE.txt file in the project root.
 */

class ATNDeserializationOptions {
  constructor(copyFrom) {
    if (copyFrom === undefined) {
      copyFrom = null;
    }
    this.readOnly = false;
    this.verifyATN = copyFrom === null ? true : copyFrom.verifyATN;
    this.generateRuleBypassTransitions = copyFrom === null ? false : copyFrom.generateRuleBypassTransitions;
  }
}
ATNDeserializationOptions.defaultOptions = new ATNDeserializationOptions();
ATNDeserializationOptions.defaultOptions.readOnly = true;

//    def __setattr__(self, key, value):
//        if key!="readOnly" and self.readOnly:
//            raise Exception("The object is read only.")
//        super(type(self), self).__setattr__(key,value)

module.exports = ATNDeserializationOptions;

/***/ }),
/* 23 */
/***/ (function(module) {

/* Copyright (c) 2012-2017 The ANTLR Project. All rights reserved.
 * Use of this file is governed by the BSD 3-clause license that
 * can be found in the LICENSE.txt file in the project root.
 */

const LexerActionType = {
  // The type of a {@link LexerChannelAction} action.
  CHANNEL: 0,
  // The type of a {@link LexerCustomAction} action
  CUSTOM: 1,
  // The type of a {@link LexerModeAction} action.
  MODE: 2,
  //The type of a {@link LexerMoreAction} action.
  MORE: 3,
  //The type of a {@link LexerPopModeAction} action.
  POP_MODE: 4,
  //The type of a {@link LexerPushModeAction} action.
  PUSH_MODE: 5,
  //The type of a {@link LexerSkipAction} action.
  SKIP: 6,
  //The type of a {@link LexerTypeAction} action.
  TYPE: 7
};
class LexerAction {
  constructor(action) {
    this.actionType = action;
    this.isPositionDependent = false;
  }
  hashCode() {
    const hash = new Hash();
    this.updateHashCode(hash);
    return hash.finish();
  }
  updateHashCode(hash) {
    hash.update(this.actionType);
  }
  equals(other) {
    return this === other;
  }
}

/**
 * Implements the {@code skip} lexer action by calling {@link Lexer//skip}.
 *
 * <p>The {@code skip} command does not have any parameters, so this action is
 * implemented as a singleton instance exposed by {@link //INSTANCE}.</p>
 */
class LexerSkipAction extends LexerAction {
  constructor() {
    super(LexerActionType.SKIP);
  }
  execute(lexer) {
    lexer.skip();
  }
  toString() {
    return "skip";
  }
}

// Provides a singleton instance of this parameterless lexer action.
LexerSkipAction.INSTANCE = new LexerSkipAction();

/**
 * Implements the {@code type} lexer action by calling {@link Lexer//setType}
 * with the assigned type
 */
class LexerTypeAction extends LexerAction {
  constructor(type) {
    super(LexerActionType.TYPE);
    this.type = type;
  }
  execute(lexer) {
    lexer.type = this.type;
  }
  updateHashCode(hash) {
    hash.update(this.actionType, this.type);
  }
  equals(other) {
    if (this === other) {
      return true;
    } else if (!(other instanceof LexerTypeAction)) {
      return false;
    } else {
      return this.type === other.type;
    }
  }
  toString() {
    return "type(" + this.type + ")";
  }
}

/**
 * Implements the {@code pushMode} lexer action by calling
 * {@link Lexer//pushMode} with the assigned mode
 */
class LexerPushModeAction extends LexerAction {
  constructor(mode) {
    super(LexerActionType.PUSH_MODE);
    this.mode = mode;
  }

  /**
   * <p>This action is implemented by calling {@link Lexer//pushMode} with the
   * value provided by {@link //getMode}.</p>
   */
  execute(lexer) {
    lexer.pushMode(this.mode);
  }
  updateHashCode(hash) {
    hash.update(this.actionType, this.mode);
  }
  equals(other) {
    if (this === other) {
      return true;
    } else if (!(other instanceof LexerPushModeAction)) {
      return false;
    } else {
      return this.mode === other.mode;
    }
  }
  toString() {
    return "pushMode(" + this.mode + ")";
  }
}

/**
 * Implements the {@code popMode} lexer action by calling {@link Lexer//popMode}.
 *
 * <p>The {@code popMode} command does not have any parameters, so this action is
 * implemented as a singleton instance exposed by {@link //INSTANCE}.</p>
 */
class LexerPopModeAction extends LexerAction {
  constructor() {
    super(LexerActionType.POP_MODE);
  }

  /**
   * <p>This action is implemented by calling {@link Lexer//popMode}.</p>
   */
  execute(lexer) {
    lexer.popMode();
  }
  toString() {
    return "popMode";
  }
}
LexerPopModeAction.INSTANCE = new LexerPopModeAction();

/**
 * Implements the {@code more} lexer action by calling {@link Lexer//more}.
 *
 * <p>The {@code more} command does not have any parameters, so this action is
 * implemented as a singleton instance exposed by {@link //INSTANCE}.</p>
 */
class LexerMoreAction extends LexerAction {
  constructor() {
    super(LexerActionType.MORE);
  }

  /**
   * <p>This action is implemented by calling {@link Lexer//popMode}.</p>
   */
  execute(lexer) {
    lexer.more();
  }
  toString() {
    return "more";
  }
}
LexerMoreAction.INSTANCE = new LexerMoreAction();

/**
 * Implements the {@code mode} lexer action by calling {@link Lexer//mode} with
 * the assigned mode
 */
class LexerModeAction extends LexerAction {
  constructor(mode) {
    super(LexerActionType.MODE);
    this.mode = mode;
  }

  /**
   * <p>This action is implemented by calling {@link Lexer//mode} with the
   * value provided by {@link //getMode}.</p>
   */
  execute(lexer) {
    lexer.mode(this.mode);
  }
  updateHashCode(hash) {
    hash.update(this.actionType, this.mode);
  }
  equals(other) {
    if (this === other) {
      return true;
    } else if (!(other instanceof LexerModeAction)) {
      return false;
    } else {
      return this.mode === other.mode;
    }
  }
  toString() {
    return "mode(" + this.mode + ")";
  }
}

/**
 * Executes a custom lexer action by calling {@link Recognizer//action} with the
 * rule and action indexes assigned to the custom action. The implementation of
 * a custom action is added to the generated code for the lexer in an override
 * of {@link Recognizer//action} when the grammar is compiled.
 *
 * <p>This class may represent embedded actions created with the <code>{...}</code>
 * syntax in ANTLR 4, as well as actions created for lexer commands where the
 * command argument could not be evaluated when the grammar was compiled.</p>
 */
class LexerCustomAction extends LexerAction {
  /**
   * Constructs a custom lexer action with the specified rule and action
   * indexes.
   *
   * @param ruleIndex The rule index to use for calls to
   * {@link Recognizer//action}.
   * @param actionIndex The action index to use for calls to
   * {@link Recognizer//action}.
   */
  constructor(ruleIndex, actionIndex) {
    super(LexerActionType.CUSTOM);
    this.ruleIndex = ruleIndex;
    this.actionIndex = actionIndex;
    this.isPositionDependent = true;
  }

  /**
   * <p>Custom actions are implemented by calling {@link Lexer//action} with the
   * appropriate rule and action indexes.</p>
   */
  execute(lexer) {
    lexer.action(null, this.ruleIndex, this.actionIndex);
  }
  updateHashCode(hash) {
    hash.update(this.actionType, this.ruleIndex, this.actionIndex);
  }
  equals(other) {
    if (this === other) {
      return true;
    } else if (!(other instanceof LexerCustomAction)) {
      return false;
    } else {
      return this.ruleIndex === other.ruleIndex && this.actionIndex === other.actionIndex;
    }
  }
}

/**
 * Implements the {@code channel} lexer action by calling
 * {@link Lexer//setChannel} with the assigned channel.
 * Constructs a new {@code channel} action with the specified channel value.
 * @param channel The channel value to pass to {@link Lexer//setChannel}
 */
class LexerChannelAction extends LexerAction {
  constructor(channel) {
    super(LexerActionType.CHANNEL);
    this.channel = channel;
  }

  /**
   * <p>This action is implemented by calling {@link Lexer//setChannel} with the
   * value provided by {@link //getChannel}.</p>
   */
  execute(lexer) {
    lexer._channel = this.channel;
  }
  updateHashCode(hash) {
    hash.update(this.actionType, this.channel);
  }
  equals(other) {
    if (this === other) {
      return true;
    } else if (!(other instanceof LexerChannelAction)) {
      return false;
    } else {
      return this.channel === other.channel;
    }
  }
  toString() {
    return "channel(" + this.channel + ")";
  }
}

/**
 * This implementation of {@link LexerAction} is used for tracking input offsets
 * for position-dependent actions within a {@link LexerActionExecutor}.
 *
 * <p>This action is not serialized as part of the ATN, and is only required for
 * position-dependent lexer actions which appear at a location other than the
 * end of a rule. For more information about DFA optimizations employed for
 * lexer actions, see {@link LexerActionExecutor//append} and
 * {@link LexerActionExecutor//fixOffsetBeforeMatch}.</p>
 *
 * Constructs a new indexed custom action by associating a character offset
 * with a {@link LexerAction}.
 *
 * <p>Note: This class is only required for lexer actions for which
 * {@link LexerAction//isPositionDependent} returns {@code true}.</p>
 *
 * @param offset The offset into the input {@link CharStream}, relative to
 * the token start index, at which the specified lexer action should be
 * executed.
 * @param action The lexer action to execute at a particular offset in the
 * input {@link CharStream}.
 */
class LexerIndexedCustomAction extends LexerAction {
  constructor(offset, action) {
    super(action.actionType);
    this.offset = offset;
    this.action = action;
    this.isPositionDependent = true;
  }

  /**
   * <p>This method calls {@link //execute} on the result of {@link //getAction}
   * using the provided {@code lexer}.</p>
   */
  execute(lexer) {
    // assume the input stream position was properly set by the calling code
    this.action.execute(lexer);
  }
  updateHashCode(hash) {
    hash.update(this.actionType, this.offset, this.action);
  }
  equals(other) {
    if (this === other) {
      return true;
    } else if (!(other instanceof LexerIndexedCustomAction)) {
      return false;
    } else {
      return this.offset === other.offset && this.action === other.action;
    }
  }
}
module.exports = {
  LexerActionType,
  LexerSkipAction,
  LexerChannelAction,
  LexerCustomAction,
  LexerIndexedCustomAction,
  LexerMoreAction,
  LexerTypeAction,
  LexerPushModeAction,
  LexerPopModeAction,
  LexerModeAction
};

/***/ }),
/* 24 */
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

/* Copyright (c) 2012-2017 The ANTLR Project. All rights reserved.
 * Use of this file is governed by the BSD 3-clause license that
 * can be found in the LICENSE.txt file in the project root.
 */

const {
  Token
} = __webpack_require__(10);
const Lexer = __webpack_require__(25);
const ATN = __webpack_require__(7);
const ATNSimulator = __webpack_require__(30);
const {
  DFAState
} = __webpack_require__(31);
const {
  OrderedATNConfigSet
} = __webpack_require__(32);
const {
  PredictionContext
} = __webpack_require__(16);
const {
  SingletonPredictionContext
} = __webpack_require__(16);
const {
  RuleStopState
} = __webpack_require__(12);
const {
  LexerATNConfig
} = __webpack_require__(11);
const {
  Transition
} = __webpack_require__(15);
const LexerActionExecutor = __webpack_require__(33);
const {
  LexerNoViableAltException
} = __webpack_require__(29);
function resetSimState(sim) {
  sim.index = -1;
  sim.line = 0;
  sim.column = -1;
  sim.dfaState = null;
}
class SimState {
  constructor() {
    resetSimState(this);
  }
  reset() {
    resetSimState(this);
  }
}
class LexerATNSimulator extends ATNSimulator {
  /**
   * When we hit an accept state in either the DFA or the ATN, we
   * have to notify the character stream to start buffering characters
   * via {@link IntStream//mark} and record the current state. The current sim state
   * includes the current index into the input, the current line,
   * and current character position in that line. Note that the Lexer is
   * tracking the starting line and characterization of the token. These
   * variables track the "state" of the simulator when it hits an accept state.
   *
   * <p>We track these variables separately for the DFA and ATN simulation
   * because the DFA simulation often has to fail over to the ATN
   * simulation. If the ATN simulation fails, we need the DFA to fall
   * back to its previously accepted state, if any. If the ATN succeeds,
   * then the ATN does the accept and the DFA simulator that invoked it
   * can simply return the predicted token type.</p>
   */
  constructor(recog, atn, decisionToDFA, sharedContextCache) {
    super(atn, sharedContextCache);
    this.decisionToDFA = decisionToDFA;
    this.recog = recog;
    /**
     * The current token's starting index into the character stream.
     * Shared across DFA to ATN simulation in case the ATN fails and the
     * DFA did not have a previous accept state. In this case, we use the
     * ATN-generated exception object
     */
    this.startIndex = -1;
    // line number 1..n within the input///
    this.line = 1;
    /**
     * The index of the character relative to the beginning of the line
     * 0..n-1
     */
    this.column = 0;
    this.mode = Lexer.DEFAULT_MODE;
    /**
     * Used during DFA/ATN exec to record the most recent accept configuration
     * info
     */
    this.prevAccept = new SimState();
  }
  copyState(simulator) {
    this.column = simulator.column;
    this.line = simulator.line;
    this.mode = simulator.mode;
    this.startIndex = simulator.startIndex;
  }
  match(input, mode) {
    this.match_calls += 1;
    this.mode = mode;
    const mark = input.mark();
    try {
      this.startIndex = input.index;
      this.prevAccept.reset();
      const dfa = this.decisionToDFA[mode];
      if (dfa.s0 === null) {
        return this.matchATN(input);
      } else {
        return this.execATN(input, dfa.s0);
      }
    } finally {
      input.release(mark);
    }
  }
  reset() {
    this.prevAccept.reset();
    this.startIndex = -1;
    this.line = 1;
    this.column = 0;
    this.mode = Lexer.DEFAULT_MODE;
  }
  matchATN(input) {
    const startState = this.atn.modeToStartState[this.mode];
    if (LexerATNSimulator.debug) {
      console.log("matchATN mode " + this.mode + " start: " + startState);
    }
    const old_mode = this.mode;
    const s0_closure = this.computeStartState(input, startState);
    const suppressEdge = s0_closure.hasSemanticContext;
    s0_closure.hasSemanticContext = false;
    const next = this.addDFAState(s0_closure);
    if (!suppressEdge) {
      this.decisionToDFA[this.mode].s0 = next;
    }
    const predict = this.execATN(input, next);
    if (LexerATNSimulator.debug) {
      console.log("DFA after matchATN: " + this.decisionToDFA[old_mode].toLexerString());
    }
    return predict;
  }
  execATN(input, ds0) {
    if (LexerATNSimulator.debug) {
      console.log("start state closure=" + ds0.configs);
    }
    if (ds0.isAcceptState) {
      // allow zero-length tokens
      this.captureSimState(this.prevAccept, input, ds0);
    }
    let t = input.LA(1);
    let s = ds0; // s is current/from DFA state

    while (true) {
      // while more work
      if (LexerATNSimulator.debug) {
        console.log("execATN loop starting closure: " + s.configs);
      }

      /**
       * As we move src->trg, src->trg, we keep track of the previous trg to
       * avoid looking up the DFA state again, which is expensive.
       * If the previous target was already part of the DFA, we might
       * be able to avoid doing a reach operation upon t. If s!=null,
       * it means that semantic predicates didn't prevent us from
       * creating a DFA state. Once we know s!=null, we check to see if
       * the DFA state has an edge already for t. If so, we can just reuse
       * it's configuration set; there's no point in re-computing it.
       * This is kind of like doing DFA simulation within the ATN
       * simulation because DFA simulation is really just a way to avoid
       * computing reach/closure sets. Technically, once we know that
       * we have a previously added DFA state, we could jump over to
       * the DFA simulator. But, that would mean popping back and forth
       * a lot and making things more complicated algorithmically.
       * This optimization makes a lot of sense for loops within DFA.
       * A character will take us back to an existing DFA state
       * that already has lots of edges out of it. e.g., .* in comments.
       * print("Target for:" + str(s) + " and:" + str(t))
       */
      let target = this.getExistingTargetState(s, t);
      // print("Existing:" + str(target))
      if (target === null) {
        target = this.computeTargetState(input, s, t);
        // print("Computed:" + str(target))
      }
      if (target === ATNSimulator.ERROR) {
        break;
      }
      // If this is a consumable input element, make sure to consume before
      // capturing the accept state so the input index, line, and char
      // position accurately reflect the state of the interpreter at the
      // end of the token.
      if (t !== Token.EOF) {
        this.consume(input);
      }
      if (target.isAcceptState) {
        this.captureSimState(this.prevAccept, input, target);
        if (t === Token.EOF) {
          break;
        }
      }
      t = input.LA(1);
      s = target; // flip; current DFA target becomes new src/from state
    }
    return this.failOrAccept(this.prevAccept, input, s.configs, t);
  }

  /**
   * Get an existing target state for an edge in the DFA. If the target state
   * for the edge has not yet been computed or is otherwise not available,
   * this method returns {@code null}.
   *
   * @param s The current DFA state
   * @param t The next input symbol
   * @return The existing target DFA state for the given input symbol
   * {@code t}, or {@code null} if the target state for this edge is not
   * already cached
   */
  getExistingTargetState(s, t) {
    if (s.edges === null || t < LexerATNSimulator.MIN_DFA_EDGE || t > LexerATNSimulator.MAX_DFA_EDGE) {
      return null;
    }
    let target = s.edges[t - LexerATNSimulator.MIN_DFA_EDGE];
    if (target === undefined) {
      target = null;
    }
    if (LexerATNSimulator.debug && target !== null) {
      console.log("reuse state " + s.stateNumber + " edge to " + target.stateNumber);
    }
    return target;
  }

  /**
   * Compute a target state for an edge in the DFA, and attempt to add the
   * computed state and corresponding edge to the DFA.
   *
   * @param input The input stream
   * @param s The current DFA state
   * @param t The next input symbol
   *
   * @return The computed target DFA state for the given input symbol
   * {@code t}. If {@code t} does not lead to a valid DFA state, this method
   * returns {@link //ERROR}.
   */
  computeTargetState(input, s, t) {
    const reach = new OrderedATNConfigSet();
    // if we don't find an existing DFA state
    // Fill reach starting from closure, following t transitions
    this.getReachableConfigSet(input, s.configs, reach, t);
    if (reach.items.length === 0) {
      // we got nowhere on t from s
      if (!reach.hasSemanticContext) {
        // we got nowhere on t, don't throw out this knowledge; it'd
        // cause a failover from DFA later.
        this.addDFAEdge(s, t, ATNSimulator.ERROR);
      }
      // stop when we can't match any more char
      return ATNSimulator.ERROR;
    }
    // Add an edge from s to target DFA found/created for reach
    return this.addDFAEdge(s, t, null, reach);
  }
  failOrAccept(prevAccept, input, reach, t) {
    if (this.prevAccept.dfaState !== null) {
      const lexerActionExecutor = prevAccept.dfaState.lexerActionExecutor;
      this.accept(input, lexerActionExecutor, this.startIndex, prevAccept.index, prevAccept.line, prevAccept.column);
      return prevAccept.dfaState.prediction;
    } else {
      // if no accept and EOF is first char, return EOF
      if (t === Token.EOF && input.index === this.startIndex) {
        return Token.EOF;
      }
      throw new LexerNoViableAltException(this.recog, input, this.startIndex, reach);
    }
  }

  /**
   * Given a starting configuration set, figure out all ATN configurations
   * we can reach upon input {@code t}. Parameter {@code reach} is a return
   * parameter.
   */
  getReachableConfigSet(input, closure, reach, t) {
    // this is used to skip processing for configs which have a lower priority
    // than a config that already reached an accept state for the same rule
    let skipAlt = ATN.INVALID_ALT_NUMBER;
    for (let i = 0; i < closure.items.length; i++) {
      const cfg = closure.items[i];
      const currentAltReachedAcceptState = cfg.alt === skipAlt;
      if (currentAltReachedAcceptState && cfg.passedThroughNonGreedyDecision) {
        continue;
      }
      if (LexerATNSimulator.debug) {
        console.log("testing %s at %s\n", this.getTokenName(t), cfg.toString(this.recog, true));
      }
      for (let j = 0; j < cfg.state.transitions.length; j++) {
        const trans = cfg.state.transitions[j]; // for each transition
        const target = this.getReachableTarget(trans, t);
        if (target !== null) {
          let lexerActionExecutor = cfg.lexerActionExecutor;
          if (lexerActionExecutor !== null) {
            lexerActionExecutor = lexerActionExecutor.fixOffsetBeforeMatch(input.index - this.startIndex);
          }
          const treatEofAsEpsilon = t === Token.EOF;
          const config = new LexerATNConfig({
            state: target,
            lexerActionExecutor: lexerActionExecutor
          }, cfg);
          if (this.closure(input, config, reach, currentAltReachedAcceptState, true, treatEofAsEpsilon)) {
            // any remaining configs for this alt have a lower priority
            // than the one that just reached an accept state.
            skipAlt = cfg.alt;
          }
        }
      }
    }
  }
  accept(input, lexerActionExecutor, startIndex, index, line, charPos) {
    if (LexerATNSimulator.debug) {
      console.log("ACTION %s\n", lexerActionExecutor);
    }
    // seek to after last char in token
    input.seek(index);
    this.line = line;
    this.column = charPos;
    if (lexerActionExecutor !== null && this.recog !== null) {
      lexerActionExecutor.execute(this.recog, input, startIndex);
    }
  }
  getReachableTarget(trans, t) {
    if (trans.matches(t, 0, Lexer.MAX_CHAR_VALUE)) {
      return trans.target;
    } else {
      return null;
    }
  }
  computeStartState(input, p) {
    const initialContext = PredictionContext.EMPTY;
    const configs = new OrderedATNConfigSet();
    for (let i = 0; i < p.transitions.length; i++) {
      const target = p.transitions[i].target;
      const cfg = new LexerATNConfig({
        state: target,
        alt: i + 1,
        context: initialContext
      }, null);
      this.closure(input, cfg, configs, false, false, false);
    }
    return configs;
  }

  /**
   * Since the alternatives within any lexer decision are ordered by
   * preference, this method stops pursuing the closure as soon as an accept
   * state is reached. After the first accept state is reached by depth-first
   * search from {@code config}, all other (potentially reachable) states for
   * this rule would have a lower priority.
   *
   * @return {Boolean} {@code true} if an accept state is reached, otherwise
   * {@code false}.
   */
  closure(input, config, configs, currentAltReachedAcceptState, speculative, treatEofAsEpsilon) {
    let cfg = null;
    if (LexerATNSimulator.debug) {
      console.log("closure(" + config.toString(this.recog, true) + ")");
    }
    if (config.state instanceof RuleStopState) {
      if (LexerATNSimulator.debug) {
        if (this.recog !== null) {
          console.log("closure at %s rule stop %s\n", this.recog.ruleNames[config.state.ruleIndex], config);
        } else {
          console.log("closure at rule stop %s\n", config);
        }
      }
      if (config.context === null || config.context.hasEmptyPath()) {
        if (config.context === null || config.context.isEmpty()) {
          configs.add(config);
          return true;
        } else {
          configs.add(new LexerATNConfig({
            state: config.state,
            context: PredictionContext.EMPTY
          }, config));
          currentAltReachedAcceptState = true;
        }
      }
      if (config.context !== null && !config.context.isEmpty()) {
        for (let i = 0; i < config.context.length; i++) {
          if (config.context.getReturnState(i) !== PredictionContext.EMPTY_RETURN_STATE) {
            const newContext = config.context.getParent(i); // "pop" return state
            const returnState = this.atn.states[config.context.getReturnState(i)];
            cfg = new LexerATNConfig({
              state: returnState,
              context: newContext
            }, config);
            currentAltReachedAcceptState = this.closure(input, cfg, configs, currentAltReachedAcceptState, speculative, treatEofAsEpsilon);
          }
        }
      }
      return currentAltReachedAcceptState;
    }
    // optimization
    if (!config.state.epsilonOnlyTransitions) {
      if (!currentAltReachedAcceptState || !config.passedThroughNonGreedyDecision) {
        configs.add(config);
      }
    }
    for (let j = 0; j < config.state.transitions.length; j++) {
      const trans = config.state.transitions[j];
      cfg = this.getEpsilonTarget(input, config, trans, configs, speculative, treatEofAsEpsilon);
      if (cfg !== null) {
        currentAltReachedAcceptState = this.closure(input, cfg, configs, currentAltReachedAcceptState, speculative, treatEofAsEpsilon);
      }
    }
    return currentAltReachedAcceptState;
  }

  // side-effect: can alter configs.hasSemanticContext
  getEpsilonTarget(input, config, trans, configs, speculative, treatEofAsEpsilon) {
    let cfg = null;
    if (trans.serializationType === Transition.RULE) {
      const newContext = SingletonPredictionContext.create(config.context, trans.followState.stateNumber);
      cfg = new LexerATNConfig({
        state: trans.target,
        context: newContext
      }, config);
    } else if (trans.serializationType === Transition.PRECEDENCE) {
      throw "Precedence predicates are not supported in lexers.";
    } else if (trans.serializationType === Transition.PREDICATE) {
      // Track traversing semantic predicates. If we traverse,
      // we cannot add a DFA state for this "reach" computation
      // because the DFA would not test the predicate again in the
      // future. Rather than creating collections of semantic predicates
      // like v3 and testing them on prediction, v4 will test them on the
      // fly all the time using the ATN not the DFA. This is slower but
      // semantically it's not used that often. One of the key elements to
      // this predicate mechanism is not adding DFA states that see
      // predicates immediately afterwards in the ATN. For example,

      // a : ID {p1}? | ID {p2}? ;

      // should create the start state for rule 'a' (to save start state
      // competition), but should not create target of ID state. The
      // collection of ATN states the following ID references includes
      // states reached by traversing predicates. Since this is when we
      // test them, we cannot cash the DFA state target of ID.

      if (LexerATNSimulator.debug) {
        console.log("EVAL rule " + trans.ruleIndex + ":" + trans.predIndex);
      }
      configs.hasSemanticContext = true;
      if (this.evaluatePredicate(input, trans.ruleIndex, trans.predIndex, speculative)) {
        cfg = new LexerATNConfig({
          state: trans.target
        }, config);
      }
    } else if (trans.serializationType === Transition.ACTION) {
      if (config.context === null || config.context.hasEmptyPath()) {
        // execute actions anywhere in the start rule for a token.
        //
        // TODO: if the entry rule is invoked recursively, some
        // actions may be executed during the recursive call. The
        // problem can appear when hasEmptyPath() is true but
        // isEmpty() is false. In this case, the config needs to be
        // split into two contexts - one with just the empty path
        // and another with everything but the empty path.
        // Unfortunately, the current algorithm does not allow
        // getEpsilonTarget to return two configurations, so
        // additional modifications are needed before we can support
        // the split operation.
        const lexerActionExecutor = LexerActionExecutor.append(config.lexerActionExecutor, this.atn.lexerActions[trans.actionIndex]);
        cfg = new LexerATNConfig({
          state: trans.target,
          lexerActionExecutor: lexerActionExecutor
        }, config);
      } else {
        // ignore actions in referenced rules
        cfg = new LexerATNConfig({
          state: trans.target
        }, config);
      }
    } else if (trans.serializationType === Transition.EPSILON) {
      cfg = new LexerATNConfig({
        state: trans.target
      }, config);
    } else if (trans.serializationType === Transition.ATOM || trans.serializationType === Transition.RANGE || trans.serializationType === Transition.SET) {
      if (treatEofAsEpsilon) {
        if (trans.matches(Token.EOF, 0, Lexer.MAX_CHAR_VALUE)) {
          cfg = new LexerATNConfig({
            state: trans.target
          }, config);
        }
      }
    }
    return cfg;
  }

  /**
   * Evaluate a predicate specified in the lexer.
   *
   * <p>If {@code speculative} is {@code true}, this method was called before
   * {@link //consume} for the matched character. This method should call
   * {@link //consume} before evaluating the predicate to ensure position
   * sensitive values, including {@link Lexer//getText}, {@link Lexer//getLine},
   * and {@link Lexer//getcolumn}, properly reflect the current
   * lexer state. This method should restore {@code input} and the simulator
   * to the original state before returning (i.e. undo the actions made by the
   * call to {@link //consume}.</p>
   *
   * @param input The input stream.
   * @param ruleIndex The rule containing the predicate.
   * @param predIndex The index of the predicate within the rule.
   * @param speculative {@code true} if the current index in {@code input} is
   * one character before the predicate's location.
   *
   * @return {@code true} if the specified predicate evaluates to
   * {@code true}.
   */
  evaluatePredicate(input, ruleIndex, predIndex, speculative) {
    // assume true if no recognizer was provided
    if (this.recog === null) {
      return true;
    }
    if (!speculative) {
      return this.recog.sempred(null, ruleIndex, predIndex);
    }
    const savedcolumn = this.column;
    const savedLine = this.line;
    const index = input.index;
    const marker = input.mark();
    try {
      this.consume(input);
      return this.recog.sempred(null, ruleIndex, predIndex);
    } finally {
      this.column = savedcolumn;
      this.line = savedLine;
      input.seek(index);
      input.release(marker);
    }
  }
  captureSimState(settings, input, dfaState) {
    settings.index = input.index;
    settings.line = this.line;
    settings.column = this.column;
    settings.dfaState = dfaState;
  }
  addDFAEdge(from_, tk, to, cfgs) {
    if (to === undefined) {
      to = null;
    }
    if (cfgs === undefined) {
      cfgs = null;
    }
    if (to === null && cfgs !== null) {
      // leading to this call, ATNConfigSet.hasSemanticContext is used as a
      // marker indicating dynamic predicate evaluation makes this edge
      // dependent on the specific input sequence, so the static edge in the
      // DFA should be omitted. The target DFAState is still created since
      // execATN has the ability to resynchronize with the DFA state cache
      // following the predicate evaluation step.
      //
      // TJP notes: next time through the DFA, we see a pred again and eval.
      // If that gets us to a previously created (but dangling) DFA
      // state, we can continue in pure DFA mode from there.
      // /
      const suppressEdge = cfgs.hasSemanticContext;
      cfgs.hasSemanticContext = false;
      to = this.addDFAState(cfgs);
      if (suppressEdge) {
        return to;
      }
    }
    // add the edge
    if (tk < LexerATNSimulator.MIN_DFA_EDGE || tk > LexerATNSimulator.MAX_DFA_EDGE) {
      // Only track edges within the DFA bounds
      return to;
    }
    if (LexerATNSimulator.debug) {
      console.log("EDGE " + from_ + " -> " + to + " upon " + tk);
    }
    if (from_.edges === null) {
      // make room for tokens 1..n and -1 masquerading as index 0
      from_.edges = [];
    }
    from_.edges[tk - LexerATNSimulator.MIN_DFA_EDGE] = to; // connect

    return to;
  }

  /**
   * Add a new DFA state if there isn't one with this set of
   * configurations already. This method also detects the first
   * configuration containing an ATN rule stop state. Later, when
   * traversing the DFA, we will know which rule to accept.
   */
  addDFAState(configs) {
    const proposed = new DFAState(null, configs);
    let firstConfigWithRuleStopState = null;
    for (let i = 0; i < configs.items.length; i++) {
      const cfg = configs.items[i];
      if (cfg.state instanceof RuleStopState) {
        firstConfigWithRuleStopState = cfg;
        break;
      }
    }
    if (firstConfigWithRuleStopState !== null) {
      proposed.isAcceptState = true;
      proposed.lexerActionExecutor = firstConfigWithRuleStopState.lexerActionExecutor;
      proposed.prediction = this.atn.ruleToTokenType[firstConfigWithRuleStopState.state.ruleIndex];
    }
    const dfa = this.decisionToDFA[this.mode];
    const existing = dfa.states.get(proposed);
    if (existing !== null) {
      return existing;
    }
    const newState = proposed;
    newState.stateNumber = dfa.states.length;
    configs.setReadonly(true);
    newState.configs = configs;
    dfa.states.add(newState);
    return newState;
  }
  getDFA(mode) {
    return this.decisionToDFA[mode];
  }

  // Get the text matched so far for the current token.
  getText(input) {
    // index is first lookahead char, don't include.
    return input.getText(this.startIndex, input.index - 1);
  }
  consume(input) {
    const curChar = input.LA(1);
    if (curChar === "\n".charCodeAt(0)) {
      this.line += 1;
      this.column = 0;
    } else {
      this.column += 1;
    }
    input.consume();
  }
  getTokenName(tt) {
    if (tt === -1) {
      return "EOF";
    } else {
      return "'" + String.fromCharCode(tt) + "'";
    }
  }
}
LexerATNSimulator.debug = false;
LexerATNSimulator.dfa_debug = false;
LexerATNSimulator.MIN_DFA_EDGE = 0;
LexerATNSimulator.MAX_DFA_EDGE = 127; // forces unicode to stay in ATN

LexerATNSimulator.match_calls = 0;
module.exports = LexerATNSimulator;

/***/ }),
/* 25 */
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

/* Copyright (c) 2012-2017 The ANTLR Project. All rights reserved.
 * Use of this file is governed by the BSD 3-clause license that
 * can be found in the LICENSE.txt file in the project root.
 */

const {
  Token
} = __webpack_require__(10);
const Recognizer = __webpack_require__(26);
const CommonTokenFactory = __webpack_require__(28);
const {
  RecognitionException
} = __webpack_require__(29);
const {
  LexerNoViableAltException
} = __webpack_require__(29);
class TokenSource {}

/**
 * A lexer is recognizer that draws input symbols from a character stream.
 * lexer grammars result in a subclass of this object. A Lexer object
 * uses simplified match() and error recovery mechanisms in the interest of speed.
 */
class Lexer extends Recognizer {
  constructor(input) {
    super();
    this._input = input;
    this._factory = CommonTokenFactory.DEFAULT;
    this._tokenFactorySourcePair = [this, input];
    this._interp = null; // child classes must populate this

    /**
     * The goal of all lexer rules/methods is to create a token object.
     * this is an instance variable as multiple rules may collaborate to
     * create a single token. nextToken will return this object after
     * matching lexer rule(s). If you subclass to allow multiple token
     * emissions, then set this to the last token to be matched or
     * something nonnull so that the auto token emit mechanism will not
     * emit another token.
     */
    this._token = null;

    /**
     * What character index in the stream did the current token start at?
     * Needed, for example, to get the text for current token. Set at
     * the start of nextToken.
     */
    this._tokenStartCharIndex = -1;

    // The line on which the first character of the token resides///
    this._tokenStartLine = -1;

    // The character position of first character within the line///
    this._tokenStartColumn = -1;

    // Once we see EOF on char stream, next token will be EOF.
    // If you have DONE : EOF ; then you see DONE EOF.
    this._hitEOF = false;

    // The channel number for the current token///
    this._channel = Token.DEFAULT_CHANNEL;

    // The token type for the current token///
    this._type = Token.INVALID_TYPE;
    this._modeStack = [];
    this._mode = Lexer.DEFAULT_MODE;

    /**
     * You can set the text for the current token to override what is in
     * the input char buffer. Use setText() or can set this instance var.
     */
    this._text = null;
  }
  reset() {
    // wack Lexer state variables
    if (this._input !== null) {
      this._input.seek(0); // rewind the input
    }
    this._token = null;
    this._type = Token.INVALID_TYPE;
    this._channel = Token.DEFAULT_CHANNEL;
    this._tokenStartCharIndex = -1;
    this._tokenStartColumn = -1;
    this._tokenStartLine = -1;
    this._text = null;
    this._hitEOF = false;
    this._mode = Lexer.DEFAULT_MODE;
    this._modeStack = [];
    this._interp.reset();
  }

  // Return a token from this source; i.e., match a token on the char stream.
  nextToken() {
    if (this._input === null) {
      throw "nextToken requires a non-null input stream.";
    }

    /**
     * Mark start location in char stream so unbuffered streams are
     * guaranteed at least have text of current token
     */
    const tokenStartMarker = this._input.mark();
    try {
      while (true) {
        if (this._hitEOF) {
          this.emitEOF();
          return this._token;
        }
        this._token = null;
        this._channel = Token.DEFAULT_CHANNEL;
        this._tokenStartCharIndex = this._input.index;
        this._tokenStartColumn = this._interp.column;
        this._tokenStartLine = this._interp.line;
        this._text = null;
        let continueOuter = false;
        while (true) {
          this._type = Token.INVALID_TYPE;
          let ttype = Lexer.SKIP;
          try {
            ttype = this._interp.match(this._input, this._mode);
          } catch (e) {
            if (e instanceof RecognitionException) {
              this.notifyListeners(e); // report error
              this.recover(e);
            } else {
              console.log(e.stack);
              throw e;
            }
          }
          if (this._input.LA(1) === Token.EOF) {
            this._hitEOF = true;
          }
          if (this._type === Token.INVALID_TYPE) {
            this._type = ttype;
          }
          if (this._type === Lexer.SKIP) {
            continueOuter = true;
            break;
          }
          if (this._type !== Lexer.MORE) {
            break;
          }
        }
        if (continueOuter) {
          continue;
        }
        if (this._token === null) {
          this.emit();
        }
        return this._token;
      }
    } finally {
      // make sure we release marker after match or
      // unbuffered char stream will keep buffering
      this._input.release(tokenStartMarker);
    }
  }

  /**
   * Instruct the lexer to skip creating a token for current lexer rule
   * and look for another token. nextToken() knows to keep looking when
   * a lexer rule finishes with token set to SKIP_TOKEN. Recall that
   * if token==null at end of any token rule, it creates one for you
   * and emits it.
   */
  skip() {
    this._type = Lexer.SKIP;
  }
  more() {
    this._type = Lexer.MORE;
  }
  mode(m) {
    this._mode = m;
  }
  pushMode(m) {
    if (this._interp.debug) {
      console.log("pushMode " + m);
    }
    this._modeStack.push(this._mode);
    this.mode(m);
  }
  popMode() {
    if (this._modeStack.length === 0) {
      throw "Empty Stack";
    }
    if (this._interp.debug) {
      console.log("popMode back to " + this._modeStack.slice(0, -1));
    }
    this.mode(this._modeStack.pop());
    return this._mode;
  }

  /**
   * By default does not support multiple emits per nextToken invocation
   * for efficiency reasons. Subclass and override this method, nextToken,
   * and getToken (to push tokens into a list and pull from that list
   * rather than a single variable as this implementation does).
   */
  emitToken(token) {
    this._token = token;
  }

  /**
   * The standard method called to automatically emit a token at the
   * outermost lexical rule. The token object should point into the
   * char buffer start..stop. If there is a text override in 'text',
   * use that to set the token's text. Override this method to emit
   * custom Token objects or provide a new factory.
   */
  emit() {
    const t = this._factory.create(this._tokenFactorySourcePair, this._type, this._text, this._channel, this._tokenStartCharIndex, this.getCharIndex() - 1, this._tokenStartLine, this._tokenStartColumn);
    this.emitToken(t);
    return t;
  }
  emitEOF() {
    const cpos = this.column;
    const lpos = this.line;
    const eof = this._factory.create(this._tokenFactorySourcePair, Token.EOF, null, Token.DEFAULT_CHANNEL, this._input.index, this._input.index - 1, lpos, cpos);
    this.emitToken(eof);
    return eof;
  }

  // What is the index of the current character of lookahead?///
  getCharIndex() {
    return this._input.index;
  }

  /**
   * Return a list of all Token objects in input char stream.
   * Forces load of all tokens. Does not include EOF token.
   */
  getAllTokens() {
    const tokens = [];
    let t = this.nextToken();
    while (t.type !== Token.EOF) {
      tokens.push(t);
      t = this.nextToken();
    }
    return tokens;
  }
  notifyListeners(e) {
    const start = this._tokenStartCharIndex;
    const stop = this._input.index;
    const text = this._input.getText(start, stop);
    const msg = "token recognition error at: '" + this.getErrorDisplay(text) + "'";
    const listener = this.getErrorListenerDispatch();
    listener.syntaxError(this, null, this._tokenStartLine, this._tokenStartColumn, msg, e);
  }
  getErrorDisplay(s) {
    const d = [];
    for (let i = 0; i < s.length; i++) {
      d.push(s[i]);
    }
    return d.join('');
  }
  getErrorDisplayForChar(c) {
    if (c.charCodeAt(0) === Token.EOF) {
      return "<EOF>";
    } else if (c === '\n') {
      return "\\n";
    } else if (c === '\t') {
      return "\\t";
    } else if (c === '\r') {
      return "\\r";
    } else {
      return c;
    }
  }
  getCharErrorDisplay(c) {
    return "'" + this.getErrorDisplayForChar(c) + "'";
  }

  /**
   * Lexers can normally match any char in it's vocabulary after matching
   * a token, so do the easy thing and just kill a character and hope
   * it all works out. You can instead use the rule invocation stack
   * to do sophisticated error recovery if you are in a fragment rule.
   */
  recover(re) {
    if (this._input.LA(1) !== Token.EOF) {
      if (re instanceof LexerNoViableAltException) {
        // skip a char and try again
        this._interp.consume(this._input);
      } else {
        // TODO: Do we lose character or line position information?
        this._input.consume();
      }
    }
  }
  get inputStream() {
    return this._input;
  }
  set inputStream(input) {
    this._input = null;
    this._tokenFactorySourcePair = [this, this._input];
    this.reset();
    this._input = input;
    this._tokenFactorySourcePair = [this, this._input];
  }
  get sourceName() {
    return this._input.sourceName;
  }
  get type() {
    return this._type;
  }
  set type(type) {
    this._type = type;
  }
  get line() {
    return this._interp.line;
  }
  set line(line) {
    this._interp.line = line;
  }
  get column() {
    return this._interp.column;
  }
  set column(column) {
    this._interp.column = column;
  }
  get text() {
    if (this._text !== null) {
      return this._text;
    } else {
      return this._interp.getText(this._input);
    }
  }
  set text(text) {
    this._text = text;
  }
}
Lexer.DEFAULT_MODE = 0;
Lexer.MORE = -2;
Lexer.SKIP = -3;
Lexer.DEFAULT_TOKEN_CHANNEL = Token.DEFAULT_CHANNEL;
Lexer.HIDDEN = Token.HIDDEN_CHANNEL;
Lexer.MIN_CHAR_VALUE = 0x0000;
Lexer.MAX_CHAR_VALUE = 0x10FFFF;

// Set the char stream and reset the lexer

module.exports = Lexer;

/***/ }),
/* 26 */
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

/* Copyright (c) 2012-2017 The ANTLR Project. All rights reserved.
 * Use of this file is governed by the BSD 3-clause license that
 * can be found in the LICENSE.txt file in the project root.
 */

const {
  Token
} = __webpack_require__(10);
const {
  ConsoleErrorListener
} = __webpack_require__(27);
const {
  ProxyErrorListener
} = __webpack_require__(27);
class Recognizer {
  constructor() {
    this._listeners = [ConsoleErrorListener.INSTANCE];
    this._interp = null;
    this._stateNumber = -1;
  }
  checkVersion(toolVersion) {
    const runtimeVersion = "4.9.3";
    if (runtimeVersion !== toolVersion) {
      console.log("ANTLR runtime and generated code versions disagree: " + runtimeVersion + "!=" + toolVersion);
    }
  }
  addErrorListener(listener) {
    this._listeners.push(listener);
  }
  removeErrorListeners() {
    this._listeners = [];
  }
  getLiteralNames() {
    return Object.getPrototypeOf(this).constructor.literalNames || [];
  }
  getSymbolicNames() {
    return Object.getPrototypeOf(this).constructor.symbolicNames || [];
  }
  getTokenNames() {
    if (!this.tokenNames) {
      const literalNames = this.getLiteralNames();
      const symbolicNames = this.getSymbolicNames();
      const length = literalNames.length > symbolicNames.length ? literalNames.length : symbolicNames.length;
      this.tokenNames = [];
      for (let i = 0; i < length; i++) {
        this.tokenNames[i] = literalNames[i] || symbolicNames[i] || "<INVALID";
      }
    }
    return this.tokenNames;
  }
  getTokenTypeMap() {
    const tokenNames = this.getTokenNames();
    if (tokenNames === null) {
      throw "The current recognizer does not provide a list of token names.";
    }
    let result = this.tokenTypeMapCache[tokenNames];
    if (result === undefined) {
      result = tokenNames.reduce(function (o, k, i) {
        o[k] = i;
      });
      result.EOF = Token.EOF;
      this.tokenTypeMapCache[tokenNames] = result;
    }
    return result;
  }

  /**
   * Get a map from rule names to rule indexes.
   * <p>Used for XPath and tree pattern compilation.</p>
   */
  getRuleIndexMap() {
    const ruleNames = this.ruleNames;
    if (ruleNames === null) {
      throw "The current recognizer does not provide a list of rule names.";
    }
    let result = this.ruleIndexMapCache[ruleNames]; // todo: should it be Recognizer.ruleIndexMapCache ?
    if (result === undefined) {
      result = ruleNames.reduce(function (o, k, i) {
        o[k] = i;
      });
      this.ruleIndexMapCache[ruleNames] = result;
    }
    return result;
  }
  getTokenType(tokenName) {
    const ttype = this.getTokenTypeMap()[tokenName];
    if (ttype !== undefined) {
      return ttype;
    } else {
      return Token.INVALID_TYPE;
    }
  }

  // What is the error header, normally line/character position information?
  getErrorHeader(e) {
    const line = e.getOffendingToken().line;
    const column = e.getOffendingToken().column;
    return "line " + line + ":" + column;
  }

  /**
   * How should a token be displayed in an error message? The default
   * is to display just the text, but during development you might
   * want to have a lot of information spit out.  Override in that case
   * to use t.toString() (which, for CommonToken, dumps everything about
   * the token). This is better than forcing you to override a method in
   * your token objects because you don't have to go modify your lexer
   * so that it creates a new Java type.
   *
   * @deprecated This method is not called by the ANTLR 4 Runtime. Specific
   * implementations of {@link ANTLRErrorStrategy} may provide a similar
   * feature when necessary. For example, see
   * {@link DefaultErrorStrategy//getTokenErrorDisplay}.*/
  getTokenErrorDisplay(t) {
    if (t === null) {
      return "<no token>";
    }
    let s = t.text;
    if (s === null) {
      if (t.type === Token.EOF) {
        s = "<EOF>";
      } else {
        s = "<" + t.type + ">";
      }
    }
    s = s.replace("\n", "\\n").replace("\r", "\\r").replace("\t", "\\t");
    return "'" + s + "'";
  }
  getErrorListenerDispatch() {
    return new ProxyErrorListener(this._listeners);
  }

  /**
   * subclass needs to override these if there are sempreds or actions
   * that the ATN interp needs to execute
   */
  sempred(localctx, ruleIndex, actionIndex) {
    return true;
  }
  precpred(localctx, precedence) {
    return true;
  }
  get state() {
    return this._stateNumber;
  }
  set state(state) {
    this._stateNumber = state;
  }
}
Recognizer.tokenTypeMapCache = {};
Recognizer.ruleIndexMapCache = {};
module.exports = Recognizer;

/***/ }),
/* 27 */
/***/ (function(module) {

/* Copyright (c) 2012-2017 The ANTLR Project. All rights reserved.
 * Use of this file is governed by the BSD 3-clause license that
 * can be found in the LICENSE.txt file in the project root.
 */

/**
 * Provides an empty default implementation of {@link ANTLRErrorListener}. The
 * default implementation of each method does nothing, but can be overridden as
 * necessary.
 */
class ErrorListener {
  syntaxError(recognizer, offendingSymbol, line, column, msg, e) {}
  reportAmbiguity(recognizer, dfa, startIndex, stopIndex, exact, ambigAlts, configs) {}
  reportAttemptingFullContext(recognizer, dfa, startIndex, stopIndex, conflictingAlts, configs) {}
  reportContextSensitivity(recognizer, dfa, startIndex, stopIndex, prediction, configs) {}
}

/**
 * {@inheritDoc}
 *
 * <p>
 * This implementation prints messages to {@link System//err} containing the
 * values of {@code line}, {@code charPositionInLine}, and {@code msg} using
 * the following format.</p>
 *
 * <pre>
 * line <em>line</em>:<em>charPositionInLine</em> <em>msg</em>
 * </pre>
 *
 */
class ConsoleErrorListener extends ErrorListener {
  constructor() {
    super();
  }
  syntaxError(recognizer, offendingSymbol, line, column, msg, e) {
    console.error("line " + line + ":" + column + " " + msg);
  }
}

/**
 * Provides a default instance of {@link ConsoleErrorListener}.
 */
ConsoleErrorListener.INSTANCE = new ConsoleErrorListener();
class ProxyErrorListener extends ErrorListener {
  constructor(delegates) {
    super();
    if (delegates === null) {
      throw "delegates";
    }
    this.delegates = delegates;
    return this;
  }
  syntaxError(recognizer, offendingSymbol, line, column, msg, e) {
    this.delegates.map(d => d.syntaxError(recognizer, offendingSymbol, line, column, msg, e));
  }
  reportAmbiguity(recognizer, dfa, startIndex, stopIndex, exact, ambigAlts, configs) {
    this.delegates.map(d => d.reportAmbiguity(recognizer, dfa, startIndex, stopIndex, exact, ambigAlts, configs));
  }
  reportAttemptingFullContext(recognizer, dfa, startIndex, stopIndex, conflictingAlts, configs) {
    this.delegates.map(d => d.reportAttemptingFullContext(recognizer, dfa, startIndex, stopIndex, conflictingAlts, configs));
  }
  reportContextSensitivity(recognizer, dfa, startIndex, stopIndex, prediction, configs) {
    this.delegates.map(d => d.reportContextSensitivity(recognizer, dfa, startIndex, stopIndex, prediction, configs));
  }
}
module.exports = {
  ErrorListener,
  ConsoleErrorListener,
  ProxyErrorListener
};

/***/ }),
/* 28 */
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

/* Copyright (c) 2012-2017 The ANTLR Project. All rights reserved.
 * Use of this file is governed by the BSD 3-clause license that
 * can be found in the LICENSE.txt file in the project root.
 */

const CommonToken = (__webpack_require__(10).CommonToken);
class TokenFactory {}

/**
 * This default implementation of {@link TokenFactory} creates
 * {@link CommonToken} objects.
 */
class CommonTokenFactory extends TokenFactory {
  constructor(copyText) {
    super();
    /**
     * Indicates whether {@link CommonToken//setText} should be called after
     * constructing tokens to explicitly set the text. This is useful for cases
     * where the input stream might not be able to provide arbitrary substrings
     * of text from the input after the lexer creates a token (e.g. the
     * implementation of {@link CharStream//getText} in
     * {@link UnbufferedCharStream} throws an
     * {@link UnsupportedOperationException}). Explicitly setting the token text
     * allows {@link Token//getText} to be called at any time regardless of the
     * input stream implementation.
     *
     * <p>
     * The default value is {@code false} to avoid the performance and memory
     * overhead of copying text for every token unless explicitly requested.</p>
     */
    this.copyText = copyText === undefined ? false : copyText;
  }
  create(source, type, text, channel, start, stop, line, column) {
    const t = new CommonToken(source, type, channel, start, stop);
    t.line = line;
    t.column = column;
    if (text !== null) {
      t.text = text;
    } else if (this.copyText && source[1] !== null) {
      t.text = source[1].getText(start, stop);
    }
    return t;
  }
  createThin(type, text) {
    const t = new CommonToken(null, type);
    t.text = text;
    return t;
  }
}

/**
 * The default {@link CommonTokenFactory} instance.
 *
 * <p>
 * This token factory does not explicitly copy token text when constructing
 * tokens.</p>
 */
CommonTokenFactory.DEFAULT = new CommonTokenFactory();
module.exports = CommonTokenFactory;

/***/ }),
/* 29 */
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

/* Copyright (c) 2012-2017 The ANTLR Project. All rights reserved.
 * Use of this file is governed by the BSD 3-clause license that
 * can be found in the LICENSE.txt file in the project root.
 */

/**
 * The root of the ANTLR exception hierarchy. In general, ANTLR tracks just
 *  3 kinds of errors: prediction errors, failed predicate errors, and
 *  mismatched input errors. In each case, the parser knows where it is
 *  in the input, where it is in the ATN, the rule invocation stack,
 *  and what kind of problem occurred.
 */

const {
  PredicateTransition
} = __webpack_require__(15);
const {
  Interval
} = (__webpack_require__(14).Interval);
class RecognitionException extends Error {
  constructor(params) {
    super(params.message);
    if (!!Error.captureStackTrace) {
      Error.captureStackTrace(this, RecognitionException);
    } else {
      var stack = new Error().stack;
    }
    this.message = params.message;
    this.recognizer = params.recognizer;
    this.input = params.input;
    this.ctx = params.ctx;
    /**
     * The current {@link Token} when an error occurred. Since not all streams
     * support accessing symbols by index, we have to track the {@link Token}
     * instance itself
    */
    this.offendingToken = null;
    /**
     * Get the ATN state number the parser was in at the time the error
     * occurred. For {@link NoViableAltException} and
     * {@link LexerNoViableAltException} exceptions, this is the
     * {@link DecisionState} number. For others, it is the state whose outgoing
     * edge we couldn't match.
     */
    this.offendingState = -1;
    if (this.recognizer !== null) {
      this.offendingState = this.recognizer.state;
    }
  }

  /**
   * Gets the set of input symbols which could potentially follow the
   * previously matched symbol at the time this exception was thrown.
   *
   * <p>If the set of expected tokens is not known and could not be computed,
   * this method returns {@code null}.</p>
   *
   * @return The set of token types that could potentially follow the current
   * state in the ATN, or {@code null} if the information is not available.
   */
  getExpectedTokens() {
    if (this.recognizer !== null) {
      return this.recognizer.atn.getExpectedTokens(this.offendingState, this.ctx);
    } else {
      return null;
    }
  }

  // <p>If the state number is not known, this method returns -1.</p>
  toString() {
    return this.message;
  }
}
class LexerNoViableAltException extends RecognitionException {
  constructor(lexer, input, startIndex, deadEndConfigs) {
    super({
      message: "",
      recognizer: lexer,
      input: input,
      ctx: null
    });
    this.startIndex = startIndex;
    this.deadEndConfigs = deadEndConfigs;
  }
  toString() {
    let symbol = "";
    if (this.startIndex >= 0 && this.startIndex < this.input.size) {
      symbol = this.input.getText(new Interval(this.startIndex, this.startIndex));
    }
    return "LexerNoViableAltException" + symbol;
  }
}

/**
 * Indicates that the parser could not decide which of two or more paths
 * to take based upon the remaining input. It tracks the starting token
 * of the offending input and also knows where the parser was
 * in the various paths when the error. Reported by reportNoViableAlternative()
 */
class NoViableAltException extends RecognitionException {
  constructor(recognizer, input, startToken, offendingToken, deadEndConfigs, ctx) {
    ctx = ctx || recognizer._ctx;
    offendingToken = offendingToken || recognizer.getCurrentToken();
    startToken = startToken || recognizer.getCurrentToken();
    input = input || recognizer.getInputStream();
    super({
      message: "",
      recognizer: recognizer,
      input: input,
      ctx: ctx
    });
    // Which configurations did we try at input.index() that couldn't match
    // input.LT(1)?//
    this.deadEndConfigs = deadEndConfigs;
    // The token object at the start index; the input stream might
    // not be buffering tokens so get a reference to it. (At the
    // time the error occurred, of course the stream needs to keep a
    // buffer all of the tokens but later we might not have access to those.)
    this.startToken = startToken;
    this.offendingToken = offendingToken;
  }
}

/**
 * This signifies any kind of mismatched input exceptions such as
 * when the current input does not match the expected token.
*/
class InputMismatchException extends RecognitionException {
  constructor(recognizer) {
    super({
      message: "",
      recognizer: recognizer,
      input: recognizer.getInputStream(),
      ctx: recognizer._ctx
    });
    this.offendingToken = recognizer.getCurrentToken();
  }
}
function formatMessage(predicate, message) {
  if (message !== null) {
    return message;
  } else {
    return "failed predicate: {" + predicate + "}?";
  }
}

/**
 * A semantic predicate failed during validation. Validation of predicates
 * occurs when normally parsing the alternative just like matching a token.
 * Disambiguating predicate evaluation occurs when we test a predicate during
 * prediction.
*/
class FailedPredicateException extends RecognitionException {
  constructor(recognizer, predicate, message) {
    super({
      message: formatMessage(predicate, message || null),
      recognizer: recognizer,
      input: recognizer.getInputStream(),
      ctx: recognizer._ctx
    });
    const s = recognizer._interp.atn.states[recognizer.state];
    const trans = s.transitions[0];
    if (trans instanceof PredicateTransition) {
      this.ruleIndex = trans.ruleIndex;
      this.predicateIndex = trans.predIndex;
    } else {
      this.ruleIndex = 0;
      this.predicateIndex = 0;
    }
    this.predicate = predicate;
    this.offendingToken = recognizer.getCurrentToken();
  }
}
class ParseCancellationException extends Error {
  constructor() {
    super();
    Error.captureStackTrace(this, ParseCancellationException);
  }
}
module.exports = {
  RecognitionException,
  NoViableAltException,
  LexerNoViableAltException,
  InputMismatchException,
  FailedPredicateException,
  ParseCancellationException
};

/***/ }),
/* 30 */
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

/* Copyright (c) 2012-2017 The ANTLR Project. All rights reserved.
 * Use of this file is governed by the BSD 3-clause license that
 * can be found in the LICENSE.txt file in the project root.
 */

const {
  DFAState
} = __webpack_require__(31);
const {
  ATNConfigSet
} = __webpack_require__(32);
const {
  getCachedPredictionContext
} = __webpack_require__(16);
const {
  Map
} = __webpack_require__(9);
class ATNSimulator {
  constructor(atn, sharedContextCache) {
    /**
     * The context cache maps all PredictionContext objects that are ==
     * to a single cached copy. This cache is shared across all contexts
     * in all ATNConfigs in all DFA states.  We rebuild each ATNConfigSet
     * to use only cached nodes/graphs in addDFAState(). We don't want to
     * fill this during closure() since there are lots of contexts that
     * pop up but are not used ever again. It also greatly slows down closure().
     *
     * <p>This cache makes a huge difference in memory and a little bit in speed.
     * For the Java grammar on java.*, it dropped the memory requirements
     * at the end from 25M to 16M. We don't store any of the full context
     * graphs in the DFA because they are limited to local context only,
     * but apparently there's a lot of repetition there as well. We optimize
     * the config contexts before storing the config set in the DFA states
     * by literally rebuilding them with cached subgraphs only.</p>
     *
     * <p>I tried a cache for use during closure operations, that was
     * whacked after each adaptivePredict(). It cost a little bit
     * more time I think and doesn't save on the overall footprint
     * so it's not worth the complexity.</p>
     */
    this.atn = atn;
    this.sharedContextCache = sharedContextCache;
    return this;
  }
  getCachedContext(context) {
    if (this.sharedContextCache === null) {
      return context;
    }
    const visited = new Map();
    return getCachedPredictionContext(context, this.sharedContextCache, visited);
  }
}

// Must distinguish between missing edge and edge we know leads nowhere///
ATNSimulator.ERROR = new DFAState(0x7FFFFFFF, new ATNConfigSet());
module.exports = ATNSimulator;

/***/ }),
/* 31 */
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

/* Copyright (c) 2012-2017 The ANTLR Project. All rights reserved.
 * Use of this file is governed by the BSD 3-clause license that
 * can be found in the LICENSE.txt file in the project root.
 */

const {
  ATNConfigSet
} = __webpack_require__(32);
const {
  Hash,
  Set
} = __webpack_require__(9);

/**
 * Map a predicate to a predicted alternative.
 */
class PredPrediction {
  constructor(pred, alt) {
    this.alt = alt;
    this.pred = pred;
  }
  toString() {
    return "(" + this.pred + ", " + this.alt + ")";
  }
}

/**
 * A DFA state represents a set of possible ATN configurations.
 * As Aho, Sethi, Ullman p. 117 says "The DFA uses its state
 * to keep track of all possible states the ATN can be in after
 * reading each input symbol. That is to say, after reading
 * input a1a2..an, the DFA is in a state that represents the
 * subset T of the states of the ATN that are reachable from the
 * ATN's start state along some path labeled a1a2..an."
 * In conventional NFA&rarr;DFA conversion, therefore, the subset T
 * would be a bitset representing the set of states the
 * ATN could be in. We need to track the alt predicted by each
 * state as well, however. More importantly, we need to maintain
 * a stack of states, tracking the closure operations as they
 * jump from rule to rule, emulating rule invocations (method calls).
 * I have to add a stack to simulate the proper lookahead sequences for
 * the underlying LL grammar from which the ATN was derived.
 *
 * <p>I use a set of ATNConfig objects not simple states. An ATNConfig
 * is both a state (ala normal conversion) and a RuleContext describing
 * the chain of rules (if any) followed to arrive at that state.</p>
 *
 * <p>A DFA state may have multiple references to a particular state,
 * but with different ATN contexts (with same or different alts)
 * meaning that state was reached via a different set of rule invocations.</p>
 */
class DFAState {
  constructor(stateNumber, configs) {
    if (stateNumber === null) {
      stateNumber = -1;
    }
    if (configs === null) {
      configs = new ATNConfigSet();
    }
    this.stateNumber = stateNumber;
    this.configs = configs;
    /**
     * {@code edges[symbol]} points to target of symbol. Shift up by 1 so (-1)
     * {@link Token//EOF} maps to {@code edges[0]}.
     */
    this.edges = null;
    this.isAcceptState = false;
    /**
     * if accept state, what ttype do we match or alt do we predict?
     * This is set to {@link ATN//INVALID_ALT_NUMBER} when {@link//predicates}
     * {@code !=null} or {@link //requiresFullContext}.
     */
    this.prediction = 0;
    this.lexerActionExecutor = null;
    /**
     * Indicates that this state was created during SLL prediction that
     * discovered a conflict between the configurations in the state. Future
     * {@link ParserATNSimulator//execATN} invocations immediately jumped doing
     * full context prediction if this field is true.
     */
    this.requiresFullContext = false;
    /**
     * During SLL parsing, this is a list of predicates associated with the
     * ATN configurations of the DFA state. When we have predicates,
     * {@link //requiresFullContext} is {@code false} since full context
     * prediction evaluates predicates
     * on-the-fly. If this is not null, then {@link //prediction} is
     * {@link ATN//INVALID_ALT_NUMBER}.
     *
     * <p>We only use these for non-{@link //requiresFullContext} but
     * conflicting states. That
     * means we know from the context (it's $ or we don't dip into outer
     * context) that it's an ambiguity not a conflict.</p>
     *
     * <p>This list is computed by {@link
     * ParserATNSimulator//predicateDFAState}.</p>
     */
    this.predicates = null;
    return this;
  }

  /**
   * Get the set of all alts mentioned by all ATN configurations in this
   * DFA state.
   */
  getAltSet() {
    const alts = new Set();
    if (this.configs !== null) {
      for (let i = 0; i < this.configs.length; i++) {
        const c = this.configs[i];
        alts.add(c.alt);
      }
    }
    if (alts.length === 0) {
      return null;
    } else {
      return alts;
    }
  }

  /**
   * Two {@link DFAState} instances are equal if their ATN configuration sets
   * are the same. This method is used to see if a state already exists.
   *
   * <p>Because the number of alternatives and number of ATN configurations are
   * finite, there is a finite number of DFA states that can be processed.
   * This is necessary to show that the algorithm terminates.</p>
   *
   * <p>Cannot test the DFA state numbers here because in
   * {@link ParserATNSimulator//addDFAState} we need to know if any other state
   * exists that has this exact set of ATN configurations. The
   * {@link //stateNumber} is irrelevant.</p>
   */
  equals(other) {
    // compare set of ATN configurations in this set with other
    return this === other || other instanceof DFAState && this.configs.equals(other.configs);
  }
  toString() {
    let s = "" + this.stateNumber + ":" + this.configs;
    if (this.isAcceptState) {
      s = s + "=>";
      if (this.predicates !== null) s = s + this.predicates;else s = s + this.prediction;
    }
    return s;
  }
  hashCode() {
    const hash = new Hash();
    hash.update(this.configs);
    return hash.finish();
  }
}
module.exports = {
  DFAState,
  PredPrediction
};

/***/ }),
/* 32 */
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

/* Copyright (c) 2012-2017 The ANTLR Project. All rights reserved.
 * Use of this file is governed by the BSD 3-clause license that
 * can be found in the LICENSE.txt file in the project root.
 */

const ATN = __webpack_require__(7);
const Utils = __webpack_require__(9);
const {
  SemanticContext
} = __webpack_require__(13);
const {
  merge
} = __webpack_require__(16);
function hashATNConfig(c) {
  return c.hashCodeForConfigSet();
}
function equalATNConfigs(a, b) {
  if (a === b) {
    return true;
  } else if (a === null || b === null) {
    return false;
  } else return a.equalsForConfigSet(b);
}

/**
 * Specialized {@link Set}{@code <}{@link ATNConfig}{@code >} that can track
 * info about the set, with support for combining similar configurations using a
 * graph-structured stack
 */
class ATNConfigSet {
  constructor(fullCtx) {
    /**
     * The reason that we need this is because we don't want the hash map to use
     * the standard hash code and equals. We need all configurations with the
     * same
     * {@code (s,i,_,semctx)} to be equal. Unfortunately, this key effectively
     * doubles
     * the number of objects associated with ATNConfigs. The other solution is
     * to
     * use a hash table that lets us specify the equals/hashcode operation.
     * All configs but hashed by (s, i, _, pi) not including context. Wiped out
     * when we go readonly as this set becomes a DFA state
     */
    this.configLookup = new Utils.Set(hashATNConfig, equalATNConfigs);
    /**
     * Indicates that this configuration set is part of a full context
     * LL prediction. It will be used to determine how to merge $. With SLL
     * it's a wildcard whereas it is not for LL context merge
     */
    this.fullCtx = fullCtx === undefined ? true : fullCtx;
    /**
     * Indicates that the set of configurations is read-only. Do not
     * allow any code to manipulate the set; DFA states will point at
     * the sets and they must not change. This does not protect the other
     * fields; in particular, conflictingAlts is set after
     * we've made this readonly
     */
    this.readOnly = false;
    // Track the elements as they are added to the set; supports get(i)///
    this.configs = [];

    // TODO: these fields make me pretty uncomfortable but nice to pack up info
    // together, saves recomputation
    // TODO: can we track conflicts as they are added to save scanning configs
    // later?
    this.uniqueAlt = 0;
    this.conflictingAlts = null;

    /**
     * Used in parser and lexer. In lexer, it indicates we hit a pred
     * while computing a closure operation. Don't make a DFA state from this
     */
    this.hasSemanticContext = false;
    this.dipsIntoOuterContext = false;
    this.cachedHashCode = -1;
  }

  /**
   * Adding a new config means merging contexts with existing configs for
   * {@code (s, i, pi, _)}, where {@code s} is the
   * {@link ATNConfig//state}, {@code i} is the {@link ATNConfig//alt}, and
   * {@code pi} is the {@link ATNConfig//semanticContext}. We use
   * {@code (s,i,pi)} as key.
   *
   * <p>This method updates {@link //dipsIntoOuterContext} and
   * {@link //hasSemanticContext} when necessary.</p>
   */
  add(config, mergeCache) {
    if (mergeCache === undefined) {
      mergeCache = null;
    }
    if (this.readOnly) {
      throw "This set is readonly";
    }
    if (config.semanticContext !== SemanticContext.NONE) {
      this.hasSemanticContext = true;
    }
    if (config.reachesIntoOuterContext > 0) {
      this.dipsIntoOuterContext = true;
    }
    const existing = this.configLookup.add(config);
    if (existing === config) {
      this.cachedHashCode = -1;
      this.configs.push(config); // track order here
      return true;
    }
    // a previous (s,i,pi,_), merge with it and save result
    const rootIsWildcard = !this.fullCtx;
    const merged = merge(existing.context, config.context, rootIsWildcard, mergeCache);
    /**
     * no need to check for existing.context, config.context in cache
     * since only way to create new graphs is "call rule" and here. We
     * cache at both places
     */
    existing.reachesIntoOuterContext = Math.max(existing.reachesIntoOuterContext, config.reachesIntoOuterContext);
    // make sure to preserve the precedence filter suppression during the merge
    if (config.precedenceFilterSuppressed) {
      existing.precedenceFilterSuppressed = true;
    }
    existing.context = merged; // replace context; no need to alt mapping
    return true;
  }
  getStates() {
    const states = new Utils.Set();
    for (let i = 0; i < this.configs.length; i++) {
      states.add(this.configs[i].state);
    }
    return states;
  }
  getPredicates() {
    const preds = [];
    for (let i = 0; i < this.configs.length; i++) {
      const c = this.configs[i].semanticContext;
      if (c !== SemanticContext.NONE) {
        preds.push(c.semanticContext);
      }
    }
    return preds;
  }
  optimizeConfigs(interpreter) {
    if (this.readOnly) {
      throw "This set is readonly";
    }
    if (this.configLookup.length === 0) {
      return;
    }
    for (let i = 0; i < this.configs.length; i++) {
      const config = this.configs[i];
      config.context = interpreter.getCachedContext(config.context);
    }
  }
  addAll(coll) {
    for (let i = 0; i < coll.length; i++) {
      this.add(coll[i]);
    }
    return false;
  }
  equals(other) {
    return this === other || other instanceof ATNConfigSet && Utils.equalArrays(this.configs, other.configs) && this.fullCtx === other.fullCtx && this.uniqueAlt === other.uniqueAlt && this.conflictingAlts === other.conflictingAlts && this.hasSemanticContext === other.hasSemanticContext && this.dipsIntoOuterContext === other.dipsIntoOuterContext;
  }
  hashCode() {
    const hash = new Utils.Hash();
    hash.update(this.configs);
    return hash.finish();
  }
  updateHashCode(hash) {
    if (this.readOnly) {
      if (this.cachedHashCode === -1) {
        this.cachedHashCode = this.hashCode();
      }
      hash.update(this.cachedHashCode);
    } else {
      hash.update(this.hashCode());
    }
  }
  isEmpty() {
    return this.configs.length === 0;
  }
  contains(item) {
    if (this.configLookup === null) {
      throw "This method is not implemented for readonly sets.";
    }
    return this.configLookup.contains(item);
  }
  containsFast(item) {
    if (this.configLookup === null) {
      throw "This method is not implemented for readonly sets.";
    }
    return this.configLookup.containsFast(item);
  }
  clear() {
    if (this.readOnly) {
      throw "This set is readonly";
    }
    this.configs = [];
    this.cachedHashCode = -1;
    this.configLookup = new Utils.Set();
  }
  setReadonly(readOnly) {
    this.readOnly = readOnly;
    if (readOnly) {
      this.configLookup = null; // can't mod, no need for lookup cache
    }
  }
  toString() {
    return Utils.arrayToString(this.configs) + (this.hasSemanticContext ? ",hasSemanticContext=" + this.hasSemanticContext : "") + (this.uniqueAlt !== ATN.INVALID_ALT_NUMBER ? ",uniqueAlt=" + this.uniqueAlt : "") + (this.conflictingAlts !== null ? ",conflictingAlts=" + this.conflictingAlts : "") + (this.dipsIntoOuterContext ? ",dipsIntoOuterContext" : "");
  }
  get items() {
    return this.configs;
  }
  get length() {
    return this.configs.length;
  }
}
class OrderedATNConfigSet extends ATNConfigSet {
  constructor() {
    super();
    this.configLookup = new Utils.Set();
  }
}
module.exports = {
  ATNConfigSet,
  OrderedATNConfigSet
};

/***/ }),
/* 33 */
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

/* Copyright (c) 2012-2017 The ANTLR Project. All rights reserved.
 * Use of this file is governed by the BSD 3-clause license that
 * can be found in the LICENSE.txt file in the project root.
 */

const {
  hashStuff
} = __webpack_require__(9);
const {
  LexerIndexedCustomAction
} = __webpack_require__(23);
class LexerActionExecutor {
  /**
   * Represents an executor for a sequence of lexer actions which traversed during
   * the matching operation of a lexer rule (token).
   *
   * <p>The executor tracks position information for position-dependent lexer actions
   * efficiently, ensuring that actions appearing only at the end of the rule do
   * not cause bloating of the {@link DFA} created for the lexer.</p>
   */
  constructor(lexerActions) {
    this.lexerActions = lexerActions === null ? [] : lexerActions;
    /**
     * Caches the result of {@link //hashCode} since the hash code is an element
     * of the performance-critical {@link LexerATNConfig//hashCode} operation
     */
    this.cachedHashCode = hashStuff(lexerActions); // "".join([str(la) for la in
    // lexerActions]))
    return this;
  }

  /**
   * Creates a {@link LexerActionExecutor} which encodes the current offset
   * for position-dependent lexer actions.
   *
   * <p>Normally, when the executor encounters lexer actions where
   * {@link LexerAction//isPositionDependent} returns {@code true}, it calls
   * {@link IntStream//seek} on the input {@link CharStream} to set the input
   * position to the <em>end</em> of the current token. This behavior provides
   * for efficient DFA representation of lexer actions which appear at the end
   * of a lexer rule, even when the lexer rule matches a variable number of
   * characters.</p>
   *
   * <p>Prior to traversing a match transition in the ATN, the current offset
   * from the token start index is assigned to all position-dependent lexer
   * actions which have not already been assigned a fixed offset. By storing
   * the offsets relative to the token start index, the DFA representation of
   * lexer actions which appear in the middle of tokens remains efficient due
   * to sharing among tokens of the same length, regardless of their absolute
   * position in the input stream.</p>
   *
   * <p>If the current executor already has offsets assigned to all
   * position-dependent lexer actions, the method returns {@code this}.</p>
   *
   * @param offset The current offset to assign to all position-dependent
   * lexer actions which do not already have offsets assigned.
   *
   * @return {LexerActionExecutor} A {@link LexerActionExecutor} which stores input stream offsets
   * for all position-dependent lexer actions.
   */
  fixOffsetBeforeMatch(offset) {
    let updatedLexerActions = null;
    for (let i = 0; i < this.lexerActions.length; i++) {
      if (this.lexerActions[i].isPositionDependent && !(this.lexerActions[i] instanceof LexerIndexedCustomAction)) {
        if (updatedLexerActions === null) {
          updatedLexerActions = this.lexerActions.concat([]);
        }
        updatedLexerActions[i] = new LexerIndexedCustomAction(offset, this.lexerActions[i]);
      }
    }
    if (updatedLexerActions === null) {
      return this;
    } else {
      return new LexerActionExecutor(updatedLexerActions);
    }
  }

  /**
   * Execute the actions encapsulated by this executor within the context of a
   * particular {@link Lexer}.
   *
   * <p>This method calls {@link IntStream//seek} to set the position of the
   * {@code input} {@link CharStream} prior to calling
   * {@link LexerAction//execute} on a position-dependent action. Before the
   * method returns, the input position will be restored to the same position
   * it was in when the method was invoked.</p>
   *
   * @param lexer The lexer instance.
   * @param input The input stream which is the source for the current token.
   * When this method is called, the current {@link IntStream//index} for
   * {@code input} should be the start of the following token, i.e. 1
   * character past the end of the current token.
   * @param startIndex The token start index. This value may be passed to
   * {@link IntStream//seek} to set the {@code input} position to the beginning
   * of the token.
   */
  execute(lexer, input, startIndex) {
    let requiresSeek = false;
    const stopIndex = input.index;
    try {
      for (let i = 0; i < this.lexerActions.length; i++) {
        let lexerAction = this.lexerActions[i];
        if (lexerAction instanceof LexerIndexedCustomAction) {
          const offset = lexerAction.offset;
          input.seek(startIndex + offset);
          lexerAction = lexerAction.action;
          requiresSeek = startIndex + offset !== stopIndex;
        } else if (lexerAction.isPositionDependent) {
          input.seek(stopIndex);
          requiresSeek = false;
        }
        lexerAction.execute(lexer);
      }
    } finally {
      if (requiresSeek) {
        input.seek(stopIndex);
      }
    }
  }
  hashCode() {
    return this.cachedHashCode;
  }
  updateHashCode(hash) {
    hash.update(this.cachedHashCode);
  }
  equals(other) {
    if (this === other) {
      return true;
    } else if (!(other instanceof LexerActionExecutor)) {
      return false;
    } else if (this.cachedHashCode != other.cachedHashCode) {
      return false;
    } else if (this.lexerActions.length != other.lexerActions.length) {
      return false;
    } else {
      const numActions = this.lexerActions.length;
      for (let idx = 0; idx < numActions; ++idx) {
        if (!this.lexerActions[idx].equals(other.lexerActions[idx])) {
          return false;
        }
      }
      return true;
    }
  }

  /**
   * Creates a {@link LexerActionExecutor} which executes the actions for
   * the input {@code lexerActionExecutor} followed by a specified
   * {@code lexerAction}.
   *
   * @param lexerActionExecutor The executor for actions already traversed by
   * the lexer while matching a token within a particular
   * {@link LexerATNConfig}. If this is {@code null}, the method behaves as
   * though it were an empty executor.
   * @param lexerAction The lexer action to execute after the actions
   * specified in {@code lexerActionExecutor}.
   *
   * @return {LexerActionExecutor} A {@link LexerActionExecutor} for executing the combine actions
   * of {@code lexerActionExecutor} and {@code lexerAction}.
   */
  static append(lexerActionExecutor, lexerAction) {
    if (lexerActionExecutor === null) {
      return new LexerActionExecutor([lexerAction]);
    }
    const lexerActions = lexerActionExecutor.lexerActions.concat([lexerAction]);
    return new LexerActionExecutor(lexerActions);
  }
}
module.exports = LexerActionExecutor;

/***/ }),
/* 34 */
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

/* Copyright (c) 2012-2017 The ANTLR Project. All rights reserved.
 * Use of this file is governed by the BSD 3-clause license that
 * can be found in the LICENSE.txt file in the project root.
 */

const Utils = __webpack_require__(9);
const {
  Set,
  BitSet,
  DoubleDict
} = Utils;
const ATN = __webpack_require__(7);
const {
  ATNState,
  RuleStopState
} = __webpack_require__(12);
const {
  ATNConfig
} = __webpack_require__(11);
const {
  ATNConfigSet
} = __webpack_require__(32);
const {
  Token
} = __webpack_require__(10);
const {
  DFAState,
  PredPrediction
} = __webpack_require__(31);
const ATNSimulator = __webpack_require__(30);
const PredictionMode = __webpack_require__(35);
const RuleContext = __webpack_require__(17);
const ParserRuleContext = __webpack_require__(36);
const {
  SemanticContext
} = __webpack_require__(13);
const {
  PredictionContext
} = __webpack_require__(16);
const {
  Interval
} = __webpack_require__(14);
const {
  Transition,
  SetTransition,
  NotSetTransition,
  RuleTransition,
  ActionTransition
} = __webpack_require__(15);
const {
  NoViableAltException
} = __webpack_require__(29);
const {
  SingletonPredictionContext,
  predictionContextFromRuleContext
} = __webpack_require__(16);

/**
 * The embodiment of the adaptive LL(*), ALL(*), parsing strategy.
 *
 * <p>
 * The basic complexity of the adaptive strategy makes it harder to understand.
 * We begin with ATN simulation to build paths in a DFA. Subsequent prediction
 * requests go through the DFA first. If they reach a state without an edge for
 * the current symbol, the algorithm fails over to the ATN simulation to
 * complete the DFA path for the current input (until it finds a conflict state
 * or uniquely predicting state).</p>
 *
 * <p>
 * All of that is done without using the outer context because we want to create
 * a DFA that is not dependent upon the rule invocation stack when we do a
 * prediction. One DFA works in all contexts. We avoid using context not
 * necessarily because it's slower, although it can be, but because of the DFA
 * caching problem. The closure routine only considers the rule invocation stack
 * created during prediction beginning in the decision rule. For example, if
 * prediction occurs without invoking another rule's ATN, there are no context
 * stacks in the configurations. When lack of context leads to a conflict, we
 * don't know if it's an ambiguity or a weakness in the strong LL(*) parsing
 * strategy (versus full LL(*)).</p>
 *
 * <p>
 * When SLL yields a configuration set with conflict, we rewind the input and
 * retry the ATN simulation, this time using full outer context without adding
 * to the DFA. Configuration context stacks will be the full invocation stacks
 * from the start rule. If we get a conflict using full context, then we can
 * definitively say we have a true ambiguity for that input sequence. If we
 * don't get a conflict, it implies that the decision is sensitive to the outer
 * context. (It is not context-sensitive in the sense of context-sensitive
 * grammars.)</p>
 *
 * <p>
 * The next time we reach this DFA state with an SLL conflict, through DFA
 * simulation, we will again retry the ATN simulation using full context mode.
 * This is slow because we can't save the results and have to "interpret" the
 * ATN each time we get that input.</p>
 *
 * <p>
 * <strong>CACHING FULL CONTEXT PREDICTIONS</strong></p>
 *
 * <p>
 * We could cache results from full context to predicted alternative easily and
 * that saves a lot of time but doesn't work in presence of predicates. The set
 * of visible predicates from the ATN start state changes depending on the
 * context, because closure can fall off the end of a rule. I tried to cache
 * tuples (stack context, semantic context, predicted alt) but it was slower
 * than interpreting and much more complicated. Also required a huge amount of
 * memory. The goal is not to create the world's fastest parser anyway. I'd like
 * to keep this algorithm simple. By launching multiple threads, we can improve
 * the speed of parsing across a large number of files.</p>
 *
 * <p>
 * There is no strict ordering between the amount of input used by SLL vs LL,
 * which makes it really hard to build a cache for full context. Let's say that
 * we have input A B C that leads to an SLL conflict with full context X. That
 * implies that using X we might only use A B but we could also use A B C D to
 * resolve conflict. Input A B C D could predict alternative 1 in one position
 * in the input and A B C E could predict alternative 2 in another position in
 * input. The conflicting SLL configurations could still be non-unique in the
 * full context prediction, which would lead us to requiring more input than the
 * original A B C.	To make a	prediction cache work, we have to track	the exact
 * input	used during the previous prediction. That amounts to a cache that maps
 * X to a specific DFA for that context.</p>
 *
 * <p>
 * Something should be done for left-recursive expression predictions. They are
 * likely LL(1) + pred eval. Easier to do the whole SLL unless error and retry
 * with full LL thing Sam does.</p>
 *
 * <p>
 * <strong>AVOIDING FULL CONTEXT PREDICTION</strong></p>
 *
 * <p>
 * We avoid doing full context retry when the outer context is empty, we did not
 * dip into the outer context by falling off the end of the decision state rule,
 * or when we force SLL mode.</p>
 *
 * <p>
 * As an example of the not dip into outer context case, consider as super
 * constructor calls versus function calls. One grammar might look like
 * this:</p>
 *
 * <pre>
 * ctorBody
 *   : '{' superCall? stat* '}'
 *   ;
 * </pre>
 *
 * <p>
 * Or, you might see something like</p>
 *
 * <pre>
 * stat
 *   : superCall ';'
 *   | expression ';'
 *   | ...
 *   ;
 * </pre>
 *
 * <p>
 * In both cases I believe that no closure operations will dip into the outer
 * context. In the first case ctorBody in the worst case will stop at the '}'.
 * In the 2nd case it should stop at the ';'. Both cases should stay within the
 * entry rule and not dip into the outer context.</p>
 *
 * <p>
 * <strong>PREDICATES</strong></p>
 *
 * <p>
 * Predicates are always evaluated if present in either SLL or LL both. SLL and
 * LL simulation deals with predicates differently. SLL collects predicates as
 * it performs closure operations like ANTLR v3 did. It delays predicate
 * evaluation until it reaches and accept state. This allows us to cache the SLL
 * ATN simulation whereas, if we had evaluated predicates on-the-fly during
 * closure, the DFA state configuration sets would be different and we couldn't
 * build up a suitable DFA.</p>
 *
 * <p>
 * When building a DFA accept state during ATN simulation, we evaluate any
 * predicates and return the sole semantically valid alternative. If there is
 * more than 1 alternative, we report an ambiguity. If there are 0 alternatives,
 * we throw an exception. Alternatives without predicates act like they have
 * true predicates. The simple way to think about it is to strip away all
 * alternatives with false predicates and choose the minimum alternative that
 * remains.</p>
 *
 * <p>
 * When we start in the DFA and reach an accept state that's predicated, we test
 * those and return the minimum semantically viable alternative. If no
 * alternatives are viable, we throw an exception.</p>
 *
 * <p>
 * During full LL ATN simulation, closure always evaluates predicates and
 * on-the-fly. This is crucial to reducing the configuration set size during
 * closure. It hits a landmine when parsing with the Java grammar, for example,
 * without this on-the-fly evaluation.</p>
 *
 * <p>
 * <strong>SHARING DFA</strong></p>
 *
 * <p>
 * All instances of the same parser share the same decision DFAs through a
 * static field. Each instance gets its own ATN simulator but they share the
 * same {@link //decisionToDFA} field. They also share a
 * {@link PredictionContextCache} object that makes sure that all
 * {@link PredictionContext} objects are shared among the DFA states. This makes
 * a big size difference.</p>
 *
 * <p>
 * <strong>THREAD SAFETY</strong></p>
 *
 * <p>
 * The {@link ParserATNSimulator} locks on the {@link //decisionToDFA} field when
 * it adds a new DFA object to that array. {@link //addDFAEdge}
 * locks on the DFA for the current decision when setting the
 * {@link DFAState//edges} field. {@link //addDFAState} locks on
 * the DFA for the current decision when looking up a DFA state to see if it
 * already exists. We must make sure that all requests to add DFA states that
 * are equivalent result in the same shared DFA object. This is because lots of
 * threads will be trying to update the DFA at once. The
 * {@link //addDFAState} method also locks inside the DFA lock
 * but this time on the shared context cache when it rebuilds the
 * configurations' {@link PredictionContext} objects using cached
 * subgraphs/nodes. No other locking occurs, even during DFA simulation. This is
 * safe as long as we can guarantee that all threads referencing
 * {@code s.edge[t]} get the same physical target {@link DFAState}, or
 * {@code null}. Once into the DFA, the DFA simulation does not reference the
 * {@link DFA//states} map. It follows the {@link DFAState//edges} field to new
 * targets. The DFA simulator will either find {@link DFAState//edges} to be
 * {@code null}, to be non-{@code null} and {@code dfa.edges[t]} null, or
 * {@code dfa.edges[t]} to be non-null. The
 * {@link //addDFAEdge} method could be racing to set the field
 * but in either case the DFA simulator works; if {@code null}, and requests ATN
 * simulation. It could also race trying to get {@code dfa.edges[t]}, but either
 * way it will work because it's not doing a test and set operation.</p>
 *
 * <p>
 * <strong>Starting with SLL then failing to combined SLL/LL (Two-Stage
 * Parsing)</strong></p>
 *
 * <p>
 * Sam pointed out that if SLL does not give a syntax error, then there is no
 * point in doing full LL, which is slower. We only have to try LL if we get a
 * syntax error. For maximum speed, Sam starts the parser set to pure SLL
 * mode with the {@link BailErrorStrategy}:</p>
 *
 * <pre>
 * parser.{@link Parser//getInterpreter() getInterpreter()}.{@link //setPredictionMode setPredictionMode}{@code (}{@link PredictionMode//SLL}{@code )};
 * parser.{@link Parser//setErrorHandler setErrorHandler}(new {@link BailErrorStrategy}());
 * </pre>
 *
 * <p>
 * If it does not get a syntax error, then we're done. If it does get a syntax
 * error, we need to retry with the combined SLL/LL strategy.</p>
 *
 * <p>
 * The reason this works is as follows. If there are no SLL conflicts, then the
 * grammar is SLL (at least for that input set). If there is an SLL conflict,
 * the full LL analysis must yield a set of viable alternatives which is a
 * subset of the alternatives reported by SLL. If the LL set is a singleton,
 * then the grammar is LL but not SLL. If the LL set is the same size as the SLL
 * set, the decision is SLL. If the LL set has size &gt; 1, then that decision
 * is truly ambiguous on the current input. If the LL set is smaller, then the
 * SLL conflict resolution might choose an alternative that the full LL would
 * rule out as a possibility based upon better context information. If that's
 * the case, then the SLL parse will definitely get an error because the full LL
 * analysis says it's not viable. If SLL conflict resolution chooses an
 * alternative within the LL set, them both SLL and LL would choose the same
 * alternative because they both choose the minimum of multiple conflicting
 * alternatives.</p>
 *
 * <p>
 * Let's say we have a set of SLL conflicting alternatives {@code {1, 2, 3}} and
 * a smaller LL set called <em>s</em>. If <em>s</em> is {@code {2, 3}}, then SLL
 * parsing will get an error because SLL will pursue alternative 1. If
 * <em>s</em> is {@code {1, 2}} or {@code {1, 3}} then both SLL and LL will
 * choose the same alternative because alternative one is the minimum of either
 * set. If <em>s</em> is {@code {2}} or {@code {3}} then SLL will get a syntax
 * error. If <em>s</em> is {@code {1}} then SLL will succeed.</p>
 *
 * <p>
 * Of course, if the input is invalid, then we will get an error for sure in
 * both SLL and LL parsing. Erroneous input will therefore require 2 passes over
 * the input.</p>
 */
class ParserATNSimulator extends ATNSimulator {
  constructor(parser, atn, decisionToDFA, sharedContextCache) {
    super(atn, sharedContextCache);
    this.parser = parser;
    this.decisionToDFA = decisionToDFA;
    // SLL, LL, or LL + exact ambig detection?//
    this.predictionMode = PredictionMode.LL;
    // LAME globals to avoid parameters!!!!! I need these down deep in predTransition
    this._input = null;
    this._startIndex = 0;
    this._outerContext = null;
    this._dfa = null;
    /**
     * Each prediction operation uses a cache for merge of prediction contexts.
     *  Don't keep around as it wastes huge amounts of memory. DoubleKeyMap
     *  isn't synchronized but we're ok since two threads shouldn't reuse same
     *  parser/atnsim object because it can only handle one input at a time.
     *  This maps graphs a and b to merged result c. (a,b)&rarr;c. We can avoid
     *  the merge if we ever see a and b again.  Note that (b,a)&rarr;c should
     *  also be examined during cache lookup.
     */
    this.mergeCache = null;
    this.debug = false;
    this.debug_closure = false;
    this.debug_add = false;
    this.debug_list_atn_decisions = false;
    this.dfa_debug = false;
    this.retry_debug = false;
  }
  reset() {}
  adaptivePredict(input, decision, outerContext) {
    if (this.debug || this.debug_list_atn_decisions) {
      console.log("adaptivePredict decision " + decision + " exec LA(1)==" + this.getLookaheadName(input) + " line " + input.LT(1).line + ":" + input.LT(1).column);
    }
    this._input = input;
    this._startIndex = input.index;
    this._outerContext = outerContext;
    const dfa = this.decisionToDFA[decision];
    this._dfa = dfa;
    const m = input.mark();
    const index = input.index;

    // Now we are certain to have a specific decision's DFA
    // But, do we still need an initial state?
    try {
      let s0;
      if (dfa.precedenceDfa) {
        // the start state for a precedence DFA depends on the current
        // parser precedence, and is provided by a DFA method.
        s0 = dfa.getPrecedenceStartState(this.parser.getPrecedence());
      } else {
        // the start state for a "regular" DFA is just s0
        s0 = dfa.s0;
      }
      if (s0 === null) {
        if (outerContext === null) {
          outerContext = RuleContext.EMPTY;
        }
        if (this.debug || this.debug_list_atn_decisions) {
          console.log("predictATN decision " + dfa.decision + " exec LA(1)==" + this.getLookaheadName(input) + ", outerContext=" + outerContext.toString(this.parser.ruleNames));
        }
        const fullCtx = false;
        let s0_closure = this.computeStartState(dfa.atnStartState, RuleContext.EMPTY, fullCtx);
        if (dfa.precedenceDfa) {
          // If this is a precedence DFA, we use applyPrecedenceFilter
          // to convert the computed start state to a precedence start
          // state. We then use DFA.setPrecedenceStartState to set the
          // appropriate start state for the precedence level rather
          // than simply setting DFA.s0.
          //
          dfa.s0.configs = s0_closure; // not used for prediction but useful to know start configs anyway
          s0_closure = this.applyPrecedenceFilter(s0_closure);
          s0 = this.addDFAState(dfa, new DFAState(null, s0_closure));
          dfa.setPrecedenceStartState(this.parser.getPrecedence(), s0);
        } else {
          s0 = this.addDFAState(dfa, new DFAState(null, s0_closure));
          dfa.s0 = s0;
        }
      }
      const alt = this.execATN(dfa, s0, input, index, outerContext);
      if (this.debug) {
        console.log("DFA after predictATN: " + dfa.toString(this.parser.literalNames, this.parser.symbolicNames));
      }
      return alt;
    } finally {
      this._dfa = null;
      this.mergeCache = null; // wack cache after each prediction
      input.seek(index);
      input.release(m);
    }
  }

  /**
   * Performs ATN simulation to compute a predicted alternative based
   *  upon the remaining input, but also updates the DFA cache to avoid
   *  having to traverse the ATN again for the same input sequence.
   *
   * There are some key conditions we're looking for after computing a new
   * set of ATN configs (proposed DFA state):
   *       if the set is empty, there is no viable alternative for current symbol
   *       does the state uniquely predict an alternative?
   *       does the state have a conflict that would prevent us from
   *         putting it on the work list?
   *
   * We also have some key operations to do:
   *       add an edge from previous DFA state to potentially new DFA state, D,
   *         upon current symbol but only if adding to work list, which means in all
   *         cases except no viable alternative (and possibly non-greedy decisions?)
   *       collecting predicates and adding semantic context to DFA accept states
   *       adding rule context to context-sensitive DFA accept states
   *       consuming an input symbol
   *       reporting a conflict
   *       reporting an ambiguity
   *       reporting a context sensitivity
   *       reporting insufficient predicates
   *
   * cover these cases:
   *    dead end
   *    single alt
   *    single alt + preds
   *    conflict
   *    conflict + preds
   *
   */
  execATN(dfa, s0, input, startIndex, outerContext) {
    if (this.debug || this.debug_list_atn_decisions) {
      console.log("execATN decision " + dfa.decision + " exec LA(1)==" + this.getLookaheadName(input) + " line " + input.LT(1).line + ":" + input.LT(1).column);
    }
    let alt;
    let previousD = s0;
    if (this.debug) {
      console.log("s0 = " + s0);
    }
    let t = input.LA(1);
    while (true) {
      // while more work
      let D = this.getExistingTargetState(previousD, t);
      if (D === null) {
        D = this.computeTargetState(dfa, previousD, t);
      }
      if (D === ATNSimulator.ERROR) {
        // if any configs in previous dipped into outer context, that
        // means that input up to t actually finished entry rule
        // at least for SLL decision. Full LL doesn't dip into outer
        // so don't need special case.
        // We will get an error no matter what so delay until after
        // decision; better error message. Also, no reachable target
        // ATN states in SLL implies LL will also get nowhere.
        // If conflict in states that dip out, choose min since we
        // will get error no matter what.
        const e = this.noViableAlt(input, outerContext, previousD.configs, startIndex);
        input.seek(startIndex);
        alt = this.getSynValidOrSemInvalidAltThatFinishedDecisionEntryRule(previousD.configs, outerContext);
        if (alt !== ATN.INVALID_ALT_NUMBER) {
          return alt;
        } else {
          throw e;
        }
      }
      if (D.requiresFullContext && this.predictionMode !== PredictionMode.SLL) {
        // IF PREDS, MIGHT RESOLVE TO SINGLE ALT => SLL (or syntax error)
        let conflictingAlts = null;
        if (D.predicates !== null) {
          if (this.debug) {
            console.log("DFA state has preds in DFA sim LL failover");
          }
          const conflictIndex = input.index;
          if (conflictIndex !== startIndex) {
            input.seek(startIndex);
          }
          conflictingAlts = this.evalSemanticContext(D.predicates, outerContext, true);
          if (conflictingAlts.length === 1) {
            if (this.debug) {
              console.log("Full LL avoided");
            }
            return conflictingAlts.minValue();
          }
          if (conflictIndex !== startIndex) {
            // restore the index so reporting the fallback to full
            // context occurs with the index at the correct spot
            input.seek(conflictIndex);
          }
        }
        if (this.dfa_debug) {
          console.log("ctx sensitive state " + outerContext + " in " + D);
        }
        const fullCtx = true;
        const s0_closure = this.computeStartState(dfa.atnStartState, outerContext, fullCtx);
        this.reportAttemptingFullContext(dfa, conflictingAlts, D.configs, startIndex, input.index);
        alt = this.execATNWithFullContext(dfa, D, s0_closure, input, startIndex, outerContext);
        return alt;
      }
      if (D.isAcceptState) {
        if (D.predicates === null) {
          return D.prediction;
        }
        const stopIndex = input.index;
        input.seek(startIndex);
        const alts = this.evalSemanticContext(D.predicates, outerContext, true);
        if (alts.length === 0) {
          throw this.noViableAlt(input, outerContext, D.configs, startIndex);
        } else if (alts.length === 1) {
          return alts.minValue();
        } else {
          // report ambiguity after predicate evaluation to make sure the correct set of ambig alts is reported.
          this.reportAmbiguity(dfa, D, startIndex, stopIndex, false, alts, D.configs);
          return alts.minValue();
        }
      }
      previousD = D;
      if (t !== Token.EOF) {
        input.consume();
        t = input.LA(1);
      }
    }
  }

  /**
   * Get an existing target state for an edge in the DFA. If the target state
   * for the edge has not yet been computed or is otherwise not available,
   * this method returns {@code null}.
   *
   * @param previousD The current DFA state
   * @param t The next input symbol
   * @return The existing target DFA state for the given input symbol
   * {@code t}, or {@code null} if the target state for this edge is not
   * already cached
   */
  getExistingTargetState(previousD, t) {
    const edges = previousD.edges;
    if (edges === null) {
      return null;
    } else {
      return edges[t + 1] || null;
    }
  }

  /**
   * Compute a target state for an edge in the DFA, and attempt to add the
   * computed state and corresponding edge to the DFA.
   *
   * @param dfa The DFA
   * @param previousD The current DFA state
   * @param t The next input symbol
   *
   * @return The computed target DFA state for the given input symbol
   * {@code t}. If {@code t} does not lead to a valid DFA state, this method
   * returns {@link //ERROR
   */
  computeTargetState(dfa, previousD, t) {
    const reach = this.computeReachSet(previousD.configs, t, false);
    if (reach === null) {
      this.addDFAEdge(dfa, previousD, t, ATNSimulator.ERROR);
      return ATNSimulator.ERROR;
    }
    // create new target state; we'll add to DFA after it's complete
    let D = new DFAState(null, reach);
    const predictedAlt = this.getUniqueAlt(reach);
    if (this.debug) {
      const altSubSets = PredictionMode.getConflictingAltSubsets(reach);
      console.log("SLL altSubSets=" + Utils.arrayToString(altSubSets) + /*", previous=" + previousD.configs + */
      ", configs=" + reach + ", predict=" + predictedAlt + ", allSubsetsConflict=" + PredictionMode.allSubsetsConflict(altSubSets) + ", conflictingAlts=" + this.getConflictingAlts(reach));
    }
    if (predictedAlt !== ATN.INVALID_ALT_NUMBER) {
      // NO CONFLICT, UNIQUELY PREDICTED ALT
      D.isAcceptState = true;
      D.configs.uniqueAlt = predictedAlt;
      D.prediction = predictedAlt;
    } else if (PredictionMode.hasSLLConflictTerminatingPrediction(this.predictionMode, reach)) {
      // MORE THAN ONE VIABLE ALTERNATIVE
      D.configs.conflictingAlts = this.getConflictingAlts(reach);
      D.requiresFullContext = true;
      // in SLL-only mode, we will stop at this state and return the minimum alt
      D.isAcceptState = true;
      D.prediction = D.configs.conflictingAlts.minValue();
    }
    if (D.isAcceptState && D.configs.hasSemanticContext) {
      this.predicateDFAState(D, this.atn.getDecisionState(dfa.decision));
      if (D.predicates !== null) {
        D.prediction = ATN.INVALID_ALT_NUMBER;
      }
    }
    // all adds to dfa are done after we've created full D state
    D = this.addDFAEdge(dfa, previousD, t, D);
    return D;
  }
  predicateDFAState(dfaState, decisionState) {
    // We need to test all predicates, even in DFA states that
    // uniquely predict alternative.
    const nalts = decisionState.transitions.length;
    // Update DFA so reach becomes accept state with (predicate,alt)
    // pairs if preds found for conflicting alts
    const altsToCollectPredsFrom = this.getConflictingAltsOrUniqueAlt(dfaState.configs);
    const altToPred = this.getPredsForAmbigAlts(altsToCollectPredsFrom, dfaState.configs, nalts);
    if (altToPred !== null) {
      dfaState.predicates = this.getPredicatePredictions(altsToCollectPredsFrom, altToPred);
      dfaState.prediction = ATN.INVALID_ALT_NUMBER; // make sure we use preds
    } else {
      // There are preds in configs but they might go away
      // when OR'd together like {p}? || NONE == NONE. If neither
      // alt has preds, resolve to min alt
      dfaState.prediction = altsToCollectPredsFrom.minValue();
    }
  }

  // comes back with reach.uniqueAlt set to a valid alt
  execATNWithFullContext(dfa, D,
  // how far we got before failing over
  s0, input, startIndex, outerContext) {
    if (this.debug || this.debug_list_atn_decisions) {
      console.log("execATNWithFullContext " + s0);
    }
    const fullCtx = true;
    let foundExactAmbig = false;
    let reach;
    let previous = s0;
    input.seek(startIndex);
    let t = input.LA(1);
    let predictedAlt = -1;
    while (true) {
      // while more work
      reach = this.computeReachSet(previous, t, fullCtx);
      if (reach === null) {
        // if any configs in previous dipped into outer context, that
        // means that input up to t actually finished entry rule
        // at least for LL decision. Full LL doesn't dip into outer
        // so don't need special case.
        // We will get an error no matter what so delay until after
        // decision; better error message. Also, no reachable target
        // ATN states in SLL implies LL will also get nowhere.
        // If conflict in states that dip out, choose min since we
        // will get error no matter what.
        const e = this.noViableAlt(input, outerContext, previous, startIndex);
        input.seek(startIndex);
        const alt = this.getSynValidOrSemInvalidAltThatFinishedDecisionEntryRule(previous, outerContext);
        if (alt !== ATN.INVALID_ALT_NUMBER) {
          return alt;
        } else {
          throw e;
        }
      }
      const altSubSets = PredictionMode.getConflictingAltSubsets(reach);
      if (this.debug) {
        console.log("LL altSubSets=" + altSubSets + ", predict=" + PredictionMode.getUniqueAlt(altSubSets) + ", resolvesToJustOneViableAlt=" + PredictionMode.resolvesToJustOneViableAlt(altSubSets));
      }
      reach.uniqueAlt = this.getUniqueAlt(reach);
      // unique prediction?
      if (reach.uniqueAlt !== ATN.INVALID_ALT_NUMBER) {
        predictedAlt = reach.uniqueAlt;
        break;
      } else if (this.predictionMode !== PredictionMode.LL_EXACT_AMBIG_DETECTION) {
        predictedAlt = PredictionMode.resolvesToJustOneViableAlt(altSubSets);
        if (predictedAlt !== ATN.INVALID_ALT_NUMBER) {
          break;
        }
      } else {
        // In exact ambiguity mode, we never try to terminate early.
        // Just keeps scarfing until we know what the conflict is
        if (PredictionMode.allSubsetsConflict(altSubSets) && PredictionMode.allSubsetsEqual(altSubSets)) {
          foundExactAmbig = true;
          predictedAlt = PredictionMode.getSingleViableAlt(altSubSets);
          break;
        }
        // else there are multiple non-conflicting subsets or
        // we're not sure what the ambiguity is yet.
        // So, keep going.
      }
      previous = reach;
      if (t !== Token.EOF) {
        input.consume();
        t = input.LA(1);
      }
    }
    // If the configuration set uniquely predicts an alternative,
    // without conflict, then we know that it's a full LL decision
    // not SLL.
    if (reach.uniqueAlt !== ATN.INVALID_ALT_NUMBER) {
      this.reportContextSensitivity(dfa, predictedAlt, reach, startIndex, input.index);
      return predictedAlt;
    }
    // We do not check predicates here because we have checked them
    // on-the-fly when doing full context prediction.

    //
    // In non-exact ambiguity detection mode, we might	actually be able to
    // detect an exact ambiguity, but I'm not going to spend the cycles
    // needed to check. We only emit ambiguity warnings in exact ambiguity
    // mode.
    //
    // For example, we might know that we have conflicting configurations.
    // But, that does not mean that there is no way forward without a
    // conflict. It's possible to have nonconflicting alt subsets as in:

    // altSubSets=[{1, 2}, {1, 2}, {1}, {1, 2}]

    // from
    //
    //    [(17,1,[5 $]), (13,1,[5 10 $]), (21,1,[5 10 $]), (11,1,[$]),
    //     (13,2,[5 10 $]), (21,2,[5 10 $]), (11,2,[$])]
    //
    // In this case, (17,1,[5 $]) indicates there is some next sequence that
    // would resolve this without conflict to alternative 1. Any other viable
    // next sequence, however, is associated with a conflict.  We stop
    // looking for input because no amount of further lookahead will alter
    // the fact that we should predict alternative 1.  We just can't say for
    // sure that there is an ambiguity without looking further.

    this.reportAmbiguity(dfa, D, startIndex, input.index, foundExactAmbig, null, reach);
    return predictedAlt;
  }
  computeReachSet(closure, t, fullCtx) {
    if (this.debug) {
      console.log("in computeReachSet, starting closure: " + closure);
    }
    if (this.mergeCache === null) {
      this.mergeCache = new DoubleDict();
    }
    const intermediate = new ATNConfigSet(fullCtx);

    // Configurations already in a rule stop state indicate reaching the end
    // of the decision rule (local context) or end of the start rule (full
    // context). Once reached, these configurations are never updated by a
    // closure operation, so they are handled separately for the performance
    // advantage of having a smaller intermediate set when calling closure.
    //
    // For full-context reach operations, separate handling is required to
    // ensure that the alternative matching the longest overall sequence is
    // chosen when multiple such configurations can match the input.

    let skippedStopStates = null;

    // First figure out where we can reach on input t
    for (let i = 0; i < closure.items.length; i++) {
      const c = closure.items[i];
      if (this.debug) {
        console.log("testing " + this.getTokenName(t) + " at " + c);
      }
      if (c.state instanceof RuleStopState) {
        if (fullCtx || t === Token.EOF) {
          if (skippedStopStates === null) {
            skippedStopStates = [];
          }
          skippedStopStates.push(c);
          if (this.debug_add) {
            console.log("added " + c + " to skippedStopStates");
          }
        }
        continue;
      }
      for (let j = 0; j < c.state.transitions.length; j++) {
        const trans = c.state.transitions[j];
        const target = this.getReachableTarget(trans, t);
        if (target !== null) {
          const cfg = new ATNConfig({
            state: target
          }, c);
          intermediate.add(cfg, this.mergeCache);
          if (this.debug_add) {
            console.log("added " + cfg + " to intermediate");
          }
        }
      }
    }
    // Now figure out where the reach operation can take us...
    let reach = null;

    // This block optimizes the reach operation for intermediate sets which
    // trivially indicate a termination state for the overall
    // adaptivePredict operation.
    //
    // The conditions assume that intermediate
    // contains all configurations relevant to the reach set, but this
    // condition is not true when one or more configurations have been
    // withheld in skippedStopStates, or when the current symbol is EOF.
    //
    if (skippedStopStates === null && t !== Token.EOF) {
      if (intermediate.items.length === 1) {
        // Don't pursue the closure if there is just one state.
        // It can only have one alternative; just add to result
        // Also don't pursue the closure if there is unique alternative
        // among the configurations.
        reach = intermediate;
      } else if (this.getUniqueAlt(intermediate) !== ATN.INVALID_ALT_NUMBER) {
        // Also don't pursue the closure if there is unique alternative
        // among the configurations.
        reach = intermediate;
      }
    }
    // If the reach set could not be trivially determined, perform a closure
    // operation on the intermediate set to compute its initial value.
    //
    if (reach === null) {
      reach = new ATNConfigSet(fullCtx);
      const closureBusy = new Set();
      const treatEofAsEpsilon = t === Token.EOF;
      for (let k = 0; k < intermediate.items.length; k++) {
        this.closure(intermediate.items[k], reach, closureBusy, false, fullCtx, treatEofAsEpsilon);
      }
    }
    if (t === Token.EOF) {
      // After consuming EOF no additional input is possible, so we are
      // only interested in configurations which reached the end of the
      // decision rule (local context) or end of the start rule (full
      // context). Update reach to contain only these configurations. This
      // handles both explicit EOF transitions in the grammar and implicit
      // EOF transitions following the end of the decision or start rule.
      //
      // When reach==intermediate, no closure operation was performed. In
      // this case, removeAllConfigsNotInRuleStopState needs to check for
      // reachable rule stop states as well as configurations already in
      // a rule stop state.
      //
      // This is handled before the configurations in skippedStopStates,
      // because any configurations potentially added from that list are
      // already guaranteed to meet this condition whether or not it's
      // required.
      //
      reach = this.removeAllConfigsNotInRuleStopState(reach, reach === intermediate);
    }
    // If skippedStopStates!==null, then it contains at least one
    // configuration. For full-context reach operations, these
    // configurations reached the end of the start rule, in which case we
    // only add them back to reach if no configuration during the current
    // closure operation reached such a state. This ensures adaptivePredict
    // chooses an alternative matching the longest overall sequence when
    // multiple alternatives are viable.
    //
    if (skippedStopStates !== null && (!fullCtx || !PredictionMode.hasConfigInRuleStopState(reach))) {
      for (let l = 0; l < skippedStopStates.length; l++) {
        reach.add(skippedStopStates[l], this.mergeCache);
      }
    }
    if (reach.items.length === 0) {
      return null;
    } else {
      return reach;
    }
  }

  /**
   * Return a configuration set containing only the configurations from
   * {@code configs} which are in a {@link RuleStopState}. If all
   * configurations in {@code configs} are already in a rule stop state, this
   * method simply returns {@code configs}.
   *
   * <p>When {@code lookToEndOfRule} is true, this method uses
   * {@link ATN//nextTokens} for each configuration in {@code configs} which is
   * not already in a rule stop state to see if a rule stop state is reachable
   * from the configuration via epsilon-only transitions.</p>
   *
   * @param configs the configuration set to update
   * @param lookToEndOfRule when true, this method checks for rule stop states
   * reachable by epsilon-only transitions from each configuration in
   * {@code configs}.
   *
   * @return {@code configs} if all configurations in {@code configs} are in a
   * rule stop state, otherwise return a new configuration set containing only
   * the configurations from {@code configs} which are in a rule stop state
   */
  removeAllConfigsNotInRuleStopState(configs, lookToEndOfRule) {
    if (PredictionMode.allConfigsInRuleStopStates(configs)) {
      return configs;
    }
    const result = new ATNConfigSet(configs.fullCtx);
    for (let i = 0; i < configs.items.length; i++) {
      const config = configs.items[i];
      if (config.state instanceof RuleStopState) {
        result.add(config, this.mergeCache);
        continue;
      }
      if (lookToEndOfRule && config.state.epsilonOnlyTransitions) {
        const nextTokens = this.atn.nextTokens(config.state);
        if (nextTokens.contains(Token.EPSILON)) {
          const endOfRuleState = this.atn.ruleToStopState[config.state.ruleIndex];
          result.add(new ATNConfig({
            state: endOfRuleState
          }, config), this.mergeCache);
        }
      }
    }
    return result;
  }
  computeStartState(p, ctx, fullCtx) {
    // always at least the implicit call to start rule
    const initialContext = predictionContextFromRuleContext(this.atn, ctx);
    const configs = new ATNConfigSet(fullCtx);
    for (let i = 0; i < p.transitions.length; i++) {
      const target = p.transitions[i].target;
      const c = new ATNConfig({
        state: target,
        alt: i + 1,
        context: initialContext
      }, null);
      const closureBusy = new Set();
      this.closure(c, configs, closureBusy, true, fullCtx, false);
    }
    return configs;
  }

  /**
   * This method transforms the start state computed by
   * {@link //computeStartState} to the special start state used by a
   * precedence DFA for a particular precedence value. The transformation
   * process applies the following changes to the start state's configuration
   * set.
   *
   * <ol>
   * <li>Evaluate the precedence predicates for each configuration using
   * {@link SemanticContext//evalPrecedence}.</li>
   * <li>Remove all configurations which predict an alternative greater than
   * 1, for which another configuration that predicts alternative 1 is in the
   * same ATN state with the same prediction context. This transformation is
   * valid for the following reasons:
   * <ul>
   * <li>The closure block cannot contain any epsilon transitions which bypass
   * the body of the closure, so all states reachable via alternative 1 are
   * part of the precedence alternatives of the transformed left-recursive
   * rule.</li>
   * <li>The "primary" portion of a left recursive rule cannot contain an
   * epsilon transition, so the only way an alternative other than 1 can exist
   * in a state that is also reachable via alternative 1 is by nesting calls
   * to the left-recursive rule, with the outer calls not being at the
   * preferred precedence level.</li>
   * </ul>
   * </li>
   * </ol>
   *
   * <p>
   * The prediction context must be considered by this filter to address
   * situations like the following.
   * </p>
   * <code>
   * <pre>
   * grammar TA;
   * prog: statement* EOF;
   * statement: letterA | statement letterA 'b' ;
   * letterA: 'a';
   * </pre>
   * </code>
   * <p>
   * If the above grammar, the ATN state immediately before the token
   * reference {@code 'a'} in {@code letterA} is reachable from the left edge
   * of both the primary and closure blocks of the left-recursive rule
   * {@code statement}. The prediction context associated with each of these
   * configurations distinguishes between them, and prevents the alternative
   * which stepped out to {@code prog} (and then back in to {@code statement}
   * from being eliminated by the filter.
   * </p>
   *
   * @param configs The configuration set computed by
   * {@link //computeStartState} as the start state for the DFA.
   * @return The transformed configuration set representing the start state
   * for a precedence DFA at a particular precedence level (determined by
   * calling {@link Parser//getPrecedence})
   */
  applyPrecedenceFilter(configs) {
    let config;
    const statesFromAlt1 = [];
    const configSet = new ATNConfigSet(configs.fullCtx);
    for (let i = 0; i < configs.items.length; i++) {
      config = configs.items[i];
      // handle alt 1 first
      if (config.alt !== 1) {
        continue;
      }
      const updatedContext = config.semanticContext.evalPrecedence(this.parser, this._outerContext);
      if (updatedContext === null) {
        // the configuration was eliminated
        continue;
      }
      statesFromAlt1[config.state.stateNumber] = config.context;
      if (updatedContext !== config.semanticContext) {
        configSet.add(new ATNConfig({
          semanticContext: updatedContext
        }, config), this.mergeCache);
      } else {
        configSet.add(config, this.mergeCache);
      }
    }
    for (let i = 0; i < configs.items.length; i++) {
      config = configs.items[i];
      if (config.alt === 1) {
        // already handled
        continue;
      }
      // In the future, this elimination step could be updated to also
      // filter the prediction context for alternatives predicting alt>1
      // (basically a graph subtraction algorithm).
      if (!config.precedenceFilterSuppressed) {
        const context = statesFromAlt1[config.state.stateNumber] || null;
        if (context !== null && context.equals(config.context)) {
          // eliminated
          continue;
        }
      }
      configSet.add(config, this.mergeCache);
    }
    return configSet;
  }
  getReachableTarget(trans, ttype) {
    if (trans.matches(ttype, 0, this.atn.maxTokenType)) {
      return trans.target;
    } else {
      return null;
    }
  }
  getPredsForAmbigAlts(ambigAlts, configs, nalts) {
    // REACH=[1|1|[]|0:0, 1|2|[]|0:1]
    // altToPred starts as an array of all null contexts. The entry at index i
    // corresponds to alternative i. altToPred[i] may have one of three values:
    //   1. null: no ATNConfig c is found such that c.alt==i
    //   2. SemanticContext.NONE: At least one ATNConfig c exists such that
    //      c.alt==i and c.semanticContext==SemanticContext.NONE. In other words,
    //      alt i has at least one unpredicated config.
    //   3. Non-NONE Semantic Context: There exists at least one, and for all
    //      ATNConfig c such that c.alt==i, c.semanticContext!=SemanticContext.NONE.
    //
    // From this, it is clear that NONE||anything==NONE.
    //
    let altToPred = [];
    for (let i = 0; i < configs.items.length; i++) {
      const c = configs.items[i];
      if (ambigAlts.contains(c.alt)) {
        altToPred[c.alt] = SemanticContext.orContext(altToPred[c.alt] || null, c.semanticContext);
      }
    }
    let nPredAlts = 0;
    for (let i = 1; i < nalts + 1; i++) {
      const pred = altToPred[i] || null;
      if (pred === null) {
        altToPred[i] = SemanticContext.NONE;
      } else if (pred !== SemanticContext.NONE) {
        nPredAlts += 1;
      }
    }
    // nonambig alts are null in altToPred
    if (nPredAlts === 0) {
      altToPred = null;
    }
    if (this.debug) {
      console.log("getPredsForAmbigAlts result " + Utils.arrayToString(altToPred));
    }
    return altToPred;
  }
  getPredicatePredictions(ambigAlts, altToPred) {
    const pairs = [];
    let containsPredicate = false;
    for (let i = 1; i < altToPred.length; i++) {
      const pred = altToPred[i];
      // unpredicated is indicated by SemanticContext.NONE
      if (ambigAlts !== null && ambigAlts.contains(i)) {
        pairs.push(new PredPrediction(pred, i));
      }
      if (pred !== SemanticContext.NONE) {
        containsPredicate = true;
      }
    }
    if (!containsPredicate) {
      return null;
    }
    return pairs;
  }

  /**
   * This method is used to improve the localization of error messages by
   * choosing an alternative rather than throwing a
   * {@link NoViableAltException} in particular prediction scenarios where the
   * {@link //ERROR} state was reached during ATN simulation.
   *
   * <p>
   * The default implementation of this method uses the following
   * algorithm to identify an ATN configuration which successfully parsed the
   * decision entry rule. Choosing such an alternative ensures that the
   * {@link ParserRuleContext} returned by the calling rule will be complete
   * and valid, and the syntax error will be reported later at a more
   * localized location.</p>
   *
   * <ul>
   * <li>If a syntactically valid path or paths reach the end of the decision rule and
   * they are semantically valid if predicated, return the min associated alt.</li>
   * <li>Else, if a semantically invalid but syntactically valid path exist
   * or paths exist, return the minimum associated alt.
   * </li>
   * <li>Otherwise, return {@link ATN//INVALID_ALT_NUMBER}.</li>
   * </ul>
   *
   * <p>
   * In some scenarios, the algorithm described above could predict an
   * alternative which will result in a {@link FailedPredicateException} in
   * the parser. Specifically, this could occur if the <em>only</em> configuration
   * capable of successfully parsing to the end of the decision rule is
   * blocked by a semantic predicate. By choosing this alternative within
   * {@link //adaptivePredict} instead of throwing a
   * {@link NoViableAltException}, the resulting
   * {@link FailedPredicateException} in the parser will identify the specific
   * predicate which is preventing the parser from successfully parsing the
   * decision rule, which helps developers identify and correct logic errors
   * in semantic predicates.
   * </p>
   *
   * @param configs The ATN configurations which were valid immediately before
   * the {@link //ERROR} state was reached
   * @param outerContext The is the \gamma_0 initial parser context from the paper
   * or the parser stack at the instant before prediction commences.
   *
   * @return The value to return from {@link //adaptivePredict}, or
   * {@link ATN//INVALID_ALT_NUMBER} if a suitable alternative was not
   * identified and {@link //adaptivePredict} should report an error instead
   */
  getSynValidOrSemInvalidAltThatFinishedDecisionEntryRule(configs, outerContext) {
    const cfgs = this.splitAccordingToSemanticValidity(configs, outerContext);
    const semValidConfigs = cfgs[0];
    const semInvalidConfigs = cfgs[1];
    let alt = this.getAltThatFinishedDecisionEntryRule(semValidConfigs);
    if (alt !== ATN.INVALID_ALT_NUMBER) {
      // semantically/syntactically viable path exists
      return alt;
    }
    // Is there a syntactically valid path with a failed pred?
    if (semInvalidConfigs.items.length > 0) {
      alt = this.getAltThatFinishedDecisionEntryRule(semInvalidConfigs);
      if (alt !== ATN.INVALID_ALT_NUMBER) {
        // syntactically viable path exists
        return alt;
      }
    }
    return ATN.INVALID_ALT_NUMBER;
  }
  getAltThatFinishedDecisionEntryRule(configs) {
    const alts = [];
    for (let i = 0; i < configs.items.length; i++) {
      const c = configs.items[i];
      if (c.reachesIntoOuterContext > 0 || c.state instanceof RuleStopState && c.context.hasEmptyPath()) {
        if (alts.indexOf(c.alt) < 0) {
          alts.push(c.alt);
        }
      }
    }
    if (alts.length === 0) {
      return ATN.INVALID_ALT_NUMBER;
    } else {
      return Math.min.apply(null, alts);
    }
  }

  /**
   * Walk the list of configurations and split them according to
   * those that have preds evaluating to true/false.  If no pred, assume
   * true pred and include in succeeded set.  Returns Pair of sets.
   *
   * Create a new set so as not to alter the incoming parameter.
   *
   * Assumption: the input stream has been restored to the starting point
   * prediction, which is where predicates need to evaluate.*/
  splitAccordingToSemanticValidity(configs, outerContext) {
    const succeeded = new ATNConfigSet(configs.fullCtx);
    const failed = new ATNConfigSet(configs.fullCtx);
    for (let i = 0; i < configs.items.length; i++) {
      const c = configs.items[i];
      if (c.semanticContext !== SemanticContext.NONE) {
        const predicateEvaluationResult = c.semanticContext.evaluate(this.parser, outerContext);
        if (predicateEvaluationResult) {
          succeeded.add(c);
        } else {
          failed.add(c);
        }
      } else {
        succeeded.add(c);
      }
    }
    return [succeeded, failed];
  }

  /**
   * Look through a list of predicate/alt pairs, returning alts for the
   * pairs that win. A {@code NONE} predicate indicates an alt containing an
   * unpredicated config which behaves as "always true." If !complete
   * then we stop at the first predicate that evaluates to true. This
   * includes pairs with null predicates.
   */
  evalSemanticContext(predPredictions, outerContext, complete) {
    const predictions = new BitSet();
    for (let i = 0; i < predPredictions.length; i++) {
      const pair = predPredictions[i];
      if (pair.pred === SemanticContext.NONE) {
        predictions.add(pair.alt);
        if (!complete) {
          break;
        }
        continue;
      }
      const predicateEvaluationResult = pair.pred.evaluate(this.parser, outerContext);
      if (this.debug || this.dfa_debug) {
        console.log("eval pred " + pair + "=" + predicateEvaluationResult);
      }
      if (predicateEvaluationResult) {
        if (this.debug || this.dfa_debug) {
          console.log("PREDICT " + pair.alt);
        }
        predictions.add(pair.alt);
        if (!complete) {
          break;
        }
      }
    }
    return predictions;
  }

  // TODO: If we are doing predicates, there is no point in pursuing
  //     closure operations if we reach a DFA state that uniquely predicts
  //     alternative. We will not be caching that DFA state and it is a
  //     waste to pursue the closure. Might have to advance when we do
  //     ambig detection thought :(
  //
  closure(config, configs, closureBusy, collectPredicates, fullCtx, treatEofAsEpsilon) {
    const initialDepth = 0;
    this.closureCheckingStopState(config, configs, closureBusy, collectPredicates, fullCtx, initialDepth, treatEofAsEpsilon);
  }
  closureCheckingStopState(config, configs, closureBusy, collectPredicates, fullCtx, depth, treatEofAsEpsilon) {
    if (this.debug || this.debug_closure) {
      console.log("closure(" + config.toString(this.parser, true) + ")");
      // console.log("configs(" + configs.toString() + ")");
      if (config.reachesIntoOuterContext > 50) {
        throw "problem";
      }
    }
    if (config.state instanceof RuleStopState) {
      // We hit rule end. If we have context info, use it
      // run thru all possible stack tops in ctx
      if (!config.context.isEmpty()) {
        for (let i = 0; i < config.context.length; i++) {
          if (config.context.getReturnState(i) === PredictionContext.EMPTY_RETURN_STATE) {
            if (fullCtx) {
              configs.add(new ATNConfig({
                state: config.state,
                context: PredictionContext.EMPTY
              }, config), this.mergeCache);
              continue;
            } else {
              // we have no context info, just chase follow links (if greedy)
              if (this.debug) {
                console.log("FALLING off rule " + this.getRuleName(config.state.ruleIndex));
              }
              this.closure_(config, configs, closureBusy, collectPredicates, fullCtx, depth, treatEofAsEpsilon);
            }
            continue;
          }
          const returnState = this.atn.states[config.context.getReturnState(i)];
          const newContext = config.context.getParent(i); // "pop" return state
          const parms = {
            state: returnState,
            alt: config.alt,
            context: newContext,
            semanticContext: config.semanticContext
          };
          const c = new ATNConfig(parms, null);
          // While we have context to pop back from, we may have
          // gotten that context AFTER having falling off a rule.
          // Make sure we track that we are now out of context.
          c.reachesIntoOuterContext = config.reachesIntoOuterContext;
          this.closureCheckingStopState(c, configs, closureBusy, collectPredicates, fullCtx, depth - 1, treatEofAsEpsilon);
        }
        return;
      } else if (fullCtx) {
        // reached end of start rule
        configs.add(config, this.mergeCache);
        return;
      } else {
        // else if we have no context info, just chase follow links (if greedy)
        if (this.debug) {
          console.log("FALLING off rule " + this.getRuleName(config.state.ruleIndex));
        }
      }
    }
    this.closure_(config, configs, closureBusy, collectPredicates, fullCtx, depth, treatEofAsEpsilon);
  }

  // Do the actual work of walking epsilon edges//
  closure_(config, configs, closureBusy, collectPredicates, fullCtx, depth, treatEofAsEpsilon) {
    const p = config.state;
    // optimization
    if (!p.epsilonOnlyTransitions) {
      configs.add(config, this.mergeCache);
      // make sure to not return here, because EOF transitions can act as
      // both epsilon transitions and non-epsilon transitions.
    }
    for (let i = 0; i < p.transitions.length; i++) {
      if (i === 0 && this.canDropLoopEntryEdgeInLeftRecursiveRule(config)) continue;
      const t = p.transitions[i];
      const continueCollecting = collectPredicates && !(t instanceof ActionTransition);
      const c = this.getEpsilonTarget(config, t, continueCollecting, depth === 0, fullCtx, treatEofAsEpsilon);
      if (c !== null) {
        let newDepth = depth;
        if (config.state instanceof RuleStopState) {
          // target fell off end of rule; mark resulting c as having dipped into outer context
          // We can't get here if incoming config was rule stop and we had context
          // track how far we dip into outer context.  Might
          // come in handy and we avoid evaluating context dependent
          // preds if this is > 0.
          if (this._dfa !== null && this._dfa.precedenceDfa) {
            if (t.outermostPrecedenceReturn === this._dfa.atnStartState.ruleIndex) {
              c.precedenceFilterSuppressed = true;
            }
          }
          c.reachesIntoOuterContext += 1;
          if (closureBusy.add(c) !== c) {
            // avoid infinite recursion for right-recursive rules
            continue;
          }
          configs.dipsIntoOuterContext = true; // TODO: can remove? only care when we add to set per middle of this method
          newDepth -= 1;
          if (this.debug) {
            console.log("dips into outer ctx: " + c);
          }
        } else {
          if (!t.isEpsilon && closureBusy.add(c) !== c) {
            // avoid infinite recursion for EOF* and EOF+
            continue;
          }
          if (t instanceof RuleTransition) {
            // latch when newDepth goes negative - once we step out of the entry context we can't return
            if (newDepth >= 0) {
              newDepth += 1;
            }
          }
        }
        this.closureCheckingStopState(c, configs, closureBusy, continueCollecting, fullCtx, newDepth, treatEofAsEpsilon);
      }
    }
  }
  canDropLoopEntryEdgeInLeftRecursiveRule(config) {
    // return False
    const p = config.state;
    // First check to see if we are in StarLoopEntryState generated during
    // left-recursion elimination. For efficiency, also check if
    // the context has an empty stack case. If so, it would mean
    // global FOLLOW so we can't perform optimization
    // Are we the special loop entry/exit state? or SLL wildcard
    if (p.stateType !== ATNState.STAR_LOOP_ENTRY) return false;
    if (p.stateType !== ATNState.STAR_LOOP_ENTRY || !p.isPrecedenceDecision || config.context.isEmpty() || config.context.hasEmptyPath()) return false;

    // Require all return states to return back to the same rule that p is in.
    const numCtxs = config.context.length;
    for (let i = 0; i < numCtxs; i++) {
      // for each stack context
      const returnState = this.atn.states[config.context.getReturnState(i)];
      if (returnState.ruleIndex !== p.ruleIndex) return false;
    }
    const decisionStartState = p.transitions[0].target;
    const blockEndStateNum = decisionStartState.endState.stateNumber;
    const blockEndState = this.atn.states[blockEndStateNum];

    // Verify that the top of each stack context leads to loop entry/exit
    // state through epsilon edges and w/o leaving rule.
    for (let i = 0; i < numCtxs; i++) {
      // for each stack context
      const returnStateNumber = config.context.getReturnState(i);
      const returnState = this.atn.states[returnStateNumber];
      // all states must have single outgoing epsilon edge
      if (returnState.transitions.length !== 1 || !returnState.transitions[0].isEpsilon) return false;

      // Look for prefix op case like 'not expr', (' type ')' expr
      const returnStateTarget = returnState.transitions[0].target;
      if (returnState.stateType === ATNState.BLOCK_END && returnStateTarget === p) continue;

      // Look for 'expr op expr' or case where expr's return state is block end
      // of (...)* internal block; the block end points to loop back
      // which points to p but we don't need to check that
      if (returnState === blockEndState) continue;

      // Look for ternary expr ? expr : expr. The return state points at block end,
      // which points at loop entry state
      if (returnStateTarget === blockEndState) continue;

      // Look for complex prefix 'between expr and expr' case where 2nd expr's
      // return state points at block end state of (...)* internal block
      if (returnStateTarget.stateType === ATNState.BLOCK_END && returnStateTarget.transitions.length === 1 && returnStateTarget.transitions[0].isEpsilon && returnStateTarget.transitions[0].target === p) continue;

      // anything else ain't conforming
      return false;
    }
    return true;
  }
  getRuleName(index) {
    if (this.parser !== null && index >= 0) {
      return this.parser.ruleNames[index];
    } else {
      return "<rule " + index + ">";
    }
  }
  getEpsilonTarget(config, t, collectPredicates, inContext, fullCtx, treatEofAsEpsilon) {
    switch (t.serializationType) {
      case Transition.RULE:
        return this.ruleTransition(config, t);
      case Transition.PRECEDENCE:
        return this.precedenceTransition(config, t, collectPredicates, inContext, fullCtx);
      case Transition.PREDICATE:
        return this.predTransition(config, t, collectPredicates, inContext, fullCtx);
      case Transition.ACTION:
        return this.actionTransition(config, t);
      case Transition.EPSILON:
        return new ATNConfig({
          state: t.target
        }, config);
      case Transition.ATOM:
      case Transition.RANGE:
      case Transition.SET:
        // EOF transitions act like epsilon transitions after the first EOF
        // transition is traversed
        if (treatEofAsEpsilon) {
          if (t.matches(Token.EOF, 0, 1)) {
            return new ATNConfig({
              state: t.target
            }, config);
          }
        }
        return null;
      default:
        return null;
    }
  }
  actionTransition(config, t) {
    if (this.debug) {
      const index = t.actionIndex === -1 ? 65535 : t.actionIndex;
      console.log("ACTION edge " + t.ruleIndex + ":" + index);
    }
    return new ATNConfig({
      state: t.target
    }, config);
  }
  precedenceTransition(config, pt, collectPredicates, inContext, fullCtx) {
    if (this.debug) {
      console.log("PRED (collectPredicates=" + collectPredicates + ") " + pt.precedence + ">=_p, ctx dependent=true");
      if (this.parser !== null) {
        console.log("context surrounding pred is " + Utils.arrayToString(this.parser.getRuleInvocationStack()));
      }
    }
    let c = null;
    if (collectPredicates && inContext) {
      if (fullCtx) {
        // In full context mode, we can evaluate predicates on-the-fly
        // during closure, which dramatically reduces the size of
        // the config sets. It also obviates the need to test predicates
        // later during conflict resolution.
        const currentPosition = this._input.index;
        this._input.seek(this._startIndex);
        const predSucceeds = pt.getPredicate().evaluate(this.parser, this._outerContext);
        this._input.seek(currentPosition);
        if (predSucceeds) {
          c = new ATNConfig({
            state: pt.target
          }, config); // no pred context
        }
      } else {
        const newSemCtx = SemanticContext.andContext(config.semanticContext, pt.getPredicate());
        c = new ATNConfig({
          state: pt.target,
          semanticContext: newSemCtx
        }, config);
      }
    } else {
      c = new ATNConfig({
        state: pt.target
      }, config);
    }
    if (this.debug) {
      console.log("config from pred transition=" + c);
    }
    return c;
  }
  predTransition(config, pt, collectPredicates, inContext, fullCtx) {
    if (this.debug) {
      console.log("PRED (collectPredicates=" + collectPredicates + ") " + pt.ruleIndex + ":" + pt.predIndex + ", ctx dependent=" + pt.isCtxDependent);
      if (this.parser !== null) {
        console.log("context surrounding pred is " + Utils.arrayToString(this.parser.getRuleInvocationStack()));
      }
    }
    let c = null;
    if (collectPredicates && (pt.isCtxDependent && inContext || !pt.isCtxDependent)) {
      if (fullCtx) {
        // In full context mode, we can evaluate predicates on-the-fly
        // during closure, which dramatically reduces the size of
        // the config sets. It also obviates the need to test predicates
        // later during conflict resolution.
        const currentPosition = this._input.index;
        this._input.seek(this._startIndex);
        const predSucceeds = pt.getPredicate().evaluate(this.parser, this._outerContext);
        this._input.seek(currentPosition);
        if (predSucceeds) {
          c = new ATNConfig({
            state: pt.target
          }, config); // no pred context
        }
      } else {
        const newSemCtx = SemanticContext.andContext(config.semanticContext, pt.getPredicate());
        c = new ATNConfig({
          state: pt.target,
          semanticContext: newSemCtx
        }, config);
      }
    } else {
      c = new ATNConfig({
        state: pt.target
      }, config);
    }
    if (this.debug) {
      console.log("config from pred transition=" + c);
    }
    return c;
  }
  ruleTransition(config, t) {
    if (this.debug) {
      console.log("CALL rule " + this.getRuleName(t.target.ruleIndex) + ", ctx=" + config.context);
    }
    const returnState = t.followState;
    const newContext = SingletonPredictionContext.create(config.context, returnState.stateNumber);
    return new ATNConfig({
      state: t.target,
      context: newContext
    }, config);
  }
  getConflictingAlts(configs) {
    const altsets = PredictionMode.getConflictingAltSubsets(configs);
    return PredictionMode.getAlts(altsets);
  }

  /**
   * Sam pointed out a problem with the previous definition, v3, of
   * ambiguous states. If we have another state associated with conflicting
   * alternatives, we should keep going. For example, the following grammar
   *
   * s : (ID | ID ID?) ';' ;
   *
   * When the ATN simulation reaches the state before ';', it has a DFA
   * state that looks like: [12|1|[], 6|2|[], 12|2|[]]. Naturally
   * 12|1|[] and 12|2|[] conflict, but we cannot stop processing this node
   * because alternative to has another way to continue, via [6|2|[]].
   * The key is that we have a single state that has config's only associated
   * with a single alternative, 2, and crucially the state transitions
   * among the configurations are all non-epsilon transitions. That means
   * we don't consider any conflicts that include alternative 2. So, we
   * ignore the conflict between alts 1 and 2. We ignore a set of
   * conflicting alts when there is an intersection with an alternative
   * associated with a single alt state in the state&rarr;config-list map.
   *
   * It's also the case that we might have two conflicting configurations but
   * also a 3rd nonconflicting configuration for a different alternative:
   * [1|1|[], 1|2|[], 8|3|[]]. This can come about from grammar:
   *
   * a : A | A | A B ;
   *
   * After matching input A, we reach the stop state for rule A, state 1.
   * State 8 is the state right before B. Clearly alternatives 1 and 2
   * conflict and no amount of further lookahead will separate the two.
   * However, alternative 3 will be able to continue and so we do not
   * stop working on this state. In the previous example, we're concerned
   * with states associated with the conflicting alternatives. Here alt
   * 3 is not associated with the conflicting configs, but since we can continue
   * looking for input reasonably, I don't declare the state done. We
   * ignore a set of conflicting alts when we have an alternative
   * that we still need to pursue
   */
  getConflictingAltsOrUniqueAlt(configs) {
    let conflictingAlts = null;
    if (configs.uniqueAlt !== ATN.INVALID_ALT_NUMBER) {
      conflictingAlts = new BitSet();
      conflictingAlts.add(configs.uniqueAlt);
    } else {
      conflictingAlts = configs.conflictingAlts;
    }
    return conflictingAlts;
  }
  getTokenName(t) {
    if (t === Token.EOF) {
      return "EOF";
    }
    if (this.parser !== null && this.parser.literalNames !== null) {
      if (t >= this.parser.literalNames.length && t >= this.parser.symbolicNames.length) {
        console.log("" + t + " ttype out of range: " + this.parser.literalNames);
        console.log("" + this.parser.getInputStream().getTokens());
      } else {
        const name = this.parser.literalNames[t] || this.parser.symbolicNames[t];
        return name + "<" + t + ">";
      }
    }
    return "" + t;
  }
  getLookaheadName(input) {
    return this.getTokenName(input.LA(1));
  }

  /**
   * Used for debugging in adaptivePredict around execATN but I cut
   * it out for clarity now that alg. works well. We can leave this
   * "dead" code for a bit
   */
  dumpDeadEndConfigs(nvae) {
    console.log("dead end configs: ");
    const decs = nvae.getDeadEndConfigs();
    for (let i = 0; i < decs.length; i++) {
      const c = decs[i];
      let trans = "no edges";
      if (c.state.transitions.length > 0) {
        const t = c.state.transitions[0];
        if (t instanceof AtomTransition) {
          trans = "Atom " + this.getTokenName(t.label);
        } else if (t instanceof SetTransition) {
          const neg = t instanceof NotSetTransition;
          trans = (neg ? "~" : "") + "Set " + t.set;
        }
      }
      console.error(c.toString(this.parser, true) + ":" + trans);
    }
  }
  noViableAlt(input, outerContext, configs, startIndex) {
    return new NoViableAltException(this.parser, input, input.get(startIndex), input.LT(1), configs, outerContext);
  }
  getUniqueAlt(configs) {
    let alt = ATN.INVALID_ALT_NUMBER;
    for (let i = 0; i < configs.items.length; i++) {
      const c = configs.items[i];
      if (alt === ATN.INVALID_ALT_NUMBER) {
        alt = c.alt; // found first alt
      } else if (c.alt !== alt) {
        return ATN.INVALID_ALT_NUMBER;
      }
    }
    return alt;
  }

  /**
   * Add an edge to the DFA, if possible. This method calls
   * {@link //addDFAState} to ensure the {@code to} state is present in the
   * DFA. If {@code from} is {@code null}, or if {@code t} is outside the
   * range of edges that can be represented in the DFA tables, this method
   * returns without adding the edge to the DFA.
   *
   * <p>If {@code to} is {@code null}, this method returns {@code null}.
   * Otherwise, this method returns the {@link DFAState} returned by calling
   * {@link //addDFAState} for the {@code to} state.</p>
   *
   * @param dfa The DFA
   * @param from_ The source state for the edge
   * @param t The input symbol
   * @param to The target state for the edge
   *
   * @return If {@code to} is {@code null}, this method returns {@code null};
   * otherwise this method returns the result of calling {@link //addDFAState}
   * on {@code to}
   */
  addDFAEdge(dfa, from_, t, to) {
    if (this.debug) {
      console.log("EDGE " + from_ + " -> " + to + " upon " + this.getTokenName(t));
    }
    if (to === null) {
      return null;
    }
    to = this.addDFAState(dfa, to); // used existing if possible not incoming
    if (from_ === null || t < -1 || t > this.atn.maxTokenType) {
      return to;
    }
    if (from_.edges === null) {
      from_.edges = [];
    }
    from_.edges[t + 1] = to; // connect

    if (this.debug) {
      const literalNames = this.parser === null ? null : this.parser.literalNames;
      const symbolicNames = this.parser === null ? null : this.parser.symbolicNames;
      console.log("DFA=\n" + dfa.toString(literalNames, symbolicNames));
    }
    return to;
  }

  /**
   * Add state {@code D} to the DFA if it is not already present, and return
   * the actual instance stored in the DFA. If a state equivalent to {@code D}
   * is already in the DFA, the existing state is returned. Otherwise this
   * method returns {@code D} after adding it to the DFA.
   *
   * <p>If {@code D} is {@link //ERROR}, this method returns {@link //ERROR} and
   * does not change the DFA.</p>
   *
   * @param dfa The dfa
   * @param D The DFA state to add
   * @return The state stored in the DFA. This will be either the existing
   * state if {@code D} is already in the DFA, or {@code D} itself if the
   * state was not already present
   */
  addDFAState(dfa, D) {
    if (D === ATNSimulator.ERROR) {
      return D;
    }
    const existing = dfa.states.get(D);
    if (existing !== null) {
      return existing;
    }
    D.stateNumber = dfa.states.length;
    if (!D.configs.readOnly) {
      D.configs.optimizeConfigs(this);
      D.configs.setReadonly(true);
    }
    dfa.states.add(D);
    if (this.debug) {
      console.log("adding new DFA state: " + D);
    }
    return D;
  }
  reportAttemptingFullContext(dfa, conflictingAlts, configs, startIndex, stopIndex) {
    if (this.debug || this.retry_debug) {
      const interval = new Interval(startIndex, stopIndex + 1);
      console.log("reportAttemptingFullContext decision=" + dfa.decision + ":" + configs + ", input=" + this.parser.getTokenStream().getText(interval));
    }
    if (this.parser !== null) {
      this.parser.getErrorListenerDispatch().reportAttemptingFullContext(this.parser, dfa, startIndex, stopIndex, conflictingAlts, configs);
    }
  }
  reportContextSensitivity(dfa, prediction, configs, startIndex, stopIndex) {
    if (this.debug || this.retry_debug) {
      const interval = new Interval(startIndex, stopIndex + 1);
      console.log("reportContextSensitivity decision=" + dfa.decision + ":" + configs + ", input=" + this.parser.getTokenStream().getText(interval));
    }
    if (this.parser !== null) {
      this.parser.getErrorListenerDispatch().reportContextSensitivity(this.parser, dfa, startIndex, stopIndex, prediction, configs);
    }
  }

  // If context sensitive parsing, we know it's ambiguity not conflict//
  reportAmbiguity(dfa, D, startIndex, stopIndex, exact, ambigAlts, configs) {
    if (this.debug || this.retry_debug) {
      const interval = new Interval(startIndex, stopIndex + 1);
      console.log("reportAmbiguity " + ambigAlts + ":" + configs + ", input=" + this.parser.getTokenStream().getText(interval));
    }
    if (this.parser !== null) {
      this.parser.getErrorListenerDispatch().reportAmbiguity(this.parser, dfa, startIndex, stopIndex, exact, ambigAlts, configs);
    }
  }
}
module.exports = ParserATNSimulator;

/***/ }),
/* 35 */
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

/* Copyright (c) 2012-2017 The ANTLR Project. All rights reserved.
 * Use of this file is governed by the BSD 3-clause license that
 * can be found in the LICENSE.txt file in the project root.
 */

const {
  Map,
  BitSet,
  AltDict,
  hashStuff
} = __webpack_require__(9);
const ATN = __webpack_require__(7);
const {
  RuleStopState
} = __webpack_require__(12);
const {
  ATNConfigSet
} = __webpack_require__(32);
const {
  ATNConfig
} = __webpack_require__(11);
const {
  SemanticContext
} = __webpack_require__(13);

/**
 * This enumeration defines the prediction modes available in ANTLR 4 along with
 * utility methods for analyzing configuration sets for conflicts and/or
 * ambiguities.
 */
const PredictionMode = {
  /**
   * The SLL(*) prediction mode. This prediction mode ignores the current
   * parser context when making predictions. This is the fastest prediction
   * mode, and provides correct results for many grammars. This prediction
   * mode is more powerful than the prediction mode provided by ANTLR 3, but
   * may result in syntax errors for grammar and input combinations which are
   * not SLL.
   *
   * <p>
   * When using this prediction mode, the parser will either return a correct
   * parse tree (i.e. the same parse tree that would be returned with the
   * {@link //LL} prediction mode), or it will report a syntax error. If a
   * syntax error is encountered when using the {@link //SLL} prediction mode,
   * it may be due to either an actual syntax error in the input or indicate
   * that the particular combination of grammar and input requires the more
   * powerful {@link //LL} prediction abilities to complete successfully.</p>
   *
   * <p>
   * This prediction mode does not provide any guarantees for prediction
   * behavior for syntactically-incorrect inputs.</p>
   */
  SLL: 0,
  /**
   * The LL(*) prediction mode. This prediction mode allows the current parser
   * context to be used for resolving SLL conflicts that occur during
   * prediction. This is the fastest prediction mode that guarantees correct
   * parse results for all combinations of grammars with syntactically correct
   * inputs.
   *
   * <p>
   * When using this prediction mode, the parser will make correct decisions
   * for all syntactically-correct grammar and input combinations. However, in
   * cases where the grammar is truly ambiguous this prediction mode might not
   * report a precise answer for <em>exactly which</em> alternatives are
   * ambiguous.</p>
   *
   * <p>
   * This prediction mode does not provide any guarantees for prediction
   * behavior for syntactically-incorrect inputs.</p>
   */
  LL: 1,
  /**
   *
   * The LL(*) prediction mode with exact ambiguity detection. In addition to
   * the correctness guarantees provided by the {@link //LL} prediction mode,
   * this prediction mode instructs the prediction algorithm to determine the
   * complete and exact set of ambiguous alternatives for every ambiguous
   * decision encountered while parsing.
   *
   * <p>
   * This prediction mode may be used for diagnosing ambiguities during
   * grammar development. Due to the performance overhead of calculating sets
   * of ambiguous alternatives, this prediction mode should be avoided when
   * the exact results are not necessary.</p>
   *
   * <p>
   * This prediction mode does not provide any guarantees for prediction
   * behavior for syntactically-incorrect inputs.</p>
   */
  LL_EXACT_AMBIG_DETECTION: 2,
  /**
   *
   * Computes the SLL prediction termination condition.
   *
   * <p>
   * This method computes the SLL prediction termination condition for both of
   * the following cases.</p>
   *
   * <ul>
   * <li>The usual SLL+LL fallback upon SLL conflict</li>
   * <li>Pure SLL without LL fallback</li>
   * </ul>
   *
   * <p><strong>COMBINED SLL+LL PARSING</strong></p>
   *
   * <p>When LL-fallback is enabled upon SLL conflict, correct predictions are
   * ensured regardless of how the termination condition is computed by this
   * method. Due to the substantially higher cost of LL prediction, the
   * prediction should only fall back to LL when the additional lookahead
   * cannot lead to a unique SLL prediction.</p>
   *
   * <p>Assuming combined SLL+LL parsing, an SLL configuration set with only
   * conflicting subsets should fall back to full LL, even if the
   * configuration sets don't resolve to the same alternative (e.g.
   * {@code {1,2}} and {@code {3,4}}. If there is at least one non-conflicting
   * configuration, SLL could continue with the hopes that more lookahead will
   * resolve via one of those non-conflicting configurations.</p>
   *
   * <p>Here's the prediction termination rule them: SLL (for SLL+LL parsing)
   * stops when it sees only conflicting configuration subsets. In contrast,
   * full LL keeps going when there is uncertainty.</p>
   *
   * <p><strong>HEURISTIC</strong></p>
   *
   * <p>As a heuristic, we stop prediction when we see any conflicting subset
   * unless we see a state that only has one alternative associated with it.
   * The single-alt-state thing lets prediction continue upon rules like
   * (otherwise, it would admit defeat too soon):</p>
   *
   * <p>{@code [12|1|[], 6|2|[], 12|2|[]]. s : (ID | ID ID?) ';' ;}</p>
   *
   * <p>When the ATN simulation reaches the state before {@code ';'}, it has a
   * DFA state that looks like: {@code [12|1|[], 6|2|[], 12|2|[]]}. Naturally
   * {@code 12|1|[]} and {@code 12|2|[]} conflict, but we cannot stop
   * processing this node because alternative to has another way to continue,
   * via {@code [6|2|[]]}.</p>
   *
   * <p>It also let's us continue for this rule:</p>
   *
   * <p>{@code [1|1|[], 1|2|[], 8|3|[]] a : A | A | A B ;}</p>
   *
   * <p>After matching input A, we reach the stop state for rule A, state 1.
   * State 8 is the state right before B. Clearly alternatives 1 and 2
   * conflict and no amount of further lookahead will separate the two.
   * However, alternative 3 will be able to continue and so we do not stop
   * working on this state. In the previous example, we're concerned with
   * states associated with the conflicting alternatives. Here alt 3 is not
   * associated with the conflicting configs, but since we can continue
   * looking for input reasonably, don't declare the state done.</p>
   *
   * <p><strong>PURE SLL PARSING</strong></p>
   *
   * <p>To handle pure SLL parsing, all we have to do is make sure that we
   * combine stack contexts for configurations that differ only by semantic
   * predicate. From there, we can do the usual SLL termination heuristic.</p>
   *
   * <p><strong>PREDICATES IN SLL+LL PARSING</strong></p>
   *
   * <p>SLL decisions don't evaluate predicates until after they reach DFA stop
   * states because they need to create the DFA cache that works in all
   * semantic situations. In contrast, full LL evaluates predicates collected
   * during start state computation so it can ignore predicates thereafter.
   * This means that SLL termination detection can totally ignore semantic
   * predicates.</p>
   *
   * <p>Implementation-wise, {@link ATNConfigSet} combines stack contexts but not
   * semantic predicate contexts so we might see two configurations like the
   * following.</p>
   *
   * <p>{@code (s, 1, x, {}), (s, 1, x', {p})}</p>
   *
   * <p>Before testing these configurations against others, we have to merge
   * {@code x} and {@code x'} (without modifying the existing configurations).
   * For example, we test {@code (x+x')==x''} when looking for conflicts in
   * the following configurations.</p>
   *
   * <p>{@code (s, 1, x, {}), (s, 1, x', {p}), (s, 2, x'', {})}</p>
   *
   * <p>If the configuration set has predicates (as indicated by
   * {@link ATNConfigSet//hasSemanticContext}), this algorithm makes a copy of
   * the configurations to strip out all of the predicates so that a standard
   * {@link ATNConfigSet} will merge everything ignoring predicates.</p>
   */
  hasSLLConflictTerminatingPrediction: function (mode, configs) {
    // Configs in rule stop states indicate reaching the end of the decision
    // rule (local context) or end of start rule (full context). If all
    // configs meet this condition, then none of the configurations is able
    // to match additional input so we terminate prediction.
    //
    if (PredictionMode.allConfigsInRuleStopStates(configs)) {
      return true;
    }
    // pure SLL mode parsing
    if (mode === PredictionMode.SLL) {
      // Don't bother with combining configs from different semantic
      // contexts if we can fail over to full LL; costs more time
      // since we'll often fail over anyway.
      if (configs.hasSemanticContext) {
        // dup configs, tossing out semantic predicates
        const dup = new ATNConfigSet();
        for (let i = 0; i < configs.items.length; i++) {
          let c = configs.items[i];
          c = new ATNConfig({
            semanticContext: SemanticContext.NONE
          }, c);
          dup.add(c);
        }
        configs = dup;
      }
      // now we have combined contexts for configs with dissimilar preds
    }
    // pure SLL or combined SLL+LL mode parsing
    const altsets = PredictionMode.getConflictingAltSubsets(configs);
    return PredictionMode.hasConflictingAltSet(altsets) && !PredictionMode.hasStateAssociatedWithOneAlt(configs);
  },
  /**
   * Checks if any configuration in {@code configs} is in a
   * {@link RuleStopState}. Configurations meeting this condition have reached
   * the end of the decision rule (local context) or end of start rule (full
   * context).
   *
   * @param configs the configuration set to test
   * @return {@code true} if any configuration in {@code configs} is in a
   * {@link RuleStopState}, otherwise {@code false}
   */
  hasConfigInRuleStopState: function (configs) {
    for (let i = 0; i < configs.items.length; i++) {
      const c = configs.items[i];
      if (c.state instanceof RuleStopState) {
        return true;
      }
    }
    return false;
  },
  /**
   * Checks if all configurations in {@code configs} are in a
   * {@link RuleStopState}. Configurations meeting this condition have reached
   * the end of the decision rule (local context) or end of start rule (full
   * context).
   *
   * @param configs the configuration set to test
   * @return {@code true} if all configurations in {@code configs} are in a
   * {@link RuleStopState}, otherwise {@code false}
   */
  allConfigsInRuleStopStates: function (configs) {
    for (let i = 0; i < configs.items.length; i++) {
      const c = configs.items[i];
      if (!(c.state instanceof RuleStopState)) {
        return false;
      }
    }
    return true;
  },
  /**
   *
   * Full LL prediction termination.
   *
   * <p>Can we stop looking ahead during ATN simulation or is there some
   * uncertainty as to which alternative we will ultimately pick, after
   * consuming more input? Even if there are partial conflicts, we might know
   * that everything is going to resolve to the same minimum alternative. That
   * means we can stop since no more lookahead will change that fact. On the
   * other hand, there might be multiple conflicts that resolve to different
   * minimums. That means we need more look ahead to decide which of those
   * alternatives we should predict.</p>
   *
   * <p>The basic idea is to split the set of configurations {@code C}, into
   * conflicting subsets {@code (s, _, ctx, _)} and singleton subsets with
   * non-conflicting configurations. Two configurations conflict if they have
   * identical {@link ATNConfig//state} and {@link ATNConfig//context} values
   * but different {@link ATNConfig//alt} value, e.g. {@code (s, i, ctx, _)}
   * and {@code (s, j, ctx, _)} for {@code i!=j}.</p>
   *
   * <p>Reduce these configuration subsets to the set of possible alternatives.
   * You can compute the alternative subsets in one pass as follows:</p>
   *
   * <p>{@code A_s,ctx = {i | (s, i, ctx, _)}} for each configuration in
   * {@code C} holding {@code s} and {@code ctx} fixed.</p>
   *
   * <p>Or in pseudo-code, for each configuration {@code c} in {@code C}:</p>
   *
   * <pre>
   * map[c] U= c.{@link ATNConfig//alt alt} // map hash/equals uses s and x, not
   * alt and not pred
   * </pre>
   *
   * <p>The values in {@code map} are the set of {@code A_s,ctx} sets.</p>
   *
   * <p>If {@code |A_s,ctx|=1} then there is no conflict associated with
   * {@code s} and {@code ctx}.</p>
   *
   * <p>Reduce the subsets to singletons by choosing a minimum of each subset. If
   * the union of these alternative subsets is a singleton, then no amount of
   * more lookahead will help us. We will always pick that alternative. If,
   * however, there is more than one alternative, then we are uncertain which
   * alternative to predict and must continue looking for resolution. We may
   * or may not discover an ambiguity in the future, even if there are no
   * conflicting subsets this round.</p>
   *
   * <p>The biggest sin is to terminate early because it means we've made a
   * decision but were uncertain as to the eventual outcome. We haven't used
   * enough lookahead. On the other hand, announcing a conflict too late is no
   * big deal; you will still have the conflict. It's just inefficient. It
   * might even look until the end of file.</p>
   *
   * <p>No special consideration for semantic predicates is required because
   * predicates are evaluated on-the-fly for full LL prediction, ensuring that
   * no configuration contains a semantic context during the termination
   * check.</p>
   *
   * <p><strong>CONFLICTING CONFIGS</strong></p>
   *
   * <p>Two configurations {@code (s, i, x)} and {@code (s, j, x')}, conflict
   * when {@code i!=j} but {@code x=x'}. Because we merge all
   * {@code (s, i, _)} configurations together, that means that there are at
   * most {@code n} configurations associated with state {@code s} for
   * {@code n} possible alternatives in the decision. The merged stacks
   * complicate the comparison of configuration contexts {@code x} and
   * {@code x'}. Sam checks to see if one is a subset of the other by calling
   * merge and checking to see if the merged result is either {@code x} or
   * {@code x'}. If the {@code x} associated with lowest alternative {@code i}
   * is the superset, then {@code i} is the only possible prediction since the
   * others resolve to {@code min(i)} as well. However, if {@code x} is
   * associated with {@code j>i} then at least one stack configuration for
   * {@code j} is not in conflict with alternative {@code i}. The algorithm
   * should keep going, looking for more lookahead due to the uncertainty.</p>
   *
   * <p>For simplicity, I'm doing a equality check between {@code x} and
   * {@code x'} that lets the algorithm continue to consume lookahead longer
   * than necessary. The reason I like the equality is of course the
   * simplicity but also because that is the test you need to detect the
   * alternatives that are actually in conflict.</p>
   *
   * <p><strong>CONTINUE/STOP RULE</strong></p>
   *
   * <p>Continue if union of resolved alternative sets from non-conflicting and
   * conflicting alternative subsets has more than one alternative. We are
   * uncertain about which alternative to predict.</p>
   *
   * <p>The complete set of alternatives, {@code [i for (_,i,_)]}, tells us which
   * alternatives are still in the running for the amount of input we've
   * consumed at this point. The conflicting sets let us to strip away
   * configurations that won't lead to more states because we resolve
   * conflicts to the configuration with a minimum alternate for the
   * conflicting set.</p>
   *
   * <p><strong>CASES</strong></p>
   *
   * <ul>
   *
   * <li>no conflicts and more than 1 alternative in set =&gt; continue</li>
   *
   * <li> {@code (s, 1, x)}, {@code (s, 2, x)}, {@code (s, 3, z)},
   * {@code (s', 1, y)}, {@code (s', 2, y)} yields non-conflicting set
   * {@code {3}} U conflicting sets {@code min({1,2})} U {@code min({1,2})} =
   * {@code {1,3}} =&gt; continue
   * </li>
   *
   * <li>{@code (s, 1, x)}, {@code (s, 2, x)}, {@code (s', 1, y)},
   * {@code (s', 2, y)}, {@code (s'', 1, z)} yields non-conflicting set
   * {@code {1}} U conflicting sets {@code min({1,2})} U {@code min({1,2})} =
   * {@code {1}} =&gt; stop and predict 1</li>
   *
   * <li>{@code (s, 1, x)}, {@code (s, 2, x)}, {@code (s', 1, y)},
   * {@code (s', 2, y)} yields conflicting, reduced sets {@code {1}} U
   * {@code {1}} = {@code {1}} =&gt; stop and predict 1, can announce
   * ambiguity {@code {1,2}}</li>
   *
   * <li>{@code (s, 1, x)}, {@code (s, 2, x)}, {@code (s', 2, y)},
   * {@code (s', 3, y)} yields conflicting, reduced sets {@code {1}} U
   * {@code {2}} = {@code {1,2}} =&gt; continue</li>
   *
   * <li>{@code (s, 1, x)}, {@code (s, 2, x)}, {@code (s', 3, y)},
   * {@code (s', 4, y)} yields conflicting, reduced sets {@code {1}} U
   * {@code {3}} = {@code {1,3}} =&gt; continue</li>
   *
   * </ul>
   *
   * <p><strong>EXACT AMBIGUITY DETECTION</strong></p>
   *
   * <p>If all states report the same conflicting set of alternatives, then we
   * know we have the exact ambiguity set.</p>
   *
   * <p><code>|A_<em>i</em>|&gt;1</code> and
   * <code>A_<em>i</em> = A_<em>j</em></code> for all <em>i</em>, <em>j</em>.</p>
   *
   * <p>In other words, we continue examining lookahead until all {@code A_i}
   * have more than one alternative and all {@code A_i} are the same. If
   * {@code A={{1,2}, {1,3}}}, then regular LL prediction would terminate
   * because the resolved set is {@code {1}}. To determine what the real
   * ambiguity is, we have to know whether the ambiguity is between one and
   * two or one and three so we keep going. We can only stop prediction when
   * we need exact ambiguity detection when the sets look like
   * {@code A={{1,2}}} or {@code {{1,2},{1,2}}}, etc...</p>
   */
  resolvesToJustOneViableAlt: function (altsets) {
    return PredictionMode.getSingleViableAlt(altsets);
  },
  /**
   * Determines if every alternative subset in {@code altsets} contains more
   * than one alternative.
   *
   * @param altsets a collection of alternative subsets
   * @return {@code true} if every {@link BitSet} in {@code altsets} has
   * {@link BitSet//cardinality cardinality} &gt; 1, otherwise {@code false}
   */
  allSubsetsConflict: function (altsets) {
    return !PredictionMode.hasNonConflictingAltSet(altsets);
  },
  /**
   * Determines if any single alternative subset in {@code altsets} contains
   * exactly one alternative.
   *
   * @param altsets a collection of alternative subsets
   * @return {@code true} if {@code altsets} contains a {@link BitSet} with
   * {@link BitSet//cardinality cardinality} 1, otherwise {@code false}
   */
  hasNonConflictingAltSet: function (altsets) {
    for (let i = 0; i < altsets.length; i++) {
      const alts = altsets[i];
      if (alts.length === 1) {
        return true;
      }
    }
    return false;
  },
  /**
   * Determines if any single alternative subset in {@code altsets} contains
   * more than one alternative.
   *
   * @param altsets a collection of alternative subsets
   * @return {@code true} if {@code altsets} contains a {@link BitSet} with
   * {@link BitSet//cardinality cardinality} &gt; 1, otherwise {@code false}
   */
  hasConflictingAltSet: function (altsets) {
    for (let i = 0; i < altsets.length; i++) {
      const alts = altsets[i];
      if (alts.length > 1) {
        return true;
      }
    }
    return false;
  },
  /**
   * Determines if every alternative subset in {@code altsets} is equivalent.
   *
   * @param altsets a collection of alternative subsets
   * @return {@code true} if every member of {@code altsets} is equal to the
   * others, otherwise {@code false}
   */
  allSubsetsEqual: function (altsets) {
    let first = null;
    for (let i = 0; i < altsets.length; i++) {
      const alts = altsets[i];
      if (first === null) {
        first = alts;
      } else if (alts !== first) {
        return false;
      }
    }
    return true;
  },
  /**
   * Returns the unique alternative predicted by all alternative subsets in
   * {@code altsets}. If no such alternative exists, this method returns
   * {@link ATN//INVALID_ALT_NUMBER}.
   *
   * @param altsets a collection of alternative subsets
   */
  getUniqueAlt: function (altsets) {
    const all = PredictionMode.getAlts(altsets);
    if (all.length === 1) {
      return all.minValue();
    } else {
      return ATN.INVALID_ALT_NUMBER;
    }
  },
  /**
   * Gets the complete set of represented alternatives for a collection of
   * alternative subsets. This method returns the union of each {@link BitSet}
   * in {@code altsets}.
   *
   * @param altsets a collection of alternative subsets
   * @return the set of represented alternatives in {@code altsets}
   */
  getAlts: function (altsets) {
    const all = new BitSet();
    altsets.map(function (alts) {
      all.or(alts);
    });
    return all;
  },
  /**
   * This function gets the conflicting alt subsets from a configuration set.
   * For each configuration {@code c} in {@code configs}:
   *
   * <pre>
   * map[c] U= c.{@link ATNConfig//alt alt} // map hash/equals uses s and x, not
   * alt and not pred
   * </pre>
   */
  getConflictingAltSubsets: function (configs) {
    const configToAlts = new Map();
    configToAlts.hashFunction = function (cfg) {
      hashStuff(cfg.state.stateNumber, cfg.context);
    };
    configToAlts.equalsFunction = function (c1, c2) {
      return c1.state.stateNumber === c2.state.stateNumber && c1.context.equals(c2.context);
    };
    configs.items.map(function (cfg) {
      let alts = configToAlts.get(cfg);
      if (alts === null) {
        alts = new BitSet();
        configToAlts.put(cfg, alts);
      }
      alts.add(cfg.alt);
    });
    return configToAlts.getValues();
  },
  /**
   * Get a map from state to alt subset from a configuration set. For each
   * configuration {@code c} in {@code configs}:
   *
   * <pre>
   * map[c.{@link ATNConfig//state state}] U= c.{@link ATNConfig//alt alt}
   * </pre>
   */
  getStateToAltMap: function (configs) {
    const m = new AltDict();
    configs.items.map(function (c) {
      let alts = m.get(c.state);
      if (alts === null) {
        alts = new BitSet();
        m.put(c.state, alts);
      }
      alts.add(c.alt);
    });
    return m;
  },
  hasStateAssociatedWithOneAlt: function (configs) {
    const values = PredictionMode.getStateToAltMap(configs).values();
    for (let i = 0; i < values.length; i++) {
      if (values[i].length === 1) {
        return true;
      }
    }
    return false;
  },
  getSingleViableAlt: function (altsets) {
    let result = null;
    for (let i = 0; i < altsets.length; i++) {
      const alts = altsets[i];
      const minAlt = alts.minValue();
      if (result === null) {
        result = minAlt;
      } else if (result !== minAlt) {
        // more than 1 viable alt
        return ATN.INVALID_ALT_NUMBER;
      }
    }
    return result;
  }
};
module.exports = PredictionMode;

/***/ }),
/* 36 */
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

/* Copyright (c) 2012-2017 The ANTLR Project. All rights reserved.
 * Use of this file is governed by the BSD 3-clause license that
 * can be found in the LICENSE.txt file in the project root.
 */

const RuleContext = __webpack_require__(17);
const Tree = __webpack_require__(18);
const INVALID_INTERVAL = Tree.INVALID_INTERVAL;
const TerminalNode = Tree.TerminalNode;
const TerminalNodeImpl = Tree.TerminalNodeImpl;
const ErrorNodeImpl = Tree.ErrorNodeImpl;
const Interval = (__webpack_require__(14).Interval);

/**
 * A rule invocation record for parsing.
 *
 *  Contains all of the information about the current rule not stored in the
 *  RuleContext. It handles parse tree children list, Any ATN state
 *  tracing, and the default values available for rule indications:
 *  start, stop, rule index, current alt number, current
 *  ATN state.
 *
 *  Subclasses made for each rule and grammar track the parameters,
 *  return values, locals, and labels specific to that rule. These
 *  are the objects that are returned from rules.
 *
 *  Note text is not an actual field of a rule return value; it is computed
 *  from start and stop using the input stream's toString() method.  I
 *  could add a ctor to this so that we can pass in and store the input
 *  stream, but I'm not sure we want to do that.  It would seem to be undefined
 *  to get the .text property anyway if the rule matches tokens from multiple
 *  input streams.
 *
 *  I do not use getters for fields of objects that are used simply to
 *  group values such as this aggregate.  The getters/setters are there to
 *  satisfy the superclass interface.
 */
class ParserRuleContext extends RuleContext {
  constructor(parent, invokingStateNumber) {
    parent = parent || null;
    invokingStateNumber = invokingStateNumber || null;
    super(parent, invokingStateNumber);
    this.ruleIndex = -1;
    /**
     * If we are debugging or building a parse tree for a visitor,
     * we need to track all of the tokens and rule invocations associated
     * with this rule's context. This is empty for parsing w/o tree constr.
     * operation because we don't the need to track the details about
     * how we parse this rule.
     */
    this.children = null;
    this.start = null;
    this.stop = null;
    /**
     * The exception that forced this rule to return. If the rule successfully
     * completed, this is {@code null}.
     */
    this.exception = null;
  }

  // COPY a ctx (I'm deliberately not using copy constructor)
  copyFrom(ctx) {
    // from RuleContext
    this.parentCtx = ctx.parentCtx;
    this.invokingState = ctx.invokingState;
    this.children = null;
    this.start = ctx.start;
    this.stop = ctx.stop;
    // copy any error nodes to alt label node
    if (ctx.children) {
      this.children = [];
      // reset parent pointer for any error nodes
      ctx.children.map(function (child) {
        if (child instanceof ErrorNodeImpl) {
          this.children.push(child);
          child.parentCtx = this;
        }
      }, this);
    }
  }

  // Double dispatch methods for listeners
  enterRule(listener) {}
  exitRule(listener) {}

  // Does not set parent link; other add methods do that
  addChild(child) {
    if (this.children === null) {
      this.children = [];
    }
    this.children.push(child);
    return child;
  }

  /** Used by enterOuterAlt to toss out a RuleContext previously added as
   * we entered a rule. If we have // label, we will need to remove
   * generic ruleContext object.
   */
  removeLastChild() {
    if (this.children !== null) {
      this.children.pop();
    }
  }
  addTokenNode(token) {
    const node = new TerminalNodeImpl(token);
    this.addChild(node);
    node.parentCtx = this;
    return node;
  }
  addErrorNode(badToken) {
    const node = new ErrorNodeImpl(badToken);
    this.addChild(node);
    node.parentCtx = this;
    return node;
  }
  getChild(i, type) {
    type = type || null;
    if (this.children === null || i < 0 || i >= this.children.length) {
      return null;
    }
    if (type === null) {
      return this.children[i];
    } else {
      for (let j = 0; j < this.children.length; j++) {
        const child = this.children[j];
        if (child instanceof type) {
          if (i === 0) {
            return child;
          } else {
            i -= 1;
          }
        }
      }
      return null;
    }
  }
  getToken(ttype, i) {
    if (this.children === null || i < 0 || i >= this.children.length) {
      return null;
    }
    for (let j = 0; j < this.children.length; j++) {
      const child = this.children[j];
      if (child instanceof TerminalNode) {
        if (child.symbol.type === ttype) {
          if (i === 0) {
            return child;
          } else {
            i -= 1;
          }
        }
      }
    }
    return null;
  }
  getTokens(ttype) {
    if (this.children === null) {
      return [];
    } else {
      const tokens = [];
      for (let j = 0; j < this.children.length; j++) {
        const child = this.children[j];
        if (child instanceof TerminalNode) {
          if (child.symbol.type === ttype) {
            tokens.push(child);
          }
        }
      }
      return tokens;
    }
  }
  getTypedRuleContext(ctxType, i) {
    return this.getChild(i, ctxType);
  }
  getTypedRuleContexts(ctxType) {
    if (this.children === null) {
      return [];
    } else {
      const contexts = [];
      for (let j = 0; j < this.children.length; j++) {
        const child = this.children[j];
        if (child instanceof ctxType) {
          contexts.push(child);
        }
      }
      return contexts;
    }
  }
  getChildCount() {
    if (this.children === null) {
      return 0;
    } else {
      return this.children.length;
    }
  }
  getSourceInterval() {
    if (this.start === null || this.stop === null) {
      return INVALID_INTERVAL;
    } else {
      return new Interval(this.start.tokenIndex, this.stop.tokenIndex);
    }
  }
}
RuleContext.EMPTY = new ParserRuleContext();
class InterpreterRuleContext extends ParserRuleContext {
  constructor(parent, invokingStateNumber, ruleIndex) {
    super(parent, invokingStateNumber);
    this.ruleIndex = ruleIndex;
  }
}
module.exports = ParserRuleContext;

/***/ }),
/* 37 */
/***/ (function() {

/*! https://mths.be/codepointat v0.2.0 by @mathias */
if (!String.prototype.codePointAt) {
  (function () {
    'use strict';

    // needed to support `apply`/`call` with `undefined`/`null`
    var defineProperty = function () {
      // IE 8 only supports `Object.defineProperty` on DOM elements
      let result;
      try {
        const object = {};
        const $defineProperty = Object.defineProperty;
        result = $defineProperty(object, object, object) && $defineProperty;
      } catch (error) {}
      return result;
    }();
    const codePointAt = function (position) {
      if (this == null) {
        throw TypeError();
      }
      const string = String(this);
      const size = string.length;
      // `ToInteger`
      let index = position ? Number(position) : 0;
      if (index !== index) {
        // better `isNaN`
        index = 0;
      }
      // Account for out-of-bounds indices:
      if (index < 0 || index >= size) {
        return undefined;
      }
      // Get the first code unit
      const first = string.charCodeAt(index);
      let second;
      if (
      // check if its the start of a surrogate pair
      first >= 0xD800 && first <= 0xDBFF &&
      // high surrogate
      size > index + 1 // there is a next code unit
      ) {
        second = string.charCodeAt(index + 1);
        if (second >= 0xDC00 && second <= 0xDFFF) {
          // low surrogate
          // https://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae
          return (first - 0xD800) * 0x400 + second - 0xDC00 + 0x10000;
        }
      }
      return first;
    };
    if (defineProperty) {
      defineProperty(String.prototype, 'codePointAt', {
        'value': codePointAt,
        'configurable': true,
        'writable': true
      });
    } else {
      String.prototype.codePointAt = codePointAt;
    }
  })();
}

/***/ }),
/* 38 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

/* Copyright (c) 2012-2017 The ANTLR Project. All rights reserved.
 * Use of this file is governed by the BSD 3-clause license that
 * can be found in the LICENSE.txt file in the project root.
 */

exports.DFA = __webpack_require__(39);
exports.DFASerializer = __webpack_require__(40).DFASerializer;
exports.LexerDFASerializer = __webpack_require__(40).LexerDFASerializer;
exports.PredPrediction = __webpack_require__(31).PredPrediction;

/***/ }),
/* 39 */
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

/* Copyright (c) 2012-2017 The ANTLR Project. All rights reserved.
 * Use of this file is governed by the BSD 3-clause license that
 * can be found in the LICENSE.txt file in the project root.
 */

const {
  Set
} = __webpack_require__(9);
const {
  DFAState
} = __webpack_require__(31);
const {
  StarLoopEntryState
} = __webpack_require__(12);
const {
  ATNConfigSet
} = __webpack_require__(32);
const {
  DFASerializer
} = __webpack_require__(40);
const {
  LexerDFASerializer
} = __webpack_require__(40);
class DFA {
  constructor(atnStartState, decision) {
    if (decision === undefined) {
      decision = 0;
    }
    /**
     * From which ATN state did we create this DFA?
     */
    this.atnStartState = atnStartState;
    this.decision = decision;
    /**
     * A set of all DFA states. Use {@link Map} so we can get old state back
     * ({@link Set} only allows you to see if it's there).
     */
    this._states = new Set();
    this.s0 = null;
    /**
     * {@code true} if this DFA is for a precedence decision; otherwise,
     * {@code false}. This is the backing field for {@link //isPrecedenceDfa},
     * {@link //setPrecedenceDfa}
     */
    this.precedenceDfa = false;
    if (atnStartState instanceof StarLoopEntryState) {
      if (atnStartState.isPrecedenceDecision) {
        this.precedenceDfa = true;
        const precedenceState = new DFAState(null, new ATNConfigSet());
        precedenceState.edges = [];
        precedenceState.isAcceptState = false;
        precedenceState.requiresFullContext = false;
        this.s0 = precedenceState;
      }
    }
  }

  /**
   * Get the start state for a specific precedence value.
   *
   * @param precedence The current precedence.
   * @return The start state corresponding to the specified precedence, or
   * {@code null} if no start state exists for the specified precedence.
   *
   * @throws IllegalStateException if this is not a precedence DFA.
   * @see //isPrecedenceDfa()
   */
  getPrecedenceStartState(precedence) {
    if (!this.precedenceDfa) {
      throw "Only precedence DFAs may contain a precedence start state.";
    }
    // s0.edges is never null for a precedence DFA
    if (precedence < 0 || precedence >= this.s0.edges.length) {
      return null;
    }
    return this.s0.edges[precedence] || null;
  }

  /**
   * Set the start state for a specific precedence value.
   *
   * @param precedence The current precedence.
   * @param startState The start state corresponding to the specified
   * precedence.
   *
   * @throws IllegalStateException if this is not a precedence DFA.
   * @see //isPrecedenceDfa()
   */
  setPrecedenceStartState(precedence, startState) {
    if (!this.precedenceDfa) {
      throw "Only precedence DFAs may contain a precedence start state.";
    }
    if (precedence < 0) {
      return;
    }

    /**
     * synchronization on s0 here is ok. when the DFA is turned into a
     * precedence DFA, s0 will be initialized once and not updated again
     * s0.edges is never null for a precedence DFA
     */
    this.s0.edges[precedence] = startState;
  }

  /**
   * Sets whether this is a precedence DFA. If the specified value differs
   * from the current DFA configuration, the following actions are taken;
   * otherwise no changes are made to the current DFA.
   *
   * <ul>
   * <li>The {@link //states} map is cleared</li>
   * <li>If {@code precedenceDfa} is {@code false}, the initial state
   * {@link //s0} is set to {@code null}; otherwise, it is initialized to a new
   * {@link DFAState} with an empty outgoing {@link DFAState//edges} array to
   * store the start states for individual precedence values.</li>
   * <li>The {@link //precedenceDfa} field is updated</li>
   * </ul>
   *
   * @param precedenceDfa {@code true} if this is a precedence DFA; otherwise,
   * {@code false}
   */
  setPrecedenceDfa(precedenceDfa) {
    if (this.precedenceDfa !== precedenceDfa) {
      this._states = new Set();
      if (precedenceDfa) {
        const precedenceState = new DFAState(null, new ATNConfigSet());
        precedenceState.edges = [];
        precedenceState.isAcceptState = false;
        precedenceState.requiresFullContext = false;
        this.s0 = precedenceState;
      } else {
        this.s0 = null;
      }
      this.precedenceDfa = precedenceDfa;
    }
  }

  /**
   * Return a list of all states in this DFA, ordered by state number.
   */
  sortedStates() {
    const list = this._states.values();
    return list.sort(function (a, b) {
      return a.stateNumber - b.stateNumber;
    });
  }
  toString(literalNames, symbolicNames) {
    literalNames = literalNames || null;
    symbolicNames = symbolicNames || null;
    if (this.s0 === null) {
      return "";
    }
    const serializer = new DFASerializer(this, literalNames, symbolicNames);
    return serializer.toString();
  }
  toLexerString() {
    if (this.s0 === null) {
      return "";
    }
    const serializer = new LexerDFASerializer(this);
    return serializer.toString();
  }
  get states() {
    return this._states;
  }
}
module.exports = DFA;

/***/ }),
/* 40 */
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

/* Copyright (c) 2012-2017 The ANTLR Project. All rights reserved.
 * Use of this file is governed by the BSD 3-clause license that
 * can be found in the LICENSE.txt file in the project root.
 */
const Utils = __webpack_require__(9);

/**
 * A DFA walker that knows how to dump them to serialized strings.
 */
class DFASerializer {
  constructor(dfa, literalNames, symbolicNames) {
    this.dfa = dfa;
    this.literalNames = literalNames || [];
    this.symbolicNames = symbolicNames || [];
  }
  toString() {
    if (this.dfa.s0 === null) {
      return null;
    }
    let buf = "";
    const states = this.dfa.sortedStates();
    for (let i = 0; i < states.length; i++) {
      const s = states[i];
      if (s.edges !== null) {
        const n = s.edges.length;
        for (let j = 0; j < n; j++) {
          const t = s.edges[j] || null;
          if (t !== null && t.stateNumber !== 0x7FFFFFFF) {
            buf = buf.concat(this.getStateString(s));
            buf = buf.concat("-");
            buf = buf.concat(this.getEdgeLabel(j));
            buf = buf.concat("->");
            buf = buf.concat(this.getStateString(t));
            buf = buf.concat('\n');
          }
        }
      }
    }
    return buf.length === 0 ? null : buf;
  }
  getEdgeLabel(i) {
    if (i === 0) {
      return "EOF";
    } else if (this.literalNames !== null || this.symbolicNames !== null) {
      return this.literalNames[i - 1] || this.symbolicNames[i - 1];
    } else {
      return String.fromCharCode(i - 1);
    }
  }
  getStateString(s) {
    const baseStateStr = (s.isAcceptState ? ":" : "") + "s" + s.stateNumber + (s.requiresFullContext ? "^" : "");
    if (s.isAcceptState) {
      if (s.predicates !== null) {
        return baseStateStr + "=>" + Utils.arrayToString(s.predicates);
      } else {
        return baseStateStr + "=>" + s.prediction.toString();
      }
    } else {
      return baseStateStr;
    }
  }
}
class LexerDFASerializer extends DFASerializer {
  constructor(dfa) {
    super(dfa, null);
  }
  getEdgeLabel(i) {
    return "'" + String.fromCharCode(i) + "'";
  }
}
module.exports = {
  DFASerializer,
  LexerDFASerializer
};

/***/ }),
/* 41 */
/***/ (function() {

/*! https://mths.be/fromcodepoint v0.2.1 by @mathias */
if (!String.fromCodePoint) {
  (function () {
    const defineProperty = function () {
      // IE 8 only supports `Object.defineProperty` on DOM elements
      let result;
      try {
        const object = {};
        const $defineProperty = Object.defineProperty;
        result = $defineProperty(object, object, object) && $defineProperty;
      } catch (error) {}
      return result;
    }();
    const stringFromCharCode = String.fromCharCode;
    const floor = Math.floor;
    const fromCodePoint = function (_) {
      const MAX_SIZE = 0x4000;
      const codeUnits = [];
      let highSurrogate;
      let lowSurrogate;
      let index = -1;
      const length = arguments.length;
      if (!length) {
        return '';
      }
      let result = '';
      while (++index < length) {
        let codePoint = Number(arguments[index]);
        if (!isFinite(codePoint) ||
        // `NaN`, `+Infinity`, or `-Infinity`
        codePoint < 0 ||
        // not a valid Unicode code point
        codePoint > 0x10FFFF ||
        // not a valid Unicode code point
        floor(codePoint) !== codePoint // not an integer
        ) {
          throw RangeError('Invalid code point: ' + codePoint);
        }
        if (codePoint <= 0xFFFF) {
          // BMP code point
          codeUnits.push(codePoint);
        } else {
          // Astral code point; split in surrogate halves
          // https://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae
          codePoint -= 0x10000;
          highSurrogate = (codePoint >> 10) + 0xD800;
          lowSurrogate = codePoint % 0x400 + 0xDC00;
          codeUnits.push(highSurrogate, lowSurrogate);
        }
        if (index + 1 === length || codeUnits.length > MAX_SIZE) {
          result += stringFromCharCode.apply(null, codeUnits);
          codeUnits.length = 0;
        }
      }
      return result;
    };
    if (defineProperty) {
      defineProperty(String, 'fromCodePoint', {
        'value': fromCodePoint,
        'configurable': true,
        'writable': true
      });
    } else {
      String.fromCodePoint = fromCodePoint;
    }
  })();
}

/***/ }),
/* 42 */
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

/* Copyright (c) 2012-2017 The ANTLR Project. All rights reserved.
 * Use of this file is governed by the BSD 3-clause license that
 * can be found in the LICENSE.txt file in the project root.
 */

const Tree = __webpack_require__(18);
const Trees = __webpack_require__(19);
module.exports = {
  ...Tree,
  Trees
};

/***/ }),
/* 43 */
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

/* Copyright (c) 2012-2017 The ANTLR Project. All rights reserved.
 * Use of this file is governed by the BSD 3-clause license that
 * can be found in the LICENSE.txt file in the project root.
 */

module.exports.RecognitionException = __webpack_require__(29).RecognitionException;
module.exports.NoViableAltException = __webpack_require__(29).NoViableAltException;
module.exports.LexerNoViableAltException = __webpack_require__(29).LexerNoViableAltException;
module.exports.InputMismatchException = __webpack_require__(29).InputMismatchException;
module.exports.FailedPredicateException = __webpack_require__(29).FailedPredicateException;
module.exports.DiagnosticErrorListener = __webpack_require__(44);
module.exports.BailErrorStrategy = __webpack_require__(45).BailErrorStrategy;
module.exports.DefaultErrorStrategy = __webpack_require__(45).DefaultErrorStrategy;
module.exports.ErrorListener = __webpack_require__(27).ErrorListener;

/***/ }),
/* 44 */
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

/* Copyright (c) 2012-2017 The ANTLR Project. All rights reserved.
 * Use of this file is governed by the BSD 3-clause license that
 * can be found in the LICENSE.txt file in the project root.
 */

const {
  BitSet
} = __webpack_require__(9);
const {
  ErrorListener
} = __webpack_require__(27);
const {
  Interval
} = __webpack_require__(14);

/**
 * This implementation of {@link ANTLRErrorListener} can be used to identify
 *  certain potential correctness and performance problems in grammars. "Reports"
 *  are made by calling {@link Parser//notifyErrorListeners} with the appropriate
 *  message.
 *
 *  <ul>
 *  <li><b>Ambiguities</b>: These are cases where more than one path through the
 *  grammar can match the input.</li>
 *  <li><b>Weak context sensitivity</b>: These are cases where full-context
 *  prediction resolved an SLL conflict to a unique alternative which equaled the
 *  minimum alternative of the SLL conflict.</li>
 *  <li><b>Strong (forced) context sensitivity</b>: These are cases where the
 *  full-context prediction resolved an SLL conflict to a unique alternative,
 *  <em>and</em> the minimum alternative of the SLL conflict was found to not be
 *  a truly viable alternative. Two-stage parsing cannot be used for inputs where
 *  this situation occurs.</li>
 *  </ul>
 */
class DiagnosticErrorListener extends ErrorListener {
  constructor(exactOnly) {
    super();
    exactOnly = exactOnly || true;
    // whether all ambiguities or only exact ambiguities are reported.
    this.exactOnly = exactOnly;
  }
  reportAmbiguity(recognizer, dfa, startIndex, stopIndex, exact, ambigAlts, configs) {
    if (this.exactOnly && !exact) {
      return;
    }
    const msg = "reportAmbiguity d=" + this.getDecisionDescription(recognizer, dfa) + ": ambigAlts=" + this.getConflictingAlts(ambigAlts, configs) + ", input='" + recognizer.getTokenStream().getText(new Interval(startIndex, stopIndex)) + "'";
    recognizer.notifyErrorListeners(msg);
  }
  reportAttemptingFullContext(recognizer, dfa, startIndex, stopIndex, conflictingAlts, configs) {
    const msg = "reportAttemptingFullContext d=" + this.getDecisionDescription(recognizer, dfa) + ", input='" + recognizer.getTokenStream().getText(new Interval(startIndex, stopIndex)) + "'";
    recognizer.notifyErrorListeners(msg);
  }
  reportContextSensitivity(recognizer, dfa, startIndex, stopIndex, prediction, configs) {
    const msg = "reportContextSensitivity d=" + this.getDecisionDescription(recognizer, dfa) + ", input='" + recognizer.getTokenStream().getText(new Interval(startIndex, stopIndex)) + "'";
    recognizer.notifyErrorListeners(msg);
  }
  getDecisionDescription(recognizer, dfa) {
    const decision = dfa.decision;
    const ruleIndex = dfa.atnStartState.ruleIndex;
    const ruleNames = recognizer.ruleNames;
    if (ruleIndex < 0 || ruleIndex >= ruleNames.length) {
      return "" + decision;
    }
    const ruleName = ruleNames[ruleIndex] || null;
    if (ruleName === null || ruleName.length === 0) {
      return "" + decision;
    }
    return `${decision} (${ruleName})`;
  }

  /**
   * Computes the set of conflicting or ambiguous alternatives from a
   * configuration set, if that information was not already provided by the
   * parser.
   *
   * @param reportedAlts The set of conflicting or ambiguous alternatives, as
   * reported by the parser.
   * @param configs The conflicting or ambiguous configuration set.
   * @return Returns {@code reportedAlts} if it is not {@code null}, otherwise
   * returns the set of alternatives represented in {@code configs}.
      */
  getConflictingAlts(reportedAlts, configs) {
    if (reportedAlts !== null) {
      return reportedAlts;
    }
    const result = new BitSet();
    for (let i = 0; i < configs.items.length; i++) {
      result.add(configs.items[i].alt);
    }
    return `{${result.values().join(", ")}}`;
  }
}
module.exports = DiagnosticErrorListener;

/***/ }),
/* 45 */
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

/* Copyright (c) 2012-2017 The ANTLR Project. All rights reserved.
 * Use of this file is governed by the BSD 3-clause license that
 * can be found in the LICENSE.txt file in the project root.
 */

const {
  Token
} = __webpack_require__(10);
const {
  NoViableAltException,
  InputMismatchException,
  FailedPredicateException,
  ParseCancellationException
} = __webpack_require__(29);
const {
  ATNState
} = __webpack_require__(12);
const {
  Interval,
  IntervalSet
} = __webpack_require__(14);
class ErrorStrategy {
  reset(recognizer) {}
  recoverInline(recognizer) {}
  recover(recognizer, e) {}
  sync(recognizer) {}
  inErrorRecoveryMode(recognizer) {}
  reportError(recognizer) {}
}

/**
 * This is the default implementation of {@link ANTLRErrorStrategy} used for
 * error reporting and recovery in ANTLR parsers.
*/
class DefaultErrorStrategy extends ErrorStrategy {
  constructor() {
    super();
    /**
     * Indicates whether the error strategy is currently "recovering from an
     * error". This is used to suppress reporting multiple error messages while
     * attempting to recover from a detected syntax error.
     *
     * @see //inErrorRecoveryMode
     */
    this.errorRecoveryMode = false;

    /**
     * The index into the input stream where the last error occurred.
     * This is used to prevent infinite loops where an error is found
     * but no token is consumed during recovery...another error is found,
     * ad nauseum. This is a failsafe mechanism to guarantee that at least
     * one token/tree node is consumed for two errors.
     */
    this.lastErrorIndex = -1;
    this.lastErrorStates = null;
    this.nextTokensContext = null;
    this.nextTokenState = 0;
  }

  /**
   * <p>The default implementation simply calls {@link //endErrorCondition} to
   * ensure that the handler is not in error recovery mode.</p>
  */
  reset(recognizer) {
    this.endErrorCondition(recognizer);
  }

  /**
   * This method is called to enter error recovery mode when a recognition
   * exception is reported.
   *
   * @param recognizer the parser instance
  */
  beginErrorCondition(recognizer) {
    this.errorRecoveryMode = true;
  }
  inErrorRecoveryMode(recognizer) {
    return this.errorRecoveryMode;
  }

  /**
   * This method is called to leave error recovery mode after recovering from
   * a recognition exception.
   * @param recognizer
   */
  endErrorCondition(recognizer) {
    this.errorRecoveryMode = false;
    this.lastErrorStates = null;
    this.lastErrorIndex = -1;
  }

  /**
   * {@inheritDoc}
   * <p>The default implementation simply calls {@link //endErrorCondition}.</p>
   */
  reportMatch(recognizer) {
    this.endErrorCondition(recognizer);
  }

  /**
   * {@inheritDoc}
   *
   * <p>The default implementation returns immediately if the handler is already
   * in error recovery mode. Otherwise, it calls {@link //beginErrorCondition}
   * and dispatches the reporting task based on the runtime type of {@code e}
   * according to the following table.</p>
   *
   * <ul>
   * <li>{@link NoViableAltException}: Dispatches the call to
   * {@link //reportNoViableAlternative}</li>
   * <li>{@link InputMismatchException}: Dispatches the call to
   * {@link //reportInputMismatch}</li>
   * <li>{@link FailedPredicateException}: Dispatches the call to
   * {@link //reportFailedPredicate}</li>
   * <li>All other types: calls {@link Parser//notifyErrorListeners} to report
   * the exception</li>
   * </ul>
   */
  reportError(recognizer, e) {
    // if we've already reported an error and have not matched a token
    // yet successfully, don't report any errors.
    if (this.inErrorRecoveryMode(recognizer)) {
      return; // don't report spurious errors
    }
    this.beginErrorCondition(recognizer);
    if (e instanceof NoViableAltException) {
      this.reportNoViableAlternative(recognizer, e);
    } else if (e instanceof InputMismatchException) {
      this.reportInputMismatch(recognizer, e);
    } else if (e instanceof FailedPredicateException) {
      this.reportFailedPredicate(recognizer, e);
    } else {
      console.log("unknown recognition error type: " + e.constructor.name);
      console.log(e.stack);
      recognizer.notifyErrorListeners(e.getOffendingToken(), e.getMessage(), e);
    }
  }

  /**
   *
   * {@inheritDoc}
   *
   * <p>The default implementation resynchronizes the parser by consuming tokens
   * until we find one in the resynchronization set--loosely the set of tokens
   * that can follow the current rule.</p>
   *
   */
  recover(recognizer, e) {
    if (this.lastErrorIndex === recognizer.getInputStream().index && this.lastErrorStates !== null && this.lastErrorStates.indexOf(recognizer.state) >= 0) {
      // uh oh, another error at same token index and previously-visited
      // state in ATN; must be a case where LT(1) is in the recovery
      // token set so nothing got consumed. Consume a single token
      // at least to prevent an infinite loop; this is a failsafe.
      recognizer.consume();
    }
    this.lastErrorIndex = recognizer._input.index;
    if (this.lastErrorStates === null) {
      this.lastErrorStates = [];
    }
    this.lastErrorStates.push(recognizer.state);
    const followSet = this.getErrorRecoverySet(recognizer);
    this.consumeUntil(recognizer, followSet);
  }

  /**
   * The default implementation of {@link ANTLRErrorStrategy//sync} makes sure
   * that the current lookahead symbol is consistent with what were expecting
   * at this point in the ATN. You can call this anytime but ANTLR only
   * generates code to check before subrules/loops and each iteration.
   *
   * <p>Implements Jim Idle's magic sync mechanism in closures and optional
   * subrules. E.g.,</p>
   *
   * <pre>
   * a : sync ( stuff sync )* ;
   * sync : {consume to what can follow sync} ;
   * </pre>
   *
   * At the start of a sub rule upon error, {@link //sync} performs single
   * token deletion, if possible. If it can't do that, it bails on the current
   * rule and uses the default error recovery, which consumes until the
   * resynchronization set of the current rule.
   *
   * <p>If the sub rule is optional ({@code (...)?}, {@code (...)*}, or block
   * with an empty alternative), then the expected set includes what follows
   * the subrule.</p>
   *
   * <p>During loop iteration, it consumes until it sees a token that can start a
   * sub rule or what follows loop. Yes, that is pretty aggressive. We opt to
   * stay in the loop as long as possible.</p>
   *
   * <p><strong>ORIGINS</strong></p>
   *
   * <p>Previous versions of ANTLR did a poor job of their recovery within loops.
   * A single mismatch token or missing token would force the parser to bail
   * out of the entire rules surrounding the loop. So, for rule</p>
   *
   * <pre>
   * classDef : 'class' ID '{' member* '}'
   * </pre>
   *
   * input with an extra token between members would force the parser to
   * consume until it found the next class definition rather than the next
   * member definition of the current class.
   *
   * <p>This functionality cost a little bit of effort because the parser has to
   * compare token set at the start of the loop and at each iteration. If for
   * some reason speed is suffering for you, you can turn off this
   * functionality by simply overriding this method as a blank { }.</p>
   *
   */
  sync(recognizer) {
    // If already recovering, don't try to sync
    if (this.inErrorRecoveryMode(recognizer)) {
      return;
    }
    const s = recognizer._interp.atn.states[recognizer.state];
    const la = recognizer.getTokenStream().LA(1);
    // try cheaper subset first; might get lucky. seems to shave a wee bit off
    const nextTokens = recognizer.atn.nextTokens(s);
    if (nextTokens.contains(la)) {
      this.nextTokensContext = null;
      this.nextTokenState = ATNState.INVALID_STATE_NUMBER;
      return;
    } else if (nextTokens.contains(Token.EPSILON)) {
      if (this.nextTokensContext === null) {
        // It's possible the next token won't match information tracked
        // by sync is restricted for performance.
        this.nextTokensContext = recognizer._ctx;
        this.nextTokensState = recognizer._stateNumber;
      }
      return;
    }
    switch (s.stateType) {
      case ATNState.BLOCK_START:
      case ATNState.STAR_BLOCK_START:
      case ATNState.PLUS_BLOCK_START:
      case ATNState.STAR_LOOP_ENTRY:
        // report error and recover if possible
        if (this.singleTokenDeletion(recognizer) !== null) {
          return;
        } else {
          throw new InputMismatchException(recognizer);
        }
      case ATNState.PLUS_LOOP_BACK:
      case ATNState.STAR_LOOP_BACK:
        this.reportUnwantedToken(recognizer);
        const expecting = new IntervalSet();
        expecting.addSet(recognizer.getExpectedTokens());
        const whatFollowsLoopIterationOrRule = expecting.addSet(this.getErrorRecoverySet(recognizer));
        this.consumeUntil(recognizer, whatFollowsLoopIterationOrRule);
        break;
      default:
      // do nothing if we can't identify the exact kind of ATN state
    }
  }

  /**
   * This is called by {@link //reportError} when the exception is a
   * {@link NoViableAltException}.
   *
   * @see //reportError
   *
   * @param recognizer the parser instance
   * @param e the recognition exception
   */
  reportNoViableAlternative(recognizer, e) {
    const tokens = recognizer.getTokenStream();
    let input;
    if (tokens !== null) {
      if (e.startToken.type === Token.EOF) {
        input = "<EOF>";
      } else {
        input = tokens.getText(new Interval(e.startToken.tokenIndex, e.offendingToken.tokenIndex));
      }
    } else {
      input = "<unknown input>";
    }
    const msg = "no viable alternative at input " + this.escapeWSAndQuote(input);
    recognizer.notifyErrorListeners(msg, e.offendingToken, e);
  }

  /**
   * This is called by {@link //reportError} when the exception is an
   * {@link InputMismatchException}.
   *
   * @see //reportError
   *
   * @param recognizer the parser instance
   * @param e the recognition exception
   */
  reportInputMismatch(recognizer, e) {
    const msg = "mismatched input " + this.getTokenErrorDisplay(e.offendingToken) + " expecting " + e.getExpectedTokens().toString(recognizer.literalNames, recognizer.symbolicNames);
    recognizer.notifyErrorListeners(msg, e.offendingToken, e);
  }

  /**
   * This is called by {@link //reportError} when the exception is a
   * {@link FailedPredicateException}.
   *
   * @see //reportError
   *
   * @param recognizer the parser instance
   * @param e the recognition exception
   */
  reportFailedPredicate(recognizer, e) {
    const ruleName = recognizer.ruleNames[recognizer._ctx.ruleIndex];
    const msg = "rule " + ruleName + " " + e.message;
    recognizer.notifyErrorListeners(msg, e.offendingToken, e);
  }

  /**
   * This method is called to report a syntax error which requires the removal
   * of a token from the input stream. At the time this method is called, the
   * erroneous symbol is current {@code LT(1)} symbol and has not yet been
   * removed from the input stream. When this method returns,
   * {@code recognizer} is in error recovery mode.
   *
   * <p>This method is called when {@link //singleTokenDeletion} identifies
   * single-token deletion as a viable recovery strategy for a mismatched
   * input error.</p>
   *
   * <p>The default implementation simply returns if the handler is already in
   * error recovery mode. Otherwise, it calls {@link //beginErrorCondition} to
   * enter error recovery mode, followed by calling
   * {@link Parser//notifyErrorListeners}.</p>
   *
   * @param recognizer the parser instance
   *
   */
  reportUnwantedToken(recognizer) {
    if (this.inErrorRecoveryMode(recognizer)) {
      return;
    }
    this.beginErrorCondition(recognizer);
    const t = recognizer.getCurrentToken();
    const tokenName = this.getTokenErrorDisplay(t);
    const expecting = this.getExpectedTokens(recognizer);
    const msg = "extraneous input " + tokenName + " expecting " + expecting.toString(recognizer.literalNames, recognizer.symbolicNames);
    recognizer.notifyErrorListeners(msg, t, null);
  }

  /**
   * This method is called to report a syntax error which requires the
   * insertion of a missing token into the input stream. At the time this
   * method is called, the missing token has not yet been inserted. When this
   * method returns, {@code recognizer} is in error recovery mode.
   *
   * <p>This method is called when {@link //singleTokenInsertion} identifies
   * single-token insertion as a viable recovery strategy for a mismatched
   * input error.</p>
   *
   * <p>The default implementation simply returns if the handler is already in
   * error recovery mode. Otherwise, it calls {@link //beginErrorCondition} to
   * enter error recovery mode, followed by calling
   * {@link Parser//notifyErrorListeners}.</p>
   *
   * @param recognizer the parser instance
   */
  reportMissingToken(recognizer) {
    if (this.inErrorRecoveryMode(recognizer)) {
      return;
    }
    this.beginErrorCondition(recognizer);
    const t = recognizer.getCurrentToken();
    const expecting = this.getExpectedTokens(recognizer);
    const msg = "missing " + expecting.toString(recognizer.literalNames, recognizer.symbolicNames) + " at " + this.getTokenErrorDisplay(t);
    recognizer.notifyErrorListeners(msg, t, null);
  }

  /**
   * <p>The default implementation attempts to recover from the mismatched input
   * by using single token insertion and deletion as described below. If the
   * recovery attempt fails, this method throws an
   * {@link InputMismatchException}.</p>
   *
   * <p><strong>EXTRA TOKEN</strong> (single token deletion)</p>
   *
   * <p>{@code LA(1)} is not what we are looking for. If {@code LA(2)} has the
   * right token, however, then assume {@code LA(1)} is some extra spurious
   * token and delete it. Then consume and return the next token (which was
   * the {@code LA(2)} token) as the successful result of the match operation.</p>
   *
   * <p>This recovery strategy is implemented by {@link
   * //singleTokenDeletion}.</p>
   *
   * <p><strong>MISSING TOKEN</strong> (single token insertion)</p>
   *
   * <p>If current token (at {@code LA(1)}) is consistent with what could come
   * after the expected {@code LA(1)} token, then assume the token is missing
   * and use the parser's {@link TokenFactory} to create it on the fly. The
   * "insertion" is performed by returning the created token as the successful
   * result of the match operation.</p>
   *
   * <p>This recovery strategy is implemented by {@link
   * //singleTokenInsertion}.</p>
   *
   * <p><strong>EXAMPLE</strong></p>
   *
   * <p>For example, Input {@code i=(3;} is clearly missing the {@code ')'}. When
   * the parser returns from the nested call to {@code expr}, it will have
   * call chain:</p>
   *
   * <pre>
   * stat &rarr; expr &rarr; atom
   * </pre>
   *
   * and it will be trying to match the {@code ')'} at this point in the
   * derivation:
   *
   * <pre>
   * =&gt; ID '=' '(' INT ')' ('+' atom)* ';'
   * ^
   * </pre>
   *
   * The attempt to match {@code ')'} will fail when it sees {@code ';'} and
   * call {@link //recoverInline}. To recover, it sees that {@code LA(1)==';'}
   * is in the set of tokens that can follow the {@code ')'} token reference
   * in rule {@code atom}. It can assume that you forgot the {@code ')'}.
   */
  recoverInline(recognizer) {
    // SINGLE TOKEN DELETION
    const matchedSymbol = this.singleTokenDeletion(recognizer);
    if (matchedSymbol !== null) {
      // we have deleted the extra token.
      // now, move past ttype token as if all were ok
      recognizer.consume();
      return matchedSymbol;
    }
    // SINGLE TOKEN INSERTION
    if (this.singleTokenInsertion(recognizer)) {
      return this.getMissingSymbol(recognizer);
    }
    // even that didn't work; must throw the exception
    throw new InputMismatchException(recognizer);
  }

  /**
   * This method implements the single-token insertion inline error recovery
   * strategy. It is called by {@link //recoverInline} if the single-token
   * deletion strategy fails to recover from the mismatched input. If this
   * method returns {@code true}, {@code recognizer} will be in error recovery
   * mode.
   *
   * <p>This method determines whether or not single-token insertion is viable by
   * checking if the {@code LA(1)} input symbol could be successfully matched
   * if it were instead the {@code LA(2)} symbol. If this method returns
   * {@code true}, the caller is responsible for creating and inserting a
   * token with the correct type to produce this behavior.</p>
   *
   * @param recognizer the parser instance
   * @return {@code true} if single-token insertion is a viable recovery
   * strategy for the current mismatched input, otherwise {@code false}
   */
  singleTokenInsertion(recognizer) {
    const currentSymbolType = recognizer.getTokenStream().LA(1);
    // if current token is consistent with what could come after current
    // ATN state, then we know we're missing a token; error recovery
    // is free to conjure up and insert the missing token
    const atn = recognizer._interp.atn;
    const currentState = atn.states[recognizer.state];
    const next = currentState.transitions[0].target;
    const expectingAtLL2 = atn.nextTokens(next, recognizer._ctx);
    if (expectingAtLL2.contains(currentSymbolType)) {
      this.reportMissingToken(recognizer);
      return true;
    } else {
      return false;
    }
  }

  /**
   * This method implements the single-token deletion inline error recovery
   * strategy. It is called by {@link //recoverInline} to attempt to recover
   * from mismatched input. If this method returns null, the parser and error
   * handler state will not have changed. If this method returns non-null,
   * {@code recognizer} will <em>not</em> be in error recovery mode since the
   * returned token was a successful match.
   *
   * <p>If the single-token deletion is successful, this method calls
   * {@link //reportUnwantedToken} to report the error, followed by
   * {@link Parser//consume} to actually "delete" the extraneous token. Then,
   * before returning {@link //reportMatch} is called to signal a successful
   * match.</p>
   *
   * @param recognizer the parser instance
   * @return the successfully matched {@link Token} instance if single-token
   * deletion successfully recovers from the mismatched input, otherwise
   * {@code null}
   */
  singleTokenDeletion(recognizer) {
    const nextTokenType = recognizer.getTokenStream().LA(2);
    const expecting = this.getExpectedTokens(recognizer);
    if (expecting.contains(nextTokenType)) {
      this.reportUnwantedToken(recognizer);
      // print("recoverFromMismatchedToken deleting " \
      // + str(recognizer.getTokenStream().LT(1)) \
      // + " since " + str(recognizer.getTokenStream().LT(2)) \
      // + " is what we want", file=sys.stderr)
      recognizer.consume(); // simply delete extra token
      // we want to return the token we're actually matching
      const matchedSymbol = recognizer.getCurrentToken();
      this.reportMatch(recognizer); // we know current token is correct
      return matchedSymbol;
    } else {
      return null;
    }
  }

  /**
   * Conjure up a missing token during error recovery.
   *
   * The recognizer attempts to recover from single missing
   * symbols. But, actions might refer to that missing symbol.
   * For example, x=ID {f($x);}. The action clearly assumes
   * that there has been an identifier matched previously and that
   * $x points at that token. If that token is missing, but
   * the next token in the stream is what we want we assume that
   * this token is missing and we keep going. Because we
   * have to return some token to replace the missing token,
   * we have to conjure one up. This method gives the user control
   * over the tokens returned for missing tokens. Mostly,
   * you will want to create something special for identifier
   * tokens. For literals such as '{' and ',', the default
   * action in the parser or tree parser works. It simply creates
   * a CommonToken of the appropriate type. The text will be the token.
   * If you change what tokens must be created by the lexer,
   * override this method to create the appropriate tokens.
   *
   */
  getMissingSymbol(recognizer) {
    const currentSymbol = recognizer.getCurrentToken();
    const expecting = this.getExpectedTokens(recognizer);
    const expectedTokenType = expecting.first(); // get any element
    let tokenText;
    if (expectedTokenType === Token.EOF) {
      tokenText = "<missing EOF>";
    } else {
      tokenText = "<missing " + recognizer.literalNames[expectedTokenType] + ">";
    }
    let current = currentSymbol;
    const lookback = recognizer.getTokenStream().LT(-1);
    if (current.type === Token.EOF && lookback !== null) {
      current = lookback;
    }
    return recognizer.getTokenFactory().create(current.source, expectedTokenType, tokenText, Token.DEFAULT_CHANNEL, -1, -1, current.line, current.column);
  }
  getExpectedTokens(recognizer) {
    return recognizer.getExpectedTokens();
  }

  /**
   * How should a token be displayed in an error message? The default
   * is to display just the text, but during development you might
   * want to have a lot of information spit out. Override in that case
   * to use t.toString() (which, for CommonToken, dumps everything about
   * the token). This is better than forcing you to override a method in
   * your token objects because you don't have to go modify your lexer
   * so that it creates a new Java type.
   */
  getTokenErrorDisplay(t) {
    if (t === null) {
      return "<no token>";
    }
    let s = t.text;
    if (s === null) {
      if (t.type === Token.EOF) {
        s = "<EOF>";
      } else {
        s = "<" + t.type + ">";
      }
    }
    return this.escapeWSAndQuote(s);
  }
  escapeWSAndQuote(s) {
    s = s.replace(/\n/g, "\\n");
    s = s.replace(/\r/g, "\\r");
    s = s.replace(/\t/g, "\\t");
    return "'" + s + "'";
  }

  /**
   * Compute the error recovery set for the current rule. During
   * rule invocation, the parser pushes the set of tokens that can
   * follow that rule reference on the stack; this amounts to
   * computing FIRST of what follows the rule reference in the
   * enclosing rule. See LinearApproximator.FIRST().
   * This local follow set only includes tokens
   * from within the rule; i.e., the FIRST computation done by
   * ANTLR stops at the end of a rule.
   *
   * EXAMPLE
   *
   * When you find a "no viable alt exception", the input is not
   * consistent with any of the alternatives for rule r. The best
   * thing to do is to consume tokens until you see something that
   * can legally follow a call to r//or* any rule that called r.
   * You don't want the exact set of viable next tokens because the
   * input might just be missing a token--you might consume the
   * rest of the input looking for one of the missing tokens.
   *
   * Consider grammar:
   *
   * a : '[' b ']'
   * | '(' b ')'
   * ;
   * b : c '^' INT ;
   * c : ID
   * | INT
   * ;
   *
   * At each rule invocation, the set of tokens that could follow
   * that rule is pushed on a stack. Here are the various
   * context-sensitive follow sets:
   *
   * FOLLOW(b1_in_a) = FIRST(']') = ']'
   * FOLLOW(b2_in_a) = FIRST(')') = ')'
   * FOLLOW(c_in_b) = FIRST('^') = '^'
   *
   * Upon erroneous input "[]", the call chain is
   *
   * a -> b -> c
   *
   * and, hence, the follow context stack is:
   *
   * depth follow set start of rule execution
   * 0 <EOF> a (from main())
   * 1 ']' b
   * 2 '^' c
   *
   * Notice that ')' is not included, because b would have to have
   * been called from a different context in rule a for ')' to be
   * included.
   *
   * For error recovery, we cannot consider FOLLOW(c)
   * (context-sensitive or otherwise). We need the combined set of
   * all context-sensitive FOLLOW sets--the set of all tokens that
   * could follow any reference in the call chain. We need to
   * resync to one of those tokens. Note that FOLLOW(c)='^' and if
   * we resync'd to that token, we'd consume until EOF. We need to
   * sync to context-sensitive FOLLOWs for a, b, and c: {']','^'}.
   * In this case, for input "[]", LA(1) is ']' and in the set, so we would
   * not consume anything. After printing an error, rule c would
   * return normally. Rule b would not find the required '^' though.
   * At this point, it gets a mismatched token error and throws an
   * exception (since LA(1) is not in the viable following token
   * set). The rule exception handler tries to recover, but finds
   * the same recovery set and doesn't consume anything. Rule b
   * exits normally returning to rule a. Now it finds the ']' (and
   * with the successful match exits errorRecovery mode).
   *
   * So, you can see that the parser walks up the call chain looking
   * for the token that was a member of the recovery set.
   *
   * Errors are not generated in errorRecovery mode.
   *
   * ANTLR's error recovery mechanism is based upon original ideas:
   *
   * "Algorithms + Data Structures = Programs" by Niklaus Wirth
   *
   * and
   *
   * "A note on error recovery in recursive descent parsers":
   * http://portal.acm.org/citation.cfm?id=947902.947905
   *
   * Later, Josef Grosch had some good ideas:
   *
   * "Efficient and Comfortable Error Recovery in Recursive Descent
   * Parsers":
   * ftp://www.cocolab.com/products/cocktail/doca4.ps/ell.ps.zip
   *
   * Like Grosch I implement context-sensitive FOLLOW sets that are combined
   * at run-time upon error to avoid overhead during parsing.
   */
  getErrorRecoverySet(recognizer) {
    const atn = recognizer._interp.atn;
    let ctx = recognizer._ctx;
    const recoverSet = new IntervalSet();
    while (ctx !== null && ctx.invokingState >= 0) {
      // compute what follows who invoked us
      const invokingState = atn.states[ctx.invokingState];
      const rt = invokingState.transitions[0];
      const follow = atn.nextTokens(rt.followState);
      recoverSet.addSet(follow);
      ctx = ctx.parentCtx;
    }
    recoverSet.removeOne(Token.EPSILON);
    return recoverSet;
  }

  // Consume tokens until one matches the given token set.//
  consumeUntil(recognizer, set) {
    let ttype = recognizer.getTokenStream().LA(1);
    while (ttype !== Token.EOF && !set.contains(ttype)) {
      recognizer.consume();
      ttype = recognizer.getTokenStream().LA(1);
    }
  }
}

/**
 * This implementation of {@link ANTLRErrorStrategy} responds to syntax errors
 * by immediately canceling the parse operation with a
 * {@link ParseCancellationException}. The implementation ensures that the
 * {@link ParserRuleContext//exception} field is set for all parse tree nodes
 * that were not completed prior to encountering the error.
 *
 * <p>
 * This error strategy is useful in the following scenarios.</p>
 *
 * <ul>
 * <li><strong>Two-stage parsing:</strong> This error strategy allows the first
 * stage of two-stage parsing to immediately terminate if an error is
 * encountered, and immediately fall back to the second stage. In addition to
 * avoiding wasted work by attempting to recover from errors here, the empty
 * implementation of {@link BailErrorStrategy//sync} improves the performance of
 * the first stage.</li>
 * <li><strong>Silent validation:</strong> When syntax errors are not being
 * reported or logged, and the parse result is simply ignored if errors occur,
 * the {@link BailErrorStrategy} avoids wasting work on recovering from errors
 * when the result will be ignored either way.</li>
 * </ul>
 *
 * <p>
 * {@code myparser.setErrorHandler(new BailErrorStrategy());}</p>
 *
 * @see Parser//setErrorHandler(ANTLRErrorStrategy)
 * */
class BailErrorStrategy extends DefaultErrorStrategy {
  constructor() {
    super();
  }

  /**
   * Instead of recovering from exception {@code e}, re-throw it wrapped
   * in a {@link ParseCancellationException} so it is not caught by the
   * rule function catches. Use {@link Exception//getCause()} to get the
   * original {@link RecognitionException}.
   */
  recover(recognizer, e) {
    let context = recognizer._ctx;
    while (context !== null) {
      context.exception = e;
      context = context.parentCtx;
    }
    throw new ParseCancellationException(e);
  }

  /**
   * Make sure we don't attempt to recover inline; if the parser
   * successfully recovers, it won't throw an exception.
   */
  recoverInline(recognizer) {
    this.recover(recognizer, new InputMismatchException(recognizer));
  }

  // Make sure we don't attempt to recover from problems in subrules.//
  sync(recognizer) {
    // pass
  }
}
module.exports = {
  BailErrorStrategy,
  DefaultErrorStrategy
};

/***/ }),
/* 46 */
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

/* Copyright (c) 2012-2017 The ANTLR Project. All rights reserved.
 * Use of this file is governed by the BSD 3-clause license that
 * can be found in the LICENSE.txt file in the project root.
 */

const {
  Token
} = __webpack_require__(10);
__webpack_require__(37);
__webpack_require__(41);

/**
 * If decodeToUnicodeCodePoints is true, the input is treated
 * as a series of Unicode code points.
 *
 * Otherwise, the input is treated as a series of 16-bit UTF-16 code
 * units.
 */
class InputStream {
  constructor(data, decodeToUnicodeCodePoints) {
    this.name = "<empty>";
    this.strdata = data;
    this.decodeToUnicodeCodePoints = decodeToUnicodeCodePoints || false;
    // _loadString - Vacuum all input from a string and then treat it like a buffer.
    this._index = 0;
    this.data = [];
    if (this.decodeToUnicodeCodePoints) {
      for (let i = 0; i < this.strdata.length;) {
        const codePoint = this.strdata.codePointAt(i);
        this.data.push(codePoint);
        i += codePoint <= 0xFFFF ? 1 : 2;
      }
    } else {
      this.data = new Array(this.strdata.length);
      for (let i = 0; i < this.strdata.length; i++) {
        const codeUnit = this.strdata.charCodeAt(i);
        this.data[i] = codeUnit;
      }
    }
    this._size = this.data.length;
  }

  /**
   * Reset the stream so that it's in the same state it was
   * when the object was created *except* the data array is not
   * touched.
   */
  reset() {
    this._index = 0;
  }
  consume() {
    if (this._index >= this._size) {
      // assert this.LA(1) == Token.EOF
      throw "cannot consume EOF";
    }
    this._index += 1;
  }
  LA(offset) {
    if (offset === 0) {
      return 0; // undefined
    }
    if (offset < 0) {
      offset += 1; // e.g., translate LA(-1) to use offset=0
    }
    const pos = this._index + offset - 1;
    if (pos < 0 || pos >= this._size) {
      // invalid
      return Token.EOF;
    }
    return this.data[pos];
  }
  LT(offset) {
    return this.LA(offset);
  }

  // mark/release do nothing; we have entire buffer
  mark() {
    return -1;
  }
  release(marker) {}

  /**
   * consume() ahead until p==_index; can't just set p=_index as we must
   * update line and column. If we seek backwards, just set p
   */
  seek(_index) {
    if (_index <= this._index) {
      this._index = _index; // just jump; don't update stream state (line,
      // ...)
      return;
    }
    // seek forward
    this._index = Math.min(_index, this._size);
  }
  getText(start, stop) {
    if (stop >= this._size) {
      stop = this._size - 1;
    }
    if (start >= this._size) {
      return "";
    } else {
      if (this.decodeToUnicodeCodePoints) {
        let result = "";
        for (let i = start; i <= stop; i++) {
          result += String.fromCodePoint(this.data[i]);
        }
        return result;
      } else {
        return this.strdata.slice(start, stop + 1);
      }
    }
  }
  toString() {
    return this.strdata;
  }
  get index() {
    return this._index;
  }
  get size() {
    return this._size;
  }
}
module.exports = InputStream;

/***/ }),
/* 47 */
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

/* Copyright (c) 2012-2017 The ANTLR Project. All rights reserved.
 * Use of this file is governed by the BSD 3-clause license that
 * can be found in the LICENSE.txt file in the project root.
 */

const Token = (__webpack_require__(10).Token);
const BufferedTokenStream = __webpack_require__(48);

/**
 * This class extends {@link BufferedTokenStream} with functionality to filter
 * token streams to tokens on a particular channel (tokens where
 * {@link Token//getChannel} returns a particular value).
 *
 * <p>
 * This token stream provides access to all tokens by index or when calling
 * methods like {@link //getText}. The channel filtering is only used for code
 * accessing tokens via the lookahead methods {@link //LA}, {@link //LT}, and
 * {@link //LB}.</p>
 *
 * <p>
 * By default, tokens are placed on the default channel
 * ({@link Token//DEFAULT_CHANNEL}), but may be reassigned by using the
 * {@code ->channel(HIDDEN)} lexer command, or by using an embedded action to
 * call {@link Lexer//setChannel}.
 * </p>
 *
 * <p>
 * Note: lexer rules which use the {@code ->skip} lexer command or call
 * {@link Lexer//skip} do not produce tokens at all, so input text matched by
 * such a rule will not be available as part of the token stream, regardless of
 * channel.</p>
 */
class CommonTokenStream extends BufferedTokenStream {
  constructor(lexer, channel) {
    super(lexer);
    this.channel = channel === undefined ? Token.DEFAULT_CHANNEL : channel;
  }
  adjustSeekIndex(i) {
    return this.nextTokenOnChannel(i, this.channel);
  }
  LB(k) {
    if (k === 0 || this.index - k < 0) {
      return null;
    }
    let i = this.index;
    let n = 1;
    // find k good tokens looking backwards
    while (n <= k) {
      // skip off-channel tokens
      i = this.previousTokenOnChannel(i - 1, this.channel);
      n += 1;
    }
    if (i < 0) {
      return null;
    }
    return this.tokens[i];
  }
  LT(k) {
    this.lazyInit();
    if (k === 0) {
      return null;
    }
    if (k < 0) {
      return this.LB(-k);
    }
    let i = this.index;
    let n = 1; // we know tokens[pos] is a good one
    // find k good tokens
    while (n < k) {
      // skip off-channel tokens, but make sure to not look past EOF
      if (this.sync(i + 1)) {
        i = this.nextTokenOnChannel(i + 1, this.channel);
      }
      n += 1;
    }
    return this.tokens[i];
  }

  // Count EOF just once.
  getNumberOfOnChannelTokens() {
    let n = 0;
    this.fill();
    for (let i = 0; i < this.tokens.length; i++) {
      const t = this.tokens[i];
      if (t.channel === this.channel) {
        n += 1;
      }
      if (t.type === Token.EOF) {
        break;
      }
    }
    return n;
  }
}
module.exports = CommonTokenStream;

/***/ }),
/* 48 */
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

/* Copyright (c) 2012-2017 The ANTLR Project. All rights reserved.
 * Use of this file is governed by the BSD 3-clause license that
 * can be found in the LICENSE.txt file in the project root.
 */

const {
  Token
} = __webpack_require__(10);
const Lexer = __webpack_require__(25);
const {
  Interval
} = __webpack_require__(14);

// this is just to keep meaningful parameter types to Parser
class TokenStream {}

/**
 * This implementation of {@link TokenStream} loads tokens from a
 * {@link TokenSource} on-demand, and places the tokens in a buffer to provide
 * access to any previous token by index.
 *
 * <p>
 * This token stream ignores the value of {@link Token//getChannel}. If your
 * parser requires the token stream filter tokens to only those on a particular
 * channel, such as {@link Token//DEFAULT_CHANNEL} or
 * {@link Token//HIDDEN_CHANNEL}, use a filtering token stream such a
 * {@link CommonTokenStream}.</p>
 */
class BufferedTokenStream extends TokenStream {
  constructor(tokenSource) {
    super();
    // The {@link TokenSource} from which tokens for this stream are fetched.
    this.tokenSource = tokenSource;
    /**
     * A collection of all tokens fetched from the token source. The list is
     * considered a complete view of the input once {@link //fetchedEOF} is set
     * to {@code true}.
     */
    this.tokens = [];

    /**
     * The index into {@link //tokens} of the current token (next token to
     * {@link //consume}). {@link //tokens}{@code [}{@link //p}{@code ]} should
     * be
     * {@link //LT LT(1)}.
     *
     * <p>This field is set to -1 when the stream is first constructed or when
     * {@link //setTokenSource} is called, indicating that the first token has
     * not yet been fetched from the token source. For additional information,
     * see the documentation of {@link IntStream} for a description of
     * Initializing Methods.</p>
     */
    this.index = -1;

    /**
     * Indicates whether the {@link Token//EOF} token has been fetched from
     * {@link //tokenSource} and added to {@link //tokens}. This field improves
     * performance for the following cases:
     *
     * <ul>
     * <li>{@link //consume}: The lookahead check in {@link //consume} to
     * prevent
     * consuming the EOF symbol is optimized by checking the values of
     * {@link //fetchedEOF} and {@link //p} instead of calling {@link
     * //LA}.</li>
     * <li>{@link //fetch}: The check to prevent adding multiple EOF symbols
     * into
     * {@link //tokens} is trivial with this field.</li>
     * <ul>
     */
    this.fetchedEOF = false;
  }
  mark() {
    return 0;
  }
  release(marker) {
    // no resources to release
  }
  reset() {
    this.seek(0);
  }
  seek(index) {
    this.lazyInit();
    this.index = this.adjustSeekIndex(index);
  }
  get(index) {
    this.lazyInit();
    return this.tokens[index];
  }
  consume() {
    let skipEofCheck = false;
    if (this.index >= 0) {
      if (this.fetchedEOF) {
        // the last token in tokens is EOF. skip check if p indexes any
        // fetched token except the last.
        skipEofCheck = this.index < this.tokens.length - 1;
      } else {
        // no EOF token in tokens. skip check if p indexes a fetched token.
        skipEofCheck = this.index < this.tokens.length;
      }
    } else {
      // not yet initialized
      skipEofCheck = false;
    }
    if (!skipEofCheck && this.LA(1) === Token.EOF) {
      throw "cannot consume EOF";
    }
    if (this.sync(this.index + 1)) {
      this.index = this.adjustSeekIndex(this.index + 1);
    }
  }

  /**
   * Make sure index {@code i} in tokens has a token.
   *
   * @return {Boolean} {@code true} if a token is located at index {@code i}, otherwise
   * {@code false}.
   * @see //get(int i)
   */
  sync(i) {
    const n = i - this.tokens.length + 1; // how many more elements we need?
    if (n > 0) {
      const fetched = this.fetch(n);
      return fetched >= n;
    }
    return true;
  }

  /**
   * Add {@code n} elements to buffer.
   *
   * @return {Number} The actual number of elements added to the buffer.
   */
  fetch(n) {
    if (this.fetchedEOF) {
      return 0;
    }
    for (let i = 0; i < n; i++) {
      const t = this.tokenSource.nextToken();
      t.tokenIndex = this.tokens.length;
      this.tokens.push(t);
      if (t.type === Token.EOF) {
        this.fetchedEOF = true;
        return i + 1;
      }
    }
    return n;
  }

  // Get all tokens from start..stop inclusively///
  getTokens(start, stop, types) {
    if (types === undefined) {
      types = null;
    }
    if (start < 0 || stop < 0) {
      return null;
    }
    this.lazyInit();
    const subset = [];
    if (stop >= this.tokens.length) {
      stop = this.tokens.length - 1;
    }
    for (let i = start; i < stop; i++) {
      const t = this.tokens[i];
      if (t.type === Token.EOF) {
        break;
      }
      if (types === null || types.contains(t.type)) {
        subset.push(t);
      }
    }
    return subset;
  }
  LA(i) {
    return this.LT(i).type;
  }
  LB(k) {
    if (this.index - k < 0) {
      return null;
    }
    return this.tokens[this.index - k];
  }
  LT(k) {
    this.lazyInit();
    if (k === 0) {
      return null;
    }
    if (k < 0) {
      return this.LB(-k);
    }
    const i = this.index + k - 1;
    this.sync(i);
    if (i >= this.tokens.length) {
      // return EOF token
      // EOF must be last token
      return this.tokens[this.tokens.length - 1];
    }
    return this.tokens[i];
  }

  /**
   * Allowed derived classes to modify the behavior of operations which change
   * the current stream position by adjusting the target token index of a seek
   * operation. The default implementation simply returns {@code i}. If an
   * exception is thrown in this method, the current stream index should not be
   * changed.
   *
   * <p>For example, {@link CommonTokenStream} overrides this method to ensure
   * that
   * the seek target is always an on-channel token.</p>
   *
   * @param {Number} i The target token index.
   * @return {Number} The adjusted target token index.
   */
  adjustSeekIndex(i) {
    return i;
  }
  lazyInit() {
    if (this.index === -1) {
      this.setup();
    }
  }
  setup() {
    this.sync(0);
    this.index = this.adjustSeekIndex(0);
  }

  // Reset this token stream by setting its token source.///
  setTokenSource(tokenSource) {
    this.tokenSource = tokenSource;
    this.tokens = [];
    this.index = -1;
    this.fetchedEOF = false;
  }

  /**
   * Given a starting index, return the index of the next token on channel.
   * Return i if tokens[i] is on channel. Return -1 if there are no tokens
   * on channel between i and EOF.
   */
  nextTokenOnChannel(i, channel) {
    this.sync(i);
    if (i >= this.tokens.length) {
      return -1;
    }
    let token = this.tokens[i];
    while (token.channel !== this.channel) {
      if (token.type === Token.EOF) {
        return -1;
      }
      i += 1;
      this.sync(i);
      token = this.tokens[i];
    }
    return i;
  }

  /**
   * Given a starting index, return the index of the previous token on channel.
   * Return i if tokens[i] is on channel. Return -1 if there are no tokens
   * on channel between i and 0.
   */
  previousTokenOnChannel(i, channel) {
    while (i >= 0 && this.tokens[i].channel !== channel) {
      i -= 1;
    }
    return i;
  }

  /**
   * Collect all tokens on specified channel to the right of
   * the current token up until we see a token on DEFAULT_TOKEN_CHANNEL or
   * EOF. If channel is -1, find any non default channel token.
   */
  getHiddenTokensToRight(tokenIndex, channel) {
    if (channel === undefined) {
      channel = -1;
    }
    this.lazyInit();
    if (tokenIndex < 0 || tokenIndex >= this.tokens.length) {
      throw "" + tokenIndex + " not in 0.." + this.tokens.length - 1;
    }
    const nextOnChannel = this.nextTokenOnChannel(tokenIndex + 1, Lexer.DEFAULT_TOKEN_CHANNEL);
    const from_ = tokenIndex + 1;
    // if none onchannel to right, nextOnChannel=-1 so set to = last token
    const to = nextOnChannel === -1 ? this.tokens.length - 1 : nextOnChannel;
    return this.filterForChannel(from_, to, channel);
  }

  /**
   * Collect all tokens on specified channel to the left of
   * the current token up until we see a token on DEFAULT_TOKEN_CHANNEL.
   * If channel is -1, find any non default channel token.
   */
  getHiddenTokensToLeft(tokenIndex, channel) {
    if (channel === undefined) {
      channel = -1;
    }
    this.lazyInit();
    if (tokenIndex < 0 || tokenIndex >= this.tokens.length) {
      throw "" + tokenIndex + " not in 0.." + this.tokens.length - 1;
    }
    const prevOnChannel = this.previousTokenOnChannel(tokenIndex - 1, Lexer.DEFAULT_TOKEN_CHANNEL);
    if (prevOnChannel === tokenIndex - 1) {
      return null;
    }
    // if none on channel to left, prevOnChannel=-1 then from=0
    const from_ = prevOnChannel + 1;
    const to = tokenIndex - 1;
    return this.filterForChannel(from_, to, channel);
  }
  filterForChannel(left, right, channel) {
    const hidden = [];
    for (let i = left; i < right + 1; i++) {
      const t = this.tokens[i];
      if (channel === -1) {
        if (t.channel !== Lexer.DEFAULT_TOKEN_CHANNEL) {
          hidden.push(t);
        }
      } else if (t.channel === channel) {
        hidden.push(t);
      }
    }
    if (hidden.length === 0) {
      return null;
    }
    return hidden;
  }
  getSourceName() {
    return this.tokenSource.getSourceName();
  }

  // Get the text of all tokens in this buffer.///
  getText(interval) {
    this.lazyInit();
    this.fill();
    if (interval === undefined || interval === null) {
      interval = new Interval(0, this.tokens.length - 1);
    }
    let start = interval.start;
    if (start instanceof Token) {
      start = start.tokenIndex;
    }
    let stop = interval.stop;
    if (stop instanceof Token) {
      stop = stop.tokenIndex;
    }
    if (start === null || stop === null || start < 0 || stop < 0) {
      return "";
    }
    if (stop >= this.tokens.length) {
      stop = this.tokens.length - 1;
    }
    let s = "";
    for (let i = start; i < stop + 1; i++) {
      const t = this.tokens[i];
      if (t.type === Token.EOF) {
        break;
      }
      s = s + t.text;
    }
    return s;
  }

  // Get all tokens from lexer until EOF///
  fill() {
    this.lazyInit();
    while (this.fetch(1000) === 1000) {
      continue;
    }
  }
}
module.exports = BufferedTokenStream;

/***/ }),
/* 49 */
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

/* Copyright (c) 2012-2017 The ANTLR Project. All rights reserved.
 * Use of this file is governed by the BSD 3-clause license that
 * can be found in the LICENSE.txt file in the project root.
 */

const {
  Token
} = __webpack_require__(10);
const {
  ParseTreeListener,
  TerminalNode,
  ErrorNode
} = __webpack_require__(18);
const Recognizer = __webpack_require__(26);
const {
  DefaultErrorStrategy
} = __webpack_require__(45);
const ATNDeserializer = __webpack_require__(20);
const ATNDeserializationOptions = __webpack_require__(22);
const Lexer = __webpack_require__(25);
class TraceListener extends ParseTreeListener {
  constructor(parser) {
    super();
    this.parser = parser;
  }
  enterEveryRule(ctx) {
    console.log("enter   " + this.parser.ruleNames[ctx.ruleIndex] + ", LT(1)=" + this.parser._input.LT(1).text);
  }
  visitTerminal(node) {
    console.log("consume " + node.symbol + " rule " + this.parser.ruleNames[this.parser._ctx.ruleIndex]);
  }
  exitEveryRule(ctx) {
    console.log("exit    " + this.parser.ruleNames[ctx.ruleIndex] + ", LT(1)=" + this.parser._input.LT(1).text);
  }
}
class Parser extends Recognizer {
  /**
   * this is all the parsing support code essentially; most of it is error
   * recovery stuff.
   */
  constructor(input) {
    super();
    // The input stream.
    this._input = null;
    /**
     * The error handling strategy for the parser. The default value is a new
     * instance of {@link DefaultErrorStrategy}.
     */
    this._errHandler = new DefaultErrorStrategy();
    this._precedenceStack = [];
    this._precedenceStack.push(0);
    /**
     * The {@link ParserRuleContext} object for the currently executing rule.
     * this is always non-null during the parsing process.
     */
    this._ctx = null;
    /**
     * Specifies whether or not the parser should construct a parse tree during
     * the parsing process. The default value is {@code true}.
     */
    this.buildParseTrees = true;
    /**
     * When {@link //setTrace}{@code (true)} is called, a reference to the
     * {@link TraceListener} is stored here so it can be easily removed in a
     * later call to {@link //setTrace}{@code (false)}. The listener itself is
     * implemented as a parser listener so this field is not directly used by
     * other parser methods.
     */
    this._tracer = null;
    /**
     * The list of {@link ParseTreeListener} listeners registered to receive
     * events during the parse.
     */
    this._parseListeners = null;
    /**
     * The number of syntax errors reported during parsing. this value is
     * incremented each time {@link //notifyErrorListeners} is called.
     */
    this._syntaxErrors = 0;
    this.setInputStream(input);
  }

  // reset the parser's state
  reset() {
    if (this._input !== null) {
      this._input.seek(0);
    }
    this._errHandler.reset(this);
    this._ctx = null;
    this._syntaxErrors = 0;
    this.setTrace(false);
    this._precedenceStack = [];
    this._precedenceStack.push(0);
    if (this._interp !== null) {
      this._interp.reset();
    }
  }

  /**
   * Match current input symbol against {@code ttype}. If the symbol type
   * matches, {@link ANTLRErrorStrategy//reportMatch} and {@link //consume} are
   * called to complete the match process.
   *
   * <p>If the symbol type does not match,
   * {@link ANTLRErrorStrategy//recoverInline} is called on the current error
   * strategy to attempt recovery. If {@link //getBuildParseTree} is
   * {@code true} and the token index of the symbol returned by
   * {@link ANTLRErrorStrategy//recoverInline} is -1, the symbol is added to
   * the parse tree by calling {@link ParserRuleContext//addErrorNode}.</p>
   *
   * @param ttype the token type to match
   * @return the matched symbol
   * @throws RecognitionException if the current input symbol did not match
   * {@code ttype} and the error strategy could not recover from the
   * mismatched symbol
   */
  match(ttype) {
    let t = this.getCurrentToken();
    if (t.type === ttype) {
      this._errHandler.reportMatch(this);
      this.consume();
    } else {
      t = this._errHandler.recoverInline(this);
      if (this.buildParseTrees && t.tokenIndex === -1) {
        // we must have conjured up a new token during single token
        // insertion
        // if it's not the current symbol
        this._ctx.addErrorNode(t);
      }
    }
    return t;
  }

  /**
   * Match current input symbol as a wildcard. If the symbol type matches
   * (i.e. has a value greater than 0), {@link ANTLRErrorStrategy//reportMatch}
   * and {@link //consume} are called to complete the match process.
   *
   * <p>If the symbol type does not match,
   * {@link ANTLRErrorStrategy//recoverInline} is called on the current error
   * strategy to attempt recovery. If {@link //getBuildParseTree} is
   * {@code true} and the token index of the symbol returned by
   * {@link ANTLRErrorStrategy//recoverInline} is -1, the symbol is added to
   * the parse tree by calling {@link ParserRuleContext//addErrorNode}.</p>
   *
   * @return the matched symbol
   * @throws RecognitionException if the current input symbol did not match
   * a wildcard and the error strategy could not recover from the mismatched
   * symbol
   */
  matchWildcard() {
    let t = this.getCurrentToken();
    if (t.type > 0) {
      this._errHandler.reportMatch(this);
      this.consume();
    } else {
      t = this._errHandler.recoverInline(this);
      if (this._buildParseTrees && t.tokenIndex === -1) {
        // we must have conjured up a new token during single token
        // insertion
        // if it's not the current symbol
        this._ctx.addErrorNode(t);
      }
    }
    return t;
  }
  getParseListeners() {
    return this._parseListeners || [];
  }

  /**
   * Registers {@code listener} to receive events during the parsing process.
   *
   * <p>To support output-preserving grammar transformations (including but not
   * limited to left-recursion removal, automated left-factoring, and
   * optimized code generation), calls to listener methods during the parse
   * may differ substantially from calls made by
   * {@link ParseTreeWalker//DEFAULT} used after the parse is complete. In
   * particular, rule entry and exit events may occur in a different order
   * during the parse than after the parser. In addition, calls to certain
   * rule entry methods may be omitted.</p>
   *
   * <p>With the following specific exceptions, calls to listener events are
   * <em>deterministic</em>, i.e. for identical input the calls to listener
   * methods will be the same.</p>
   *
   * <ul>
   * <li>Alterations to the grammar used to generate code may change the
   * behavior of the listener calls.</li>
   * <li>Alterations to the command line options passed to ANTLR 4 when
   * generating the parser may change the behavior of the listener calls.</li>
   * <li>Changing the version of the ANTLR Tool used to generate the parser
   * may change the behavior of the listener calls.</li>
   * </ul>
   *
   * @param listener the listener to add
   *
   * @throws NullPointerException if {@code} listener is {@code null}
   */
  addParseListener(listener) {
    if (listener === null) {
      throw "listener";
    }
    if (this._parseListeners === null) {
      this._parseListeners = [];
    }
    this._parseListeners.push(listener);
  }

  /**
   * Remove {@code listener} from the list of parse listeners.
   *
   * <p>If {@code listener} is {@code null} or has not been added as a parse
   * listener, this method does nothing.</p>
   * @param listener the listener to remove
   */
  removeParseListener(listener) {
    if (this._parseListeners !== null) {
      const idx = this._parseListeners.indexOf(listener);
      if (idx >= 0) {
        this._parseListeners.splice(idx, 1);
      }
      if (this._parseListeners.length === 0) {
        this._parseListeners = null;
      }
    }
  }

  // Remove all parse listeners.
  removeParseListeners() {
    this._parseListeners = null;
  }

  // Notify any parse listeners of an enter rule event.
  triggerEnterRuleEvent() {
    if (this._parseListeners !== null) {
      const ctx = this._ctx;
      this._parseListeners.forEach(function (listener) {
        listener.enterEveryRule(ctx);
        ctx.enterRule(listener);
      });
    }
  }

  /**
   * Notify any parse listeners of an exit rule event.
   * @see //addParseListener
   */
  triggerExitRuleEvent() {
    if (this._parseListeners !== null) {
      // reverse order walk of listeners
      const ctx = this._ctx;
      this._parseListeners.slice(0).reverse().forEach(function (listener) {
        ctx.exitRule(listener);
        listener.exitEveryRule(ctx);
      });
    }
  }
  getTokenFactory() {
    return this._input.tokenSource._factory;
  }

  // Tell our token source and error strategy about a new way to create tokens.
  setTokenFactory(factory) {
    this._input.tokenSource._factory = factory;
  }

  /**
   * The ATN with bypass alternatives is expensive to create so we create it
   * lazily.
   *
   * @throws UnsupportedOperationException if the current parser does not
   * implement the {@link //getSerializedATN()} method.
   */
  getATNWithBypassAlts() {
    const serializedAtn = this.getSerializedATN();
    if (serializedAtn === null) {
      throw "The current parser does not support an ATN with bypass alternatives.";
    }
    let result = this.bypassAltsAtnCache[serializedAtn];
    if (result === null) {
      const deserializationOptions = new ATNDeserializationOptions();
      deserializationOptions.generateRuleBypassTransitions = true;
      result = new ATNDeserializer(deserializationOptions).deserialize(serializedAtn);
      this.bypassAltsAtnCache[serializedAtn] = result;
    }
    return result;
  }

  /**
   * The preferred method of getting a tree pattern. For example, here's a
   * sample use:
   *
   * <pre>
   * ParseTree t = parser.expr();
   * ParseTreePattern p = parser.compileParseTreePattern("&lt;ID&gt;+0",
   * MyParser.RULE_expr);
   * ParseTreeMatch m = p.match(t);
   * String id = m.get("ID");
   * </pre>
   */
  compileParseTreePattern(pattern, patternRuleIndex, lexer) {
    lexer = lexer || null;
    if (lexer === null) {
      if (this.getTokenStream() !== null) {
        const tokenSource = this.getTokenStream().tokenSource;
        if (tokenSource instanceof Lexer) {
          lexer = tokenSource;
        }
      }
    }
    if (lexer === null) {
      throw "Parser can't discover a lexer to use";
    }
    const m = new ParseTreePatternMatcher(lexer, this);
    return m.compile(pattern, patternRuleIndex);
  }
  getInputStream() {
    return this.getTokenStream();
  }
  setInputStream(input) {
    this.setTokenStream(input);
  }
  getTokenStream() {
    return this._input;
  }

  // Set the token stream and reset the parser.
  setTokenStream(input) {
    this._input = null;
    this.reset();
    this._input = input;
  }

  /**
   * Match needs to return the current input symbol, which gets put
   * into the label for the associated token ref; e.g., x=ID.
   */
  getCurrentToken() {
    return this._input.LT(1);
  }
  notifyErrorListeners(msg, offendingToken, err) {
    offendingToken = offendingToken || null;
    err = err || null;
    if (offendingToken === null) {
      offendingToken = this.getCurrentToken();
    }
    this._syntaxErrors += 1;
    const line = offendingToken.line;
    const column = offendingToken.column;
    const listener = this.getErrorListenerDispatch();
    listener.syntaxError(this, offendingToken, line, column, msg, err);
  }

  /**
   * Consume and return the {@linkplain //getCurrentToken current symbol}.
   *
   * <p>E.g., given the following input with {@code A} being the current
   * lookahead symbol, this function moves the cursor to {@code B} and returns
   * {@code A}.</p>
   *
   * <pre>
   * A B
   * ^
   * </pre>
   *
   * If the parser is not in error recovery mode, the consumed symbol is added
   * to the parse tree using {@link ParserRuleContext//addChild(Token)}, and
   * {@link ParseTreeListener//visitTerminal} is called on any parse listeners.
   * If the parser <em>is</em> in error recovery mode, the consumed symbol is
   * added to the parse tree using
   * {@link ParserRuleContext//addErrorNode(Token)}, and
   * {@link ParseTreeListener//visitErrorNode} is called on any parse
   * listeners.
   */
  consume() {
    const o = this.getCurrentToken();
    if (o.type !== Token.EOF) {
      this.getInputStream().consume();
    }
    const hasListener = this._parseListeners !== null && this._parseListeners.length > 0;
    if (this.buildParseTrees || hasListener) {
      let node;
      if (this._errHandler.inErrorRecoveryMode(this)) {
        node = this._ctx.addErrorNode(o);
      } else {
        node = this._ctx.addTokenNode(o);
      }
      node.invokingState = this.state;
      if (hasListener) {
        this._parseListeners.forEach(function (listener) {
          if (node instanceof ErrorNode || node.isErrorNode !== undefined && node.isErrorNode()) {
            listener.visitErrorNode(node);
          } else if (node instanceof TerminalNode) {
            listener.visitTerminal(node);
          }
        });
      }
    }
    return o;
  }
  addContextToParseTree() {
    // add current context to parent if we have a parent
    if (this._ctx.parentCtx !== null) {
      this._ctx.parentCtx.addChild(this._ctx);
    }
  }

  /**
   * Always called by generated parsers upon entry to a rule. Access field
   * {@link //_ctx} get the current context.
   */
  enterRule(localctx, state, ruleIndex) {
    this.state = state;
    this._ctx = localctx;
    this._ctx.start = this._input.LT(1);
    if (this.buildParseTrees) {
      this.addContextToParseTree();
    }
    this.triggerEnterRuleEvent();
  }
  exitRule() {
    this._ctx.stop = this._input.LT(-1);
    // trigger event on _ctx, before it reverts to parent
    this.triggerExitRuleEvent();
    this.state = this._ctx.invokingState;
    this._ctx = this._ctx.parentCtx;
  }
  enterOuterAlt(localctx, altNum) {
    localctx.setAltNumber(altNum);
    // if we have new localctx, make sure we replace existing ctx
    // that is previous child of parse tree
    if (this.buildParseTrees && this._ctx !== localctx) {
      if (this._ctx.parentCtx !== null) {
        this._ctx.parentCtx.removeLastChild();
        this._ctx.parentCtx.addChild(localctx);
      }
    }
    this._ctx = localctx;
  }

  /**
   * Get the precedence level for the top-most precedence rule.
   *
   * @return The precedence level for the top-most precedence rule, or -1 if
   * the parser context is not nested within a precedence rule.
   */
  getPrecedence() {
    if (this._precedenceStack.length === 0) {
      return -1;
    } else {
      return this._precedenceStack[this._precedenceStack.length - 1];
    }
  }
  enterRecursionRule(localctx, state, ruleIndex, precedence) {
    this.state = state;
    this._precedenceStack.push(precedence);
    this._ctx = localctx;
    this._ctx.start = this._input.LT(1);
    this.triggerEnterRuleEvent(); // simulates rule entry for left-recursive rules
  }

  // Like {@link //enterRule} but for recursive rules.
  pushNewRecursionContext(localctx, state, ruleIndex) {
    const previous = this._ctx;
    previous.parentCtx = localctx;
    previous.invokingState = state;
    previous.stop = this._input.LT(-1);
    this._ctx = localctx;
    this._ctx.start = previous.start;
    if (this.buildParseTrees) {
      this._ctx.addChild(previous);
    }
    this.triggerEnterRuleEvent(); // simulates rule entry for left-recursive rules
  }
  unrollRecursionContexts(parentCtx) {
    this._precedenceStack.pop();
    this._ctx.stop = this._input.LT(-1);
    const retCtx = this._ctx; // save current ctx (return value)
    // unroll so _ctx is as it was before call to recursive method
    const parseListeners = this.getParseListeners();
    if (parseListeners !== null && parseListeners.length > 0) {
      while (this._ctx !== parentCtx) {
        this.triggerExitRuleEvent();
        this._ctx = this._ctx.parentCtx;
      }
    } else {
      this._ctx = parentCtx;
    }
    // hook into tree
    retCtx.parentCtx = parentCtx;
    if (this.buildParseTrees && parentCtx !== null) {
      // add return ctx into invoking rule's tree
      parentCtx.addChild(retCtx);
    }
  }
  getInvokingContext(ruleIndex) {
    let ctx = this._ctx;
    while (ctx !== null) {
      if (ctx.ruleIndex === ruleIndex) {
        return ctx;
      }
      ctx = ctx.parentCtx;
    }
    return null;
  }
  precpred(localctx, precedence) {
    return precedence >= this._precedenceStack[this._precedenceStack.length - 1];
  }
  inContext(context) {
    // TODO: useful in parser?
    return false;
  }

  /**
   * Checks whether or not {@code symbol} can follow the current state in the
   * ATN. The behavior of this method is equivalent to the following, but is
   * implemented such that the complete context-sensitive follow set does not
   * need to be explicitly constructed.
   *
   * <pre>
   * return getExpectedTokens().contains(symbol);
   * </pre>
   *
   * @param symbol the symbol type to check
   * @return {@code true} if {@code symbol} can follow the current state in
   * the ATN, otherwise {@code false}.
   */
  isExpectedToken(symbol) {
    const atn = this._interp.atn;
    let ctx = this._ctx;
    const s = atn.states[this.state];
    let following = atn.nextTokens(s);
    if (following.contains(symbol)) {
      return true;
    }
    if (!following.contains(Token.EPSILON)) {
      return false;
    }
    while (ctx !== null && ctx.invokingState >= 0 && following.contains(Token.EPSILON)) {
      const invokingState = atn.states[ctx.invokingState];
      const rt = invokingState.transitions[0];
      following = atn.nextTokens(rt.followState);
      if (following.contains(symbol)) {
        return true;
      }
      ctx = ctx.parentCtx;
    }
    if (following.contains(Token.EPSILON) && symbol === Token.EOF) {
      return true;
    } else {
      return false;
    }
  }

  /**
   * Computes the set of input symbols which could follow the current parser
   * state and context, as given by {@link //getState} and {@link //getContext},
   * respectively.
   *
   * @see ATN//getExpectedTokens(int, RuleContext)
   */
  getExpectedTokens() {
    return this._interp.atn.getExpectedTokens(this.state, this._ctx);
  }
  getExpectedTokensWithinCurrentRule() {
    const atn = this._interp.atn;
    const s = atn.states[this.state];
    return atn.nextTokens(s);
  }

  // Get a rule's index (i.e., {@code RULE_ruleName} field) or -1 if not found.
  getRuleIndex(ruleName) {
    const ruleIndex = this.getRuleIndexMap()[ruleName];
    if (ruleIndex !== null) {
      return ruleIndex;
    } else {
      return -1;
    }
  }

  /**
   * Return List&lt;String&gt; of the rule names in your parser instance
   * leading up to a call to the current rule. You could override if
   * you want more details such as the file/line info of where
   * in the ATN a rule is invoked.
   *
   * this is very useful for error messages.
   */
  getRuleInvocationStack(p) {
    p = p || null;
    if (p === null) {
      p = this._ctx;
    }
    const stack = [];
    while (p !== null) {
      // compute what follows who invoked us
      const ruleIndex = p.ruleIndex;
      if (ruleIndex < 0) {
        stack.push("n/a");
      } else {
        stack.push(this.ruleNames[ruleIndex]);
      }
      p = p.parentCtx;
    }
    return stack;
  }

  // For debugging and other purposes.
  getDFAStrings() {
    return this._interp.decisionToDFA.toString();
  }

  // For debugging and other purposes.
  dumpDFA() {
    let seenOne = false;
    for (let i = 0; i < this._interp.decisionToDFA.length; i++) {
      const dfa = this._interp.decisionToDFA[i];
      if (dfa.states.length > 0) {
        if (seenOne) {
          console.log();
        }
        this.printer.println("Decision " + dfa.decision + ":");
        this.printer.print(dfa.toString(this.literalNames, this.symbolicNames));
        seenOne = true;
      }
    }
  }

  /*
  	"			printer = function() {\r\n" +
  	"				this.println = function(s) { document.getElementById('output') += s + '\\n'; }\r\n" +
  	"				this.print = function(s) { document.getElementById('output') += s; }\r\n" +
  	"			};\r\n" +
  	*/
  getSourceName() {
    return this._input.sourceName;
  }

  /**
   * During a parse is sometimes useful to listen in on the rule entry and exit
   * events as well as token matches. this is for quick and dirty debugging.
   */
  setTrace(trace) {
    if (!trace) {
      this.removeParseListener(this._tracer);
      this._tracer = null;
    } else {
      if (this._tracer !== null) {
        this.removeParseListener(this._tracer);
      }
      this._tracer = new TraceListener(this);
      this.addParseListener(this._tracer);
    }
  }
}

/**
 * this field maps from the serialized ATN string to the deserialized {@link
 * ATN} with
 * bypass alternatives.
 *
 * @see ATNDeserializationOptions//isGenerateRuleBypassTransitions()
 */
Parser.bypassAltsAtnCache = {};
module.exports = Parser;

/***/ }),
/* 50 */
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

// Generated from FHIRPath.g4 by ANTLR 4.9.3
// jshint ignore: start
const antlr4 = __webpack_require__(5);
const serializedATN = ["\u0003\u608b\ua72a\u8133\ub9ed\u417c\u3be7\u7786", "\u5964\u0002A\u0203\b\u0001\u0004\u0002\t\u0002\u0004\u0003\t\u0003", "\u0004\u0004\t\u0004\u0004\u0005\t\u0005\u0004\u0006\t\u0006\u0004\u0007", "\t\u0007\u0004\b\t\b\u0004\t\t\t\u0004\n\t\n\u0004\u000b\t\u000b\u0004", "\f\t\f\u0004\r\t\r\u0004\u000e\t\u000e\u0004\u000f\t\u000f\u0004\u0010", "\t\u0010\u0004\u0011\t\u0011\u0004\u0012\t\u0012\u0004\u0013\t\u0013", "\u0004\u0014\t\u0014\u0004\u0015\t\u0015\u0004\u0016\t\u0016\u0004\u0017", "\t\u0017\u0004\u0018\t\u0018\u0004\u0019\t\u0019\u0004\u001a\t\u001a", "\u0004\u001b\t\u001b\u0004\u001c\t\u001c\u0004\u001d\t\u001d\u0004\u001e", "\t\u001e\u0004\u001f\t\u001f\u0004 \t \u0004!\t!\u0004\"\t\"\u0004#", "\t#\u0004$\t$\u0004%\t%\u0004&\t&\u0004\'\t\'\u0004(\t(\u0004)\t)\u0004", "*\t*\u0004+\t+\u0004,\t,\u0004-\t-\u0004.\t.\u0004/\t/\u00040\t0\u0004", "1\t1\u00042\t2\u00043\t3\u00044\t4\u00045\t5\u00046\t6\u00047\t7\u0004", "8\t8\u00049\t9\u0004:\t:\u0004;\t;\u0004<\t<\u0004=\t=\u0004>\t>\u0004", "?\t?\u0004@\t@\u0004A\tA\u0004B\tB\u0004C\tC\u0004D\tD\u0003\u0002\u0003", "\u0002\u0003\u0003\u0003\u0003\u0003\u0004\u0003\u0004\u0003\u0005\u0003", "\u0005\u0003\u0006\u0003\u0006\u0003\u0007\u0003\u0007\u0003\b\u0003", "\b\u0003\t\u0003\t\u0003\t\u0003\t\u0003\n\u0003\n\u0003\n\u0003\n\u0003", "\u000b\u0003\u000b\u0003\f\u0003\f\u0003\r\u0003\r\u0003\r\u0003\u000e", "\u0003\u000e\u0003\u000f\u0003\u000f\u0003\u0010\u0003\u0010\u0003\u0010", "\u0003\u0011\u0003\u0011\u0003\u0011\u0003\u0012\u0003\u0012\u0003\u0012", "\u0003\u0013\u0003\u0013\u0003\u0014\u0003\u0014\u0003\u0015\u0003\u0015", "\u0003\u0015\u0003\u0016\u0003\u0016\u0003\u0016\u0003\u0017\u0003\u0017", "\u0003\u0017\u0003\u0018\u0003\u0018\u0003\u0018\u0003\u0018\u0003\u0018", "\u0003\u0018\u0003\u0018\u0003\u0018\u0003\u0018\u0003\u0019\u0003\u0019", "\u0003\u0019\u0003\u0019\u0003\u001a\u0003\u001a\u0003\u001a\u0003\u001b", "\u0003\u001b\u0003\u001b\u0003\u001b\u0003\u001c\u0003\u001c\u0003\u001c", "\u0003\u001c\u0003\u001c\u0003\u001c\u0003\u001c\u0003\u001c\u0003\u001d", "\u0003\u001d\u0003\u001e\u0003\u001e\u0003\u001f\u0003\u001f\u0003 ", "\u0003 \u0003!\u0003!\u0003!\u0003!\u0003!\u0003\"\u0003\"\u0003\"\u0003", "\"\u0003\"\u0003\"\u0003#\u0003#\u0003$\u0003$\u0003$\u0003$\u0003$", "\u0003$\u0003%\u0003%\u0003%\u0003%\u0003%\u0003%\u0003%\u0003&\u0003", "&\u0003&\u0003&\u0003&\u0003&\u0003&\u0003\'\u0003\'\u0003(\u0003(\u0003", "(\u0003(\u0003(\u0003)\u0003)\u0003)\u0003)\u0003)\u0003)\u0003*\u0003", "*\u0003*\u0003*\u0003*\u0003+\u0003+\u0003+\u0003+\u0003,\u0003,\u0003", ",\u0003,\u0003,\u0003-\u0003-\u0003-\u0003-\u0003-\u0003-\u0003-\u0003", ".\u0003.\u0003.\u0003.\u0003.\u0003.\u0003.\u0003/\u0003/\u0003/\u0003", "/\u0003/\u0003/\u0003/\u0003/\u0003/\u0003/\u0003/\u0003/\u00030\u0003", "0\u00030\u00030\u00030\u00030\u00031\u00031\u00031\u00031\u00031\u0003", "1\u00031\u00032\u00032\u00032\u00032\u00032\u00032\u00033\u00033\u0003", "3\u00033\u00033\u00034\u00034\u00034\u00034\u00034\u00034\u00035\u0003", "5\u00035\u00035\u00035\u00035\u00035\u00035\u00036\u00036\u00036\u0003", "6\u00036\u00036\u00036\u00036\u00037\u00037\u00037\u00037\u00037\u0003", "7\u00037\u00037\u00037\u00037\u00037\u00037\u00037\u00038\u00038\u0003", "8\u00038\u00038\u00038\u00038\u00038\u00038\u00038\u00038\u00038\u0003", "8\u00058\u0183\n8\u00058\u0185\n8\u00058\u0187\n8\u00038\u00058\u018a", "\n8\u00039\u00039\u00039\u00039\u0003:\u0003:\u0003:\u0003:\u0003:\u0003", ":\u0003:\u0003:\u0003:\u0003:\u0006:\u019a\n:\r:\u000e:\u019b\u0005", ":\u019e\n:\u0005:\u01a0\n:\u0005:\u01a2\n:\u0003:\u0003:\u0003:\u0003", ":\u0003:\u0003:\u0003:\u0005:\u01ab\n:\u0003;\u0005;\u01ae\n;\u0003", ";\u0007;\u01b1\n;\f;\u000e;\u01b4\u000b;\u0003<\u0003<\u0003<\u0007", "<\u01b9\n<\f<\u000e<\u01bc\u000b<\u0003<\u0003<\u0003=\u0003=\u0003", "=\u0007=\u01c3\n=\f=\u000e=\u01c6\u000b=\u0003=\u0003=\u0003>\u0006", ">\u01cb\n>\r>\u000e>\u01cc\u0003>\u0003>\u0006>\u01d1\n>\r>\u000e>\u01d2", "\u0005>\u01d5\n>\u0003?\u0006?\u01d8\n?\r?\u000e?\u01d9\u0003?\u0003", "?\u0003@\u0003@\u0003@\u0003@\u0007@\u01e2\n@\f@\u000e@\u01e5\u000b", "@\u0003@\u0003@\u0003@\u0003@\u0003@\u0003A\u0003A\u0003A\u0003A\u0007", "A\u01f0\nA\fA\u000eA\u01f3\u000bA\u0003A\u0003A\u0003B\u0003B\u0003", "B\u0005B\u01fa\nB\u0003C\u0003C\u0003C\u0003C\u0003C\u0003C\u0003D\u0003", "D\u0003\u01e3\u0002E\u0003\u0003\u0005\u0004\u0007\u0005\t\u0006\u000b", "\u0007\r\b\u000f\t\u0011\n\u0013\u000b\u0015\f\u0017\r\u0019\u000e\u001b", "\u000f\u001d\u0010\u001f\u0011!\u0012#\u0013%\u0014\'\u0015)\u0016+", "\u0017-\u0018/\u00191\u001a3\u001b5\u001c7\u001d9\u001e;\u001f= ?!A", "\"C#E$G%I&K\'M(O)Q*S+U,W-Y.[/]0_1a2c3e4g5i6k7m8o9q:s\u0002u;w<y={>}", "?\u007f@\u0081A\u0083\u0002\u0085\u0002\u0087\u0002\u0003\u0002\f\u0003", "\u00022;\u0004\u0002--//\u0005\u0002C\\aac|\u0006\u00022;C\\aac|\u0004", "\u0002^^bb\u0003\u0002))\u0005\u0002\u000b\f\u000f\u000f\"\"\u0004\u0002", "\f\f\u000f\u000f\n\u0002))11^^bbhhppttvv\u0005\u00022;CHch\u0002\u0214", "\u0002\u0003\u0003\u0002\u0002\u0002\u0002\u0005\u0003\u0002\u0002\u0002", "\u0002\u0007\u0003\u0002\u0002\u0002\u0002\t\u0003\u0002\u0002\u0002", "\u0002\u000b\u0003\u0002\u0002\u0002\u0002\r\u0003\u0002\u0002\u0002", "\u0002\u000f\u0003\u0002\u0002\u0002\u0002\u0011\u0003\u0002\u0002\u0002", "\u0002\u0013\u0003\u0002\u0002\u0002\u0002\u0015\u0003\u0002\u0002\u0002", "\u0002\u0017\u0003\u0002\u0002\u0002\u0002\u0019\u0003\u0002\u0002\u0002", "\u0002\u001b\u0003\u0002\u0002\u0002\u0002\u001d\u0003\u0002\u0002\u0002", "\u0002\u001f\u0003\u0002\u0002\u0002\u0002!\u0003\u0002\u0002\u0002", "\u0002#\u0003\u0002\u0002\u0002\u0002%\u0003\u0002\u0002\u0002\u0002", "\'\u0003\u0002\u0002\u0002\u0002)\u0003\u0002\u0002\u0002\u0002+\u0003", "\u0002\u0002\u0002\u0002-\u0003\u0002\u0002\u0002\u0002/\u0003\u0002", "\u0002\u0002\u00021\u0003\u0002\u0002\u0002\u00023\u0003\u0002\u0002", "\u0002\u00025\u0003\u0002\u0002\u0002\u00027\u0003\u0002\u0002\u0002", "\u00029\u0003\u0002\u0002\u0002\u0002;\u0003\u0002\u0002\u0002\u0002", "=\u0003\u0002\u0002\u0002\u0002?\u0003\u0002\u0002\u0002\u0002A\u0003", "\u0002\u0002\u0002\u0002C\u0003\u0002\u0002\u0002\u0002E\u0003\u0002", "\u0002\u0002\u0002G\u0003\u0002\u0002\u0002\u0002I\u0003\u0002\u0002", "\u0002\u0002K\u0003\u0002\u0002\u0002\u0002M\u0003\u0002\u0002\u0002", "\u0002O\u0003\u0002\u0002\u0002\u0002Q\u0003\u0002\u0002\u0002\u0002", "S\u0003\u0002\u0002\u0002\u0002U\u0003\u0002\u0002\u0002\u0002W\u0003", "\u0002\u0002\u0002\u0002Y\u0003\u0002\u0002\u0002\u0002[\u0003\u0002", "\u0002\u0002\u0002]\u0003\u0002\u0002\u0002\u0002_\u0003\u0002\u0002", "\u0002\u0002a\u0003\u0002\u0002\u0002\u0002c\u0003\u0002\u0002\u0002", "\u0002e\u0003\u0002\u0002\u0002\u0002g\u0003\u0002\u0002\u0002\u0002", "i\u0003\u0002\u0002\u0002\u0002k\u0003\u0002\u0002\u0002\u0002m\u0003", "\u0002\u0002\u0002\u0002o\u0003\u0002\u0002\u0002\u0002q\u0003\u0002", "\u0002\u0002\u0002u\u0003\u0002\u0002\u0002\u0002w\u0003\u0002\u0002", "\u0002\u0002y\u0003\u0002\u0002\u0002\u0002{\u0003\u0002\u0002\u0002", "\u0002}\u0003\u0002\u0002\u0002\u0002\u007f\u0003\u0002\u0002\u0002", "\u0002\u0081\u0003\u0002\u0002\u0002\u0003\u0089\u0003\u0002\u0002\u0002", "\u0005\u008b\u0003\u0002\u0002\u0002\u0007\u008d\u0003\u0002\u0002\u0002", "\t\u008f\u0003\u0002\u0002\u0002\u000b\u0091\u0003\u0002\u0002\u0002", "\r\u0093\u0003\u0002\u0002\u0002\u000f\u0095\u0003\u0002\u0002\u0002", "\u0011\u0097\u0003\u0002\u0002\u0002\u0013\u009b\u0003\u0002\u0002\u0002", "\u0015\u009f\u0003\u0002\u0002\u0002\u0017\u00a1\u0003\u0002\u0002\u0002", "\u0019\u00a3\u0003\u0002\u0002\u0002\u001b\u00a6\u0003\u0002\u0002\u0002", "\u001d\u00a8\u0003\u0002\u0002\u0002\u001f\u00aa\u0003\u0002\u0002\u0002", "!\u00ad\u0003\u0002\u0002\u0002#\u00b0\u0003\u0002\u0002\u0002%\u00b3", "\u0003\u0002\u0002\u0002\'\u00b5\u0003\u0002\u0002\u0002)\u00b7\u0003", "\u0002\u0002\u0002+\u00ba\u0003\u0002\u0002\u0002-\u00bd\u0003\u0002", "\u0002\u0002/\u00c0\u0003\u0002\u0002\u00021\u00c9\u0003\u0002\u0002", "\u00023\u00cd\u0003\u0002\u0002\u00025\u00d0\u0003\u0002\u0002\u0002", "7\u00d4\u0003\u0002\u0002\u00029\u00dc\u0003\u0002\u0002\u0002;\u00de", "\u0003\u0002\u0002\u0002=\u00e0\u0003\u0002\u0002\u0002?\u00e2\u0003", "\u0002\u0002\u0002A\u00e4\u0003\u0002\u0002\u0002C\u00e9\u0003\u0002", "\u0002\u0002E\u00ef\u0003\u0002\u0002\u0002G\u00f1\u0003\u0002\u0002", "\u0002I\u00f7\u0003\u0002\u0002\u0002K\u00fe\u0003\u0002\u0002\u0002", "M\u0105\u0003\u0002\u0002\u0002O\u0107\u0003\u0002\u0002\u0002Q\u010c", "\u0003\u0002\u0002\u0002S\u0112\u0003\u0002\u0002\u0002U\u0117\u0003", "\u0002\u0002\u0002W\u011b\u0003\u0002\u0002\u0002Y\u0120\u0003\u0002", "\u0002\u0002[\u0127\u0003\u0002\u0002\u0002]\u012e\u0003\u0002\u0002", "\u0002_\u013a\u0003\u0002\u0002\u0002a\u0140\u0003\u0002\u0002\u0002", "c\u0147\u0003\u0002\u0002\u0002e\u014d\u0003\u0002\u0002\u0002g\u0152", "\u0003\u0002\u0002\u0002i\u0158\u0003\u0002\u0002\u0002k\u0160\u0003", "\u0002\u0002\u0002m\u0168\u0003\u0002\u0002\u0002o\u0175\u0003\u0002", "\u0002\u0002q\u018b\u0003\u0002\u0002\u0002s\u018f\u0003\u0002\u0002", "\u0002u\u01ad\u0003\u0002\u0002\u0002w\u01b5\u0003\u0002\u0002\u0002", "y\u01bf\u0003\u0002\u0002\u0002{\u01ca\u0003\u0002\u0002\u0002}\u01d7", "\u0003\u0002\u0002\u0002\u007f\u01dd\u0003\u0002\u0002\u0002\u0081\u01eb", "\u0003\u0002\u0002\u0002\u0083\u01f6\u0003\u0002\u0002\u0002\u0085\u01fb", "\u0003\u0002\u0002\u0002\u0087\u0201\u0003\u0002\u0002\u0002\u0089\u008a", "\u00070\u0002\u0002\u008a\u0004\u0003\u0002\u0002\u0002\u008b\u008c", "\u0007]\u0002\u0002\u008c\u0006\u0003\u0002\u0002\u0002\u008d\u008e", "\u0007_\u0002\u0002\u008e\b\u0003\u0002\u0002\u0002\u008f\u0090\u0007", "-\u0002\u0002\u0090\n\u0003\u0002\u0002\u0002\u0091\u0092\u0007/\u0002", "\u0002\u0092\f\u0003\u0002\u0002\u0002\u0093\u0094\u0007,\u0002\u0002", "\u0094\u000e\u0003\u0002\u0002\u0002\u0095\u0096\u00071\u0002\u0002", "\u0096\u0010\u0003\u0002\u0002\u0002\u0097\u0098\u0007f\u0002\u0002", "\u0098\u0099\u0007k\u0002\u0002\u0099\u009a\u0007x\u0002\u0002\u009a", "\u0012\u0003\u0002\u0002\u0002\u009b\u009c\u0007o\u0002\u0002\u009c", "\u009d\u0007q\u0002\u0002\u009d\u009e\u0007f\u0002\u0002\u009e\u0014", "\u0003\u0002\u0002\u0002\u009f\u00a0\u0007(\u0002\u0002\u00a0\u0016", "\u0003\u0002\u0002\u0002\u00a1\u00a2\u0007~\u0002\u0002\u00a2\u0018", "\u0003\u0002\u0002\u0002\u00a3\u00a4\u0007>\u0002\u0002\u00a4\u00a5", "\u0007?\u0002\u0002\u00a5\u001a\u0003\u0002\u0002\u0002\u00a6\u00a7", "\u0007>\u0002\u0002\u00a7\u001c\u0003\u0002\u0002\u0002\u00a8\u00a9", "\u0007@\u0002\u0002\u00a9\u001e\u0003\u0002\u0002\u0002\u00aa\u00ab", "\u0007@\u0002\u0002\u00ab\u00ac\u0007?\u0002\u0002\u00ac \u0003\u0002", "\u0002\u0002\u00ad\u00ae\u0007k\u0002\u0002\u00ae\u00af\u0007u\u0002", "\u0002\u00af\"\u0003\u0002\u0002\u0002\u00b0\u00b1\u0007c\u0002\u0002", "\u00b1\u00b2\u0007u\u0002\u0002\u00b2$\u0003\u0002\u0002\u0002\u00b3", "\u00b4\u0007?\u0002\u0002\u00b4&\u0003\u0002\u0002\u0002\u00b5\u00b6", "\u0007\u0080\u0002\u0002\u00b6(\u0003\u0002\u0002\u0002\u00b7\u00b8", "\u0007#\u0002\u0002\u00b8\u00b9\u0007?\u0002\u0002\u00b9*\u0003\u0002", "\u0002\u0002\u00ba\u00bb\u0007#\u0002\u0002\u00bb\u00bc\u0007\u0080", "\u0002\u0002\u00bc,\u0003\u0002\u0002\u0002\u00bd\u00be\u0007k\u0002", "\u0002\u00be\u00bf\u0007p\u0002\u0002\u00bf.\u0003\u0002\u0002\u0002", "\u00c0\u00c1\u0007e\u0002\u0002\u00c1\u00c2\u0007q\u0002\u0002\u00c2", "\u00c3\u0007p\u0002\u0002\u00c3\u00c4\u0007v\u0002\u0002\u00c4\u00c5", "\u0007c\u0002\u0002\u00c5\u00c6\u0007k\u0002\u0002\u00c6\u00c7\u0007", "p\u0002\u0002\u00c7\u00c8\u0007u\u0002\u0002\u00c80\u0003\u0002\u0002", "\u0002\u00c9\u00ca\u0007c\u0002\u0002\u00ca\u00cb\u0007p\u0002\u0002", "\u00cb\u00cc\u0007f\u0002\u0002\u00cc2\u0003\u0002\u0002\u0002\u00cd", "\u00ce\u0007q\u0002\u0002\u00ce\u00cf\u0007t\u0002\u0002\u00cf4\u0003", "\u0002\u0002\u0002\u00d0\u00d1\u0007z\u0002\u0002\u00d1\u00d2\u0007", "q\u0002\u0002\u00d2\u00d3\u0007t\u0002\u0002\u00d36\u0003\u0002\u0002", "\u0002\u00d4\u00d5\u0007k\u0002\u0002\u00d5\u00d6\u0007o\u0002\u0002", "\u00d6\u00d7\u0007r\u0002\u0002\u00d7\u00d8\u0007n\u0002\u0002\u00d8", "\u00d9\u0007k\u0002\u0002\u00d9\u00da\u0007g\u0002\u0002\u00da\u00db", "\u0007u\u0002\u0002\u00db8\u0003\u0002\u0002\u0002\u00dc\u00dd\u0007", "*\u0002\u0002\u00dd:\u0003\u0002\u0002\u0002\u00de\u00df\u0007+\u0002", "\u0002\u00df<\u0003\u0002\u0002\u0002\u00e0\u00e1\u0007}\u0002\u0002", "\u00e1>\u0003\u0002\u0002\u0002\u00e2\u00e3\u0007\u007f\u0002\u0002", "\u00e3@\u0003\u0002\u0002\u0002\u00e4\u00e5\u0007v\u0002\u0002\u00e5", "\u00e6\u0007t\u0002\u0002\u00e6\u00e7\u0007w\u0002\u0002\u00e7\u00e8", "\u0007g\u0002\u0002\u00e8B\u0003\u0002\u0002\u0002\u00e9\u00ea\u0007", "h\u0002\u0002\u00ea\u00eb\u0007c\u0002\u0002\u00eb\u00ec\u0007n\u0002", "\u0002\u00ec\u00ed\u0007u\u0002\u0002\u00ed\u00ee\u0007g\u0002\u0002", "\u00eeD\u0003\u0002\u0002\u0002\u00ef\u00f0\u0007\'\u0002\u0002\u00f0", "F\u0003\u0002\u0002\u0002\u00f1\u00f2\u0007&\u0002\u0002\u00f2\u00f3", "\u0007v\u0002\u0002\u00f3\u00f4\u0007j\u0002\u0002\u00f4\u00f5\u0007", "k\u0002\u0002\u00f5\u00f6\u0007u\u0002\u0002\u00f6H\u0003\u0002\u0002", "\u0002\u00f7\u00f8\u0007&\u0002\u0002\u00f8\u00f9\u0007k\u0002\u0002", "\u00f9\u00fa\u0007p\u0002\u0002\u00fa\u00fb\u0007f\u0002\u0002\u00fb", "\u00fc\u0007g\u0002\u0002\u00fc\u00fd\u0007z\u0002\u0002\u00fdJ\u0003", "\u0002\u0002\u0002\u00fe\u00ff\u0007&\u0002\u0002\u00ff\u0100\u0007", "v\u0002\u0002\u0100\u0101\u0007q\u0002\u0002\u0101\u0102\u0007v\u0002", "\u0002\u0102\u0103\u0007c\u0002\u0002\u0103\u0104\u0007n\u0002\u0002", "\u0104L\u0003\u0002\u0002\u0002\u0105\u0106\u0007.\u0002\u0002\u0106", "N\u0003\u0002\u0002\u0002\u0107\u0108\u0007{\u0002\u0002\u0108\u0109", "\u0007g\u0002\u0002\u0109\u010a\u0007c\u0002\u0002\u010a\u010b\u0007", "t\u0002\u0002\u010bP\u0003\u0002\u0002\u0002\u010c\u010d\u0007o\u0002", "\u0002\u010d\u010e\u0007q\u0002\u0002\u010e\u010f\u0007p\u0002\u0002", "\u010f\u0110\u0007v\u0002\u0002\u0110\u0111\u0007j\u0002\u0002\u0111", "R\u0003\u0002\u0002\u0002\u0112\u0113\u0007y\u0002\u0002\u0113\u0114", "\u0007g\u0002\u0002\u0114\u0115\u0007g\u0002\u0002\u0115\u0116\u0007", "m\u0002\u0002\u0116T\u0003\u0002\u0002\u0002\u0117\u0118\u0007f\u0002", "\u0002\u0118\u0119\u0007c\u0002\u0002\u0119\u011a\u0007{\u0002\u0002", "\u011aV\u0003\u0002\u0002\u0002\u011b\u011c\u0007j\u0002\u0002\u011c", "\u011d\u0007q\u0002\u0002\u011d\u011e\u0007w\u0002\u0002\u011e\u011f", "\u0007t\u0002\u0002\u011fX\u0003\u0002\u0002\u0002\u0120\u0121\u0007", "o\u0002\u0002\u0121\u0122\u0007k\u0002\u0002\u0122\u0123\u0007p\u0002", "\u0002\u0123\u0124\u0007w\u0002\u0002\u0124\u0125\u0007v\u0002\u0002", "\u0125\u0126\u0007g\u0002\u0002\u0126Z\u0003\u0002\u0002\u0002\u0127", "\u0128\u0007u\u0002\u0002\u0128\u0129\u0007g\u0002\u0002\u0129\u012a", "\u0007e\u0002\u0002\u012a\u012b\u0007q\u0002\u0002\u012b\u012c\u0007", "p\u0002\u0002\u012c\u012d\u0007f\u0002\u0002\u012d\\\u0003\u0002\u0002", "\u0002\u012e\u012f\u0007o\u0002\u0002\u012f\u0130\u0007k\u0002\u0002", "\u0130\u0131\u0007n\u0002\u0002\u0131\u0132\u0007n\u0002\u0002\u0132", "\u0133\u0007k\u0002\u0002\u0133\u0134\u0007u\u0002\u0002\u0134\u0135", "\u0007g\u0002\u0002\u0135\u0136\u0007e\u0002\u0002\u0136\u0137\u0007", "q\u0002\u0002\u0137\u0138\u0007p\u0002\u0002\u0138\u0139\u0007f\u0002", "\u0002\u0139^\u0003\u0002\u0002\u0002\u013a\u013b\u0007{\u0002\u0002", "\u013b\u013c\u0007g\u0002\u0002\u013c\u013d\u0007c\u0002\u0002\u013d", "\u013e\u0007t\u0002\u0002\u013e\u013f\u0007u\u0002\u0002\u013f`\u0003", "\u0002\u0002\u0002\u0140\u0141\u0007o\u0002\u0002\u0141\u0142\u0007", "q\u0002\u0002\u0142\u0143\u0007p\u0002\u0002\u0143\u0144\u0007v\u0002", "\u0002\u0144\u0145\u0007j\u0002\u0002\u0145\u0146\u0007u\u0002\u0002", "\u0146b\u0003\u0002\u0002\u0002\u0147\u0148\u0007y\u0002\u0002\u0148", "\u0149\u0007g\u0002\u0002\u0149\u014a\u0007g\u0002\u0002\u014a\u014b", "\u0007m\u0002\u0002\u014b\u014c\u0007u\u0002\u0002\u014cd\u0003\u0002", "\u0002\u0002\u014d\u014e\u0007f\u0002\u0002\u014e\u014f\u0007c\u0002", "\u0002\u014f\u0150\u0007{\u0002\u0002\u0150\u0151\u0007u\u0002\u0002", "\u0151f\u0003\u0002\u0002\u0002\u0152\u0153\u0007j\u0002\u0002\u0153", "\u0154\u0007q\u0002\u0002\u0154\u0155\u0007w\u0002\u0002\u0155\u0156", "\u0007t\u0002\u0002\u0156\u0157\u0007u\u0002\u0002\u0157h\u0003\u0002", "\u0002\u0002\u0158\u0159\u0007o\u0002\u0002\u0159\u015a\u0007k\u0002", "\u0002\u015a\u015b\u0007p\u0002\u0002\u015b\u015c\u0007w\u0002\u0002", "\u015c\u015d\u0007v\u0002\u0002\u015d\u015e\u0007g\u0002\u0002\u015e", "\u015f\u0007u\u0002\u0002\u015fj\u0003\u0002\u0002\u0002\u0160\u0161", "\u0007u\u0002\u0002\u0161\u0162\u0007g\u0002\u0002\u0162\u0163\u0007", "e\u0002\u0002\u0163\u0164\u0007q\u0002\u0002\u0164\u0165\u0007p\u0002", "\u0002\u0165\u0166\u0007f\u0002\u0002\u0166\u0167\u0007u\u0002\u0002", "\u0167l\u0003\u0002\u0002\u0002\u0168\u0169\u0007o\u0002\u0002\u0169", "\u016a\u0007k\u0002\u0002\u016a\u016b\u0007n\u0002\u0002\u016b\u016c", "\u0007n\u0002\u0002\u016c\u016d\u0007k\u0002\u0002\u016d\u016e\u0007", "u\u0002\u0002\u016e\u016f\u0007g\u0002\u0002\u016f\u0170\u0007e\u0002", "\u0002\u0170\u0171\u0007q\u0002\u0002\u0171\u0172\u0007p\u0002\u0002", "\u0172\u0173\u0007f\u0002\u0002\u0173\u0174\u0007u\u0002\u0002\u0174", "n\u0003\u0002\u0002\u0002\u0175\u0176\u0007B\u0002\u0002\u0176\u0177", "\t\u0002\u0002\u0002\u0177\u0178\t\u0002\u0002\u0002\u0178\u0179\t\u0002", "\u0002\u0002\u0179\u0186\t\u0002\u0002\u0002\u017a\u017b\u0007/\u0002", "\u0002\u017b\u017c\t\u0002\u0002\u0002\u017c\u0184\t\u0002\u0002\u0002", "\u017d\u017e\u0007/\u0002\u0002\u017e\u017f\t\u0002\u0002\u0002\u017f", "\u0182\t\u0002\u0002\u0002\u0180\u0181\u0007V\u0002\u0002\u0181\u0183", "\u0005s:\u0002\u0182\u0180\u0003\u0002\u0002\u0002\u0182\u0183\u0003", "\u0002\u0002\u0002\u0183\u0185\u0003\u0002\u0002\u0002\u0184\u017d\u0003", "\u0002\u0002\u0002\u0184\u0185\u0003\u0002\u0002\u0002\u0185\u0187\u0003", "\u0002\u0002\u0002\u0186\u017a\u0003\u0002\u0002\u0002\u0186\u0187\u0003", "\u0002\u0002\u0002\u0187\u0189\u0003\u0002\u0002\u0002\u0188\u018a\u0007", "\\\u0002\u0002\u0189\u0188\u0003\u0002\u0002\u0002\u0189\u018a\u0003", "\u0002\u0002\u0002\u018ap\u0003\u0002\u0002\u0002\u018b\u018c\u0007", "B\u0002\u0002\u018c\u018d\u0007V\u0002\u0002\u018d\u018e\u0005s:\u0002", "\u018er\u0003\u0002\u0002\u0002\u018f\u0190\t\u0002\u0002\u0002\u0190", "\u01a1\t\u0002\u0002\u0002\u0191\u0192\u0007<\u0002\u0002\u0192\u0193", "\t\u0002\u0002\u0002\u0193\u019f\t\u0002\u0002\u0002\u0194\u0195\u0007", "<\u0002\u0002\u0195\u0196\t\u0002\u0002\u0002\u0196\u019d\t\u0002\u0002", "\u0002\u0197\u0199\u00070\u0002\u0002\u0198\u019a\t\u0002\u0002\u0002", "\u0199\u0198\u0003\u0002\u0002\u0002\u019a\u019b\u0003\u0002\u0002\u0002", "\u019b\u0199\u0003\u0002\u0002\u0002\u019b\u019c\u0003\u0002\u0002\u0002", "\u019c\u019e\u0003\u0002\u0002\u0002\u019d\u0197\u0003\u0002\u0002\u0002", "\u019d\u019e\u0003\u0002\u0002\u0002\u019e\u01a0\u0003\u0002\u0002\u0002", "\u019f\u0194\u0003\u0002\u0002\u0002\u019f\u01a0\u0003\u0002\u0002\u0002", "\u01a0\u01a2\u0003\u0002\u0002\u0002\u01a1\u0191\u0003\u0002\u0002\u0002", "\u01a1\u01a2\u0003\u0002\u0002\u0002\u01a2\u01aa\u0003\u0002\u0002\u0002", "\u01a3\u01ab\u0007\\\u0002\u0002\u01a4\u01a5\t\u0003\u0002\u0002\u01a5", "\u01a6\t\u0002\u0002\u0002\u01a6\u01a7\t\u0002\u0002\u0002\u01a7\u01a8", "\u0007<\u0002\u0002\u01a8\u01a9\t\u0002\u0002\u0002\u01a9\u01ab\t\u0002", "\u0002\u0002\u01aa\u01a3\u0003\u0002\u0002\u0002\u01aa\u01a4\u0003\u0002", "\u0002\u0002\u01aa\u01ab\u0003\u0002\u0002\u0002\u01abt\u0003\u0002", "\u0002\u0002\u01ac\u01ae\t\u0004\u0002\u0002\u01ad\u01ac\u0003\u0002", "\u0002\u0002\u01ae\u01b2\u0003\u0002\u0002\u0002\u01af\u01b1\t\u0005", "\u0002\u0002\u01b0\u01af\u0003\u0002\u0002\u0002\u01b1\u01b4\u0003\u0002", "\u0002\u0002\u01b2\u01b0\u0003\u0002\u0002\u0002\u01b2\u01b3\u0003\u0002", "\u0002\u0002\u01b3v\u0003\u0002\u0002\u0002\u01b4\u01b2\u0003\u0002", "\u0002\u0002\u01b5\u01ba\u0007b\u0002\u0002\u01b6\u01b9\u0005\u0083", "B\u0002\u01b7\u01b9\n\u0006\u0002\u0002\u01b8\u01b6\u0003\u0002\u0002", "\u0002\u01b8\u01b7\u0003\u0002\u0002\u0002\u01b9\u01bc\u0003\u0002\u0002", "\u0002\u01ba\u01b8\u0003\u0002\u0002\u0002\u01ba\u01bb\u0003\u0002\u0002", "\u0002\u01bb\u01bd\u0003\u0002\u0002\u0002\u01bc\u01ba\u0003\u0002\u0002", "\u0002\u01bd\u01be\u0007b\u0002\u0002\u01bex\u0003\u0002\u0002\u0002", "\u01bf\u01c4\u0007)\u0002\u0002\u01c0\u01c3\u0005\u0083B\u0002\u01c1", "\u01c3\n\u0007\u0002\u0002\u01c2\u01c0\u0003\u0002\u0002\u0002\u01c2", "\u01c1\u0003\u0002\u0002\u0002\u01c3\u01c6\u0003\u0002\u0002\u0002\u01c4", "\u01c2\u0003\u0002\u0002\u0002\u01c4\u01c5\u0003\u0002\u0002\u0002\u01c5", "\u01c7\u0003\u0002\u0002\u0002\u01c6\u01c4\u0003\u0002\u0002\u0002\u01c7", "\u01c8\u0007)\u0002\u0002\u01c8z\u0003\u0002\u0002\u0002\u01c9\u01cb", "\t\u0002\u0002\u0002\u01ca\u01c9\u0003\u0002\u0002\u0002\u01cb\u01cc", "\u0003\u0002\u0002\u0002\u01cc\u01ca\u0003\u0002\u0002\u0002\u01cc\u01cd", "\u0003\u0002\u0002\u0002\u01cd\u01d4\u0003\u0002\u0002\u0002\u01ce\u01d0", "\u00070\u0002\u0002\u01cf\u01d1\t\u0002\u0002\u0002\u01d0\u01cf\u0003", "\u0002\u0002\u0002\u01d1\u01d2\u0003\u0002\u0002\u0002\u01d2\u01d0\u0003", "\u0002\u0002\u0002\u01d2\u01d3\u0003\u0002\u0002\u0002\u01d3\u01d5\u0003", "\u0002\u0002\u0002\u01d4\u01ce\u0003\u0002\u0002\u0002\u01d4\u01d5\u0003", "\u0002\u0002\u0002\u01d5|\u0003\u0002\u0002\u0002\u01d6\u01d8\t\b\u0002", "\u0002\u01d7\u01d6\u0003\u0002\u0002\u0002\u01d8\u01d9\u0003\u0002\u0002", "\u0002\u01d9\u01d7\u0003\u0002\u0002\u0002\u01d9\u01da\u0003\u0002\u0002", "\u0002\u01da\u01db\u0003\u0002\u0002\u0002\u01db\u01dc\b?\u0002\u0002", "\u01dc~\u0003\u0002\u0002\u0002\u01dd\u01de\u00071\u0002\u0002\u01de", "\u01df\u0007,\u0002\u0002\u01df\u01e3\u0003\u0002\u0002\u0002\u01e0", "\u01e2\u000b\u0002\u0002\u0002\u01e1\u01e0\u0003\u0002\u0002\u0002\u01e2", "\u01e5\u0003\u0002\u0002\u0002\u01e3\u01e4\u0003\u0002\u0002\u0002\u01e3", "\u01e1\u0003\u0002\u0002\u0002\u01e4\u01e6\u0003\u0002\u0002\u0002\u01e5", "\u01e3\u0003\u0002\u0002\u0002\u01e6\u01e7\u0007,\u0002\u0002\u01e7", "\u01e8\u00071\u0002\u0002\u01e8\u01e9\u0003\u0002\u0002\u0002\u01e9", "\u01ea\b@\u0002\u0002\u01ea\u0080\u0003\u0002\u0002\u0002\u01eb\u01ec", "\u00071\u0002\u0002\u01ec\u01ed\u00071\u0002\u0002\u01ed\u01f1\u0003", "\u0002\u0002\u0002\u01ee\u01f0\n\t\u0002\u0002\u01ef\u01ee\u0003\u0002", "\u0002\u0002\u01f0\u01f3\u0003\u0002\u0002\u0002\u01f1\u01ef\u0003\u0002", "\u0002\u0002\u01f1\u01f2\u0003\u0002\u0002\u0002\u01f2\u01f4\u0003\u0002", "\u0002\u0002\u01f3\u01f1\u0003\u0002\u0002\u0002\u01f4\u01f5\bA\u0002", "\u0002\u01f5\u0082\u0003\u0002\u0002\u0002\u01f6\u01f9\u0007^\u0002", "\u0002\u01f7\u01fa\t\n\u0002\u0002\u01f8\u01fa\u0005\u0085C\u0002\u01f9", "\u01f7\u0003\u0002\u0002\u0002\u01f9\u01f8\u0003\u0002\u0002\u0002\u01fa", "\u0084\u0003\u0002\u0002\u0002\u01fb\u01fc\u0007w\u0002\u0002\u01fc", "\u01fd\u0005\u0087D\u0002\u01fd\u01fe\u0005\u0087D\u0002\u01fe\u01ff", "\u0005\u0087D\u0002\u01ff\u0200\u0005\u0087D\u0002\u0200\u0086\u0003", "\u0002\u0002\u0002\u0201\u0202\t\u000b\u0002\u0002\u0202\u0088\u0003", "\u0002\u0002\u0002\u001a\u0002\u0182\u0184\u0186\u0189\u019b\u019d\u019f", "\u01a1\u01aa\u01ad\u01b0\u01b2\u01b8\u01ba\u01c2\u01c4\u01cc\u01d2\u01d4", "\u01d9\u01e3\u01f1\u01f9\u0003\u0002\u0003\u0002"].join("");
const atn = new antlr4.atn.ATNDeserializer().deserialize(serializedATN);
const decisionsToDFA = atn.decisionToState.map((ds, index) => new antlr4.dfa.DFA(ds, index));
class FHIRPathLexer extends antlr4.Lexer {
  static grammarFileName = "FHIRPath.g4";
  static channelNames = ["DEFAULT_TOKEN_CHANNEL", "HIDDEN"];
  static modeNames = ["DEFAULT_MODE"];
  static literalNames = [null, "'.'", "'['", "']'", "'+'", "'-'", "'*'", "'/'", "'div'", "'mod'", "'&'", "'|'", "'<='", "'<'", "'>'", "'>='", "'is'", "'as'", "'='", "'~'", "'!='", "'!~'", "'in'", "'contains'", "'and'", "'or'", "'xor'", "'implies'", "'('", "')'", "'{'", "'}'", "'true'", "'false'", "'%'", "'$this'", "'$index'", "'$total'", "','", "'year'", "'month'", "'week'", "'day'", "'hour'", "'minute'", "'second'", "'millisecond'", "'years'", "'months'", "'weeks'", "'days'", "'hours'", "'minutes'", "'seconds'", "'milliseconds'"];
  static symbolicNames = [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, "DATETIME", "TIME", "IDENTIFIER", "DELIMITEDIDENTIFIER", "STRING", "NUMBER", "WS", "COMMENT", "LINE_COMMENT"];
  static ruleNames = ["T__0", "T__1", "T__2", "T__3", "T__4", "T__5", "T__6", "T__7", "T__8", "T__9", "T__10", "T__11", "T__12", "T__13", "T__14", "T__15", "T__16", "T__17", "T__18", "T__19", "T__20", "T__21", "T__22", "T__23", "T__24", "T__25", "T__26", "T__27", "T__28", "T__29", "T__30", "T__31", "T__32", "T__33", "T__34", "T__35", "T__36", "T__37", "T__38", "T__39", "T__40", "T__41", "T__42", "T__43", "T__44", "T__45", "T__46", "T__47", "T__48", "T__49", "T__50", "T__51", "T__52", "T__53", "DATETIME", "TIME", "TIMEFORMAT", "IDENTIFIER", "DELIMITEDIDENTIFIER", "STRING", "NUMBER", "WS", "COMMENT", "LINE_COMMENT", "ESC", "UNICODE", "HEX"];
  constructor(input) {
    super(input);
    this._interp = new antlr4.atn.LexerATNSimulator(this, atn, decisionsToDFA, new antlr4.PredictionContextCache());
  }
  get atn() {
    return atn;
  }
}
FHIRPathLexer.EOF = antlr4.Token.EOF;
FHIRPathLexer.T__0 = 1;
FHIRPathLexer.T__1 = 2;
FHIRPathLexer.T__2 = 3;
FHIRPathLexer.T__3 = 4;
FHIRPathLexer.T__4 = 5;
FHIRPathLexer.T__5 = 6;
FHIRPathLexer.T__6 = 7;
FHIRPathLexer.T__7 = 8;
FHIRPathLexer.T__8 = 9;
FHIRPathLexer.T__9 = 10;
FHIRPathLexer.T__10 = 11;
FHIRPathLexer.T__11 = 12;
FHIRPathLexer.T__12 = 13;
FHIRPathLexer.T__13 = 14;
FHIRPathLexer.T__14 = 15;
FHIRPathLexer.T__15 = 16;
FHIRPathLexer.T__16 = 17;
FHIRPathLexer.T__17 = 18;
FHIRPathLexer.T__18 = 19;
FHIRPathLexer.T__19 = 20;
FHIRPathLexer.T__20 = 21;
FHIRPathLexer.T__21 = 22;
FHIRPathLexer.T__22 = 23;
FHIRPathLexer.T__23 = 24;
FHIRPathLexer.T__24 = 25;
FHIRPathLexer.T__25 = 26;
FHIRPathLexer.T__26 = 27;
FHIRPathLexer.T__27 = 28;
FHIRPathLexer.T__28 = 29;
FHIRPathLexer.T__29 = 30;
FHIRPathLexer.T__30 = 31;
FHIRPathLexer.T__31 = 32;
FHIRPathLexer.T__32 = 33;
FHIRPathLexer.T__33 = 34;
FHIRPathLexer.T__34 = 35;
FHIRPathLexer.T__35 = 36;
FHIRPathLexer.T__36 = 37;
FHIRPathLexer.T__37 = 38;
FHIRPathLexer.T__38 = 39;
FHIRPathLexer.T__39 = 40;
FHIRPathLexer.T__40 = 41;
FHIRPathLexer.T__41 = 42;
FHIRPathLexer.T__42 = 43;
FHIRPathLexer.T__43 = 44;
FHIRPathLexer.T__44 = 45;
FHIRPathLexer.T__45 = 46;
FHIRPathLexer.T__46 = 47;
FHIRPathLexer.T__47 = 48;
FHIRPathLexer.T__48 = 49;
FHIRPathLexer.T__49 = 50;
FHIRPathLexer.T__50 = 51;
FHIRPathLexer.T__51 = 52;
FHIRPathLexer.T__52 = 53;
FHIRPathLexer.T__53 = 54;
FHIRPathLexer.DATETIME = 55;
FHIRPathLexer.TIME = 56;
FHIRPathLexer.IDENTIFIER = 57;
FHIRPathLexer.DELIMITEDIDENTIFIER = 58;
FHIRPathLexer.STRING = 59;
FHIRPathLexer.NUMBER = 60;
FHIRPathLexer.WS = 61;
FHIRPathLexer.COMMENT = 62;
FHIRPathLexer.LINE_COMMENT = 63;
module.exports = FHIRPathLexer;

/***/ }),
/* 51 */
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

// Generated from FHIRPath.g4 by ANTLR 4.9.3
// jshint ignore: start
const antlr4 = __webpack_require__(5);
const FHIRPathListener = __webpack_require__(52);
const serializedATN = ["\u0003\u608b\ua72a\u8133\ub9ed\u417c\u3be7\u7786", "\u5964\u0003A\u009c\u0004\u0002\t\u0002\u0004\u0003\t\u0003\u0004\u0004", "\t\u0004\u0004\u0005\t\u0005\u0004\u0006\t\u0006\u0004\u0007\t\u0007", "\u0004\b\t\b\u0004\t\t\t\u0004\n\t\n\u0004\u000b\t\u000b\u0004\f\t\f", "\u0004\r\t\r\u0004\u000e\t\u000e\u0004\u000f\t\u000f\u0004\u0010\t\u0010", "\u0003\u0002\u0003\u0002\u0003\u0002\u0003\u0003\u0003\u0003\u0003\u0003", "\u0003\u0003\u0005\u0003(\n\u0003\u0003\u0003\u0003\u0003\u0003\u0003", "\u0003\u0003\u0003\u0003\u0003\u0003\u0003\u0003\u0003\u0003\u0003\u0003", "\u0003\u0003\u0003\u0003\u0003\u0003\u0003\u0003\u0003\u0003\u0003\u0003", "\u0003\u0003\u0003\u0003\u0003\u0003\u0003\u0003\u0003\u0003\u0003\u0003", "\u0003\u0003\u0003\u0003\u0003\u0003\u0003\u0003\u0003\u0003\u0003\u0003", "\u0003\u0003\u0003\u0003\u0003\u0003\u0003\u0003\u0003\u0003\u0003\u0003", "\u0003\u0003\u0003\u0003\u0003\u0003\u0003\u0003\u0003\u0003\u0007\u0003", "P\n\u0003\f\u0003\u000e\u0003S\u000b\u0003\u0003\u0004\u0003\u0004\u0003", "\u0004\u0003\u0004\u0003\u0004\u0003\u0004\u0003\u0004\u0005\u0004\\", "\n\u0004\u0003\u0005\u0003\u0005\u0003\u0005\u0003\u0005\u0003\u0005", "\u0003\u0005\u0003\u0005\u0003\u0005\u0005\u0005f\n\u0005\u0003\u0006", "\u0003\u0006\u0003\u0006\u0005\u0006k\n\u0006\u0003\u0007\u0003\u0007", "\u0003\u0007\u0003\u0007\u0003\u0007\u0005\u0007r\n\u0007\u0003\b\u0003", "\b\u0003\b\u0005\bw\n\b\u0003\b\u0003\b\u0003\t\u0003\t\u0003\t\u0007", "\t~\n\t\f\t\u000e\t\u0081\u000b\t\u0003\n\u0003\n\u0005\n\u0085\n\n", "\u0003\u000b\u0003\u000b\u0003\u000b\u0005\u000b\u008a\n\u000b\u0003", "\f\u0003\f\u0003\r\u0003\r\u0003\u000e\u0003\u000e\u0003\u000f\u0003", "\u000f\u0003\u000f\u0007\u000f\u0095\n\u000f\f\u000f\u000e\u000f\u0098", "\u000b\u000f\u0003\u0010\u0003\u0010\u0003\u0010\u0002\u0003\u0004\u0011", "\u0002\u0004\u0006\b\n\f\u000e\u0010\u0012\u0014\u0016\u0018\u001a\u001c", "\u001e\u0002\u000e\u0003\u0002\u0006\u0007\u0003\u0002\b\u000b\u0004", "\u0002\u0006\u0007\f\f\u0003\u0002\u000e\u0011\u0003\u0002\u0014\u0017", "\u0003\u0002\u0018\u0019\u0003\u0002\u001b\u001c\u0003\u0002\u0012\u0013", "\u0003\u0002\"#\u0003\u0002)0\u0003\u000218\u0005\u0002\u0012\u0013", "\u0018\u0019;<\u0002\u00ad\u0002 \u0003\u0002\u0002\u0002\u0004\'\u0003", "\u0002\u0002\u0002\u0006[\u0003\u0002\u0002\u0002\be\u0003\u0002\u0002", "\u0002\ng\u0003\u0002\u0002\u0002\fq\u0003\u0002\u0002\u0002\u000es", "\u0003\u0002\u0002\u0002\u0010z\u0003\u0002\u0002\u0002\u0012\u0082", "\u0003\u0002\u0002\u0002\u0014\u0089\u0003\u0002\u0002\u0002\u0016\u008b", "\u0003\u0002\u0002\u0002\u0018\u008d\u0003\u0002\u0002\u0002\u001a\u008f", "\u0003\u0002\u0002\u0002\u001c\u0091\u0003\u0002\u0002\u0002\u001e\u0099", "\u0003\u0002\u0002\u0002 !\u0005\u0004\u0003\u0002!\"\u0007\u0002\u0002", "\u0003\"\u0003\u0003\u0002\u0002\u0002#$\b\u0003\u0001\u0002$(\u0005", "\u0006\u0004\u0002%&\t\u0002\u0002\u0002&(\u0005\u0004\u0003\r\'#\u0003", "\u0002\u0002\u0002\'%\u0003\u0002\u0002\u0002(Q\u0003\u0002\u0002\u0002", ")*\f\f\u0002\u0002*+\t\u0003\u0002\u0002+P\u0005\u0004\u0003\r,-\f\u000b", "\u0002\u0002-.\t\u0004\u0002\u0002.P\u0005\u0004\u0003\f/0\f\n\u0002", "\u000201\u0007\r\u0002\u00021P\u0005\u0004\u0003\u000b23\f\t\u0002\u0002", "34\t\u0005\u0002\u00024P\u0005\u0004\u0003\n56\f\u0007\u0002\u00026", "7\t\u0006\u0002\u00027P\u0005\u0004\u0003\b89\f\u0006\u0002\u00029:", "\t\u0007\u0002\u0002:P\u0005\u0004\u0003\u0007;<\f\u0005\u0002\u0002", "<=\u0007\u001a\u0002\u0002=P\u0005\u0004\u0003\u0006>?\f\u0004\u0002", "\u0002?@\t\b\u0002\u0002@P\u0005\u0004\u0003\u0005AB\f\u0003\u0002\u0002", "BC\u0007\u001d\u0002\u0002CP\u0005\u0004\u0003\u0004DE\f\u000f\u0002", "\u0002EF\u0007\u0003\u0002\u0002FP\u0005\f\u0007\u0002GH\f\u000e\u0002", "\u0002HI\u0007\u0004\u0002\u0002IJ\u0005\u0004\u0003\u0002JK\u0007\u0005", "\u0002\u0002KP\u0003\u0002\u0002\u0002LM\f\b\u0002\u0002MN\t\t\u0002", "\u0002NP\u0005\u001a\u000e\u0002O)\u0003\u0002\u0002\u0002O,\u0003\u0002", "\u0002\u0002O/\u0003\u0002\u0002\u0002O2\u0003\u0002\u0002\u0002O5\u0003", "\u0002\u0002\u0002O8\u0003\u0002\u0002\u0002O;\u0003\u0002\u0002\u0002", "O>\u0003\u0002\u0002\u0002OA\u0003\u0002\u0002\u0002OD\u0003\u0002\u0002", "\u0002OG\u0003\u0002\u0002\u0002OL\u0003\u0002\u0002\u0002PS\u0003\u0002", "\u0002\u0002QO\u0003\u0002\u0002\u0002QR\u0003\u0002\u0002\u0002R\u0005", "\u0003\u0002\u0002\u0002SQ\u0003\u0002\u0002\u0002T\\\u0005\f\u0007", "\u0002U\\\u0005\b\u0005\u0002V\\\u0005\n\u0006\u0002WX\u0007\u001e\u0002", "\u0002XY\u0005\u0004\u0003\u0002YZ\u0007\u001f\u0002\u0002Z\\\u0003", "\u0002\u0002\u0002[T\u0003\u0002\u0002\u0002[U\u0003\u0002\u0002\u0002", "[V\u0003\u0002\u0002\u0002[W\u0003\u0002\u0002\u0002\\\u0007\u0003\u0002", "\u0002\u0002]^\u0007 \u0002\u0002^f\u0007!\u0002\u0002_f\t\n\u0002\u0002", "`f\u0007=\u0002\u0002af\u0007>\u0002\u0002bf\u00079\u0002\u0002cf\u0007", ":\u0002\u0002df\u0005\u0012\n\u0002e]\u0003\u0002\u0002\u0002e_\u0003", "\u0002\u0002\u0002e`\u0003\u0002\u0002\u0002ea\u0003\u0002\u0002\u0002", "eb\u0003\u0002\u0002\u0002ec\u0003\u0002\u0002\u0002ed\u0003\u0002\u0002", "\u0002f\t\u0003\u0002\u0002\u0002gj\u0007$\u0002\u0002hk\u0005\u001e", "\u0010\u0002ik\u0007=\u0002\u0002jh\u0003\u0002\u0002\u0002ji\u0003", "\u0002\u0002\u0002k\u000b\u0003\u0002\u0002\u0002lr\u0005\u001e\u0010", "\u0002mr\u0005\u000e\b\u0002nr\u0007%\u0002\u0002or\u0007&\u0002\u0002", "pr\u0007\'\u0002\u0002ql\u0003\u0002\u0002\u0002qm\u0003\u0002\u0002", "\u0002qn\u0003\u0002\u0002\u0002qo\u0003\u0002\u0002\u0002qp\u0003\u0002", "\u0002\u0002r\r\u0003\u0002\u0002\u0002st\u0005\u001e\u0010\u0002tv", "\u0007\u001e\u0002\u0002uw\u0005\u0010\t\u0002vu\u0003\u0002\u0002\u0002", "vw\u0003\u0002\u0002\u0002wx\u0003\u0002\u0002\u0002xy\u0007\u001f\u0002", "\u0002y\u000f\u0003\u0002\u0002\u0002z\u007f\u0005\u0004\u0003\u0002", "{|\u0007(\u0002\u0002|~\u0005\u0004\u0003\u0002}{\u0003\u0002\u0002", "\u0002~\u0081\u0003\u0002\u0002\u0002\u007f}\u0003\u0002\u0002\u0002", "\u007f\u0080\u0003\u0002\u0002\u0002\u0080\u0011\u0003\u0002\u0002\u0002", "\u0081\u007f\u0003\u0002\u0002\u0002\u0082\u0084\u0007>\u0002\u0002", "\u0083\u0085\u0005\u0014\u000b\u0002\u0084\u0083\u0003\u0002\u0002\u0002", "\u0084\u0085\u0003\u0002\u0002\u0002\u0085\u0013\u0003\u0002\u0002\u0002", "\u0086\u008a\u0005\u0016\f\u0002\u0087\u008a\u0005\u0018\r\u0002\u0088", "\u008a\u0007=\u0002\u0002\u0089\u0086\u0003\u0002\u0002\u0002\u0089", "\u0087\u0003\u0002\u0002\u0002\u0089\u0088\u0003\u0002\u0002\u0002\u008a", "\u0015\u0003\u0002\u0002\u0002\u008b\u008c\t\u000b\u0002\u0002\u008c", "\u0017\u0003\u0002\u0002\u0002\u008d\u008e\t\f\u0002\u0002\u008e\u0019", "\u0003\u0002\u0002\u0002\u008f\u0090\u0005\u001c\u000f\u0002\u0090\u001b", "\u0003\u0002\u0002\u0002\u0091\u0096\u0005\u001e\u0010\u0002\u0092\u0093", "\u0007\u0003\u0002\u0002\u0093\u0095\u0005\u001e\u0010\u0002\u0094\u0092", "\u0003\u0002\u0002\u0002\u0095\u0098\u0003\u0002\u0002\u0002\u0096\u0094", "\u0003\u0002\u0002\u0002\u0096\u0097\u0003\u0002\u0002\u0002\u0097\u001d", "\u0003\u0002\u0002\u0002\u0098\u0096\u0003\u0002\u0002\u0002\u0099\u009a", "\t\r\u0002\u0002\u009a\u001f\u0003\u0002\u0002\u0002\u000e\'OQ[ejqv", "\u007f\u0084\u0089\u0096"].join("");
const atn = new antlr4.atn.ATNDeserializer().deserialize(serializedATN);
const decisionsToDFA = atn.decisionToState.map((ds, index) => new antlr4.dfa.DFA(ds, index));
const sharedContextCache = new antlr4.PredictionContextCache();
class FHIRPathParser extends antlr4.Parser {
  static grammarFileName = "FHIRPath.g4";
  static literalNames = [null, "'.'", "'['", "']'", "'+'", "'-'", "'*'", "'/'", "'div'", "'mod'", "'&'", "'|'", "'<='", "'<'", "'>'", "'>='", "'is'", "'as'", "'='", "'~'", "'!='", "'!~'", "'in'", "'contains'", "'and'", "'or'", "'xor'", "'implies'", "'('", "')'", "'{'", "'}'", "'true'", "'false'", "'%'", "'$this'", "'$index'", "'$total'", "','", "'year'", "'month'", "'week'", "'day'", "'hour'", "'minute'", "'second'", "'millisecond'", "'years'", "'months'", "'weeks'", "'days'", "'hours'", "'minutes'", "'seconds'", "'milliseconds'"];
  static symbolicNames = [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, "DATETIME", "TIME", "IDENTIFIER", "DELIMITEDIDENTIFIER", "STRING", "NUMBER", "WS", "COMMENT", "LINE_COMMENT"];
  static ruleNames = ["entireExpression", "expression", "term", "literal", "externalConstant", "invocation", "functn", "paramList", "quantity", "unit", "dateTimePrecision", "pluralDateTimePrecision", "typeSpecifier", "qualifiedIdentifier", "identifier"];
  constructor(input) {
    super(input);
    this._interp = new antlr4.atn.ParserATNSimulator(this, atn, decisionsToDFA, sharedContextCache);
    this.ruleNames = FHIRPathParser.ruleNames;
    this.literalNames = FHIRPathParser.literalNames;
    this.symbolicNames = FHIRPathParser.symbolicNames;
  }
  get atn() {
    return atn;
  }
  sempred(localctx, ruleIndex, predIndex) {
    switch (ruleIndex) {
      case 1:
        return this.expression_sempred(localctx, predIndex);
      default:
        throw "No predicate with index:" + ruleIndex;
    }
  }
  expression_sempred(localctx, predIndex) {
    switch (predIndex) {
      case 0:
        return this.precpred(this._ctx, 10);
      case 1:
        return this.precpred(this._ctx, 9);
      case 2:
        return this.precpred(this._ctx, 8);
      case 3:
        return this.precpred(this._ctx, 7);
      case 4:
        return this.precpred(this._ctx, 5);
      case 5:
        return this.precpred(this._ctx, 4);
      case 6:
        return this.precpred(this._ctx, 3);
      case 7:
        return this.precpred(this._ctx, 2);
      case 8:
        return this.precpred(this._ctx, 1);
      case 9:
        return this.precpred(this._ctx, 13);
      case 10:
        return this.precpred(this._ctx, 12);
      case 11:
        return this.precpred(this._ctx, 6);
      default:
        throw "No predicate with index:" + predIndex;
    }
  }
  entireExpression() {
    let localctx = new EntireExpressionContext(this, this._ctx, this.state);
    this.enterRule(localctx, 0, FHIRPathParser.RULE_entireExpression);
    try {
      this.enterOuterAlt(localctx, 1);
      this.state = 30;
      this.expression(0);
      this.state = 31;
      this.match(FHIRPathParser.EOF);
    } catch (re) {
      if (re instanceof antlr4.error.RecognitionException) {
        localctx.exception = re;
        this._errHandler.reportError(this, re);
        this._errHandler.recover(this, re);
      } else {
        throw re;
      }
    } finally {
      this.exitRule();
    }
    return localctx;
  }
  expression(_p) {
    if (_p === undefined) {
      _p = 0;
    }
    const _parentctx = this._ctx;
    const _parentState = this.state;
    let localctx = new ExpressionContext(this, this._ctx, _parentState);
    let _prevctx = localctx;
    const _startState = 2;
    this.enterRecursionRule(localctx, 2, FHIRPathParser.RULE_expression, _p);
    var _la = 0; // Token type
    try {
      this.enterOuterAlt(localctx, 1);
      this.state = 37;
      this._errHandler.sync(this);
      switch (this._input.LA(1)) {
        case FHIRPathParser.T__15:
        case FHIRPathParser.T__16:
        case FHIRPathParser.T__21:
        case FHIRPathParser.T__22:
        case FHIRPathParser.T__27:
        case FHIRPathParser.T__29:
        case FHIRPathParser.T__31:
        case FHIRPathParser.T__32:
        case FHIRPathParser.T__33:
        case FHIRPathParser.T__34:
        case FHIRPathParser.T__35:
        case FHIRPathParser.T__36:
        case FHIRPathParser.DATETIME:
        case FHIRPathParser.TIME:
        case FHIRPathParser.IDENTIFIER:
        case FHIRPathParser.DELIMITEDIDENTIFIER:
        case FHIRPathParser.STRING:
        case FHIRPathParser.NUMBER:
          localctx = new TermExpressionContext(this, localctx);
          this._ctx = localctx;
          _prevctx = localctx;
          this.state = 34;
          this.term();
          break;
        case FHIRPathParser.T__3:
        case FHIRPathParser.T__4:
          localctx = new PolarityExpressionContext(this, localctx);
          this._ctx = localctx;
          _prevctx = localctx;
          this.state = 35;
          _la = this._input.LA(1);
          if (!(_la === FHIRPathParser.T__3 || _la === FHIRPathParser.T__4)) {
            this._errHandler.recoverInline(this);
          } else {
            this._errHandler.reportMatch(this);
            this.consume();
          }
          this.state = 36;
          this.expression(11);
          break;
        default:
          throw new antlr4.error.NoViableAltException(this);
      }
      this._ctx.stop = this._input.LT(-1);
      this.state = 79;
      this._errHandler.sync(this);
      var _alt = this._interp.adaptivePredict(this._input, 2, this._ctx);
      while (_alt != 2 && _alt != antlr4.atn.ATN.INVALID_ALT_NUMBER) {
        if (_alt === 1) {
          if (this._parseListeners !== null) {
            this.triggerExitRuleEvent();
          }
          _prevctx = localctx;
          this.state = 77;
          this._errHandler.sync(this);
          var la_ = this._interp.adaptivePredict(this._input, 1, this._ctx);
          switch (la_) {
            case 1:
              localctx = new MultiplicativeExpressionContext(this, new ExpressionContext(this, _parentctx, _parentState));
              this.pushNewRecursionContext(localctx, _startState, FHIRPathParser.RULE_expression);
              this.state = 39;
              if (!this.precpred(this._ctx, 10)) {
                throw new antlr4.error.FailedPredicateException(this, "this.precpred(this._ctx, 10)");
              }
              this.state = 40;
              _la = this._input.LA(1);
              if (!((_la & ~0x1f) == 0 && (1 << _la & (1 << FHIRPathParser.T__5 | 1 << FHIRPathParser.T__6 | 1 << FHIRPathParser.T__7 | 1 << FHIRPathParser.T__8)) !== 0)) {
                this._errHandler.recoverInline(this);
              } else {
                this._errHandler.reportMatch(this);
                this.consume();
              }
              this.state = 41;
              this.expression(11);
              break;
            case 2:
              localctx = new AdditiveExpressionContext(this, new ExpressionContext(this, _parentctx, _parentState));
              this.pushNewRecursionContext(localctx, _startState, FHIRPathParser.RULE_expression);
              this.state = 42;
              if (!this.precpred(this._ctx, 9)) {
                throw new antlr4.error.FailedPredicateException(this, "this.precpred(this._ctx, 9)");
              }
              this.state = 43;
              _la = this._input.LA(1);
              if (!((_la & ~0x1f) == 0 && (1 << _la & (1 << FHIRPathParser.T__3 | 1 << FHIRPathParser.T__4 | 1 << FHIRPathParser.T__9)) !== 0)) {
                this._errHandler.recoverInline(this);
              } else {
                this._errHandler.reportMatch(this);
                this.consume();
              }
              this.state = 44;
              this.expression(10);
              break;
            case 3:
              localctx = new UnionExpressionContext(this, new ExpressionContext(this, _parentctx, _parentState));
              this.pushNewRecursionContext(localctx, _startState, FHIRPathParser.RULE_expression);
              this.state = 45;
              if (!this.precpred(this._ctx, 8)) {
                throw new antlr4.error.FailedPredicateException(this, "this.precpred(this._ctx, 8)");
              }
              this.state = 46;
              this.match(FHIRPathParser.T__10);
              this.state = 47;
              this.expression(9);
              break;
            case 4:
              localctx = new InequalityExpressionContext(this, new ExpressionContext(this, _parentctx, _parentState));
              this.pushNewRecursionContext(localctx, _startState, FHIRPathParser.RULE_expression);
              this.state = 48;
              if (!this.precpred(this._ctx, 7)) {
                throw new antlr4.error.FailedPredicateException(this, "this.precpred(this._ctx, 7)");
              }
              this.state = 49;
              _la = this._input.LA(1);
              if (!((_la & ~0x1f) == 0 && (1 << _la & (1 << FHIRPathParser.T__11 | 1 << FHIRPathParser.T__12 | 1 << FHIRPathParser.T__13 | 1 << FHIRPathParser.T__14)) !== 0)) {
                this._errHandler.recoverInline(this);
              } else {
                this._errHandler.reportMatch(this);
                this.consume();
              }
              this.state = 50;
              this.expression(8);
              break;
            case 5:
              localctx = new EqualityExpressionContext(this, new ExpressionContext(this, _parentctx, _parentState));
              this.pushNewRecursionContext(localctx, _startState, FHIRPathParser.RULE_expression);
              this.state = 51;
              if (!this.precpred(this._ctx, 5)) {
                throw new antlr4.error.FailedPredicateException(this, "this.precpred(this._ctx, 5)");
              }
              this.state = 52;
              _la = this._input.LA(1);
              if (!((_la & ~0x1f) == 0 && (1 << _la & (1 << FHIRPathParser.T__17 | 1 << FHIRPathParser.T__18 | 1 << FHIRPathParser.T__19 | 1 << FHIRPathParser.T__20)) !== 0)) {
                this._errHandler.recoverInline(this);
              } else {
                this._errHandler.reportMatch(this);
                this.consume();
              }
              this.state = 53;
              this.expression(6);
              break;
            case 6:
              localctx = new MembershipExpressionContext(this, new ExpressionContext(this, _parentctx, _parentState));
              this.pushNewRecursionContext(localctx, _startState, FHIRPathParser.RULE_expression);
              this.state = 54;
              if (!this.precpred(this._ctx, 4)) {
                throw new antlr4.error.FailedPredicateException(this, "this.precpred(this._ctx, 4)");
              }
              this.state = 55;
              _la = this._input.LA(1);
              if (!(_la === FHIRPathParser.T__21 || _la === FHIRPathParser.T__22)) {
                this._errHandler.recoverInline(this);
              } else {
                this._errHandler.reportMatch(this);
                this.consume();
              }
              this.state = 56;
              this.expression(5);
              break;
            case 7:
              localctx = new AndExpressionContext(this, new ExpressionContext(this, _parentctx, _parentState));
              this.pushNewRecursionContext(localctx, _startState, FHIRPathParser.RULE_expression);
              this.state = 57;
              if (!this.precpred(this._ctx, 3)) {
                throw new antlr4.error.FailedPredicateException(this, "this.precpred(this._ctx, 3)");
              }
              this.state = 58;
              this.match(FHIRPathParser.T__23);
              this.state = 59;
              this.expression(4);
              break;
            case 8:
              localctx = new OrExpressionContext(this, new ExpressionContext(this, _parentctx, _parentState));
              this.pushNewRecursionContext(localctx, _startState, FHIRPathParser.RULE_expression);
              this.state = 60;
              if (!this.precpred(this._ctx, 2)) {
                throw new antlr4.error.FailedPredicateException(this, "this.precpred(this._ctx, 2)");
              }
              this.state = 61;
              _la = this._input.LA(1);
              if (!(_la === FHIRPathParser.T__24 || _la === FHIRPathParser.T__25)) {
                this._errHandler.recoverInline(this);
              } else {
                this._errHandler.reportMatch(this);
                this.consume();
              }
              this.state = 62;
              this.expression(3);
              break;
            case 9:
              localctx = new ImpliesExpressionContext(this, new ExpressionContext(this, _parentctx, _parentState));
              this.pushNewRecursionContext(localctx, _startState, FHIRPathParser.RULE_expression);
              this.state = 63;
              if (!this.precpred(this._ctx, 1)) {
                throw new antlr4.error.FailedPredicateException(this, "this.precpred(this._ctx, 1)");
              }
              this.state = 64;
              this.match(FHIRPathParser.T__26);
              this.state = 65;
              this.expression(2);
              break;
            case 10:
              localctx = new InvocationExpressionContext(this, new ExpressionContext(this, _parentctx, _parentState));
              this.pushNewRecursionContext(localctx, _startState, FHIRPathParser.RULE_expression);
              this.state = 66;
              if (!this.precpred(this._ctx, 13)) {
                throw new antlr4.error.FailedPredicateException(this, "this.precpred(this._ctx, 13)");
              }
              this.state = 67;
              this.match(FHIRPathParser.T__0);
              this.state = 68;
              this.invocation();
              break;
            case 11:
              localctx = new IndexerExpressionContext(this, new ExpressionContext(this, _parentctx, _parentState));
              this.pushNewRecursionContext(localctx, _startState, FHIRPathParser.RULE_expression);
              this.state = 69;
              if (!this.precpred(this._ctx, 12)) {
                throw new antlr4.error.FailedPredicateException(this, "this.precpred(this._ctx, 12)");
              }
              this.state = 70;
              this.match(FHIRPathParser.T__1);
              this.state = 71;
              this.expression(0);
              this.state = 72;
              this.match(FHIRPathParser.T__2);
              break;
            case 12:
              localctx = new TypeExpressionContext(this, new ExpressionContext(this, _parentctx, _parentState));
              this.pushNewRecursionContext(localctx, _startState, FHIRPathParser.RULE_expression);
              this.state = 74;
              if (!this.precpred(this._ctx, 6)) {
                throw new antlr4.error.FailedPredicateException(this, "this.precpred(this._ctx, 6)");
              }
              this.state = 75;
              _la = this._input.LA(1);
              if (!(_la === FHIRPathParser.T__15 || _la === FHIRPathParser.T__16)) {
                this._errHandler.recoverInline(this);
              } else {
                this._errHandler.reportMatch(this);
                this.consume();
              }
              this.state = 76;
              this.typeSpecifier();
              break;
          }
        }
        this.state = 81;
        this._errHandler.sync(this);
        _alt = this._interp.adaptivePredict(this._input, 2, this._ctx);
      }
    } catch (error) {
      if (error instanceof antlr4.error.RecognitionException) {
        localctx.exception = error;
        this._errHandler.reportError(this, error);
        this._errHandler.recover(this, error);
      } else {
        throw error;
      }
    } finally {
      this.unrollRecursionContexts(_parentctx);
    }
    return localctx;
  }
  term() {
    let localctx = new TermContext(this, this._ctx, this.state);
    this.enterRule(localctx, 4, FHIRPathParser.RULE_term);
    try {
      this.state = 89;
      this._errHandler.sync(this);
      switch (this._input.LA(1)) {
        case FHIRPathParser.T__15:
        case FHIRPathParser.T__16:
        case FHIRPathParser.T__21:
        case FHIRPathParser.T__22:
        case FHIRPathParser.T__34:
        case FHIRPathParser.T__35:
        case FHIRPathParser.T__36:
        case FHIRPathParser.IDENTIFIER:
        case FHIRPathParser.DELIMITEDIDENTIFIER:
          localctx = new InvocationTermContext(this, localctx);
          this.enterOuterAlt(localctx, 1);
          this.state = 82;
          this.invocation();
          break;
        case FHIRPathParser.T__29:
        case FHIRPathParser.T__31:
        case FHIRPathParser.T__32:
        case FHIRPathParser.DATETIME:
        case FHIRPathParser.TIME:
        case FHIRPathParser.STRING:
        case FHIRPathParser.NUMBER:
          localctx = new LiteralTermContext(this, localctx);
          this.enterOuterAlt(localctx, 2);
          this.state = 83;
          this.literal();
          break;
        case FHIRPathParser.T__33:
          localctx = new ExternalConstantTermContext(this, localctx);
          this.enterOuterAlt(localctx, 3);
          this.state = 84;
          this.externalConstant();
          break;
        case FHIRPathParser.T__27:
          localctx = new ParenthesizedTermContext(this, localctx);
          this.enterOuterAlt(localctx, 4);
          this.state = 85;
          this.match(FHIRPathParser.T__27);
          this.state = 86;
          this.expression(0);
          this.state = 87;
          this.match(FHIRPathParser.T__28);
          break;
        default:
          throw new antlr4.error.NoViableAltException(this);
      }
    } catch (re) {
      if (re instanceof antlr4.error.RecognitionException) {
        localctx.exception = re;
        this._errHandler.reportError(this, re);
        this._errHandler.recover(this, re);
      } else {
        throw re;
      }
    } finally {
      this.exitRule();
    }
    return localctx;
  }
  literal() {
    let localctx = new LiteralContext(this, this._ctx, this.state);
    this.enterRule(localctx, 6, FHIRPathParser.RULE_literal);
    var _la = 0; // Token type
    try {
      this.state = 99;
      this._errHandler.sync(this);
      var la_ = this._interp.adaptivePredict(this._input, 4, this._ctx);
      switch (la_) {
        case 1:
          localctx = new NullLiteralContext(this, localctx);
          this.enterOuterAlt(localctx, 1);
          this.state = 91;
          this.match(FHIRPathParser.T__29);
          this.state = 92;
          this.match(FHIRPathParser.T__30);
          break;
        case 2:
          localctx = new BooleanLiteralContext(this, localctx);
          this.enterOuterAlt(localctx, 2);
          this.state = 93;
          _la = this._input.LA(1);
          if (!(_la === FHIRPathParser.T__31 || _la === FHIRPathParser.T__32)) {
            this._errHandler.recoverInline(this);
          } else {
            this._errHandler.reportMatch(this);
            this.consume();
          }
          break;
        case 3:
          localctx = new StringLiteralContext(this, localctx);
          this.enterOuterAlt(localctx, 3);
          this.state = 94;
          this.match(FHIRPathParser.STRING);
          break;
        case 4:
          localctx = new NumberLiteralContext(this, localctx);
          this.enterOuterAlt(localctx, 4);
          this.state = 95;
          this.match(FHIRPathParser.NUMBER);
          break;
        case 5:
          localctx = new DateTimeLiteralContext(this, localctx);
          this.enterOuterAlt(localctx, 5);
          this.state = 96;
          this.match(FHIRPathParser.DATETIME);
          break;
        case 6:
          localctx = new TimeLiteralContext(this, localctx);
          this.enterOuterAlt(localctx, 6);
          this.state = 97;
          this.match(FHIRPathParser.TIME);
          break;
        case 7:
          localctx = new QuantityLiteralContext(this, localctx);
          this.enterOuterAlt(localctx, 7);
          this.state = 98;
          this.quantity();
          break;
      }
    } catch (re) {
      if (re instanceof antlr4.error.RecognitionException) {
        localctx.exception = re;
        this._errHandler.reportError(this, re);
        this._errHandler.recover(this, re);
      } else {
        throw re;
      }
    } finally {
      this.exitRule();
    }
    return localctx;
  }
  externalConstant() {
    let localctx = new ExternalConstantContext(this, this._ctx, this.state);
    this.enterRule(localctx, 8, FHIRPathParser.RULE_externalConstant);
    try {
      this.enterOuterAlt(localctx, 1);
      this.state = 101;
      this.match(FHIRPathParser.T__33);
      this.state = 104;
      this._errHandler.sync(this);
      switch (this._input.LA(1)) {
        case FHIRPathParser.T__15:
        case FHIRPathParser.T__16:
        case FHIRPathParser.T__21:
        case FHIRPathParser.T__22:
        case FHIRPathParser.IDENTIFIER:
        case FHIRPathParser.DELIMITEDIDENTIFIER:
          this.state = 102;
          this.identifier();
          break;
        case FHIRPathParser.STRING:
          this.state = 103;
          this.match(FHIRPathParser.STRING);
          break;
        default:
          throw new antlr4.error.NoViableAltException(this);
      }
    } catch (re) {
      if (re instanceof antlr4.error.RecognitionException) {
        localctx.exception = re;
        this._errHandler.reportError(this, re);
        this._errHandler.recover(this, re);
      } else {
        throw re;
      }
    } finally {
      this.exitRule();
    }
    return localctx;
  }
  invocation() {
    let localctx = new InvocationContext(this, this._ctx, this.state);
    this.enterRule(localctx, 10, FHIRPathParser.RULE_invocation);
    try {
      this.state = 111;
      this._errHandler.sync(this);
      var la_ = this._interp.adaptivePredict(this._input, 6, this._ctx);
      switch (la_) {
        case 1:
          localctx = new MemberInvocationContext(this, localctx);
          this.enterOuterAlt(localctx, 1);
          this.state = 106;
          this.identifier();
          break;
        case 2:
          localctx = new FunctionInvocationContext(this, localctx);
          this.enterOuterAlt(localctx, 2);
          this.state = 107;
          this.functn();
          break;
        case 3:
          localctx = new ThisInvocationContext(this, localctx);
          this.enterOuterAlt(localctx, 3);
          this.state = 108;
          this.match(FHIRPathParser.T__34);
          break;
        case 4:
          localctx = new IndexInvocationContext(this, localctx);
          this.enterOuterAlt(localctx, 4);
          this.state = 109;
          this.match(FHIRPathParser.T__35);
          break;
        case 5:
          localctx = new TotalInvocationContext(this, localctx);
          this.enterOuterAlt(localctx, 5);
          this.state = 110;
          this.match(FHIRPathParser.T__36);
          break;
      }
    } catch (re) {
      if (re instanceof antlr4.error.RecognitionException) {
        localctx.exception = re;
        this._errHandler.reportError(this, re);
        this._errHandler.recover(this, re);
      } else {
        throw re;
      }
    } finally {
      this.exitRule();
    }
    return localctx;
  }
  functn() {
    let localctx = new FunctnContext(this, this._ctx, this.state);
    this.enterRule(localctx, 12, FHIRPathParser.RULE_functn);
    var _la = 0; // Token type
    try {
      this.enterOuterAlt(localctx, 1);
      this.state = 113;
      this.identifier();
      this.state = 114;
      this.match(FHIRPathParser.T__27);
      this.state = 116;
      this._errHandler.sync(this);
      _la = this._input.LA(1);
      if ((_la & ~0x1f) == 0 && (1 << _la & (1 << FHIRPathParser.T__3 | 1 << FHIRPathParser.T__4 | 1 << FHIRPathParser.T__15 | 1 << FHIRPathParser.T__16 | 1 << FHIRPathParser.T__21 | 1 << FHIRPathParser.T__22 | 1 << FHIRPathParser.T__27 | 1 << FHIRPathParser.T__29)) !== 0 || (_la - 32 & ~0x1f) == 0 && (1 << _la - 32 & (1 << FHIRPathParser.T__31 - 32 | 1 << FHIRPathParser.T__32 - 32 | 1 << FHIRPathParser.T__33 - 32 | 1 << FHIRPathParser.T__34 - 32 | 1 << FHIRPathParser.T__35 - 32 | 1 << FHIRPathParser.T__36 - 32 | 1 << FHIRPathParser.DATETIME - 32 | 1 << FHIRPathParser.TIME - 32 | 1 << FHIRPathParser.IDENTIFIER - 32 | 1 << FHIRPathParser.DELIMITEDIDENTIFIER - 32 | 1 << FHIRPathParser.STRING - 32 | 1 << FHIRPathParser.NUMBER - 32)) !== 0) {
        this.state = 115;
        this.paramList();
      }
      this.state = 118;
      this.match(FHIRPathParser.T__28);
    } catch (re) {
      if (re instanceof antlr4.error.RecognitionException) {
        localctx.exception = re;
        this._errHandler.reportError(this, re);
        this._errHandler.recover(this, re);
      } else {
        throw re;
      }
    } finally {
      this.exitRule();
    }
    return localctx;
  }
  paramList() {
    let localctx = new ParamListContext(this, this._ctx, this.state);
    this.enterRule(localctx, 14, FHIRPathParser.RULE_paramList);
    var _la = 0; // Token type
    try {
      this.enterOuterAlt(localctx, 1);
      this.state = 120;
      this.expression(0);
      this.state = 125;
      this._errHandler.sync(this);
      _la = this._input.LA(1);
      while (_la === FHIRPathParser.T__37) {
        this.state = 121;
        this.match(FHIRPathParser.T__37);
        this.state = 122;
        this.expression(0);
        this.state = 127;
        this._errHandler.sync(this);
        _la = this._input.LA(1);
      }
    } catch (re) {
      if (re instanceof antlr4.error.RecognitionException) {
        localctx.exception = re;
        this._errHandler.reportError(this, re);
        this._errHandler.recover(this, re);
      } else {
        throw re;
      }
    } finally {
      this.exitRule();
    }
    return localctx;
  }
  quantity() {
    let localctx = new QuantityContext(this, this._ctx, this.state);
    this.enterRule(localctx, 16, FHIRPathParser.RULE_quantity);
    try {
      this.enterOuterAlt(localctx, 1);
      this.state = 128;
      this.match(FHIRPathParser.NUMBER);
      this.state = 130;
      this._errHandler.sync(this);
      var la_ = this._interp.adaptivePredict(this._input, 9, this._ctx);
      if (la_ === 1) {
        this.state = 129;
        this.unit();
      }
    } catch (re) {
      if (re instanceof antlr4.error.RecognitionException) {
        localctx.exception = re;
        this._errHandler.reportError(this, re);
        this._errHandler.recover(this, re);
      } else {
        throw re;
      }
    } finally {
      this.exitRule();
    }
    return localctx;
  }
  unit() {
    let localctx = new UnitContext(this, this._ctx, this.state);
    this.enterRule(localctx, 18, FHIRPathParser.RULE_unit);
    try {
      this.state = 135;
      this._errHandler.sync(this);
      switch (this._input.LA(1)) {
        case FHIRPathParser.T__38:
        case FHIRPathParser.T__39:
        case FHIRPathParser.T__40:
        case FHIRPathParser.T__41:
        case FHIRPathParser.T__42:
        case FHIRPathParser.T__43:
        case FHIRPathParser.T__44:
        case FHIRPathParser.T__45:
          this.enterOuterAlt(localctx, 1);
          this.state = 132;
          this.dateTimePrecision();
          break;
        case FHIRPathParser.T__46:
        case FHIRPathParser.T__47:
        case FHIRPathParser.T__48:
        case FHIRPathParser.T__49:
        case FHIRPathParser.T__50:
        case FHIRPathParser.T__51:
        case FHIRPathParser.T__52:
        case FHIRPathParser.T__53:
          this.enterOuterAlt(localctx, 2);
          this.state = 133;
          this.pluralDateTimePrecision();
          break;
        case FHIRPathParser.STRING:
          this.enterOuterAlt(localctx, 3);
          this.state = 134;
          this.match(FHIRPathParser.STRING);
          break;
        default:
          throw new antlr4.error.NoViableAltException(this);
      }
    } catch (re) {
      if (re instanceof antlr4.error.RecognitionException) {
        localctx.exception = re;
        this._errHandler.reportError(this, re);
        this._errHandler.recover(this, re);
      } else {
        throw re;
      }
    } finally {
      this.exitRule();
    }
    return localctx;
  }
  dateTimePrecision() {
    let localctx = new DateTimePrecisionContext(this, this._ctx, this.state);
    this.enterRule(localctx, 20, FHIRPathParser.RULE_dateTimePrecision);
    var _la = 0; // Token type
    try {
      this.enterOuterAlt(localctx, 1);
      this.state = 137;
      _la = this._input.LA(1);
      if (!((_la - 39 & ~0x1f) == 0 && (1 << _la - 39 & (1 << FHIRPathParser.T__38 - 39 | 1 << FHIRPathParser.T__39 - 39 | 1 << FHIRPathParser.T__40 - 39 | 1 << FHIRPathParser.T__41 - 39 | 1 << FHIRPathParser.T__42 - 39 | 1 << FHIRPathParser.T__43 - 39 | 1 << FHIRPathParser.T__44 - 39 | 1 << FHIRPathParser.T__45 - 39)) !== 0)) {
        this._errHandler.recoverInline(this);
      } else {
        this._errHandler.reportMatch(this);
        this.consume();
      }
    } catch (re) {
      if (re instanceof antlr4.error.RecognitionException) {
        localctx.exception = re;
        this._errHandler.reportError(this, re);
        this._errHandler.recover(this, re);
      } else {
        throw re;
      }
    } finally {
      this.exitRule();
    }
    return localctx;
  }
  pluralDateTimePrecision() {
    let localctx = new PluralDateTimePrecisionContext(this, this._ctx, this.state);
    this.enterRule(localctx, 22, FHIRPathParser.RULE_pluralDateTimePrecision);
    var _la = 0; // Token type
    try {
      this.enterOuterAlt(localctx, 1);
      this.state = 139;
      _la = this._input.LA(1);
      if (!((_la - 47 & ~0x1f) == 0 && (1 << _la - 47 & (1 << FHIRPathParser.T__46 - 47 | 1 << FHIRPathParser.T__47 - 47 | 1 << FHIRPathParser.T__48 - 47 | 1 << FHIRPathParser.T__49 - 47 | 1 << FHIRPathParser.T__50 - 47 | 1 << FHIRPathParser.T__51 - 47 | 1 << FHIRPathParser.T__52 - 47 | 1 << FHIRPathParser.T__53 - 47)) !== 0)) {
        this._errHandler.recoverInline(this);
      } else {
        this._errHandler.reportMatch(this);
        this.consume();
      }
    } catch (re) {
      if (re instanceof antlr4.error.RecognitionException) {
        localctx.exception = re;
        this._errHandler.reportError(this, re);
        this._errHandler.recover(this, re);
      } else {
        throw re;
      }
    } finally {
      this.exitRule();
    }
    return localctx;
  }
  typeSpecifier() {
    let localctx = new TypeSpecifierContext(this, this._ctx, this.state);
    this.enterRule(localctx, 24, FHIRPathParser.RULE_typeSpecifier);
    try {
      this.enterOuterAlt(localctx, 1);
      this.state = 141;
      this.qualifiedIdentifier();
    } catch (re) {
      if (re instanceof antlr4.error.RecognitionException) {
        localctx.exception = re;
        this._errHandler.reportError(this, re);
        this._errHandler.recover(this, re);
      } else {
        throw re;
      }
    } finally {
      this.exitRule();
    }
    return localctx;
  }
  qualifiedIdentifier() {
    let localctx = new QualifiedIdentifierContext(this, this._ctx, this.state);
    this.enterRule(localctx, 26, FHIRPathParser.RULE_qualifiedIdentifier);
    try {
      this.enterOuterAlt(localctx, 1);
      this.state = 143;
      this.identifier();
      this.state = 148;
      this._errHandler.sync(this);
      var _alt = this._interp.adaptivePredict(this._input, 11, this._ctx);
      while (_alt != 2 && _alt != antlr4.atn.ATN.INVALID_ALT_NUMBER) {
        if (_alt === 1) {
          this.state = 144;
          this.match(FHIRPathParser.T__0);
          this.state = 145;
          this.identifier();
        }
        this.state = 150;
        this._errHandler.sync(this);
        _alt = this._interp.adaptivePredict(this._input, 11, this._ctx);
      }
    } catch (re) {
      if (re instanceof antlr4.error.RecognitionException) {
        localctx.exception = re;
        this._errHandler.reportError(this, re);
        this._errHandler.recover(this, re);
      } else {
        throw re;
      }
    } finally {
      this.exitRule();
    }
    return localctx;
  }
  identifier() {
    let localctx = new IdentifierContext(this, this._ctx, this.state);
    this.enterRule(localctx, 28, FHIRPathParser.RULE_identifier);
    var _la = 0; // Token type
    try {
      this.enterOuterAlt(localctx, 1);
      this.state = 151;
      _la = this._input.LA(1);
      if (!((_la & ~0x1f) == 0 && (1 << _la & (1 << FHIRPathParser.T__15 | 1 << FHIRPathParser.T__16 | 1 << FHIRPathParser.T__21 | 1 << FHIRPathParser.T__22)) !== 0 || _la === FHIRPathParser.IDENTIFIER || _la === FHIRPathParser.DELIMITEDIDENTIFIER)) {
        this._errHandler.recoverInline(this);
      } else {
        this._errHandler.reportMatch(this);
        this.consume();
      }
    } catch (re) {
      if (re instanceof antlr4.error.RecognitionException) {
        localctx.exception = re;
        this._errHandler.reportError(this, re);
        this._errHandler.recover(this, re);
      } else {
        throw re;
      }
    } finally {
      this.exitRule();
    }
    return localctx;
  }
}
FHIRPathParser.EOF = antlr4.Token.EOF;
FHIRPathParser.T__0 = 1;
FHIRPathParser.T__1 = 2;
FHIRPathParser.T__2 = 3;
FHIRPathParser.T__3 = 4;
FHIRPathParser.T__4 = 5;
FHIRPathParser.T__5 = 6;
FHIRPathParser.T__6 = 7;
FHIRPathParser.T__7 = 8;
FHIRPathParser.T__8 = 9;
FHIRPathParser.T__9 = 10;
FHIRPathParser.T__10 = 11;
FHIRPathParser.T__11 = 12;
FHIRPathParser.T__12 = 13;
FHIRPathParser.T__13 = 14;
FHIRPathParser.T__14 = 15;
FHIRPathParser.T__15 = 16;
FHIRPathParser.T__16 = 17;
FHIRPathParser.T__17 = 18;
FHIRPathParser.T__18 = 19;
FHIRPathParser.T__19 = 20;
FHIRPathParser.T__20 = 21;
FHIRPathParser.T__21 = 22;
FHIRPathParser.T__22 = 23;
FHIRPathParser.T__23 = 24;
FHIRPathParser.T__24 = 25;
FHIRPathParser.T__25 = 26;
FHIRPathParser.T__26 = 27;
FHIRPathParser.T__27 = 28;
FHIRPathParser.T__28 = 29;
FHIRPathParser.T__29 = 30;
FHIRPathParser.T__30 = 31;
FHIRPathParser.T__31 = 32;
FHIRPathParser.T__32 = 33;
FHIRPathParser.T__33 = 34;
FHIRPathParser.T__34 = 35;
FHIRPathParser.T__35 = 36;
FHIRPathParser.T__36 = 37;
FHIRPathParser.T__37 = 38;
FHIRPathParser.T__38 = 39;
FHIRPathParser.T__39 = 40;
FHIRPathParser.T__40 = 41;
FHIRPathParser.T__41 = 42;
FHIRPathParser.T__42 = 43;
FHIRPathParser.T__43 = 44;
FHIRPathParser.T__44 = 45;
FHIRPathParser.T__45 = 46;
FHIRPathParser.T__46 = 47;
FHIRPathParser.T__47 = 48;
FHIRPathParser.T__48 = 49;
FHIRPathParser.T__49 = 50;
FHIRPathParser.T__50 = 51;
FHIRPathParser.T__51 = 52;
FHIRPathParser.T__52 = 53;
FHIRPathParser.T__53 = 54;
FHIRPathParser.DATETIME = 55;
FHIRPathParser.TIME = 56;
FHIRPathParser.IDENTIFIER = 57;
FHIRPathParser.DELIMITEDIDENTIFIER = 58;
FHIRPathParser.STRING = 59;
FHIRPathParser.NUMBER = 60;
FHIRPathParser.WS = 61;
FHIRPathParser.COMMENT = 62;
FHIRPathParser.LINE_COMMENT = 63;
FHIRPathParser.RULE_entireExpression = 0;
FHIRPathParser.RULE_expression = 1;
FHIRPathParser.RULE_term = 2;
FHIRPathParser.RULE_literal = 3;
FHIRPathParser.RULE_externalConstant = 4;
FHIRPathParser.RULE_invocation = 5;
FHIRPathParser.RULE_functn = 6;
FHIRPathParser.RULE_paramList = 7;
FHIRPathParser.RULE_quantity = 8;
FHIRPathParser.RULE_unit = 9;
FHIRPathParser.RULE_dateTimePrecision = 10;
FHIRPathParser.RULE_pluralDateTimePrecision = 11;
FHIRPathParser.RULE_typeSpecifier = 12;
FHIRPathParser.RULE_qualifiedIdentifier = 13;
FHIRPathParser.RULE_identifier = 14;
class EntireExpressionContext extends antlr4.ParserRuleContext {
  constructor(parser, parent, invokingState) {
    if (parent === undefined) {
      parent = null;
    }
    if (invokingState === undefined || invokingState === null) {
      invokingState = -1;
    }
    super(parent, invokingState);
    this.parser = parser;
    this.ruleIndex = FHIRPathParser.RULE_entireExpression;
  }
  expression() {
    return this.getTypedRuleContext(ExpressionContext, 0);
  }
  EOF() {
    return this.getToken(FHIRPathParser.EOF, 0);
  }
  enterRule(listener) {
    if (listener instanceof FHIRPathListener) {
      listener.enterEntireExpression(this);
    }
  }
  exitRule(listener) {
    if (listener instanceof FHIRPathListener) {
      listener.exitEntireExpression(this);
    }
  }
}
class ExpressionContext extends antlr4.ParserRuleContext {
  constructor(parser, parent, invokingState) {
    if (parent === undefined) {
      parent = null;
    }
    if (invokingState === undefined || invokingState === null) {
      invokingState = -1;
    }
    super(parent, invokingState);
    this.parser = parser;
    this.ruleIndex = FHIRPathParser.RULE_expression;
  }
  copyFrom(ctx) {
    super.copyFrom(ctx);
  }
}
class IndexerExpressionContext extends ExpressionContext {
  constructor(parser, ctx) {
    super(parser);
    super.copyFrom(ctx);
  }
  expression = function (i) {
    if (i === undefined) {
      i = null;
    }
    if (i === null) {
      return this.getTypedRuleContexts(ExpressionContext);
    } else {
      return this.getTypedRuleContext(ExpressionContext, i);
    }
  };
  enterRule(listener) {
    if (listener instanceof FHIRPathListener) {
      listener.enterIndexerExpression(this);
    }
  }
  exitRule(listener) {
    if (listener instanceof FHIRPathListener) {
      listener.exitIndexerExpression(this);
    }
  }
}
FHIRPathParser.IndexerExpressionContext = IndexerExpressionContext;
class PolarityExpressionContext extends ExpressionContext {
  constructor(parser, ctx) {
    super(parser);
    super.copyFrom(ctx);
  }
  expression() {
    return this.getTypedRuleContext(ExpressionContext, 0);
  }
  enterRule(listener) {
    if (listener instanceof FHIRPathListener) {
      listener.enterPolarityExpression(this);
    }
  }
  exitRule(listener) {
    if (listener instanceof FHIRPathListener) {
      listener.exitPolarityExpression(this);
    }
  }
}
FHIRPathParser.PolarityExpressionContext = PolarityExpressionContext;
class AdditiveExpressionContext extends ExpressionContext {
  constructor(parser, ctx) {
    super(parser);
    super.copyFrom(ctx);
  }
  expression = function (i) {
    if (i === undefined) {
      i = null;
    }
    if (i === null) {
      return this.getTypedRuleContexts(ExpressionContext);
    } else {
      return this.getTypedRuleContext(ExpressionContext, i);
    }
  };
  enterRule(listener) {
    if (listener instanceof FHIRPathListener) {
      listener.enterAdditiveExpression(this);
    }
  }
  exitRule(listener) {
    if (listener instanceof FHIRPathListener) {
      listener.exitAdditiveExpression(this);
    }
  }
}
FHIRPathParser.AdditiveExpressionContext = AdditiveExpressionContext;
class MultiplicativeExpressionContext extends ExpressionContext {
  constructor(parser, ctx) {
    super(parser);
    super.copyFrom(ctx);
  }
  expression = function (i) {
    if (i === undefined) {
      i = null;
    }
    if (i === null) {
      return this.getTypedRuleContexts(ExpressionContext);
    } else {
      return this.getTypedRuleContext(ExpressionContext, i);
    }
  };
  enterRule(listener) {
    if (listener instanceof FHIRPathListener) {
      listener.enterMultiplicativeExpression(this);
    }
  }
  exitRule(listener) {
    if (listener instanceof FHIRPathListener) {
      listener.exitMultiplicativeExpression(this);
    }
  }
}
FHIRPathParser.MultiplicativeExpressionContext = MultiplicativeExpressionContext;
class UnionExpressionContext extends ExpressionContext {
  constructor(parser, ctx) {
    super(parser);
    super.copyFrom(ctx);
  }
  expression = function (i) {
    if (i === undefined) {
      i = null;
    }
    if (i === null) {
      return this.getTypedRuleContexts(ExpressionContext);
    } else {
      return this.getTypedRuleContext(ExpressionContext, i);
    }
  };
  enterRule(listener) {
    if (listener instanceof FHIRPathListener) {
      listener.enterUnionExpression(this);
    }
  }
  exitRule(listener) {
    if (listener instanceof FHIRPathListener) {
      listener.exitUnionExpression(this);
    }
  }
}
FHIRPathParser.UnionExpressionContext = UnionExpressionContext;
class OrExpressionContext extends ExpressionContext {
  constructor(parser, ctx) {
    super(parser);
    super.copyFrom(ctx);
  }
  expression = function (i) {
    if (i === undefined) {
      i = null;
    }
    if (i === null) {
      return this.getTypedRuleContexts(ExpressionContext);
    } else {
      return this.getTypedRuleContext(ExpressionContext, i);
    }
  };
  enterRule(listener) {
    if (listener instanceof FHIRPathListener) {
      listener.enterOrExpression(this);
    }
  }
  exitRule(listener) {
    if (listener instanceof FHIRPathListener) {
      listener.exitOrExpression(this);
    }
  }
}
FHIRPathParser.OrExpressionContext = OrExpressionContext;
class AndExpressionContext extends ExpressionContext {
  constructor(parser, ctx) {
    super(parser);
    super.copyFrom(ctx);
  }
  expression = function (i) {
    if (i === undefined) {
      i = null;
    }
    if (i === null) {
      return this.getTypedRuleContexts(ExpressionContext);
    } else {
      return this.getTypedRuleContext(ExpressionContext, i);
    }
  };
  enterRule(listener) {
    if (listener instanceof FHIRPathListener) {
      listener.enterAndExpression(this);
    }
  }
  exitRule(listener) {
    if (listener instanceof FHIRPathListener) {
      listener.exitAndExpression(this);
    }
  }
}
FHIRPathParser.AndExpressionContext = AndExpressionContext;
class MembershipExpressionContext extends ExpressionContext {
  constructor(parser, ctx) {
    super(parser);
    super.copyFrom(ctx);
  }
  expression = function (i) {
    if (i === undefined) {
      i = null;
    }
    if (i === null) {
      return this.getTypedRuleContexts(ExpressionContext);
    } else {
      return this.getTypedRuleContext(ExpressionContext, i);
    }
  };
  enterRule(listener) {
    if (listener instanceof FHIRPathListener) {
      listener.enterMembershipExpression(this);
    }
  }
  exitRule(listener) {
    if (listener instanceof FHIRPathListener) {
      listener.exitMembershipExpression(this);
    }
  }
}
FHIRPathParser.MembershipExpressionContext = MembershipExpressionContext;
class InequalityExpressionContext extends ExpressionContext {
  constructor(parser, ctx) {
    super(parser);
    super.copyFrom(ctx);
  }
  expression = function (i) {
    if (i === undefined) {
      i = null;
    }
    if (i === null) {
      return this.getTypedRuleContexts(ExpressionContext);
    } else {
      return this.getTypedRuleContext(ExpressionContext, i);
    }
  };
  enterRule(listener) {
    if (listener instanceof FHIRPathListener) {
      listener.enterInequalityExpression(this);
    }
  }
  exitRule(listener) {
    if (listener instanceof FHIRPathListener) {
      listener.exitInequalityExpression(this);
    }
  }
}
FHIRPathParser.InequalityExpressionContext = InequalityExpressionContext;
class InvocationExpressionContext extends ExpressionContext {
  constructor(parser, ctx) {
    super(parser);
    super.copyFrom(ctx);
  }
  expression() {
    return this.getTypedRuleContext(ExpressionContext, 0);
  }
  invocation() {
    return this.getTypedRuleContext(InvocationContext, 0);
  }
  enterRule(listener) {
    if (listener instanceof FHIRPathListener) {
      listener.enterInvocationExpression(this);
    }
  }
  exitRule(listener) {
    if (listener instanceof FHIRPathListener) {
      listener.exitInvocationExpression(this);
    }
  }
}
FHIRPathParser.InvocationExpressionContext = InvocationExpressionContext;
class EqualityExpressionContext extends ExpressionContext {
  constructor(parser, ctx) {
    super(parser);
    super.copyFrom(ctx);
  }
  expression = function (i) {
    if (i === undefined) {
      i = null;
    }
    if (i === null) {
      return this.getTypedRuleContexts(ExpressionContext);
    } else {
      return this.getTypedRuleContext(ExpressionContext, i);
    }
  };
  enterRule(listener) {
    if (listener instanceof FHIRPathListener) {
      listener.enterEqualityExpression(this);
    }
  }
  exitRule(listener) {
    if (listener instanceof FHIRPathListener) {
      listener.exitEqualityExpression(this);
    }
  }
}
FHIRPathParser.EqualityExpressionContext = EqualityExpressionContext;
class ImpliesExpressionContext extends ExpressionContext {
  constructor(parser, ctx) {
    super(parser);
    super.copyFrom(ctx);
  }
  expression = function (i) {
    if (i === undefined) {
      i = null;
    }
    if (i === null) {
      return this.getTypedRuleContexts(ExpressionContext);
    } else {
      return this.getTypedRuleContext(ExpressionContext, i);
    }
  };
  enterRule(listener) {
    if (listener instanceof FHIRPathListener) {
      listener.enterImpliesExpression(this);
    }
  }
  exitRule(listener) {
    if (listener instanceof FHIRPathListener) {
      listener.exitImpliesExpression(this);
    }
  }
}
FHIRPathParser.ImpliesExpressionContext = ImpliesExpressionContext;
class TermExpressionContext extends ExpressionContext {
  constructor(parser, ctx) {
    super(parser);
    super.copyFrom(ctx);
  }
  term() {
    return this.getTypedRuleContext(TermContext, 0);
  }
  enterRule(listener) {
    if (listener instanceof FHIRPathListener) {
      listener.enterTermExpression(this);
    }
  }
  exitRule(listener) {
    if (listener instanceof FHIRPathListener) {
      listener.exitTermExpression(this);
    }
  }
}
FHIRPathParser.TermExpressionContext = TermExpressionContext;
class TypeExpressionContext extends ExpressionContext {
  constructor(parser, ctx) {
    super(parser);
    super.copyFrom(ctx);
  }
  expression() {
    return this.getTypedRuleContext(ExpressionContext, 0);
  }
  typeSpecifier() {
    return this.getTypedRuleContext(TypeSpecifierContext, 0);
  }
  enterRule(listener) {
    if (listener instanceof FHIRPathListener) {
      listener.enterTypeExpression(this);
    }
  }
  exitRule(listener) {
    if (listener instanceof FHIRPathListener) {
      listener.exitTypeExpression(this);
    }
  }
}
FHIRPathParser.TypeExpressionContext = TypeExpressionContext;
class TermContext extends antlr4.ParserRuleContext {
  constructor(parser, parent, invokingState) {
    if (parent === undefined) {
      parent = null;
    }
    if (invokingState === undefined || invokingState === null) {
      invokingState = -1;
    }
    super(parent, invokingState);
    this.parser = parser;
    this.ruleIndex = FHIRPathParser.RULE_term;
  }
  copyFrom(ctx) {
    super.copyFrom(ctx);
  }
}
class ExternalConstantTermContext extends TermContext {
  constructor(parser, ctx) {
    super(parser);
    super.copyFrom(ctx);
  }
  externalConstant() {
    return this.getTypedRuleContext(ExternalConstantContext, 0);
  }
  enterRule(listener) {
    if (listener instanceof FHIRPathListener) {
      listener.enterExternalConstantTerm(this);
    }
  }
  exitRule(listener) {
    if (listener instanceof FHIRPathListener) {
      listener.exitExternalConstantTerm(this);
    }
  }
}
FHIRPathParser.ExternalConstantTermContext = ExternalConstantTermContext;
class LiteralTermContext extends TermContext {
  constructor(parser, ctx) {
    super(parser);
    super.copyFrom(ctx);
  }
  literal() {
    return this.getTypedRuleContext(LiteralContext, 0);
  }
  enterRule(listener) {
    if (listener instanceof FHIRPathListener) {
      listener.enterLiteralTerm(this);
    }
  }
  exitRule(listener) {
    if (listener instanceof FHIRPathListener) {
      listener.exitLiteralTerm(this);
    }
  }
}
FHIRPathParser.LiteralTermContext = LiteralTermContext;
class ParenthesizedTermContext extends TermContext {
  constructor(parser, ctx) {
    super(parser);
    super.copyFrom(ctx);
  }
  expression() {
    return this.getTypedRuleContext(ExpressionContext, 0);
  }
  enterRule(listener) {
    if (listener instanceof FHIRPathListener) {
      listener.enterParenthesizedTerm(this);
    }
  }
  exitRule(listener) {
    if (listener instanceof FHIRPathListener) {
      listener.exitParenthesizedTerm(this);
    }
  }
}
FHIRPathParser.ParenthesizedTermContext = ParenthesizedTermContext;
class InvocationTermContext extends TermContext {
  constructor(parser, ctx) {
    super(parser);
    super.copyFrom(ctx);
  }
  invocation() {
    return this.getTypedRuleContext(InvocationContext, 0);
  }
  enterRule(listener) {
    if (listener instanceof FHIRPathListener) {
      listener.enterInvocationTerm(this);
    }
  }
  exitRule(listener) {
    if (listener instanceof FHIRPathListener) {
      listener.exitInvocationTerm(this);
    }
  }
}
FHIRPathParser.InvocationTermContext = InvocationTermContext;
class LiteralContext extends antlr4.ParserRuleContext {
  constructor(parser, parent, invokingState) {
    if (parent === undefined) {
      parent = null;
    }
    if (invokingState === undefined || invokingState === null) {
      invokingState = -1;
    }
    super(parent, invokingState);
    this.parser = parser;
    this.ruleIndex = FHIRPathParser.RULE_literal;
  }
  copyFrom(ctx) {
    super.copyFrom(ctx);
  }
}
class TimeLiteralContext extends LiteralContext {
  constructor(parser, ctx) {
    super(parser);
    super.copyFrom(ctx);
  }
  TIME() {
    return this.getToken(FHIRPathParser.TIME, 0);
  }
  enterRule(listener) {
    if (listener instanceof FHIRPathListener) {
      listener.enterTimeLiteral(this);
    }
  }
  exitRule(listener) {
    if (listener instanceof FHIRPathListener) {
      listener.exitTimeLiteral(this);
    }
  }
}
FHIRPathParser.TimeLiteralContext = TimeLiteralContext;
class NullLiteralContext extends LiteralContext {
  constructor(parser, ctx) {
    super(parser);
    super.copyFrom(ctx);
  }
  enterRule(listener) {
    if (listener instanceof FHIRPathListener) {
      listener.enterNullLiteral(this);
    }
  }
  exitRule(listener) {
    if (listener instanceof FHIRPathListener) {
      listener.exitNullLiteral(this);
    }
  }
}
FHIRPathParser.NullLiteralContext = NullLiteralContext;
class DateTimeLiteralContext extends LiteralContext {
  constructor(parser, ctx) {
    super(parser);
    super.copyFrom(ctx);
  }
  DATETIME() {
    return this.getToken(FHIRPathParser.DATETIME, 0);
  }
  enterRule(listener) {
    if (listener instanceof FHIRPathListener) {
      listener.enterDateTimeLiteral(this);
    }
  }
  exitRule(listener) {
    if (listener instanceof FHIRPathListener) {
      listener.exitDateTimeLiteral(this);
    }
  }
}
FHIRPathParser.DateTimeLiteralContext = DateTimeLiteralContext;
class StringLiteralContext extends LiteralContext {
  constructor(parser, ctx) {
    super(parser);
    super.copyFrom(ctx);
  }
  STRING() {
    return this.getToken(FHIRPathParser.STRING, 0);
  }
  enterRule(listener) {
    if (listener instanceof FHIRPathListener) {
      listener.enterStringLiteral(this);
    }
  }
  exitRule(listener) {
    if (listener instanceof FHIRPathListener) {
      listener.exitStringLiteral(this);
    }
  }
}
FHIRPathParser.StringLiteralContext = StringLiteralContext;
class BooleanLiteralContext extends LiteralContext {
  constructor(parser, ctx) {
    super(parser);
    super.copyFrom(ctx);
  }
  enterRule(listener) {
    if (listener instanceof FHIRPathListener) {
      listener.enterBooleanLiteral(this);
    }
  }
  exitRule(listener) {
    if (listener instanceof FHIRPathListener) {
      listener.exitBooleanLiteral(this);
    }
  }
}
FHIRPathParser.BooleanLiteralContext = BooleanLiteralContext;
class NumberLiteralContext extends LiteralContext {
  constructor(parser, ctx) {
    super(parser);
    super.copyFrom(ctx);
  }
  NUMBER() {
    return this.getToken(FHIRPathParser.NUMBER, 0);
  }
  enterRule(listener) {
    if (listener instanceof FHIRPathListener) {
      listener.enterNumberLiteral(this);
    }
  }
  exitRule(listener) {
    if (listener instanceof FHIRPathListener) {
      listener.exitNumberLiteral(this);
    }
  }
}
FHIRPathParser.NumberLiteralContext = NumberLiteralContext;
class QuantityLiteralContext extends LiteralContext {
  constructor(parser, ctx) {
    super(parser);
    super.copyFrom(ctx);
  }
  quantity() {
    return this.getTypedRuleContext(QuantityContext, 0);
  }
  enterRule(listener) {
    if (listener instanceof FHIRPathListener) {
      listener.enterQuantityLiteral(this);
    }
  }
  exitRule(listener) {
    if (listener instanceof FHIRPathListener) {
      listener.exitQuantityLiteral(this);
    }
  }
}
FHIRPathParser.QuantityLiteralContext = QuantityLiteralContext;
class ExternalConstantContext extends antlr4.ParserRuleContext {
  constructor(parser, parent, invokingState) {
    if (parent === undefined) {
      parent = null;
    }
    if (invokingState === undefined || invokingState === null) {
      invokingState = -1;
    }
    super(parent, invokingState);
    this.parser = parser;
    this.ruleIndex = FHIRPathParser.RULE_externalConstant;
  }
  identifier() {
    return this.getTypedRuleContext(IdentifierContext, 0);
  }
  STRING() {
    return this.getToken(FHIRPathParser.STRING, 0);
  }
  enterRule(listener) {
    if (listener instanceof FHIRPathListener) {
      listener.enterExternalConstant(this);
    }
  }
  exitRule(listener) {
    if (listener instanceof FHIRPathListener) {
      listener.exitExternalConstant(this);
    }
  }
}
class InvocationContext extends antlr4.ParserRuleContext {
  constructor(parser, parent, invokingState) {
    if (parent === undefined) {
      parent = null;
    }
    if (invokingState === undefined || invokingState === null) {
      invokingState = -1;
    }
    super(parent, invokingState);
    this.parser = parser;
    this.ruleIndex = FHIRPathParser.RULE_invocation;
  }
  copyFrom(ctx) {
    super.copyFrom(ctx);
  }
}
class TotalInvocationContext extends InvocationContext {
  constructor(parser, ctx) {
    super(parser);
    super.copyFrom(ctx);
  }
  enterRule(listener) {
    if (listener instanceof FHIRPathListener) {
      listener.enterTotalInvocation(this);
    }
  }
  exitRule(listener) {
    if (listener instanceof FHIRPathListener) {
      listener.exitTotalInvocation(this);
    }
  }
}
FHIRPathParser.TotalInvocationContext = TotalInvocationContext;
class ThisInvocationContext extends InvocationContext {
  constructor(parser, ctx) {
    super(parser);
    super.copyFrom(ctx);
  }
  enterRule(listener) {
    if (listener instanceof FHIRPathListener) {
      listener.enterThisInvocation(this);
    }
  }
  exitRule(listener) {
    if (listener instanceof FHIRPathListener) {
      listener.exitThisInvocation(this);
    }
  }
}
FHIRPathParser.ThisInvocationContext = ThisInvocationContext;
class IndexInvocationContext extends InvocationContext {
  constructor(parser, ctx) {
    super(parser);
    super.copyFrom(ctx);
  }
  enterRule(listener) {
    if (listener instanceof FHIRPathListener) {
      listener.enterIndexInvocation(this);
    }
  }
  exitRule(listener) {
    if (listener instanceof FHIRPathListener) {
      listener.exitIndexInvocation(this);
    }
  }
}
FHIRPathParser.IndexInvocationContext = IndexInvocationContext;
class FunctionInvocationContext extends InvocationContext {
  constructor(parser, ctx) {
    super(parser);
    super.copyFrom(ctx);
  }
  functn() {
    return this.getTypedRuleContext(FunctnContext, 0);
  }
  enterRule(listener) {
    if (listener instanceof FHIRPathListener) {
      listener.enterFunctionInvocation(this);
    }
  }
  exitRule(listener) {
    if (listener instanceof FHIRPathListener) {
      listener.exitFunctionInvocation(this);
    }
  }
}
FHIRPathParser.FunctionInvocationContext = FunctionInvocationContext;
class MemberInvocationContext extends InvocationContext {
  constructor(parser, ctx) {
    super(parser);
    super.copyFrom(ctx);
  }
  identifier() {
    return this.getTypedRuleContext(IdentifierContext, 0);
  }
  enterRule(listener) {
    if (listener instanceof FHIRPathListener) {
      listener.enterMemberInvocation(this);
    }
  }
  exitRule(listener) {
    if (listener instanceof FHIRPathListener) {
      listener.exitMemberInvocation(this);
    }
  }
}
FHIRPathParser.MemberInvocationContext = MemberInvocationContext;
class FunctnContext extends antlr4.ParserRuleContext {
  constructor(parser, parent, invokingState) {
    if (parent === undefined) {
      parent = null;
    }
    if (invokingState === undefined || invokingState === null) {
      invokingState = -1;
    }
    super(parent, invokingState);
    this.parser = parser;
    this.ruleIndex = FHIRPathParser.RULE_functn;
  }
  identifier() {
    return this.getTypedRuleContext(IdentifierContext, 0);
  }
  paramList() {
    return this.getTypedRuleContext(ParamListContext, 0);
  }
  enterRule(listener) {
    if (listener instanceof FHIRPathListener) {
      listener.enterFunctn(this);
    }
  }
  exitRule(listener) {
    if (listener instanceof FHIRPathListener) {
      listener.exitFunctn(this);
    }
  }
}
class ParamListContext extends antlr4.ParserRuleContext {
  constructor(parser, parent, invokingState) {
    if (parent === undefined) {
      parent = null;
    }
    if (invokingState === undefined || invokingState === null) {
      invokingState = -1;
    }
    super(parent, invokingState);
    this.parser = parser;
    this.ruleIndex = FHIRPathParser.RULE_paramList;
  }
  expression = function (i) {
    if (i === undefined) {
      i = null;
    }
    if (i === null) {
      return this.getTypedRuleContexts(ExpressionContext);
    } else {
      return this.getTypedRuleContext(ExpressionContext, i);
    }
  };
  enterRule(listener) {
    if (listener instanceof FHIRPathListener) {
      listener.enterParamList(this);
    }
  }
  exitRule(listener) {
    if (listener instanceof FHIRPathListener) {
      listener.exitParamList(this);
    }
  }
}
class QuantityContext extends antlr4.ParserRuleContext {
  constructor(parser, parent, invokingState) {
    if (parent === undefined) {
      parent = null;
    }
    if (invokingState === undefined || invokingState === null) {
      invokingState = -1;
    }
    super(parent, invokingState);
    this.parser = parser;
    this.ruleIndex = FHIRPathParser.RULE_quantity;
  }
  NUMBER() {
    return this.getToken(FHIRPathParser.NUMBER, 0);
  }
  unit() {
    return this.getTypedRuleContext(UnitContext, 0);
  }
  enterRule(listener) {
    if (listener instanceof FHIRPathListener) {
      listener.enterQuantity(this);
    }
  }
  exitRule(listener) {
    if (listener instanceof FHIRPathListener) {
      listener.exitQuantity(this);
    }
  }
}
class UnitContext extends antlr4.ParserRuleContext {
  constructor(parser, parent, invokingState) {
    if (parent === undefined) {
      parent = null;
    }
    if (invokingState === undefined || invokingState === null) {
      invokingState = -1;
    }
    super(parent, invokingState);
    this.parser = parser;
    this.ruleIndex = FHIRPathParser.RULE_unit;
  }
  dateTimePrecision() {
    return this.getTypedRuleContext(DateTimePrecisionContext, 0);
  }
  pluralDateTimePrecision() {
    return this.getTypedRuleContext(PluralDateTimePrecisionContext, 0);
  }
  STRING() {
    return this.getToken(FHIRPathParser.STRING, 0);
  }
  enterRule(listener) {
    if (listener instanceof FHIRPathListener) {
      listener.enterUnit(this);
    }
  }
  exitRule(listener) {
    if (listener instanceof FHIRPathListener) {
      listener.exitUnit(this);
    }
  }
}
class DateTimePrecisionContext extends antlr4.ParserRuleContext {
  constructor(parser, parent, invokingState) {
    if (parent === undefined) {
      parent = null;
    }
    if (invokingState === undefined || invokingState === null) {
      invokingState = -1;
    }
    super(parent, invokingState);
    this.parser = parser;
    this.ruleIndex = FHIRPathParser.RULE_dateTimePrecision;
  }
  enterRule(listener) {
    if (listener instanceof FHIRPathListener) {
      listener.enterDateTimePrecision(this);
    }
  }
  exitRule(listener) {
    if (listener instanceof FHIRPathListener) {
      listener.exitDateTimePrecision(this);
    }
  }
}
class PluralDateTimePrecisionContext extends antlr4.ParserRuleContext {
  constructor(parser, parent, invokingState) {
    if (parent === undefined) {
      parent = null;
    }
    if (invokingState === undefined || invokingState === null) {
      invokingState = -1;
    }
    super(parent, invokingState);
    this.parser = parser;
    this.ruleIndex = FHIRPathParser.RULE_pluralDateTimePrecision;
  }
  enterRule(listener) {
    if (listener instanceof FHIRPathListener) {
      listener.enterPluralDateTimePrecision(this);
    }
  }
  exitRule(listener) {
    if (listener instanceof FHIRPathListener) {
      listener.exitPluralDateTimePrecision(this);
    }
  }
}
class TypeSpecifierContext extends antlr4.ParserRuleContext {
  constructor(parser, parent, invokingState) {
    if (parent === undefined) {
      parent = null;
    }
    if (invokingState === undefined || invokingState === null) {
      invokingState = -1;
    }
    super(parent, invokingState);
    this.parser = parser;
    this.ruleIndex = FHIRPathParser.RULE_typeSpecifier;
  }
  qualifiedIdentifier() {
    return this.getTypedRuleContext(QualifiedIdentifierContext, 0);
  }
  enterRule(listener) {
    if (listener instanceof FHIRPathListener) {
      listener.enterTypeSpecifier(this);
    }
  }
  exitRule(listener) {
    if (listener instanceof FHIRPathListener) {
      listener.exitTypeSpecifier(this);
    }
  }
}
class QualifiedIdentifierContext extends antlr4.ParserRuleContext {
  constructor(parser, parent, invokingState) {
    if (parent === undefined) {
      parent = null;
    }
    if (invokingState === undefined || invokingState === null) {
      invokingState = -1;
    }
    super(parent, invokingState);
    this.parser = parser;
    this.ruleIndex = FHIRPathParser.RULE_qualifiedIdentifier;
  }
  identifier = function (i) {
    if (i === undefined) {
      i = null;
    }
    if (i === null) {
      return this.getTypedRuleContexts(IdentifierContext);
    } else {
      return this.getTypedRuleContext(IdentifierContext, i);
    }
  };
  enterRule(listener) {
    if (listener instanceof FHIRPathListener) {
      listener.enterQualifiedIdentifier(this);
    }
  }
  exitRule(listener) {
    if (listener instanceof FHIRPathListener) {
      listener.exitQualifiedIdentifier(this);
    }
  }
}
class IdentifierContext extends antlr4.ParserRuleContext {
  constructor(parser, parent, invokingState) {
    if (parent === undefined) {
      parent = null;
    }
    if (invokingState === undefined || invokingState === null) {
      invokingState = -1;
    }
    super(parent, invokingState);
    this.parser = parser;
    this.ruleIndex = FHIRPathParser.RULE_identifier;
  }
  IDENTIFIER() {
    return this.getToken(FHIRPathParser.IDENTIFIER, 0);
  }
  DELIMITEDIDENTIFIER() {
    return this.getToken(FHIRPathParser.DELIMITEDIDENTIFIER, 0);
  }
  enterRule(listener) {
    if (listener instanceof FHIRPathListener) {
      listener.enterIdentifier(this);
    }
  }
  exitRule(listener) {
    if (listener instanceof FHIRPathListener) {
      listener.exitIdentifier(this);
    }
  }
}
FHIRPathParser.EntireExpressionContext = EntireExpressionContext;
FHIRPathParser.ExpressionContext = ExpressionContext;
FHIRPathParser.TermContext = TermContext;
FHIRPathParser.LiteralContext = LiteralContext;
FHIRPathParser.ExternalConstantContext = ExternalConstantContext;
FHIRPathParser.InvocationContext = InvocationContext;
FHIRPathParser.FunctnContext = FunctnContext;
FHIRPathParser.ParamListContext = ParamListContext;
FHIRPathParser.QuantityContext = QuantityContext;
FHIRPathParser.UnitContext = UnitContext;
FHIRPathParser.DateTimePrecisionContext = DateTimePrecisionContext;
FHIRPathParser.PluralDateTimePrecisionContext = PluralDateTimePrecisionContext;
FHIRPathParser.TypeSpecifierContext = TypeSpecifierContext;
FHIRPathParser.QualifiedIdentifierContext = QualifiedIdentifierContext;
FHIRPathParser.IdentifierContext = IdentifierContext;
module.exports = FHIRPathParser;

/***/ }),
/* 52 */
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

// Generated from FHIRPath.g4 by ANTLR 4.9.3
// jshint ignore: start
const antlr4 = __webpack_require__(5);

// This class defines a complete listener for a parse tree produced by FHIRPathParser.
class FHIRPathListener extends antlr4.tree.ParseTreeListener {
  // Enter a parse tree produced by FHIRPathParser#entireExpression.
  enterEntireExpression(ctx) {}

  // Exit a parse tree produced by FHIRPathParser#entireExpression.
  exitEntireExpression(ctx) {}

  // Enter a parse tree produced by FHIRPathParser#indexerExpression.
  enterIndexerExpression(ctx) {}

  // Exit a parse tree produced by FHIRPathParser#indexerExpression.
  exitIndexerExpression(ctx) {}

  // Enter a parse tree produced by FHIRPathParser#polarityExpression.
  enterPolarityExpression(ctx) {}

  // Exit a parse tree produced by FHIRPathParser#polarityExpression.
  exitPolarityExpression(ctx) {}

  // Enter a parse tree produced by FHIRPathParser#additiveExpression.
  enterAdditiveExpression(ctx) {}

  // Exit a parse tree produced by FHIRPathParser#additiveExpression.
  exitAdditiveExpression(ctx) {}

  // Enter a parse tree produced by FHIRPathParser#multiplicativeExpression.
  enterMultiplicativeExpression(ctx) {}

  // Exit a parse tree produced by FHIRPathParser#multiplicativeExpression.
  exitMultiplicativeExpression(ctx) {}

  // Enter a parse tree produced by FHIRPathParser#unionExpression.
  enterUnionExpression(ctx) {}

  // Exit a parse tree produced by FHIRPathParser#unionExpression.
  exitUnionExpression(ctx) {}

  // Enter a parse tree produced by FHIRPathParser#orExpression.
  enterOrExpression(ctx) {}

  // Exit a parse tree produced by FHIRPathParser#orExpression.
  exitOrExpression(ctx) {}

  // Enter a parse tree produced by FHIRPathParser#andExpression.
  enterAndExpression(ctx) {}

  // Exit a parse tree produced by FHIRPathParser#andExpression.
  exitAndExpression(ctx) {}

  // Enter a parse tree produced by FHIRPathParser#membershipExpression.
  enterMembershipExpression(ctx) {}

  // Exit a parse tree produced by FHIRPathParser#membershipExpression.
  exitMembershipExpression(ctx) {}

  // Enter a parse tree produced by FHIRPathParser#inequalityExpression.
  enterInequalityExpression(ctx) {}

  // Exit a parse tree produced by FHIRPathParser#inequalityExpression.
  exitInequalityExpression(ctx) {}

  // Enter a parse tree produced by FHIRPathParser#invocationExpression.
  enterInvocationExpression(ctx) {}

  // Exit a parse tree produced by FHIRPathParser#invocationExpression.
  exitInvocationExpression(ctx) {}

  // Enter a parse tree produced by FHIRPathParser#equalityExpression.
  enterEqualityExpression(ctx) {}

  // Exit a parse tree produced by FHIRPathParser#equalityExpression.
  exitEqualityExpression(ctx) {}

  // Enter a parse tree produced by FHIRPathParser#impliesExpression.
  enterImpliesExpression(ctx) {}

  // Exit a parse tree produced by FHIRPathParser#impliesExpression.
  exitImpliesExpression(ctx) {}

  // Enter a parse tree produced by FHIRPathParser#termExpression.
  enterTermExpression(ctx) {}

  // Exit a parse tree produced by FHIRPathParser#termExpression.
  exitTermExpression(ctx) {}

  // Enter a parse tree produced by FHIRPathParser#typeExpression.
  enterTypeExpression(ctx) {}

  // Exit a parse tree produced by FHIRPathParser#typeExpression.
  exitTypeExpression(ctx) {}

  // Enter a parse tree produced by FHIRPathParser#invocationTerm.
  enterInvocationTerm(ctx) {}

  // Exit a parse tree produced by FHIRPathParser#invocationTerm.
  exitInvocationTerm(ctx) {}

  // Enter a parse tree produced by FHIRPathParser#literalTerm.
  enterLiteralTerm(ctx) {}

  // Exit a parse tree produced by FHIRPathParser#literalTerm.
  exitLiteralTerm(ctx) {}

  // Enter a parse tree produced by FHIRPathParser#externalConstantTerm.
  enterExternalConstantTerm(ctx) {}

  // Exit a parse tree produced by FHIRPathParser#externalConstantTerm.
  exitExternalConstantTerm(ctx) {}

  // Enter a parse tree produced by FHIRPathParser#parenthesizedTerm.
  enterParenthesizedTerm(ctx) {}

  // Exit a parse tree produced by FHIRPathParser#parenthesizedTerm.
  exitParenthesizedTerm(ctx) {}

  // Enter a parse tree produced by FHIRPathParser#nullLiteral.
  enterNullLiteral(ctx) {}

  // Exit a parse tree produced by FHIRPathParser#nullLiteral.
  exitNullLiteral(ctx) {}

  // Enter a parse tree produced by FHIRPathParser#booleanLiteral.
  enterBooleanLiteral(ctx) {}

  // Exit a parse tree produced by FHIRPathParser#booleanLiteral.
  exitBooleanLiteral(ctx) {}

  // Enter a parse tree produced by FHIRPathParser#stringLiteral.
  enterStringLiteral(ctx) {}

  // Exit a parse tree produced by FHIRPathParser#stringLiteral.
  exitStringLiteral(ctx) {}

  // Enter a parse tree produced by FHIRPathParser#numberLiteral.
  enterNumberLiteral(ctx) {}

  // Exit a parse tree produced by FHIRPathParser#numberLiteral.
  exitNumberLiteral(ctx) {}

  // Enter a parse tree produced by FHIRPathParser#dateTimeLiteral.
  enterDateTimeLiteral(ctx) {}

  // Exit a parse tree produced by FHIRPathParser#dateTimeLiteral.
  exitDateTimeLiteral(ctx) {}

  // Enter a parse tree produced by FHIRPathParser#timeLiteral.
  enterTimeLiteral(ctx) {}

  // Exit a parse tree produced by FHIRPathParser#timeLiteral.
  exitTimeLiteral(ctx) {}

  // Enter a parse tree produced by FHIRPathParser#quantityLiteral.
  enterQuantityLiteral(ctx) {}

  // Exit a parse tree produced by FHIRPathParser#quantityLiteral.
  exitQuantityLiteral(ctx) {}

  // Enter a parse tree produced by FHIRPathParser#externalConstant.
  enterExternalConstant(ctx) {}

  // Exit a parse tree produced by FHIRPathParser#externalConstant.
  exitExternalConstant(ctx) {}

  // Enter a parse tree produced by FHIRPathParser#memberInvocation.
  enterMemberInvocation(ctx) {}

  // Exit a parse tree produced by FHIRPathParser#memberInvocation.
  exitMemberInvocation(ctx) {}

  // Enter a parse tree produced by FHIRPathParser#functionInvocation.
  enterFunctionInvocation(ctx) {}

  // Exit a parse tree produced by FHIRPathParser#functionInvocation.
  exitFunctionInvocation(ctx) {}

  // Enter a parse tree produced by FHIRPathParser#thisInvocation.
  enterThisInvocation(ctx) {}

  // Exit a parse tree produced by FHIRPathParser#thisInvocation.
  exitThisInvocation(ctx) {}

  // Enter a parse tree produced by FHIRPathParser#indexInvocation.
  enterIndexInvocation(ctx) {}

  // Exit a parse tree produced by FHIRPathParser#indexInvocation.
  exitIndexInvocation(ctx) {}

  // Enter a parse tree produced by FHIRPathParser#totalInvocation.
  enterTotalInvocation(ctx) {}

  // Exit a parse tree produced by FHIRPathParser#totalInvocation.
  exitTotalInvocation(ctx) {}

  // Enter a parse tree produced by FHIRPathParser#functn.
  enterFunctn(ctx) {}

  // Exit a parse tree produced by FHIRPathParser#functn.
  exitFunctn(ctx) {}

  // Enter a parse tree produced by FHIRPathParser#paramList.
  enterParamList(ctx) {}

  // Exit a parse tree produced by FHIRPathParser#paramList.
  exitParamList(ctx) {}

  // Enter a parse tree produced by FHIRPathParser#quantity.
  enterQuantity(ctx) {}

  // Exit a parse tree produced by FHIRPathParser#quantity.
  exitQuantity(ctx) {}

  // Enter a parse tree produced by FHIRPathParser#unit.
  enterUnit(ctx) {}

  // Exit a parse tree produced by FHIRPathParser#unit.
  exitUnit(ctx) {}

  // Enter a parse tree produced by FHIRPathParser#dateTimePrecision.
  enterDateTimePrecision(ctx) {}

  // Exit a parse tree produced by FHIRPathParser#dateTimePrecision.
  exitDateTimePrecision(ctx) {}

  // Enter a parse tree produced by FHIRPathParser#pluralDateTimePrecision.
  enterPluralDateTimePrecision(ctx) {}

  // Exit a parse tree produced by FHIRPathParser#pluralDateTimePrecision.
  exitPluralDateTimePrecision(ctx) {}

  // Enter a parse tree produced by FHIRPathParser#typeSpecifier.
  enterTypeSpecifier(ctx) {}

  // Exit a parse tree produced by FHIRPathParser#typeSpecifier.
  exitTypeSpecifier(ctx) {}

  // Enter a parse tree produced by FHIRPathParser#qualifiedIdentifier.
  enterQualifiedIdentifier(ctx) {}

  // Exit a parse tree produced by FHIRPathParser#qualifiedIdentifier.
  exitQualifiedIdentifier(ctx) {}

  // Enter a parse tree produced by FHIRPathParser#identifier.
  enterIdentifier(ctx) {}

  // Exit a parse tree produced by FHIRPathParser#identifier.
  exitIdentifier(ctx) {}
}
module.exports = FHIRPathListener;

/***/ }),
/* 53 */
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

// This file holds utility functions used in implementing the public functions.

const util = {};
const types = __webpack_require__(54);
const {
  ResourceNode
} = types;

/**
 *  Reports and error to the calling environment and stops processing.
 * @param message the error message
 * @param fnName the name of the function raising the error (optional)
 */
util.raiseError = function (message, fnName) {
  fnName = fnName ? fnName + ": " : "";
  throw fnName + message;
};

/**
 *  Throws an exception if the collection contains not one value.
 * @param collection the collection to be checked.
 * @param errorMsgPrefix An optional prefix for the error message to assist in
 *  debugging.
 */
util.assertOnlyOne = function (collection, errorMsgPrefix) {
  if (collection.length !== 1) {
    util.raiseError("Was expecting only one element but got " + JSON.stringify(collection), errorMsgPrefix);
  }
};

/**
 *  Throws an exception if the data is not one of the expected types.
 * @param data the value to be checked.  This may be a ResourceNode.
 * @param types an array of the permitted types
 * @param errorMsgPrefix An optional prefix for the error message to assist in
 *  debugging.
 * @return the value that was checked.  If "data" was a ResourceNode, this will
 *  be the ReourceNode's data.
 */
util.assertType = function (data, types, errorMsgPrefix) {
  let val = this.valData(data);
  if (types.indexOf(typeof val) < 0) {
    let typeList = types.length > 1 ? "one of " + types.join(", ") : types[0];
    util.raiseError("Found type '" + typeof data + "' but was expecting " + typeList, errorMsgPrefix);
  }
  return val;
};
util.isEmpty = function (x) {
  return Array.isArray(x) && x.length === 0;
};
util.isSome = function (x) {
  return x !== null && x !== undefined && !util.isEmpty(x);
};
util.isTrue = function (x) {
  // We use util.valData because we can use a boolean node as a criterion
  return x !== null && x !== undefined && (x === true || x.length === 1 && util.valData(x[0]) === true);
};
util.isCapitalized = function (x) {
  return x && x[0] === x[0].toUpperCase();
};
util.capitalize = function (x) {
  return x[0].toUpperCase() + x.substring(1);
};
util.flatten = function (x) {
  if (x.some(i => i instanceof Promise)) {
    return Promise.all(x).then(arr => flattenSync(arr));
  }
  return flattenSync(x);
};

/**
 * Creates a shallow copy of the source array and replaces those elements of the
 * source array that are arrays with their contents.
 * For example:
 * [1, [2, 3]] -> [1, 2, 3]
 * @param {Array} x - source array
 * @return {Array}
 */
function flattenSync(x) {
  return [].concat(...x);
}
util.arraify = function (x) {
  if (Array.isArray(x)) {
    return x;
  }
  if (util.isSome(x)) {
    return [x];
  }
  return [];
};

/**
 * If the input parameter is a promise, arraify the result of that promise,
 * otherwise arraify the input parameter.
 * @param {*|Promise<*>} x - input parameter
 * @return {*[]|Promise<*[]>}
 */
util.resolveAndArraify = function (x) {
  return x instanceof Promise ? x.then(r => util.arraify(r)) : util.arraify(x);
};

/**
 *  Returns the data value of the given parameter, which might be a ResourceNode.
 *  Otherwise, it returns the value that was passed in.
 */
util.valData = function (val) {
  return val instanceof ResourceNode ? val.data : val;
};

/**
 *  Returns the data value of the given parameter, which might be a ResourceNode.
 *  Otherwise, it returns the value that was passed in.  In the case of a
 *  ResourceNode that is a Quantity, the returned value will have been converted
 *  to an FP_Quantity.
 */
util.valDataConverted = function (val) {
  if (val instanceof ResourceNode) {
    val = val.convertData();
  }
  return val;
};

/**
 * Prepares a string for insertion into a regular expression
 * @param {string} str
 * @return {string}
 */
util.escapeStringForRegExp = function (str) {
  return str.replace(/[-[\]{}()*+?.,\\/^$|#\s]/g, '\\$&');
};

/**
 * Binding to the Array.prototype.push.apply function to define a function to
 * push the contents of the source array to the destination array.
 * @name pushFn
 * @function
 * @param {Array} destArray - destination array
 * @param {Array} sourceArray - source array
 * @returns the new length property of destArray
 */
util.pushFn = Function.prototype.apply.bind(Array.prototype.push);

/**
 * Creates child resource nodes for the specified resource node property.
 * @param {ResourceNode} parentResNode - resource node
 * @param {string} childProperty - name of property
 * @param {object} [model] - "model" data object
 * @return {ResourceNode[]}
 */
util.makeChildResNodes = function (parentResNode, childProperty, model) {
  let childPath = parentResNode.path + '.' + childProperty;
  if (model) {
    let defPath = model.pathsDefinedElsewhere[childPath];
    if (defPath) childPath = defPath;
  }
  let toAdd, _toAdd;
  let actualTypes = model && model.choiceTypePaths[childPath];
  if (actualTypes) {
    // Use actualTypes to find the field's value
    for (let t of actualTypes) {
      let field = childProperty + t;
      toAdd = parentResNode.data?.[field];
      _toAdd = parentResNode.data?.['_' + field];
      if (toAdd !== undefined || _toAdd !== undefined) {
        childPath += t;
        break;
      }
    }
  } else {
    toAdd = parentResNode.data?.[childProperty];
    _toAdd = parentResNode.data?.['_' + childProperty];
    if (toAdd === undefined && _toAdd === undefined) {
      toAdd = parentResNode._data[childProperty];
    }
    if (childProperty === 'extension') {
      childPath = 'Extension';
    }
  }
  let fhirNodeDataType = null;
  if (model) {
    fhirNodeDataType = model.path2Type[childPath];
    childPath = model.path2TypeWithoutElements[childPath] || childPath;
  }
  let result;
  if (util.isSome(toAdd) || util.isSome(_toAdd)) {
    if (Array.isArray(toAdd)) {
      result = toAdd.map((x, i) => ResourceNode.makeResNode(x, parentResNode, childPath, _toAdd && _toAdd[i], fhirNodeDataType, model));
      // Add items to the end of the ResourceNode list that have no value
      // but have associated data, such as extensions or ids.
      const _toAddLength = _toAdd?.length || 0;
      for (let i = toAdd.length; i < _toAddLength; ++i) {
        result.push(ResourceNode.makeResNode(null, parentResNode, childPath, _toAdd[i], fhirNodeDataType, model));
      }
    } else if (toAdd == null && Array.isArray(_toAdd)) {
      // Add items to the end of the ResourceNode list when there are no
      // values at all, but there is a list of associated data, such as
      // extensions or ids.
      result = _toAdd.map(x => ResourceNode.makeResNode(null, parentResNode, childPath, x, fhirNodeDataType, model));
    } else {
      result = [ResourceNode.makeResNode(toAdd, parentResNode, childPath, _toAdd, fhirNodeDataType, model)];
    }
  } else {
    result = [];
  }
  return result;
};

// Object for storing fetch promises.
const requestCache = {};
// Duration of data storage in cache.
const requestCacheStorageTime = 3600000; // 1 hour = 60 * 60 * 1000

/**
 * fetch() wrapper for caching server responses.
 * @param {string} url - a URL of the resource you want to fetch.
 * @param {object} [options] - optional object containing any custom settings
 *  that you want to apply to the request.
 * @return {Promise}
 */
util.fetchWithCache = function (url, options) {
  const requestKey = [url, options ? JSON.stringify(options) : ''].join('|');
  const timestamp = Date.now();
  for (const key in requestCache) {
    if (timestamp - requestCache[key].timestamp > requestCacheStorageTime) {
      // Remove responses older than an hour
      delete requestCache[key];
    }
  }
  if (!requestCache[requestKey]) {
    requestCache[requestKey] = {
      timestamp,
      // In Jest unit tests, a promise returned by 'fetch' is not an instance of
      // Promise that we have in our application context, so we use Promise.resolve
      // to do the conversion.
      promise: Promise.resolve(options ? fetch(url, options) : fetch(url)).then(r => {
        const contentType = r.headers.get('Content-Type');
        const isJson = contentType.includes('application/json') || contentType.includes('application/fhir+json');
        try {
          if (isJson) {
            return r.json().then(json => r.ok ? json : Promise.reject(json));
          } else {
            return r.text().then(text => Promise.reject(text));
          }
        } catch (e) {
          return Promise.reject(new Error(e));
        }
      })
    };
  }
  return requestCache[requestKey].promise;
};
module.exports = util;

/***/ }),
/* 54 */
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

const addMinutes = __webpack_require__(55);
const ucumUtils = (__webpack_require__(60).UcumLhcUtils).getInstance();
const numbers = __webpack_require__(61);
const ucumSystemUrl = 'http://unitsofmeasure.org';
let timeFormat = '[0-9][0-9](\\:[0-9][0-9](\\:[0-9][0-9](\\.[0-9]+)?)?)?(Z|(\\+|-)[0-9][0-9]\\:[0-9][0-9])?';
let timeRE = new RegExp('^T?' + timeFormat + '$');
let dateTimeRE = new RegExp('^[0-9][0-9][0-9][0-9](-[0-9][0-9](-[0-9][0-9](T' + timeFormat + ')?)?)?Z?$');
let dateRE = new RegExp('^[0-9][0-9][0-9][0-9](-[0-9][0-9](-[0-9][0-9])?)?$');
let instantRE = new RegExp('^[0-9][0-9][0-9][0-9](-[0-9][0-9](-[0-9][0-9](T[0-9][0-9](\\:[0-9][0-9](\\:[0-9][0-9](\\.[0-9]+)?))(Z|(\\+|-)[0-9][0-9]\\:[0-9][0-9]))))$');
// FHIR date/time regular expressions are slightly different.  For now, we will
// stick with the FHIRPath regular expressions.
//let fhirTimeRE = /([01][0-9]|2[0-3]):[0-5][0-9]:([0-5][0-9]|60)(\.[0-9]+)?/;
//let fhirDateTimeRE =
///([0-9]([0-9]([0-9][1-9]|[1-9]0)|[1-9]00)|[1-9]000)(-(0[1-9]|1[0-2])(-(0[1-9]|[1-2][0-9]|3[0-1])(T([01][0-9]|2[0-3]):[0-5][0-9]:([0-5][0-9]|60)(\.[0-9]+)?(Z|(\+|-)((0[0-9]|1[0-3]):[0-5][0-9]|14:00)))?)?)?/;

/**
 *   Class FP_Type is the superclass for FHIRPath types that required special
 *   handling.
 */
class FP_Type {
  /**
   *  Tests whether this object is equal to another.  Returns either true,
   *  false, or undefined (where in the FHIRPath specification empty would be
   *  returned).  The undefined return value indicates that the values were the
   *  same to the shared precision, but that they had differnent levels of
   *  precision.
   */
  equals(/* otherObj */
  ) {
    return false;
  }

  /**
   *  Tests whether this object is equivalant to another.  Returns either true,
   *  false, or undefined (where in the FHIRPath specification empty would be
   *  returned).
   */
  equivalentTo(/* otherObj */
  ) {
    return false;
  }
  toString() {
    return this.asStr ? this.asStr : super.toString();
  }
  toJSON() {
    return this.toString();
  }

  /**
   *  Returns -1, 0, or 1 if this object is less then, equal to, or greater
   *  than otherObj.
   */
  compare(/* otherObj */
  ) {
    throw 'Comparison not implemented for ' + this.constructor.name;
  }

  /**
   *  Adds other value to this value.
   */
  plus(/* otherObj */
  ) {
    throw 'Addition not implemented for ' + this.constructor.name;
  }

  /**
   * Multiplies this value by another value.
   */
  mul(/* otherObj */
  ) {
    throw 'Multiplication not implemented for ' + this.constructor.name;
  }

  /**
   * Divides this value by another value.
   */
  div(/* otherObj */
  ) {
    throw 'Division not implemented for ' + this.constructor.name;
  }
}

/**
 *  A class for Quantities.
 */
class FP_Quantity extends FP_Type {
  constructor(value, unit) {
    super();
    this.asStr = value + ' ' + unit;
    this.value = value;
    this.unit = unit;
  }
  equals(otherQuantity) {
    if (!(otherQuantity instanceof this.constructor)) {
      return false;
    }
    const thisUnitInSeconds = FP_Quantity._calendarDuration2Seconds[this.unit];
    const otherUnitInSeconds = FP_Quantity._calendarDuration2Seconds[otherQuantity.unit];
    if (!thisUnitInSeconds !== !otherUnitInSeconds && (thisUnitInSeconds > 1 || otherUnitInSeconds > 1)) {
      // If one of the operands is a calendar duration greater than seconds and
      // another one is not a calendar duration, return empty result
      return null;
    }
    if (this.unit === otherQuantity.unit) {
      return numbers.isEqual(this.value, otherQuantity.value);
    }

    // Special year/month comparison case: 1 year = 12 month
    const compareYearsAndMonths = this._compareYearsAndMonths(otherQuantity);
    if (compareYearsAndMonths) {
      return compareYearsAndMonths.isEqual;
    }

    // General comparison case
    const thisQuantity = FP_Quantity.toUcumQuantity(this.value, this.unit),
      normalizedOtherQuantity = FP_Quantity.toUcumQuantity(otherQuantity.value, otherQuantity.unit),
      convResult = ucumUtils.convertUnitTo(normalizedOtherQuantity.unit, normalizedOtherQuantity.value, thisQuantity.unit);
    if (convResult.status !== 'succeeded') {
      return false;
    }
    return numbers.isEqual(thisQuantity.value, convResult.toVal);
  }
  equivalentTo(otherQuantity) {
    if (!(otherQuantity instanceof this.constructor)) {
      return false;
    }
    if (this.unit === otherQuantity.unit) {
      return numbers.isEquivalent(this.value, otherQuantity.value);
    }
    const ucumUnitCode = FP_Quantity.getEquivalentUcumUnitCode(this.unit),
      otherUcumUnitCode = FP_Quantity.getEquivalentUcumUnitCode(otherQuantity.unit),
      convResult = ucumUtils.convertUnitTo(otherUcumUnitCode, otherQuantity.value, ucumUnitCode);
    if (convResult.status !== 'succeeded') {
      return false;
    }
    return numbers.isEquivalent(this.value, convResult.toVal);
  }

  /**
   *  Returns a number less than 0, equal to 0 or greater than 0
   *  if this quantity is less than, equal to, or greater than otherQuantity.
   *  If the quantities could not be compared, returns null, which will be
   *  converted to an empty collection in the "doInvoke" function
   *  See https://hl7.org/fhirpath/#comparison
   *  @param {FP_Quantity} otherQuantity
   *  @return {number|null}
   */
  compare(otherQuantity) {
    if (this.unit === otherQuantity.unit) {
      return this.value - otherQuantity.value;
    }
    const thisUnitInSeconds = FP_Quantity._calendarDuration2Seconds[this.unit];
    const otherUnitInSeconds = FP_Quantity._calendarDuration2Seconds[otherQuantity.unit];
    if (!thisUnitInSeconds !== !otherUnitInSeconds && (thisUnitInSeconds > 1 || otherUnitInSeconds > 1)) {
      // If one of the operands is a calendar duration greater than seconds and
      // another one is not a calendar duration, return empty result
      // For example, 1 year > 1 'a' should return []
      return null;
    }
    const ucumUnitCode = FP_Quantity.getEquivalentUcumUnitCode(this.unit),
      otherUcumUnitCode = FP_Quantity.getEquivalentUcumUnitCode(otherQuantity.unit),
      convResult = ucumUtils.convertUnitTo(otherUcumUnitCode, otherQuantity.value, ucumUnitCode);
    if (convResult.status !== 'succeeded') {
      return null;
    }
    return this.value - convResult.toVal;
  }

  /**
   *  Adds a quantity to this quantity.
   * @param {FP_Quantity} otherQuantity a quantity to be added to this quantity.
   * @return {FP_Quantity|null}
   */
  plus(otherQuantity) {
    const thisConvFactor = FP_Quantity._yearMonthConversionFactor[this.unit];
    const otherConvFactor = FP_Quantity._yearMonthConversionFactor[otherQuantity.unit];
    if (thisConvFactor && otherConvFactor) {
      // If the values are indicated in years and months, we use the conversion factor: 1 year = 12 months
      return new FP_Quantity(this.value + otherQuantity.value * otherConvFactor / thisConvFactor, this.unit);
    }
    const thisUnitInSeconds = FP_Quantity._calendarDuration2Seconds[this.unit];
    const otherUnitInSeconds = FP_Quantity._calendarDuration2Seconds[otherQuantity.unit];
    if (!thisUnitInSeconds !== !otherUnitInSeconds && (thisUnitInSeconds > 1 || otherUnitInSeconds > 1)) {
      // If one of the operands is a calendar duration greater than seconds and
      // another one is not a calendar duration, return empty result
      return null;
    }
    const thisUcumUnitCode = thisUnitInSeconds ? 's' : this.unit.replace(surroundingApostrophesRegex, '');
    const thisValue = (thisUnitInSeconds || 1) * this.value;
    const otherUcumUnitCode = otherUnitInSeconds ? 's' : otherQuantity.unit.replace(surroundingApostrophesRegex, '');
    const otherValue = (otherUnitInSeconds || 1) * otherQuantity.value;
    const convResult = ucumUtils.convertUnitTo(otherUcumUnitCode, otherValue, thisUcumUnitCode);
    if (convResult.status !== 'succeeded' || convResult.fromUnit.isSpecial_ || convResult.toUnit.isSpecial_) {
      return null;
    }
    return new FP_Quantity(thisValue + convResult.toVal, thisUcumUnitCode);
  }

  /**
   * Multiplies this quantity to another quantity.
   * @param {FP_Quantity} otherQuantity a quantity by which to multiply this quantity.
   * @return {FP_Quantity}
   */
  mul(otherQuantity) {
    const thisUnitInSeconds = FP_Quantity._calendarDuration2Seconds[this.unit];
    const otherUnitInSeconds = FP_Quantity._calendarDuration2Seconds[otherQuantity.unit];
    if (thisUnitInSeconds > 1 && otherQuantity.unit !== "'1'" || otherUnitInSeconds > 1 && this.unit !== "'1'") {
      // If one of the operands is a calendar duration greater than seconds and
      // another one is not a number, return empty result
      return null;
    }
    const thisQ = this.convToUcumUnits(this, thisUnitInSeconds);
    if (!thisQ) {
      // If the first operand is not a UCUM quantity or it has a special unit
      return null;
    }
    const otherQ = this.convToUcumUnits(otherQuantity, otherUnitInSeconds);
    if (!otherQ) {
      // If the second operand is not a UCUM quantity or it has a special unit
      return null;
    }

    // Do not use UCUM unit codes for durations in simple cases
    if (this.unit === "'1'") {
      return new FP_Quantity(this.value * otherQuantity.value, otherQuantity.unit);
    } else if (otherQuantity.unit === "'1'") {
      return new FP_Quantity(this.value * otherQuantity.value, this.unit);
    }
    return new FP_Quantity(thisQ.value * otherQ.value, `'(${thisQ.unit}).(${otherQ.unit})'`);
  }

  /**
   * Divides this quantity by another quantity.
   * @param {FP_Quantity} otherQuantity a quantity by which to divide this quantity.
   * @return {FP_Quantity}
   */
  div(otherQuantity) {
    // Division by zero always gives an empty result
    if (otherQuantity.value === 0) {
      return null;
    }
    const thisUnitInSeconds = FP_Quantity._calendarDuration2Seconds[this.unit];
    const otherUnitInSeconds = FP_Quantity._calendarDuration2Seconds[otherQuantity.unit];
    if (thisUnitInSeconds) {
      if (otherUnitInSeconds) {
        // If both operands are calendar duration quantities
        const thisConvFactor = FP_Quantity._yearMonthConversionFactor[this.unit];
        const otherConvFactor = FP_Quantity._yearMonthConversionFactor[otherQuantity.unit];
        if (thisConvFactor && otherConvFactor) {
          // If the values are indicated in years and months, we use the conversion factor: 1 year = 12 months
          return new FP_Quantity(this.value * thisConvFactor / (otherQuantity.value * otherConvFactor), "'1'");
        }
      } else if (otherQuantity.unit === "'1'") {
        // If the second operand is a number
        return new FP_Quantity(this.value / otherQuantity.value, this.unit);
      } else if (thisUnitInSeconds > 1) {
        // If the first operand is a calendar duration greater than seconds
        // and the other is not a calendar duration or number, return an empty result.
        return null;
      }
    } else if (otherUnitInSeconds > 1) {
      // If the first operands is not a calendar duration and the other is a
      // calendar duration greater than seconds, return an empty result.
      return null;
    }
    const thisQ = this.convToUcumUnits(this, thisUnitInSeconds);
    if (!thisQ) {
      // If the first operand is not a UCUM quantity or it has a special unit
      return null;
    }
    const otherQ = this.convToUcumUnits(otherQuantity, otherUnitInSeconds);
    if (!otherQ) {
      // If the second operand is not a UCUM quantity or it has a special unit
      return null;
    }
    const resultUnit = otherQ.unit === '1' ? thisQ.unit : `(${thisQ.unit})/(${otherQ.unit})`;
    const convResult = ucumUtils.convertToBaseUnits(resultUnit, thisQ.value / otherQ.value);
    if (convResult.status !== 'succeeded') {
      // If the result units are unclear
      return null;
    }
    return new FP_Quantity(convResult.magnitude, `'${Object.keys(convResult.unitToExp).map(key => key + convResult.unitToExp[key]).join('.') || "1"}'`);
  }

  /**
   * Converts a quantity to UCUM unit if possible, otherwise returns null.
   * @param {FP_Quantity} quantity - source quantity.
   * @param {number|undefined} unitInSeconds - if the source quantity is a
   *  calendar duration then the value of the quantity unit in seconds,
   *  otherwise undefined.
   * @return {{unit: string, value: number} | null}
   */
  convToUcumUnits(quantity, unitInSeconds) {
    if (unitInSeconds) {
      return {
        value: unitInSeconds * quantity.value,
        unit: 's'
      };
    } else {
      const unit = quantity.unit.replace(surroundingApostrophesRegex, '');
      const convRes = ucumUtils.convertToBaseUnits(unit, quantity.value);
      if (convRes.status !== 'succeeded' || convRes.fromUnitIsSpecial) {
        // If it is not a UCUM quantity or it has a special unit
        return null;
      }
      return {
        value: convRes.magnitude,
        unit: Object.keys(convRes.unitToExp).map(key => key + convRes.unitToExp[key]).join('.') || "1"
      };
    }
  }

  /**
   * If both quantities have one of these units: year or month,
   * then a special case will apply; otherwise returns null.
   * In the special case of comparison, the fact that 1 year = 12 months is used.
   *
   * Just note: in general, for a calendar duration:
   * 1 year = 365 days
   * 12 month = 12*30 days = 360 days
   * so, 1 year != 12 month
   * That's why this special case is needed
   *
   * @param {FP_Quantity} otherQuantity
   * @return {null|{isEqual: boolean}}
   * @private
   */
  _compareYearsAndMonths(otherQuantity) {
    const magnitude1 = FP_Quantity._yearMonthConversionFactor[this.unit],
      magnitude2 = FP_Quantity._yearMonthConversionFactor[otherQuantity.unit];
    if (magnitude1 && magnitude2) {
      return {
        isEqual: numbers.isEqual(this.value * magnitude1, otherQuantity.value * magnitude2)
      };
    }
    return null;
  }
}
const surroundingApostrophesRegex = /^'|'$/g;
/**
 * Converts a FHIR path unit to a UCUM unit code by converting a calendar duration keyword to an equivalent UCUM unit code
 * or removing single quotes for a UCUM unit.
 * @param {string} unit
 * @return {string}
 */
FP_Quantity.getEquivalentUcumUnitCode = function (unit) {
  return FP_Quantity.mapTimeUnitsToUCUMCode[unit] || unit.replace(surroundingApostrophesRegex, '');
};

/**
 * Converts FHIR path value/unit to UCUM value/unit. Usable for comparison.
 * @param {number} value
 * @param {string} unit
 * @returns { {value: number, unit: string} }
 */
FP_Quantity.toUcumQuantity = function (value, unit) {
  const magnitude = FP_Quantity._calendarDuration2Seconds[unit];
  if (magnitude) {
    return {
      value: magnitude * value,
      unit: 's'
    };
  }
  return {
    value,
    unit: unit.replace(surroundingApostrophesRegex, '')
  };
};

/**
 * Converts FHIRPath value/unit to other FHIRPath value/unit.
 * @param {string} fromUnit
 * @param {number} value
 * @param {string} toUnit
 * @return {FP_Quantity|null}
 */
FP_Quantity.convUnitTo = function (fromUnit, value, toUnit) {
  // 1 Year <-> 12 Months
  const fromYearMonthMagnitude = FP_Quantity._yearMonthConversionFactor[fromUnit],
    toYearMonthMagnitude = FP_Quantity._yearMonthConversionFactor[toUnit];
  if (fromYearMonthMagnitude && toYearMonthMagnitude) {
    return new FP_Quantity(fromYearMonthMagnitude * value / toYearMonthMagnitude, toUnit);
  }
  const fromMagnitude = FP_Quantity._calendarDuration2Seconds[fromUnit],
    toMagnitude = FP_Quantity._calendarDuration2Seconds[toUnit];

  // To FHIR path calendar duration
  if (toMagnitude) {
    if (fromMagnitude) {
      return new FP_Quantity(fromMagnitude * value / toMagnitude, toUnit);
    } else {
      const convResult = ucumUtils.convertUnitTo(fromUnit.replace(/^'|'$/g, ''), value, 's');
      if (convResult.status === 'succeeded') {
        return new FP_Quantity(convResult.toVal / toMagnitude, toUnit);
      }
    }
    // To Ucum unit
  } else {
    const convResult = fromMagnitude ? ucumUtils.convertUnitTo('s', fromMagnitude * value, toUnit.replace(/^'|'$/g, '')) : ucumUtils.convertUnitTo(fromUnit.replace(/^'|'$/g, ''), value, toUnit.replace(/^'|'$/g, ''));
    if (convResult.status === 'succeeded') {
      return new FP_Quantity(convResult.toVal, toUnit);
    }
  }
  return null;
};

// Defines conversion factors for calendar durations
FP_Quantity._calendarDuration2Seconds = {
  'years': 365 * 24 * 60 * 60,
  'months': 30 * 24 * 60 * 60,
  'weeks': 7 * 24 * 60 * 60,
  'days': 24 * 60 * 60,
  'hours': 60 * 60,
  'minutes': 60,
  'seconds': 1,
  'milliseconds': .001,
  'year': 365 * 24 * 60 * 60,
  'month': 30 * 24 * 60 * 60,
  'week': 7 * 24 * 60 * 60,
  'day': 24 * 60 * 60,
  'hour': 60 * 60,
  'minute': 60,
  'second': 1,
  'millisecond': .001
};

// Defines special case to compare years with months for calendar durations
FP_Quantity._yearMonthConversionFactor = {
  'years': 12,
  'months': 1,
  'year': 12,
  'month': 1
};

/**
 *  Defines a map from time units that are supported for date/time arithmetic
 *  (including some UCUM time based units) to FHIRPath time units.
 */
FP_Quantity.dateTimeArithmeticDurationUnits = {
  'years': "year",
  'months': "month",
  'weeks': "week",
  'days': "day",
  'hours': "hour",
  'minutes': "minute",
  'seconds': "second",
  'milliseconds': "millisecond",
  'year': "year",
  'month': "month",
  'week': "week",
  'day': "day",
  'hour': "hour",
  'minute': "minute",
  'second': "second",
  'millisecond': "millisecond",
  "'s'": "second",
  "'ms'": "millisecond"
};

/**
 *  Defines a map from UCUM code to FHIRPath time units.
 */
FP_Quantity.mapUCUMCodeToTimeUnits = {
  'a': "year",
  'mo': "month",
  'wk': "week",
  'd': "day",
  'h': "hour",
  'min': "minute",
  's': "second",
  'ms': "millisecond"
};

/**
 *  Defines a map from FHIRPath time units to UCUM code.
 */
FP_Quantity.mapTimeUnitsToUCUMCode = Object.keys(FP_Quantity.mapUCUMCodeToTimeUnits).reduce(function (res, key) {
  res[FP_Quantity.mapUCUMCodeToTimeUnits[key]] = key;
  res[FP_Quantity.mapUCUMCodeToTimeUnits[key] + 's'] = key;
  return res;
}, {});
class FP_TimeBase extends FP_Type {
  constructor(timeStr) {
    super();
    this.asStr = timeStr;
  }

  /**
   *  Adds a time-based quantity to this date/time.
   * @param timeQuantity a quantity to be added to this date/time.  See the
   *  FHIRPath specification for supported units.
   */
  plus(timeQuantity) {
    const unit = timeQuantity.unit;
    let timeUnit = FP_Quantity.dateTimeArithmeticDurationUnits[unit];
    if (!timeUnit) {
      throw new Error('For date/time arithmetic, the unit of the quantity ' + 'must be one of the following time-based units: ' + Object.keys(FP_Quantity.dateTimeArithmeticDurationUnits));
    }
    const cls = this.constructor;
    const unitPrecision = cls._timeUnitToDatePrecision[timeUnit];
    if (unitPrecision === undefined) {
      throw new Error('Unsupported unit for +.  The unit should be one of ' + Object.keys(cls._timeUnitToDatePrecision).join(', ') + '.');
    }
    let qVal = timeQuantity.value;
    const isTime = cls === FP_Time;

    // From the FHIRPath specification: "For precisions above seconds, the
    // decimal portion of the time-valued quantity is ignored, since date/time
    // arithmetic above seconds is performed with calendar duration semantics."
    if (isTime ? unitPrecision < 2 : unitPrecision < 5) {
      qVal = Math.trunc(qVal);
    }

    // If the precision of the time quantity is higher than the precision of the
    // date, we need to convert the time quantity to the precision of the date.
    if (this._getPrecision() < unitPrecision) {
      const neededUnit = cls._datePrecisionToTimeUnit[this._getPrecision()];
      if (neededUnit !== 'second') {
        const newQuantity = FP_Quantity.convUnitTo(timeUnit, qVal, neededUnit);
        timeUnit = newQuantity.unit;
        qVal = Math.trunc(newQuantity.value);
      }
    }
    const newDate = FP_TimeBase.timeUnitToAddFn[timeUnit](this._getDateObj(), qVal);
    // newDate is a Date.  We need to make a string with the correct precision.
    let precision = this._getPrecision();
    if (isTime) precision += 3; // based on dateTimeRE, not timeRE
    let newDateStr = FP_DateTime.isoDateTime(newDate, precision);
    if (isTime) {
      // FP_Time just needs the time part of the string
      newDateStr = newDateStr.slice(newDateStr.indexOf('T') + 1);
    }
    return new cls(newDateStr);
  }

  /**
   *  Tests whether this object is equal to another.  Returns either true,
   *  false, or undefined (where in the FHIRPath specification empty would be
   *  returned).  The undefined return value indicates that the values were the
   *  same to the shared precision, but that they had differnent levels of
   *  precision.
   * @param otherDateTime any sub-type of FP_TimeBase, but it should be the same
   *  as the type of "this".
   */
  equals(otherDateTime) {
    // From the 2019May ballot:
    // For Date, DateTime and Time equality, the comparison is performed by
    // considering each precision in order, beginning with years (or hours for
    // time values), and respecting timezone offsets. If the values are the
    // same, comparison proceeds to the next precision; if the values are
    // different, the comparison stops and the result is false. If one input has
    // a value for the precision and the other does not, the comparison stops
    // and the result is empty ({ }); if neither input has a value for the
    // precision, or the last precision has been reached, the comparison stops
    // and the result is true.
    // Note:  Per the spec above
    //   2012-01 = 2012 //  empty
    //   2012-01 = 2011 //  false
    //   2012-01 ~ 2012 //  false
    var rtn;
    if (!(otherDateTime instanceof this.constructor) && !(this instanceof otherDateTime.constructor)) rtn = false;else {
      var thisPrec = this._getPrecision();
      var otherPrec = otherDateTime._getPrecision();
      if (thisPrec == otherPrec) {
        rtn = this._getDateObj().getTime() == otherDateTime._getDateObj().getTime();
      } else {
        // The dates are not equal, but decide whether to return empty or false.
        var commonPrec = thisPrec <= otherPrec ? thisPrec : otherPrec;
        // Adjust for timezone offsets, if any, so they are at a common timezone
        var thisUTCStr = this._getDateObj().toISOString();
        var otherUTCStr = otherDateTime._getDateObj().toISOString();
        if (this.constructor === FP_Time) {
          commonPrec += 3; // because we now have year, month, and day
          thisPrec += 3;
          otherPrec += 3;
        }

        // Now parse the strings and compare the adjusted time parts.
        // Dates without time specify no timezone and should be treated as already normalized to UTC. So we do not adjust the timezone, as this would change the date
        var thisAdj = thisPrec > 2 ? new FP_DateTime(thisUTCStr)._getTimeParts() : this._getTimeParts();
        var otherAdj = otherPrec > 2 ? new FP_DateTime(otherUTCStr)._getTimeParts() : otherDateTime._getTimeParts();
        for (var i = 0; i <= commonPrec && rtn !== false; ++i) {
          rtn = thisAdj[i] == otherAdj[i];
        }
        // if rtn is still true, then return empty to indicate the difference in
        // precision.
        if (rtn) rtn = undefined;
      }
    }
    // else return undefined (empty)
    return rtn;
  }

  /**
   *  Tests whether this object is equivalant to another.  Returns either true
   *  or false.
   */
  equivalentTo(otherDateTime) {
    var rtn = otherDateTime instanceof this.constructor;
    if (rtn) {
      var thisPrec = this._getPrecision();
      var otherPrec = otherDateTime._getPrecision();
      rtn = thisPrec == otherPrec;
      if (rtn) {
        rtn = this._getDateObj().getTime() == otherDateTime._getDateObj().getTime();
      }
    }
    return rtn;
  }

  /**
   *  Returns a number less than 0, equal to 0 or greater than 0
   *  if this (date) time is less than, equal to, or greater than otherTime.
   *  Comparisons are made at the lesser of the two time precisions.
   *  @param {FP_TimeBase} otherTime
   *  @return {number}
   */
  compare(otherTime) {
    var thisPrecision = this._getPrecision();
    var otherPrecision = otherTime._getPrecision();
    var thisTimeInt = thisPrecision <= otherPrecision ? this._getDateObj().getTime() : this._dateAtPrecision(otherPrecision).getTime();
    var otherTimeInt = otherPrecision <= thisPrecision ? otherTime._getDateObj().getTime() : otherTime._dateAtPrecision(thisPrecision).getTime();
    if (thisPrecision !== otherPrecision && thisTimeInt === otherTimeInt) {
      return null;
    }
    return thisTimeInt - otherTimeInt;
  }

  /**
   *  Returns a number representing the precision of the time string given to
   *  the constructor.  (Higher means more precise).  The number is the number
   *  of components of the time string (ignoring the time zone) produced by
   *  matching against the time regular expression, except that milliseconds
   *  and seconds are counted together as a single of level of precision.
   *  @return {number}
   */
  _getPrecision() {
    if (this.precision === undefined) this._getMatchData();
    return this.precision;
  }

  /**
   *  Returns the match data from matching the given RegExp against the
   *  date/time string given to the constructor.
   *  Also sets this.precision.
   * @param regEx The regular expression to match against the date/time string.
   * @param maxPrecision the maximum precision possible for the type
   */
  _getMatchData(regEx, maxPrecision) {
    if (this.timeMatchData === undefined) {
      this.timeMatchData = this.asStr.match(regEx);
      if (this.timeMatchData) {
        for (let i = maxPrecision; i >= 0 && this.precision === undefined; --i) {
          if (this.timeMatchData[i]) this.precision = i;
        }
      }
    }
    return this.timeMatchData;
  }

  /**
   *  Returns an array of the pieces of the given time string, for use in
   *  constructing lower precision versions of the time. The returned array will
   *  contain separate elements for the hour, minutes, seconds, and milliseconds
   *  (or as many of those are as present).  The length of the returned array
   *  will therefore be an indication of the precision.
   *  It will not include the timezone.
   * @timeMatchData the result of matching the time portion of the string passed
   *  into the constructor against the "timeRE" regular expression.
   */
  _getTimeParts(timeMatchData) {
    var timeParts = [];
    // Finish parsing the data into pieces, for later use in building
    // lower-precision versions of the date if needed.
    timeParts = [timeMatchData[0]];
    var timeZone = timeMatchData[4];
    if (timeZone) {
      // remove time zone from hours
      let hours = timeParts[0];
      timeParts[0] = hours.slice(0, hours.length - timeZone.length);
    }
    var min = timeMatchData[1];
    if (min) {
      // remove minutes from hours
      let hours = timeParts[0];
      timeParts[0] = hours.slice(0, hours.length - min.length);
      timeParts[1] = min;
      var sec = timeMatchData[2];
      if (sec) {
        // remove seconds from minutes
        timeParts[1] = min.slice(0, min.length - sec.length);
        timeParts[2] = sec;
        var ms = timeMatchData[3];
        if (ms) {
          // remove milliseconds from seconds
          timeParts[2] = sec.slice(0, sec.length - ms.length);
          timeParts[3] = ms;
        }
      }
    }
    return timeParts;
  }

  /**
   *  Returns a date object representing this time on a certain date.
   */
  _getDateObj() {
    if (!this.dateObj) {
      var precision = this._getPrecision();
      // We cannot directly pass the string into the date constructor because
      // (1) we don't want to introduce a time-dependent system date and (2) the
      // time string might not have contained minutes, which are required by the
      // Date constructor.
      this.dateObj = this._dateAtPrecision(precision);
    }
    return this.dateObj;
  }

  /**
   *  Creates a date object for the given timezone.  The returned date object
   *  will have the specified date and time in the specified timezone.
   * @param year...ms Just as in the Date constructor.
   * @param timezoneOffset (optional) a string in the format (+-)HH:mm or Z, representing the
   *  timezone offset.  If not provided, the local timzone will be assumed (as the
   *  Date constructor does).
   */
  _createDate(year, month, day, hour, minutes, seconds, ms, timezoneOffset) {
    var d = new Date(year, month, day, hour, minutes, seconds, ms);
    if (timezoneOffset) {
      // d is in local time.  Adjust for the timezone offset.
      // First adjust the date by the timezone offset before reducing its
      // precision.  Otherwise,
      // @2018-11-01T-04:00 < @2018T-05:00
      var localTimezoneMinutes = d.getTimezoneOffset();
      var timezoneMinutes = 0; // if Z
      if (timezoneOffset != 'Z') {
        var timezoneParts = timezoneOffset.split(':'); // (+-)hours:minutes
        var hours = parseInt(timezoneParts[0]);
        timezoneMinutes = parseInt(timezoneParts[1]);
        if (hours < 0) timezoneMinutes = -timezoneMinutes;
        timezoneMinutes += 60 * hours;
      }
      // localTimezoneMinutes has the inverse sign of its timezone offset
      d = addMinutes(d, -localTimezoneMinutes - timezoneMinutes);
    }
    return d;
  }
}

/**
 *  A map from a FHIRPath time units to a function used to add that
 *  quantity to a date/time.
 */
FP_TimeBase.timeUnitToAddFn = {
  "year": __webpack_require__(62),
  "month": __webpack_require__(63),
  "week": __webpack_require__(65),
  "day": __webpack_require__(66),
  "hour": __webpack_require__(67),
  "minute": __webpack_require__(55),
  "second": __webpack_require__(68),
  "millisecond": __webpack_require__(56)
};
class FP_DateTime extends FP_TimeBase {
  /**
   *  Constructs an FP_DateTime, assuming dateStr is valid.  If you don't know
   *  whether a string is a valid DateTime, use FP_DateTime.checkString instead.
   */
  constructor(dateStr) {
    super(dateStr);
  }

  /**
   *  Returns -1, 0, or 1 if this date time is less then, equal to, or greater
   *  than otherDateTime.  Comparisons are made at the lesser of the two date time
   *  precisions.
   */
  compare(otherDateTime) {
    if (!(otherDateTime instanceof FP_DateTime)) throw 'Invalid comparison of a DateTime with something else';
    return super.compare(otherDateTime);
  }

  /**
   *  Returns the match data from matching dateTimeRE against the datetime string.
   *  Also sets this.precision.
   */
  _getMatchData() {
    return super._getMatchData(dateTimeRE, 5);
  }

  /**
   *  Returns an array of the pieces of the date time string passed into the
   *  constructor, for use in constructing lower precision versions of the
   *  date time. The returned array will contain separate elements for the year,
   *  month, day, hour, minutes, seconds, and milliseconds (or as many of those
   *  are as present).  The length of the returned array will therefore be an
   *  indication of the precision.  It will not include the timezone.
   */
  _getTimeParts() {
    if (!this.timeParts) {
      let timeMatchData = this._getMatchData();
      let year = timeMatchData[0];
      this.timeParts = [year];
      var month = timeMatchData[1];
      if (month) {
        // Remove other information from year
        this.timeParts[0] = year.slice(0, year.length - month.length);
        this.timeParts[1] = month;
        let day = timeMatchData[2];
        if (day) {
          // Remove day information from month
          this.timeParts[1] = month.slice(0, month.length - day.length);
          this.timeParts[2] = day;
          let time = timeMatchData[3];
          if (time) {
            // Remove time from day
            this.timeParts[2] = day.slice(0, day.length - time.length);
            if (time[0] === 'T')
              // remove T from hour
              timeMatchData[3] = time.slice(1);
            this.timeParts = this.timeParts.concat(super._getTimeParts(timeMatchData.slice(3)));
          }
        }
      }
    }
    return this.timeParts;
  }

  /**
   *  Returns a new Date object for a time equal to what this time would be if
   *  the string passed into the constructor had the given precision.
   * @param precision the new precision, which is assumed to be less than
   *  or equal to the current precision.
   */
  _dateAtPrecision(precision) {
    var timeParts = this._getTimeParts();
    var timezoneOffset = this._getMatchData()[7];
    // Get the date object first at the current precision.
    var thisPrecision = this._getPrecision();
    var year = parseInt(timeParts[0]);
    var month = thisPrecision > 0 ? parseInt(timeParts[1].slice(1)) - 1 : 0;
    var day = thisPrecision > 1 ? parseInt(timeParts[2].slice(1)) : 1;
    var hour = thisPrecision > 2 ? parseInt(timeParts[3]) : 0;
    var minutes = thisPrecision > 3 ? parseInt(timeParts[4].slice(1)) : 0;
    var seconds = thisPrecision > 4 ? parseInt(timeParts[5].slice(1)) : 0;
    var ms = timeParts.length > 6 ? parseInt(timeParts[6].slice(1)) : 0;
    var d = this._createDate(year, month, day, hour, minutes, seconds, ms, timezoneOffset);
    if (precision < thisPrecision) {
      // Adjust the precision
      year = d.getFullYear();
      month = precision > 0 ? d.getMonth() : 0;
      day = precision > 1 ? d.getDate() : 1;
      hour = precision > 2 ? d.getHours() : 0;
      minutes = precision > 3 ? d.getMinutes() : 0;
      // Here the precision will always be less than the maximum
      // due to the condition in the if statement: "precision < thisPrecision"
      d = new Date(year, month, day, hour, minutes);
    }
    return d;
  }
}

/**
 *  Tests str to see if it is convertible to a DateTime.
 * @return If str is convertible to a DateTime, returns an FP_DateTime;
 *  otherwise returns null.
 */
FP_DateTime.checkString = function (str) {
  let d = new FP_DateTime(str);
  if (!d._getMatchData()) d = null;
  return d;
};

/**
 *  A map from FHIRPath time units to the internal DateTime "precision" number.
 */
FP_DateTime._timeUnitToDatePrecision = {
  "year": 0,
  "month": 1,
  "week": 2,
  // wk is just 7*d
  "day": 2,
  "hour": 3,
  "minute": 4,
  "second": 5,
  "millisecond": 6
};

/**
 *  The inverse of _timeUnitToDatePrecision.
 */
FP_DateTime._datePrecisionToTimeUnit = ["year", "month", "day", "hour", "minute", "second", "millisecond"];
class FP_Time extends FP_TimeBase {
  /**
   *  Constructs an FP_Time, assuming dateStr is valid.  If you don't know
   *  whether a string is a valid DateTime, use FP_Time.checkString instead.
   */
  constructor(timeStr) {
    if (timeStr[0] == 'T') timeStr = timeStr.slice(1);
    super(timeStr);
  }

  /**
   *  Returns -1, 0, or 1 if this time is less then, equal to, or greater
   *  than otherTime.  Comparisons are made at the lesser of the two time
   *  precisions.
   */
  compare(otherTime) {
    if (!(otherTime instanceof FP_Time)) throw 'Invalid comparison of a time with something else';
    return super.compare(otherTime);
  }

  /**
   *  Returns a new Date object for a time equal to what this time would be if
   *  the string passed into the constructor had the given precision.
   *  The "date" portion of the returned Date object is not meaningful, and
   *  should be ignored.
   * @param precision the new precision, which is assumed to be less than the
   *  or equal to the current precision.  A precision of 0 means the hour.
   */
  _dateAtPrecision(precision) {
    var timeParts = this._getTimeParts();
    var timezoneOffset = this._getMatchData()[4];
    // Get the date object first at the current precision.
    var thisPrecision = this._getPrecision();
    var year = 2010; // Have to pick some year for the date object
    var month = 0;
    var day = 1;
    var hour = parseInt(timeParts[0]);
    var minutes = thisPrecision > 0 ? parseInt(timeParts[1].slice(1)) : 0;
    var seconds = thisPrecision > 1 ? parseInt(timeParts[2].slice(1)) : 0;
    var ms = timeParts.length > 3 ? parseInt(timeParts[3].slice(1)) : 0;
    var d = this._createDate(year, month, day, hour, minutes, seconds, ms, timezoneOffset);
    if (timezoneOffset) {
      // Keep the date the same (in the local timezone), so it is not a relevant
      // factor when comparing different times.
      d.setYear(year);
      d.setMonth(month);
      d.setDate(day);
    }
    if (precision < thisPrecision) {
      // Adjust the precision
      hour = d.getHours();
      minutes = precision > 0 ? d.getMinutes() : 0;
      // Here the precision will always be less than the maximum
      // due to the condition in the if statement: "precision < thisPrecision"
      d = new Date(year, month, day, hour, minutes);
    }
    return d;
  }

  /**
   *  Returns the match data from matching timeRE against the time string.
   *  Also sets this.precision.
   */
  _getMatchData() {
    return super._getMatchData(timeRE, 2);
  }

  /**
   *  Returns an array of the pieces of the time string passed into the
   *  constructor, for use in constructing lower precision versions of the
   *  time. The returned array will contain separate elements for the hour,
   *  minutes, seconds, and milliseconds (or as many of those are as present).
   *  The length of the returned array will therefore be an indication of the
   *  precision.  It will not include the timezone.
   */
  _getTimeParts() {
    if (!this.timeParts) {
      this.timeParts = super._getTimeParts(this._getMatchData());
    }
    return this.timeParts;
  }
}

/**
 *  Tests str to see if it is convertible to a Time.
 * @return If str is convertible to a Time, returns an FP_Time;
 *  otherwise returns null.
 */
FP_Time.checkString = function (str) {
  let d = new FP_Time(str);
  if (!d._getMatchData()) d = null;
  return d;
};

/**
 *  A map from FHIRPath time units to the internal DateTime "precision" number.
 */
FP_Time._timeUnitToDatePrecision = {
  "hour": 0,
  "minute": 1,
  "second": 2,
  "millisecond": 3
};

/**
 *  The inverse of _timeUnitToDatePrecision.
 */
FP_Time._datePrecisionToTimeUnit = ["hour", "minute", "second", "millisecond"];

/**
 *  Returns either the given number or a string with the number prefixed by
 *  zeros if the given number is less than the given length.
 * @param num the nubmer to format
 * @param len the number of returned digits.  For now this must either be 2 or
 *  3. (Optional-- default is 2).
 */
function formatNum(num, len) {
  // Could use String.repeat, but that requires convertin num to an string first
  // to get its length.  This might be slightly faster given that we only need 2
  // or three 3 digit return values.
  var rtn = num;
  if (len === 3 && num < 100) rtn = '0' + num;
  if (num < 10) rtn = '0' + rtn;
  return rtn;
}

/**
 *  Formats the given date object into an ISO8601 datetime string, expressing it
 *  in the local timezone.
 * @date the date to format
 * @precision the precision at which to terminate string string.  (This is
 *  optional). If present, it will be an integer into the matching components of
 *  dateTimeRE.
 * @return a string in ISO8601 format.
 */
FP_DateTime.isoDateTime = function (date, precision) {
  if (precision === undefined) precision = 5; // maximum
  // YYYY-MM-DDTHH:mm:ss.sss[+-]HH:mm
  // Note:  Date.toISOString sets the timezone at 'Z', which I did not want.
  // Actually, I wanted to keep the original timezone given in the constructor,
  // but that is difficult due to daylight savings time changes.  (For instance,
  // if you add 6 months, the timezone offset could change).
  var rtn = '' + date.getFullYear();
  if (precision > 0) {
    rtn += '-' + formatNum(date.getMonth() + 1);
    if (precision > 1) {
      rtn += '-' + formatNum(date.getDate());
      if (precision > 2) {
        rtn += 'T' + FP_DateTime.isoTime(date, precision - 3);
      }
    }
  }
  // FHIRPath STU1 does not allow a timezone offset on a dateTime that does not
  // have a time part (except that the grammar allows 'Z', which is
  // inconsistent).
  if (precision > 2) {
    // Note:  getTimezoneoffset returns the offset for the local system at the
    // given date.
    var tzOffset = date.getTimezoneOffset();
    // tzOffset is a number of minutes, and is positive for negative timezones,
    // and negative for positive timezones.
    var tzSign = tzOffset < 0 ? '+' : '-';
    tzOffset = Math.abs(tzOffset);
    var tzMin = tzOffset % 60;
    var tzHour = (tzOffset - tzMin) / 60;
    rtn += tzSign + formatNum(tzHour) + ':' + formatNum(tzMin);
  }
  return rtn;
};

/**
 *  Returns a time string in ISO format at the given precision level.
 * @date the date to format
 * @precision the precision at which to terminate string.  (This is
 *  optional). If present, it will be an integer into the matching components of
 *  timeRE.
 * @return a string in ISO 8601 format.
 */
FP_DateTime.isoTime = function (date, precision) {
  if (precision === undefined) precision = 2; // maximum

  let rtn = '' + formatNum(date.getHours());
  if (precision > 0) {
    rtn += ':' + formatNum(date.getMinutes());
    if (precision > 1) {
      rtn += ':' + formatNum(date.getSeconds());
      if (date.getMilliseconds()) rtn += '.' + formatNum(date.getMilliseconds(), 3);
    }
  }
  return rtn;
};
class FP_Date extends FP_DateTime {
  /**
   * Constructs an FP_Date, assuming dateStr is valid.  If you don't know
   * whether a string is a valid Date, use FP_Date.checkString instead.
   */
  constructor(dateStr) {
    super(dateStr);
  }

  /**
   * Returns the match data from matching dateRE against the date string.
   * Also sets this.precision.
   */
  _getMatchData() {
    return FP_TimeBase.prototype._getMatchData.apply(this, [dateRE, 2]);
  }
}

/**
 * Tests str to see if it is convertible to a Date.
 * @return If str is convertible to a Date, returns an FP_Date;
 *  otherwise returns null.
 */
FP_Date.checkString = function (str) {
  let d = new FP_Date(str);
  if (!d._getMatchData()) d = null;
  return d;
};

/**
 * Returns a date string in ISO format at the given precision level.
 * @date the date to format
 * @precision the precision at which to terminate string.  (This is
 *  optional). If present, it will be an integer into the matching components of
 *  dateTimeRE.
 * @return a string in ISO8601 format.
 */
FP_Date.isoDate = function (date, precision) {
  if (precision === undefined || precision > 2) precision = 2;
  return FP_DateTime.isoDateTime(date, precision);
};
class FP_Instant extends FP_DateTime {
  /**
   * Constructs an FP_Instant, assuming instantStr is valid.  If you don't know
   * whether a string is a valid "instant", use FP_Instant.checkString instead.
   */
  constructor(instantStr) {
    super(instantStr);
  }

  /**
   * Returns the match data from matching instantRE against the "instant" string.
   * Also sets this.precision.
   */
  _getMatchData() {
    return FP_TimeBase.prototype._getMatchData.apply(this, [instantRE, 5]);
  }
}

/**
 * Tests str to see if it is convertible to an "instant".
 * @return If str match the "instant" RegExp, returns an FP_Instant;
 *  otherwise returns null.
 */
FP_Instant.checkString = function (str) {
  let d = new FP_Instant(str);
  if (!d._getMatchData()) d = null;
  return d;
};

/**
 *  A class that represents a node in a FHIR resource, with path and possibly type
 *  information.
 */
class ResourceNode {
  /**
   *  Constructs a instance for the given node ("data") of a resource.  If the
   *  data is the top-level node of a resouce, the path and type parameters will
   *  be ignored in favor of the resource's resourceType field.
   * @param {*} data - the node's data or value (which might be an object with
   *  sub-nodes, an array, or FHIR data type)
   * @param {ResourceNode} parentResNode - parent ResourceNode.
   * @param {string} path - the node's path in the resource (e.g. Patient.name).
   *  If the data's type can be determined from data, that will take precedence
   *  over this parameter.
   * @param {*} _data - additional data stored in a property named with "_"
   *  prepended, see https://www.hl7.org/fhir/element.html#json for details.
   * @param {string} fhirNodeDataType - FHIR node data type, if the resource node
   *  is described in the FHIR model.
   *  @param {Object} model - the model object specific to a domain, e.g. R4.
   */
  constructor(data, parentResNode, path, _data, fhirNodeDataType, model) {
    // If data is a resource (maybe a contained resource) reset the path
    // information to the resource type.
    if (data?.resourceType) {
      path = data.resourceType;
      fhirNodeDataType = data.resourceType;
    }
    this.parentResNode = parentResNode || null;
    this.path = path || null;
    this.data = data;
    this._data = _data || {};
    this.fhirNodeDataType = fhirNodeDataType || null;
    this.model = model || null;
  }

  /**
   * Returns resource node type info.
   * @return {TypeInfo}
   */
  getTypeInfo() {
    if (!this.typeInfo) {
      let typeInfo;
      if (this.fhirNodeDataType) {
        if (/^System\.(.*)$/.test(this.fhirNodeDataType)) {
          typeInfo = new TypeInfo({
            namespace: TypeInfo.System,
            name: RegExp.$1
          });
        } else {
          typeInfo = new TypeInfo({
            namespace: TypeInfo.FHIR,
            name: this.fhirNodeDataType
          });
        }
      }
      this.typeInfo = typeInfo
      // Resource object properties that are not defined in the model now have
      // System.* data types:
      || TypeInfo.createByValueInSystemNamespace(this.data);
    }
    return this.typeInfo;
  }
  toJSON() {
    return JSON.stringify(this.data);
  }

  /**
   * Converts a resource node value to an instance of the FHIRPath system type
   * (FP_Quantity, FP_Date, FP_DateTime, or FP_Time) for use in evaluating
   * a FHIRPath expression if the node path matches the specified type in the
   * model and when conversion is possible, otherwise returns the data as is.
   * Throws an exception if the data is a Quantity that has a comparator.
   * The Mapping from FHIR Quantity to FHIRPath System.Quantity is explained here:
   * https://www.hl7.org/fhir/fhirpath.html#quantity
   * this.data is not changed, but converted value is returned.
   * @return {FP_Type|any}
   */
  convertData() {
    if (!this.convertedData) {
      var data = this.data;
      if (data != null) {
        const cls = TypeInfo.typeToClassWithCheckString[this.path];
        if (cls) {
          data = cls.checkString(data) || data;
        } else if (TypeInfo.isType(this.path, 'Quantity', this.model)) {
          if (data?.system === ucumSystemUrl) {
            if (typeof data.value === 'number' && typeof data.code === 'string') {
              if (data.comparator !== undefined) throw new Error('Cannot convert a FHIR.Quantity that has a comparator');
              data = new FP_Quantity(data.value, FP_Quantity.mapUCUMCodeToTimeUnits[data.code] || '\'' + data.code + '\'');
            }
          }
        }
      }
      this.convertedData = data;
    }
    return this.convertedData;
  }
}

/**
 *  Returns a ResourceNode for the given data node, checking first to see if the
 *  given node is already a ResourceNode.  Takes the same arguments as the
 *  constructor for ResourceNode.
 */
ResourceNode.makeResNode = function (data, parentResNode, path, _data, fhirNodeDataType, model) {
  return data instanceof ResourceNode ? data : new ResourceNode(data, parentResNode, path, _data, fhirNodeDataType, model);
};

// The set of available data types in the System namespace
const availableSystemTypes = new Set();
// IE11 probably doesn't support `new Set(iterable)`
['Boolean', 'String', 'Integer', 'Decimal', 'Date', 'DateTime', 'Time', 'Quantity'].forEach(i => availableSystemTypes.add(i));

/**
 * Object class defining type information.
 * Used for minimal type support.
 * (see http://hl7.org/fhirpath/#types-and-reflection)
 */
class TypeInfo {
  constructor({
    name,
    namespace
  }) {
    this.name = name;
    this.namespace = namespace;
  }

  // The "model" data object specific to a domain, e.g. R4.
  static model = null;

  /**
   * Checks for equality with another TypeInfo object, or that another TypeInfo
   * object specifies a superclass for the type specified by this object.
   * @param {TypeInfo} other - the TypeInfo object to compare with.
   * @param {Object} model - the model object specific to a domain, e.g. R4.
   * @return {boolean}
   */
  is(other, model) {
    if (other instanceof TypeInfo && (!this.namespace || !other.namespace || this.namespace === other.namespace)) {
      return model && (!this.namespace || this.namespace === TypeInfo.FHIR) ? TypeInfo.isType(this.name, other.name, model) : this.name === other.name;
    }
    return false;
  }

  /**
   * Returns the string representation of type info.
   * @returns {string}
   */
  toString() {
    return (this.namespace ? this.namespace + '.' : '') + this.name;
  }

  /**
   * Returns true if type info represents a valid type identifier, false otherwise.
   * @param {Object} model - the model object specific to a domain, e.g. R4.
   * @returns {boolean}
   */
  isValid(model) {
    let result = false;
    if (this.namespace === 'System') {
      result = availableSystemTypes.has(this.name);
    } else if (this.namespace === 'FHIR') {
      result = model.availableTypes.has(this.name);
    } else if (!this.namespace) {
      result = availableSystemTypes.has(this.name) || model.availableTypes.has(this.name);
    }
    return result;
  }
}

/**
 * Defines a map from a datatype to a datatype class which has a checkString method.
 * @type {Object.<string, FP_DateTime | FP_Time>}
 */
TypeInfo.typeToClassWithCheckString = {
  date: FP_Date,
  dateTime: FP_DateTime,
  instant: FP_Instant,
  time: FP_Time
};

/**
 * Checks if the type name or its parent type name is equal to
 * the expected type name.
 * @param type - type name to check.
 * @param superType - expected type name.
 * @param model - the model object specific to a domain, e.g. R4.
 * @return {boolean}
 */
TypeInfo.isType = function (type, superType, model) {
  do {
    if (type === superType) {
      return true;
    }
  } while (type = model?.type2Parent[type]);
  return false;
};

// Available namespaces:
TypeInfo.System = 'System';
TypeInfo.FHIR = 'FHIR';

/**
 * Creates new TypeInfo object for specified value in the System namespace.
 * @param {*} value
 * @return {TypeInfo}
 */
TypeInfo.createByValueInSystemNamespace = function (value) {
  let name = typeof value;
  if (Number.isInteger(value)) {
    name = 'integer';
  } else if (name === "number") {
    name = 'decimal';
  } else if (value instanceof FP_Date) {
    name = 'date';
  } else if (value instanceof FP_DateTime) {
    name = 'dateTime';
  } else if (value instanceof FP_Time) {
    name = 'time';
  } else if (value instanceof FP_Quantity) {
    name = 'Quantity';
  }
  name = name.replace(/^\w/, c => c.toUpperCase());

  // Currently can return name = "Object" which is probably wrong,
  // but the isValid method allows you to check this.
  return new TypeInfo({
    namespace: TypeInfo.System,
    name
  });
};

/**
 * Retrieves TypeInfo by value
 * @param {*} value
 * @return {TypeInfo}
 */
TypeInfo.fromValue = function (value) {
  return value instanceof ResourceNode ? value.getTypeInfo() : TypeInfo.createByValueInSystemNamespace(value);
};

/**
 * Set of primitive data type names.
 */
const primitives = new Set();
// IE11 probably doesn't support `new Set(iterable)`
["instant", "time", "date", "dateTime", "base64Binary", "decimal", "integer64", "boolean", "string", "code", "markdown", "id", "integer", "unsignedInt", "positiveInt", "uri", "oid", "uuid", "canonical", "url", "Integer", "Decimal", "String", "Date", "DateTime", "Time"].forEach(i => primitives.add(i));

/**
 * Checks whether the specified type information contains a primitive data type.
 * @param {TypeInfo} typeInfo
 * @return {boolean}
 */
TypeInfo.isPrimitive = function (typeInfo) {
  return primitives.has(typeInfo.name);
};

/**
 * Checks whether the specified value is of a primitive data type.
 * @param {*} value - The value to check.
 * @returns {boolean} - Returns true if the value is a primitive data type,
 *  otherwise false.
 */

TypeInfo.isPrimitiveValue = function (value) {
  if (value instanceof ResourceNode) {
    return primitives.has(value.getTypeInfo().name);
  } else {
    // Simplified check for primitive data types:
    return typeof value !== 'object' || value instanceof FP_Type;
  }
};

/**
 * Basic "type()" function implementation
 * (see http://hl7.org/fhirpath/#reflection)
 * @param {Array<*>} coll - input collection
 * @return {Array<*>}
 */
function typeFn(coll) {
  return coll.map(value => {
    return TypeInfo.fromValue(value);
  });
}

/**
 * Implementation of function "is(type : type specifier)" and operator "is"
 * (see http://hl7.org/fhirpath/#is-type-specifier)
 * @param {Array<*>} coll - input collection
 * @param {TypeInfo} typeInfo
 * @return {boolean|[]}
 */
function isFn(coll, typeInfo) {
  if (coll.length === 0) {
    return [];
  }
  if (coll.length > 1) {
    throw new Error("Expected singleton on left side of 'is', got " + JSON.stringify(coll));
  }
  const ctx = this;
  return TypeInfo.fromValue(coll[0]).is(typeInfo, ctx.model);
}

/**
 * Implementation of function "as(type : type specifier)" and operator "as"
 * (see http://hl7.org/fhirpath/#as-type-specifier)
 * @param {Array<*>} coll - input collection
 * @param {TypeInfo} typeInfo
 * @return {Array<*>}
 */
function asFn(coll, typeInfo) {
  if (coll.length === 0) {
    return [];
  }
  if (coll.length > 1) {
    throw new Error("Expected singleton on left side of 'as', got " + JSON.stringify(coll));
  }
  const ctx = this;
  return TypeInfo.fromValue(coll[0]).is(typeInfo, ctx.model) ? coll : [];
}
module.exports = {
  FP_Type,
  FP_TimeBase,
  FP_Date,
  FP_DateTime,
  FP_Instant,
  FP_Time,
  FP_Quantity,
  timeRE,
  dateTimeRE,
  dateRE,
  instantRE,
  ResourceNode,
  TypeInfo,
  typeFn,
  isFn,
  asFn
};

/***/ }),
/* 55 */
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var addMilliseconds = __webpack_require__(56);
var MILLISECONDS_IN_MINUTE = 60000;

/**
 * @category Minute Helpers
 * @summary Add the specified number of minutes to the given date.
 *
 * @description
 * Add the specified number of minutes to the given date.
 *
 * @param {Date|String|Number} date - the date to be changed
 * @param {Number} amount - the amount of minutes to be added
 * @returns {Date} the new date with the minutes added
 *
 * @example
 * // Add 30 minutes to 10 July 2014 12:00:00:
 * var result = addMinutes(new Date(2014, 6, 10, 12, 0), 30)
 * //=> Thu Jul 10 2014 12:30:00
 */
function addMinutes(dirtyDate, dirtyAmount) {
  var amount = Number(dirtyAmount);
  return addMilliseconds(dirtyDate, amount * MILLISECONDS_IN_MINUTE);
}
module.exports = addMinutes;

/***/ }),
/* 56 */
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var parse = __webpack_require__(57);

/**
 * @category Millisecond Helpers
 * @summary Add the specified number of milliseconds to the given date.
 *
 * @description
 * Add the specified number of milliseconds to the given date.
 *
 * @param {Date|String|Number} date - the date to be changed
 * @param {Number} amount - the amount of milliseconds to be added
 * @returns {Date} the new date with the milliseconds added
 *
 * @example
 * // Add 750 milliseconds to 10 July 2014 12:45:30.000:
 * var result = addMilliseconds(new Date(2014, 6, 10, 12, 45, 30, 0), 750)
 * //=> Thu Jul 10 2014 12:45:30.750
 */
function addMilliseconds(dirtyDate, dirtyAmount) {
  var timestamp = parse(dirtyDate).getTime();
  var amount = Number(dirtyAmount);
  return new Date(timestamp + amount);
}
module.exports = addMilliseconds;

/***/ }),
/* 57 */
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var getTimezoneOffsetInMilliseconds = __webpack_require__(58);
var isDate = __webpack_require__(59);
var MILLISECONDS_IN_HOUR = 3600000;
var MILLISECONDS_IN_MINUTE = 60000;
var DEFAULT_ADDITIONAL_DIGITS = 2;
var parseTokenDateTimeDelimeter = /[T ]/;
var parseTokenPlainTime = /:/;

// year tokens
var parseTokenYY = /^(\d{2})$/;
var parseTokensYYY = [/^([+-]\d{2})$/,
// 0 additional digits
/^([+-]\d{3})$/,
// 1 additional digit
/^([+-]\d{4})$/ // 2 additional digits
];
var parseTokenYYYY = /^(\d{4})/;
var parseTokensYYYYY = [/^([+-]\d{4})/,
// 0 additional digits
/^([+-]\d{5})/,
// 1 additional digit
/^([+-]\d{6})/ // 2 additional digits
];

// date tokens
var parseTokenMM = /^-(\d{2})$/;
var parseTokenDDD = /^-?(\d{3})$/;
var parseTokenMMDD = /^-?(\d{2})-?(\d{2})$/;
var parseTokenWww = /^-?W(\d{2})$/;
var parseTokenWwwD = /^-?W(\d{2})-?(\d{1})$/;

// time tokens
var parseTokenHH = /^(\d{2}([.,]\d*)?)$/;
var parseTokenHHMM = /^(\d{2}):?(\d{2}([.,]\d*)?)$/;
var parseTokenHHMMSS = /^(\d{2}):?(\d{2}):?(\d{2}([.,]\d*)?)$/;

// timezone tokens
var parseTokenTimezone = /([Z+-].*)$/;
var parseTokenTimezoneZ = /^(Z)$/;
var parseTokenTimezoneHH = /^([+-])(\d{2})$/;
var parseTokenTimezoneHHMM = /^([+-])(\d{2}):?(\d{2})$/;

/**
 * @category Common Helpers
 * @summary Convert the given argument to an instance of Date.
 *
 * @description
 * Convert the given argument to an instance of Date.
 *
 * If the argument is an instance of Date, the function returns its clone.
 *
 * If the argument is a number, it is treated as a timestamp.
 *
 * If an argument is a string, the function tries to parse it.
 * Function accepts complete ISO 8601 formats as well as partial implementations.
 * ISO 8601: http://en.wikipedia.org/wiki/ISO_8601
 *
 * If all above fails, the function passes the given argument to Date constructor.
 *
 * @param {Date|String|Number} argument - the value to convert
 * @param {Object} [options] - the object with options
 * @param {0 | 1 | 2} [options.additionalDigits=2] - the additional number of digits in the extended year format
 * @returns {Date} the parsed date in the local time zone
 *
 * @example
 * // Convert string '2014-02-11T11:30:30' to date:
 * var result = parse('2014-02-11T11:30:30')
 * //=> Tue Feb 11 2014 11:30:30
 *
 * @example
 * // Parse string '+02014101',
 * // if the additional number of digits in the extended year format is 1:
 * var result = parse('+02014101', {additionalDigits: 1})
 * //=> Fri Apr 11 2014 00:00:00
 */
function parse(argument, dirtyOptions) {
  if (isDate(argument)) {
    // Prevent the date to lose the milliseconds when passed to new Date() in IE10
    return new Date(argument.getTime());
  } else if (typeof argument !== 'string') {
    return new Date(argument);
  }
  var options = dirtyOptions || {};
  var additionalDigits = options.additionalDigits;
  if (additionalDigits == null) {
    additionalDigits = DEFAULT_ADDITIONAL_DIGITS;
  } else {
    additionalDigits = Number(additionalDigits);
  }
  var dateStrings = splitDateString(argument);
  var parseYearResult = parseYear(dateStrings.date, additionalDigits);
  var year = parseYearResult.year;
  var restDateString = parseYearResult.restDateString;
  var date = parseDate(restDateString, year);
  if (date) {
    var timestamp = date.getTime();
    var time = 0;
    var offset;
    if (dateStrings.time) {
      time = parseTime(dateStrings.time);
    }
    if (dateStrings.timezone) {
      offset = parseTimezone(dateStrings.timezone) * MILLISECONDS_IN_MINUTE;
    } else {
      var fullTime = timestamp + time;
      var fullTimeDate = new Date(fullTime);
      offset = getTimezoneOffsetInMilliseconds(fullTimeDate);

      // Adjust time when it's coming from DST
      var fullTimeDateNextDay = new Date(fullTime);
      fullTimeDateNextDay.setDate(fullTimeDate.getDate() + 1);
      var offsetDiff = getTimezoneOffsetInMilliseconds(fullTimeDateNextDay) - getTimezoneOffsetInMilliseconds(fullTimeDate);
      if (offsetDiff > 0) {
        offset += offsetDiff;
      }
    }
    return new Date(timestamp + time + offset);
  } else {
    return new Date(argument);
  }
}
function splitDateString(dateString) {
  var dateStrings = {};
  var array = dateString.split(parseTokenDateTimeDelimeter);
  var timeString;
  if (parseTokenPlainTime.test(array[0])) {
    dateStrings.date = null;
    timeString = array[0];
  } else {
    dateStrings.date = array[0];
    timeString = array[1];
  }
  if (timeString) {
    var token = parseTokenTimezone.exec(timeString);
    if (token) {
      dateStrings.time = timeString.replace(token[1], '');
      dateStrings.timezone = token[1];
    } else {
      dateStrings.time = timeString;
    }
  }
  return dateStrings;
}
function parseYear(dateString, additionalDigits) {
  var parseTokenYYY = parseTokensYYY[additionalDigits];
  var parseTokenYYYYY = parseTokensYYYYY[additionalDigits];
  var token;

  // YYYY or YYYYY
  token = parseTokenYYYY.exec(dateString) || parseTokenYYYYY.exec(dateString);
  if (token) {
    var yearString = token[1];
    return {
      year: parseInt(yearString, 10),
      restDateString: dateString.slice(yearString.length)
    };
  }

  // YY or YYY
  token = parseTokenYY.exec(dateString) || parseTokenYYY.exec(dateString);
  if (token) {
    var centuryString = token[1];
    return {
      year: parseInt(centuryString, 10) * 100,
      restDateString: dateString.slice(centuryString.length)
    };
  }

  // Invalid ISO-formatted year
  return {
    year: null
  };
}
function parseDate(dateString, year) {
  // Invalid ISO-formatted year
  if (year === null) {
    return null;
  }
  var token;
  var date;
  var month;
  var week;

  // YYYY
  if (dateString.length === 0) {
    date = new Date(0);
    date.setUTCFullYear(year);
    return date;
  }

  // YYYY-MM
  token = parseTokenMM.exec(dateString);
  if (token) {
    date = new Date(0);
    month = parseInt(token[1], 10) - 1;
    date.setUTCFullYear(year, month);
    return date;
  }

  // YYYY-DDD or YYYYDDD
  token = parseTokenDDD.exec(dateString);
  if (token) {
    date = new Date(0);
    var dayOfYear = parseInt(token[1], 10);
    date.setUTCFullYear(year, 0, dayOfYear);
    return date;
  }

  // YYYY-MM-DD or YYYYMMDD
  token = parseTokenMMDD.exec(dateString);
  if (token) {
    date = new Date(0);
    month = parseInt(token[1], 10) - 1;
    var day = parseInt(token[2], 10);
    date.setUTCFullYear(year, month, day);
    return date;
  }

  // YYYY-Www or YYYYWww
  token = parseTokenWww.exec(dateString);
  if (token) {
    week = parseInt(token[1], 10) - 1;
    return dayOfISOYear(year, week);
  }

  // YYYY-Www-D or YYYYWwwD
  token = parseTokenWwwD.exec(dateString);
  if (token) {
    week = parseInt(token[1], 10) - 1;
    var dayOfWeek = parseInt(token[2], 10) - 1;
    return dayOfISOYear(year, week, dayOfWeek);
  }

  // Invalid ISO-formatted date
  return null;
}
function parseTime(timeString) {
  var token;
  var hours;
  var minutes;

  // hh
  token = parseTokenHH.exec(timeString);
  if (token) {
    hours = parseFloat(token[1].replace(',', '.'));
    return hours % 24 * MILLISECONDS_IN_HOUR;
  }

  // hh:mm or hhmm
  token = parseTokenHHMM.exec(timeString);
  if (token) {
    hours = parseInt(token[1], 10);
    minutes = parseFloat(token[2].replace(',', '.'));
    return hours % 24 * MILLISECONDS_IN_HOUR + minutes * MILLISECONDS_IN_MINUTE;
  }

  // hh:mm:ss or hhmmss
  token = parseTokenHHMMSS.exec(timeString);
  if (token) {
    hours = parseInt(token[1], 10);
    minutes = parseInt(token[2], 10);
    var seconds = parseFloat(token[3].replace(',', '.'));
    return hours % 24 * MILLISECONDS_IN_HOUR + minutes * MILLISECONDS_IN_MINUTE + seconds * 1000;
  }

  // Invalid ISO-formatted time
  return null;
}
function parseTimezone(timezoneString) {
  var token;
  var absoluteOffset;

  // Z
  token = parseTokenTimezoneZ.exec(timezoneString);
  if (token) {
    return 0;
  }

  // hh
  token = parseTokenTimezoneHH.exec(timezoneString);
  if (token) {
    absoluteOffset = parseInt(token[2], 10) * 60;
    return token[1] === '+' ? -absoluteOffset : absoluteOffset;
  }

  // hh:mm or hhmm
  token = parseTokenTimezoneHHMM.exec(timezoneString);
  if (token) {
    absoluteOffset = parseInt(token[2], 10) * 60 + parseInt(token[3], 10);
    return token[1] === '+' ? -absoluteOffset : absoluteOffset;
  }
  return 0;
}
function dayOfISOYear(isoYear, week, day) {
  week = week || 0;
  day = day || 0;
  var date = new Date(0);
  date.setUTCFullYear(isoYear, 0, 4);
  var fourthOfJanuaryDay = date.getUTCDay() || 7;
  var diff = week * 7 + day + 1 - fourthOfJanuaryDay;
  date.setUTCDate(date.getUTCDate() + diff);
  return date;
}
module.exports = parse;

/***/ }),
/* 58 */
/***/ (function(module) {

var MILLISECONDS_IN_MINUTE = 60000;

/**
 * Google Chrome as of 67.0.3396.87 introduced timezones with offset that includes seconds.
 * They usually appear for dates that denote time before the timezones were introduced
 * (e.g. for 'Europe/Prague' timezone the offset is GMT+00:57:44 before 1 October 1891
 * and GMT+01:00:00 after that date)
 *
 * Date#getTimezoneOffset returns the offset in minutes and would return 57 for the example above,
 * which would lead to incorrect calculations.
 *
 * This function returns the timezone offset in milliseconds that takes seconds in account.
 */
module.exports = function getTimezoneOffsetInMilliseconds(dirtyDate) {
  var date = new Date(dirtyDate.getTime());
  var baseTimezoneOffset = date.getTimezoneOffset();
  date.setSeconds(0, 0);
  var millisecondsPartOfTimezoneOffset = date.getTime() % MILLISECONDS_IN_MINUTE;
  return baseTimezoneOffset * MILLISECONDS_IN_MINUTE + millisecondsPartOfTimezoneOffset;
};

/***/ }),
/* 59 */
/***/ (function(module) {

/**
 * @category Common Helpers
 * @summary Is the given argument an instance of Date?
 *
 * @description
 * Is the given argument an instance of Date?
 *
 * @param {*} argument - the argument to check
 * @returns {Boolean} the given argument is an instance of Date
 *
 * @example
 * // Is 'mayonnaise' a Date?
 * var result = isDate('mayonnaise')
 * //=> false
 */
function isDate(argument) {
  return argument instanceof Date;
}
module.exports = isDate;

/***/ }),
/* 60 */
/***/ (function(module) {

"use strict";
module.exports = LForms.ucumPkg;

/***/ }),
/* 61 */
/***/ (function(module) {

let numberFns = {};

// Returns the number of digits in the number after the decimal point, ignoring
// trailing zeros.
function decimalPlaces(x) {
  // Based on https://stackoverflow.com/a/9539746/360782
  // Make sure it is a number and use the builtin number -> string.
  const s = "" + +x,
    match = /(\d+)(?:\.(\d+))?(?:[eE]([+-]?\d+))?$/.exec(s);
  // NaN or Infinity or integer.
  // We arbitrarily decide that Infinity is integral.
  if (!match) {
    return 0;
  }
  // Count the number of digits in the fraction and subtract the
  // exponent to simulate moving the decimal point left by exponent places.
  // 1.234e+2 has 1 fraction digit and '234'.length -  2 == 1
  // 1.234e-2 has 5 fraction digit and '234'.length - -2 == 5
  //var wholeNum = match[1];
  const fraction = match[2],
    exponent = match[3];
  return Math.max(0,
  // lower limit.
  (fraction === '0' ? 0 : (fraction || '').length // fraction length
  ) - (exponent || 0)); // exponent
}

/**
 *  Rounds a number to the specified number of decimal places.
 * @param x the decimal number to be rounded
 * @param n the (maximum) number of decimal places to preserve.  (The result
 *  could contain fewer if the decimal digits in x contain zeros).
 */
function roundToDecimalPlaces(x, n) {
  const scale = Math.pow(10, n);
  return Math.round(x * scale) / scale;
}

/**
 *  The smallest representable number in FHIRPath.
 */
const PRECISION_STEP = 1e-8;

/**
 *  Rounds a number to the nearest multiple of PRECISION_STEP.
 */
const roundToMaxPrecision = numberFns.roundToMaxPrecision = function (x) {
  return Math.round(x / PRECISION_STEP) * PRECISION_STEP;
};

/**
 * Determines numbers equivalence
 * @param {number} actual
 * @param {number} expected
 * @return {boolean}
 */
numberFns.isEquivalent = function (actual, expected) {
  if (Number.isInteger(actual) && Number.isInteger(expected)) {
    return actual === expected;
  }
  const prec = Math.min(decimalPlaces(actual), decimalPlaces(expected));
  if (prec === 0) {
    return Math.round(actual) === Math.round(expected);
  } else {
    // Note: parseFloat(0.00000011).toPrecision(7) ===  "1.100000e-7"
    // It does # of significant digits, not decimal places.
    return roundToDecimalPlaces(actual, prec) === roundToDecimalPlaces(expected, prec);
  }
};

/**
 * Determines numbers equality
 * @param {number} actual
 * @param {number} expected
 * @return {boolean}
 */
numberFns.isEqual = function (actual, expected) {
  return roundToMaxPrecision(actual) === roundToMaxPrecision(expected);
};
module.exports = numberFns;

/***/ }),
/* 62 */
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var addMonths = __webpack_require__(63);

/**
 * @category Year Helpers
 * @summary Add the specified number of years to the given date.
 *
 * @description
 * Add the specified number of years to the given date.
 *
 * @param {Date|String|Number} date - the date to be changed
 * @param {Number} amount - the amount of years to be added
 * @returns {Date} the new date with the years added
 *
 * @example
 * // Add 5 years to 1 September 2014:
 * var result = addYears(new Date(2014, 8, 1), 5)
 * //=> Sun Sep 01 2019 00:00:00
 */
function addYears(dirtyDate, dirtyAmount) {
  var amount = Number(dirtyAmount);
  return addMonths(dirtyDate, amount * 12);
}
module.exports = addYears;

/***/ }),
/* 63 */
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var parse = __webpack_require__(57);
var getDaysInMonth = __webpack_require__(64);

/**
 * @category Month Helpers
 * @summary Add the specified number of months to the given date.
 *
 * @description
 * Add the specified number of months to the given date.
 *
 * @param {Date|String|Number} date - the date to be changed
 * @param {Number} amount - the amount of months to be added
 * @returns {Date} the new date with the months added
 *
 * @example
 * // Add 5 months to 1 September 2014:
 * var result = addMonths(new Date(2014, 8, 1), 5)
 * //=> Sun Feb 01 2015 00:00:00
 */
function addMonths(dirtyDate, dirtyAmount) {
  var date = parse(dirtyDate);
  var amount = Number(dirtyAmount);
  var desiredMonth = date.getMonth() + amount;
  var dateWithDesiredMonth = new Date(0);
  dateWithDesiredMonth.setFullYear(date.getFullYear(), desiredMonth, 1);
  dateWithDesiredMonth.setHours(0, 0, 0, 0);
  var daysInMonth = getDaysInMonth(dateWithDesiredMonth);
  // Set the last day of the new month
  // if the original date was the last day of the longer month
  date.setMonth(desiredMonth, Math.min(daysInMonth, date.getDate()));
  return date;
}
module.exports = addMonths;

/***/ }),
/* 64 */
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var parse = __webpack_require__(57);

/**
 * @category Month Helpers
 * @summary Get the number of days in a month of the given date.
 *
 * @description
 * Get the number of days in a month of the given date.
 *
 * @param {Date|String|Number} date - the given date
 * @returns {Number} the number of days in a month
 *
 * @example
 * // How many days are in February 2000?
 * var result = getDaysInMonth(new Date(2000, 1))
 * //=> 29
 */
function getDaysInMonth(dirtyDate) {
  var date = parse(dirtyDate);
  var year = date.getFullYear();
  var monthIndex = date.getMonth();
  var lastDayOfMonth = new Date(0);
  lastDayOfMonth.setFullYear(year, monthIndex + 1, 0);
  lastDayOfMonth.setHours(0, 0, 0, 0);
  return lastDayOfMonth.getDate();
}
module.exports = getDaysInMonth;

/***/ }),
/* 65 */
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var addDays = __webpack_require__(66);

/**
 * @category Week Helpers
 * @summary Add the specified number of weeks to the given date.
 *
 * @description
 * Add the specified number of week to the given date.
 *
 * @param {Date|String|Number} date - the date to be changed
 * @param {Number} amount - the amount of weeks to be added
 * @returns {Date} the new date with the weeks added
 *
 * @example
 * // Add 4 weeks to 1 September 2014:
 * var result = addWeeks(new Date(2014, 8, 1), 4)
 * //=> Mon Sep 29 2014 00:00:00
 */
function addWeeks(dirtyDate, dirtyAmount) {
  var amount = Number(dirtyAmount);
  var days = amount * 7;
  return addDays(dirtyDate, days);
}
module.exports = addWeeks;

/***/ }),
/* 66 */
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var parse = __webpack_require__(57);

/**
 * @category Day Helpers
 * @summary Add the specified number of days to the given date.
 *
 * @description
 * Add the specified number of days to the given date.
 *
 * @param {Date|String|Number} date - the date to be changed
 * @param {Number} amount - the amount of days to be added
 * @returns {Date} the new date with the days added
 *
 * @example
 * // Add 10 days to 1 September 2014:
 * var result = addDays(new Date(2014, 8, 1), 10)
 * //=> Thu Sep 11 2014 00:00:00
 */
function addDays(dirtyDate, dirtyAmount) {
  var date = parse(dirtyDate);
  var amount = Number(dirtyAmount);
  date.setDate(date.getDate() + amount);
  return date;
}
module.exports = addDays;

/***/ }),
/* 67 */
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var addMilliseconds = __webpack_require__(56);
var MILLISECONDS_IN_HOUR = 3600000;

/**
 * @category Hour Helpers
 * @summary Add the specified number of hours to the given date.
 *
 * @description
 * Add the specified number of hours to the given date.
 *
 * @param {Date|String|Number} date - the date to be changed
 * @param {Number} amount - the amount of hours to be added
 * @returns {Date} the new date with the hours added
 *
 * @example
 * // Add 2 hours to 10 July 2014 23:00:00:
 * var result = addHours(new Date(2014, 6, 10, 23, 0), 2)
 * //=> Fri Jul 11 2014 01:00:00
 */
function addHours(dirtyDate, dirtyAmount) {
  var amount = Number(dirtyAmount);
  return addMilliseconds(dirtyDate, amount * MILLISECONDS_IN_HOUR);
}
module.exports = addHours;

/***/ }),
/* 68 */
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var addMilliseconds = __webpack_require__(56);

/**
 * @category Second Helpers
 * @summary Add the specified number of seconds to the given date.
 *
 * @description
 * Add the specified number of seconds to the given date.
 *
 * @param {Date|String|Number} date - the date to be changed
 * @param {Number} amount - the amount of seconds to be added
 * @returns {Date} the new date with the seconds added
 *
 * @example
 * // Add 30 seconds to 10 July 2014 12:45:00:
 * var result = addSeconds(new Date(2014, 6, 10, 12, 45, 0), 30)
 * //=> Thu Jul 10 2014 12:45:30
 */
function addSeconds(dirtyDate, dirtyAmount) {
  var amount = Number(dirtyAmount);
  return addMilliseconds(dirtyDate, amount * 1000);
}
module.exports = addSeconds;

/***/ }),
/* 69 */
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

// Binding the function Array.prototype.slice.call for convert Array-like objects/collections to a new Array.
const slice = Function.prototype.call.bind(Array.prototype.slice);

// isInteger (not in IE)
// From Mozilla docs
Number.isInteger = Number.isInteger || function (value) {
  return typeof value === 'number' && isFinite(value) && Math.floor(value) === value;
};
if (!String.prototype.startsWith) {
  // From Mozilla docs with little changes
  Object.defineProperty(String.prototype, 'startsWith', {
    value: function (searchString, position) {
      position = position || 0;
      return this.indexOf(searchString, position) === position;
    }
  });
}
if (!String.prototype.endsWith) {
  // From Mozilla docs with little changes
  Object.defineProperty(String.prototype, 'endsWith', {
    value: function (searchString, position) {
      var subjectString = this.toString();
      if (position === undefined || position > subjectString.length) {
        position = subjectString.length;
      }
      position -= searchString.length;
      var lastIndex = subjectString.indexOf(searchString, position);
      return lastIndex !== -1 && lastIndex === position;
    }
  });
}
if (!String.prototype.includes) {
  Object.defineProperty(String.prototype, 'includes', {
    value: function () {
      return this.indexOf.apply(this, arguments) !== -1;
    }
  });
}
if (!Object.assign) {
  // From Mozilla docs with little changes
  Object.defineProperty(Object, 'assign', {
    value: function (target) {
      if (target === undefined || target === null) {
        throw new TypeError('Cannot convert undefined or null to object');
      }
      return slice(arguments, 1).reduce(function (to, nextSource) {
        Object.keys(Object(nextSource)).forEach(function (nextKey) {
          to[nextKey] = nextSource[nextKey];
        });
        return to;
      }, Object(target));
    }
  });
}

// Define btoa for NodeJS
if (typeof btoa === 'undefined') {
  __webpack_require__.g.btoa = function (str) {
    return new Buffer.from(str, 'binary').toString('base64');
  };
}

// Define atob for NodeJS
if (typeof atob === 'undefined') {
  __webpack_require__.g.atob = function (b64Encoded) {
    return new Buffer.from(b64Encoded, 'base64').toString('binary');
  };
}

/***/ }),
/* 70 */
/***/ (function(module) {

// These are values that should not change during an evaluation of a FHIRPath
// expression (e.g. the return value of today(), per the spec.)  They are
// constant during at least one evaluation.

module.exports = {
  /**
   *  Resets the constants.  Should be called when before the engine starts its
   *  processing.
   */
  reset: function () {
    this.nowDate = new Date(); // a Date object representing "now"
    this.today = null;
    this.now = null;
    this.timeOfDay = null;
    this.localTimezoneOffset = null;
  },
  /**
   *  The cached value of today().
   */
  today: null,
  /**
   *  The cached value of now().
   */
  now: null,
  /**
   *  The cached value of timeOfDay().
   */
  timeOfDay: null
};

/***/ }),
/* 71 */
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

// This file holds code to hande the FHIRPath Existence functions (5.1 in the
// specification).

const util = __webpack_require__(53);
const {
  whereMacro,
  distinctFn
} = __webpack_require__(72);
const misc = __webpack_require__(75);
const hashObject = __webpack_require__(73);
const {
  deepEqual,
  maxCollSizeForDeepEqual
} = __webpack_require__(74);
const {
  TypeInfo
} = __webpack_require__(54);
const engine = {};
engine.emptyFn = util.isEmpty;
engine.notFn = function (coll) {
  let d = misc.singleton(coll, 'Boolean');
  return typeof d === 'boolean' ? !d : [];
};
engine.existsMacro = function (coll, expr) {
  if (expr) {
    const exprRes = whereMacro.call(this, coll, expr);
    if (exprRes instanceof Promise) {
      return exprRes.then(r => engine.existsMacro(r));
    }
    return engine.existsMacro(exprRes);
  }
  return !util.isEmpty(coll);
};
engine.allMacro = function (coll, expr) {
  const promises = [];
  for (let i = 0, len = coll.length; i < len; ++i) {
    this.$index = i;
    const exprRes = expr(coll[i]);
    if (exprRes instanceof Promise) {
      promises.push(exprRes);
    } else if (!util.isTrue(exprRes)) {
      return [false];
    }
  }
  if (promises.length) {
    return Promise.all(promises).then(r => r.some(i => !util.isTrue(i)) ? [false] : [true]);
  }
  return [true];
};
engine.allTrueFn = function (x) {
  let rtn = true;
  for (let i = 0, len = x.length; i < len && rtn; ++i) {
    let xi = util.assertType(x[i], ["boolean"], "allTrue");
    rtn = xi === true;
  }
  return [rtn];
};
engine.anyTrueFn = function (x) {
  let rtn = false;
  for (let i = 0, len = x.length; i < len && !rtn; ++i) {
    let xi = util.assertType(x[i], ["boolean"], "anyTrue");
    rtn = xi === true;
  }
  return [rtn];
};
engine.allFalseFn = function (x) {
  let rtn = true;
  for (let i = 0, len = x.length; i < len && rtn; ++i) {
    let xi = util.assertType(x[i], ["boolean"], "allFalse");
    rtn = xi === false;
  }
  return [rtn];
};
engine.anyFalseFn = function (x) {
  let rtn = false;
  for (let i = 0, len = x.length; i < len && !rtn; ++i) {
    let xi = util.assertType(x[i], ["boolean"], "anyFalse");
    rtn = xi === false;
  }
  return [rtn];
};

/**
 *  Returns true if coll1 is a subset of coll2.
 */
function subsetOf(coll1, coll2) {
  const coll1Length = coll1.length;
  const coll2Length = coll2.length;
  let rtn = coll1Length <= coll2Length;
  if (rtn) {
    const hasPrimitive = coll1.some(i => TypeInfo.isPrimitiveValue(i)) || coll2.some(i => TypeInfo.isPrimitiveValue(i));
    if (!hasPrimitive && coll1Length + coll2Length > maxCollSizeForDeepEqual) {
      // When we have more than maxCollSizeForDeepEqual items in input collections,
      // we use a hash table (on JSON strings) for efficiency.
      const c2Hash = coll2.reduce((hash, item) => {
        hash[hashObject(item)] = true;
        return hash;
      }, {});
      rtn = !coll1.some(item => !c2Hash[hashObject(item)]);
    } else {
      // Otherwise, it is more efficient to perform a deep comparison.
      for (let p = 0, pLen = coll1.length; p < pLen && rtn; ++p) {
        let obj1 = util.valData(coll1[p]);
        rtn = coll2.some(obj2 => deepEqual(obj1, util.valData(obj2)));
      }
    }
  }
  return rtn;
}
engine.subsetOfFn = function (coll1, coll2) {
  return [subsetOf(coll1, coll2)];
};
engine.supersetOfFn = function (coll1, coll2) {
  return [subsetOf(coll2, coll1)];
};
engine.isDistinctFn = function (x) {
  return [x.length === distinctFn(x).length];
};
module.exports = engine;

/***/ }),
/* 72 */
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

// Contains the FHIRPath Filtering and Projection functions.  (Section 5.2 of
// the FHIRPath 1.0.0 specification).

/**
 *  Adds the filtering and projection functions to the given FHIRPath engine.
 */
const util = __webpack_require__(53);
const {
  TypeInfo,
  ResourceNode
} = __webpack_require__(54);
const hashObject = __webpack_require__(73);
const {
  deepEqual,
  maxCollSizeForDeepEqual
} = __webpack_require__(74);
var engine = {};
engine.whereMacro = function (parentData, expr) {
  if (parentData !== false && !parentData) {
    return [];
  }
  return util.flatten(parentData.map((x, i) => {
    this.$index = i;
    const condition = expr(x);
    if (condition instanceof Promise) {
      return condition.then(c => c[0] ? x : []);
    }
    return condition[0] ? x : [];
  }));
};
engine.extension = function (parentData, url) {
  const ctx = this;
  if (parentData !== false && !parentData || !url) {
    return [];
  }
  return util.flatten(parentData.map((x, i) => {
    this.$index = i;
    const extensions = x && (x.data && x.data.extension || x._data && x._data.extension);
    if (extensions) {
      return extensions.filter(extension => extension.url === url).map(e => ResourceNode.makeResNode(e, x, 'Extension', null, 'Extension', ctx.model));
    }
    return [];
  }));
};
engine.selectMacro = function (data, expr) {
  if (data !== false && !data) {
    return [];
  }
  return util.flatten(data.map((x, i) => {
    this.$index = i;
    return expr(x);
  }));
};
engine.repeatMacro = function (parentData, expr, state = {
  res: [],
  unique: {},
  hasPrimitive: false
}) {
  if (parentData !== false && !parentData) {
    return [];
  }
  let newItems = [].concat(...parentData.map(i => expr(i)));
  if (newItems.some(i => i instanceof Promise)) {
    return Promise.all(newItems).then(items => {
      items = [].concat(...items);
      if (items.length) {
        return engine.repeatMacro(getNewItems(items, state), expr, state);
      }
      return state.res;
    });
  } else if (newItems.length) {
    return engine.repeatMacro(getNewItems(newItems, state), expr, state);
  } else {
    return state.res;
  }
};

/**
 * Returns new items from the input array that are not in the hash of existing
 * unique items and adds them to the result array.
 * @param {Array<*>} items - inout array.
 * @param {Object} state - current state object.
 * @param {{[key: string]: *}} state.unique - hash of existing unique items.
 * @param {Array<*>} state.res - result array.
 * @param {boolean} state.hasPrimitive - flag indicating if the result array has
 *  primitives.
 * @return {Array<*>}
 */
function getNewItems(items, state) {
  let newItems;
  state.hasPrimitive = state.hasPrimitive || items.some(i => TypeInfo.isPrimitiveValue(i));
  if (!state.hasPrimitive && items.length + state.res.length > maxCollSizeForDeepEqual) {
    newItems = items.filter(item => {
      const key = hashObject(item);
      const isUnique = !state.unique[key];
      if (isUnique) {
        state.unique[key] = true;
      }
      return isUnique;
    });
    state.res.push.apply(state.res, newItems);
  } else {
    newItems = items.filter(item => {
      const isUnique = !state.res.some(i => deepEqual(i, item));
      if (isUnique) {
        state.res.push(item);
      }
      return isUnique;
    });
  }
  return newItems;
}

//TODO: behavior on object?
engine.singleFn = function (x) {
  if (x.length === 1) {
    return x;
  } else if (x.length === 0) {
    return [];
  } else {
    throw new Error("Expected single");
  }
};
engine.firstFn = function (x) {
  return x[0];
};
engine.lastFn = function (x) {
  return x[x.length - 1];
};
engine.tailFn = function (x) {
  return x.slice(1, x.length);
};
engine.takeFn = function (x, n) {
  return x.slice(0, n);
};
engine.skipFn = function (x, num) {
  return x.slice(num, x.length);
};
engine.ofTypeFn = function (coll, typeInfo) {
  const ctx = this;
  return coll.filter(value => {
    return TypeInfo.fromValue(value).is(typeInfo, ctx.model);
  });
};
engine.distinctFn = function (x, hasPrimitive = undefined) {
  let unique = [];
  if (x.length > 0) {
    hasPrimitive = hasPrimitive ?? x.some(i => TypeInfo.isPrimitiveValue(i));
    if (!hasPrimitive && x.length > maxCollSizeForDeepEqual) {
      // When we have more than maxCollSizeForDeepEqual items in input collection,
      // we use a hash table (on JSON strings) for efficiency.
      let uniqueHash = {};
      for (let i = 0, len = x.length; i < len; ++i) {
        let xObj = x[i];
        let xStr = hashObject(xObj);
        if (!uniqueHash[xStr]) {
          unique.push(xObj);
          uniqueHash[xStr] = true;
        }
      }
    } else {
      // Otherwise, it is more efficient to perform a deep comparison.
      // Use reverse() + pop() instead of shift() to improve performance and
      // maintain order.
      x = x.concat().reverse();
      do {
        let xObj = x.pop();
        unique.push(xObj);
        x = x.filter(o => !deepEqual(xObj, o));
      } while (x.length);
    }
  }
  return unique;
};
module.exports = engine;

/***/ }),
/* 73 */
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

const ucumUtils = (__webpack_require__(60).UcumLhcUtils).getInstance();
const {
  roundToMaxPrecision
} = __webpack_require__(61);
const {
  valDataConverted
} = __webpack_require__(53);
const {
  FP_Type,
  FP_Quantity
} = __webpack_require__(54);

/**
 *  Returns a JSON version of the given object, but with the object's keys
 *  in sorted order (or at least stable order,
 *  see https://stackoverflow.com/a/35810961/360782) and the values in
 *  unified forms, e.g. "1 year" is converted to the same value as "12 months",
 *  "3 'min'" is converted to the same value as "120 'sec'".
 *  This function is used instead of deepEqual for optimization when you need
 *  to compare many objects.
 */
function hashObject(obj) {
  return JSON.stringify(prepareObject(obj));
}

/**
 * Brings an object to the unified form so that it can be serialized to JSON to
 * compare with other objects according to https://hl7.org/fhirpath/#equals
 * This function is following the logic from deepEqual (if changes are needed
 * here they are likely also needed there).
 */
function prepareObject(value) {
  value = valDataConverted(value);
  if (value === null) {
    return null;
  } else if (typeof value === 'number') {
    return roundToMaxPrecision(value);
  } else if (value instanceof Date) {
    return value.toISOString();
  }
  if (value instanceof FP_Quantity) {
    const magnitude = FP_Quantity._yearMonthConversionFactor[value.unit];
    if (magnitude) {
      return '_!yearMonth!_:' + magnitude * value.value;
    } else {
      const ucumQuantity = FP_Quantity.toUcumQuantity(value.value, value.unit);
      const unit = ucumUtils.getSpecifiedUnit(ucumQuantity.unit).unit;
      return '_!' + unit.property_ + '!_:' + unit.magnitude_ * ucumQuantity.value;
    }
  } else if (value instanceof FP_Type) {
    return value.toString();
  } else if (typeof value === 'object') {
    return Array.isArray(value) ? value.map(prepareObject) : Object.keys(value).sort().reduce((o, key) => {
      const v = value[key];
      o[key] = prepareObject(v);
      return o;
    }, {});
  }
  return value;
}
module.exports = hashObject;

/***/ }),
/* 74 */
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

// Originally copied from node-deep-equal
// (https://github.com/substack/node-deep-equal), with modifications.
// For the license for node-deep-equal, see the bottom of this file.

const {
  FP_Type,
  FP_Quantity,
  ResourceNode
} = __webpack_require__(54);
var numbers = __webpack_require__(61);
var pSlice = Array.prototype.slice;
var objectKeys = Object.keys;
var isArguments = function (object) {
  return Object.prototype.toString.call(object) === '[object Arguments]';
};
function isString(myVar) {
  return typeof myVar === 'string' || myVar instanceof String;
}
function isNumber(n) {
  return !isNaN(parseFloat(n)) && isFinite(n);
}
function normalizeStr(x) {
  return x.toUpperCase().replace(/\s+/, ' ');
}

/**
 * Performs a deep comparison between two values to determine if they are equal.
 * When you need to compare many objects, you can use hashObject instead for
 * optimization (if changes are needed here, they are likely also needed there).
 * @param {any} v1 - one of the comparing objects
 * @param {any} v2 - one of the comparing objects
 * @param {Object} [opts] - comparison options
 * @param {boolean} [opts.fuzzy] - false (by default), if comparing objects for
 *   equality (see https://hl7.org/fhirpath/#equals).
 *   true, if comparing objects for equivalence
 *   (see https://hl7.org/fhirpath/#equivalent).
 * @return {boolean}
 */
function deepEqual(v1, v2, opts) {
  const v1IsResourceNode = v1 instanceof ResourceNode;
  const v2IsResourceNode = v2 instanceof ResourceNode;
  let actual = v1IsResourceNode ? v1.convertData() : v1;
  let expected = v2IsResourceNode ? v2.convertData() : v2;
  if (!opts) opts = {};

  // 7.1. All identical values are equivalent, as determined by ===.
  if (actual === expected) {
    return opts.fuzzy || !v1IsResourceNode || !v2IsResourceNode || deepEqual(v1._data, v2._data);
  }
  if (opts.fuzzy) {
    if (isString(actual) && isString(expected)) {
      return normalizeStr(actual) === normalizeStr(expected);
    }
    if (isNumber(actual) && isNumber(expected)) {
      return numbers.isEquivalent(actual, expected);
    }
  } else {
    // !opts.fuzzy
    // If these are numbers, they need to be rounded to the maximum supported
    // precision to remove floating point arithmetic errors (e.g. 0.1+0.1+0.1 should
    // equal 0.3) before comparing.
    if (typeof actual === 'number' && typeof expected === 'number') {
      if (numbers.isEqual(actual, expected)) {
        return v1IsResourceNode && v2IsResourceNode ? deepEqual(v1._data, v2._data, opts) : true;
      } else {
        return false;
      }
    }
  }
  if (actual instanceof Date && expected instanceof Date) {
    return actual.getTime() === expected.getTime() && (opts.fuzzy || !v1IsResourceNode || !v2IsResourceNode || deepEqual(v1._data, v2._data));
  } else if (!actual || !expected || typeof actual != 'object' && typeof expected != 'object') {
    return actual === expected && (opts.fuzzy || !v1IsResourceNode || !v2IsResourceNode || deepEqual(v1._data, v2._data));
  } else {
    var actualIsFPT = actual instanceof FP_Type;
    var expectedIsFPT = expected instanceof FP_Type;
    if (actualIsFPT && expectedIsFPT) {
      // if both are FP_Type
      if (opts.fuzzy) {
        return actual.equivalentTo(expected);
      } else {
        let result = actual.equals(expected); // May return undefined
        if (result) {
          return !v1IsResourceNode || !v2IsResourceNode || deepEqual(v1._data, v2._data) && deepEqual(v1.data?.id, v2.data?.id) && deepEqual(v1.data?.extension, v2.data?.extension);
        } else {
          return result;
        }
      }
    } else if (actualIsFPT || expectedIsFPT) {
      // if only one is an FP_Type
      let anotherIsNumber = false;
      if (typeof actual == 'number') {
        actual = new FP_Quantity(actual, "'1'");
        anotherIsNumber = true;
      }
      if (typeof expected == 'number') {
        expected = new FP_Quantity(expected, "'1'");
        anotherIsNumber = true;
      }
      if (anotherIsNumber) {
        return opts.fuzzy ? actual.equivalentTo(expected) : actual.equals(expected);
      }
      return false;
    }
    // 7.4. For all other Object pairs, including Array objects, equivalence is
    // determined by having the same number of owned properties (as verified
    // with Object.prototype.hasOwnProperty.call), the same set of keys
    // (although not necessarily the same order), equivalent values for every
    // corresponding key, and an identical 'prototype' property. Note: this
    // accounts for both named and indexed properties on Arrays.
    return objEquiv(actual, expected, opts);
  }
}
function isUndefinedOrNull(value) {
  return value === null || value === undefined;
}
function objEquiv(a, b, opts) {
  var i, key;
  if (isUndefinedOrNull(a) || isUndefinedOrNull(b)) return false;
  // an identical 'prototype' property.
  if (a.prototype !== b.prototype) return false;
  //~~~I've managed to break Object.keys through screwy arguments passing.
  //   Converting to array solves the problem.
  if (isArguments(a) || isArguments(b)) {
    a = isArguments(a) ? pSlice.call(a) : a;
    b = isArguments(b) ? pSlice.call(b) : b;
    return deepEqual(a, b, opts);
  }
  try {
    var ka = objectKeys(a),
      kb = objectKeys(b);
  } catch (e) {
    //happens when one is a string literal and the other isn't
    return false;
  }
  // having the same number of owned properties (keys incorporates
  // hasOwnProperty)
  if (ka.length != kb.length) return false;
  //the same set of keys (although not necessarily the same order),
  ka.sort();
  kb.sort();
  //~~~cheap key test
  for (i = ka.length - 1; i >= 0; i--) {
    if (ka[i] != kb[i]) return false;
  }
  //equivalent values for every corresponding key, and
  //~~~possibly expensive deep test
  // If the length of the array is one, return the value of deepEqual (which can
  // be "undefined".
  if (ka.length === 1) {
    key = ka[0];
    return deepEqual(a[key], b[key], opts);
  }
  for (i = ka.length - 1; i >= 0; i--) {
    key = ka[i];
    if (!deepEqual(a[key], b[key], opts)) return false;
  }
  return typeof a === typeof b;
}
module.exports = {
  deepEqual,
  // Maximum collection length to use deepEqual(). When comparing a large number
  // of collection items, it is more efficient to convert the items to strings
  // using the hashObject() function and compare them.
  maxCollSizeForDeepEqual: 6
};

// The license for node-deep-equal, on which the above code is based, is as
// follows:
//
// This software is released under the MIT license:
//
// Permission is hereby granted, free of charge, to any person obtaining a copy of
// this software and associated documentation files (the "Software"), to deal in
// the Software without restriction, including without limitation the rights to
// use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
// the Software, and to permit persons to whom the Software is furnished to do so,
// subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
// FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
// COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
// IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
// CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

/***/ }),
/* 75 */
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

// This file holds code to hande the FHIRPath Existence functions (5.1 in the
// specification).

var util = __webpack_require__(53);
var types = __webpack_require__(54);
const {
  FP_Quantity,
  TypeInfo
} = types;
var engine = {};
engine.iifMacro = function (data, cond, ok, fail) {
  const condition = cond(data);
  if (condition instanceof Promise) {
    return condition.then(c => iifMacroSync(data, c, ok, fail));
  }
  return iifMacroSync(data, condition, ok, fail);
};
function iifMacroSync(data, condition, ok, fail) {
  if (util.isTrue(condition)) {
    return ok(data);
  } else {
    return fail ? fail(data) : [];
  }
}
engine.traceFn = function (x, label, expr) {
  const exprRes = expr ? expr(x) : null;
  if (exprRes instanceof Promise) {
    return exprRes.then(r => engine.traceFn(x, label, r));
  }
  if (this.customTraceFn) {
    if (expr) {
      this.customTraceFn(expr(x), label ?? "");
    } else {
      this.customTraceFn(x, label ?? "");
    }
  } else {
    if (expr) {
      console.log("TRACE:[" + (label || "") + "]", JSON.stringify(expr(x), null, " "));
    } else {
      console.log("TRACE:[" + (label || "") + "]", JSON.stringify(x, null, " "));
    }
  }
  return x;
};

/**
 * Defines a variable named name that is accessible in subsequent expressions
 * and has the value of expr if present, otherwise the value of the input
 * collection.
 * @param {Array} x - the input collection on which the function is executed
 * @param {string} label - the name of the variable to define
 * @param {*} [expr] - an expression to run on the input collection
 * @returns the value of the input collection (The function should be transparent
 *  to the caller)
 */
engine.defineVariable = function (x, label, expr) {
  let data = x;
  if (expr) {
    data = expr(x);
  }
  // Just in time initialization of definedVars
  if (!this.definedVars) this.definedVars = {};
  if (label in this.vars || label in this.processedVars) {
    throw new Error("Environment Variable %" + label + " already defined");
  }
  if (Object.keys(this.definedVars).includes(label)) {
    throw new Error("Variable %" + label + " already defined");
  }
  this.definedVars[label] = data;
  return x;
};
var intRegex = /^[+-]?\d+$/;
engine.toInteger = function (coll) {
  if (coll.length !== 1) {
    return [];
  }
  var v = util.valData(coll[0]);
  if (v === false) {
    return 0;
  }
  if (v === true) {
    return 1;
  }
  if (typeof v === "number") {
    if (Number.isInteger(v)) {
      return v;
    } else {
      return [];
    }
  }
  if (typeof v === "string" && intRegex.test(v)) {
    return parseInt(v);
  }
  return [];
};
const quantityRegex = /^((\+|-)?\d+(\.\d+)?)\s*(('[^']+')|([a-zA-Z]+))?$/,
  quantityRegexMap = {
    value: 1,
    unit: 5,
    time: 6
  };
engine.toQuantity = function (coll, toUnit) {
  let result;
  if (coll.length > 1) {
    throw new Error("Could not convert to quantity: input collection contains multiple items");
  } else if (coll.length === 1) {
    if (toUnit) {
      const thisUnitInSeconds = FP_Quantity._calendarDuration2Seconds[this.unit];
      const toUnitInSeconds = FP_Quantity._calendarDuration2Seconds[toUnit];
      if (!thisUnitInSeconds !== !toUnitInSeconds && (thisUnitInSeconds > 1 || toUnitInSeconds > 1)) {
        // Conversion from calendar duration quantities greater than seconds to
        // time-valued UCUM quantities greater than seconds or vice versa is not
        // allowed.
        return null;
      }

      // Surround UCUM unit code in the toUnit parameter with single quotes
      if (!FP_Quantity.mapTimeUnitsToUCUMCode[toUnit]) {
        toUnit = `'${toUnit}'`;
      }
    }
    var v = util.valDataConverted(coll[0]);
    let quantityRegexRes;
    if (typeof v === "number") {
      result = new FP_Quantity(v, '\'1\'');
    } else if (v instanceof FP_Quantity) {
      result = v;
    } else if (typeof v === 'boolean') {
      result = new FP_Quantity(v ? 1 : 0, '\'1\'');
    } else if (typeof v === "string" && (quantityRegexRes = quantityRegex.exec(v))) {
      const value = quantityRegexRes[quantityRegexMap.value],
        unit = quantityRegexRes[quantityRegexMap.unit],
        time = quantityRegexRes[quantityRegexMap.time];

      // UCUM unit code in the input string must be surrounded with single quotes
      if (!time || FP_Quantity.mapTimeUnitsToUCUMCode[time]) {
        result = new FP_Quantity(Number(value), unit || time || '\'1\'');
      }
    }
    if (result && toUnit && result.unit !== toUnit) {
      result = FP_Quantity.convUnitTo(result.unit, result.value, toUnit);
    }
  }
  return result || [];
};
var numRegex = /^[+-]?\d+(\.\d+)?$/;
engine.toDecimal = function (coll) {
  if (coll.length !== 1) {
    return [];
  }
  var v = util.valData(coll[0]);
  if (v === false) {
    return 0;
  }
  if (v === true) {
    return 1.0;
  }
  if (typeof v === "number") {
    return v;
  }
  if (typeof v === "string" && numRegex.test(v)) {
    return parseFloat(v);
  }
  return [];
};
engine.toString = function (coll) {
  if (coll.length !== 1) {
    return [];
  }
  var v = util.valDataConverted(coll[0]);
  if (v == null) {
    return [];
  }
  return v.toString();
};

/**
 *  Defines a function on engine called to+timeType (e.g., toDateTime, etc.).
 * @param timeType The string name of a class for a time type (e.g. "FP_DateTime").
 */
function defineTimeConverter(timeType) {
  let timeName = timeType.slice(3); // Remove 'FP_'
  engine['to' + timeName] = function (coll) {
    var rtn = [];
    if (coll.length > 1) throw Error('to ' + timeName + ' called for a collection of length ' + coll.length);
    if (coll.length === 1) {
      var v = util.valData(coll[0]);
      if (typeof v === "string") {
        var t = types[timeType].checkString(v);
        if (t) {
          rtn = t;
        }
      }
    }
    return rtn;
  };
}
defineTimeConverter('FP_Date');
defineTimeConverter('FP_DateTime');
defineTimeConverter('FP_Time');

// Possible string values convertible to the true boolean value
const trueStrings = ['true', 't', 'yes', 'y', '1', '1.0'].reduce((acc, val) => {
  acc[val] = true;
  return acc;
}, {});

// Possible string values convertible to the false boolean value
const falseStrings = ['false', 'f', 'no', 'n', '0', '0.0'].reduce((acc, val) => {
  acc[val] = true;
  return acc;
}, {});
engine.toBoolean = function (coll) {
  if (coll.length !== 1) {
    return [];
  }
  const v = util.valData(coll[0]);
  switch (typeof v) {
    case 'boolean':
      return v;
    case 'number':
      if (v === 1) {
        return true;
      }
      if (v === 0) {
        return false;
      }
      break;
    case 'string':
      // eslint-disable-next-line no-case-declarations
      const lowerCaseValue = v.toLowerCase();
      if (trueStrings[lowerCaseValue]) {
        return true;
      }
      if (falseStrings[lowerCaseValue]) {
        return false;
      }
  }
  return [];
};

/**
 * Creates function that checks if toFunction returns specified type
 * @param {function(coll: array): <type|[]>} toFunction
 * @param {string|class} type - specifies type, for example: 'string' or FP_Quantity
 * @return {function(coll: array)}
 */
engine.createConvertsToFn = function (toFunction, type) {
  if (typeof type === 'string') {
    return function (coll) {
      if (coll.length !== 1) {
        return [];
      }
      return typeof toFunction(coll) === type;
    };
  }
  return function (coll) {
    if (coll.length !== 1) {
      return [];
    }
    return toFunction(coll) instanceof type;
  };
};
const singletonEvalByType = {
  "Integer": function (d) {
    if (Number.isInteger(d)) {
      return d;
    }
  },
  "Boolean": function (d) {
    if (d === true || d === false) {
      return d;
    } else {
      return true;
    }
  },
  "Number": function (d) {
    if (typeof d === "number") {
      return d;
    }
  },
  "String": function (d) {
    if (typeof d === "string") {
      return d;
    }
  },
  "StringOrNumber": function (d) {
    if (typeof d === "string" || typeof d === "number") {
      return d;
    }
  },
  "AnySingletonAtRoot": function (d) {
    return d;
  }
};

/**
 * Converts a collection to a singleton of the specified type.
 * The result can be an empty array if input collection is empty.
 * See http://hl7.org/fhirpath/#singleton-evaluation-of-collections for details.
 * @param {Array} coll - collection
 * @param {string} type - 'Integer', 'Boolean', 'Number' or 'String'
 * @throws {Error}  if there is more than one item in input collection,
 *   or an item that is not a specified type
 * @return {*|[]} the value of specified type or empty array
 */
engine.singleton = function (coll, type) {
  if (coll.length > 1) {
    throw new Error("Unexpected collection" + JSON.stringify(coll) + "; expected singleton of type " + type);
  } else if (coll.length === 0) {
    return [];
  }
  const v = util.valData(coll[0]);
  if (v == null) {
    return [];
  }
  const toSingleton = singletonEvalByType[type];
  if (toSingleton) {
    const value = toSingleton(v);
    if (value !== undefined) {
      return value;
    }
    throw new Error(`Expected ${type.toLowerCase()}, but got: ${JSON.stringify(coll)}`);
  }
  throw new Error('Not supported type ' + type);
};
engine.hasValueFn = function (coll) {
  return coll.length === 1 && util.valData(coll[0]) != null && TypeInfo.isPrimitiveValue(coll[0]);
};

/**
 * Returns the underlying system value for the FHIR primitive if the input
 * collection contains a single value which is a FHIR primitive, and it has a
 * primitive value. Otherwise, the return value is empty (i.e. []).
 *
 * See: https://hl7.org/fhir/fhirpath.html#functions
 * @param {Array<*>} coll - input collection
 * @returns {*|[]}
 */
engine.getValueFn = function (coll) {
  if (coll.length === 1) {
    const node = coll[0];
    const v = util.valData(node);
    if (v != null && TypeInfo.isPrimitiveValue(node)) {
      return v;
    }
  }
  return [];
};
module.exports = engine;

/***/ }),
/* 76 */
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

// Contains the FHIRPath Aggregate functions.
// (Section 7 of the FHIRPath 2.0.0 (N1) specification).

let engine = {};
const math = __webpack_require__(77);
const equality = __webpack_require__(78);
const util = __webpack_require__(53);
engine.aggregateMacro = function (data, expr, initialValue) {
  return data.reduce((total, x, i) => {
    if (total instanceof Promise) {
      return total.then(t => {
        this.$index = i;
        this.$total = t;
        return this.$total = expr(x);
      });
    } else {
      this.$index = i;
      return this.$total = expr(x);
    }
  }, this.$total = initialValue);
};
engine.countFn = function (x) {
  if (x && x.length) {
    return x.length;
  } else {
    return 0;
  }
};

// Shortcut for "value.tail().aggregate($this+$total, value.first())" `
engine.sumFn = function (data) {
  return engine.aggregateMacro.apply(this, [data.slice(1), $this => {
    let x = util.arraify($this).filter(i => util.valData(i) != null);
    let y = util.arraify(this.$total).filter(i => util.valData(i) != null);
    if (x.length === 0 || y.length === 0) {
      return [];
    }
    return math.plus(x, y);
  }, data[0]]);
};

/**
 * Shortcut for "[source collection].aggregate(iif($total.empty(), $this, iif($this [operator] $total, $this, $total)))"
 * Used for functions min() and max().
 * @param {Array} data - source collection
 * @param {Function} fn - operator function
 * @return {Array}
 */
function minMaxShortcutTemplate(data, fn) {
  let $total;
  if (data.length === 0 || util.valData(data[0]) == null) {
    $total = [];
  } else {
    $total = [data[0]];
    for (let i = 1; i < data.length; i++) {
      if (util.valData(data[i]) == null) {
        $total = [];
        break;
      }
      const $this = [data[i]];
      $total = util.isTrue(fn($this, $total)) ? $this : $total;
    }
  }
  return $total;
}

// Shortcut for "value.aggregate(iif($total.empty(), $this, iif($this < $total, $this, $total)))"
engine.minFn = function (data) {
  return minMaxShortcutTemplate(data, equality.lt);
};

// Shortcut for "value.aggregate(iif($total.empty(), $this, iif($this > $total, $this, $total)))"
engine.maxFn = function (data) {
  return minMaxShortcutTemplate(data, equality.gt);
};

// Shortcut for "value.sum()/value.count()"
engine.avgFn = function (data) {
  const x = util.arraify(engine.sumFn(data));
  const y = util.arraify(engine.countFn(data));
  if (x.length === 0 || y.length === 0) {
    return [];
  }
  return math.div(x, y);
};
module.exports = engine;

/***/ }),
/* 77 */
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

// This file holds code to hande the FHIRPath Math functions.

const {
  FP_Quantity,
  FP_Type
} = __webpack_require__(54);
const util = __webpack_require__(53);

/**
 *  Adds the math functions to the given FHIRPath engine.
 */
const engine = {};

/**
 * Checks if input collection is a number singleton and runs the passed function.
 * @param {Array<ResourceNode|number|any>} x - input collection
 * @param {Function} fn - math function
 * @throws Error
 * @return {number}
 */
function callFnForNumericSingleton(x, fn) {
  let res;
  if (isEmpty(x)) {
    res = [];
  } else if (x.length !== 1) {
    throw new Error("Unexpected collection" + JSON.stringify(x) + "; expected singleton of type number");
  } else {
    const num = util.valData(x[0]);
    if (num == null) {
      res = [];
    } else if (typeof num === 'number') {
      res = fn(num);
    } else {
      throw new Error("Expected number, but got " + JSON.stringify(num));
    }
  }
  return res;
}
function isEmpty(x) {
  if (typeof x == 'number') {
    return false;
  }
  return x.length === 0;
}
engine.amp = function (x, y) {
  return (x || "") + (y || "");
};

//HACK: for only polymorphic function
//  Actually, "minus" is now also polymorphic
engine.plus = function (xs, ys) {
  let res;
  if (xs.length === 1 && ys.length === 1) {
    const x = util.valDataConverted(xs[0]);
    const y = util.valDataConverted(ys[0]);
    // In the future, this and other functions might need to return ResourceNode
    // to preserve the type information (integer vs decimal, and maybe decimal
    // vs string if decimals are represented as strings), in order to support
    // "as" and "is", but that support is deferred for now.
    if (x == null || y == null) {
      res = [];
    } else if (typeof x == "string" && typeof y == "string") {
      res = x + y;
    } else if (typeof x == "number") {
      if (typeof y == "number") {
        res = x + y;
      } else if (y instanceof FP_Quantity) {
        res = new FP_Quantity(x, "'1'").plus(y);
      }
    } else if (x instanceof FP_Type) {
      if (y instanceof FP_Quantity) {
        res = x.plus(y);
      } else if (y instanceof FP_Type) {
        res = y.plus(x);
      } else if (typeof y == "number") {
        res = x.plus(new FP_Quantity(y, "'1'"));
      }
    }
  }
  if (res === undefined) {
    throw new Error("Cannot " + JSON.stringify(xs) + " + " + JSON.stringify(ys));
  }
  return res;
};
engine.minus = function (xs, ys) {
  if (xs.length === 1 && ys.length === 1) {
    const x = util.valDataConverted(xs[0]);
    const y = util.valDataConverted(ys[0]);
    if (x == null || y == null) {
      return [];
    }
    if (typeof x == "number") {
      if (typeof y == "number") {
        return x - y;
      }
      if (y instanceof FP_Quantity) {
        return new FP_Quantity(x, "'1'").plus(new FP_Quantity(-y.value, y.unit));
      }
    }
    if (x instanceof FP_Type) {
      if (y instanceof FP_Quantity) {
        return x.plus(new FP_Quantity(-y.value, y.unit));
      }
      if (typeof y == "number") {
        return x.plus(new FP_Quantity(-y, "'1'"));
      }
    }
  }
  throw new Error("Cannot " + JSON.stringify(xs) + " - " + JSON.stringify(ys));
};
engine.mul = function (xs, ys) {
  if (xs.length === 1 && ys.length === 1) {
    const x = util.valDataConverted(xs[0]);
    const y = util.valDataConverted(ys[0]);
    if (x == null || y == null) {
      return [];
    }
    if (typeof x == "number") {
      if (typeof y == "number") {
        return x * y;
      }
      if (y instanceof FP_Quantity) {
        return new FP_Quantity(x, "'1'").mul(y);
      }
    }
    if (x instanceof FP_Type) {
      if (y instanceof FP_Quantity) {
        return x.mul(y);
      }
      if (typeof y == 'number') {
        return x.mul(new FP_Quantity(y, "'1'"));
      }
    }
  }
  throw new Error("Cannot " + JSON.stringify(xs) + " * " + JSON.stringify(ys));
};
engine.div = function (xs, ys) {
  if (xs.length === 1 && ys.length === 1) {
    const x = util.valDataConverted(xs[0]);
    const y = util.valDataConverted(ys[0]);
    if (x == null || y == null) {
      return [];
    }
    if (typeof x == "number") {
      if (typeof y == "number") {
        if (y === 0) return [];
        return x / y;
      }
      if (y instanceof FP_Quantity) {
        return new FP_Quantity(x, "'1'").div(y);
      }
    }
    if (x instanceof FP_Type) {
      if (y instanceof FP_Quantity) {
        return x.div(y);
      }
      if (typeof y == "number") {
        return x.div(new FP_Quantity(y, "'1'"));
      }
    }
  }
  throw new Error("Cannot " + JSON.stringify(xs) + " / " + JSON.stringify(ys));
};
engine.intdiv = function (x, y) {
  if (y === 0) return [];
  return Math.floor(x / y);
};
engine.mod = function (x, y) {
  if (y === 0) return [];
  return x % y;
};
engine.abs = function (x) {
  let res;
  if (isEmpty(x)) {
    res = [];
  } else if (x.length !== 1) {
    throw new Error("Unexpected collection" + JSON.stringify(x) + "; expected singleton of type number or Quantity");
  } else {
    var val = util.valData(x[0]);
    if (val == null) {
      res = [];
    } else if (typeof val === 'number') {
      res = Math.abs(val);
    } else if (val instanceof FP_Quantity) {
      res = new FP_Quantity(Math.abs(val.value), val.unit);
    } else {
      throw new Error("Expected number or Quantity, but got " + JSON.stringify(val || x));
    }
  }
  return res;
};
engine.ceiling = function (x) {
  return callFnForNumericSingleton(x, Math.ceil);
};
engine.exp = function (x) {
  return callFnForNumericSingleton(x, Math.exp);
};
engine.floor = function (x) {
  return callFnForNumericSingleton(x, Math.floor);
};
engine.ln = function (x) {
  return callFnForNumericSingleton(x, Math.log);
};
engine.log = function (x, base) {
  return callFnForNumericSingleton(x, num => {
    return Math.log(num) / Math.log(base);
  });
};
engine.power = function (x, exponent) {
  return callFnForNumericSingleton(x, num => {
    const res = Math.pow(num, exponent);
    return isNaN(res) ? [] : res;
  });
};

/**
 * Implements the "round" function documented at
 * https://hl7.org/fhirpath/#roundprecision-integer-decimal
 * @param {Array} x - input collection
 * @param {integer} [precision] - determines what decimal place to round to
 * @return {number}
 */
engine.round = function (x, precision) {
  return callFnForNumericSingleton(x, num => {
    if (precision === undefined) {
      return Math.round(num);
    } else {
      let degree = Math.pow(10, precision);
      return Math.round(num * degree) / degree;
    }
  });
};
engine.sqrt = function (x) {
  return callFnForNumericSingleton(x, num => {
    if (num < 0) {
      return [];
    } else {
      return Math.sqrt(num);
    }
  });
};
engine.truncate = function (x) {
  return callFnForNumericSingleton(x, Math.trunc);
};
module.exports = engine;

/***/ }),
/* 78 */
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

// This file holds code to handle the FHIRPath Math functions.

const util = __webpack_require__(53);
const {
  deepEqual
} = __webpack_require__(74);
const types = __webpack_require__(54);
const FP_Type = types.FP_Type;
const FP_DateTime = types.FP_DateTime;
var engine = {};
function equality(x, y) {
  if (util.isEmpty(x) || util.isEmpty(y)) {
    return [];
  }
  return deepEqual(x, y);
}
function equivalence(x, y) {
  if (util.isEmpty(x) && util.isEmpty(y)) {
    return [true];
  }
  if (util.isEmpty(x) || util.isEmpty(y)) {
    return [];
  }
  return deepEqual(x, y, {
    fuzzy: true
  });
}
engine.equal = function (a, b) {
  return equality(a, b);
};
engine.unequal = function (a, b) {
  var eq = equality(a, b);
  return eq === undefined ? undefined : !eq;
};
engine.equival = function (a, b) {
  return equivalence(a, b);
};
engine.unequival = function (a, b) {
  return !equivalence(a, b);
};

/**
 *  Checks that the types of a and b are suitable for comparison in an
 *  inequality expression.
 * @param a the left side of the inequality expression (which should be an array of
 *  one value).
 * @param b the right side of the inequality expression (which should be an array of
 *  one value).
 * @return the singleton values of the arrays a, and b.  If one was an FP_Type
 *  and the other was convertible, the converted value will be returned.
 */
function typecheck(a, b) {
  util.assertOnlyOne(a, "Singleton was expected");
  util.assertOnlyOne(b, "Singleton was expected");
  a = util.valDataConverted(a[0]);
  b = util.valDataConverted(b[0]);
  if (a != null && b != null) {
    let lClass = a instanceof FP_DateTime ? FP_DateTime : a.constructor;
    let rClass = b instanceof FP_DateTime ? FP_DateTime : b.constructor;
    if (lClass !== rClass) {
      util.raiseError('Type of "' + a + '" (' + lClass.name + ') did not match type of "' + b + '" (' + rClass.name + ')', 'InequalityExpression');
    }
  }
  return [a, b];
}
engine.lt = function (a, b) {
  const [a0, b0] = typecheck(a, b);
  if (a0 == null || b0 == null) {
    return [];
  }
  if (a0 instanceof FP_Type) {
    const compare = a0.compare(b0);
    return compare === null ? [] : compare < 0;
  }
  return a0 < b0;
};
engine.gt = function (a, b) {
  const [a0, b0] = typecheck(a, b);
  if (a0 == null || b0 == null) {
    return [];
  }
  if (a0 instanceof FP_Type) {
    const compare = a0.compare(b0);
    return compare === null ? [] : compare > 0;
  }
  return a0 > b0;
};
engine.lte = function (a, b) {
  const [a0, b0] = typecheck(a, b);
  if (a0 == null || b0 == null) {
    return [];
  }
  if (a0 instanceof FP_Type) {
    const compare = a0.compare(b0);
    return compare === null ? [] : compare <= 0;
  }
  return a0 <= b0;
};
engine.gte = function (a, b) {
  const [a0, b0] = typecheck(a, b);
  if (a0 == null || b0 == null) {
    return [];
  }
  if (a0 instanceof FP_Type) {
    const compare = a0.compare(b0);
    return compare === null ? [] : compare >= 0;
  }
  return a0 >= b0;
};
module.exports = engine;

/***/ }),
/* 79 */
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

// Contains the supplementary FHIRPath functions defined in the Structured Data
// Capture IG, https://hl7.org/fhir/uv/sdc/expressions.html#fhirpath-supplements.

let engine = {};
const util = __webpack_require__(53);

/**
 * Returns numeric values from the score extension associated with the input
 * collection of resource nodes (e.g. QuestionnaireResponse item answers).
 *
 * Currently, when searching for a score extension, we respect the "Context of
 * Use" for each possible extension used to store a score. See:
 *   * https://www.hl7.org/fhir/extensions/StructureDefinition-itemWeight.html
 *   * https://build.fhir.org/ig/HL7/fhir-extensions/StructureDefinition-itemWeight.html
 *   * https://hl7.org/fhir/R5/codesystem.html#defined-props
 *   * https://www.hl7.org/fhir/codesystem-concept-properties.html
 *   * https://www.hl7.org/fhir/R4/extension-ordinalvalue.html
 *
 * Since the first mention of the ordinal() (a.k.a. weight()) function was in
 * SDC 3 (https://hl7.org/fhir/uv/sdc/expressions.html#fhirpath-supplements),
 * we don't support this function in STU3 and DSTU2 for extensions described in
 * these links:
 *   * https://www.hl7.org/fhir/stu3/extension-questionnaire-ordinalvalue.html
 *   * https://www.hl7.org/fhir/stu3/extension-valueset-ordinalvalue.html
 *   * https://hl7.org/fhir/STU3/extension-iso21090-co-value.html
 *   * https://hl7.org/fhir/DSTU2/questionnaire.html#4.26.5.9
 *   * https://hl7.org/fhir/DSTU2/extension-iso21090-co-value.html
 *   * https://hl7.org/fhir/DSTU2/extension-valueset-ordinalvalue.html
 *
 * Also, according to the resolution of this JIRA issue
 * https://jira.hl7.org/browse/FHIR-49329, we support
 * a score extension for all possible [x] in value[x] in QuestionnaireResponse
 * answers.
 *
 * We search for the first score extension for each source node to add its value
 * to the result in the following order:
 * 1. Check the source node for a score extension.
 * 2. If the source node is an answer from a `QuestionnaireResponse` or its
 *    `value[x]`:
 *     - Check the `value[x]` element for a score extension.
 *     - Check the corresponding answer option (if any) of the corresponding
 *       `Questionnaire` item for a score extension.
 *     - Otherwise, if the `Questionnaire` item references a contained `ValueSet`,
 *       check the corresponding element there for a score extension.
 * 4. If the source resource (to which the source node belongs, e.g.
 *    `QuestionnaireResponse`) or `Questionnaire` contains a corresponding
 *    `CodeSystem`, check for a score extension (for R4) or property (for R5)
 *    there.
 * 5. Look for a score extension (for R4) or property (for R5) in the
 *    corresponding `CodeSystem` loaded from the terminology server.
 * @param {Array} coll - resource nodes
 * @return {(number|Promise<number>)[]}
 */
engine.weight = function (coll) {
  const ctx = this;
  if (!ctx.model?.score) {
    throw new Error("The weight()/ordinal() function is not supported for the current model.");
  }
  if (coll !== false && !coll) {
    return [];
  }
  const res = [];
  const questionnaire = this.vars.questionnaire || this.processedVars.questionnaire?.data;
  let hasPromise = false;
  coll.forEach(elem => {
    if (elem?.data) {
      const {
        score: embeddedScore,
        isQuestionnaireResponse,
        value,
        valueType
      } = getResourceNodeInfo(ctx, elem);
      if (embeddedScore !== undefined) {
        // if we have a score extension in the source item, use it.
        res.push(embeddedScore);
      } else if (isQuestionnaireResponse && value != null && valueType) {
        const linkIds = getLinkIds(elem);
        if (questionnaire) {
          const qItem = getQItemByLinkIds(ctx.model?.version, questionnaire, linkIds);
          if (qItem) {
            const qItemInfo = getQuestionnaireItemInfo(ctx, qItem, value, valueType);
            if (qItemInfo.score !== undefined) {
              // if we have a score extension for the answerOption, use it.
              res.push(qItemInfo.score);
            } else if (qItemInfo.answerOption && value.system || qItemInfo.answerValueSet) {
              // Otherwise, check corresponding value set and code system
              hasPromise = addWeightFromCorrespondingResourcesToResult(res, ctx, questionnaire, qItemInfo.answerValueSet, value.code, value.system, elem) || hasPromise;
            }
          } else {
            throw new Error('Questionnaire item with this linkId were not found: ' + elem.parentResNode.data.linkId + '.');
          }
        } else {
          throw new Error('%questionnaire is needed but not specified.');
        }
      } else if (valueType === 'Coding' && value?.system) {
        // If there are no questionnaire (no linkId) check corresponding code system
        hasPromise = addWeightFromCorrespondingResourcesToResult(res, ctx, null, null, value.code, value.system, elem) || hasPromise;
      }
    }
  });
  return hasPromise ? Promise.all(res) : res;
};

/**
 * Returns the score extension value for the specified ResourceNode, a flag
 * indicating that the ResourceNode belongs to an answer in the
 * QuestionnaireResponse, a node value and its capitalized data type name that
 * can be used to further search for the score if the score extension is not
 * embedded in the node.
 * @param {Object} ctx - object describing the context of expression
 *  evaluation (see the "applyParsedPath" function).
 * @param {ResourceNode} rNode - resource node.
 * @returns {{
 *   score: (number|undefined),
 *   isQuestionnaireResponse: (true|false|undefined),
 *   value: (any)
 *   valueType: (string)
 *   }}
 */
function getResourceNodeInfo(ctx, rNode) {
  const scorePropertyUri = ctx.model.score.propertyURI;
  const scoreExtensionUri = ctx.model.score.extensionURI;
  let score;
  let isQuestionnaireResponse;
  let value;
  let valueType;
  let valueProp;
  switch (rNode.path) {
    case 'Coding':
      isQuestionnaireResponse = rNode.parentResNode?.path === 'QuestionnaireResponse.item.answer';
      score = getScoreExtensionValue(rNode.data, scoreExtensionUri);
      value = rNode.data;
      valueType = 'Coding';
      break;
    case 'Questionnaire.item.answerOption':
      score = getScoreExtensionValue(rNode.data, scoreExtensionUri);
      value = rNode.data;
      // No need to return value and valueType, because there is no further search;
      break;
    case 'QuestionnaireResponse.item.answer':
      isQuestionnaireResponse = true;
      // eslint-disable-next-line no-fallthrough
      valueProp = rNode.data && Object.keys(rNode.data).find(p => p.length > 5 && p.startsWith('value'));
      if (valueProp) {
        valueType = valueProp.substring(5);
        value = rNode.data[valueProp];
        score = getScoreExtensionValue(rNode.data['_' + valueProp] || value, scoreExtensionUri);
      }
      break;
    case 'ValueSet.compose.include.concept':
      if (!ctx.model.score.propertyURI) {
        score = getScoreExtensionValue(rNode.data, scoreExtensionUri);
      }
      // Create a fake node value to allow further search in CodeSystem
      value = {
        code: rNode.data.code,
        system: rNode.parentResNode?.data.system
      };
      valueType = 'Coding';
      break;
    case 'ValueSet.expansion.contains':
      if (scorePropertyUri) {
        const scorePropertyCode = getPropertyCode(rNode.parentResNode?.data.property, scorePropertyUri);
        score = getDecimalPropertyValue(rNode.data, scorePropertyCode);
        value = rNode.data;
        valueType = 'Coding';
      }
      break;
    case 'CodeSystem.concept':
      if (scorePropertyUri) {
        const scorePropertyCode = getPropertyCode(rNode.parentResNode?.data.property, scorePropertyUri);
        score = getDecimalPropertyValue(rNode.data, scorePropertyCode);
      } else {
        score = getScoreExtensionValue(rNode.data, scoreExtensionUri);
      }
      // No need to return value and valueType, because there is no further search
      break;
    default:
      isQuestionnaireResponse = rNode.parentResNode?.path === 'QuestionnaireResponse.item.answer';
      if (isQuestionnaireResponse) {
        score = getScoreExtensionValue(rNode._data || rNode.data, scoreExtensionUri);
        value = rNode.data;
        valueType = util.capitalize(rNode.fhirNodeDataType);
      }
  }
  return {
    score,
    isQuestionnaireResponse,
    value,
    valueType
  };
}

/**
 * Returns the value of the score extension from the specified node data.
 * @param {Object|undefined} nodeData - node data.
 * @param {string[]|undefined} extensionURI - score extension URI.
 * @returns {number|undefined}
 */
function getScoreExtensionValue(nodeData, extensionURI) {
  return extensionURI && nodeData?.extension?.find(i => extensionURI.indexOf(i.url) !== -1)?.valueDecimal;
}

/**
 * Returns the score extension value for the specified questionnaire item,
 * the answer option that matches specified value and valueType,
 * and a value set URL specified in the Questionnaire item.
 * @param {Object} ctx - object describing the context of expression
 *  evaluation (see the "applyParsedPath" function).
 * @param {Object} qItem - questionnaire item.
 * @param {any} value - item value.
 * @param {string} valueType - item value type.
 * @returns {{
 *   score: number | undefined,
 *   answerOption: Object | undefined,
 *   answerValueSet: string
 *   }}
 */
function getQuestionnaireItemInfo(ctx, qItem, value, valueType) {
  let compareFn;
  const valuePropName = 'value' + valueType;
  switch (valueType) {
    case 'Attachment':
    case 'Quantity':
    case 'Reference':
      compareFn = o => Object.keys(value).find(propKey => propKey !== 'extension' && o[valuePropName][propKey] !== value[propKey]) === undefined;
      break;
    case 'Coding':
      compareFn = o => o.valueCoding?.code === value.code && o.valueCoding?.system === value.system;
      break;
    default:
      compareFn = o => o[valuePropName] === value;
  }
  const answerOption = qItem?.answerOption?.find(compareFn);
  const score = getScoreExtensionValue(answerOption, ctx.model.score.extensionURI);
  const answerValueSet = qItem?.answerValueSet;
  return {
    score,
    answerOption,
    answerValueSet
  };
}

// Object for storing received scores
const weightCache = {};
// Duration of data storage in cache.
const cacheStorageTime = 3600000; // 1 hour = 60 * 60 * 1000

/**
 * Caches score.
 * @param {string} key - key to store score in cache.
 * @param {number|Promise} value - value of score or promise of value.
 */
function putScoreToCache(key, value) {
  weightCache[key] = {
    timestamp: Date.now(),
    value
  };
}

/**
 * Checks if there is an unexpired score in the cache.
 * @param {string} key - key to store score in cache.
 * @return {boolean|undefined}
 */
function hasScoreInCache(key) {
  return weightCache[key] && Date.now() - weightCache[key].timestamp < cacheStorageTime;
}

/**
 * Returns a score or promise of score from the cache. Does not check the
 * expiration time. {@link hasScoreInCache} should be called before this
 * function.
 * @param {string} key - key to store score in cache.
 * @return {number | Promise}
 */
function getScoreFromCache(key) {
  return weightCache[key].value;
}

/**
 * Adds the value of score or its promise received from a corresponding value
 * set or code system to the result array.
 * @param {Array} res - result array.
 * @param {Object} ctx - object describing the context of expression
 *  evaluation (see the "applyParsedPath" function).
 * @param {Object} questionnaire - object containing questionnaire resource data
 * @param {string} vsURL - value set URL specified in the Questionnaire item.
 * @param {string} code - symbol in syntax defined by the system.
 * @param {string} system - code system.
 * @param {ResourceNode|any} elem - source collection item for which we obtain
 *  the score value.
 * @return {boolean} a flag indicating that a promise has been added to the
 *  resulting array.
 */
function addWeightFromCorrespondingResourcesToResult(res, ctx, questionnaire, vsURL, code, system, elem) {
  let score;
  const modelVersion = ctx.model?.version;
  const cacheKey = [modelVersion, questionnaire?.url || questionnaire?.id, ctx.processedVars.terminologies?.terminologyUrl, vsURL, code, system].join('|');
  if (hasScoreInCache(cacheKey)) {
    score = getScoreFromCache(cacheKey);
  } else {
    if (code) {
      if (vsURL) {
        const vsId = /^#(.*)/.test(vsURL) ? RegExp.$1 : null;
        const isAnswerValueSet = vsId ? r => r.id === vsId && r.resourceType === 'ValueSet' : r => r.url === vsURL && r.resourceType === 'ValueSet';
        const containedVS = questionnaire?.contained?.find(isAnswerValueSet);
        if (containedVS) {
          score = getWeightFromVS(ctx, containedVS, code, system);
        } else if (vsId) {
          throw new Error(`Cannot find a contained value set with id: ` + vsId + '.');
        }
      } // end if (vsURL)

      if (system) {
        if (score === undefined || score === null) {
          score = getWeightFromCS(ctx, questionnaire, elem, code, system);
        } else if (score instanceof Promise) {
          score = score.then(weightFromVS => {
            if (weightFromVS !== undefined && weightFromVS !== null) {
              return weightFromVS;
            }
            return getWeightFromCS(ctx, questionnaire, elem, code, system);
          });
        }
      }
    }
    putScoreToCache(cacheKey, score);
  }
  if (score !== undefined) {
    res.push(score);
  }
  return score instanceof Promise;
}

/**
 * Returns the value (or its promise) of the itemWeight property or score
 * extension for the specified system and code from a CodeSystem.
 * @param {Object} ctx - object describing the context of expression
 *  evaluation (see the "applyParsedPath" function). * @param ctx
 * @param {Object} questionnaire - object containing questionnaire resource data
 * @param {ResourceNode|any} elem - source collection item for which we obtain
 *  the score value.
 * @param {string} code - symbol in syntax defined by the system.
 * @param {string} system - code system.
 * @return {number|undefined|Promise<number|undefined>}
 */
function getWeightFromCS(ctx, questionnaire, elem, code, system) {
  const isCodeSystem = r => r.url === system && r.resourceType === 'CodeSystem';
  const containedCS = getContainedResources(elem)?.find(isCodeSystem) || questionnaire?.contained?.find(isCodeSystem);
  let score;
  if (containedCS) {
    const scorePropertyUri = ctx.model?.score.propertyURI;
    if (scorePropertyUri) {
      const scorePropertyCode = getPropertyCode(containedCS?.property, scorePropertyUri);
      if (scorePropertyCode) {
        const item = getCodeSystemItem(containedCS?.concept, code);
        score = getDecimalPropertyValue(item, scorePropertyCode);
      }
    } else {
      const codeSystemExt = ctx.model?.score.extensionURI;
      if (codeSystemExt) {
        const item = getCodeSystemItem(containedCS?.concept, code);
        score = getScoreExtensionValue(item, codeSystemExt);
      }
    }
  } else {
    score = getWeightFromTerminologyCodeSet(ctx, code, system);
  }
  return score;
}

/**
 * Returns a promise to return a score value from the code system obtained from
 * the terminology server.
 * @param {Object} ctx - object describing the context of expression
 *  evaluation (see the "applyParsedPath" function).
 * @param {string} code - symbol in syntax defined by the system.
 * @param {string} system - code system.
 * @return {Promise<number|undefined>}
 */
function getWeightFromTerminologyCodeSet(ctx, code, system) {
  const scorePropertyUri = ctx.model?.score.propertyURI;
  const codeSystemExt = ctx.model?.score.extensionURI;
  const terminologyUrl = getTerminologyUrl(ctx);
  const fetchOptions = {
    headers: {
      'Accept': 'application/fhir+json'
    },
    ...(ctx.signal ? {
      signal: ctx.signal
    } : {})
  };
  return util.fetchWithCache(`${terminologyUrl}/CodeSystem?` + new URLSearchParams({
    url: system,
    ...(scorePropertyUri ? {
      _elements: 'property'
    } : {})
  }).toString(), fetchOptions).then(bundle => {
    if (scorePropertyUri) {
      const scorePropertyCode = getPropertyCode(bundle?.entry?.[0]?.resource?.property, scorePropertyUri);
      if (scorePropertyCode) {
        return util.fetchWithCache(`${terminologyUrl}/CodeSystem/$lookup?` + new URLSearchParams({
          code,
          system,
          property: scorePropertyCode
        }).toString(), fetchOptions).then(parameters => {
          return parameters.parameter.find(p => p.name === 'property' && p.part.find(part => part.name === 'code' && part.valueCode === scorePropertyCode))?.part?.find(p => p.name === 'value')?.valueDecimal;
        });
      }
    } else {
      const item = getCodeSystemItem(bundle?.entry?.[0]?.resource.concept, code);
      return getScoreExtensionValue(item, codeSystemExt);
    }
  });
}

/**
 * Returns the URL of the terminology server.
 * @param {Object} ctx - object describing the context of expression
 *  evaluation (see the "applyParsedPath" function).
 * @return {string}
 */
function getTerminologyUrl(ctx) {
  if (!ctx.async) {
    throw new Error('The asynchronous function "weight"/"ordinal" is not allowed. ' + 'To enable asynchronous functions, use the async=true or async="always"' + ' option.');
  }
  const terminologyUrl = ctx.processedVars.terminologies?.terminologyUrl;
  if (!terminologyUrl) {
    throw new Error('Option "terminologyUrl" is not specified.');
  }
  return terminologyUrl;
}

/**
 * Returns an item from "ValueSet.expansion.contains" that has the specified
 * code and system.
 * @param {Array<Object>} contains - value of "ValueSet.expansion.contains".
 * @param {string} code - symbol in syntax defined by the system.
 * @param {string} system - code system.
 * @return {Object| undefined}
 */
function getValueSetItem(contains, code, system) {
  let result;
  if (contains) {
    for (let i = 0; i < contains.length && !result; i++) {
      const item = contains[i];
      if (item.code === code && item.system === system) {
        result = item;
      } else {
        result = getValueSetItem(item.contains, code, system);
      }
    }
  }
  return result;
}

/**
 * Returns an item from "CodeSystem.concept" that has the specified code.
 * @param {Array<Object>} concept - value of "CodeSystem.concept".
 * @param {string} code - symbol in syntax defined by the system.
 * @return {Object| undefined}
 */
function getCodeSystemItem(concept, code) {
  let result;
  if (concept) {
    for (let i = 0; i < concept.length && !result; i++) {
      const item = concept[i];
      if (item.code === code) {
        result = item;
      } else if (item.concept) {
        result = getCodeSystemItem(item.concept, code);
      }
    }
  }
  return result;
}

/**
 * Returns  a property code from the array with additional information
 * supplied about each concept by its URI.
 * @param {Object} properties - ValueSet.expansion.property or
 *  CodeSystem.property.
 *  @param {string} uri - property URI.
 * @return {boolean}
 */
function getPropertyCode(properties, uri) {
  return properties?.find(p => p.uri === uri)?.code;
}

/**
 * Returns the decimal value of a property from a value set item or code
 * system concept item by its code.
 * @param {Object} item - an item from a ValueSet.expansion.contains or
 *  CodeSystem.concept.
 * @param {Object} code - property code.
 * @return {number | undefined}
 */
function getDecimalPropertyValue(item, code) {
  return item?.property?.find(p => p.code === code)?.valueDecimal;
}

/**
 * Returns the value of the itemWeight property or score extension for the
 * specified system and code from a value set. If the item in the value set has
 * no score, undefined is returned. If the item does not exist, null is returned.
 * The difference between null and undefined values may be used in paging.
 * @param {Object} ctx - object describing the context of expression
 *  evaluation (see the "applyParsedPath" function).
 * @param {Object} vs - ValueSet.
 * @param {string} code - symbol in syntax defined by the system.
 * @param {string} system - code system.
 * @return {number|null|undefined}
 */
function getWeightFromVS(ctx, vs, code, system) {
  let score;
  let item;
  const scorePropertyUri = ctx.model?.score.propertyURI;
  if (scorePropertyUri) {
    // "ValueSet.expansion.contains" for R5
    const scorePropertyCode = getPropertyCode(vs.expansion?.property, scorePropertyUri);
    if (scorePropertyCode) {
      item = getValueSetItem(vs.expansion?.contains, code, system);
      score = getDecimalPropertyValue(item, scorePropertyCode);
    }
  } else {
    // "ValueSet.compose.include.concept" for R4
    const includeExt = ctx.model?.score.extensionURI;
    const include = vs.compose?.include;
    const len = include?.length;
    for (let i = 0; i < len && !item; ++i) {
      if (include[i].system === system) {
        item = getCodeSystemItem(include[i].concept, code);
      }
    }
    score = getScoreExtensionValue(item, includeExt);
  }
  return item ? score : null;
}

/**
 * Returns array of linkIds of ancestor ResourceNodes and source ResourceNode
 * starting with the linkId of the given node and ending with the topmost item's
 * linkId.
 * @param {ResourceNode} node - source ResourceNode.
 * @return {String[]}
 */
function getLinkIds(node) {
  const res = [];
  while (!node.data?.linkId && node?.parentResNode) {
    node = node.parentResNode;
  }
  while (node?.data?.linkId) {
    res.push(node.data.linkId);
    node = node.parentResNode;
  }
  return res;
}

/**
 * Returns the "contained" property of the resource to which the ResourceNode
 * belongs, or an undefined value if not a ResourceNode was passed or if there
 * is no contained property.
 * @param {ResourceNode|any} node - source ResourceNode or something else.
 * @return {Object[]|undefined}
 */
function getContainedResources(node) {
  while (node) {
    if (node.data?.resourceType && node.data?.contained) {
      return node.data?.contained;
    }
    node = node.parentResNode;
  }
}

/**
 * Mapping questionnaires to "linkIds" keys mapped to questionnaire items.
 * It is used to cache the result in the getQItemByLinkIds function.
 * @type {WeakMap<WeakKey, Object>}
 */
const questionnaire2linkIds = new WeakMap();

/**
 * Returns a questionnaire item based on the linkIds array of the ancestor
 * ResourceNodes and the target ResourceNode. If the questionnaire item is not
 * found, it returns null.
 * @param {string} modelVersion - model version: 'r5', 'r4', 'stu3', or 'dstu2'.
 * @param {Object} questionnaire - object with a Questionnaire resource.
 * @param {string[]} linkIds - array of linkIds starting with the linkId of the
 * target node and ending with the topmost known item's linkId.
 * @return {Object | null}
 */
function getQItemByLinkIds(modelVersion, questionnaire, linkIds) {
  let currentNode;
  // Mapping "linkIds" keys to questionnaire items.
  let linkIds2items;
  // "linkIds" key.
  const linkIdsKey = linkIds.join('|');

  // Get the mapping of "linkIds" keys to questionnaire items for the current
  // questionnaire, or create it if it doesn't exist.
  if (questionnaire2linkIds.has(questionnaire)) {
    linkIds2items = questionnaire2linkIds.get(questionnaire);
    currentNode = linkIds2items[linkIdsKey];
  } else {
    linkIds2items = {};
    questionnaire2linkIds.set(questionnaire, linkIds2items);
  }

  // We use "hasOwnProperty" because we also cache undefined results for scores.
  if (!Object.prototype.hasOwnProperty.call(linkIds2items, linkIdsKey)) {
    // If the result is not cached yet, we search for the questionnaire item.
    const topLinkId = linkIds[linkIds.length - 1];
    if (modelVersion === 'dstu2') {
      // Search for an item in a questionnaire specified in DSTU2 format.
      let collection = questionnaire.group;

      // Find the questionnaire item that matches the linkId of the topmost
      // known item.
      while (collection?.length > 0) {
        currentNode = collection.find(o => o.linkId === topLinkId);
        if (currentNode) {
          break;
        } else {
          collection = [].concat(...collection.map(i => [].concat(i.question || [], i.group || [])));
        }
      }

      // Getting a questionnaire item relative to the topmost known item using
      // subsequent linkIds.
      for (let i = linkIds.length - 2; i >= 0 && currentNode; --i) {
        currentNode = currentNode.question?.find(o => o.linkId === linkIds[i]) || currentNode.group?.find(o => o.linkId === linkIds[i]);
      }
    } else {
      // Search for an item in a questionnaire specified in STU3, R4 or R5
      // format.
      let collection = questionnaire.item;

      // Find the questionnaire item that matches the linkId of the topmost
      // known item.
      while (collection?.length > 0) {
        currentNode = collection.find(o => o.linkId === topLinkId);
        if (currentNode) {
          break;
        } else {
          collection = [].concat(...collection.map(i => i.item || []));
        }
      }

      // Getting a questionnaire item relative to the topmost known item using
      // subsequent linkIds.
      for (let i = linkIds.length - 2; i >= 0 && currentNode; --i) {
        currentNode = currentNode.item?.find(o => o.linkId === linkIds[i]);
      }
    }
    linkIds2items[linkIdsKey] = currentNode;
  }
  return currentNode;
}
module.exports = engine;

/***/ }),
/* 80 */
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

// This file holds code to hande the FHIRPath Combining functions.

const combineFns = {};
const {
  distinctFn
} = __webpack_require__(72);
const hashObject = __webpack_require__(73);
const {
  deepEqual,
  maxCollSizeForDeepEqual
} = __webpack_require__(74);
const {
  TypeInfo
} = __webpack_require__(54);
combineFns.union = function (coll1, coll2) {
  return distinctFn(coll1.concat(coll2));
};
combineFns.combineFn = function (coll1, coll2) {
  return coll1.concat(coll2);
};
combineFns.intersect = function (coll1, coll2) {
  let result = [];
  const coll1Length = coll1.length;
  let uncheckedLength = coll2.length;
  if (coll1Length && uncheckedLength) {
    const hasPrimitive = coll1.some(i => TypeInfo.isPrimitiveValue(i)) || coll2.some(i => TypeInfo.isPrimitiveValue(i));
    if (!hasPrimitive && coll1Length + uncheckedLength > maxCollSizeForDeepEqual) {
      // When we have more than maxCollSizeForDeepEqual items in input collections,
      // we use a hash table (on JSON strings) for efficiency.
      let coll2hash = {};
      coll2.forEach(item => {
        const hash = hashObject(item);
        if (coll2hash[hash]) {
          uncheckedLength--;
        } else {
          coll2hash[hash] = true;
        }
      });
      for (let i = 0; i < coll1Length && uncheckedLength > 0; ++i) {
        let item = coll1[i];
        let hash = hashObject(item);
        if (coll2hash[hash]) {
          result.push(item);
          coll2hash[hash] = false;
          uncheckedLength--;
        }
      }
    } else {
      // Otherwise, it is more efficient to perform a deep comparison.
      result = distinctFn(coll1, hasPrimitive).filter(obj1 => coll2.some(obj2 => deepEqual(obj1, obj2)));
    }
  }
  return result;
};
combineFns.exclude = function (coll1, coll2) {
  let result = [];
  const coll1Length = coll1.length;
  const coll2Length = coll2.length;
  if (!coll2Length) {
    return coll1;
  }
  if (coll1Length) {
    const hasPrimitive = coll1.some(i => TypeInfo.isPrimitiveValue(i)) || coll2.some(i => TypeInfo.isPrimitiveValue(i));
    if (!hasPrimitive && coll1Length + coll2Length > maxCollSizeForDeepEqual) {
      // When we have more than maxCollSizeForDeepEqual items in input collections,
      // we use a hash table (on JSON strings) for efficiency.
      let coll2hash = {};
      coll2.forEach(item => {
        const hash = hashObject(item);
        coll2hash[hash] = true;
      });
      result = coll1.filter(item => !coll2hash[hashObject(item)]);
    } else {
      // Otherwise, it is more efficient to perform a deep comparison.
      result = coll1.filter(item => {
        return !coll2.some(item2 => deepEqual(item, item2));
      });
    }
  }
  return result;
};
module.exports = combineFns;

/***/ }),
/* 81 */
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

// This file holds code to hande the FHIRPath Math functions.

const {
  deepEqual
} = __webpack_require__(74);
const engine = {};

// "b" is assumed to have one element and it tests whether "b[0]" is in "a"
function containsImpl(a, b) {
  for (var i = 0; i < a.length; i++) {
    if (deepEqual(a[i], b[0])) {
      return true;
    }
  }
  return false;
}
engine.contains = function (a, b) {
  if (b.length == 0) {
    return [];
  }
  if (a.length == 0) {
    return false;
  }
  if (b.length > 1) {
    throw new Error("Expected singleton on right side of contains, got " + JSON.stringify(b));
  }
  return containsImpl(a, b);
};
engine.in = function (a, b) {
  if (a.length == 0) {
    return [];
  }
  if (b.length == 0) {
    return false;
  }
  if (a.length > 1) {
    throw new Error("Expected singleton on right side of in, got " + JSON.stringify(b));
  }
  return containsImpl(b, a);
};
module.exports = engine;

/***/ }),
/* 82 */
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

const util = __webpack_require__(53);
const misc = __webpack_require__(75);
const engine = {};

// Cache for rewritten RegExp patterns
const cachedRegExp = {};

/**
 * Rewrites RegExp pattern to support single-line mode (dotAll) in IE11:
 * To do that we replace "." with "[^]" in source RegExp pattern,
 * except where "." is escaped or is inside unescaped [].
 * Another way to do the same is using package regexpu-core
 * or packages regjsparser/regjsgen.
 * @param {string} pattern - source RegExp pattern
 * @return {string}
 */
function rewritePatternForDotAll(pattern) {
  if (!cachedRegExp[pattern]) {
    cachedRegExp[pattern] = pattern.replace(/\./g, (_, offset, entirePattern) => {
      // The preceding part of the string
      const precedingPart = entirePattern.substr(0, offset);
      // The preceding part of the string without escaped characters: '\', '[' or ']'
      const cleanPrecedingPart = precedingPart.replace(/\\\\/g, '').replace(/\\[\][]/g, '');
      // Check if '.' is escaped
      const escaped = cleanPrecedingPart[cleanPrecedingPart.length - 1] === '\\';
      // The last index of unescaped '['
      const lastIndexOfOpenBracket = cleanPrecedingPart.lastIndexOf('[');
      // The last index of unescaped ']'
      const lastIndexOfCloseBracket = cleanPrecedingPart.lastIndexOf(']');
      return escaped || lastIndexOfOpenBracket > lastIndexOfCloseBracket ? '.' : '[^]';
    });
  }
  return cachedRegExp[pattern];
}
engine.indexOf = function (coll, substr) {
  const str = misc.singleton(coll, 'String');
  return util.isEmpty(substr) || util.isEmpty(str) ? [] : str.indexOf(substr);
};
engine.substring = function (coll, start, length) {
  const str = misc.singleton(coll, 'String');
  if (util.isEmpty(str) || util.isEmpty(start) || start < 0 || start >= str.length) {
    return [];
  }
  if (length === undefined || util.isEmpty(length)) {
    return str.substring(start);
  }
  return str.substring(start, start + length);
};
engine.startsWith = function (coll, prefix) {
  const str = misc.singleton(coll, 'String');
  return util.isEmpty(prefix) || util.isEmpty(str) ? [] : str.startsWith(prefix);
};
engine.endsWith = function (coll, postfix) {
  const str = misc.singleton(coll, 'String');
  return util.isEmpty(postfix) || util.isEmpty(str) ? [] : str.endsWith(postfix);
};
engine.containsFn = function (coll, substr) {
  const str = misc.singleton(coll, 'String');
  return util.isEmpty(substr) || util.isEmpty(str) ? [] : str.includes(substr);
};
engine.upper = function (coll) {
  const str = misc.singleton(coll, 'String');
  return util.isEmpty(str) ? [] : str.toUpperCase();
};
engine.lower = function (coll) {
  const str = misc.singleton(coll, 'String');
  return util.isEmpty(str) ? [] : str.toLowerCase();
};

// See https://build.fhir.org/ig/HL7/FHIRPath/#joinseparator-string-string
engine.joinFn = function (coll, separator) {
  const stringValues = [];
  coll.forEach(n => {
    const d = util.valData(n);
    if (typeof d === "string") {
      stringValues.push(d);
    } else if (d != null) {
      throw new Error('Join requires a collection of strings.');
    }
  });
  if (util.isEmpty(stringValues)) {
    return [];
  }
  if (separator === undefined) {
    separator = "";
  }
  return stringValues.join(separator);
};
engine.splitFn = function (coll, separator) {
  const strToSplit = misc.singleton(coll, 'String');
  return util.isEmpty(strToSplit) ? [] : strToSplit.split(separator);
};
engine.trimFn = function (coll) {
  const strToTrim = misc.singleton(coll, 'String');
  return util.isEmpty(strToTrim) ? [] : strToTrim.trim();
};

// encoding/decoding
engine.encodeFn = function (coll, format) {
  const strToEncode = misc.singleton(coll, 'String');
  if (util.isEmpty(strToEncode)) {
    return [];
  }
  if (format === 'urlbase64' || format === 'base64url') {
    return btoa(strToEncode).replace(/\+/g, '-').replace(/\//g, '_');
  }
  if (format === 'base64') {
    return btoa(strToEncode);
  }
  if (format === 'hex') {
    return Array.from(strToEncode).map(c => c.charCodeAt(0) < 128 ? c.charCodeAt(0).toString(16) : encodeURIComponent(c).replace(/%/g, '')).join('');
  }
  return [];
};
engine.decodeFn = function (coll, format) {
  const strDecode = misc.singleton(coll, 'String');
  if (util.isEmpty(strDecode)) {
    return [];
  }
  if (format === 'urlbase64' || format === 'base64url') {
    return atob(strDecode.replace(/-/g, '+').replace(/_/g, '/'));
  }
  if (format === 'base64') {
    return atob(strDecode);
  }
  if (format === 'hex') {
    if (strDecode.length % 2 !== 0) {
      throw new Error('Decode \'hex\' requires an even number of characters.');
    }
    return decodeURIComponent('%' + strDecode.match(/.{2}/g).join('%'));
  }
  return [];
};

// Check if dotAll is supported.
// See https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp/dotAll for details.
const dotAllIsSupported = new RegExp('').dotAll === false;
if (dotAllIsSupported) {
  engine.matches = function (coll, regex) {
    const str = misc.singleton(coll, 'String');
    if (util.isEmpty(regex) || util.isEmpty(str)) {
      return [];
    }
    const reg = new RegExp(regex, 'su');
    return reg.test(str);
  };
} else {
  engine.matches = function (coll, regex) {
    const str = misc.singleton(coll, 'String');
    if (util.isEmpty(regex) || util.isEmpty(str)) {
      return [];
    }
    const reg = new RegExp(rewritePatternForDotAll(regex), 'u');
    return reg.test(str);
  };
}
engine.replace = function (coll, pattern, repl) {
  const str = misc.singleton(coll, 'String');
  if (util.isEmpty(pattern) || util.isEmpty(repl) || util.isEmpty(str)) {
    return [];
  }
  const reg = new RegExp(util.escapeStringForRegExp(pattern), 'g');
  return str.replace(reg, repl);
};
engine.replaceMatches = function (coll, regex, repl) {
  const str = misc.singleton(coll, 'String');
  if (util.isEmpty(regex) || util.isEmpty(repl) || util.isEmpty(str)) {
    return [];
  }
  const reg = new RegExp(regex, 'gu');
  return str.replace(reg, repl);
};
engine.length = function (coll) {
  const str = misc.singleton(coll, 'String');
  return util.isEmpty(str) ? [] : str.length;
};
engine.toChars = function (coll) {
  const str = misc.singleton(coll, 'String');
  return util.isEmpty(str) ? [] : str.split('');
};
module.exports = engine;

/***/ }),
/* 83 */
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

const util = __webpack_require__(53);
var engine = {};
engine.children = function (coll) {
  let model = this.model; // "this" is the context object
  return coll.reduce(function (acc, x) {
    let d = util.valData(x);
    if (d == null) {
      return acc;
    } else if (typeof d === 'object') {
      for (var prop of Object.keys(d)) {
        util.pushFn(acc, util.makeChildResNodes(x, prop, model));
      }
      return acc;
    } else {
      return acc;
    }
  }, []);
};
engine.descendants = function (coll) {
  var ch = engine.children.call(this, coll); // "this" is the context object
  var res = [];
  while (ch.length > 0) {
    util.pushFn(res, ch);
    ch = engine.children.call(this, ch);
  }
  return res;
};
module.exports = engine;

/***/ }),
/* 84 */
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var engine = {};
const types = __webpack_require__(54);
const constants = __webpack_require__(70);
const FP_Date = types.FP_Date;
const FP_DateTime = types.FP_DateTime;
const FP_Time = types.FP_Time;

/**
 *  Implements FHIRPath now().
 */
engine.now = function () {
  if (!constants.now) {
    // return new FP_DateTime((new Date()).toISOString());
    // The above would construct an FP_DateTime with a timezone of "Z", which
    // would not make a difference for computation, but if the end result of an
    // expression is "now()", then it would look different when output to a user.
    // Construct it ourselves to preserve timezone
    var now = constants.nowDate; // a JS Date
    var isoStr = FP_DateTime.isoDateTime(now);
    constants.now = new FP_DateTime(isoStr);
  }
  return constants.now;
};

/**
 *  Implements FHIRPath today().  See comments in now(). This does not
 *  include a timezone offset.
 */
engine.today = function () {
  if (!constants.today) {
    // Construct the string ourselves to preserve timezone
    var now = constants.nowDate; // a JS Date
    var isoStr = FP_Date.isoDate(now);
    constants.today = new FP_Date(isoStr);
  }
  return constants.today;
};

/**
 *  Implements FHIRPath timeOfDay().  See comments in now(). This does not
 *  include a timezone offset.
 */
engine.timeOfDay = function () {
  if (!constants.timeOfDay) {
    // Construct the string ourselves to preserve timezone
    const now = constants.nowDate; // a JS Date
    const isoStr = FP_DateTime.isoTime(now);
    constants.timeOfDay = new FP_Time(isoStr);
  }
  return constants.timeOfDay;
};
module.exports = engine;

/***/ }),
/* 85 */
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

// Contains the additional FHIRPath functions.
// See https://build.fhir.org/fhirpath.html#functions for details.
const util = __webpack_require__(53);
const Terminologies = __webpack_require__(86);
let engine = {};

/**
 * Returns true if the code is a member of the given valueset.
 * @param {(string|Object)[]} coll - input collection with a single Coding,
 *  CodeableConcept, or code element.
 * @param {string} valueset - value set URL
 * @return {Promise<boolean>|[]} - promise of a boolean value indicating that
 *  there is one element in the input collection whose code is a member of the
 *  specified value set.
 */
engine.memberOf = function (coll, valueset) {
  if (!this.async) {
    throw new Error('The asynchronous function "memberOf" is not allowed. ' + 'To enable asynchronous functions, use the async=true or async="always"' + ' option.');
  }
  // If the input is empty or has more than one value, the return value is empty
  if (coll.length !== 1 || coll[0] == null) {
    return [];
  }
  if (typeof valueset === 'string' && /^https?:\/\/.*/.test(valueset)) {
    const terminologies = this.processedVars.terminologies;
    if (!terminologies) {
      throw new Error('Option "terminologyUrl" is not specified.');
    }
    return Terminologies.validateVS.call(this, [terminologies], valueset, util.valData(coll[0]), '').then(params => {
      return params.parameter.find(p => p.name === "result").valueBoolean;
    }, () => []);
  }

  // If the valueset cannot be resolved as an uri to a value set,
  // the return value is empty.
  return [];
};
module.exports = engine;

/***/ }),
/* 86 */
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

// This file contains a class that implements the Terminology Service API.
// See https://build.fhir.org/fhirpath.html#txapi for details.

const util = __webpack_require__(53);
class Terminologies {
  constructor(terminologyUrl) {
    this.terminologyUrl = terminologyUrl;
    this.invocationTable = Terminologies.invocationTable;
  }

  // Same as fhirpath.invocationTable, but for %terminologies methods
  static invocationTable = {
    validateVS: {
      fn: Terminologies.validateVS,
      arity: {
        2: ['String', 'AnySingletonAtRoot'],
        3: ['String', 'AnySingletonAtRoot', 'String']
      }
    }
  };

  /**
   * This example function calls the Terminology Service $validate-code operation
   * on a value set. See Terminology Service API: https://build.fhir.org/fhirpath.html#txapi
   * The source code of this function is based on this script:
   * https://gist.github.com/brianpos/97e1237470d76835ea9a35bf8e021ca6#file-fhirpath-async-ts
   * @param {Terminologies[]} self - an array with one element that refers to
   *  the current Terminology instance.
   * @param {string} valueset - a canonical URL reference to a value set. In the original
   *  specification this could also be an actual ValueSet, but I don't want to
   *  complicate this example.
   * @param {string|Object} coded - either a Coding, a CodeableConcept,
   *  or a resource element that is a code.
   * @param {string} [params] - a URL encoded string with other parameters for the
   *  validate-code operation (e.g. 'date=2011-03-04&displayLanguage=en').
   * @return {Promise<Parameters>} - a Parameters resource
   *  (https://build.fhir.org/parameters.html) with the results of the validation
   *  operation.
   */
  static validateVS(self, valueset, coded, params = '') {
    const ctx = this;
    if (!ctx.async) {
      throw new Error('The asynchronous function "validateVS" is not allowed. ' + 'To enable asynchronous functions, use the async=true or async="always"' + ' option.');
    }
    checkParams(params);
    const httpHeaders = {
      "Accept": "application/fhir+json; charset=utf-8"
    };
    const httpPostHeaders = {
      "Accept": "application/fhir+json; charset=utf-8",
      "Content-Type": "application/fhir+json; charset=utf-8"
    };
    let myHeaders = new Headers(httpHeaders);
    const requestUrl = `${self[0].terminologyUrl}/ValueSet/$validate-code`;
    let response;
    if (coded.coding) {
      const parameters = {
        "resourceType": "Parameters",
        "parameter": [{
          "name": "url",
          "valueUri": valueset
        }, {
          "name": "codeableConcept",
          "valueCodeableConcept": coded
        }]
      };
      myHeaders = new Headers(httpPostHeaders);
      response = util.fetchWithCache(requestUrl + (params ? '?' + params : ''), {
        method: "POST",
        headers: myHeaders,
        body: JSON.stringify(parameters),
        ...(ctx.signal ? {
          signal: ctx.signal
        } : {})
      });
    } else if (typeof coded === "string") {
      const queryParams1 = new URLSearchParams({
        url: valueset
      });
      //  Workaround for the case where we don't have a system. See discussion here:
      //  https://chat.fhir.org/#narrow/stream/179266-fhirpath/topic/Problem.20with.20the.20.22memberOf.22.20function.20and.20R4.20servers
      response = util.fetchWithCache(`${self[0].terminologyUrl}/ValueSet?${queryParams1.toString() + (params ? '&' + params : '')}`, {
        headers: myHeaders,
        ...(ctx.signal ? {
          signal: ctx.signal
        } : {})
      }).then(bundle => {
        const system = bundle?.entry?.length === 1 && (getSystemFromArrayItems(bundle.entry[0].resource.expansion?.contains) || getSystemFromArrayItems(bundle.entry[0].resource.compose?.include));
        if (system) {
          const queryParams2 = new URLSearchParams({
            url: valueset,
            code: coded,
            system
          });
          return util.fetchWithCache(`${requestUrl}?${queryParams2.toString() + (params ? '&' + params : '')}`, {
            headers: myHeaders,
            ...(ctx.signal ? {
              signal: ctx.signal
            } : {})
          });
        } else {
          throw new Error('The valueset does not have a single code system.');
        }
      });
    } else {
      if (coded.code) {
        const queryParams = new URLSearchParams({
          url: valueset ?? '',
          system: coded.system ?? '',
          code: coded.code
        });
        response = util.fetchWithCache(`${requestUrl}?${queryParams.toString() + (params ? '&' + params : '')}`, {
          headers: myHeaders,
          ...(ctx.signal ? {
            signal: ctx.signal
          } : {})
        });
      }
    }
    return response.then(params => {
      if (params?.parameter) {
        return params;
      }
      throw new Error(params);
    }).catch(() => {
      const key = createIndexKeyMemberOf(coded, valueset);
      throw new Error("Failed to check membership: " + key);
    });
  }
}

/**
 * Create and returns an Index Key for the validateVS function
 * The source code of this function was borrowed from this script:
 * https://gist.github.com/brianpos/97e1237470d76835ea9a35bf8e021ca6#file-fhirpath-async-ts
 * @param {Object|string} value - either a Coding, a CodeableConcept, or
 *  a resource element that is a code.
 * @param {string} valueset - a canonical URL reference to a value set.
 * @returns {string|undefined}
 */
function createIndexKeyMemberOf(value, valueset) {
  if (typeof value === "string") {
    return value + " - " + valueset;
  }
  if (value.code) {
    return value.system + "|" + value.code + " - " + valueset;
  }
  if (value.coding) {
    // return the same as for coding by joining each of the codings with a comma
    return value.coding.map(c => c.system + "|" + c.code).join(",") + " - " + valueset;
  }
  return undefined;
}

/**
 * Throws an exception if the params parameter is not empty and is not a valid
 * URL-encoded string.
 * @param {string|undefined} params - a URL encoded string with parameters
 *  (e.g. 'date=2011-03-04&displayLanguage=en').
 */
function checkParams(params) {
  if (params?.split('&').find(p => {
    const v = p.split('=');
    return v.length <= 2 && v.find(x => encodeURIComponent(decodeURIComponent(x)) !== x);
  })) {
    throw new Error(`"${params}" should be a valid URL-encoded string`);
  }
}

/**
 * Returns the "system" property from an array of items if it is the same for all
 * items and equal to the initial value if the initial value is defined.
 * @param {Object[]|undefined} arr - array of items
 * @param {string|undefined} [system] - optional initial value
 * @return {string|undefined}
 */
function getSystemFromArrayItems(arr, system = undefined) {
  if (arr) {
    for (let i = 0; i < arr.length; ++i) {
      if (!system) {
        system = arr[i].system;
      } else if (system !== arr[i].system) {
        system = undefined;
        break;
      }
    }
  }
  return system;
}
module.exports = Terminologies;

/***/ }),
/* 87 */
/***/ (function(module) {

var engine = {};
engine.orOp = function (a, b) {
  if (Array.isArray(b)) {
    if (a === true) {
      return true;
    } else if (a === false) {
      return [];
    } else if (Array.isArray(a)) {
      return [];
    }
  }
  if (Array.isArray(a)) {
    if (b === true) {
      return true;
    } else {
      return [];
    }
  }
  return a || b;
};
engine.andOp = function (a, b) {
  if (Array.isArray(b)) {
    if (a === true) {
      return [];
    } else if (a === false) {
      return false;
    } else if (Array.isArray(a)) {
      return [];
    }
  }
  if (Array.isArray(a)) {
    if (b === true) {
      return [];
    } else {
      return false;
    }
  }
  return a && b;
};
engine.xorOp = function (a, b) {
  // If a or b are arrays, they must be the empty set.
  // In that case, the result is always the empty set.
  if (Array.isArray(a) || Array.isArray(b)) return [];
  return a && !b || !a && b;
};
engine.impliesOp = function (a, b) {
  if (Array.isArray(b)) {
    if (a === true) {
      return [];
    } else if (a === false) {
      return true;
    } else if (Array.isArray(a)) {
      return [];
    }
  }
  if (Array.isArray(a)) {
    if (b === true) {
      return true;
    } else {
      return [];
    }
  }
  if (a === false) {
    return true;
  }
  return a && b;
};
module.exports = engine;

/***/ }),
/* 88 */
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

// This file contains a class that implements the Type Factory API.
// See https://hl7.org/fhir/fhirpath.html#factory for details.
const util = __webpack_require__(53);
const {
  ResourceNode,
  TypeInfo,
  instantRE,
  timeRE,
  dateRE,
  dateTimeRE
} = __webpack_require__(54);
class Factory {
  // Same as fhirpath.invocationTable, but for %factory methods
  static invocationTable = {
    Extension: {
      fn: Factory.Extension,
      arity: {
        2: ['String', 'AnyAtRoot']
      }
    },
    Identifier: {
      fn: Factory.Identifier,
      arity: {
        1: ['String'],
        2: ['String', 'String'],
        3: ['String', 'String', 'String'],
        4: ['String', 'String', 'String', 'Any']
      }
    },
    HumanName: {
      fn: Factory.HumanName,
      arity: {
        1: ['String'],
        2: ['String', 'AnyAtRoot'],
        3: ['String', 'AnyAtRoot', 'String'],
        4: ['String', 'AnyAtRoot', 'String', 'String'],
        5: ['String', 'AnyAtRoot', 'String', 'String', 'String'],
        6: ['String', 'AnyAtRoot', 'String', 'String', 'String', 'String']
      }
    },
    ContactPoint: {
      fn: Factory.ContactPoint,
      arity: {
        1: ['String'],
        2: ['String', 'String'],
        3: ['String', 'String', 'String']
      }
    },
    Address: {
      fn: Factory.Address,
      arity: {
        1: ['AnyAtRoot'],
        2: ['AnyAtRoot', 'String'],
        3: ['AnyAtRoot', 'String', 'String'],
        4: ['AnyAtRoot', 'String', 'String', 'String'],
        5: ['AnyAtRoot', 'String', 'String', 'String', 'String'],
        6: ['AnyAtRoot', 'String', 'String', 'String', 'String', 'String'],
        7: ['AnyAtRoot', 'String', 'String', 'String', 'String', 'String', 'String']
      }
    },
    Quantity: {
      fn: Factory.Quantity,
      arity: {
        1: ['String'],
        2: ['String', 'String'],
        3: ['String', 'String', 'StringOrNumber'],
        4: ['String', 'String', 'StringOrNumber', 'String']
      }
    },
    Coding: {
      fn: Factory.Coding,
      arity: {
        1: ['String'],
        2: ['String', 'String'],
        3: ['String', 'String', 'String'],
        4: ['String', 'String', 'String', 'String']
      }
    },
    CodeableConcept: {
      fn: Factory.CodeableConcept,
      arity: {
        1: ['AnyAtRoot'],
        2: ['AnyAtRoot', 'String']
      }
    },
    create: {
      fn: Factory.create,
      arity: {
        1: ['TypeSpecifier']
      }
    },
    withExtension: {
      fn: Factory.withExtension,
      arity: {
        3: ['AnyAtRoot', 'String', 'AnyAtRoot']
      }
    },
    withProperty: {
      fn: Factory.withProperty,
      arity: {
        3: ['AnyAtRoot', 'String', 'AnyAtRoot']
      }
    }
  };

  // Create functions to create primitive types and add these functions to the
  // invocationTable.
  static {
    [{
      type: 'string',
      getValue: function (v) {
        if (typeof v === 'string' && /^[\s\S]+$/.test(v)) {
          return String(v);
        }
        throw new Error(`"${v}" is not a string.`);
      }
    }, {
      type: 'integer',
      getValue: v => {
        const n = Number(v);
        if (Number.isInteger(n)) {
          return n;
        }
        throw new Error(`"${v}" is not an integer.`);
      }
    }, {
      type: 'unsignedInt',
      getValue: v => {
        const n = Number(v);
        if (Number.isInteger(n) && n >= 0) {
          return n;
        }
        throw new Error(`"${v}" is not an unsignedInt.`);
      }
    }, {
      type: 'positiveInt',
      getValue: v => {
        const n = Number(v);
        if (Number.isInteger(n) && n > 0) {
          return n;
        }
        throw new Error(`"${v}" is not a positiveInt.`);
      }
    }, {
      type: 'integer64',
      getValue: v => {
        const n = Number(v);
        if (Number.isInteger(n)) {
          return n;
        }
        throw new Error(`"${v}" is not an integer.`);
      }
    }, {
      type: 'markdown',
      getValue(v) {
        if (typeof v === 'string' && /^[\s\S]+$/.test(v)) {
          return v;
        }
        throw new Error(`"${v}" is not a markdown.`);
      }
    }, {
      type: 'url',
      getValue(v) {
        if (typeof v === 'string' && /^\S*$/.test(v)) {
          return v;
        }
        throw new Error(`"${v}" is not a url.`);
      }
    }, {
      type: 'uri',
      getValue(v) {
        if (typeof v === 'string' && /^\S*$/.test(v)) {
          return v;
        }
        throw new Error(`"${v}" is not a uri.`);
      }
    }, {
      type: 'instant',
      getValue(v) {
        if (typeof v === 'string' && instantRE.test(v)) {
          return v;
        }
        throw new Error(`"${v}" is not an instant.`);
      }
    }, {
      type: 'time',
      getValue(v) {
        if (typeof v === 'string' && timeRE.test(v)) {
          return v;
        }
        throw new Error(`"${v}" is not a time.`);
      }
    }, {
      type: 'date',
      getValue(v) {
        if (typeof v === 'string' && dateRE.test(v)) {
          return v;
        }
        throw new Error(`"${v}" is not a date.`);
      }
    }, {
      type: 'dateTime',
      getValue(v) {
        if (typeof v === 'string' && dateTimeRE.test(v)) {
          return v;
        }
        throw new Error(`"${v}" is not a dateTime.`);
      }
    }, {
      type: 'base64Binary',
      getValue(v) {
        if (typeof v === 'string' && /^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/.test(v)) {
          return v;
        }
        throw new Error(`"${v}" is not a base64Binary.`);
      }
    }, {
      type: 'decimal',
      getValue(v) {
        const n = Number(v);
        if (Number.isNaN(n)) {
          throw new Error(`"${v}" is not an decimal.`);
        }
        return n;
      }
    }, {
      type: 'boolean',
      getValue(v) {
        if (v === true || v === 'true') {
          return true;
        } else if (v === false || v === 'false') {
          return false;
        } else {
          throw new Error(`"${v}" is not a boolean.`);
        }
      }
    }, {
      type: 'code',
      getValue(v) {
        if (typeof v === 'string' && /^\S+( \S+)*$/.test(v)) {
          return v;
        }
        throw new Error(`"${v}" is not a code.`);
      }
    }, {
      type: 'id',
      getValue(v) {
        if (typeof v === 'string' && /^[A-Za-z0-9\-.]{1,64}$/.test(v)) {
          return v;
        }
        throw new Error(`"${v}" is not an id.`);
      }
    }, {
      type: 'oid',
      getValue(v) {
        if (typeof v === 'string' && /^urn:oid:[0-2](\.(0|[1-9][0-9]*))+$/.test(v)) {
          return v;
        }
        throw new Error(`"${v}" is not an oid.`);
      }
    }, {
      type: 'uuid',
      getValue(v) {
        if (typeof v === 'string' && /^urn:uuid:[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/.test(v)) {
          return v;
        }
        throw new Error(`"${v}" is not an uuid.`);
      }
    }, {
      type: 'canonical',
      getValue(v) {
        if (typeof v === 'string' && /^\S*$/.test(v)) {
          return v;
        }
        throw new Error(`"${v}" is not an canonical.`);
      }
    }].forEach(({
      type: primitiveType,
      getValue
    }) => {
      /**
       * Creates an instance of the type with the value and possibly one or more
       * extensions.
       * See primitive type descriptions here:
       * https://hl7.org/fhir/datatypes.html#primitive
       * @param {Factory[]} self - an array with one element, which is the
       *  Factory class.
       * @param {*} valueColl - a collection that should contain a single value
       *  of a primitive type.
       * @param {Extension[]} [extensions] - an optional array of Extensions.
       * @return {ResourceNode} - a new ResourceNode.
       */
      Factory[primitiveType] = function (self, valueColl, extensions) {
        let data;
        if (valueColl.length > 1) {
          throw new Error('Unexpected collection ' + JSON.stringify(valueColl) + ` as a value for %factory.${primitiveType}(value, extensions)`);
        } else if (valueColl.length === 0) {
          data = null;
        } else {
          const v = util.valData(valueColl[0]);
          if (v == null) {
            data = null;
          }
          if (typeof v !== 'object') {
            data = getValue(v);
          } else {
            throw new Error(`"${v}" is not a ${primitiveType}`);
          }
        }
        let _data = null;
        if (extensions?.length > 0) {
          _data = {
            extension: extensions.map(e => {
              const extensionDataType = TypeInfo.fromValue(e);
              if (TypeInfo.isType(extensionDataType.name, 'Extension')) {
                return util.valData(e);
              } else {
                throw new Error(`Expected "FHIR.Extension", got "${extensionDataType}"`);
              }
            })
          };
        }
        return ResourceNode.makeResNode(data, null, primitiveType, _data, primitiveType);
      };
      Factory.invocationTable[primitiveType] = {
        fn: Factory[primitiveType],
        arity: {
          1: ['AnyAtRoot'],
          2: ['AnyAtRoot', 'Any']
        }
      };
    });
  }

  /**
   * Creates an extension with the given url and value
   * @param {Factory[]} self - an array with one element, which is the Factory
   *  class.
   * @param {string} url - a string value that identifies the extension
   * @param {*} value - the value of the extension (any valid type for
   *  extension.value[x]).
   * @return {ResourceNode}
   */
  static Extension(self, url, value) {
    if (value.length !== 1) {
      if (value.length > 1) {
        throw new Error("Unexpected collection " + JSON.stringify(value) + " as a value for %factory.Extension(url, value)");
      }
      if (value.length === 0) {
        throw new Error("Unexpected empty collection " + JSON.stringify(value) + " as a value for %factory.Extension(url, value)");
      }
    } else {
      return ResourceNode.makeResNode(Factory.createExtensionObject(url, value[0]), null, 'Extension', null, 'Extension');
    }
  }

  /**
   * Creates an object to store the extension value.
   * @param {string} url - a string value that identifies the extension
   * @param {*} value - the value of the extension (any valid type for
   *  extension.value[x]).
   * @return {{[p: string]: *, url}}
   */
  static createExtensionObject(url, value) {
    const valuePropertyName = 'value' + TypeInfo.fromValue(value).name.replace(/^\w/, c => c.toUpperCase());
    return {
      url,
      [valuePropertyName]: util.valData(value)
    };
  }

  /**
   * Creates an identifier with the given properties.
   * @param {Factory[]} self - an array with one element, which is the Factory
   *  class.
   * @param {string} system - a string value that goes in Identifier.system.
   * @param {string} value - a string value that goes in Identifier.value.
   * @param {string} use - a string value that goes in Identifier.use.
   * @param {ResourceNode[]} typeColl - a CodeableConcept that goes in
   *  Identifier.type.
   * @return {ResourceNode}
   */
  static Identifier(self, system, value, use, typeColl) {
    if (typeColl?.length > 1) {
      throw new Error("Unexpected collection " + JSON.stringify(typeColl) + " as a type for %factory.Identifier{system, value, use, type)");
    }
    const data = {};
    if (util.isSome(system)) {
      data.system = system;
    }
    if (util.isSome(value)) {
      data.value = value;
    }
    if (util.isSome(use)) {
      data.use = use;
    }
    if (util.isSome(typeColl)) {
      const typeInfo = TypeInfo.fromValue(typeColl[0]);
      if (!TypeInfo.isType(typeInfo.name, 'CodeableConcept')) {
        throw new Error(`Expected "FHIR.CodeableConcept", got "${typeInfo}"`);
      }
      data.type = typeColl[0];
    }
    return ResourceNode.makeResNode(data, null, 'Identifier', null, 'Identifier');
  }

  /**
   * Create a human name with the given properties.
   * @param {Factory[]} self - an array with one element, which is the Factory
   *  class.
   * @param {string} family - a string value that goes in HumanName.system.
   * @param {ResourceNode[]} givenColl - a collection of string values that goes
   *  in HumanName.given.
   * @param {string} prefix - a string value that goes in HumanName.prefix.
   * @param {string} suffix - a string value that goes in HumanName.suffix.
   * @param {string} text - a string value that goes in HumanName.text.
   * @param {string} use - a string value that goes in HumanName.use.
   * @return {ResourceNode}
   */
  static HumanName(self, family, givenColl, prefix, suffix, text, use) {
    const data = {};
    if (util.isSome(family)) {
      data.family = family;
    }
    if (util.isSome(givenColl)) {
      data.given = givenColl.map(given => {
        const v = util.valData(given);
        if (typeof v === "string") {
          return v;
        }
        throw new Error(`Expected string, but got: ${JSON.stringify(v)}`);
      });
    }
    if (util.isSome(prefix)) {
      data.prefix = prefix;
    }
    if (util.isSome(suffix)) {
      data.suffix = suffix;
    }
    if (util.isSome(text)) {
      data.text = text;
    }
    if (util.isSome(use)) {
      data.use = use;
    }
    return ResourceNode.makeResNode(data, null, 'HumanName', null, 'HumanName');
  }

  /**
   * Creates a ContactPoint.
   * @param {Factory[]} self - an array with one element, which is the Factory
   *  class.
   * @param {string} system - a string value that goes in ContactPoint.system.
   * @param {string} value - a string value that goes in ContactPoint.value.
   * @param {string} use - a string value that goes in ContactPoint.use.
   * @return {ResourceNode}
   */
  static ContactPoint(self, system, value, use) {
    const data = {};
    if (util.isSome(system)) {
      data.system = system;
    }
    if (util.isSome(value)) {
      data.value = value;
    }
    if (util.isSome(use)) {
      data.use = use;
    }
    return ResourceNode.makeResNode(data, null, 'ContactPoint', null, 'ContactPoint');
  }

  /**
   * Creates an Address
   * @param {Factory[]} self - an array with one element, which is the Factory
   *  class.
   * @param {ResourceNode[]} lineColl - a collection of string values that goes
   *  in Address.line.
   * @param {string} city - a string value that goes in Address.city.
   * @param {string} state - a string value that goes in Address.state.
   * @param {string} postalCode - a string value that goes in Address.postalCode.
   * @param {string} country - a string value that goes in Address.country.
   * @param {string} use - a string value that goes in Address.use.
   * @param {string} type - a string value that goes in Address.type.
   * @return {ResourceNode}
   */
  static Address(self, lineColl, city, state, postalCode, country, use, type) {
    const data = {};
    if (util.isSome(lineColl)) {
      data.line = lineColl.map(line => {
        const v = util.valData(line);
        if (typeof v === "string") {
          return v;
        }
        throw new Error(`Expected string, but got: ${JSON.stringify(v)}`);
      });
    }
    if (util.isSome(city)) {
      data.city = city;
    }
    if (util.isSome(state)) {
      data.state = state;
    }
    if (util.isSome(postalCode)) {
      data.postalCode = postalCode;
    }
    if (util.isSome(country)) {
      data.country = country;
    }
    if (util.isSome(use)) {
      data.use = use;
    }
    if (util.isSome(type)) {
      data.type = type;
    }
    return ResourceNode.makeResNode(data, null, 'Address', null, 'Address');
  }

  /**
   * Creates a Quantity.
   * @param {Factory[]} self - an array with one element, which is the Factory
   *  class.
   * @param {string} system - a string value that goes in Quantity.system.
   * @param {string} code - a string value that goes in Quantity.code.
   * @param {string} value - a string or decimal value that goes in
   *  Quantity.value.
   * @param {string} unit - a string value that goes in Quantity.unit.
   * @return {ResourceNode}
   */
  static Quantity(self, system, code, value, unit) {
    const data = {};
    if (util.isSome(system)) {
      data.system = system;
    }
    if (util.isSome(code)) {
      data.code = code;
    }
    if (util.isSome(value)) {
      data.value = Number(value);
    }
    if (util.isSome(unit)) {
      data.unit = unit;
    }
    return ResourceNode.makeResNode(data, null, 'Quantity', null, 'Quantity');
  }

  /**
   * Creates a Coding.
   * @param {Factory[]} self - an array with one element, which is the Factory
   *  class.
   * @param {string} system - a string value that goes in Coding.system.
   * @param {string} code - a string value that goes in Coding.code.
   * @param {string} display - a string value that goes in Coding.display.
   * @param {string} version - a string value that goes in Coding.version.
   * @return {ResourceNode}
   */
  static Coding(self, system, code, display, version) {
    const data = {};
    if (util.isSome(system)) {
      data.system = system;
    }
    if (util.isSome(code)) {
      data.code = code;
    }
    if (util.isSome(display)) {
      data.display = display;
    }
    if (util.isSome(version)) {
      data.version = version;
    }
    return ResourceNode.makeResNode(data, null, 'Coding', null, 'Coding');
  }

  /**
   * Creates a CodeableConcept.
   * @param {Factory[]} self - an array with one element, which is the Factory
   *  class.
   * @param {ResourceNode[]} valueColl - a collection of Coding that goes in
   *  CodeableConcept.coding.
   * @param {string} text - a string value that goes in CodeableConcept.text.
   * @return {ResourceNode}
   */
  static CodeableConcept(self, valueColl, text) {
    const data = valueColl?.length > 0 ? {
      coding: valueColl.map(coding => {
        if (coding instanceof ResourceNode && coding.getTypeInfo().name === 'Coding') {
          return util.valData(coding);
        }
        throw new Error("Unexpected value " + JSON.stringify(coding) + "; expected value of type Coding");
      })
    } : {};
    if (util.isSome(text)) {
      data.text = text;
    }
    return ResourceNode.makeResNode(data, null, 'CodeableConcept', null, 'CodeableConcept');
  }

  /**
   * Create an instance of the named type.
   * @param {Factory[]} self - an array with one element that refers to
   *  the current Factory instance.
   * @param {TypeInfo} typeInfo - a value that is the type to create.
   * @return {ResourceNode}
   */
  static create(self, typeInfo) {
    if (typeInfo.namespace === TypeInfo.System) {
      throw new Error('%factory.create(type) doesn\'t support system types.');
    }
    return ResourceNode.makeResNode(null, null, typeInfo.name, null, typeInfo.name);
  }

  /**
   * Add an extension, and return the new type.
   * @param {Factory[]} self - an array with one element that refers to
   *  the current Factory instance.
   * @param {ResourceNode[]} instanceColl - a collection that should contain the
   *  instance to which the extension is to be added.
   * @param {string} url - a string value that goes in Extension.url.
   *  specification this could also be an actual ValueSet, but I don't want to
   *  complicate this example.
   * @param {ResourceNode[]} value - the value of the extension.
   * @return {ResourceNode|[]}
   */
  static withExtension(self, instanceColl, url, value) {
    if (instanceColl.length > 1) {
      throw new Error("Unexpected collection " + JSON.stringify(instanceColl) + " as an instance for %factory.withExtension(instance, url, value)");
    }
    if (value.length !== 1) {
      if (value.length > 1) {
        throw new Error("Unexpected collection " + JSON.stringify(value) + " as a value for %factory.withExtension(instance, url, value)");
      }
      if (value.length === 0) {
        throw new Error("Unexpected empty collection " + JSON.stringify(value) + " as a value for %factory.withExtension(instance, url, value)");
      }
    }
    if (instanceColl.length === 0) {
      return [];
    }
    const instance = instanceColl[0];
    if (instance instanceof ResourceNode) {
      let data = instance.data;
      let _data = instance._data;
      if (TypeInfo.isPrimitive(instance.getTypeInfo())) {
        _data = {
          ...(instance._data || {}),
          extension: [...(instance._data?.extension || []), Factory.createExtensionObject(url, value[0])]
        };
      } else {
        data = {
          ...(instance.data || {}),
          extension: [...(instance.data?.extension || []), Factory.createExtensionObject(url, value[0])]
        };
      }
      return ResourceNode.makeResNode(data, null, instance.path, _data, instance.fhirNodeDataType);
    } else {
      throw new Error('Expected a ResourceNode.');
    }
  }

  /**
   * Set a property value, and return the new type.
   * @param {Factory[]} self - an array with one element that refers to
   *  the current Factory instance.
   * @param {ResourceNode[]} instanceColl - a collection that should contain the
   *  instance to set the property on.
   * @param {string} name - a string value that identifies the property to set.
   * @param {string} value - the value of the property
   * @return {ResourceNode|*[]}
   */
  static withProperty(self, instanceColl, name, value) {
    if (instanceColl.length > 1) {
      throw new Error("Unexpected collection " + JSON.stringify(instanceColl) + " as an instance for %factory.withProperty(instance, name, value)");
    }
    if (value.length !== 1) {
      if (value.length > 1) {
        throw new Error("Unexpected collection " + JSON.stringify(value) + " as a value for %factory.withProperty(instance, name, value)");
      }
      if (value.length === 0) {
        throw new Error("Unexpected empty collection " + JSON.stringify(value) + " as a value for %factory.withProperty(instance, name, value)");
      }
    }
    if (instanceColl.length === 0) {
      return [];
    }
    const instance = instanceColl[0];
    if (instance instanceof ResourceNode) {
      let data = instance.data;
      let _data = instance._data;
      if (TypeInfo.isPrimitive(instance.getTypeInfo())) {
        _data = {
          ...(instance._data || {}),
          [name]: util.valData(value[0]),
          ...(value[0]?._data ? {
            ['_' + name]: value[0]._data
          } : {})
        };
      } else {
        data = {
          ...(instance.data || {}),
          [name]: util.valData(value[0]),
          ...(value[0]?._data ? {
            ['_' + name]: value[0]._data
          } : {})
        };
      }
      return ResourceNode.makeResNode(data, null, instance.path, _data, instance.fhirNodeDataType);
    } else {
      throw new Error('Expected a ResourceNode.');
    }
  }
}
module.exports = Factory;

/***/ }),
/* 89 */
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

const updateWithGeneratedData = __webpack_require__(90);
/**
 *  Exports the FHIR model data for R5.  This is an internal structure that
 *  will likely evolve as more FHIR specific processing is added.
 */
const modelInfo = {
  version: 'r5',
  score: {
    // See
    // - https://hl7.org/fhir/R5/codesystem.html#defined-props
    // - https://hl7.org/fhir/codesystem-concept-properties.html
    propertyURI: 'http://hl7.org/fhir/concept-properties#itemWeight',
    // See
    // - https://www.hl7.org/fhir/extensions/StructureDefinition-itemWeight.html
    // - https://build.fhir.org/ig/HL7/fhir-extensions/StructureDefinition-itemWeight.html
    extensionURI: ['http://hl7.org/fhir/StructureDefinition/itemWeight']
  },
  /**
   *  A hash of resource element paths (e.g. Observation.value) that are known
   *  to point to fiels that are choice types.
   */
  choiceTypePaths: __webpack_require__(91),
  /**
   *  A hash from paths to the path for which their content is defined, e.g.
   *  Questionnaire.item.item -> Questionnaire.item.
   */
  pathsDefinedElsewhere: __webpack_require__(92),
  /**
   * Mapping data types to parent data types.
   */
  type2Parent: __webpack_require__(93),
  /**
   * Mapping paths to data types.
   */
  path2Type: __webpack_require__(94)
};

// Update with generated data
updateWithGeneratedData(modelInfo);
module.exports = modelInfo;

/***/ }),
/* 90 */
/***/ (function(module) {

// Update the model with generated data
module.exports = modelInfo => {
  // Generate a set of available data types
  modelInfo.availableTypes = new Set();
  // IE11 probably doesn't support `new Set(iterable)`
  Object.keys(modelInfo.type2Parent).forEach(i => modelInfo.availableTypes.add(i));
  Object.values(modelInfo.type2Parent).forEach(i => modelInfo.availableTypes.add(i));

  // Generate a hash map to map paths to data types excluding "BackboneElement" and "Element".
  modelInfo.path2TypeWithoutElements = {};
  for (let i in modelInfo.path2Type) {
    if (modelInfo.path2Type[i] === 'Element' || modelInfo.path2Type[i] === 'BackboneElement') {
      continue;
    }
    modelInfo.path2TypeWithoutElements[i] = modelInfo.path2Type[i];
  }
};

/***/ }),
/* 91 */
/***/ (function(module) {

"use strict";
module.exports = /*#__PURE__*/JSON.parse('{"ActivityDefinition.asNeeded":["Boolean","CodeableConcept"],"ActivityDefinition.product":["Reference","CodeableConcept"],"ActivityDefinition.subject":["CodeableConcept","Reference","Canonical"],"ActivityDefinition.timing":["Timing","Age","Range","Duration"],"ActivityDefinition.versionAlgorithm":["String","Coding"],"ActorDefinition.versionAlgorithm":["String","Coding"],"AdministrableProductDefinition.property.value":["CodeableConcept","Quantity","Date","Boolean","Markdown","Attachment","Reference"],"AdverseEvent.contributingFactor.item":["Reference","CodeableConcept"],"AdverseEvent.mitigatingAction.item":["Reference","CodeableConcept"],"AdverseEvent.occurrence":["DateTime","Period","Timing"],"AdverseEvent.preventiveAction.item":["Reference","CodeableConcept"],"AdverseEvent.supportingInfo.item":["Reference","CodeableConcept"],"AdverseEvent.suspectEntity.instance":["CodeableConcept","Reference"],"AllergyIntolerance.onset":["DateTime","Age","Period","Range","String"],"Annotation.author":["Reference","String"],"ArtifactAssessment.artifact":["Reference","Canonical","Uri"],"ArtifactAssessment.citeAs":["Reference","Markdown"],"AuditEvent.agent.network":["Reference","Uri","String"],"AuditEvent.entity.detail.value":["Quantity","CodeableConcept","String","Boolean","Integer","Range","Ratio","Time","DateTime","Period","Base64Binary"],"AuditEvent.occurred":["Period","DateTime"],"BiologicallyDerivedProduct.collection.collected":["DateTime","Period"],"BiologicallyDerivedProduct.property.value":["Boolean","Integer","CodeableConcept","Period","Quantity","Range","Ratio","String","Attachment"],"CanonicalResource.versionAlgorithm":["String","Coding"],"CapabilityStatement.versionAlgorithm":["String","Coding"],"CareTeam.participant.coverage":["Period","Timing"],"ChargeItem.occurrence":["DateTime","Period","Timing"],"ChargeItemDefinition.versionAlgorithm":["String","Coding"],"Citation.versionAlgorithm":["String","Coding"],"Claim.accident.location":["Address","Reference"],"Claim.diagnosis.diagnosis":["CodeableConcept","Reference"],"Claim.event.when":["DateTime","Period"],"Claim.item.location":["CodeableConcept","Address","Reference"],"Claim.item.serviced":["Date","Period"],"Claim.procedure.procedure":["CodeableConcept","Reference"],"Claim.supportingInfo.timing":["Date","Period"],"Claim.supportingInfo.value":["Boolean","String","Quantity","Attachment","Reference","Identifier"],"ClaimResponse.addItem.location":["CodeableConcept","Address","Reference"],"ClaimResponse.addItem.serviced":["Date","Period"],"ClaimResponse.event.when":["DateTime","Period"],"ClinicalImpression.effective":["DateTime","Period"],"ClinicalUseDefinition.indication.duration":["Range","String"],"ClinicalUseDefinition.interaction.interactant.item":["Reference","CodeableConcept"],"CodeSystem.concept.property.value":["Code","Coding","String","Integer","Boolean","DateTime","Decimal"],"CodeSystem.versionAlgorithm":["String","Coding"],"Communication.payload.content":["Attachment","Reference","CodeableConcept"],"CommunicationRequest.occurrence":["DateTime","Period"],"CommunicationRequest.payload.content":["Attachment","Reference","CodeableConcept"],"CompartmentDefinition.versionAlgorithm":["String","Coding"],"ConceptMap.group.element.target.dependsOn.value":["Code","Coding","String","Boolean","Quantity"],"ConceptMap.group.element.target.property.value":["Coding","String","Integer","Boolean","DateTime","Decimal","Code"],"ConceptMap.sourceScope":["Uri","Canonical"],"ConceptMap.targetScope":["Uri","Canonical"],"ConceptMap.versionAlgorithm":["String","Coding"],"Condition.abatement":["DateTime","Age","Period","Range","String"],"Condition.onset":["DateTime","Age","Period","Range","String"],"ConditionDefinition.precondition.value":["CodeableConcept","Quantity"],"ConditionDefinition.versionAlgorithm":["String","Coding"],"Contract.friendly.content":["Attachment","Reference"],"Contract.legal.content":["Attachment","Reference"],"Contract.legallyBinding":["Attachment","Reference"],"Contract.rule.content":["Attachment","Reference"],"Contract.term.action.occurrence":["DateTime","Period","Timing"],"Contract.term.asset.valuedItem.entity":["CodeableConcept","Reference"],"Contract.term.offer.answer.value":["Boolean","Decimal","Integer","Date","DateTime","Time","String","Uri","Attachment","Coding","Quantity","Reference"],"Contract.term.topic":["CodeableConcept","Reference"],"Contract.topic":["CodeableConcept","Reference"],"Coverage.costToBeneficiary.value":["Quantity","Money"],"CoverageEligibilityRequest.event.when":["DateTime","Period"],"CoverageEligibilityRequest.item.diagnosis.diagnosis":["CodeableConcept","Reference"],"CoverageEligibilityRequest.serviced":["Date","Period"],"CoverageEligibilityResponse.event.when":["DateTime","Period"],"CoverageEligibilityResponse.insurance.item.benefit.allowed":["UnsignedInt","String","Money"],"CoverageEligibilityResponse.insurance.item.benefit.used":["UnsignedInt","String","Money"],"CoverageEligibilityResponse.serviced":["Date","Period"],"DataRequirement.dateFilter.value":["DateTime","Period","Duration"],"DataRequirement.subject":["CodeableConcept","Reference"],"DataRequirement.valueFilter.value":["DateTime","Period","Duration"],"DetectedIssue.identified":["DateTime","Period"],"Device.property.value":["Quantity","CodeableConcept","String","Boolean","Integer","Range","Attachment"],"DeviceDefinition.property.value":["Quantity","CodeableConcept","String","Boolean","Integer","Range","Attachment"],"DeviceRequest.occurrence":["DateTime","Period","Timing"],"DeviceRequest.parameter.value":["CodeableConcept","Quantity","Range","Boolean"],"DeviceUsage.timing":["Timing","Period","DateTime"],"DiagnosticReport.effective":["DateTime","Period"],"DocumentReference.content.profile.value":["Coding","Uri","Canonical"],"Dosage.doseAndRate.dose":["Range","Quantity"],"Dosage.doseAndRate.rate":["Ratio","Range","Quantity"],"ElementDefinition.defaultValue":["Base64Binary","Boolean","Canonical","Code","Date","DateTime","Decimal","Id","Instant","Integer","Integer64","Markdown","Oid","PositiveInt","String","Time","UnsignedInt","Uri","Url","Uuid","Address","Age","Annotation","Attachment","CodeableConcept","CodeableReference","Coding","ContactPoint","Count","Distance","Duration","HumanName","Identifier","Money","Period","Quantity","Range","Ratio","RatioRange","Reference","SampledData","Signature","Timing","ContactDetail","DataRequirement","Expression","ParameterDefinition","RelatedArtifact","TriggerDefinition","UsageContext","Availability","ExtendedContactDetail","Dosage","Meta"],"ElementDefinition.example.value":["Base64Binary","Boolean","Canonical","Code","Date","DateTime","Decimal","Id","Instant","Integer","Integer64","Markdown","Oid","PositiveInt","String","Time","UnsignedInt","Uri","Url","Uuid","Address","Age","Annotation","Attachment","CodeableConcept","CodeableReference","Coding","ContactPoint","Count","Distance","Duration","HumanName","Identifier","Money","Period","Quantity","Range","Ratio","RatioRange","Reference","SampledData","Signature","Timing","ContactDetail","DataRequirement","Expression","ParameterDefinition","RelatedArtifact","TriggerDefinition","UsageContext","Availability","ExtendedContactDetail","Dosage","Meta"],"ElementDefinition.fixed":["Base64Binary","Boolean","Canonical","Code","Date","DateTime","Decimal","Id","Instant","Integer","Integer64","Markdown","Oid","PositiveInt","String","Time","UnsignedInt","Uri","Url","Uuid","Address","Age","Annotation","Attachment","CodeableConcept","CodeableReference","Coding","ContactPoint","Count","Distance","Duration","HumanName","Identifier","Money","Period","Quantity","Range","Ratio","RatioRange","Reference","SampledData","Signature","Timing","ContactDetail","DataRequirement","Expression","ParameterDefinition","RelatedArtifact","TriggerDefinition","UsageContext","Availability","ExtendedContactDetail","Dosage","Meta"],"ElementDefinition.maxValue":["Date","DateTime","Instant","Time","Decimal","Integer","Integer64","PositiveInt","UnsignedInt","Quantity"],"ElementDefinition.minValue":["Date","DateTime","Instant","Time","Decimal","Integer","Integer64","PositiveInt","UnsignedInt","Quantity"],"ElementDefinition.pattern":["Base64Binary","Boolean","Canonical","Code","Date","DateTime","Decimal","Id","Instant","Integer","Integer64","Markdown","Oid","PositiveInt","String","Time","UnsignedInt","Uri","Url","Uuid","Address","Age","Annotation","Attachment","CodeableConcept","CodeableReference","Coding","ContactPoint","Count","Distance","Duration","HumanName","Identifier","Money","Period","Quantity","Range","Ratio","RatioRange","Reference","SampledData","Signature","Timing","ContactDetail","DataRequirement","Expression","ParameterDefinition","RelatedArtifact","TriggerDefinition","UsageContext","Availability","ExtendedContactDetail","Dosage","Meta"],"EventDefinition.subject":["CodeableConcept","Reference"],"EventDefinition.versionAlgorithm":["String","Coding"],"Evidence.citeAs":["Reference","Markdown"],"Evidence.versionAlgorithm":["String","Coding"],"EvidenceReport.citeAs":["Reference","Markdown"],"EvidenceReport.subject.characteristic.value":["Reference","CodeableConcept","Boolean","Quantity","Range"],"EvidenceVariable.category.value":["CodeableConcept","Quantity","Range"],"EvidenceVariable.characteristic.definitionByTypeAndValue.value":["CodeableConcept","Boolean","Quantity","Range","Reference","Id"],"EvidenceVariable.characteristic.duration":["Quantity","Range"],"EvidenceVariable.characteristic.instances":["Quantity","Range"],"EvidenceVariable.characteristic.timeFromEvent.event":["CodeableConcept","Reference","DateTime","Id"],"EvidenceVariable.versionAlgorithm":["String","Coding"],"ExampleScenario.instance.structureProfile":["Canonical","Uri"],"ExampleScenario.versionAlgorithm":["String","Coding"],"ExplanationOfBenefit.accident.location":["Address","Reference"],"ExplanationOfBenefit.addItem.location":["CodeableConcept","Address","Reference"],"ExplanationOfBenefit.addItem.serviced":["Date","Period"],"ExplanationOfBenefit.benefitBalance.financial.allowed":["UnsignedInt","String","Money"],"ExplanationOfBenefit.benefitBalance.financial.used":["UnsignedInt","Money"],"ExplanationOfBenefit.diagnosis.diagnosis":["CodeableConcept","Reference"],"ExplanationOfBenefit.event.when":["DateTime","Period"],"ExplanationOfBenefit.item.location":["CodeableConcept","Address","Reference"],"ExplanationOfBenefit.item.serviced":["Date","Period"],"ExplanationOfBenefit.procedure.procedure":["CodeableConcept","Reference"],"ExplanationOfBenefit.supportingInfo.timing":["Date","Period"],"ExplanationOfBenefit.supportingInfo.value":["Boolean","String","Quantity","Attachment","Reference","Identifier"],"Extension.value":["Base64Binary","Boolean","Canonical","Code","Date","DateTime","Decimal","Id","Instant","Integer","Integer64","Markdown","Oid","PositiveInt","String","Time","UnsignedInt","Uri","Url","Uuid","Address","Age","Annotation","Attachment","CodeableConcept","CodeableReference","Coding","ContactPoint","Count","Distance","Duration","HumanName","Identifier","Money","Period","Quantity","Range","Ratio","RatioRange","Reference","SampledData","Signature","Timing","ContactDetail","DataRequirement","Expression","ParameterDefinition","RelatedArtifact","TriggerDefinition","UsageContext","Availability","ExtendedContactDetail","Dosage","Meta"],"FamilyMemberHistory.age":["Age","Range","String"],"FamilyMemberHistory.born":["Period","Date","String"],"FamilyMemberHistory.condition.onset":["Age","Range","Period","String"],"FamilyMemberHistory.deceased":["Boolean","Age","Range","Date","String"],"FamilyMemberHistory.procedure.performed":["Age","Range","Period","String","DateTime"],"GenomicStudy.analysis.input.generatedBy":["Identifier","Reference"],"Goal.start":["Date","CodeableConcept"],"Goal.target.detail":["Quantity","Range","CodeableConcept","String","Boolean","Integer","Ratio"],"Goal.target.due":["Date","Duration"],"GraphDefinition.versionAlgorithm":["String","Coding"],"Group.characteristic.value":["CodeableConcept","Boolean","Quantity","Range","Reference"],"GuidanceResponse.module":["Uri","Canonical","CodeableConcept"],"Immunization.occurrence":["DateTime","String"],"ImplementationGuide.definition.page.source":["Url","String","Markdown"],"ImplementationGuide.versionAlgorithm":["String","Coding"],"Ingredient.substance.strength.concentration":["Ratio","RatioRange","CodeableConcept","Quantity"],"Ingredient.substance.strength.presentation":["Ratio","RatioRange","CodeableConcept","Quantity"],"Ingredient.substance.strength.referenceStrength.strength":["Ratio","RatioRange","Quantity"],"InventoryItem.characteristic.value":["String","Integer","Decimal","Boolean","Url","DateTime","Quantity","Range","Ratio","Annotation","Address","Duration","CodeableConcept"],"Invoice.lineItem.chargeItem":["Reference","CodeableConcept"],"Invoice.lineItem.serviced":["Date","Period"],"Invoice.period":["Date","Period"],"Library.subject":["CodeableConcept","Reference"],"Library.versionAlgorithm":["String","Coding"],"ManufacturedItemDefinition.property.value":["CodeableConcept","Quantity","Date","Boolean","Markdown","Attachment","Reference"],"Measure.group.subject":["CodeableConcept","Reference"],"Measure.subject":["CodeableConcept","Reference"],"Measure.versionAlgorithm":["String","Coding"],"MeasureReport.group.measureScore":["Quantity","DateTime","CodeableConcept","Period","Range","Duration"],"MeasureReport.group.stratifier.stratum.component.value":["CodeableConcept","Boolean","Quantity","Range","Reference"],"MeasureReport.group.stratifier.stratum.measureScore":["Quantity","DateTime","CodeableConcept","Period","Range","Duration"],"MeasureReport.group.stratifier.stratum.value":["CodeableConcept","Boolean","Quantity","Range","Reference"],"Medication.ingredient.strength":["Ratio","CodeableConcept","Quantity"],"MedicationAdministration.dosage.rate":["Ratio","Quantity"],"MedicationAdministration.occurence":["DateTime","Period","Timing"],"MedicationKnowledge.cost.cost":["Money","CodeableConcept"],"MedicationKnowledge.definitional.drugCharacteristic.value":["CodeableConcept","String","Quantity","Base64Binary","Attachment"],"MedicationKnowledge.definitional.ingredient.strength":["Ratio","CodeableConcept","Quantity"],"MedicationKnowledge.indicationGuideline.dosingGuideline.patientCharacteristic.value":["CodeableConcept","Quantity","Range"],"MedicationKnowledge.medicineClassification.source":["String","Uri"],"MedicationKnowledge.storageGuideline.environmentalSetting.value":["Quantity","Range","CodeableConcept"],"MedicationRequest.substitution.allowed":["Boolean","CodeableConcept"],"MedicationStatement.effective":["DateTime","Period","Timing"],"MedicinalProductDefinition.characteristic.value":["CodeableConcept","Markdown","Quantity","Integer","Date","Boolean","Attachment"],"MessageDefinition.event":["Coding","Uri"],"MessageDefinition.versionAlgorithm":["String","Coding"],"MessageHeader.destination.endpoint":["Url","Reference"],"MessageHeader.event":["Coding","Canonical"],"MessageHeader.source.endpoint":["Url","Reference"],"MetadataResource.versionAlgorithm":["String","Coding"],"MolecularSequence.relative.startingSequence.sequence":["CodeableConcept","String","Reference"],"NamingSystem.versionAlgorithm":["String","Coding"],"NutritionIntake.occurrence":["DateTime","Period"],"NutritionIntake.reported":["Boolean","Reference"],"NutritionOrder.enteralFormula.administration.rate":["Quantity","Ratio"],"NutritionProduct.characteristic.value":["CodeableConcept","String","Quantity","Base64Binary","Attachment","Boolean"],"Observation.component.value":["Quantity","CodeableConcept","String","Boolean","Integer","Range","Ratio","SampledData","Time","DateTime","Period","Attachment","Reference"],"Observation.effective":["DateTime","Period","Timing","Instant"],"Observation.instantiates":["Canonical","Reference"],"Observation.value":["Quantity","CodeableConcept","String","Boolean","Integer","Range","Ratio","SampledData","Time","DateTime","Period","Attachment","Reference"],"ObservationDefinition.versionAlgorithm":["String","Coding"],"OperationDefinition.versionAlgorithm":["String","Coding"],"PackagedProductDefinition.packaging.property.value":["CodeableConcept","Quantity","Date","Boolean","Attachment"],"Parameters.parameter.value":["Base64Binary","Boolean","Canonical","Code","Date","DateTime","Decimal","Id","Instant","Integer","Integer64","Markdown","Oid","PositiveInt","String","Time","UnsignedInt","Uri","Url","Uuid","Address","Age","Annotation","Attachment","CodeableConcept","CodeableReference","Coding","ContactPoint","Count","Distance","Duration","HumanName","Identifier","Money","Period","Quantity","Range","Ratio","RatioRange","Reference","SampledData","Signature","Timing","ContactDetail","DataRequirement","Expression","ParameterDefinition","RelatedArtifact","TriggerDefinition","UsageContext","Availability","ExtendedContactDetail","Dosage","Meta"],"Patient.deceased":["Boolean","DateTime"],"Patient.multipleBirth":["Boolean","Integer"],"PaymentReconciliation.allocation.targetItem":["String","Identifier","PositiveInt"],"Person.deceased":["Boolean","DateTime"],"PlanDefinition.action.definition":["Canonical","Uri"],"PlanDefinition.action.relatedAction.offset":["Duration","Range"],"PlanDefinition.action.subject":["CodeableConcept","Reference","Canonical"],"PlanDefinition.action.timing":["Age","Duration","Range","Timing"],"PlanDefinition.asNeeded":["Boolean","CodeableConcept"],"PlanDefinition.goal.target.detail":["Quantity","Range","CodeableConcept","String","Boolean","Integer","Ratio"],"PlanDefinition.subject":["CodeableConcept","Reference","Canonical"],"PlanDefinition.versionAlgorithm":["String","Coding"],"Practitioner.deceased":["Boolean","DateTime"],"Procedure.occurrence":["DateTime","Period","String","Age","Range","Timing"],"Procedure.reported":["Boolean","Reference"],"ProductShelfLife.period":["Duration","String"],"Provenance.occurred":["Period","DateTime"],"Questionnaire.item.answerOption.value":["Integer","Date","Time","String","Coding","Reference"],"Questionnaire.item.enableWhen.answer":["Boolean","Decimal","Integer","Date","DateTime","Time","String","Coding","Quantity","Reference"],"Questionnaire.item.initial.value":["Boolean","Decimal","Integer","Date","DateTime","Time","String","Uri","Attachment","Coding","Quantity","Reference"],"Questionnaire.versionAlgorithm":["String","Coding"],"QuestionnaireResponse.item.answer.value":["Boolean","Decimal","Integer","Date","DateTime","Time","String","Uri","Attachment","Coding","Quantity","Reference"],"RegulatedAuthorization.case.date":["Period","DateTime"],"RequestOrchestration.action.definition":["Canonical","Uri"],"RequestOrchestration.action.participant.actor":["Canonical","Reference"],"RequestOrchestration.action.relatedAction.offset":["Duration","Range"],"RequestOrchestration.action.timing":["DateTime","Age","Period","Duration","Range","Timing"],"Requirements.versionAlgorithm":["String","Coding"],"RiskAssessment.occurrence":["DateTime","Period"],"RiskAssessment.prediction.probability":["Decimal","Range"],"RiskAssessment.prediction.when":["Period","Range"],"SearchParameter.versionAlgorithm":["String","Coding"],"ServiceRequest.asNeeded":["Boolean","CodeableConcept"],"ServiceRequest.occurrence":["DateTime","Period","Timing"],"ServiceRequest.orderDetail.parameter.value":["Quantity","Ratio","Range","Boolean","CodeableConcept","String","Period"],"ServiceRequest.patientInstruction.instruction":["Markdown","Reference"],"ServiceRequest.quantity":["Quantity","Ratio","Range"],"Specimen.collection.collected":["DateTime","Period"],"Specimen.collection.fastingStatus":["CodeableConcept","Duration"],"Specimen.processing.time":["DateTime","Period"],"SpecimenDefinition.subject":["CodeableConcept","Reference"],"SpecimenDefinition.typeTested.container.additive.additive":["CodeableConcept","Reference"],"SpecimenDefinition.typeTested.container.minimumVolume":["Quantity","String"],"SpecimenDefinition.versionAlgorithm":["String","Coding"],"StructureDefinition.versionAlgorithm":["String","Coding"],"StructureMap.group.rule.target.parameter.value":["Id","String","Boolean","Integer","Decimal","Date","Time","DateTime"],"StructureMap.versionAlgorithm":["String","Coding"],"SubscriptionTopic.versionAlgorithm":["String","Coding"],"Substance.ingredient.substance":["CodeableConcept","Reference"],"SubstanceDefinition.moiety.amount":["Quantity","String"],"SubstanceDefinition.property.value":["CodeableConcept","Quantity","Date","Boolean","Attachment"],"SubstanceDefinition.relationship.amount":["Quantity","Ratio","String"],"SubstanceDefinition.relationship.substanceDefinition":["Reference","CodeableConcept"],"SubstanceReferenceInformation.target.amount":["Quantity","Range","String"],"SupplyDelivery.occurrence":["DateTime","Period","Timing"],"SupplyDelivery.suppliedItem.item":["CodeableConcept","Reference"],"SupplyRequest.occurrence":["DateTime","Period","Timing"],"SupplyRequest.parameter.value":["CodeableConcept","Quantity","Range","Boolean"],"Task.input.value":["Base64Binary","Boolean","Canonical","Code","Date","DateTime","Decimal","Id","Instant","Integer","Integer64","Markdown","Oid","PositiveInt","String","Time","UnsignedInt","Uri","Url","Uuid","Address","Age","Annotation","Attachment","CodeableConcept","CodeableReference","Coding","ContactPoint","Count","Distance","Duration","HumanName","Identifier","Money","Period","Quantity","Range","Ratio","RatioRange","Reference","SampledData","Signature","Timing","ContactDetail","DataRequirement","Expression","ParameterDefinition","RelatedArtifact","TriggerDefinition","UsageContext","Availability","ExtendedContactDetail","Dosage","Meta"],"Task.output.value":["Base64Binary","Boolean","Canonical","Code","Date","DateTime","Decimal","Id","Instant","Integer","Integer64","Markdown","Oid","PositiveInt","String","Time","UnsignedInt","Uri","Url","Uuid","Address","Age","Annotation","Attachment","CodeableConcept","CodeableReference","Coding","ContactPoint","Count","Distance","Duration","HumanName","Identifier","Money","Period","Quantity","Range","Ratio","RatioRange","Reference","SampledData","Signature","Timing","ContactDetail","DataRequirement","Expression","ParameterDefinition","RelatedArtifact","TriggerDefinition","UsageContext","Availability","ExtendedContactDetail","Dosage","Meta"],"TerminologyCapabilities.versionAlgorithm":["String","Coding"],"TestPlan.testCase.testData.source":["String","Reference"],"TestPlan.testCase.testRun.script.source":["String","Reference"],"TestPlan.versionAlgorithm":["String","Coding"],"TestReport.setup.action.assert.requirement.link":["Uri","Canonical"],"TestScript.setup.action.assert.requirement.link":["Uri","Canonical"],"TestScript.versionAlgorithm":["String","Coding"],"Timing.repeat.bounds":["Duration","Range","Period"],"Transport.input.value":["Base64Binary","Boolean","Canonical","Code","Date","DateTime","Decimal","Id","Instant","Integer","Integer64","Markdown","Oid","PositiveInt","String","Time","UnsignedInt","Uri","Url","Uuid","Address","Age","Annotation","Attachment","CodeableConcept","CodeableReference","Coding","ContactPoint","Count","Distance","Duration","HumanName","Identifier","Money","Period","Quantity","Range","Ratio","RatioRange","Reference","SampledData","Signature","Timing","ContactDetail","DataRequirement","Expression","ParameterDefinition","RelatedArtifact","TriggerDefinition","UsageContext","Availability","ExtendedContactDetail","Dosage","Meta"],"Transport.output.value":["Base64Binary","Boolean","Canonical","Code","Date","DateTime","Decimal","Id","Instant","Integer","Integer64","Markdown","Oid","PositiveInt","String","Time","UnsignedInt","Uri","Url","Uuid","Address","Age","Annotation","Attachment","CodeableConcept","CodeableReference","Coding","ContactPoint","Count","Distance","Duration","HumanName","Identifier","Money","Period","Quantity","Range","Ratio","RatioRange","Reference","SampledData","Signature","Timing","ContactDetail","DataRequirement","Expression","ParameterDefinition","RelatedArtifact","TriggerDefinition","UsageContext","Availability","ExtendedContactDetail","Dosage","Meta"],"TriggerDefinition.timing":["Timing","Reference","Date","DateTime"],"UsageContext.value":["CodeableConcept","Quantity","Range","Reference"],"ValueSet.expansion.contains.property.subProperty.value":["Code","Coding","String","Integer","Boolean","DateTime","Decimal"],"ValueSet.expansion.contains.property.value":["Code","Coding","String","Integer","Boolean","DateTime","Decimal"],"ValueSet.expansion.parameter.value":["String","Boolean","Integer","Decimal","Uri","Code","DateTime"],"ValueSet.versionAlgorithm":["String","Coding"],"VirtualServiceDetail.address":["Url","String","ContactPoint","ExtendedContactDetail"]}');

/***/ }),
/* 92 */
/***/ (function(module) {

"use strict";
module.exports = /*#__PURE__*/JSON.parse('{"ArtifactAssessment.content.component":"ArtifactAssessment.content","AuditEvent.entity.agent":"AuditEvent.agent","BodyStructure.excludedStructure":"BodyStructure.includedStructure","Bundle.entry.link":"Bundle.link","CapabilityStatement.rest.operation":"CapabilityStatement.rest.resource.operation","CapabilityStatement.rest.searchParam":"CapabilityStatement.rest.resource.searchParam","ChargeItemDefinition.propertyGroup.applicability":"ChargeItemDefinition.applicability","ClaimResponse.addItem.adjudication":"ClaimResponse.item.adjudication","ClaimResponse.addItem.detail.adjudication":"ClaimResponse.item.adjudication","ClaimResponse.addItem.detail.reviewOutcome":"ClaimResponse.item.reviewOutcome","ClaimResponse.addItem.detail.subDetail.adjudication":"ClaimResponse.item.adjudication","ClaimResponse.addItem.detail.subDetail.reviewOutcome":"ClaimResponse.item.reviewOutcome","ClaimResponse.addItem.reviewOutcome":"ClaimResponse.item.reviewOutcome","ClaimResponse.adjudication":"ClaimResponse.item.adjudication","ClaimResponse.item.detail.adjudication":"ClaimResponse.item.adjudication","ClaimResponse.item.detail.reviewOutcome":"ClaimResponse.item.reviewOutcome","ClaimResponse.item.detail.subDetail.adjudication":"ClaimResponse.item.adjudication","ClaimResponse.item.detail.subDetail.reviewOutcome":"ClaimResponse.item.reviewOutcome","ClinicalUseDefinition.indication.otherTherapy":"ClinicalUseDefinition.contraindication.otherTherapy","CodeSystem.concept.concept":"CodeSystem.concept","Composition.section.section":"Composition.section","ConceptMap.group.element.target.product":"ConceptMap.group.element.target.dependsOn","Consent.provision.provision":"Consent.provision","Contract.term.asset.answer":"Contract.term.offer.answer","Contract.term.group":"Contract.term","DeviceDefinition.packaging.packaging":"DeviceDefinition.packaging","DeviceDefinition.packaging.udiDeviceIdentifier":"DeviceDefinition.udiDeviceIdentifier","Evidence.certainty.subcomponent":"Evidence.certainty","Evidence.statistic.attributeEstimate.attributeEstimate":"Evidence.statistic.attributeEstimate","Evidence.statistic.modelCharacteristic.attributeEstimate":"Evidence.statistic.attributeEstimate","EvidenceReport.section.section":"EvidenceReport.section","EvidenceVariable.characteristic.definitionByCombination.characteristic":"EvidenceVariable.characteristic","ExampleScenario.process.step.alternative.step":"ExampleScenario.process.step","ExampleScenario.process.step.operation.request":"ExampleScenario.instance.containedInstance","ExampleScenario.process.step.operation.response":"ExampleScenario.instance.containedInstance","ExampleScenario.process.step.process":"ExampleScenario.process","ExplanationOfBenefit.addItem.adjudication":"ExplanationOfBenefit.item.adjudication","ExplanationOfBenefit.addItem.detail.adjudication":"ExplanationOfBenefit.item.adjudication","ExplanationOfBenefit.addItem.detail.reviewOutcome":"ExplanationOfBenefit.item.reviewOutcome","ExplanationOfBenefit.addItem.detail.subDetail.adjudication":"ExplanationOfBenefit.item.adjudication","ExplanationOfBenefit.addItem.detail.subDetail.reviewOutcome":"ExplanationOfBenefit.item.reviewOutcome","ExplanationOfBenefit.addItem.reviewOutcome":"ExplanationOfBenefit.item.reviewOutcome","ExplanationOfBenefit.adjudication":"ExplanationOfBenefit.item.adjudication","ExplanationOfBenefit.item.detail.adjudication":"ExplanationOfBenefit.item.adjudication","ExplanationOfBenefit.item.detail.reviewOutcome":"ExplanationOfBenefit.item.reviewOutcome","ExplanationOfBenefit.item.detail.subDetail.adjudication":"ExplanationOfBenefit.item.adjudication","ExplanationOfBenefit.item.detail.subDetail.reviewOutcome":"ExplanationOfBenefit.item.reviewOutcome","ImplementationGuide.definition.page.page":"ImplementationGuide.definition.page","ManufacturedItemDefinition.component.component":"ManufacturedItemDefinition.component","ManufacturedItemDefinition.component.property":"ManufacturedItemDefinition.property","MedicationKnowledge.packaging.cost":"MedicationKnowledge.cost","Observation.component.referenceRange":"Observation.referenceRange","ObservationDefinition.component.qualifiedValue":"ObservationDefinition.qualifiedValue","OperationDefinition.parameter.part":"OperationDefinition.parameter","PackagedProductDefinition.characteristic":"PackagedProductDefinition.packaging.property","PackagedProductDefinition.packaging.packaging":"PackagedProductDefinition.packaging","Parameters.parameter.part":"Parameters.parameter","PlanDefinition.action.action":"PlanDefinition.action","Provenance.entity.agent":"Provenance.agent","Questionnaire.item.item":"Questionnaire.item","QuestionnaireResponse.item.answer.item":"QuestionnaireResponse.item","QuestionnaireResponse.item.item":"QuestionnaireResponse.item","RegulatedAuthorization.case.application":"RegulatedAuthorization.case","RequestOrchestration.action.action":"RequestOrchestration.action","StructureMap.group.rule.dependent.parameter":"StructureMap.group.rule.target.parameter","StructureMap.group.rule.rule":"StructureMap.group.rule","SubstanceDefinition.name.synonym":"SubstanceDefinition.name","SubstanceDefinition.name.translation":"SubstanceDefinition.name","SubstanceDefinition.structure.molecularWeight":"SubstanceDefinition.molecularWeight","TestReport.teardown.action.operation":"TestReport.setup.action.operation","TestReport.test.action.assert":"TestReport.setup.action.assert","TestReport.test.action.operation":"TestReport.setup.action.operation","TestScript.teardown.action.operation":"TestScript.setup.action.operation","TestScript.test.action.assert":"TestScript.setup.action.assert","TestScript.test.action.operation":"TestScript.setup.action.operation","ValueSet.compose.exclude":"ValueSet.compose.include","ValueSet.expansion.contains.contains":"ValueSet.expansion.contains","ValueSet.expansion.contains.designation":"ValueSet.compose.include.concept.designation"}');

/***/ }),
/* 93 */
/***/ (function(module) {

"use strict";
module.exports = /*#__PURE__*/JSON.parse('{"Account":"DomainResource","ActivityDefinition":"DomainResource","ActorDefinition":"DomainResource","Address":"DataType","AdministrableProductDefinition":"DomainResource","AdverseEvent":"DomainResource","Age":"Quantity","AllergyIntolerance":"DomainResource","Annotation":"DataType","Appointment":"DomainResource","AppointmentResponse":"DomainResource","ArtifactAssessment":"DomainResource","Attachment":"DataType","AuditEvent":"DomainResource","Availability":"DataType","BackboneElement":"Element","BackboneType":"DataType","Basic":"DomainResource","Binary":"Resource","BiologicallyDerivedProduct":"DomainResource","BiologicallyDerivedProductDispense":"DomainResource","BodyStructure":"DomainResource","Bundle":"Resource","CanonicalResource":"DomainResource","CapabilityStatement":"DomainResource","CarePlan":"DomainResource","CareTeam":"DomainResource","ChargeItem":"DomainResource","ChargeItemDefinition":"DomainResource","Citation":"DomainResource","Claim":"DomainResource","ClaimResponse":"DomainResource","ClinicalImpression":"DomainResource","ClinicalUseDefinition":"DomainResource","CodeSystem":"DomainResource","CodeableConcept":"DataType","CodeableReference":"DataType","Coding":"DataType","Communication":"DomainResource","CommunicationRequest":"DomainResource","CompartmentDefinition":"DomainResource","Composition":"DomainResource","ConceptMap":"DomainResource","Condition":"DomainResource","ConditionDefinition":"DomainResource","Consent":"DomainResource","ContactDetail":"DataType","ContactPoint":"DataType","Contract":"DomainResource","Contributor":"DataType","Count":"Quantity","Coverage":"DomainResource","CoverageEligibilityRequest":"DomainResource","CoverageEligibilityResponse":"DomainResource","DataRequirement":"DataType","DataType":"Element","DetectedIssue":"DomainResource","Device":"DomainResource","DeviceAssociation":"DomainResource","DeviceDefinition":"DomainResource","DeviceDispense":"DomainResource","DeviceMetric":"DomainResource","DeviceRequest":"DomainResource","DeviceUsage":"DomainResource","DiagnosticReport":"DomainResource","Distance":"Quantity","DocumentReference":"DomainResource","DomainResource":"Resource","Dosage":"BackboneType","Duration":"Quantity","Element":"Base","ElementDefinition":"BackboneType","Encounter":"DomainResource","EncounterHistory":"DomainResource","Endpoint":"DomainResource","EnrollmentRequest":"DomainResource","EnrollmentResponse":"DomainResource","EpisodeOfCare":"DomainResource","EventDefinition":"DomainResource","Evidence":"DomainResource","EvidenceReport":"DomainResource","EvidenceVariable":"DomainResource","ExampleScenario":"DomainResource","ExplanationOfBenefit":"DomainResource","Expression":"DataType","ExtendedContactDetail":"DataType","Extension":"DataType","FamilyMemberHistory":"DomainResource","Flag":"DomainResource","FormularyItem":"DomainResource","GenomicStudy":"DomainResource","Goal":"DomainResource","GraphDefinition":"DomainResource","Group":"DomainResource","GuidanceResponse":"DomainResource","HealthcareService":"DomainResource","HumanName":"DataType","Identifier":"DataType","ImagingSelection":"DomainResource","ImagingStudy":"DomainResource","Immunization":"DomainResource","ImmunizationEvaluation":"DomainResource","ImmunizationRecommendation":"DomainResource","ImplementationGuide":"DomainResource","Ingredient":"DomainResource","InsurancePlan":"DomainResource","InventoryItem":"DomainResource","InventoryReport":"DomainResource","Invoice":"DomainResource","Library":"DomainResource","Linkage":"DomainResource","List":"DomainResource","Location":"DomainResource","ManufacturedItemDefinition":"DomainResource","MarketingStatus":"BackboneType","Measure":"DomainResource","MeasureReport":"DomainResource","Medication":"DomainResource","MedicationAdministration":"DomainResource","MedicationDispense":"DomainResource","MedicationKnowledge":"DomainResource","MedicationRequest":"DomainResource","MedicationStatement":"DomainResource","MedicinalProductDefinition":"DomainResource","MessageDefinition":"DomainResource","MessageHeader":"DomainResource","Meta":"DataType","MetadataResource":"DomainResource","MolecularSequence":"DomainResource","MonetaryComponent":"DataType","Money":"DataType","MoneyQuantity":"Quantity","NamingSystem":"DomainResource","Narrative":"DataType","NutritionIntake":"DomainResource","NutritionOrder":"DomainResource","NutritionProduct":"DomainResource","Observation":"DomainResource","ObservationDefinition":"DomainResource","OperationDefinition":"DomainResource","OperationOutcome":"DomainResource","Organization":"DomainResource","OrganizationAffiliation":"DomainResource","PackagedProductDefinition":"DomainResource","ParameterDefinition":"DataType","Parameters":"Resource","Patient":"DomainResource","PaymentNotice":"DomainResource","PaymentReconciliation":"DomainResource","Period":"DataType","Permission":"DomainResource","Person":"DomainResource","PlanDefinition":"DomainResource","Practitioner":"DomainResource","PractitionerRole":"DomainResource","PrimitiveType":"DataType","Procedure":"DomainResource","ProductShelfLife":"BackboneType","Provenance":"DomainResource","Quantity":"DataType","Questionnaire":"DomainResource","QuestionnaireResponse":"DomainResource","Range":"DataType","Ratio":"DataType","RatioRange":"DataType","Reference":"DataType","RegulatedAuthorization":"DomainResource","RelatedArtifact":"DataType","RelatedPerson":"DomainResource","RequestOrchestration":"DomainResource","Requirements":"DomainResource","ResearchStudy":"DomainResource","ResearchSubject":"DomainResource","Resource":"Base","RiskAssessment":"DomainResource","SampledData":"DataType","Schedule":"DomainResource","SearchParameter":"DomainResource","ServiceRequest":"DomainResource","Signature":"DataType","SimpleQuantity":"Quantity","Slot":"DomainResource","Specimen":"DomainResource","SpecimenDefinition":"DomainResource","StructureDefinition":"DomainResource","StructureMap":"DomainResource","Subscription":"DomainResource","SubscriptionStatus":"DomainResource","SubscriptionTopic":"DomainResource","Substance":"DomainResource","SubstanceDefinition":"DomainResource","SubstanceNucleicAcid":"DomainResource","SubstancePolymer":"DomainResource","SubstanceProtein":"DomainResource","SubstanceReferenceInformation":"DomainResource","SubstanceSourceMaterial":"DomainResource","SupplyDelivery":"DomainResource","SupplyRequest":"DomainResource","Task":"DomainResource","TerminologyCapabilities":"DomainResource","TestPlan":"DomainResource","TestReport":"DomainResource","TestScript":"DomainResource","Timing":"BackboneType","Transport":"DomainResource","TriggerDefinition":"DataType","UsageContext":"DataType","ValueSet":"DomainResource","VerificationResult":"DomainResource","VirtualServiceDetail":"DataType","VisionPrescription":"DomainResource","base64Binary":"PrimitiveType","boolean":"PrimitiveType","canonical":"uri","code":"string","date":"PrimitiveType","dateTime":"PrimitiveType","decimal":"PrimitiveType","id":"string","instant":"PrimitiveType","integer":"PrimitiveType","integer64":"PrimitiveType","markdown":"string","oid":"uri","positiveInt":"integer","string":"PrimitiveType","time":"PrimitiveType","unsignedInt":"integer","uri":"PrimitiveType","url":"uri","uuid":"uri","xhtml":"Element"}');

/***/ }),
/* 94 */
/***/ (function(module) {

"use strict";
module.exports = /*#__PURE__*/JSON.parse('{"Account.balance":"BackboneElement","Account.balance.aggregate":"CodeableConcept","Account.balance.amount":"Money","Account.balance.estimate":"boolean","Account.balance.extension":"Extension","Account.balance.id":"System.String","Account.balance.modifierExtension":"Extension","Account.balance.term":"CodeableConcept","Account.billingStatus":"CodeableConcept","Account.calculatedAt":"instant","Account.contained":"Resource","Account.coverage":"BackboneElement","Account.coverage.coverage":"Reference","Account.coverage.extension":"Extension","Account.coverage.id":"System.String","Account.coverage.modifierExtension":"Extension","Account.coverage.priority":"positiveInt","Account.currency":"CodeableConcept","Account.description":"markdown","Account.diagnosis":"BackboneElement","Account.diagnosis.condition":"CodeableReference","Account.diagnosis.dateOfDiagnosis":"dateTime","Account.diagnosis.extension":"Extension","Account.diagnosis.id":"System.String","Account.diagnosis.modifierExtension":"Extension","Account.diagnosis.onAdmission":"boolean","Account.diagnosis.packageCode":"CodeableConcept","Account.diagnosis.sequence":"positiveInt","Account.diagnosis.type":"CodeableConcept","Account.extension":"Extension","Account.guarantor":"BackboneElement","Account.guarantor.extension":"Extension","Account.guarantor.id":"System.String","Account.guarantor.modifierExtension":"Extension","Account.guarantor.onHold":"boolean","Account.guarantor.party":"Reference","Account.guarantor.period":"Period","Account.id":"System.String","Account.identifier":"Identifier","Account.implicitRules":"uri","Account.language":"code","Account.meta":"Meta","Account.modifierExtension":"Extension","Account.name":"string","Account.owner":"Reference","Account.procedure":"BackboneElement","Account.procedure.code":"CodeableReference","Account.procedure.dateOfService":"dateTime","Account.procedure.device":"Reference","Account.procedure.extension":"Extension","Account.procedure.id":"System.String","Account.procedure.modifierExtension":"Extension","Account.procedure.packageCode":"CodeableConcept","Account.procedure.sequence":"positiveInt","Account.procedure.type":"CodeableConcept","Account.relatedAccount":"BackboneElement","Account.relatedAccount.account":"Reference","Account.relatedAccount.extension":"Extension","Account.relatedAccount.id":"System.String","Account.relatedAccount.modifierExtension":"Extension","Account.relatedAccount.relationship":"CodeableConcept","Account.servicePeriod":"Period","Account.status":"code","Account.subject":"Reference","Account.text":"Narrative","Account.type":"CodeableConcept","ActivityDefinition.approvalDate":"date","ActivityDefinition.asNeededBoolean":"boolean","ActivityDefinition.asNeededCodeableConcept":"CodeableConcept","ActivityDefinition.author":"ContactDetail","ActivityDefinition.bodySite":"CodeableConcept","ActivityDefinition.code":"CodeableConcept","ActivityDefinition.contact":"ContactDetail","ActivityDefinition.contained":"Resource","ActivityDefinition.copyright":"markdown","ActivityDefinition.copyrightLabel":"string","ActivityDefinition.date":"dateTime","ActivityDefinition.description":"markdown","ActivityDefinition.doNotPerform":"boolean","ActivityDefinition.dosage":"Dosage","ActivityDefinition.dynamicValue":"BackboneElement","ActivityDefinition.dynamicValue.expression":"Expression","ActivityDefinition.dynamicValue.extension":"Extension","ActivityDefinition.dynamicValue.id":"System.String","ActivityDefinition.dynamicValue.modifierExtension":"Extension","ActivityDefinition.dynamicValue.path":"string","ActivityDefinition.editor":"ContactDetail","ActivityDefinition.effectivePeriod":"Period","ActivityDefinition.endorser":"ContactDetail","ActivityDefinition.experimental":"boolean","ActivityDefinition.extension":"Extension","ActivityDefinition.id":"System.String","ActivityDefinition.identifier":"Identifier","ActivityDefinition.implicitRules":"uri","ActivityDefinition.intent":"code","ActivityDefinition.jurisdiction":"CodeableConcept","ActivityDefinition.kind":"code","ActivityDefinition.language":"code","ActivityDefinition.lastReviewDate":"date","ActivityDefinition.library":"canonical","ActivityDefinition.location":"CodeableReference","ActivityDefinition.meta":"Meta","ActivityDefinition.modifierExtension":"Extension","ActivityDefinition.name":"string","ActivityDefinition.observationRequirement":"canonical","ActivityDefinition.observationResultRequirement":"canonical","ActivityDefinition.participant":"BackboneElement","ActivityDefinition.participant.extension":"Extension","ActivityDefinition.participant.function":"CodeableConcept","ActivityDefinition.participant.id":"System.String","ActivityDefinition.participant.modifierExtension":"Extension","ActivityDefinition.participant.role":"CodeableConcept","ActivityDefinition.participant.type":"code","ActivityDefinition.participant.typeCanonical":"canonical","ActivityDefinition.participant.typeReference":"Reference","ActivityDefinition.priority":"code","ActivityDefinition.productCodeableConcept":"CodeableConcept","ActivityDefinition.productReference":"Reference","ActivityDefinition.profile":"canonical","ActivityDefinition.publisher":"string","ActivityDefinition.purpose":"markdown","ActivityDefinition.quantity":"Quantity","ActivityDefinition.relatedArtifact":"RelatedArtifact","ActivityDefinition.reviewer":"ContactDetail","ActivityDefinition.specimenRequirement":"canonical","ActivityDefinition.status":"code","ActivityDefinition.subjectCanonical":"canonical","ActivityDefinition.subjectCodeableConcept":"CodeableConcept","ActivityDefinition.subjectReference":"Reference","ActivityDefinition.subtitle":"string","ActivityDefinition.text":"Narrative","ActivityDefinition.timingAge":"Age","ActivityDefinition.timingDuration":"Duration","ActivityDefinition.timingRange":"Range","ActivityDefinition.timingTiming":"Timing","ActivityDefinition.title":"string","ActivityDefinition.topic":"CodeableConcept","ActivityDefinition.transform":"canonical","ActivityDefinition.url":"uri","ActivityDefinition.usage":"markdown","ActivityDefinition.useContext":"UsageContext","ActivityDefinition.version":"string","ActivityDefinition.versionAlgorithmCoding":"Coding","ActivityDefinition.versionAlgorithmString":"string","ActorDefinition.capabilities":"canonical","ActorDefinition.contact":"ContactDetail","ActorDefinition.contained":"Resource","ActorDefinition.copyright":"markdown","ActorDefinition.copyrightLabel":"string","ActorDefinition.date":"dateTime","ActorDefinition.derivedFrom":"canonical","ActorDefinition.description":"markdown","ActorDefinition.documentation":"markdown","ActorDefinition.experimental":"boolean","ActorDefinition.extension":"Extension","ActorDefinition.id":"System.String","ActorDefinition.identifier":"Identifier","ActorDefinition.implicitRules":"uri","ActorDefinition.jurisdiction":"CodeableConcept","ActorDefinition.language":"code","ActorDefinition.meta":"Meta","ActorDefinition.modifierExtension":"Extension","ActorDefinition.name":"string","ActorDefinition.publisher":"string","ActorDefinition.purpose":"markdown","ActorDefinition.reference":"url","ActorDefinition.status":"code","ActorDefinition.text":"Narrative","ActorDefinition.title":"string","ActorDefinition.type":"code","ActorDefinition.url":"uri","ActorDefinition.useContext":"UsageContext","ActorDefinition.version":"string","ActorDefinition.versionAlgorithmCoding":"Coding","ActorDefinition.versionAlgorithmString":"string","Address.city":"string","Address.country":"string","Address.district":"string","Address.extension":"Extension","Address.id":"System.String","Address.line":"string","Address.period":"Period","Address.postalCode":"string","Address.state":"string","Address.text":"string","Address.type":"code","Address.use":"code","AdministrableProductDefinition.administrableDoseForm":"CodeableConcept","AdministrableProductDefinition.contained":"Resource","AdministrableProductDefinition.description":"markdown","AdministrableProductDefinition.device":"Reference","AdministrableProductDefinition.extension":"Extension","AdministrableProductDefinition.formOf":"Reference","AdministrableProductDefinition.id":"System.String","AdministrableProductDefinition.identifier":"Identifier","AdministrableProductDefinition.implicitRules":"uri","AdministrableProductDefinition.ingredient":"CodeableConcept","AdministrableProductDefinition.language":"code","AdministrableProductDefinition.meta":"Meta","AdministrableProductDefinition.modifierExtension":"Extension","AdministrableProductDefinition.producedFrom":"Reference","AdministrableProductDefinition.property":"BackboneElement","AdministrableProductDefinition.property.extension":"Extension","AdministrableProductDefinition.property.id":"System.String","AdministrableProductDefinition.property.modifierExtension":"Extension","AdministrableProductDefinition.property.status":"CodeableConcept","AdministrableProductDefinition.property.type":"CodeableConcept","AdministrableProductDefinition.property.valueAttachment":"Attachment","AdministrableProductDefinition.property.valueBoolean":"boolean","AdministrableProductDefinition.property.valueCodeableConcept":"CodeableConcept","AdministrableProductDefinition.property.valueDate":"date","AdministrableProductDefinition.property.valueMarkdown":"markdown","AdministrableProductDefinition.property.valueQuantity":"Quantity","AdministrableProductDefinition.property.valueReference":"Reference","AdministrableProductDefinition.routeOfAdministration":"BackboneElement","AdministrableProductDefinition.routeOfAdministration.code":"CodeableConcept","AdministrableProductDefinition.routeOfAdministration.extension":"Extension","AdministrableProductDefinition.routeOfAdministration.firstDose":"Quantity","AdministrableProductDefinition.routeOfAdministration.id":"System.String","AdministrableProductDefinition.routeOfAdministration.maxDosePerDay":"Quantity","AdministrableProductDefinition.routeOfAdministration.maxDosePerTreatmentPeriod":"Ratio","AdministrableProductDefinition.routeOfAdministration.maxSingleDose":"Quantity","AdministrableProductDefinition.routeOfAdministration.maxTreatmentPeriod":"Duration","AdministrableProductDefinition.routeOfAdministration.modifierExtension":"Extension","AdministrableProductDefinition.routeOfAdministration.targetSpecies":"BackboneElement","AdministrableProductDefinition.routeOfAdministration.targetSpecies.code":"CodeableConcept","AdministrableProductDefinition.routeOfAdministration.targetSpecies.extension":"Extension","AdministrableProductDefinition.routeOfAdministration.targetSpecies.id":"System.String","AdministrableProductDefinition.routeOfAdministration.targetSpecies.modifierExtension":"Extension","AdministrableProductDefinition.routeOfAdministration.targetSpecies.withdrawalPeriod":"BackboneElement","AdministrableProductDefinition.routeOfAdministration.targetSpecies.withdrawalPeriod.extension":"Extension","AdministrableProductDefinition.routeOfAdministration.targetSpecies.withdrawalPeriod.id":"System.String","AdministrableProductDefinition.routeOfAdministration.targetSpecies.withdrawalPeriod.modifierExtension":"Extension","AdministrableProductDefinition.routeOfAdministration.targetSpecies.withdrawalPeriod.supportingInformation":"string","AdministrableProductDefinition.routeOfAdministration.targetSpecies.withdrawalPeriod.tissue":"CodeableConcept","AdministrableProductDefinition.routeOfAdministration.targetSpecies.withdrawalPeriod.value":"Quantity","AdministrableProductDefinition.status":"code","AdministrableProductDefinition.text":"Narrative","AdministrableProductDefinition.unitOfPresentation":"CodeableConcept","AdverseEvent.actuality":"code","AdverseEvent.category":"CodeableConcept","AdverseEvent.code":"CodeableConcept","AdverseEvent.contained":"Resource","AdverseEvent.contributingFactor":"BackboneElement","AdverseEvent.contributingFactor.extension":"Extension","AdverseEvent.contributingFactor.id":"System.String","AdverseEvent.contributingFactor.itemCodeableConcept":"CodeableConcept","AdverseEvent.contributingFactor.itemReference":"Reference","AdverseEvent.contributingFactor.modifierExtension":"Extension","AdverseEvent.detected":"dateTime","AdverseEvent.encounter":"Reference","AdverseEvent.expectedInResearchStudy":"boolean","AdverseEvent.extension":"Extension","AdverseEvent.id":"System.String","AdverseEvent.identifier":"Identifier","AdverseEvent.implicitRules":"uri","AdverseEvent.language":"code","AdverseEvent.location":"Reference","AdverseEvent.meta":"Meta","AdverseEvent.mitigatingAction":"BackboneElement","AdverseEvent.mitigatingAction.extension":"Extension","AdverseEvent.mitigatingAction.id":"System.String","AdverseEvent.mitigatingAction.itemCodeableConcept":"CodeableConcept","AdverseEvent.mitigatingAction.itemReference":"Reference","AdverseEvent.mitigatingAction.modifierExtension":"Extension","AdverseEvent.modifierExtension":"Extension","AdverseEvent.note":"Annotation","AdverseEvent.occurrenceDateTime":"dateTime","AdverseEvent.occurrencePeriod":"Period","AdverseEvent.occurrenceTiming":"Timing","AdverseEvent.outcome":"CodeableConcept","AdverseEvent.participant":"BackboneElement","AdverseEvent.participant.actor":"Reference","AdverseEvent.participant.extension":"Extension","AdverseEvent.participant.function":"CodeableConcept","AdverseEvent.participant.id":"System.String","AdverseEvent.participant.modifierExtension":"Extension","AdverseEvent.preventiveAction":"BackboneElement","AdverseEvent.preventiveAction.extension":"Extension","AdverseEvent.preventiveAction.id":"System.String","AdverseEvent.preventiveAction.itemCodeableConcept":"CodeableConcept","AdverseEvent.preventiveAction.itemReference":"Reference","AdverseEvent.preventiveAction.modifierExtension":"Extension","AdverseEvent.recordedDate":"dateTime","AdverseEvent.recorder":"Reference","AdverseEvent.resultingEffect":"Reference","AdverseEvent.seriousness":"CodeableConcept","AdverseEvent.status":"code","AdverseEvent.study":"Reference","AdverseEvent.subject":"Reference","AdverseEvent.supportingInfo":"BackboneElement","AdverseEvent.supportingInfo.extension":"Extension","AdverseEvent.supportingInfo.id":"System.String","AdverseEvent.supportingInfo.itemCodeableConcept":"CodeableConcept","AdverseEvent.supportingInfo.itemReference":"Reference","AdverseEvent.supportingInfo.modifierExtension":"Extension","AdverseEvent.suspectEntity":"BackboneElement","AdverseEvent.suspectEntity.causality":"BackboneElement","AdverseEvent.suspectEntity.causality.assessmentMethod":"CodeableConcept","AdverseEvent.suspectEntity.causality.author":"Reference","AdverseEvent.suspectEntity.causality.entityRelatedness":"CodeableConcept","AdverseEvent.suspectEntity.causality.extension":"Extension","AdverseEvent.suspectEntity.causality.id":"System.String","AdverseEvent.suspectEntity.causality.modifierExtension":"Extension","AdverseEvent.suspectEntity.extension":"Extension","AdverseEvent.suspectEntity.id":"System.String","AdverseEvent.suspectEntity.instanceCodeableConcept":"CodeableConcept","AdverseEvent.suspectEntity.instanceReference":"Reference","AdverseEvent.suspectEntity.modifierExtension":"Extension","AdverseEvent.text":"Narrative","Age.code":"code","Age.comparator":"code","Age.extension":"Extension","Age.id":"System.String","Age.system":"uri","Age.unit":"string","Age.value":"decimal","AllergyIntolerance.category":"code","AllergyIntolerance.clinicalStatus":"CodeableConcept","AllergyIntolerance.code":"CodeableConcept","AllergyIntolerance.contained":"Resource","AllergyIntolerance.criticality":"code","AllergyIntolerance.encounter":"Reference","AllergyIntolerance.extension":"Extension","AllergyIntolerance.id":"System.String","AllergyIntolerance.identifier":"Identifier","AllergyIntolerance.implicitRules":"uri","AllergyIntolerance.language":"code","AllergyIntolerance.lastOccurrence":"dateTime","AllergyIntolerance.meta":"Meta","AllergyIntolerance.modifierExtension":"Extension","AllergyIntolerance.note":"Annotation","AllergyIntolerance.onsetAge":"Age","AllergyIntolerance.onsetDateTime":"dateTime","AllergyIntolerance.onsetPeriod":"Period","AllergyIntolerance.onsetRange":"Range","AllergyIntolerance.onsetString":"string","AllergyIntolerance.participant":"BackboneElement","AllergyIntolerance.participant.actor":"Reference","AllergyIntolerance.participant.extension":"Extension","AllergyIntolerance.participant.function":"CodeableConcept","AllergyIntolerance.participant.id":"System.String","AllergyIntolerance.participant.modifierExtension":"Extension","AllergyIntolerance.patient":"Reference","AllergyIntolerance.reaction":"BackboneElement","AllergyIntolerance.reaction.description":"string","AllergyIntolerance.reaction.exposureRoute":"CodeableConcept","AllergyIntolerance.reaction.extension":"Extension","AllergyIntolerance.reaction.id":"System.String","AllergyIntolerance.reaction.manifestation":"CodeableReference","AllergyIntolerance.reaction.modifierExtension":"Extension","AllergyIntolerance.reaction.note":"Annotation","AllergyIntolerance.reaction.onset":"dateTime","AllergyIntolerance.reaction.severity":"code","AllergyIntolerance.reaction.substance":"CodeableConcept","AllergyIntolerance.recordedDate":"dateTime","AllergyIntolerance.text":"Narrative","AllergyIntolerance.type":"CodeableConcept","AllergyIntolerance.verificationStatus":"CodeableConcept","Annotation.authorReference":"Reference","Annotation.authorString":"string","Annotation.extension":"Extension","Annotation.id":"System.String","Annotation.text":"markdown","Annotation.time":"dateTime","Appointment.account":"Reference","Appointment.appointmentType":"CodeableConcept","Appointment.basedOn":"Reference","Appointment.cancellationDate":"dateTime","Appointment.cancellationReason":"CodeableConcept","Appointment.class":"CodeableConcept","Appointment.contained":"Resource","Appointment.created":"dateTime","Appointment.description":"string","Appointment.end":"instant","Appointment.extension":"Extension","Appointment.id":"System.String","Appointment.identifier":"Identifier","Appointment.implicitRules":"uri","Appointment.language":"code","Appointment.meta":"Meta","Appointment.minutesDuration":"positiveInt","Appointment.modifierExtension":"Extension","Appointment.note":"Annotation","Appointment.occurrenceChanged":"boolean","Appointment.originatingAppointment":"Reference","Appointment.participant":"BackboneElement","Appointment.participant.actor":"Reference","Appointment.participant.extension":"Extension","Appointment.participant.id":"System.String","Appointment.participant.modifierExtension":"Extension","Appointment.participant.period":"Period","Appointment.participant.required":"boolean","Appointment.participant.status":"code","Appointment.participant.type":"CodeableConcept","Appointment.patientInstruction":"CodeableReference","Appointment.previousAppointment":"Reference","Appointment.priority":"CodeableConcept","Appointment.reason":"CodeableReference","Appointment.recurrenceId":"positiveInt","Appointment.recurrenceTemplate":"BackboneElement","Appointment.recurrenceTemplate.excludingDate":"date","Appointment.recurrenceTemplate.excludingRecurrenceId":"positiveInt","Appointment.recurrenceTemplate.extension":"Extension","Appointment.recurrenceTemplate.id":"System.String","Appointment.recurrenceTemplate.lastOccurrenceDate":"date","Appointment.recurrenceTemplate.modifierExtension":"Extension","Appointment.recurrenceTemplate.monthlyTemplate":"BackboneElement","Appointment.recurrenceTemplate.monthlyTemplate.dayOfMonth":"positiveInt","Appointment.recurrenceTemplate.monthlyTemplate.dayOfWeek":"Coding","Appointment.recurrenceTemplate.monthlyTemplate.extension":"Extension","Appointment.recurrenceTemplate.monthlyTemplate.id":"System.String","Appointment.recurrenceTemplate.monthlyTemplate.modifierExtension":"Extension","Appointment.recurrenceTemplate.monthlyTemplate.monthInterval":"positiveInt","Appointment.recurrenceTemplate.monthlyTemplate.nthWeekOfMonth":"Coding","Appointment.recurrenceTemplate.occurrenceCount":"positiveInt","Appointment.recurrenceTemplate.occurrenceDate":"date","Appointment.recurrenceTemplate.recurrenceType":"CodeableConcept","Appointment.recurrenceTemplate.timezone":"CodeableConcept","Appointment.recurrenceTemplate.weeklyTemplate":"BackboneElement","Appointment.recurrenceTemplate.weeklyTemplate.extension":"Extension","Appointment.recurrenceTemplate.weeklyTemplate.friday":"boolean","Appointment.recurrenceTemplate.weeklyTemplate.id":"System.String","Appointment.recurrenceTemplate.weeklyTemplate.modifierExtension":"Extension","Appointment.recurrenceTemplate.weeklyTemplate.monday":"boolean","Appointment.recurrenceTemplate.weeklyTemplate.saturday":"boolean","Appointment.recurrenceTemplate.weeklyTemplate.sunday":"boolean","Appointment.recurrenceTemplate.weeklyTemplate.thursday":"boolean","Appointment.recurrenceTemplate.weeklyTemplate.tuesday":"boolean","Appointment.recurrenceTemplate.weeklyTemplate.wednesday":"boolean","Appointment.recurrenceTemplate.weeklyTemplate.weekInterval":"positiveInt","Appointment.recurrenceTemplate.yearlyTemplate":"BackboneElement","Appointment.recurrenceTemplate.yearlyTemplate.extension":"Extension","Appointment.recurrenceTemplate.yearlyTemplate.id":"System.String","Appointment.recurrenceTemplate.yearlyTemplate.modifierExtension":"Extension","Appointment.recurrenceTemplate.yearlyTemplate.yearInterval":"positiveInt","Appointment.replaces":"Reference","Appointment.requestedPeriod":"Period","Appointment.serviceCategory":"CodeableConcept","Appointment.serviceType":"CodeableReference","Appointment.slot":"Reference","Appointment.specialty":"CodeableConcept","Appointment.start":"instant","Appointment.status":"code","Appointment.subject":"Reference","Appointment.supportingInformation":"Reference","Appointment.text":"Narrative","Appointment.virtualService":"VirtualServiceDetail","AppointmentResponse.actor":"Reference","AppointmentResponse.appointment":"Reference","AppointmentResponse.comment":"markdown","AppointmentResponse.contained":"Resource","AppointmentResponse.end":"instant","AppointmentResponse.extension":"Extension","AppointmentResponse.id":"System.String","AppointmentResponse.identifier":"Identifier","AppointmentResponse.implicitRules":"uri","AppointmentResponse.language":"code","AppointmentResponse.meta":"Meta","AppointmentResponse.modifierExtension":"Extension","AppointmentResponse.occurrenceDate":"date","AppointmentResponse.participantStatus":"code","AppointmentResponse.participantType":"CodeableConcept","AppointmentResponse.proposedNewTime":"boolean","AppointmentResponse.recurrenceId":"positiveInt","AppointmentResponse.recurring":"boolean","AppointmentResponse.start":"instant","AppointmentResponse.text":"Narrative","ArtifactAssessment.approvalDate":"date","ArtifactAssessment.artifactCanonical":"canonical","ArtifactAssessment.artifactReference":"Reference","ArtifactAssessment.artifactUri":"uri","ArtifactAssessment.citeAsMarkdown":"markdown","ArtifactAssessment.citeAsReference":"Reference","ArtifactAssessment.contained":"Resource","ArtifactAssessment.content":"BackboneElement","ArtifactAssessment.content.author":"Reference","ArtifactAssessment.content.classifier":"CodeableConcept","ArtifactAssessment.content.extension":"Extension","ArtifactAssessment.content.freeToShare":"boolean","ArtifactAssessment.content.id":"System.String","ArtifactAssessment.content.informationType":"code","ArtifactAssessment.content.modifierExtension":"Extension","ArtifactAssessment.content.path":"uri","ArtifactAssessment.content.quantity":"Quantity","ArtifactAssessment.content.relatedArtifact":"RelatedArtifact","ArtifactAssessment.content.summary":"markdown","ArtifactAssessment.content.type":"CodeableConcept","ArtifactAssessment.copyright":"markdown","ArtifactAssessment.date":"dateTime","ArtifactAssessment.disposition":"code","ArtifactAssessment.extension":"Extension","ArtifactAssessment.id":"System.String","ArtifactAssessment.identifier":"Identifier","ArtifactAssessment.implicitRules":"uri","ArtifactAssessment.language":"code","ArtifactAssessment.lastReviewDate":"date","ArtifactAssessment.meta":"Meta","ArtifactAssessment.modifierExtension":"Extension","ArtifactAssessment.text":"Narrative","ArtifactAssessment.title":"string","ArtifactAssessment.workflowStatus":"code","Attachment.contentType":"code","Attachment.creation":"dateTime","Attachment.data":"base64Binary","Attachment.duration":"decimal","Attachment.extension":"Extension","Attachment.frames":"positiveInt","Attachment.hash":"base64Binary","Attachment.height":"positiveInt","Attachment.id":"System.String","Attachment.language":"code","Attachment.pages":"positiveInt","Attachment.size":"integer64","Attachment.title":"string","Attachment.url":"url","Attachment.width":"positiveInt","AuditEvent.action":"code","AuditEvent.agent":"BackboneElement","AuditEvent.agent.authorization":"CodeableConcept","AuditEvent.agent.extension":"Extension","AuditEvent.agent.id":"System.String","AuditEvent.agent.location":"Reference","AuditEvent.agent.modifierExtension":"Extension","AuditEvent.agent.networkReference":"Reference","AuditEvent.agent.networkString":"string","AuditEvent.agent.networkUri":"uri","AuditEvent.agent.policy":"uri","AuditEvent.agent.requestor":"boolean","AuditEvent.agent.role":"CodeableConcept","AuditEvent.agent.type":"CodeableConcept","AuditEvent.agent.who":"Reference","AuditEvent.authorization":"CodeableConcept","AuditEvent.basedOn":"Reference","AuditEvent.category":"CodeableConcept","AuditEvent.code":"CodeableConcept","AuditEvent.contained":"Resource","AuditEvent.encounter":"Reference","AuditEvent.entity":"BackboneElement","AuditEvent.entity.detail":"BackboneElement","AuditEvent.entity.detail.extension":"Extension","AuditEvent.entity.detail.id":"System.String","AuditEvent.entity.detail.modifierExtension":"Extension","AuditEvent.entity.detail.type":"CodeableConcept","AuditEvent.entity.detail.valueBase64Binary":"base64Binary","AuditEvent.entity.detail.valueBoolean":"boolean","AuditEvent.entity.detail.valueCodeableConcept":"CodeableConcept","AuditEvent.entity.detail.valueDateTime":"dateTime","AuditEvent.entity.detail.valueInteger":"integer","AuditEvent.entity.detail.valuePeriod":"Period","AuditEvent.entity.detail.valueQuantity":"Quantity","AuditEvent.entity.detail.valueRange":"Range","AuditEvent.entity.detail.valueRatio":"Ratio","AuditEvent.entity.detail.valueString":"string","AuditEvent.entity.detail.valueTime":"time","AuditEvent.entity.extension":"Extension","AuditEvent.entity.id":"System.String","AuditEvent.entity.modifierExtension":"Extension","AuditEvent.entity.query":"base64Binary","AuditEvent.entity.role":"CodeableConcept","AuditEvent.entity.securityLabel":"CodeableConcept","AuditEvent.entity.what":"Reference","AuditEvent.extension":"Extension","AuditEvent.id":"System.String","AuditEvent.implicitRules":"uri","AuditEvent.language":"code","AuditEvent.meta":"Meta","AuditEvent.modifierExtension":"Extension","AuditEvent.occurredDateTime":"dateTime","AuditEvent.occurredPeriod":"Period","AuditEvent.outcome":"BackboneElement","AuditEvent.outcome.code":"Coding","AuditEvent.outcome.detail":"CodeableConcept","AuditEvent.outcome.extension":"Extension","AuditEvent.outcome.id":"System.String","AuditEvent.outcome.modifierExtension":"Extension","AuditEvent.patient":"Reference","AuditEvent.recorded":"instant","AuditEvent.severity":"code","AuditEvent.source":"BackboneElement","AuditEvent.source.extension":"Extension","AuditEvent.source.id":"System.String","AuditEvent.source.modifierExtension":"Extension","AuditEvent.source.observer":"Reference","AuditEvent.source.site":"Reference","AuditEvent.source.type":"CodeableConcept","AuditEvent.text":"Narrative","Availability.availableTime":"Element","Availability.availableTime.allDay":"boolean","Availability.availableTime.availableEndTime":"time","Availability.availableTime.availableStartTime":"time","Availability.availableTime.daysOfWeek":"code","Availability.availableTime.extension":"Extension","Availability.availableTime.id":"System.String","Availability.extension":"Extension","Availability.id":"System.String","Availability.notAvailableTime":"Element","Availability.notAvailableTime.description":"string","Availability.notAvailableTime.during":"Period","Availability.notAvailableTime.extension":"Extension","Availability.notAvailableTime.id":"System.String","BackboneElement.extension":"Extension","BackboneElement.id":"System.String","BackboneElement.modifierExtension":"Extension","BackboneType.extension":"Extension","BackboneType.id":"System.String","BackboneType.modifierExtension":"Extension","Basic.author":"Reference","Basic.code":"CodeableConcept","Basic.contained":"Resource","Basic.created":"dateTime","Basic.extension":"Extension","Basic.id":"System.String","Basic.identifier":"Identifier","Basic.implicitRules":"uri","Basic.language":"code","Basic.meta":"Meta","Basic.modifierExtension":"Extension","Basic.subject":"Reference","Basic.text":"Narrative","Binary.contentType":"code","Binary.data":"base64Binary","Binary.id":"System.String","Binary.implicitRules":"uri","Binary.language":"code","Binary.meta":"Meta","Binary.securityContext":"Reference","BiologicallyDerivedProduct.biologicalSourceEvent":"Identifier","BiologicallyDerivedProduct.collection":"BackboneElement","BiologicallyDerivedProduct.collection.collectedDateTime":"dateTime","BiologicallyDerivedProduct.collection.collectedPeriod":"Period","BiologicallyDerivedProduct.collection.collector":"Reference","BiologicallyDerivedProduct.collection.extension":"Extension","BiologicallyDerivedProduct.collection.id":"System.String","BiologicallyDerivedProduct.collection.modifierExtension":"Extension","BiologicallyDerivedProduct.collection.source":"Reference","BiologicallyDerivedProduct.contained":"Resource","BiologicallyDerivedProduct.division":"string","BiologicallyDerivedProduct.expirationDate":"dateTime","BiologicallyDerivedProduct.extension":"Extension","BiologicallyDerivedProduct.id":"System.String","BiologicallyDerivedProduct.identifier":"Identifier","BiologicallyDerivedProduct.implicitRules":"uri","BiologicallyDerivedProduct.language":"code","BiologicallyDerivedProduct.meta":"Meta","BiologicallyDerivedProduct.modifierExtension":"Extension","BiologicallyDerivedProduct.parent":"Reference","BiologicallyDerivedProduct.processingFacility":"Reference","BiologicallyDerivedProduct.productCategory":"Coding","BiologicallyDerivedProduct.productCode":"CodeableConcept","BiologicallyDerivedProduct.productStatus":"Coding","BiologicallyDerivedProduct.property":"BackboneElement","BiologicallyDerivedProduct.property.extension":"Extension","BiologicallyDerivedProduct.property.id":"System.String","BiologicallyDerivedProduct.property.modifierExtension":"Extension","BiologicallyDerivedProduct.property.type":"CodeableConcept","BiologicallyDerivedProduct.property.valueAttachment":"Attachment","BiologicallyDerivedProduct.property.valueBoolean":"boolean","BiologicallyDerivedProduct.property.valueCodeableConcept":"CodeableConcept","BiologicallyDerivedProduct.property.valueInteger":"integer","BiologicallyDerivedProduct.property.valuePeriod":"Period","BiologicallyDerivedProduct.property.valueQuantity":"Quantity","BiologicallyDerivedProduct.property.valueRange":"Range","BiologicallyDerivedProduct.property.valueRatio":"Ratio","BiologicallyDerivedProduct.property.valueString":"string","BiologicallyDerivedProduct.request":"Reference","BiologicallyDerivedProduct.storageTempRequirements":"Range","BiologicallyDerivedProduct.text":"Narrative","BiologicallyDerivedProductDispense.basedOn":"Reference","BiologicallyDerivedProductDispense.contained":"Resource","BiologicallyDerivedProductDispense.destination":"Reference","BiologicallyDerivedProductDispense.extension":"Extension","BiologicallyDerivedProductDispense.id":"System.String","BiologicallyDerivedProductDispense.identifier":"Identifier","BiologicallyDerivedProductDispense.implicitRules":"uri","BiologicallyDerivedProductDispense.language":"code","BiologicallyDerivedProductDispense.location":"Reference","BiologicallyDerivedProductDispense.matchStatus":"CodeableConcept","BiologicallyDerivedProductDispense.meta":"Meta","BiologicallyDerivedProductDispense.modifierExtension":"Extension","BiologicallyDerivedProductDispense.note":"Annotation","BiologicallyDerivedProductDispense.originRelationshipType":"CodeableConcept","BiologicallyDerivedProductDispense.partOf":"Reference","BiologicallyDerivedProductDispense.patient":"Reference","BiologicallyDerivedProductDispense.performer":"BackboneElement","BiologicallyDerivedProductDispense.performer.actor":"Reference","BiologicallyDerivedProductDispense.performer.extension":"Extension","BiologicallyDerivedProductDispense.performer.function":"CodeableConcept","BiologicallyDerivedProductDispense.performer.id":"System.String","BiologicallyDerivedProductDispense.performer.modifierExtension":"Extension","BiologicallyDerivedProductDispense.preparedDate":"dateTime","BiologicallyDerivedProductDispense.product":"Reference","BiologicallyDerivedProductDispense.quantity":"Quantity","BiologicallyDerivedProductDispense.status":"code","BiologicallyDerivedProductDispense.text":"Narrative","BiologicallyDerivedProductDispense.usageInstruction":"string","BiologicallyDerivedProductDispense.whenHandedOver":"dateTime","BodyStructure.active":"boolean","BodyStructure.contained":"Resource","BodyStructure.description":"markdown","BodyStructure.extension":"Extension","BodyStructure.id":"System.String","BodyStructure.identifier":"Identifier","BodyStructure.image":"Attachment","BodyStructure.implicitRules":"uri","BodyStructure.includedStructure":"BackboneElement","BodyStructure.includedStructure.bodyLandmarkOrientation":"BackboneElement","BodyStructure.includedStructure.bodyLandmarkOrientation.clockFacePosition":"CodeableConcept","BodyStructure.includedStructure.bodyLandmarkOrientation.distanceFromLandmark":"BackboneElement","BodyStructure.includedStructure.bodyLandmarkOrientation.distanceFromLandmark.device":"CodeableReference","BodyStructure.includedStructure.bodyLandmarkOrientation.distanceFromLandmark.extension":"Extension","BodyStructure.includedStructure.bodyLandmarkOrientation.distanceFromLandmark.id":"System.String","BodyStructure.includedStructure.bodyLandmarkOrientation.distanceFromLandmark.modifierExtension":"Extension","BodyStructure.includedStructure.bodyLandmarkOrientation.distanceFromLandmark.value":"Quantity","BodyStructure.includedStructure.bodyLandmarkOrientation.extension":"Extension","BodyStructure.includedStructure.bodyLandmarkOrientation.id":"System.String","BodyStructure.includedStructure.bodyLandmarkOrientation.landmarkDescription":"CodeableConcept","BodyStructure.includedStructure.bodyLandmarkOrientation.modifierExtension":"Extension","BodyStructure.includedStructure.bodyLandmarkOrientation.surfaceOrientation":"CodeableConcept","BodyStructure.includedStructure.extension":"Extension","BodyStructure.includedStructure.id":"System.String","BodyStructure.includedStructure.laterality":"CodeableConcept","BodyStructure.includedStructure.modifierExtension":"Extension","BodyStructure.includedStructure.qualifier":"CodeableConcept","BodyStructure.includedStructure.spatialReference":"Reference","BodyStructure.includedStructure.structure":"CodeableConcept","BodyStructure.language":"code","BodyStructure.meta":"Meta","BodyStructure.modifierExtension":"Extension","BodyStructure.morphology":"CodeableConcept","BodyStructure.patient":"Reference","BodyStructure.text":"Narrative","Bundle.entry":"BackboneElement","Bundle.entry.extension":"Extension","Bundle.entry.fullUrl":"uri","Bundle.entry.id":"System.String","Bundle.entry.modifierExtension":"Extension","Bundle.entry.request":"BackboneElement","Bundle.entry.request.extension":"Extension","Bundle.entry.request.id":"System.String","Bundle.entry.request.ifMatch":"string","Bundle.entry.request.ifModifiedSince":"instant","Bundle.entry.request.ifNoneExist":"string","Bundle.entry.request.ifNoneMatch":"string","Bundle.entry.request.method":"code","Bundle.entry.request.modifierExtension":"Extension","Bundle.entry.request.url":"uri","Bundle.entry.resource":"Resource","Bundle.entry.response":"BackboneElement","Bundle.entry.response.etag":"string","Bundle.entry.response.extension":"Extension","Bundle.entry.response.id":"System.String","Bundle.entry.response.lastModified":"instant","Bundle.entry.response.location":"uri","Bundle.entry.response.modifierExtension":"Extension","Bundle.entry.response.outcome":"Resource","Bundle.entry.response.status":"string","Bundle.entry.search":"BackboneElement","Bundle.entry.search.extension":"Extension","Bundle.entry.search.id":"System.String","Bundle.entry.search.mode":"code","Bundle.entry.search.modifierExtension":"Extension","Bundle.entry.search.score":"decimal","Bundle.id":"System.String","Bundle.identifier":"Identifier","Bundle.implicitRules":"uri","Bundle.issues":"Resource","Bundle.language":"code","Bundle.link":"BackboneElement","Bundle.link.extension":"Extension","Bundle.link.id":"System.String","Bundle.link.modifierExtension":"Extension","Bundle.link.relation":"code","Bundle.link.url":"uri","Bundle.meta":"Meta","Bundle.signature":"Signature","Bundle.timestamp":"instant","Bundle.total":"unsignedInt","Bundle.type":"code","CanonicalResource.contact":"ContactDetail","CanonicalResource.contained":"Resource","CanonicalResource.copyright":"markdown","CanonicalResource.copyrightLabel":"string","CanonicalResource.date":"dateTime","CanonicalResource.description":"markdown","CanonicalResource.experimental":"boolean","CanonicalResource.extension":"Extension","CanonicalResource.id":"System.String","CanonicalResource.identifier":"Identifier","CanonicalResource.implicitRules":"uri","CanonicalResource.jurisdiction":"CodeableConcept","CanonicalResource.language":"code","CanonicalResource.meta":"Meta","CanonicalResource.modifierExtension":"Extension","CanonicalResource.name":"string","CanonicalResource.publisher":"string","CanonicalResource.purpose":"markdown","CanonicalResource.status":"code","CanonicalResource.text":"Narrative","CanonicalResource.title":"string","CanonicalResource.url":"uri","CanonicalResource.useContext":"UsageContext","CanonicalResource.version":"string","CanonicalResource.versionAlgorithmCoding":"Coding","CanonicalResource.versionAlgorithmString":"string","CapabilityStatement.acceptLanguage":"code","CapabilityStatement.contact":"ContactDetail","CapabilityStatement.contained":"Resource","CapabilityStatement.copyright":"markdown","CapabilityStatement.copyrightLabel":"string","CapabilityStatement.date":"dateTime","CapabilityStatement.description":"markdown","CapabilityStatement.document":"BackboneElement","CapabilityStatement.document.documentation":"markdown","CapabilityStatement.document.extension":"Extension","CapabilityStatement.document.id":"System.String","CapabilityStatement.document.mode":"code","CapabilityStatement.document.modifierExtension":"Extension","CapabilityStatement.document.profile":"canonical","CapabilityStatement.experimental":"boolean","CapabilityStatement.extension":"Extension","CapabilityStatement.fhirVersion":"code","CapabilityStatement.format":"code","CapabilityStatement.id":"System.String","CapabilityStatement.identifier":"Identifier","CapabilityStatement.implementation":"BackboneElement","CapabilityStatement.implementation.custodian":"Reference","CapabilityStatement.implementation.description":"markdown","CapabilityStatement.implementation.extension":"Extension","CapabilityStatement.implementation.id":"System.String","CapabilityStatement.implementation.modifierExtension":"Extension","CapabilityStatement.implementation.url":"url","CapabilityStatement.implementationGuide":"canonical","CapabilityStatement.implicitRules":"uri","CapabilityStatement.imports":"canonical","CapabilityStatement.instantiates":"canonical","CapabilityStatement.jurisdiction":"CodeableConcept","CapabilityStatement.kind":"code","CapabilityStatement.language":"code","CapabilityStatement.messaging":"BackboneElement","CapabilityStatement.messaging.documentation":"markdown","CapabilityStatement.messaging.endpoint":"BackboneElement","CapabilityStatement.messaging.endpoint.address":"url","CapabilityStatement.messaging.endpoint.extension":"Extension","CapabilityStatement.messaging.endpoint.id":"System.String","CapabilityStatement.messaging.endpoint.modifierExtension":"Extension","CapabilityStatement.messaging.endpoint.protocol":"Coding","CapabilityStatement.messaging.extension":"Extension","CapabilityStatement.messaging.id":"System.String","CapabilityStatement.messaging.modifierExtension":"Extension","CapabilityStatement.messaging.reliableCache":"unsignedInt","CapabilityStatement.messaging.supportedMessage":"BackboneElement","CapabilityStatement.messaging.supportedMessage.definition":"canonical","CapabilityStatement.messaging.supportedMessage.extension":"Extension","CapabilityStatement.messaging.supportedMessage.id":"System.String","CapabilityStatement.messaging.supportedMessage.mode":"code","CapabilityStatement.messaging.supportedMessage.modifierExtension":"Extension","CapabilityStatement.meta":"Meta","CapabilityStatement.modifierExtension":"Extension","CapabilityStatement.name":"string","CapabilityStatement.patchFormat":"code","CapabilityStatement.publisher":"string","CapabilityStatement.purpose":"markdown","CapabilityStatement.rest":"BackboneElement","CapabilityStatement.rest.compartment":"canonical","CapabilityStatement.rest.documentation":"markdown","CapabilityStatement.rest.extension":"Extension","CapabilityStatement.rest.id":"System.String","CapabilityStatement.rest.interaction":"BackboneElement","CapabilityStatement.rest.interaction.code":"code","CapabilityStatement.rest.interaction.documentation":"markdown","CapabilityStatement.rest.interaction.extension":"Extension","CapabilityStatement.rest.interaction.id":"System.String","CapabilityStatement.rest.interaction.modifierExtension":"Extension","CapabilityStatement.rest.mode":"code","CapabilityStatement.rest.modifierExtension":"Extension","CapabilityStatement.rest.resource":"BackboneElement","CapabilityStatement.rest.resource.conditionalCreate":"boolean","CapabilityStatement.rest.resource.conditionalDelete":"code","CapabilityStatement.rest.resource.conditionalPatch":"boolean","CapabilityStatement.rest.resource.conditionalRead":"code","CapabilityStatement.rest.resource.conditionalUpdate":"boolean","CapabilityStatement.rest.resource.documentation":"markdown","CapabilityStatement.rest.resource.extension":"Extension","CapabilityStatement.rest.resource.id":"System.String","CapabilityStatement.rest.resource.interaction":"BackboneElement","CapabilityStatement.rest.resource.interaction.code":"code","CapabilityStatement.rest.resource.interaction.documentation":"markdown","CapabilityStatement.rest.resource.interaction.extension":"Extension","CapabilityStatement.rest.resource.interaction.id":"System.String","CapabilityStatement.rest.resource.interaction.modifierExtension":"Extension","CapabilityStatement.rest.resource.modifierExtension":"Extension","CapabilityStatement.rest.resource.operation":"BackboneElement","CapabilityStatement.rest.resource.operation.definition":"canonical","CapabilityStatement.rest.resource.operation.documentation":"markdown","CapabilityStatement.rest.resource.operation.extension":"Extension","CapabilityStatement.rest.resource.operation.id":"System.String","CapabilityStatement.rest.resource.operation.modifierExtension":"Extension","CapabilityStatement.rest.resource.operation.name":"string","CapabilityStatement.rest.resource.profile":"canonical","CapabilityStatement.rest.resource.readHistory":"boolean","CapabilityStatement.rest.resource.referencePolicy":"code","CapabilityStatement.rest.resource.searchInclude":"string","CapabilityStatement.rest.resource.searchParam":"BackboneElement","CapabilityStatement.rest.resource.searchParam.definition":"canonical","CapabilityStatement.rest.resource.searchParam.documentation":"markdown","CapabilityStatement.rest.resource.searchParam.extension":"Extension","CapabilityStatement.rest.resource.searchParam.id":"System.String","CapabilityStatement.rest.resource.searchParam.modifierExtension":"Extension","CapabilityStatement.rest.resource.searchParam.name":"string","CapabilityStatement.rest.resource.searchParam.type":"code","CapabilityStatement.rest.resource.searchRevInclude":"string","CapabilityStatement.rest.resource.supportedProfile":"canonical","CapabilityStatement.rest.resource.type":"code","CapabilityStatement.rest.resource.updateCreate":"boolean","CapabilityStatement.rest.resource.versioning":"code","CapabilityStatement.rest.security":"BackboneElement","CapabilityStatement.rest.security.cors":"boolean","CapabilityStatement.rest.security.description":"markdown","CapabilityStatement.rest.security.extension":"Extension","CapabilityStatement.rest.security.id":"System.String","CapabilityStatement.rest.security.modifierExtension":"Extension","CapabilityStatement.rest.security.service":"CodeableConcept","CapabilityStatement.software":"BackboneElement","CapabilityStatement.software.extension":"Extension","CapabilityStatement.software.id":"System.String","CapabilityStatement.software.modifierExtension":"Extension","CapabilityStatement.software.name":"string","CapabilityStatement.software.releaseDate":"dateTime","CapabilityStatement.software.version":"string","CapabilityStatement.status":"code","CapabilityStatement.text":"Narrative","CapabilityStatement.title":"string","CapabilityStatement.url":"uri","CapabilityStatement.useContext":"UsageContext","CapabilityStatement.version":"string","CapabilityStatement.versionAlgorithmCoding":"Coding","CapabilityStatement.versionAlgorithmString":"string","CarePlan.activity":"BackboneElement","CarePlan.activity.extension":"Extension","CarePlan.activity.id":"System.String","CarePlan.activity.modifierExtension":"Extension","CarePlan.activity.performedActivity":"CodeableReference","CarePlan.activity.plannedActivityReference":"Reference","CarePlan.activity.progress":"Annotation","CarePlan.addresses":"CodeableReference","CarePlan.basedOn":"Reference","CarePlan.careTeam":"Reference","CarePlan.category":"CodeableConcept","CarePlan.contained":"Resource","CarePlan.contributor":"Reference","CarePlan.created":"dateTime","CarePlan.custodian":"Reference","CarePlan.description":"string","CarePlan.encounter":"Reference","CarePlan.extension":"Extension","CarePlan.goal":"Reference","CarePlan.id":"System.String","CarePlan.identifier":"Identifier","CarePlan.implicitRules":"uri","CarePlan.instantiatesCanonical":"canonical","CarePlan.instantiatesUri":"uri","CarePlan.intent":"code","CarePlan.language":"code","CarePlan.meta":"Meta","CarePlan.modifierExtension":"Extension","CarePlan.note":"Annotation","CarePlan.partOf":"Reference","CarePlan.period":"Period","CarePlan.replaces":"Reference","CarePlan.status":"code","CarePlan.subject":"Reference","CarePlan.supportingInfo":"Reference","CarePlan.text":"Narrative","CarePlan.title":"string","CareTeam.category":"CodeableConcept","CareTeam.contained":"Resource","CareTeam.extension":"Extension","CareTeam.id":"System.String","CareTeam.identifier":"Identifier","CareTeam.implicitRules":"uri","CareTeam.language":"code","CareTeam.managingOrganization":"Reference","CareTeam.meta":"Meta","CareTeam.modifierExtension":"Extension","CareTeam.name":"string","CareTeam.note":"Annotation","CareTeam.participant":"BackboneElement","CareTeam.participant.coveragePeriod":"Period","CareTeam.participant.coverageTiming":"Timing","CareTeam.participant.extension":"Extension","CareTeam.participant.id":"System.String","CareTeam.participant.member":"Reference","CareTeam.participant.modifierExtension":"Extension","CareTeam.participant.onBehalfOf":"Reference","CareTeam.participant.role":"CodeableConcept","CareTeam.period":"Period","CareTeam.reason":"CodeableReference","CareTeam.status":"code","CareTeam.subject":"Reference","CareTeam.telecom":"ContactPoint","CareTeam.text":"Narrative","ChargeItem.account":"Reference","ChargeItem.bodysite":"CodeableConcept","ChargeItem.code":"CodeableConcept","ChargeItem.contained":"Resource","ChargeItem.costCenter":"Reference","ChargeItem.definitionCanonical":"canonical","ChargeItem.definitionUri":"uri","ChargeItem.encounter":"Reference","ChargeItem.enteredDate":"dateTime","ChargeItem.enterer":"Reference","ChargeItem.extension":"Extension","ChargeItem.id":"System.String","ChargeItem.identifier":"Identifier","ChargeItem.implicitRules":"uri","ChargeItem.language":"code","ChargeItem.meta":"Meta","ChargeItem.modifierExtension":"Extension","ChargeItem.note":"Annotation","ChargeItem.occurrenceDateTime":"dateTime","ChargeItem.occurrencePeriod":"Period","ChargeItem.occurrenceTiming":"Timing","ChargeItem.overrideReason":"CodeableConcept","ChargeItem.partOf":"Reference","ChargeItem.performer":"BackboneElement","ChargeItem.performer.actor":"Reference","ChargeItem.performer.extension":"Extension","ChargeItem.performer.function":"CodeableConcept","ChargeItem.performer.id":"System.String","ChargeItem.performer.modifierExtension":"Extension","ChargeItem.performingOrganization":"Reference","ChargeItem.product":"CodeableReference","ChargeItem.quantity":"Quantity","ChargeItem.reason":"CodeableConcept","ChargeItem.requestingOrganization":"Reference","ChargeItem.service":"CodeableReference","ChargeItem.status":"code","ChargeItem.subject":"Reference","ChargeItem.supportingInformation":"Reference","ChargeItem.text":"Narrative","ChargeItem.totalPriceComponent":"MonetaryComponent","ChargeItem.unitPriceComponent":"MonetaryComponent","ChargeItemDefinition.applicability":"BackboneElement","ChargeItemDefinition.applicability.condition":"Expression","ChargeItemDefinition.applicability.effectivePeriod":"Period","ChargeItemDefinition.applicability.extension":"Extension","ChargeItemDefinition.applicability.id":"System.String","ChargeItemDefinition.applicability.modifierExtension":"Extension","ChargeItemDefinition.applicability.relatedArtifact":"RelatedArtifact","ChargeItemDefinition.approvalDate":"date","ChargeItemDefinition.code":"CodeableConcept","ChargeItemDefinition.contact":"ContactDetail","ChargeItemDefinition.contained":"Resource","ChargeItemDefinition.copyright":"markdown","ChargeItemDefinition.copyrightLabel":"string","ChargeItemDefinition.date":"dateTime","ChargeItemDefinition.derivedFromUri":"uri","ChargeItemDefinition.description":"markdown","ChargeItemDefinition.experimental":"boolean","ChargeItemDefinition.extension":"Extension","ChargeItemDefinition.id":"System.String","ChargeItemDefinition.identifier":"Identifier","ChargeItemDefinition.implicitRules":"uri","ChargeItemDefinition.instance":"Reference","ChargeItemDefinition.jurisdiction":"CodeableConcept","ChargeItemDefinition.language":"code","ChargeItemDefinition.lastReviewDate":"date","ChargeItemDefinition.meta":"Meta","ChargeItemDefinition.modifierExtension":"Extension","ChargeItemDefinition.name":"string","ChargeItemDefinition.partOf":"canonical","ChargeItemDefinition.propertyGroup":"BackboneElement","ChargeItemDefinition.propertyGroup.extension":"Extension","ChargeItemDefinition.propertyGroup.id":"System.String","ChargeItemDefinition.propertyGroup.modifierExtension":"Extension","ChargeItemDefinition.propertyGroup.priceComponent":"MonetaryComponent","ChargeItemDefinition.publisher":"string","ChargeItemDefinition.purpose":"markdown","ChargeItemDefinition.replaces":"canonical","ChargeItemDefinition.status":"code","ChargeItemDefinition.text":"Narrative","ChargeItemDefinition.title":"string","ChargeItemDefinition.url":"uri","ChargeItemDefinition.useContext":"UsageContext","ChargeItemDefinition.version":"string","ChargeItemDefinition.versionAlgorithmCoding":"Coding","ChargeItemDefinition.versionAlgorithmString":"string","Citation.approvalDate":"date","Citation.author":"ContactDetail","Citation.citedArtifact":"BackboneElement","Citation.citedArtifact.abstract":"BackboneElement","Citation.citedArtifact.abstract.copyright":"markdown","Citation.citedArtifact.abstract.extension":"Extension","Citation.citedArtifact.abstract.id":"System.String","Citation.citedArtifact.abstract.language":"CodeableConcept","Citation.citedArtifact.abstract.modifierExtension":"Extension","Citation.citedArtifact.abstract.text":"markdown","Citation.citedArtifact.abstract.type":"CodeableConcept","Citation.citedArtifact.classification":"BackboneElement","Citation.citedArtifact.classification.artifactAssessment":"Reference","Citation.citedArtifact.classification.classifier":"CodeableConcept","Citation.citedArtifact.classification.extension":"Extension","Citation.citedArtifact.classification.id":"System.String","Citation.citedArtifact.classification.modifierExtension":"Extension","Citation.citedArtifact.classification.type":"CodeableConcept","Citation.citedArtifact.contributorship":"BackboneElement","Citation.citedArtifact.contributorship.complete":"boolean","Citation.citedArtifact.contributorship.entry":"BackboneElement","Citation.citedArtifact.contributorship.entry.affiliation":"Reference","Citation.citedArtifact.contributorship.entry.contributionInstance":"BackboneElement","Citation.citedArtifact.contributorship.entry.contributionInstance.extension":"Extension","Citation.citedArtifact.contributorship.entry.contributionInstance.id":"System.String","Citation.citedArtifact.contributorship.entry.contributionInstance.modifierExtension":"Extension","Citation.citedArtifact.contributorship.entry.contributionInstance.time":"dateTime","Citation.citedArtifact.contributorship.entry.contributionInstance.type":"CodeableConcept","Citation.citedArtifact.contributorship.entry.contributionType":"CodeableConcept","Citation.citedArtifact.contributorship.entry.contributor":"Reference","Citation.citedArtifact.contributorship.entry.correspondingContact":"boolean","Citation.citedArtifact.contributorship.entry.extension":"Extension","Citation.citedArtifact.contributorship.entry.forenameInitials":"string","Citation.citedArtifact.contributorship.entry.id":"System.String","Citation.citedArtifact.contributorship.entry.modifierExtension":"Extension","Citation.citedArtifact.contributorship.entry.rankingOrder":"positiveInt","Citation.citedArtifact.contributorship.entry.role":"CodeableConcept","Citation.citedArtifact.contributorship.extension":"Extension","Citation.citedArtifact.contributorship.id":"System.String","Citation.citedArtifact.contributorship.modifierExtension":"Extension","Citation.citedArtifact.contributorship.summary":"BackboneElement","Citation.citedArtifact.contributorship.summary.extension":"Extension","Citation.citedArtifact.contributorship.summary.id":"System.String","Citation.citedArtifact.contributorship.summary.modifierExtension":"Extension","Citation.citedArtifact.contributorship.summary.source":"CodeableConcept","Citation.citedArtifact.contributorship.summary.style":"CodeableConcept","Citation.citedArtifact.contributorship.summary.type":"CodeableConcept","Citation.citedArtifact.contributorship.summary.value":"markdown","Citation.citedArtifact.currentState":"CodeableConcept","Citation.citedArtifact.dateAccessed":"dateTime","Citation.citedArtifact.extension":"Extension","Citation.citedArtifact.id":"System.String","Citation.citedArtifact.identifier":"Identifier","Citation.citedArtifact.modifierExtension":"Extension","Citation.citedArtifact.note":"Annotation","Citation.citedArtifact.part":"BackboneElement","Citation.citedArtifact.part.baseCitation":"Reference","Citation.citedArtifact.part.extension":"Extension","Citation.citedArtifact.part.id":"System.String","Citation.citedArtifact.part.modifierExtension":"Extension","Citation.citedArtifact.part.type":"CodeableConcept","Citation.citedArtifact.part.value":"string","Citation.citedArtifact.publicationForm":"BackboneElement","Citation.citedArtifact.publicationForm.accessionNumber":"string","Citation.citedArtifact.publicationForm.articleDate":"dateTime","Citation.citedArtifact.publicationForm.citedMedium":"CodeableConcept","Citation.citedArtifact.publicationForm.copyright":"markdown","Citation.citedArtifact.publicationForm.extension":"Extension","Citation.citedArtifact.publicationForm.firstPage":"string","Citation.citedArtifact.publicationForm.id":"System.String","Citation.citedArtifact.publicationForm.issue":"string","Citation.citedArtifact.publicationForm.language":"CodeableConcept","Citation.citedArtifact.publicationForm.lastPage":"string","Citation.citedArtifact.publicationForm.lastRevisionDate":"dateTime","Citation.citedArtifact.publicationForm.modifierExtension":"Extension","Citation.citedArtifact.publicationForm.pageCount":"string","Citation.citedArtifact.publicationForm.pageString":"string","Citation.citedArtifact.publicationForm.publicationDateSeason":"string","Citation.citedArtifact.publicationForm.publicationDateText":"string","Citation.citedArtifact.publicationForm.publishedIn":"BackboneElement","Citation.citedArtifact.publicationForm.publishedIn.extension":"Extension","Citation.citedArtifact.publicationForm.publishedIn.id":"System.String","Citation.citedArtifact.publicationForm.publishedIn.identifier":"Identifier","Citation.citedArtifact.publicationForm.publishedIn.modifierExtension":"Extension","Citation.citedArtifact.publicationForm.publishedIn.publisher":"Reference","Citation.citedArtifact.publicationForm.publishedIn.publisherLocation":"string","Citation.citedArtifact.publicationForm.publishedIn.title":"string","Citation.citedArtifact.publicationForm.publishedIn.type":"CodeableConcept","Citation.citedArtifact.publicationForm.volume":"string","Citation.citedArtifact.relatedIdentifier":"Identifier","Citation.citedArtifact.relatesTo":"BackboneElement","Citation.citedArtifact.relatesTo.citation":"markdown","Citation.citedArtifact.relatesTo.classifier":"CodeableConcept","Citation.citedArtifact.relatesTo.display":"string","Citation.citedArtifact.relatesTo.document":"Attachment","Citation.citedArtifact.relatesTo.extension":"Extension","Citation.citedArtifact.relatesTo.id":"System.String","Citation.citedArtifact.relatesTo.label":"string","Citation.citedArtifact.relatesTo.modifierExtension":"Extension","Citation.citedArtifact.relatesTo.resource":"canonical","Citation.citedArtifact.relatesTo.resourceReference":"Reference","Citation.citedArtifact.relatesTo.type":"code","Citation.citedArtifact.statusDate":"BackboneElement","Citation.citedArtifact.statusDate.activity":"CodeableConcept","Citation.citedArtifact.statusDate.actual":"boolean","Citation.citedArtifact.statusDate.extension":"Extension","Citation.citedArtifact.statusDate.id":"System.String","Citation.citedArtifact.statusDate.modifierExtension":"Extension","Citation.citedArtifact.statusDate.period":"Period","Citation.citedArtifact.title":"BackboneElement","Citation.citedArtifact.title.extension":"Extension","Citation.citedArtifact.title.id":"System.String","Citation.citedArtifact.title.language":"CodeableConcept","Citation.citedArtifact.title.modifierExtension":"Extension","Citation.citedArtifact.title.text":"markdown","Citation.citedArtifact.title.type":"CodeableConcept","Citation.citedArtifact.version":"BackboneElement","Citation.citedArtifact.version.baseCitation":"Reference","Citation.citedArtifact.version.extension":"Extension","Citation.citedArtifact.version.id":"System.String","Citation.citedArtifact.version.modifierExtension":"Extension","Citation.citedArtifact.version.value":"string","Citation.citedArtifact.webLocation":"BackboneElement","Citation.citedArtifact.webLocation.classifier":"CodeableConcept","Citation.citedArtifact.webLocation.extension":"Extension","Citation.citedArtifact.webLocation.id":"System.String","Citation.citedArtifact.webLocation.modifierExtension":"Extension","Citation.citedArtifact.webLocation.url":"uri","Citation.classification":"BackboneElement","Citation.classification.classifier":"CodeableConcept","Citation.classification.extension":"Extension","Citation.classification.id":"System.String","Citation.classification.modifierExtension":"Extension","Citation.classification.type":"CodeableConcept","Citation.contact":"ContactDetail","Citation.contained":"Resource","Citation.copyright":"markdown","Citation.copyrightLabel":"string","Citation.currentState":"CodeableConcept","Citation.date":"dateTime","Citation.description":"markdown","Citation.editor":"ContactDetail","Citation.effectivePeriod":"Period","Citation.endorser":"ContactDetail","Citation.experimental":"boolean","Citation.extension":"Extension","Citation.id":"System.String","Citation.identifier":"Identifier","Citation.implicitRules":"uri","Citation.jurisdiction":"CodeableConcept","Citation.language":"code","Citation.lastReviewDate":"date","Citation.meta":"Meta","Citation.modifierExtension":"Extension","Citation.name":"string","Citation.note":"Annotation","Citation.publisher":"string","Citation.purpose":"markdown","Citation.relatedArtifact":"RelatedArtifact","Citation.reviewer":"ContactDetail","Citation.status":"code","Citation.statusDate":"BackboneElement","Citation.statusDate.activity":"CodeableConcept","Citation.statusDate.actual":"boolean","Citation.statusDate.extension":"Extension","Citation.statusDate.id":"System.String","Citation.statusDate.modifierExtension":"Extension","Citation.statusDate.period":"Period","Citation.summary":"BackboneElement","Citation.summary.extension":"Extension","Citation.summary.id":"System.String","Citation.summary.modifierExtension":"Extension","Citation.summary.style":"CodeableConcept","Citation.summary.text":"markdown","Citation.text":"Narrative","Citation.title":"string","Citation.url":"uri","Citation.useContext":"UsageContext","Citation.version":"string","Citation.versionAlgorithmCoding":"Coding","Citation.versionAlgorithmString":"string","Claim.accident":"BackboneElement","Claim.accident.date":"date","Claim.accident.extension":"Extension","Claim.accident.id":"System.String","Claim.accident.locationAddress":"Address","Claim.accident.locationReference":"Reference","Claim.accident.modifierExtension":"Extension","Claim.accident.type":"CodeableConcept","Claim.billablePeriod":"Period","Claim.careTeam":"BackboneElement","Claim.careTeam.extension":"Extension","Claim.careTeam.id":"System.String","Claim.careTeam.modifierExtension":"Extension","Claim.careTeam.provider":"Reference","Claim.careTeam.responsible":"boolean","Claim.careTeam.role":"CodeableConcept","Claim.careTeam.sequence":"positiveInt","Claim.careTeam.specialty":"CodeableConcept","Claim.contained":"Resource","Claim.created":"dateTime","Claim.diagnosis":"BackboneElement","Claim.diagnosis.diagnosisCodeableConcept":"CodeableConcept","Claim.diagnosis.diagnosisReference":"Reference","Claim.diagnosis.extension":"Extension","Claim.diagnosis.id":"System.String","Claim.diagnosis.modifierExtension":"Extension","Claim.diagnosis.onAdmission":"CodeableConcept","Claim.diagnosis.sequence":"positiveInt","Claim.diagnosis.type":"CodeableConcept","Claim.diagnosisRelatedGroup":"CodeableConcept","Claim.encounter":"Reference","Claim.enterer":"Reference","Claim.event":"BackboneElement","Claim.event.extension":"Extension","Claim.event.id":"System.String","Claim.event.modifierExtension":"Extension","Claim.event.type":"CodeableConcept","Claim.event.whenDateTime":"dateTime","Claim.event.whenPeriod":"Period","Claim.extension":"Extension","Claim.facility":"Reference","Claim.fundsReserve":"CodeableConcept","Claim.id":"System.String","Claim.identifier":"Identifier","Claim.implicitRules":"uri","Claim.insurance":"BackboneElement","Claim.insurance.businessArrangement":"string","Claim.insurance.claimResponse":"Reference","Claim.insurance.coverage":"Reference","Claim.insurance.extension":"Extension","Claim.insurance.focal":"boolean","Claim.insurance.id":"System.String","Claim.insurance.identifier":"Identifier","Claim.insurance.modifierExtension":"Extension","Claim.insurance.preAuthRef":"string","Claim.insurance.sequence":"positiveInt","Claim.insurer":"Reference","Claim.item":"BackboneElement","Claim.item.bodySite":"BackboneElement","Claim.item.bodySite.extension":"Extension","Claim.item.bodySite.id":"System.String","Claim.item.bodySite.modifierExtension":"Extension","Claim.item.bodySite.site":"CodeableReference","Claim.item.bodySite.subSite":"CodeableConcept","Claim.item.careTeamSequence":"positiveInt","Claim.item.category":"CodeableConcept","Claim.item.detail":"BackboneElement","Claim.item.detail.category":"CodeableConcept","Claim.item.detail.extension":"Extension","Claim.item.detail.factor":"decimal","Claim.item.detail.id":"System.String","Claim.item.detail.modifier":"CodeableConcept","Claim.item.detail.modifierExtension":"Extension","Claim.item.detail.net":"Money","Claim.item.detail.patientPaid":"Money","Claim.item.detail.productOrService":"CodeableConcept","Claim.item.detail.productOrServiceEnd":"CodeableConcept","Claim.item.detail.programCode":"CodeableConcept","Claim.item.detail.quantity":"Quantity","Claim.item.detail.revenue":"CodeableConcept","Claim.item.detail.sequence":"positiveInt","Claim.item.detail.subDetail":"BackboneElement","Claim.item.detail.subDetail.category":"CodeableConcept","Claim.item.detail.subDetail.extension":"Extension","Claim.item.detail.subDetail.factor":"decimal","Claim.item.detail.subDetail.id":"System.String","Claim.item.detail.subDetail.modifier":"CodeableConcept","Claim.item.detail.subDetail.modifierExtension":"Extension","Claim.item.detail.subDetail.net":"Money","Claim.item.detail.subDetail.patientPaid":"Money","Claim.item.detail.subDetail.productOrService":"CodeableConcept","Claim.item.detail.subDetail.productOrServiceEnd":"CodeableConcept","Claim.item.detail.subDetail.programCode":"CodeableConcept","Claim.item.detail.subDetail.quantity":"Quantity","Claim.item.detail.subDetail.revenue":"CodeableConcept","Claim.item.detail.subDetail.sequence":"positiveInt","Claim.item.detail.subDetail.tax":"Money","Claim.item.detail.subDetail.traceNumber":"Identifier","Claim.item.detail.subDetail.udi":"Reference","Claim.item.detail.subDetail.unitPrice":"Money","Claim.item.detail.tax":"Money","Claim.item.detail.traceNumber":"Identifier","Claim.item.detail.udi":"Reference","Claim.item.detail.unitPrice":"Money","Claim.item.diagnosisSequence":"positiveInt","Claim.item.encounter":"Reference","Claim.item.extension":"Extension","Claim.item.factor":"decimal","Claim.item.id":"System.String","Claim.item.informationSequence":"positiveInt","Claim.item.locationAddress":"Address","Claim.item.locationCodeableConcept":"CodeableConcept","Claim.item.locationReference":"Reference","Claim.item.modifier":"CodeableConcept","Claim.item.modifierExtension":"Extension","Claim.item.net":"Money","Claim.item.patientPaid":"Money","Claim.item.procedureSequence":"positiveInt","Claim.item.productOrService":"CodeableConcept","Claim.item.productOrServiceEnd":"CodeableConcept","Claim.item.programCode":"CodeableConcept","Claim.item.quantity":"Quantity","Claim.item.request":"Reference","Claim.item.revenue":"CodeableConcept","Claim.item.sequence":"positiveInt","Claim.item.servicedDate":"date","Claim.item.servicedPeriod":"Period","Claim.item.tax":"Money","Claim.item.traceNumber":"Identifier","Claim.item.udi":"Reference","Claim.item.unitPrice":"Money","Claim.language":"code","Claim.meta":"Meta","Claim.modifierExtension":"Extension","Claim.originalPrescription":"Reference","Claim.patient":"Reference","Claim.patientPaid":"Money","Claim.payee":"BackboneElement","Claim.payee.extension":"Extension","Claim.payee.id":"System.String","Claim.payee.modifierExtension":"Extension","Claim.payee.party":"Reference","Claim.payee.type":"CodeableConcept","Claim.prescription":"Reference","Claim.priority":"CodeableConcept","Claim.procedure":"BackboneElement","Claim.procedure.date":"dateTime","Claim.procedure.extension":"Extension","Claim.procedure.id":"System.String","Claim.procedure.modifierExtension":"Extension","Claim.procedure.procedureCodeableConcept":"CodeableConcept","Claim.procedure.procedureReference":"Reference","Claim.procedure.sequence":"positiveInt","Claim.procedure.type":"CodeableConcept","Claim.procedure.udi":"Reference","Claim.provider":"Reference","Claim.referral":"Reference","Claim.related":"BackboneElement","Claim.related.claim":"Reference","Claim.related.extension":"Extension","Claim.related.id":"System.String","Claim.related.modifierExtension":"Extension","Claim.related.reference":"Identifier","Claim.related.relationship":"CodeableConcept","Claim.status":"code","Claim.subType":"CodeableConcept","Claim.supportingInfo":"BackboneElement","Claim.supportingInfo.category":"CodeableConcept","Claim.supportingInfo.code":"CodeableConcept","Claim.supportingInfo.extension":"Extension","Claim.supportingInfo.id":"System.String","Claim.supportingInfo.modifierExtension":"Extension","Claim.supportingInfo.reason":"CodeableConcept","Claim.supportingInfo.sequence":"positiveInt","Claim.supportingInfo.timingDate":"date","Claim.supportingInfo.timingPeriod":"Period","Claim.supportingInfo.valueAttachment":"Attachment","Claim.supportingInfo.valueBoolean":"boolean","Claim.supportingInfo.valueIdentifier":"Identifier","Claim.supportingInfo.valueQuantity":"Quantity","Claim.supportingInfo.valueReference":"Reference","Claim.supportingInfo.valueString":"string","Claim.text":"Narrative","Claim.total":"Money","Claim.traceNumber":"Identifier","Claim.type":"CodeableConcept","Claim.use":"code","ClaimResponse.addItem":"BackboneElement","ClaimResponse.addItem.bodySite":"BackboneElement","ClaimResponse.addItem.bodySite.extension":"Extension","ClaimResponse.addItem.bodySite.id":"System.String","ClaimResponse.addItem.bodySite.modifierExtension":"Extension","ClaimResponse.addItem.bodySite.site":"CodeableReference","ClaimResponse.addItem.bodySite.subSite":"CodeableConcept","ClaimResponse.addItem.detail":"BackboneElement","ClaimResponse.addItem.detail.extension":"Extension","ClaimResponse.addItem.detail.factor":"decimal","ClaimResponse.addItem.detail.id":"System.String","ClaimResponse.addItem.detail.modifier":"CodeableConcept","ClaimResponse.addItem.detail.modifierExtension":"Extension","ClaimResponse.addItem.detail.net":"Money","ClaimResponse.addItem.detail.noteNumber":"positiveInt","ClaimResponse.addItem.detail.productOrService":"CodeableConcept","ClaimResponse.addItem.detail.productOrServiceEnd":"CodeableConcept","ClaimResponse.addItem.detail.quantity":"Quantity","ClaimResponse.addItem.detail.revenue":"CodeableConcept","ClaimResponse.addItem.detail.subDetail":"BackboneElement","ClaimResponse.addItem.detail.subDetail.extension":"Extension","ClaimResponse.addItem.detail.subDetail.factor":"decimal","ClaimResponse.addItem.detail.subDetail.id":"System.String","ClaimResponse.addItem.detail.subDetail.modifier":"CodeableConcept","ClaimResponse.addItem.detail.subDetail.modifierExtension":"Extension","ClaimResponse.addItem.detail.subDetail.net":"Money","ClaimResponse.addItem.detail.subDetail.noteNumber":"positiveInt","ClaimResponse.addItem.detail.subDetail.productOrService":"CodeableConcept","ClaimResponse.addItem.detail.subDetail.productOrServiceEnd":"CodeableConcept","ClaimResponse.addItem.detail.subDetail.quantity":"Quantity","ClaimResponse.addItem.detail.subDetail.revenue":"CodeableConcept","ClaimResponse.addItem.detail.subDetail.tax":"Money","ClaimResponse.addItem.detail.subDetail.traceNumber":"Identifier","ClaimResponse.addItem.detail.subDetail.unitPrice":"Money","ClaimResponse.addItem.detail.tax":"Money","ClaimResponse.addItem.detail.traceNumber":"Identifier","ClaimResponse.addItem.detail.unitPrice":"Money","ClaimResponse.addItem.detailSequence":"positiveInt","ClaimResponse.addItem.extension":"Extension","ClaimResponse.addItem.factor":"decimal","ClaimResponse.addItem.id":"System.String","ClaimResponse.addItem.itemSequence":"positiveInt","ClaimResponse.addItem.locationAddress":"Address","ClaimResponse.addItem.locationCodeableConcept":"CodeableConcept","ClaimResponse.addItem.locationReference":"Reference","ClaimResponse.addItem.modifier":"CodeableConcept","ClaimResponse.addItem.modifierExtension":"Extension","ClaimResponse.addItem.net":"Money","ClaimResponse.addItem.noteNumber":"positiveInt","ClaimResponse.addItem.productOrService":"CodeableConcept","ClaimResponse.addItem.productOrServiceEnd":"CodeableConcept","ClaimResponse.addItem.programCode":"CodeableConcept","ClaimResponse.addItem.provider":"Reference","ClaimResponse.addItem.quantity":"Quantity","ClaimResponse.addItem.request":"Reference","ClaimResponse.addItem.revenue":"CodeableConcept","ClaimResponse.addItem.servicedDate":"date","ClaimResponse.addItem.servicedPeriod":"Period","ClaimResponse.addItem.subdetailSequence":"positiveInt","ClaimResponse.addItem.tax":"Money","ClaimResponse.addItem.traceNumber":"Identifier","ClaimResponse.addItem.unitPrice":"Money","ClaimResponse.communicationRequest":"Reference","ClaimResponse.contained":"Resource","ClaimResponse.created":"dateTime","ClaimResponse.decision":"CodeableConcept","ClaimResponse.diagnosisRelatedGroup":"CodeableConcept","ClaimResponse.disposition":"string","ClaimResponse.encounter":"Reference","ClaimResponse.error":"BackboneElement","ClaimResponse.error.code":"CodeableConcept","ClaimResponse.error.detailSequence":"positiveInt","ClaimResponse.error.expression":"string","ClaimResponse.error.extension":"Extension","ClaimResponse.error.id":"System.String","ClaimResponse.error.itemSequence":"positiveInt","ClaimResponse.error.modifierExtension":"Extension","ClaimResponse.error.subDetailSequence":"positiveInt","ClaimResponse.event":"BackboneElement","ClaimResponse.event.extension":"Extension","ClaimResponse.event.id":"System.String","ClaimResponse.event.modifierExtension":"Extension","ClaimResponse.event.type":"CodeableConcept","ClaimResponse.event.whenDateTime":"dateTime","ClaimResponse.event.whenPeriod":"Period","ClaimResponse.extension":"Extension","ClaimResponse.form":"Attachment","ClaimResponse.formCode":"CodeableConcept","ClaimResponse.fundsReserve":"CodeableConcept","ClaimResponse.id":"System.String","ClaimResponse.identifier":"Identifier","ClaimResponse.implicitRules":"uri","ClaimResponse.insurance":"BackboneElement","ClaimResponse.insurance.businessArrangement":"string","ClaimResponse.insurance.claimResponse":"Reference","ClaimResponse.insurance.coverage":"Reference","ClaimResponse.insurance.extension":"Extension","ClaimResponse.insurance.focal":"boolean","ClaimResponse.insurance.id":"System.String","ClaimResponse.insurance.modifierExtension":"Extension","ClaimResponse.insurance.sequence":"positiveInt","ClaimResponse.insurer":"Reference","ClaimResponse.item":"BackboneElement","ClaimResponse.item.adjudication":"BackboneElement","ClaimResponse.item.adjudication.amount":"Money","ClaimResponse.item.adjudication.category":"CodeableConcept","ClaimResponse.item.adjudication.extension":"Extension","ClaimResponse.item.adjudication.id":"System.String","ClaimResponse.item.adjudication.modifierExtension":"Extension","ClaimResponse.item.adjudication.quantity":"Quantity","ClaimResponse.item.adjudication.reason":"CodeableConcept","ClaimResponse.item.detail":"BackboneElement","ClaimResponse.item.detail.detailSequence":"positiveInt","ClaimResponse.item.detail.extension":"Extension","ClaimResponse.item.detail.id":"System.String","ClaimResponse.item.detail.modifierExtension":"Extension","ClaimResponse.item.detail.noteNumber":"positiveInt","ClaimResponse.item.detail.subDetail":"BackboneElement","ClaimResponse.item.detail.subDetail.extension":"Extension","ClaimResponse.item.detail.subDetail.id":"System.String","ClaimResponse.item.detail.subDetail.modifierExtension":"Extension","ClaimResponse.item.detail.subDetail.noteNumber":"positiveInt","ClaimResponse.item.detail.subDetail.subDetailSequence":"positiveInt","ClaimResponse.item.detail.subDetail.traceNumber":"Identifier","ClaimResponse.item.detail.traceNumber":"Identifier","ClaimResponse.item.extension":"Extension","ClaimResponse.item.id":"System.String","ClaimResponse.item.itemSequence":"positiveInt","ClaimResponse.item.modifierExtension":"Extension","ClaimResponse.item.noteNumber":"positiveInt","ClaimResponse.item.reviewOutcome":"BackboneElement","ClaimResponse.item.reviewOutcome.decision":"CodeableConcept","ClaimResponse.item.reviewOutcome.extension":"Extension","ClaimResponse.item.reviewOutcome.id":"System.String","ClaimResponse.item.reviewOutcome.modifierExtension":"Extension","ClaimResponse.item.reviewOutcome.preAuthPeriod":"Period","ClaimResponse.item.reviewOutcome.preAuthRef":"string","ClaimResponse.item.reviewOutcome.reason":"CodeableConcept","ClaimResponse.item.traceNumber":"Identifier","ClaimResponse.language":"code","ClaimResponse.meta":"Meta","ClaimResponse.modifierExtension":"Extension","ClaimResponse.outcome":"code","ClaimResponse.patient":"Reference","ClaimResponse.payeeType":"CodeableConcept","ClaimResponse.payment":"BackboneElement","ClaimResponse.payment.adjustment":"Money","ClaimResponse.payment.adjustmentReason":"CodeableConcept","ClaimResponse.payment.amount":"Money","ClaimResponse.payment.date":"date","ClaimResponse.payment.extension":"Extension","ClaimResponse.payment.id":"System.String","ClaimResponse.payment.identifier":"Identifier","ClaimResponse.payment.modifierExtension":"Extension","ClaimResponse.payment.type":"CodeableConcept","ClaimResponse.preAuthPeriod":"Period","ClaimResponse.preAuthRef":"string","ClaimResponse.processNote":"BackboneElement","ClaimResponse.processNote.extension":"Extension","ClaimResponse.processNote.id":"System.String","ClaimResponse.processNote.language":"CodeableConcept","ClaimResponse.processNote.modifierExtension":"Extension","ClaimResponse.processNote.number":"positiveInt","ClaimResponse.processNote.text":"string","ClaimResponse.processNote.type":"CodeableConcept","ClaimResponse.request":"Reference","ClaimResponse.requestor":"Reference","ClaimResponse.status":"code","ClaimResponse.subType":"CodeableConcept","ClaimResponse.text":"Narrative","ClaimResponse.total":"BackboneElement","ClaimResponse.total.amount":"Money","ClaimResponse.total.category":"CodeableConcept","ClaimResponse.total.extension":"Extension","ClaimResponse.total.id":"System.String","ClaimResponse.total.modifierExtension":"Extension","ClaimResponse.traceNumber":"Identifier","ClaimResponse.type":"CodeableConcept","ClaimResponse.use":"code","ClinicalImpression.changePattern":"CodeableConcept","ClinicalImpression.contained":"Resource","ClinicalImpression.date":"dateTime","ClinicalImpression.description":"string","ClinicalImpression.effectiveDateTime":"dateTime","ClinicalImpression.effectivePeriod":"Period","ClinicalImpression.encounter":"Reference","ClinicalImpression.extension":"Extension","ClinicalImpression.finding":"BackboneElement","ClinicalImpression.finding.basis":"string","ClinicalImpression.finding.extension":"Extension","ClinicalImpression.finding.id":"System.String","ClinicalImpression.finding.item":"CodeableReference","ClinicalImpression.finding.modifierExtension":"Extension","ClinicalImpression.id":"System.String","ClinicalImpression.identifier":"Identifier","ClinicalImpression.implicitRules":"uri","ClinicalImpression.language":"code","ClinicalImpression.meta":"Meta","ClinicalImpression.modifierExtension":"Extension","ClinicalImpression.note":"Annotation","ClinicalImpression.performer":"Reference","ClinicalImpression.previous":"Reference","ClinicalImpression.problem":"Reference","ClinicalImpression.prognosisCodeableConcept":"CodeableConcept","ClinicalImpression.prognosisReference":"Reference","ClinicalImpression.protocol":"uri","ClinicalImpression.status":"code","ClinicalImpression.statusReason":"CodeableConcept","ClinicalImpression.subject":"Reference","ClinicalImpression.summary":"string","ClinicalImpression.supportingInfo":"Reference","ClinicalImpression.text":"Narrative","ClinicalUseDefinition.category":"CodeableConcept","ClinicalUseDefinition.contained":"Resource","ClinicalUseDefinition.contraindication":"BackboneElement","ClinicalUseDefinition.contraindication.applicability":"Expression","ClinicalUseDefinition.contraindication.comorbidity":"CodeableReference","ClinicalUseDefinition.contraindication.diseaseStatus":"CodeableReference","ClinicalUseDefinition.contraindication.diseaseSymptomProcedure":"CodeableReference","ClinicalUseDefinition.contraindication.extension":"Extension","ClinicalUseDefinition.contraindication.id":"System.String","ClinicalUseDefinition.contraindication.indication":"Reference","ClinicalUseDefinition.contraindication.modifierExtension":"Extension","ClinicalUseDefinition.contraindication.otherTherapy":"BackboneElement","ClinicalUseDefinition.contraindication.otherTherapy.extension":"Extension","ClinicalUseDefinition.contraindication.otherTherapy.id":"System.String","ClinicalUseDefinition.contraindication.otherTherapy.modifierExtension":"Extension","ClinicalUseDefinition.contraindication.otherTherapy.relationshipType":"CodeableConcept","ClinicalUseDefinition.contraindication.otherTherapy.treatment":"CodeableReference","ClinicalUseDefinition.extension":"Extension","ClinicalUseDefinition.id":"System.String","ClinicalUseDefinition.identifier":"Identifier","ClinicalUseDefinition.implicitRules":"uri","ClinicalUseDefinition.indication":"BackboneElement","ClinicalUseDefinition.indication.applicability":"Expression","ClinicalUseDefinition.indication.comorbidity":"CodeableReference","ClinicalUseDefinition.indication.diseaseStatus":"CodeableReference","ClinicalUseDefinition.indication.diseaseSymptomProcedure":"CodeableReference","ClinicalUseDefinition.indication.durationRange":"Range","ClinicalUseDefinition.indication.durationString":"string","ClinicalUseDefinition.indication.extension":"Extension","ClinicalUseDefinition.indication.id":"System.String","ClinicalUseDefinition.indication.intendedEffect":"CodeableReference","ClinicalUseDefinition.indication.modifierExtension":"Extension","ClinicalUseDefinition.indication.undesirableEffect":"Reference","ClinicalUseDefinition.interaction":"BackboneElement","ClinicalUseDefinition.interaction.effect":"CodeableReference","ClinicalUseDefinition.interaction.extension":"Extension","ClinicalUseDefinition.interaction.id":"System.String","ClinicalUseDefinition.interaction.incidence":"CodeableConcept","ClinicalUseDefinition.interaction.interactant":"BackboneElement","ClinicalUseDefinition.interaction.interactant.extension":"Extension","ClinicalUseDefinition.interaction.interactant.id":"System.String","ClinicalUseDefinition.interaction.interactant.itemCodeableConcept":"CodeableConcept","ClinicalUseDefinition.interaction.interactant.itemReference":"Reference","ClinicalUseDefinition.interaction.interactant.modifierExtension":"Extension","ClinicalUseDefinition.interaction.management":"CodeableConcept","ClinicalUseDefinition.interaction.modifierExtension":"Extension","ClinicalUseDefinition.interaction.type":"CodeableConcept","ClinicalUseDefinition.language":"code","ClinicalUseDefinition.library":"canonical","ClinicalUseDefinition.meta":"Meta","ClinicalUseDefinition.modifierExtension":"Extension","ClinicalUseDefinition.population":"Reference","ClinicalUseDefinition.status":"CodeableConcept","ClinicalUseDefinition.subject":"Reference","ClinicalUseDefinition.text":"Narrative","ClinicalUseDefinition.type":"code","ClinicalUseDefinition.undesirableEffect":"BackboneElement","ClinicalUseDefinition.undesirableEffect.classification":"CodeableConcept","ClinicalUseDefinition.undesirableEffect.extension":"Extension","ClinicalUseDefinition.undesirableEffect.frequencyOfOccurrence":"CodeableConcept","ClinicalUseDefinition.undesirableEffect.id":"System.String","ClinicalUseDefinition.undesirableEffect.modifierExtension":"Extension","ClinicalUseDefinition.undesirableEffect.symptomConditionEffect":"CodeableReference","ClinicalUseDefinition.warning":"BackboneElement","ClinicalUseDefinition.warning.code":"CodeableConcept","ClinicalUseDefinition.warning.description":"markdown","ClinicalUseDefinition.warning.extension":"Extension","ClinicalUseDefinition.warning.id":"System.String","ClinicalUseDefinition.warning.modifierExtension":"Extension","CodeSystem.approvalDate":"date","CodeSystem.author":"ContactDetail","CodeSystem.caseSensitive":"boolean","CodeSystem.compositional":"boolean","CodeSystem.concept":"BackboneElement","CodeSystem.concept.code":"code","CodeSystem.concept.definition":"string","CodeSystem.concept.designation":"BackboneElement","CodeSystem.concept.designation.additionalUse":"Coding","CodeSystem.concept.designation.extension":"Extension","CodeSystem.concept.designation.id":"System.String","CodeSystem.concept.designation.language":"code","CodeSystem.concept.designation.modifierExtension":"Extension","CodeSystem.concept.designation.use":"Coding","CodeSystem.concept.designation.value":"string","CodeSystem.concept.display":"string","CodeSystem.concept.extension":"Extension","CodeSystem.concept.id":"System.String","CodeSystem.concept.modifierExtension":"Extension","CodeSystem.concept.property":"BackboneElement","CodeSystem.concept.property.code":"code","CodeSystem.concept.property.extension":"Extension","CodeSystem.concept.property.id":"System.String","CodeSystem.concept.property.modifierExtension":"Extension","CodeSystem.concept.property.valueBoolean":"boolean","CodeSystem.concept.property.valueCode":"code","CodeSystem.concept.property.valueCoding":"Coding","CodeSystem.concept.property.valueDateTime":"dateTime","CodeSystem.concept.property.valueDecimal":"decimal","CodeSystem.concept.property.valueInteger":"integer","CodeSystem.concept.property.valueString":"string","CodeSystem.contact":"ContactDetail","CodeSystem.contained":"Resource","CodeSystem.content":"code","CodeSystem.copyright":"markdown","CodeSystem.copyrightLabel":"string","CodeSystem.count":"unsignedInt","CodeSystem.date":"dateTime","CodeSystem.description":"markdown","CodeSystem.editor":"ContactDetail","CodeSystem.effectivePeriod":"Period","CodeSystem.endorser":"ContactDetail","CodeSystem.experimental":"boolean","CodeSystem.extension":"Extension","CodeSystem.filter":"BackboneElement","CodeSystem.filter.code":"code","CodeSystem.filter.description":"string","CodeSystem.filter.extension":"Extension","CodeSystem.filter.id":"System.String","CodeSystem.filter.modifierExtension":"Extension","CodeSystem.filter.operator":"code","CodeSystem.filter.value":"string","CodeSystem.hierarchyMeaning":"code","CodeSystem.id":"System.String","CodeSystem.identifier":"Identifier","CodeSystem.implicitRules":"uri","CodeSystem.jurisdiction":"CodeableConcept","CodeSystem.language":"code","CodeSystem.lastReviewDate":"date","CodeSystem.meta":"Meta","CodeSystem.modifierExtension":"Extension","CodeSystem.name":"string","CodeSystem.property":"BackboneElement","CodeSystem.property.code":"code","CodeSystem.property.description":"string","CodeSystem.property.extension":"Extension","CodeSystem.property.id":"System.String","CodeSystem.property.modifierExtension":"Extension","CodeSystem.property.type":"code","CodeSystem.property.uri":"uri","CodeSystem.publisher":"string","CodeSystem.purpose":"markdown","CodeSystem.relatedArtifact":"RelatedArtifact","CodeSystem.reviewer":"ContactDetail","CodeSystem.status":"code","CodeSystem.supplements":"canonical","CodeSystem.text":"Narrative","CodeSystem.title":"string","CodeSystem.topic":"CodeableConcept","CodeSystem.url":"uri","CodeSystem.useContext":"UsageContext","CodeSystem.valueSet":"canonical","CodeSystem.version":"string","CodeSystem.versionAlgorithmCoding":"Coding","CodeSystem.versionAlgorithmString":"string","CodeSystem.versionNeeded":"boolean","CodeableConcept.coding":"Coding","CodeableConcept.extension":"Extension","CodeableConcept.id":"System.String","CodeableConcept.text":"string","CodeableReference.concept":"CodeableConcept","CodeableReference.extension":"Extension","CodeableReference.id":"System.String","CodeableReference.reference":"Reference","Coding.code":"code","Coding.display":"string","Coding.extension":"Extension","Coding.id":"System.String","Coding.system":"uri","Coding.userSelected":"boolean","Coding.version":"string","Communication.about":"Reference","Communication.basedOn":"Reference","Communication.category":"CodeableConcept","Communication.contained":"Resource","Communication.encounter":"Reference","Communication.extension":"Extension","Communication.id":"System.String","Communication.identifier":"Identifier","Communication.implicitRules":"uri","Communication.inResponseTo":"Reference","Communication.instantiatesCanonical":"canonical","Communication.instantiatesUri":"uri","Communication.language":"code","Communication.medium":"CodeableConcept","Communication.meta":"Meta","Communication.modifierExtension":"Extension","Communication.note":"Annotation","Communication.partOf":"Reference","Communication.payload":"BackboneElement","Communication.payload.contentAttachment":"Attachment","Communication.payload.contentCodeableConcept":"CodeableConcept","Communication.payload.contentReference":"Reference","Communication.payload.extension":"Extension","Communication.payload.id":"System.String","Communication.payload.modifierExtension":"Extension","Communication.priority":"code","Communication.reason":"CodeableReference","Communication.received":"dateTime","Communication.recipient":"Reference","Communication.sender":"Reference","Communication.sent":"dateTime","Communication.status":"code","Communication.statusReason":"CodeableConcept","Communication.subject":"Reference","Communication.text":"Narrative","Communication.topic":"CodeableConcept","CommunicationRequest.about":"Reference","CommunicationRequest.authoredOn":"dateTime","CommunicationRequest.basedOn":"Reference","CommunicationRequest.category":"CodeableConcept","CommunicationRequest.contained":"Resource","CommunicationRequest.doNotPerform":"boolean","CommunicationRequest.encounter":"Reference","CommunicationRequest.extension":"Extension","CommunicationRequest.groupIdentifier":"Identifier","CommunicationRequest.id":"System.String","CommunicationRequest.identifier":"Identifier","CommunicationRequest.implicitRules":"uri","CommunicationRequest.informationProvider":"Reference","CommunicationRequest.intent":"code","CommunicationRequest.language":"code","CommunicationRequest.medium":"CodeableConcept","CommunicationRequest.meta":"Meta","CommunicationRequest.modifierExtension":"Extension","CommunicationRequest.note":"Annotation","CommunicationRequest.occurrenceDateTime":"dateTime","CommunicationRequest.occurrencePeriod":"Period","CommunicationRequest.payload":"BackboneElement","CommunicationRequest.payload.contentAttachment":"Attachment","CommunicationRequest.payload.contentCodeableConcept":"CodeableConcept","CommunicationRequest.payload.contentReference":"Reference","CommunicationRequest.payload.extension":"Extension","CommunicationRequest.payload.id":"System.String","CommunicationRequest.payload.modifierExtension":"Extension","CommunicationRequest.priority":"code","CommunicationRequest.reason":"CodeableReference","CommunicationRequest.recipient":"Reference","CommunicationRequest.replaces":"Reference","CommunicationRequest.requester":"Reference","CommunicationRequest.status":"code","CommunicationRequest.statusReason":"CodeableConcept","CommunicationRequest.subject":"Reference","CommunicationRequest.text":"Narrative","CompartmentDefinition.code":"code","CompartmentDefinition.contact":"ContactDetail","CompartmentDefinition.contained":"Resource","CompartmentDefinition.date":"dateTime","CompartmentDefinition.description":"markdown","CompartmentDefinition.experimental":"boolean","CompartmentDefinition.extension":"Extension","CompartmentDefinition.id":"System.String","CompartmentDefinition.implicitRules":"uri","CompartmentDefinition.language":"code","CompartmentDefinition.meta":"Meta","CompartmentDefinition.modifierExtension":"Extension","CompartmentDefinition.name":"string","CompartmentDefinition.publisher":"string","CompartmentDefinition.purpose":"markdown","CompartmentDefinition.resource":"BackboneElement","CompartmentDefinition.resource.code":"code","CompartmentDefinition.resource.documentation":"string","CompartmentDefinition.resource.endParam":"uri","CompartmentDefinition.resource.extension":"Extension","CompartmentDefinition.resource.id":"System.String","CompartmentDefinition.resource.modifierExtension":"Extension","CompartmentDefinition.resource.param":"string","CompartmentDefinition.resource.startParam":"uri","CompartmentDefinition.search":"boolean","CompartmentDefinition.status":"code","CompartmentDefinition.text":"Narrative","CompartmentDefinition.title":"string","CompartmentDefinition.url":"uri","CompartmentDefinition.useContext":"UsageContext","CompartmentDefinition.version":"string","CompartmentDefinition.versionAlgorithmCoding":"Coding","CompartmentDefinition.versionAlgorithmString":"string","Composition.attester":"BackboneElement","Composition.attester.extension":"Extension","Composition.attester.id":"System.String","Composition.attester.mode":"CodeableConcept","Composition.attester.modifierExtension":"Extension","Composition.attester.party":"Reference","Composition.attester.time":"dateTime","Composition.author":"Reference","Composition.category":"CodeableConcept","Composition.contained":"Resource","Composition.custodian":"Reference","Composition.date":"dateTime","Composition.encounter":"Reference","Composition.event":"BackboneElement","Composition.event.detail":"CodeableReference","Composition.event.extension":"Extension","Composition.event.id":"System.String","Composition.event.modifierExtension":"Extension","Composition.event.period":"Period","Composition.extension":"Extension","Composition.id":"System.String","Composition.identifier":"Identifier","Composition.implicitRules":"uri","Composition.language":"code","Composition.meta":"Meta","Composition.modifierExtension":"Extension","Composition.name":"string","Composition.note":"Annotation","Composition.relatesTo":"RelatedArtifact","Composition.section":"BackboneElement","Composition.section.author":"Reference","Composition.section.code":"CodeableConcept","Composition.section.emptyReason":"CodeableConcept","Composition.section.entry":"Reference","Composition.section.extension":"Extension","Composition.section.focus":"Reference","Composition.section.id":"System.String","Composition.section.modifierExtension":"Extension","Composition.section.orderedBy":"CodeableConcept","Composition.section.text":"Narrative","Composition.section.title":"string","Composition.status":"code","Composition.subject":"Reference","Composition.text":"Narrative","Composition.title":"string","Composition.type":"CodeableConcept","Composition.url":"uri","Composition.useContext":"UsageContext","Composition.version":"string","ConceptMap.additionalAttribute":"BackboneElement","ConceptMap.additionalAttribute.code":"code","ConceptMap.additionalAttribute.description":"string","ConceptMap.additionalAttribute.extension":"Extension","ConceptMap.additionalAttribute.id":"System.String","ConceptMap.additionalAttribute.modifierExtension":"Extension","ConceptMap.additionalAttribute.type":"code","ConceptMap.additionalAttribute.uri":"uri","ConceptMap.approvalDate":"date","ConceptMap.author":"ContactDetail","ConceptMap.contact":"ContactDetail","ConceptMap.contained":"Resource","ConceptMap.copyright":"markdown","ConceptMap.copyrightLabel":"string","ConceptMap.date":"dateTime","ConceptMap.description":"markdown","ConceptMap.editor":"ContactDetail","ConceptMap.effectivePeriod":"Period","ConceptMap.endorser":"ContactDetail","ConceptMap.experimental":"boolean","ConceptMap.extension":"Extension","ConceptMap.group":"BackboneElement","ConceptMap.group.element":"BackboneElement","ConceptMap.group.element.code":"code","ConceptMap.group.element.display":"string","ConceptMap.group.element.extension":"Extension","ConceptMap.group.element.id":"System.String","ConceptMap.group.element.modifierExtension":"Extension","ConceptMap.group.element.noMap":"boolean","ConceptMap.group.element.target":"BackboneElement","ConceptMap.group.element.target.code":"code","ConceptMap.group.element.target.comment":"string","ConceptMap.group.element.target.dependsOn":"BackboneElement","ConceptMap.group.element.target.dependsOn.attribute":"code","ConceptMap.group.element.target.dependsOn.extension":"Extension","ConceptMap.group.element.target.dependsOn.id":"System.String","ConceptMap.group.element.target.dependsOn.modifierExtension":"Extension","ConceptMap.group.element.target.dependsOn.valueBoolean":"boolean","ConceptMap.group.element.target.dependsOn.valueCode":"code","ConceptMap.group.element.target.dependsOn.valueCoding":"Coding","ConceptMap.group.element.target.dependsOn.valueQuantity":"Quantity","ConceptMap.group.element.target.dependsOn.valueSet":"canonical","ConceptMap.group.element.target.dependsOn.valueString":"string","ConceptMap.group.element.target.display":"string","ConceptMap.group.element.target.extension":"Extension","ConceptMap.group.element.target.id":"System.String","ConceptMap.group.element.target.modifierExtension":"Extension","ConceptMap.group.element.target.property":"BackboneElement","ConceptMap.group.element.target.property.code":"code","ConceptMap.group.element.target.property.extension":"Extension","ConceptMap.group.element.target.property.id":"System.String","ConceptMap.group.element.target.property.modifierExtension":"Extension","ConceptMap.group.element.target.property.valueBoolean":"boolean","ConceptMap.group.element.target.property.valueCode":"code","ConceptMap.group.element.target.property.valueCoding":"Coding","ConceptMap.group.element.target.property.valueDateTime":"dateTime","ConceptMap.group.element.target.property.valueDecimal":"decimal","ConceptMap.group.element.target.property.valueInteger":"integer","ConceptMap.group.element.target.property.valueString":"string","ConceptMap.group.element.target.relationship":"code","ConceptMap.group.element.target.valueSet":"canonical","ConceptMap.group.element.valueSet":"canonical","ConceptMap.group.extension":"Extension","ConceptMap.group.id":"System.String","ConceptMap.group.modifierExtension":"Extension","ConceptMap.group.source":"canonical","ConceptMap.group.target":"canonical","ConceptMap.group.unmapped":"BackboneElement","ConceptMap.group.unmapped.code":"code","ConceptMap.group.unmapped.display":"string","ConceptMap.group.unmapped.extension":"Extension","ConceptMap.group.unmapped.id":"System.String","ConceptMap.group.unmapped.mode":"code","ConceptMap.group.unmapped.modifierExtension":"Extension","ConceptMap.group.unmapped.otherMap":"canonical","ConceptMap.group.unmapped.relationship":"code","ConceptMap.group.unmapped.valueSet":"canonical","ConceptMap.id":"System.String","ConceptMap.identifier":"Identifier","ConceptMap.implicitRules":"uri","ConceptMap.jurisdiction":"CodeableConcept","ConceptMap.language":"code","ConceptMap.lastReviewDate":"date","ConceptMap.meta":"Meta","ConceptMap.modifierExtension":"Extension","ConceptMap.name":"string","ConceptMap.property":"BackboneElement","ConceptMap.property.code":"code","ConceptMap.property.description":"string","ConceptMap.property.extension":"Extension","ConceptMap.property.id":"System.String","ConceptMap.property.modifierExtension":"Extension","ConceptMap.property.system":"canonical","ConceptMap.property.type":"code","ConceptMap.property.uri":"uri","ConceptMap.publisher":"string","ConceptMap.purpose":"markdown","ConceptMap.relatedArtifact":"RelatedArtifact","ConceptMap.reviewer":"ContactDetail","ConceptMap.sourceScopeCanonical":"canonical","ConceptMap.sourceScopeUri":"uri","ConceptMap.status":"code","ConceptMap.targetScopeCanonical":"canonical","ConceptMap.targetScopeUri":"uri","ConceptMap.text":"Narrative","ConceptMap.title":"string","ConceptMap.topic":"CodeableConcept","ConceptMap.url":"uri","ConceptMap.useContext":"UsageContext","ConceptMap.version":"string","ConceptMap.versionAlgorithmCoding":"Coding","ConceptMap.versionAlgorithmString":"string","Condition.abatementAge":"Age","Condition.abatementDateTime":"dateTime","Condition.abatementPeriod":"Period","Condition.abatementRange":"Range","Condition.abatementString":"string","Condition.bodySite":"CodeableConcept","Condition.category":"CodeableConcept","Condition.clinicalStatus":"CodeableConcept","Condition.code":"CodeableConcept","Condition.contained":"Resource","Condition.encounter":"Reference","Condition.evidence":"CodeableReference","Condition.extension":"Extension","Condition.id":"System.String","Condition.identifier":"Identifier","Condition.implicitRules":"uri","Condition.language":"code","Condition.meta":"Meta","Condition.modifierExtension":"Extension","Condition.note":"Annotation","Condition.onsetAge":"Age","Condition.onsetDateTime":"dateTime","Condition.onsetPeriod":"Period","Condition.onsetRange":"Range","Condition.onsetString":"string","Condition.participant":"BackboneElement","Condition.participant.actor":"Reference","Condition.participant.extension":"Extension","Condition.participant.function":"CodeableConcept","Condition.participant.id":"System.String","Condition.participant.modifierExtension":"Extension","Condition.recordedDate":"dateTime","Condition.severity":"CodeableConcept","Condition.stage":"BackboneElement","Condition.stage.assessment":"Reference","Condition.stage.extension":"Extension","Condition.stage.id":"System.String","Condition.stage.modifierExtension":"Extension","Condition.stage.summary":"CodeableConcept","Condition.stage.type":"CodeableConcept","Condition.subject":"Reference","Condition.text":"Narrative","Condition.verificationStatus":"CodeableConcept","ConditionDefinition.bodySite":"CodeableConcept","ConditionDefinition.code":"CodeableConcept","ConditionDefinition.contact":"ContactDetail","ConditionDefinition.contained":"Resource","ConditionDefinition.date":"dateTime","ConditionDefinition.definition":"uri","ConditionDefinition.description":"markdown","ConditionDefinition.experimental":"boolean","ConditionDefinition.extension":"Extension","ConditionDefinition.hasBodySite":"boolean","ConditionDefinition.hasSeverity":"boolean","ConditionDefinition.hasStage":"boolean","ConditionDefinition.id":"System.String","ConditionDefinition.identifier":"Identifier","ConditionDefinition.implicitRules":"uri","ConditionDefinition.jurisdiction":"CodeableConcept","ConditionDefinition.language":"code","ConditionDefinition.medication":"BackboneElement","ConditionDefinition.medication.category":"CodeableConcept","ConditionDefinition.medication.code":"CodeableConcept","ConditionDefinition.medication.extension":"Extension","ConditionDefinition.medication.id":"System.String","ConditionDefinition.medication.modifierExtension":"Extension","ConditionDefinition.meta":"Meta","ConditionDefinition.modifierExtension":"Extension","ConditionDefinition.name":"string","ConditionDefinition.observation":"BackboneElement","ConditionDefinition.observation.category":"CodeableConcept","ConditionDefinition.observation.code":"CodeableConcept","ConditionDefinition.observation.extension":"Extension","ConditionDefinition.observation.id":"System.String","ConditionDefinition.observation.modifierExtension":"Extension","ConditionDefinition.plan":"BackboneElement","ConditionDefinition.plan.extension":"Extension","ConditionDefinition.plan.id":"System.String","ConditionDefinition.plan.modifierExtension":"Extension","ConditionDefinition.plan.reference":"Reference","ConditionDefinition.plan.role":"CodeableConcept","ConditionDefinition.precondition":"BackboneElement","ConditionDefinition.precondition.code":"CodeableConcept","ConditionDefinition.precondition.extension":"Extension","ConditionDefinition.precondition.id":"System.String","ConditionDefinition.precondition.modifierExtension":"Extension","ConditionDefinition.precondition.type":"code","ConditionDefinition.precondition.valueCodeableConcept":"CodeableConcept","ConditionDefinition.precondition.valueQuantity":"Quantity","ConditionDefinition.publisher":"string","ConditionDefinition.questionnaire":"BackboneElement","ConditionDefinition.questionnaire.extension":"Extension","ConditionDefinition.questionnaire.id":"System.String","ConditionDefinition.questionnaire.modifierExtension":"Extension","ConditionDefinition.questionnaire.purpose":"code","ConditionDefinition.questionnaire.reference":"Reference","ConditionDefinition.severity":"CodeableConcept","ConditionDefinition.stage":"CodeableConcept","ConditionDefinition.status":"code","ConditionDefinition.subtitle":"string","ConditionDefinition.team":"Reference","ConditionDefinition.text":"Narrative","ConditionDefinition.title":"string","ConditionDefinition.url":"uri","ConditionDefinition.useContext":"UsageContext","ConditionDefinition.version":"string","ConditionDefinition.versionAlgorithmCoding":"Coding","ConditionDefinition.versionAlgorithmString":"string","Consent.category":"CodeableConcept","Consent.contained":"Resource","Consent.controller":"Reference","Consent.date":"date","Consent.decision":"code","Consent.extension":"Extension","Consent.grantee":"Reference","Consent.grantor":"Reference","Consent.id":"System.String","Consent.identifier":"Identifier","Consent.implicitRules":"uri","Consent.language":"code","Consent.manager":"Reference","Consent.meta":"Meta","Consent.modifierExtension":"Extension","Consent.period":"Period","Consent.policyBasis":"BackboneElement","Consent.policyBasis.extension":"Extension","Consent.policyBasis.id":"System.String","Consent.policyBasis.modifierExtension":"Extension","Consent.policyBasis.reference":"Reference","Consent.policyBasis.url":"url","Consent.policyText":"Reference","Consent.provision":"BackboneElement","Consent.provision.action":"CodeableConcept","Consent.provision.actor":"BackboneElement","Consent.provision.actor.extension":"Extension","Consent.provision.actor.id":"System.String","Consent.provision.actor.modifierExtension":"Extension","Consent.provision.actor.reference":"Reference","Consent.provision.actor.role":"CodeableConcept","Consent.provision.code":"CodeableConcept","Consent.provision.data":"BackboneElement","Consent.provision.data.extension":"Extension","Consent.provision.data.id":"System.String","Consent.provision.data.meaning":"code","Consent.provision.data.modifierExtension":"Extension","Consent.provision.data.reference":"Reference","Consent.provision.dataPeriod":"Period","Consent.provision.documentType":"Coding","Consent.provision.expression":"Expression","Consent.provision.extension":"Extension","Consent.provision.id":"System.String","Consent.provision.modifierExtension":"Extension","Consent.provision.period":"Period","Consent.provision.purpose":"Coding","Consent.provision.resourceType":"Coding","Consent.provision.securityLabel":"Coding","Consent.regulatoryBasis":"CodeableConcept","Consent.sourceAttachment":"Attachment","Consent.sourceReference":"Reference","Consent.status":"code","Consent.subject":"Reference","Consent.text":"Narrative","Consent.verification":"BackboneElement","Consent.verification.extension":"Extension","Consent.verification.id":"System.String","Consent.verification.modifierExtension":"Extension","Consent.verification.verificationDate":"dateTime","Consent.verification.verificationType":"CodeableConcept","Consent.verification.verified":"boolean","Consent.verification.verifiedBy":"Reference","Consent.verification.verifiedWith":"Reference","ContactDetail.extension":"Extension","ContactDetail.id":"System.String","ContactDetail.name":"string","ContactDetail.telecom":"ContactPoint","ContactPoint.extension":"Extension","ContactPoint.id":"System.String","ContactPoint.period":"Period","ContactPoint.rank":"positiveInt","ContactPoint.system":"code","ContactPoint.use":"code","ContactPoint.value":"string","Contract.alias":"string","Contract.applies":"Period","Contract.author":"Reference","Contract.authority":"Reference","Contract.contained":"Resource","Contract.contentDefinition":"BackboneElement","Contract.contentDefinition.copyright":"markdown","Contract.contentDefinition.extension":"Extension","Contract.contentDefinition.id":"System.String","Contract.contentDefinition.modifierExtension":"Extension","Contract.contentDefinition.publicationDate":"dateTime","Contract.contentDefinition.publicationStatus":"code","Contract.contentDefinition.publisher":"Reference","Contract.contentDefinition.subType":"CodeableConcept","Contract.contentDefinition.type":"CodeableConcept","Contract.contentDerivative":"CodeableConcept","Contract.domain":"Reference","Contract.expirationType":"CodeableConcept","Contract.extension":"Extension","Contract.friendly":"BackboneElement","Contract.friendly.contentAttachment":"Attachment","Contract.friendly.contentReference":"Reference","Contract.friendly.extension":"Extension","Contract.friendly.id":"System.String","Contract.friendly.modifierExtension":"Extension","Contract.id":"System.String","Contract.identifier":"Identifier","Contract.implicitRules":"uri","Contract.instantiatesCanonical":"Reference","Contract.instantiatesUri":"uri","Contract.issued":"dateTime","Contract.language":"code","Contract.legal":"BackboneElement","Contract.legal.contentAttachment":"Attachment","Contract.legal.contentReference":"Reference","Contract.legal.extension":"Extension","Contract.legal.id":"System.String","Contract.legal.modifierExtension":"Extension","Contract.legalState":"CodeableConcept","Contract.legallyBindingAttachment":"Attachment","Contract.legallyBindingReference":"Reference","Contract.meta":"Meta","Contract.modifierExtension":"Extension","Contract.name":"string","Contract.relevantHistory":"Reference","Contract.rule":"BackboneElement","Contract.rule.contentAttachment":"Attachment","Contract.rule.contentReference":"Reference","Contract.rule.extension":"Extension","Contract.rule.id":"System.String","Contract.rule.modifierExtension":"Extension","Contract.scope":"CodeableConcept","Contract.signer":"BackboneElement","Contract.signer.extension":"Extension","Contract.signer.id":"System.String","Contract.signer.modifierExtension":"Extension","Contract.signer.party":"Reference","Contract.signer.signature":"Signature","Contract.signer.type":"Coding","Contract.site":"Reference","Contract.status":"code","Contract.subType":"CodeableConcept","Contract.subject":"Reference","Contract.subtitle":"string","Contract.supportingInfo":"Reference","Contract.term":"BackboneElement","Contract.term.action":"BackboneElement","Contract.term.action.context":"Reference","Contract.term.action.contextLinkId":"string","Contract.term.action.doNotPerform":"boolean","Contract.term.action.extension":"Extension","Contract.term.action.id":"System.String","Contract.term.action.intent":"CodeableConcept","Contract.term.action.linkId":"string","Contract.term.action.modifierExtension":"Extension","Contract.term.action.note":"Annotation","Contract.term.action.occurrenceDateTime":"dateTime","Contract.term.action.occurrencePeriod":"Period","Contract.term.action.occurrenceTiming":"Timing","Contract.term.action.performer":"Reference","Contract.term.action.performerLinkId":"string","Contract.term.action.performerRole":"CodeableConcept","Contract.term.action.performerType":"CodeableConcept","Contract.term.action.reason":"CodeableReference","Contract.term.action.reasonLinkId":"string","Contract.term.action.requester":"Reference","Contract.term.action.requesterLinkId":"string","Contract.term.action.securityLabelNumber":"unsignedInt","Contract.term.action.status":"CodeableConcept","Contract.term.action.subject":"BackboneElement","Contract.term.action.subject.extension":"Extension","Contract.term.action.subject.id":"System.String","Contract.term.action.subject.modifierExtension":"Extension","Contract.term.action.subject.reference":"Reference","Contract.term.action.subject.role":"CodeableConcept","Contract.term.action.type":"CodeableConcept","Contract.term.applies":"Period","Contract.term.asset":"BackboneElement","Contract.term.asset.condition":"string","Contract.term.asset.context":"BackboneElement","Contract.term.asset.context.code":"CodeableConcept","Contract.term.asset.context.extension":"Extension","Contract.term.asset.context.id":"System.String","Contract.term.asset.context.modifierExtension":"Extension","Contract.term.asset.context.reference":"Reference","Contract.term.asset.context.text":"string","Contract.term.asset.extension":"Extension","Contract.term.asset.id":"System.String","Contract.term.asset.linkId":"string","Contract.term.asset.modifierExtension":"Extension","Contract.term.asset.period":"Period","Contract.term.asset.periodType":"CodeableConcept","Contract.term.asset.relationship":"Coding","Contract.term.asset.scope":"CodeableConcept","Contract.term.asset.securityLabelNumber":"unsignedInt","Contract.term.asset.subtype":"CodeableConcept","Contract.term.asset.text":"string","Contract.term.asset.type":"CodeableConcept","Contract.term.asset.typeReference":"Reference","Contract.term.asset.usePeriod":"Period","Contract.term.asset.valuedItem":"BackboneElement","Contract.term.asset.valuedItem.effectiveTime":"dateTime","Contract.term.asset.valuedItem.entityCodeableConcept":"CodeableConcept","Contract.term.asset.valuedItem.entityReference":"Reference","Contract.term.asset.valuedItem.extension":"Extension","Contract.term.asset.valuedItem.factor":"decimal","Contract.term.asset.valuedItem.id":"System.String","Contract.term.asset.valuedItem.identifier":"Identifier","Contract.term.asset.valuedItem.linkId":"string","Contract.term.asset.valuedItem.modifierExtension":"Extension","Contract.term.asset.valuedItem.net":"Money","Contract.term.asset.valuedItem.payment":"string","Contract.term.asset.valuedItem.paymentDate":"dateTime","Contract.term.asset.valuedItem.points":"decimal","Contract.term.asset.valuedItem.quantity":"Quantity","Contract.term.asset.valuedItem.recipient":"Reference","Contract.term.asset.valuedItem.responsible":"Reference","Contract.term.asset.valuedItem.securityLabelNumber":"unsignedInt","Contract.term.asset.valuedItem.unitPrice":"Money","Contract.term.extension":"Extension","Contract.term.id":"System.String","Contract.term.identifier":"Identifier","Contract.term.issued":"dateTime","Contract.term.modifierExtension":"Extension","Contract.term.offer":"BackboneElement","Contract.term.offer.answer":"BackboneElement","Contract.term.offer.answer.extension":"Extension","Contract.term.offer.answer.id":"System.String","Contract.term.offer.answer.modifierExtension":"Extension","Contract.term.offer.answer.valueAttachment":"Attachment","Contract.term.offer.answer.valueBoolean":"boolean","Contract.term.offer.answer.valueCoding":"Coding","Contract.term.offer.answer.valueDate":"date","Contract.term.offer.answer.valueDateTime":"dateTime","Contract.term.offer.answer.valueDecimal":"decimal","Contract.term.offer.answer.valueInteger":"integer","Contract.term.offer.answer.valueQuantity":"Quantity","Contract.term.offer.answer.valueReference":"Reference","Contract.term.offer.answer.valueString":"string","Contract.term.offer.answer.valueTime":"time","Contract.term.offer.answer.valueUri":"uri","Contract.term.offer.decision":"CodeableConcept","Contract.term.offer.decisionMode":"CodeableConcept","Contract.term.offer.extension":"Extension","Contract.term.offer.id":"System.String","Contract.term.offer.identifier":"Identifier","Contract.term.offer.linkId":"string","Contract.term.offer.modifierExtension":"Extension","Contract.term.offer.party":"BackboneElement","Contract.term.offer.party.extension":"Extension","Contract.term.offer.party.id":"System.String","Contract.term.offer.party.modifierExtension":"Extension","Contract.term.offer.party.reference":"Reference","Contract.term.offer.party.role":"CodeableConcept","Contract.term.offer.securityLabelNumber":"unsignedInt","Contract.term.offer.text":"string","Contract.term.offer.topic":"Reference","Contract.term.offer.type":"CodeableConcept","Contract.term.securityLabel":"BackboneElement","Contract.term.securityLabel.category":"Coding","Contract.term.securityLabel.classification":"Coding","Contract.term.securityLabel.control":"Coding","Contract.term.securityLabel.extension":"Extension","Contract.term.securityLabel.id":"System.String","Contract.term.securityLabel.modifierExtension":"Extension","Contract.term.securityLabel.number":"unsignedInt","Contract.term.subType":"CodeableConcept","Contract.term.text":"string","Contract.term.topicCodeableConcept":"CodeableConcept","Contract.term.topicReference":"Reference","Contract.term.type":"CodeableConcept","Contract.text":"Narrative","Contract.title":"string","Contract.topicCodeableConcept":"CodeableConcept","Contract.topicReference":"Reference","Contract.type":"CodeableConcept","Contract.url":"uri","Contract.version":"string","Contributor.contact":"ContactDetail","Contributor.extension":"Extension","Contributor.id":"System.String","Contributor.name":"string","Contributor.type":"code","Count.code":"code","Count.comparator":"code","Count.extension":"Extension","Count.id":"System.String","Count.system":"uri","Count.unit":"string","Count.value":"decimal","Coverage.beneficiary":"Reference","Coverage.class":"BackboneElement","Coverage.class.extension":"Extension","Coverage.class.id":"System.String","Coverage.class.modifierExtension":"Extension","Coverage.class.name":"string","Coverage.class.type":"CodeableConcept","Coverage.class.value":"Identifier","Coverage.contained":"Resource","Coverage.contract":"Reference","Coverage.costToBeneficiary":"BackboneElement","Coverage.costToBeneficiary.category":"CodeableConcept","Coverage.costToBeneficiary.exception":"BackboneElement","Coverage.costToBeneficiary.exception.extension":"Extension","Coverage.costToBeneficiary.exception.id":"System.String","Coverage.costToBeneficiary.exception.modifierExtension":"Extension","Coverage.costToBeneficiary.exception.period":"Period","Coverage.costToBeneficiary.exception.type":"CodeableConcept","Coverage.costToBeneficiary.extension":"Extension","Coverage.costToBeneficiary.id":"System.String","Coverage.costToBeneficiary.modifierExtension":"Extension","Coverage.costToBeneficiary.network":"CodeableConcept","Coverage.costToBeneficiary.term":"CodeableConcept","Coverage.costToBeneficiary.type":"CodeableConcept","Coverage.costToBeneficiary.unit":"CodeableConcept","Coverage.costToBeneficiary.valueMoney":"Money","Coverage.costToBeneficiary.valueQuantity":"Quantity","Coverage.dependent":"string","Coverage.extension":"Extension","Coverage.id":"System.String","Coverage.identifier":"Identifier","Coverage.implicitRules":"uri","Coverage.insurancePlan":"Reference","Coverage.insurer":"Reference","Coverage.kind":"code","Coverage.language":"code","Coverage.meta":"Meta","Coverage.modifierExtension":"Extension","Coverage.network":"string","Coverage.order":"positiveInt","Coverage.paymentBy":"BackboneElement","Coverage.paymentBy.extension":"Extension","Coverage.paymentBy.id":"System.String","Coverage.paymentBy.modifierExtension":"Extension","Coverage.paymentBy.party":"Reference","Coverage.paymentBy.responsibility":"string","Coverage.period":"Period","Coverage.policyHolder":"Reference","Coverage.relationship":"CodeableConcept","Coverage.status":"code","Coverage.subrogation":"boolean","Coverage.subscriber":"Reference","Coverage.subscriberId":"Identifier","Coverage.text":"Narrative","Coverage.type":"CodeableConcept","CoverageEligibilityRequest.contained":"Resource","CoverageEligibilityRequest.created":"dateTime","CoverageEligibilityRequest.enterer":"Reference","CoverageEligibilityRequest.event":"BackboneElement","CoverageEligibilityRequest.event.extension":"Extension","CoverageEligibilityRequest.event.id":"System.String","CoverageEligibilityRequest.event.modifierExtension":"Extension","CoverageEligibilityRequest.event.type":"CodeableConcept","CoverageEligibilityRequest.event.whenDateTime":"dateTime","CoverageEligibilityRequest.event.whenPeriod":"Period","CoverageEligibilityRequest.extension":"Extension","CoverageEligibilityRequest.facility":"Reference","CoverageEligibilityRequest.id":"System.String","CoverageEligibilityRequest.identifier":"Identifier","CoverageEligibilityRequest.implicitRules":"uri","CoverageEligibilityRequest.insurance":"BackboneElement","CoverageEligibilityRequest.insurance.businessArrangement":"string","CoverageEligibilityRequest.insurance.coverage":"Reference","CoverageEligibilityRequest.insurance.extension":"Extension","CoverageEligibilityRequest.insurance.focal":"boolean","CoverageEligibilityRequest.insurance.id":"System.String","CoverageEligibilityRequest.insurance.modifierExtension":"Extension","CoverageEligibilityRequest.insurer":"Reference","CoverageEligibilityRequest.item":"BackboneElement","CoverageEligibilityRequest.item.category":"CodeableConcept","CoverageEligibilityRequest.item.detail":"Reference","CoverageEligibilityRequest.item.diagnosis":"BackboneElement","CoverageEligibilityRequest.item.diagnosis.diagnosisCodeableConcept":"CodeableConcept","CoverageEligibilityRequest.item.diagnosis.diagnosisReference":"Reference","CoverageEligibilityRequest.item.diagnosis.extension":"Extension","CoverageEligibilityRequest.item.diagnosis.id":"System.String","CoverageEligibilityRequest.item.diagnosis.modifierExtension":"Extension","CoverageEligibilityRequest.item.extension":"Extension","CoverageEligibilityRequest.item.facility":"Reference","CoverageEligibilityRequest.item.id":"System.String","CoverageEligibilityRequest.item.modifier":"CodeableConcept","CoverageEligibilityRequest.item.modifierExtension":"Extension","CoverageEligibilityRequest.item.productOrService":"CodeableConcept","CoverageEligibilityRequest.item.provider":"Reference","CoverageEligibilityRequest.item.quantity":"Quantity","CoverageEligibilityRequest.item.supportingInfoSequence":"positiveInt","CoverageEligibilityRequest.item.unitPrice":"Money","CoverageEligibilityRequest.language":"code","CoverageEligibilityRequest.meta":"Meta","CoverageEligibilityRequest.modifierExtension":"Extension","CoverageEligibilityRequest.patient":"Reference","CoverageEligibilityRequest.priority":"CodeableConcept","CoverageEligibilityRequest.provider":"Reference","CoverageEligibilityRequest.purpose":"code","CoverageEligibilityRequest.servicedDate":"date","CoverageEligibilityRequest.servicedPeriod":"Period","CoverageEligibilityRequest.status":"code","CoverageEligibilityRequest.supportingInfo":"BackboneElement","CoverageEligibilityRequest.supportingInfo.appliesToAll":"boolean","CoverageEligibilityRequest.supportingInfo.extension":"Extension","CoverageEligibilityRequest.supportingInfo.id":"System.String","CoverageEligibilityRequest.supportingInfo.information":"Reference","CoverageEligibilityRequest.supportingInfo.modifierExtension":"Extension","CoverageEligibilityRequest.supportingInfo.sequence":"positiveInt","CoverageEligibilityRequest.text":"Narrative","CoverageEligibilityResponse.contained":"Resource","CoverageEligibilityResponse.created":"dateTime","CoverageEligibilityResponse.disposition":"string","CoverageEligibilityResponse.error":"BackboneElement","CoverageEligibilityResponse.error.code":"CodeableConcept","CoverageEligibilityResponse.error.expression":"string","CoverageEligibilityResponse.error.extension":"Extension","CoverageEligibilityResponse.error.id":"System.String","CoverageEligibilityResponse.error.modifierExtension":"Extension","CoverageEligibilityResponse.event":"BackboneElement","CoverageEligibilityResponse.event.extension":"Extension","CoverageEligibilityResponse.event.id":"System.String","CoverageEligibilityResponse.event.modifierExtension":"Extension","CoverageEligibilityResponse.event.type":"CodeableConcept","CoverageEligibilityResponse.event.whenDateTime":"dateTime","CoverageEligibilityResponse.event.whenPeriod":"Period","CoverageEligibilityResponse.extension":"Extension","CoverageEligibilityResponse.form":"CodeableConcept","CoverageEligibilityResponse.id":"System.String","CoverageEligibilityResponse.identifier":"Identifier","CoverageEligibilityResponse.implicitRules":"uri","CoverageEligibilityResponse.insurance":"BackboneElement","CoverageEligibilityResponse.insurance.benefitPeriod":"Period","CoverageEligibilityResponse.insurance.coverage":"Reference","CoverageEligibilityResponse.insurance.extension":"Extension","CoverageEligibilityResponse.insurance.id":"System.String","CoverageEligibilityResponse.insurance.inforce":"boolean","CoverageEligibilityResponse.insurance.item":"BackboneElement","CoverageEligibilityResponse.insurance.item.authorizationRequired":"boolean","CoverageEligibilityResponse.insurance.item.authorizationSupporting":"CodeableConcept","CoverageEligibilityResponse.insurance.item.authorizationUrl":"uri","CoverageEligibilityResponse.insurance.item.benefit":"BackboneElement","CoverageEligibilityResponse.insurance.item.benefit.allowedMoney":"Money","CoverageEligibilityResponse.insurance.item.benefit.allowedString":"string","CoverageEligibilityResponse.insurance.item.benefit.allowedUnsignedInt":"unsignedInt","CoverageEligibilityResponse.insurance.item.benefit.extension":"Extension","CoverageEligibilityResponse.insurance.item.benefit.id":"System.String","CoverageEligibilityResponse.insurance.item.benefit.modifierExtension":"Extension","CoverageEligibilityResponse.insurance.item.benefit.type":"CodeableConcept","CoverageEligibilityResponse.insurance.item.benefit.usedMoney":"Money","CoverageEligibilityResponse.insurance.item.benefit.usedString":"string","CoverageEligibilityResponse.insurance.item.benefit.usedUnsignedInt":"unsignedInt","CoverageEligibilityResponse.insurance.item.category":"CodeableConcept","CoverageEligibilityResponse.insurance.item.description":"string","CoverageEligibilityResponse.insurance.item.excluded":"boolean","CoverageEligibilityResponse.insurance.item.extension":"Extension","CoverageEligibilityResponse.insurance.item.id":"System.String","CoverageEligibilityResponse.insurance.item.modifier":"CodeableConcept","CoverageEligibilityResponse.insurance.item.modifierExtension":"Extension","CoverageEligibilityResponse.insurance.item.name":"string","CoverageEligibilityResponse.insurance.item.network":"CodeableConcept","CoverageEligibilityResponse.insurance.item.productOrService":"CodeableConcept","CoverageEligibilityResponse.insurance.item.provider":"Reference","CoverageEligibilityResponse.insurance.item.term":"CodeableConcept","CoverageEligibilityResponse.insurance.item.unit":"CodeableConcept","CoverageEligibilityResponse.insurance.modifierExtension":"Extension","CoverageEligibilityResponse.insurer":"Reference","CoverageEligibilityResponse.language":"code","CoverageEligibilityResponse.meta":"Meta","CoverageEligibilityResponse.modifierExtension":"Extension","CoverageEligibilityResponse.outcome":"code","CoverageEligibilityResponse.patient":"Reference","CoverageEligibilityResponse.preAuthRef":"string","CoverageEligibilityResponse.purpose":"code","CoverageEligibilityResponse.request":"Reference","CoverageEligibilityResponse.requestor":"Reference","CoverageEligibilityResponse.servicedDate":"date","CoverageEligibilityResponse.servicedPeriod":"Period","CoverageEligibilityResponse.status":"code","CoverageEligibilityResponse.text":"Narrative","DataRequirement.codeFilter":"Element","DataRequirement.codeFilter.code":"Coding","DataRequirement.codeFilter.extension":"Extension","DataRequirement.codeFilter.id":"System.String","DataRequirement.codeFilter.path":"string","DataRequirement.codeFilter.searchParam":"string","DataRequirement.codeFilter.valueSet":"canonical","DataRequirement.dateFilter":"Element","DataRequirement.dateFilter.extension":"Extension","DataRequirement.dateFilter.id":"System.String","DataRequirement.dateFilter.path":"string","DataRequirement.dateFilter.searchParam":"string","DataRequirement.dateFilter.valueDateTime":"dateTime","DataRequirement.dateFilter.valueDuration":"Duration","DataRequirement.dateFilter.valuePeriod":"Period","DataRequirement.extension":"Extension","DataRequirement.id":"System.String","DataRequirement.limit":"positiveInt","DataRequirement.mustSupport":"string","DataRequirement.profile":"canonical","DataRequirement.sort":"Element","DataRequirement.sort.direction":"code","DataRequirement.sort.extension":"Extension","DataRequirement.sort.id":"System.String","DataRequirement.sort.path":"string","DataRequirement.subjectCodeableConcept":"CodeableConcept","DataRequirement.subjectReference":"Reference","DataRequirement.type":"code","DataRequirement.valueFilter":"Element","DataRequirement.valueFilter.comparator":"code","DataRequirement.valueFilter.extension":"Extension","DataRequirement.valueFilter.id":"System.String","DataRequirement.valueFilter.path":"string","DataRequirement.valueFilter.searchParam":"string","DataRequirement.valueFilter.valueDateTime":"dateTime","DataRequirement.valueFilter.valueDuration":"Duration","DataRequirement.valueFilter.valuePeriod":"Period","DataType.extension":"Extension","DataType.id":"System.String","DetectedIssue.author":"Reference","DetectedIssue.category":"CodeableConcept","DetectedIssue.code":"CodeableConcept","DetectedIssue.contained":"Resource","DetectedIssue.detail":"markdown","DetectedIssue.encounter":"Reference","DetectedIssue.evidence":"BackboneElement","DetectedIssue.evidence.code":"CodeableConcept","DetectedIssue.evidence.detail":"Reference","DetectedIssue.evidence.extension":"Extension","DetectedIssue.evidence.id":"System.String","DetectedIssue.evidence.modifierExtension":"Extension","DetectedIssue.extension":"Extension","DetectedIssue.id":"System.String","DetectedIssue.identifiedDateTime":"dateTime","DetectedIssue.identifiedPeriod":"Period","DetectedIssue.identifier":"Identifier","DetectedIssue.implicated":"Reference","DetectedIssue.implicitRules":"uri","DetectedIssue.language":"code","DetectedIssue.meta":"Meta","DetectedIssue.mitigation":"BackboneElement","DetectedIssue.mitigation.action":"CodeableConcept","DetectedIssue.mitigation.author":"Reference","DetectedIssue.mitigation.date":"dateTime","DetectedIssue.mitigation.extension":"Extension","DetectedIssue.mitigation.id":"System.String","DetectedIssue.mitigation.modifierExtension":"Extension","DetectedIssue.mitigation.note":"Annotation","DetectedIssue.modifierExtension":"Extension","DetectedIssue.reference":"uri","DetectedIssue.severity":"code","DetectedIssue.status":"code","DetectedIssue.subject":"Reference","DetectedIssue.text":"Narrative","Device.availabilityStatus":"CodeableConcept","Device.biologicalSourceEvent":"Identifier","Device.category":"CodeableConcept","Device.conformsTo":"BackboneElement","Device.conformsTo.category":"CodeableConcept","Device.conformsTo.extension":"Extension","Device.conformsTo.id":"System.String","Device.conformsTo.modifierExtension":"Extension","Device.conformsTo.specification":"CodeableConcept","Device.conformsTo.version":"string","Device.contact":"ContactPoint","Device.contained":"Resource","Device.cycle":"Count","Device.definition":"CodeableReference","Device.displayName":"string","Device.duration":"Duration","Device.endpoint":"Reference","Device.expirationDate":"dateTime","Device.extension":"Extension","Device.gateway":"CodeableReference","Device.id":"System.String","Device.identifier":"Identifier","Device.implicitRules":"uri","Device.language":"code","Device.location":"Reference","Device.lotNumber":"string","Device.manufactureDate":"dateTime","Device.manufacturer":"string","Device.meta":"Meta","Device.mode":"CodeableConcept","Device.modelNumber":"string","Device.modifierExtension":"Extension","Device.name":"BackboneElement","Device.name.display":"boolean","Device.name.extension":"Extension","Device.name.id":"System.String","Device.name.modifierExtension":"Extension","Device.name.type":"code","Device.name.value":"string","Device.note":"Annotation","Device.owner":"Reference","Device.parent":"Reference","Device.partNumber":"string","Device.property":"BackboneElement","Device.property.extension":"Extension","Device.property.id":"System.String","Device.property.modifierExtension":"Extension","Device.property.type":"CodeableConcept","Device.property.valueAttachment":"Attachment","Device.property.valueBoolean":"boolean","Device.property.valueCodeableConcept":"CodeableConcept","Device.property.valueInteger":"integer","Device.property.valueQuantity":"Quantity","Device.property.valueRange":"Range","Device.property.valueString":"string","Device.safety":"CodeableConcept","Device.serialNumber":"string","Device.status":"code","Device.text":"Narrative","Device.type":"CodeableConcept","Device.udiCarrier":"BackboneElement","Device.udiCarrier.carrierAIDC":"base64Binary","Device.udiCarrier.carrierHRF":"string","Device.udiCarrier.deviceIdentifier":"string","Device.udiCarrier.entryType":"code","Device.udiCarrier.extension":"Extension","Device.udiCarrier.id":"System.String","Device.udiCarrier.issuer":"uri","Device.udiCarrier.jurisdiction":"uri","Device.udiCarrier.modifierExtension":"Extension","Device.url":"uri","Device.version":"BackboneElement","Device.version.component":"Identifier","Device.version.extension":"Extension","Device.version.id":"System.String","Device.version.installDate":"dateTime","Device.version.modifierExtension":"Extension","Device.version.type":"CodeableConcept","Device.version.value":"string","DeviceAssociation.bodyStructure":"Reference","DeviceAssociation.category":"CodeableConcept","DeviceAssociation.contained":"Resource","DeviceAssociation.device":"Reference","DeviceAssociation.extension":"Extension","DeviceAssociation.id":"System.String","DeviceAssociation.identifier":"Identifier","DeviceAssociation.implicitRules":"uri","DeviceAssociation.language":"code","DeviceAssociation.meta":"Meta","DeviceAssociation.modifierExtension":"Extension","DeviceAssociation.operation":"BackboneElement","DeviceAssociation.operation.extension":"Extension","DeviceAssociation.operation.id":"System.String","DeviceAssociation.operation.modifierExtension":"Extension","DeviceAssociation.operation.operator":"Reference","DeviceAssociation.operation.period":"Period","DeviceAssociation.operation.status":"CodeableConcept","DeviceAssociation.period":"Period","DeviceAssociation.status":"CodeableConcept","DeviceAssociation.statusReason":"CodeableConcept","DeviceAssociation.subject":"Reference","DeviceAssociation.text":"Narrative","DeviceDefinition.chargeItem":"BackboneElement","DeviceDefinition.chargeItem.chargeItemCode":"CodeableReference","DeviceDefinition.chargeItem.count":"Quantity","DeviceDefinition.chargeItem.effectivePeriod":"Period","DeviceDefinition.chargeItem.extension":"Extension","DeviceDefinition.chargeItem.id":"System.String","DeviceDefinition.chargeItem.modifierExtension":"Extension","DeviceDefinition.chargeItem.useContext":"UsageContext","DeviceDefinition.classification":"BackboneElement","DeviceDefinition.classification.extension":"Extension","DeviceDefinition.classification.id":"System.String","DeviceDefinition.classification.justification":"RelatedArtifact","DeviceDefinition.classification.modifierExtension":"Extension","DeviceDefinition.classification.type":"CodeableConcept","DeviceDefinition.conformsTo":"BackboneElement","DeviceDefinition.conformsTo.category":"CodeableConcept","DeviceDefinition.conformsTo.extension":"Extension","DeviceDefinition.conformsTo.id":"System.String","DeviceDefinition.conformsTo.modifierExtension":"Extension","DeviceDefinition.conformsTo.source":"RelatedArtifact","DeviceDefinition.conformsTo.specification":"CodeableConcept","DeviceDefinition.conformsTo.version":"string","DeviceDefinition.contact":"ContactPoint","DeviceDefinition.contained":"Resource","DeviceDefinition.correctiveAction":"BackboneElement","DeviceDefinition.correctiveAction.extension":"Extension","DeviceDefinition.correctiveAction.id":"System.String","DeviceDefinition.correctiveAction.modifierExtension":"Extension","DeviceDefinition.correctiveAction.period":"Period","DeviceDefinition.correctiveAction.recall":"boolean","DeviceDefinition.correctiveAction.scope":"code","DeviceDefinition.description":"markdown","DeviceDefinition.deviceName":"BackboneElement","DeviceDefinition.deviceName.extension":"Extension","DeviceDefinition.deviceName.id":"System.String","DeviceDefinition.deviceName.modifierExtension":"Extension","DeviceDefinition.deviceName.name":"string","DeviceDefinition.deviceName.type":"code","DeviceDefinition.extension":"Extension","DeviceDefinition.guideline":"BackboneElement","DeviceDefinition.guideline.contraindication":"CodeableConcept","DeviceDefinition.guideline.extension":"Extension","DeviceDefinition.guideline.id":"System.String","DeviceDefinition.guideline.indication":"CodeableConcept","DeviceDefinition.guideline.intendedUse":"string","DeviceDefinition.guideline.modifierExtension":"Extension","DeviceDefinition.guideline.relatedArtifact":"RelatedArtifact","DeviceDefinition.guideline.usageInstruction":"markdown","DeviceDefinition.guideline.useContext":"UsageContext","DeviceDefinition.guideline.warning":"CodeableConcept","DeviceDefinition.hasPart":"BackboneElement","DeviceDefinition.hasPart.count":"integer","DeviceDefinition.hasPart.extension":"Extension","DeviceDefinition.hasPart.id":"System.String","DeviceDefinition.hasPart.modifierExtension":"Extension","DeviceDefinition.hasPart.reference":"Reference","DeviceDefinition.id":"System.String","DeviceDefinition.identifier":"Identifier","DeviceDefinition.implicitRules":"uri","DeviceDefinition.language":"code","DeviceDefinition.languageCode":"CodeableConcept","DeviceDefinition.link":"BackboneElement","DeviceDefinition.link.extension":"Extension","DeviceDefinition.link.id":"System.String","DeviceDefinition.link.modifierExtension":"Extension","DeviceDefinition.link.relatedDevice":"CodeableReference","DeviceDefinition.link.relation":"Coding","DeviceDefinition.manufacturer":"Reference","DeviceDefinition.material":"BackboneElement","DeviceDefinition.material.allergenicIndicator":"boolean","DeviceDefinition.material.alternate":"boolean","DeviceDefinition.material.extension":"Extension","DeviceDefinition.material.id":"System.String","DeviceDefinition.material.modifierExtension":"Extension","DeviceDefinition.material.substance":"CodeableConcept","DeviceDefinition.meta":"Meta","DeviceDefinition.modelNumber":"string","DeviceDefinition.modifierExtension":"Extension","DeviceDefinition.note":"Annotation","DeviceDefinition.owner":"Reference","DeviceDefinition.packaging":"BackboneElement","DeviceDefinition.packaging.count":"integer","DeviceDefinition.packaging.distributor":"BackboneElement","DeviceDefinition.packaging.distributor.extension":"Extension","DeviceDefinition.packaging.distributor.id":"System.String","DeviceDefinition.packaging.distributor.modifierExtension":"Extension","DeviceDefinition.packaging.distributor.name":"string","DeviceDefinition.packaging.distributor.organizationReference":"Reference","DeviceDefinition.packaging.extension":"Extension","DeviceDefinition.packaging.id":"System.String","DeviceDefinition.packaging.identifier":"Identifier","DeviceDefinition.packaging.modifierExtension":"Extension","DeviceDefinition.packaging.type":"CodeableConcept","DeviceDefinition.partNumber":"string","DeviceDefinition.productionIdentifierInUDI":"code","DeviceDefinition.property":"BackboneElement","DeviceDefinition.property.extension":"Extension","DeviceDefinition.property.id":"System.String","DeviceDefinition.property.modifierExtension":"Extension","DeviceDefinition.property.type":"CodeableConcept","DeviceDefinition.property.valueAttachment":"Attachment","DeviceDefinition.property.valueBoolean":"boolean","DeviceDefinition.property.valueCodeableConcept":"CodeableConcept","DeviceDefinition.property.valueInteger":"integer","DeviceDefinition.property.valueQuantity":"Quantity","DeviceDefinition.property.valueRange":"Range","DeviceDefinition.property.valueString":"string","DeviceDefinition.regulatoryIdentifier":"BackboneElement","DeviceDefinition.regulatoryIdentifier.deviceIdentifier":"string","DeviceDefinition.regulatoryIdentifier.extension":"Extension","DeviceDefinition.regulatoryIdentifier.id":"System.String","DeviceDefinition.regulatoryIdentifier.issuer":"uri","DeviceDefinition.regulatoryIdentifier.jurisdiction":"uri","DeviceDefinition.regulatoryIdentifier.modifierExtension":"Extension","DeviceDefinition.regulatoryIdentifier.type":"code","DeviceDefinition.safety":"CodeableConcept","DeviceDefinition.shelfLifeStorage":"ProductShelfLife","DeviceDefinition.text":"Narrative","DeviceDefinition.udiDeviceIdentifier":"BackboneElement","DeviceDefinition.udiDeviceIdentifier.deviceIdentifier":"string","DeviceDefinition.udiDeviceIdentifier.extension":"Extension","DeviceDefinition.udiDeviceIdentifier.id":"System.String","DeviceDefinition.udiDeviceIdentifier.issuer":"uri","DeviceDefinition.udiDeviceIdentifier.jurisdiction":"uri","DeviceDefinition.udiDeviceIdentifier.marketDistribution":"BackboneElement","DeviceDefinition.udiDeviceIdentifier.marketDistribution.extension":"Extension","DeviceDefinition.udiDeviceIdentifier.marketDistribution.id":"System.String","DeviceDefinition.udiDeviceIdentifier.marketDistribution.marketPeriod":"Period","DeviceDefinition.udiDeviceIdentifier.marketDistribution.modifierExtension":"Extension","DeviceDefinition.udiDeviceIdentifier.marketDistribution.subJurisdiction":"uri","DeviceDefinition.udiDeviceIdentifier.modifierExtension":"Extension","DeviceDefinition.version":"BackboneElement","DeviceDefinition.version.component":"Identifier","DeviceDefinition.version.extension":"Extension","DeviceDefinition.version.id":"System.String","DeviceDefinition.version.modifierExtension":"Extension","DeviceDefinition.version.type":"CodeableConcept","DeviceDefinition.version.value":"string","DeviceDispense.basedOn":"Reference","DeviceDispense.category":"CodeableConcept","DeviceDispense.contained":"Resource","DeviceDispense.destination":"Reference","DeviceDispense.device":"CodeableReference","DeviceDispense.encounter":"Reference","DeviceDispense.eventHistory":"Reference","DeviceDispense.extension":"Extension","DeviceDispense.id":"System.String","DeviceDispense.identifier":"Identifier","DeviceDispense.implicitRules":"uri","DeviceDispense.language":"code","DeviceDispense.location":"Reference","DeviceDispense.meta":"Meta","DeviceDispense.modifierExtension":"Extension","DeviceDispense.note":"Annotation","DeviceDispense.partOf":"Reference","DeviceDispense.performer":"BackboneElement","DeviceDispense.performer.actor":"Reference","DeviceDispense.performer.extension":"Extension","DeviceDispense.performer.function":"CodeableConcept","DeviceDispense.performer.id":"System.String","DeviceDispense.performer.modifierExtension":"Extension","DeviceDispense.preparedDate":"dateTime","DeviceDispense.quantity":"Quantity","DeviceDispense.receiver":"Reference","DeviceDispense.status":"code","DeviceDispense.statusReason":"CodeableReference","DeviceDispense.subject":"Reference","DeviceDispense.supportingInformation":"Reference","DeviceDispense.text":"Narrative","DeviceDispense.type":"CodeableConcept","DeviceDispense.usageInstruction":"markdown","DeviceDispense.whenHandedOver":"dateTime","DeviceMetric.calibration":"BackboneElement","DeviceMetric.calibration.extension":"Extension","DeviceMetric.calibration.id":"System.String","DeviceMetric.calibration.modifierExtension":"Extension","DeviceMetric.calibration.state":"code","DeviceMetric.calibration.time":"instant","DeviceMetric.calibration.type":"code","DeviceMetric.category":"code","DeviceMetric.color":"code","DeviceMetric.contained":"Resource","DeviceMetric.device":"Reference","DeviceMetric.extension":"Extension","DeviceMetric.id":"System.String","DeviceMetric.identifier":"Identifier","DeviceMetric.implicitRules":"uri","DeviceMetric.language":"code","DeviceMetric.measurementFrequency":"Quantity","DeviceMetric.meta":"Meta","DeviceMetric.modifierExtension":"Extension","DeviceMetric.operationalStatus":"code","DeviceMetric.text":"Narrative","DeviceMetric.type":"CodeableConcept","DeviceMetric.unit":"CodeableConcept","DeviceRequest.asNeeded":"boolean","DeviceRequest.asNeededFor":"CodeableConcept","DeviceRequest.authoredOn":"dateTime","DeviceRequest.basedOn":"Reference","DeviceRequest.code":"CodeableReference","DeviceRequest.contained":"Resource","DeviceRequest.doNotPerform":"boolean","DeviceRequest.encounter":"Reference","DeviceRequest.extension":"Extension","DeviceRequest.groupIdentifier":"Identifier","DeviceRequest.id":"System.String","DeviceRequest.identifier":"Identifier","DeviceRequest.implicitRules":"uri","DeviceRequest.instantiatesCanonical":"canonical","DeviceRequest.instantiatesUri":"uri","DeviceRequest.insurance":"Reference","DeviceRequest.intent":"code","DeviceRequest.language":"code","DeviceRequest.meta":"Meta","DeviceRequest.modifierExtension":"Extension","DeviceRequest.note":"Annotation","DeviceRequest.occurrenceDateTime":"dateTime","DeviceRequest.occurrencePeriod":"Period","DeviceRequest.occurrenceTiming":"Timing","DeviceRequest.parameter":"BackboneElement","DeviceRequest.parameter.code":"CodeableConcept","DeviceRequest.parameter.extension":"Extension","DeviceRequest.parameter.id":"System.String","DeviceRequest.parameter.modifierExtension":"Extension","DeviceRequest.parameter.valueBoolean":"boolean","DeviceRequest.parameter.valueCodeableConcept":"CodeableConcept","DeviceRequest.parameter.valueQuantity":"Quantity","DeviceRequest.parameter.valueRange":"Range","DeviceRequest.performer":"CodeableReference","DeviceRequest.priority":"code","DeviceRequest.quantity":"integer","DeviceRequest.reason":"CodeableReference","DeviceRequest.relevantHistory":"Reference","DeviceRequest.replaces":"Reference","DeviceRequest.requester":"Reference","DeviceRequest.status":"code","DeviceRequest.subject":"Reference","DeviceRequest.supportingInfo":"Reference","DeviceRequest.text":"Narrative","DeviceUsage.adherence":"BackboneElement","DeviceUsage.adherence.code":"CodeableConcept","DeviceUsage.adherence.extension":"Extension","DeviceUsage.adherence.id":"System.String","DeviceUsage.adherence.modifierExtension":"Extension","DeviceUsage.adherence.reason":"CodeableConcept","DeviceUsage.basedOn":"Reference","DeviceUsage.bodySite":"CodeableReference","DeviceUsage.category":"CodeableConcept","DeviceUsage.contained":"Resource","DeviceUsage.context":"Reference","DeviceUsage.dateAsserted":"dateTime","DeviceUsage.derivedFrom":"Reference","DeviceUsage.device":"CodeableReference","DeviceUsage.extension":"Extension","DeviceUsage.id":"System.String","DeviceUsage.identifier":"Identifier","DeviceUsage.implicitRules":"uri","DeviceUsage.informationSource":"Reference","DeviceUsage.language":"code","DeviceUsage.meta":"Meta","DeviceUsage.modifierExtension":"Extension","DeviceUsage.note":"Annotation","DeviceUsage.patient":"Reference","DeviceUsage.reason":"CodeableReference","DeviceUsage.status":"code","DeviceUsage.text":"Narrative","DeviceUsage.timingDateTime":"dateTime","DeviceUsage.timingPeriod":"Period","DeviceUsage.timingTiming":"Timing","DeviceUsage.usageReason":"CodeableConcept","DeviceUsage.usageStatus":"CodeableConcept","DiagnosticReport.basedOn":"Reference","DiagnosticReport.category":"CodeableConcept","DiagnosticReport.code":"CodeableConcept","DiagnosticReport.composition":"Reference","DiagnosticReport.conclusion":"markdown","DiagnosticReport.conclusionCode":"CodeableConcept","DiagnosticReport.contained":"Resource","DiagnosticReport.effectiveDateTime":"dateTime","DiagnosticReport.effectivePeriod":"Period","DiagnosticReport.encounter":"Reference","DiagnosticReport.extension":"Extension","DiagnosticReport.id":"System.String","DiagnosticReport.identifier":"Identifier","DiagnosticReport.implicitRules":"uri","DiagnosticReport.issued":"instant","DiagnosticReport.language":"code","DiagnosticReport.media":"BackboneElement","DiagnosticReport.media.comment":"string","DiagnosticReport.media.extension":"Extension","DiagnosticReport.media.id":"System.String","DiagnosticReport.media.link":"Reference","DiagnosticReport.media.modifierExtension":"Extension","DiagnosticReport.meta":"Meta","DiagnosticReport.modifierExtension":"Extension","DiagnosticReport.note":"Annotation","DiagnosticReport.performer":"Reference","DiagnosticReport.presentedForm":"Attachment","DiagnosticReport.result":"Reference","DiagnosticReport.resultsInterpreter":"Reference","DiagnosticReport.specimen":"Reference","DiagnosticReport.status":"code","DiagnosticReport.study":"Reference","DiagnosticReport.subject":"Reference","DiagnosticReport.supportingInfo":"BackboneElement","DiagnosticReport.supportingInfo.extension":"Extension","DiagnosticReport.supportingInfo.id":"System.String","DiagnosticReport.supportingInfo.modifierExtension":"Extension","DiagnosticReport.supportingInfo.reference":"Reference","DiagnosticReport.supportingInfo.type":"CodeableConcept","DiagnosticReport.text":"Narrative","Distance.code":"code","Distance.comparator":"code","Distance.extension":"Extension","Distance.id":"System.String","Distance.system":"uri","Distance.unit":"string","Distance.value":"decimal","DocumentReference.attester":"BackboneElement","DocumentReference.attester.extension":"Extension","DocumentReference.attester.id":"System.String","DocumentReference.attester.mode":"CodeableConcept","DocumentReference.attester.modifierExtension":"Extension","DocumentReference.attester.party":"Reference","DocumentReference.attester.time":"dateTime","DocumentReference.author":"Reference","DocumentReference.basedOn":"Reference","DocumentReference.bodySite":"CodeableReference","DocumentReference.category":"CodeableConcept","DocumentReference.contained":"Resource","DocumentReference.content":"BackboneElement","DocumentReference.content.attachment":"Attachment","DocumentReference.content.extension":"Extension","DocumentReference.content.id":"System.String","DocumentReference.content.modifierExtension":"Extension","DocumentReference.content.profile":"BackboneElement","DocumentReference.content.profile.extension":"Extension","DocumentReference.content.profile.id":"System.String","DocumentReference.content.profile.modifierExtension":"Extension","DocumentReference.content.profile.valueCanonical":"canonical","DocumentReference.content.profile.valueCoding":"Coding","DocumentReference.content.profile.valueUri":"uri","DocumentReference.context":"Reference","DocumentReference.custodian":"Reference","DocumentReference.date":"instant","DocumentReference.description":"markdown","DocumentReference.docStatus":"code","DocumentReference.event":"CodeableReference","DocumentReference.extension":"Extension","DocumentReference.facilityType":"CodeableConcept","DocumentReference.id":"System.String","DocumentReference.identifier":"Identifier","DocumentReference.implicitRules":"uri","DocumentReference.language":"code","DocumentReference.meta":"Meta","DocumentReference.modality":"CodeableConcept","DocumentReference.modifierExtension":"Extension","DocumentReference.period":"Period","DocumentReference.practiceSetting":"CodeableConcept","DocumentReference.relatesTo":"BackboneElement","DocumentReference.relatesTo.code":"CodeableConcept","DocumentReference.relatesTo.extension":"Extension","DocumentReference.relatesTo.id":"System.String","DocumentReference.relatesTo.modifierExtension":"Extension","DocumentReference.relatesTo.target":"Reference","DocumentReference.securityLabel":"CodeableConcept","DocumentReference.status":"code","DocumentReference.subject":"Reference","DocumentReference.text":"Narrative","DocumentReference.type":"CodeableConcept","DocumentReference.version":"string","DomainResource.contained":"Resource","DomainResource.extension":"Extension","DomainResource.id":"System.String","DomainResource.implicitRules":"uri","DomainResource.language":"code","DomainResource.meta":"Meta","DomainResource.modifierExtension":"Extension","DomainResource.text":"Narrative","Dosage.additionalInstruction":"CodeableConcept","Dosage.asNeeded":"boolean","Dosage.asNeededFor":"CodeableConcept","Dosage.doseAndRate":"Element","Dosage.doseAndRate.doseQuantity":"Quantity","Dosage.doseAndRate.doseRange":"Range","Dosage.doseAndRate.extension":"Extension","Dosage.doseAndRate.id":"System.String","Dosage.doseAndRate.rateQuantity":"Quantity","Dosage.doseAndRate.rateRange":"Range","Dosage.doseAndRate.rateRatio":"Ratio","Dosage.doseAndRate.type":"CodeableConcept","Dosage.extension":"Extension","Dosage.id":"System.String","Dosage.maxDosePerAdministration":"Quantity","Dosage.maxDosePerLifetime":"Quantity","Dosage.maxDosePerPeriod":"Ratio","Dosage.method":"CodeableConcept","Dosage.modifierExtension":"Extension","Dosage.patientInstruction":"string","Dosage.route":"CodeableConcept","Dosage.sequence":"integer","Dosage.site":"CodeableConcept","Dosage.text":"string","Dosage.timing":"Timing","Duration.code":"code","Duration.comparator":"code","Duration.extension":"Extension","Duration.id":"System.String","Duration.system":"uri","Duration.unit":"string","Duration.value":"decimal","Element.extension":"Extension","Element.id":"System.String","ElementDefinition.alias":"string","ElementDefinition.base":"Element","ElementDefinition.base.extension":"Extension","ElementDefinition.base.id":"System.String","ElementDefinition.base.max":"string","ElementDefinition.base.min":"unsignedInt","ElementDefinition.base.path":"string","ElementDefinition.binding":"Element","ElementDefinition.binding.additional":"Element","ElementDefinition.binding.additional.any":"boolean","ElementDefinition.binding.additional.documentation":"markdown","ElementDefinition.binding.additional.extension":"Extension","ElementDefinition.binding.additional.id":"System.String","ElementDefinition.binding.additional.purpose":"code","ElementDefinition.binding.additional.shortDoco":"string","ElementDefinition.binding.additional.usage":"UsageContext","ElementDefinition.binding.additional.valueSet":"canonical","ElementDefinition.binding.description":"markdown","ElementDefinition.binding.extension":"Extension","ElementDefinition.binding.id":"System.String","ElementDefinition.binding.strength":"code","ElementDefinition.binding.valueSet":"canonical","ElementDefinition.code":"Coding","ElementDefinition.comment":"markdown","ElementDefinition.condition":"id","ElementDefinition.constraint":"Element","ElementDefinition.constraint.expression":"string","ElementDefinition.constraint.extension":"Extension","ElementDefinition.constraint.human":"string","ElementDefinition.constraint.id":"System.String","ElementDefinition.constraint.key":"id","ElementDefinition.constraint.requirements":"markdown","ElementDefinition.constraint.severity":"code","ElementDefinition.constraint.source":"canonical","ElementDefinition.constraint.suppress":"boolean","ElementDefinition.contentReference":"uri","ElementDefinition.defaultValueAddress":"Address","ElementDefinition.defaultValueAge":"Age","ElementDefinition.defaultValueAnnotation":"Annotation","ElementDefinition.defaultValueAttachment":"Attachment","ElementDefinition.defaultValueAvailability":"Availability","ElementDefinition.defaultValueBase64Binary":"base64Binary","ElementDefinition.defaultValueBoolean":"boolean","ElementDefinition.defaultValueCanonical":"canonical","ElementDefinition.defaultValueCode":"code","ElementDefinition.defaultValueCodeableConcept":"CodeableConcept","ElementDefinition.defaultValueCodeableReference":"CodeableReference","ElementDefinition.defaultValueCoding":"Coding","ElementDefinition.defaultValueContactDetail":"ContactDetail","ElementDefinition.defaultValueContactPoint":"ContactPoint","ElementDefinition.defaultValueCount":"Count","ElementDefinition.defaultValueDataRequirement":"DataRequirement","ElementDefinition.defaultValueDate":"date","ElementDefinition.defaultValueDateTime":"dateTime","ElementDefinition.defaultValueDecimal":"decimal","ElementDefinition.defaultValueDistance":"Distance","ElementDefinition.defaultValueDosage":"Dosage","ElementDefinition.defaultValueDuration":"Duration","ElementDefinition.defaultValueExpression":"Expression","ElementDefinition.defaultValueExtendedContactDetail":"ExtendedContactDetail","ElementDefinition.defaultValueHumanName":"HumanName","ElementDefinition.defaultValueId":"id","ElementDefinition.defaultValueIdentifier":"Identifier","ElementDefinition.defaultValueInstant":"instant","ElementDefinition.defaultValueInteger":"integer","ElementDefinition.defaultValueInteger64":"integer64","ElementDefinition.defaultValueMarkdown":"markdown","ElementDefinition.defaultValueMeta":"Meta","ElementDefinition.defaultValueMoney":"Money","ElementDefinition.defaultValueOid":"oid","ElementDefinition.defaultValueParameterDefinition":"ParameterDefinition","ElementDefinition.defaultValuePeriod":"Period","ElementDefinition.defaultValuePositiveInt":"positiveInt","ElementDefinition.defaultValueQuantity":"Quantity","ElementDefinition.defaultValueRange":"Range","ElementDefinition.defaultValueRatio":"Ratio","ElementDefinition.defaultValueRatioRange":"RatioRange","ElementDefinition.defaultValueReference":"Reference","ElementDefinition.defaultValueRelatedArtifact":"RelatedArtifact","ElementDefinition.defaultValueSampledData":"SampledData","ElementDefinition.defaultValueSignature":"Signature","ElementDefinition.defaultValueString":"string","ElementDefinition.defaultValueTime":"time","ElementDefinition.defaultValueTiming":"Timing","ElementDefinition.defaultValueTriggerDefinition":"TriggerDefinition","ElementDefinition.defaultValueUnsignedInt":"unsignedInt","ElementDefinition.defaultValueUri":"uri","ElementDefinition.defaultValueUrl":"url","ElementDefinition.defaultValueUsageContext":"UsageContext","ElementDefinition.defaultValueUuid":"uuid","ElementDefinition.definition":"markdown","ElementDefinition.example":"Element","ElementDefinition.example.extension":"Extension","ElementDefinition.example.id":"System.String","ElementDefinition.example.label":"string","ElementDefinition.example.valueAddress":"Address","ElementDefinition.example.valueAge":"Age","ElementDefinition.example.valueAnnotation":"Annotation","ElementDefinition.example.valueAttachment":"Attachment","ElementDefinition.example.valueAvailability":"Availability","ElementDefinition.example.valueBase64Binary":"base64Binary","ElementDefinition.example.valueBoolean":"boolean","ElementDefinition.example.valueCanonical":"canonical","ElementDefinition.example.valueCode":"code","ElementDefinition.example.valueCodeableConcept":"CodeableConcept","ElementDefinition.example.valueCodeableReference":"CodeableReference","ElementDefinition.example.valueCoding":"Coding","ElementDefinition.example.valueContactDetail":"ContactDetail","ElementDefinition.example.valueContactPoint":"ContactPoint","ElementDefinition.example.valueCount":"Count","ElementDefinition.example.valueDataRequirement":"DataRequirement","ElementDefinition.example.valueDate":"date","ElementDefinition.example.valueDateTime":"dateTime","ElementDefinition.example.valueDecimal":"decimal","ElementDefinition.example.valueDistance":"Distance","ElementDefinition.example.valueDosage":"Dosage","ElementDefinition.example.valueDuration":"Duration","ElementDefinition.example.valueExpression":"Expression","ElementDefinition.example.valueExtendedContactDetail":"ExtendedContactDetail","ElementDefinition.example.valueHumanName":"HumanName","ElementDefinition.example.valueId":"id","ElementDefinition.example.valueIdentifier":"Identifier","ElementDefinition.example.valueInstant":"instant","ElementDefinition.example.valueInteger":"integer","ElementDefinition.example.valueInteger64":"integer64","ElementDefinition.example.valueMarkdown":"markdown","ElementDefinition.example.valueMeta":"Meta","ElementDefinition.example.valueMoney":"Money","ElementDefinition.example.valueOid":"oid","ElementDefinition.example.valueParameterDefinition":"ParameterDefinition","ElementDefinition.example.valuePeriod":"Period","ElementDefinition.example.valuePositiveInt":"positiveInt","ElementDefinition.example.valueQuantity":"Quantity","ElementDefinition.example.valueRange":"Range","ElementDefinition.example.valueRatio":"Ratio","ElementDefinition.example.valueRatioRange":"RatioRange","ElementDefinition.example.valueReference":"Reference","ElementDefinition.example.valueRelatedArtifact":"RelatedArtifact","ElementDefinition.example.valueSampledData":"SampledData","ElementDefinition.example.valueSignature":"Signature","ElementDefinition.example.valueString":"string","ElementDefinition.example.valueTime":"time","ElementDefinition.example.valueTiming":"Timing","ElementDefinition.example.valueTriggerDefinition":"TriggerDefinition","ElementDefinition.example.valueUnsignedInt":"unsignedInt","ElementDefinition.example.valueUri":"uri","ElementDefinition.example.valueUrl":"url","ElementDefinition.example.valueUsageContext":"UsageContext","ElementDefinition.example.valueUuid":"uuid","ElementDefinition.extension":"Extension","ElementDefinition.fixedAddress":"Address","ElementDefinition.fixedAge":"Age","ElementDefinition.fixedAnnotation":"Annotation","ElementDefinition.fixedAttachment":"Attachment","ElementDefinition.fixedAvailability":"Availability","ElementDefinition.fixedBase64Binary":"base64Binary","ElementDefinition.fixedBoolean":"boolean","ElementDefinition.fixedCanonical":"canonical","ElementDefinition.fixedCode":"code","ElementDefinition.fixedCodeableConcept":"CodeableConcept","ElementDefinition.fixedCodeableReference":"CodeableReference","ElementDefinition.fixedCoding":"Coding","ElementDefinition.fixedContactDetail":"ContactDetail","ElementDefinition.fixedContactPoint":"ContactPoint","ElementDefinition.fixedCount":"Count","ElementDefinition.fixedDataRequirement":"DataRequirement","ElementDefinition.fixedDate":"date","ElementDefinition.fixedDateTime":"dateTime","ElementDefinition.fixedDecimal":"decimal","ElementDefinition.fixedDistance":"Distance","ElementDefinition.fixedDosage":"Dosage","ElementDefinition.fixedDuration":"Duration","ElementDefinition.fixedExpression":"Expression","ElementDefinition.fixedExtendedContactDetail":"ExtendedContactDetail","ElementDefinition.fixedHumanName":"HumanName","ElementDefinition.fixedId":"id","ElementDefinition.fixedIdentifier":"Identifier","ElementDefinition.fixedInstant":"instant","ElementDefinition.fixedInteger":"integer","ElementDefinition.fixedInteger64":"integer64","ElementDefinition.fixedMarkdown":"markdown","ElementDefinition.fixedMeta":"Meta","ElementDefinition.fixedMoney":"Money","ElementDefinition.fixedOid":"oid","ElementDefinition.fixedParameterDefinition":"ParameterDefinition","ElementDefinition.fixedPeriod":"Period","ElementDefinition.fixedPositiveInt":"positiveInt","ElementDefinition.fixedQuantity":"Quantity","ElementDefinition.fixedRange":"Range","ElementDefinition.fixedRatio":"Ratio","ElementDefinition.fixedRatioRange":"RatioRange","ElementDefinition.fixedReference":"Reference","ElementDefinition.fixedRelatedArtifact":"RelatedArtifact","ElementDefinition.fixedSampledData":"SampledData","ElementDefinition.fixedSignature":"Signature","ElementDefinition.fixedString":"string","ElementDefinition.fixedTime":"time","ElementDefinition.fixedTiming":"Timing","ElementDefinition.fixedTriggerDefinition":"TriggerDefinition","ElementDefinition.fixedUnsignedInt":"unsignedInt","ElementDefinition.fixedUri":"uri","ElementDefinition.fixedUrl":"url","ElementDefinition.fixedUsageContext":"UsageContext","ElementDefinition.fixedUuid":"uuid","ElementDefinition.id":"System.String","ElementDefinition.isModifier":"boolean","ElementDefinition.isModifierReason":"string","ElementDefinition.isSummary":"boolean","ElementDefinition.label":"string","ElementDefinition.mapping":"Element","ElementDefinition.mapping.comment":"markdown","ElementDefinition.mapping.extension":"Extension","ElementDefinition.mapping.id":"System.String","ElementDefinition.mapping.identity":"id","ElementDefinition.mapping.language":"code","ElementDefinition.mapping.map":"string","ElementDefinition.max":"string","ElementDefinition.maxLength":"integer","ElementDefinition.maxValueDate":"date","ElementDefinition.maxValueDateTime":"dateTime","ElementDefinition.maxValueDecimal":"decimal","ElementDefinition.maxValueInstant":"instant","ElementDefinition.maxValueInteger":"integer","ElementDefinition.maxValueInteger64":"integer64","ElementDefinition.maxValuePositiveInt":"positiveInt","ElementDefinition.maxValueQuantity":"Quantity","ElementDefinition.maxValueTime":"time","ElementDefinition.maxValueUnsignedInt":"unsignedInt","ElementDefinition.meaningWhenMissing":"markdown","ElementDefinition.min":"unsignedInt","ElementDefinition.minValueDate":"date","ElementDefinition.minValueDateTime":"dateTime","ElementDefinition.minValueDecimal":"decimal","ElementDefinition.minValueInstant":"instant","ElementDefinition.minValueInteger":"integer","ElementDefinition.minValueInteger64":"integer64","ElementDefinition.minValuePositiveInt":"positiveInt","ElementDefinition.minValueQuantity":"Quantity","ElementDefinition.minValueTime":"time","ElementDefinition.minValueUnsignedInt":"unsignedInt","ElementDefinition.modifierExtension":"Extension","ElementDefinition.mustHaveValue":"boolean","ElementDefinition.mustSupport":"boolean","ElementDefinition.orderMeaning":"string","ElementDefinition.path":"string","ElementDefinition.patternAddress":"Address","ElementDefinition.patternAge":"Age","ElementDefinition.patternAnnotation":"Annotation","ElementDefinition.patternAttachment":"Attachment","ElementDefinition.patternAvailability":"Availability","ElementDefinition.patternBase64Binary":"base64Binary","ElementDefinition.patternBoolean":"boolean","ElementDefinition.patternCanonical":"canonical","ElementDefinition.patternCode":"code","ElementDefinition.patternCodeableConcept":"CodeableConcept","ElementDefinition.patternCodeableReference":"CodeableReference","ElementDefinition.patternCoding":"Coding","ElementDefinition.patternContactDetail":"ContactDetail","ElementDefinition.patternContactPoint":"ContactPoint","ElementDefinition.patternCount":"Count","ElementDefinition.patternDataRequirement":"DataRequirement","ElementDefinition.patternDate":"date","ElementDefinition.patternDateTime":"dateTime","ElementDefinition.patternDecimal":"decimal","ElementDefinition.patternDistance":"Distance","ElementDefinition.patternDosage":"Dosage","ElementDefinition.patternDuration":"Duration","ElementDefinition.patternExpression":"Expression","ElementDefinition.patternExtendedContactDetail":"ExtendedContactDetail","ElementDefinition.patternHumanName":"HumanName","ElementDefinition.patternId":"id","ElementDefinition.patternIdentifier":"Identifier","ElementDefinition.patternInstant":"instant","ElementDefinition.patternInteger":"integer","ElementDefinition.patternInteger64":"integer64","ElementDefinition.patternMarkdown":"markdown","ElementDefinition.patternMeta":"Meta","ElementDefinition.patternMoney":"Money","ElementDefinition.patternOid":"oid","ElementDefinition.patternParameterDefinition":"ParameterDefinition","ElementDefinition.patternPeriod":"Period","ElementDefinition.patternPositiveInt":"positiveInt","ElementDefinition.patternQuantity":"Quantity","ElementDefinition.patternRange":"Range","ElementDefinition.patternRatio":"Ratio","ElementDefinition.patternRatioRange":"RatioRange","ElementDefinition.patternReference":"Reference","ElementDefinition.patternRelatedArtifact":"RelatedArtifact","ElementDefinition.patternSampledData":"SampledData","ElementDefinition.patternSignature":"Signature","ElementDefinition.patternString":"string","ElementDefinition.patternTime":"time","ElementDefinition.patternTiming":"Timing","ElementDefinition.patternTriggerDefinition":"TriggerDefinition","ElementDefinition.patternUnsignedInt":"unsignedInt","ElementDefinition.patternUri":"uri","ElementDefinition.patternUrl":"url","ElementDefinition.patternUsageContext":"UsageContext","ElementDefinition.patternUuid":"uuid","ElementDefinition.representation":"code","ElementDefinition.requirements":"markdown","ElementDefinition.short":"string","ElementDefinition.sliceIsConstraining":"boolean","ElementDefinition.sliceName":"string","ElementDefinition.slicing":"Element","ElementDefinition.slicing.description":"string","ElementDefinition.slicing.discriminator":"Element","ElementDefinition.slicing.discriminator.extension":"Extension","ElementDefinition.slicing.discriminator.id":"System.String","ElementDefinition.slicing.discriminator.path":"string","ElementDefinition.slicing.discriminator.type":"code","ElementDefinition.slicing.extension":"Extension","ElementDefinition.slicing.id":"System.String","ElementDefinition.slicing.ordered":"boolean","ElementDefinition.slicing.rules":"code","ElementDefinition.type":"Element","ElementDefinition.type.aggregation":"code","ElementDefinition.type.code":"uri","ElementDefinition.type.extension":"Extension","ElementDefinition.type.id":"System.String","ElementDefinition.type.profile":"canonical","ElementDefinition.type.targetProfile":"canonical","ElementDefinition.type.versioning":"code","ElementDefinition.valueAlternatives":"canonical","Encounter.account":"Reference","Encounter.actualPeriod":"Period","Encounter.admission":"BackboneElement","Encounter.admission.admitSource":"CodeableConcept","Encounter.admission.destination":"Reference","Encounter.admission.dischargeDisposition":"CodeableConcept","Encounter.admission.extension":"Extension","Encounter.admission.id":"System.String","Encounter.admission.modifierExtension":"Extension","Encounter.admission.origin":"Reference","Encounter.admission.preAdmissionIdentifier":"Identifier","Encounter.admission.reAdmission":"CodeableConcept","Encounter.appointment":"Reference","Encounter.basedOn":"Reference","Encounter.careTeam":"Reference","Encounter.class":"CodeableConcept","Encounter.contained":"Resource","Encounter.diagnosis":"BackboneElement","Encounter.diagnosis.condition":"CodeableReference","Encounter.diagnosis.extension":"Extension","Encounter.diagnosis.id":"System.String","Encounter.diagnosis.modifierExtension":"Extension","Encounter.diagnosis.use":"CodeableConcept","Encounter.dietPreference":"CodeableConcept","Encounter.episodeOfCare":"Reference","Encounter.extension":"Extension","Encounter.id":"System.String","Encounter.identifier":"Identifier","Encounter.implicitRules":"uri","Encounter.language":"code","Encounter.length":"Duration","Encounter.location":"BackboneElement","Encounter.location.extension":"Extension","Encounter.location.form":"CodeableConcept","Encounter.location.id":"System.String","Encounter.location.location":"Reference","Encounter.location.modifierExtension":"Extension","Encounter.location.period":"Period","Encounter.location.status":"code","Encounter.meta":"Meta","Encounter.modifierExtension":"Extension","Encounter.partOf":"Reference","Encounter.participant":"BackboneElement","Encounter.participant.actor":"Reference","Encounter.participant.extension":"Extension","Encounter.participant.id":"System.String","Encounter.participant.modifierExtension":"Extension","Encounter.participant.period":"Period","Encounter.participant.type":"CodeableConcept","Encounter.plannedEndDate":"dateTime","Encounter.plannedStartDate":"dateTime","Encounter.priority":"CodeableConcept","Encounter.reason":"BackboneElement","Encounter.reason.extension":"Extension","Encounter.reason.id":"System.String","Encounter.reason.modifierExtension":"Extension","Encounter.reason.use":"CodeableConcept","Encounter.reason.value":"CodeableReference","Encounter.serviceProvider":"Reference","Encounter.serviceType":"CodeableReference","Encounter.specialArrangement":"CodeableConcept","Encounter.specialCourtesy":"CodeableConcept","Encounter.status":"code","Encounter.subject":"Reference","Encounter.subjectStatus":"CodeableConcept","Encounter.text":"Narrative","Encounter.type":"CodeableConcept","Encounter.virtualService":"VirtualServiceDetail","EncounterHistory.actualPeriod":"Period","EncounterHistory.class":"CodeableConcept","EncounterHistory.contained":"Resource","EncounterHistory.encounter":"Reference","EncounterHistory.extension":"Extension","EncounterHistory.id":"System.String","EncounterHistory.identifier":"Identifier","EncounterHistory.implicitRules":"uri","EncounterHistory.language":"code","EncounterHistory.length":"Duration","EncounterHistory.location":"BackboneElement","EncounterHistory.location.extension":"Extension","EncounterHistory.location.form":"CodeableConcept","EncounterHistory.location.id":"System.String","EncounterHistory.location.location":"Reference","EncounterHistory.location.modifierExtension":"Extension","EncounterHistory.meta":"Meta","EncounterHistory.modifierExtension":"Extension","EncounterHistory.plannedEndDate":"dateTime","EncounterHistory.plannedStartDate":"dateTime","EncounterHistory.serviceType":"CodeableReference","EncounterHistory.status":"code","EncounterHistory.subject":"Reference","EncounterHistory.subjectStatus":"CodeableConcept","EncounterHistory.text":"Narrative","EncounterHistory.type":"CodeableConcept","Endpoint.address":"url","Endpoint.connectionType":"CodeableConcept","Endpoint.contact":"ContactPoint","Endpoint.contained":"Resource","Endpoint.description":"string","Endpoint.environmentType":"CodeableConcept","Endpoint.extension":"Extension","Endpoint.header":"string","Endpoint.id":"System.String","Endpoint.identifier":"Identifier","Endpoint.implicitRules":"uri","Endpoint.language":"code","Endpoint.managingOrganization":"Reference","Endpoint.meta":"Meta","Endpoint.modifierExtension":"Extension","Endpoint.name":"string","Endpoint.payload":"BackboneElement","Endpoint.payload.extension":"Extension","Endpoint.payload.id":"System.String","Endpoint.payload.mimeType":"code","Endpoint.payload.modifierExtension":"Extension","Endpoint.payload.type":"CodeableConcept","Endpoint.period":"Period","Endpoint.status":"code","Endpoint.text":"Narrative","EnrollmentRequest.candidate":"Reference","EnrollmentRequest.contained":"Resource","EnrollmentRequest.coverage":"Reference","EnrollmentRequest.created":"dateTime","EnrollmentRequest.extension":"Extension","EnrollmentRequest.id":"System.String","EnrollmentRequest.identifier":"Identifier","EnrollmentRequest.implicitRules":"uri","EnrollmentRequest.insurer":"Reference","EnrollmentRequest.language":"code","EnrollmentRequest.meta":"Meta","EnrollmentRequest.modifierExtension":"Extension","EnrollmentRequest.provider":"Reference","EnrollmentRequest.status":"code","EnrollmentRequest.text":"Narrative","EnrollmentResponse.contained":"Resource","EnrollmentResponse.created":"dateTime","EnrollmentResponse.disposition":"string","EnrollmentResponse.extension":"Extension","EnrollmentResponse.id":"System.String","EnrollmentResponse.identifier":"Identifier","EnrollmentResponse.implicitRules":"uri","EnrollmentResponse.language":"code","EnrollmentResponse.meta":"Meta","EnrollmentResponse.modifierExtension":"Extension","EnrollmentResponse.organization":"Reference","EnrollmentResponse.outcome":"code","EnrollmentResponse.request":"Reference","EnrollmentResponse.requestProvider":"Reference","EnrollmentResponse.status":"code","EnrollmentResponse.text":"Narrative","EpisodeOfCare.account":"Reference","EpisodeOfCare.careManager":"Reference","EpisodeOfCare.careTeam":"Reference","EpisodeOfCare.contained":"Resource","EpisodeOfCare.diagnosis":"BackboneElement","EpisodeOfCare.diagnosis.condition":"CodeableReference","EpisodeOfCare.diagnosis.extension":"Extension","EpisodeOfCare.diagnosis.id":"System.String","EpisodeOfCare.diagnosis.modifierExtension":"Extension","EpisodeOfCare.diagnosis.use":"CodeableConcept","EpisodeOfCare.extension":"Extension","EpisodeOfCare.id":"System.String","EpisodeOfCare.identifier":"Identifier","EpisodeOfCare.implicitRules":"uri","EpisodeOfCare.language":"code","EpisodeOfCare.managingOrganization":"Reference","EpisodeOfCare.meta":"Meta","EpisodeOfCare.modifierExtension":"Extension","EpisodeOfCare.patient":"Reference","EpisodeOfCare.period":"Period","EpisodeOfCare.reason":"BackboneElement","EpisodeOfCare.reason.extension":"Extension","EpisodeOfCare.reason.id":"System.String","EpisodeOfCare.reason.modifierExtension":"Extension","EpisodeOfCare.reason.use":"CodeableConcept","EpisodeOfCare.reason.value":"CodeableReference","EpisodeOfCare.referralRequest":"Reference","EpisodeOfCare.status":"code","EpisodeOfCare.statusHistory":"BackboneElement","EpisodeOfCare.statusHistory.extension":"Extension","EpisodeOfCare.statusHistory.id":"System.String","EpisodeOfCare.statusHistory.modifierExtension":"Extension","EpisodeOfCare.statusHistory.period":"Period","EpisodeOfCare.statusHistory.status":"code","EpisodeOfCare.text":"Narrative","EpisodeOfCare.type":"CodeableConcept","EventDefinition.approvalDate":"date","EventDefinition.author":"ContactDetail","EventDefinition.contact":"ContactDetail","EventDefinition.contained":"Resource","EventDefinition.copyright":"markdown","EventDefinition.copyrightLabel":"string","EventDefinition.date":"dateTime","EventDefinition.description":"markdown","EventDefinition.editor":"ContactDetail","EventDefinition.effectivePeriod":"Period","EventDefinition.endorser":"ContactDetail","EventDefinition.experimental":"boolean","EventDefinition.extension":"Extension","EventDefinition.id":"System.String","EventDefinition.identifier":"Identifier","EventDefinition.implicitRules":"uri","EventDefinition.jurisdiction":"CodeableConcept","EventDefinition.language":"code","EventDefinition.lastReviewDate":"date","EventDefinition.meta":"Meta","EventDefinition.modifierExtension":"Extension","EventDefinition.name":"string","EventDefinition.publisher":"string","EventDefinition.purpose":"markdown","EventDefinition.relatedArtifact":"RelatedArtifact","EventDefinition.reviewer":"ContactDetail","EventDefinition.status":"code","EventDefinition.subjectCodeableConcept":"CodeableConcept","EventDefinition.subjectReference":"Reference","EventDefinition.subtitle":"string","EventDefinition.text":"Narrative","EventDefinition.title":"string","EventDefinition.topic":"CodeableConcept","EventDefinition.trigger":"TriggerDefinition","EventDefinition.url":"uri","EventDefinition.usage":"markdown","EventDefinition.useContext":"UsageContext","EventDefinition.version":"string","EventDefinition.versionAlgorithmCoding":"Coding","EventDefinition.versionAlgorithmString":"string","Evidence.approvalDate":"date","Evidence.assertion":"markdown","Evidence.author":"ContactDetail","Evidence.certainty":"BackboneElement","Evidence.certainty.description":"markdown","Evidence.certainty.extension":"Extension","Evidence.certainty.id":"System.String","Evidence.certainty.modifierExtension":"Extension","Evidence.certainty.note":"Annotation","Evidence.certainty.rater":"string","Evidence.certainty.rating":"CodeableConcept","Evidence.certainty.type":"CodeableConcept","Evidence.citeAsMarkdown":"markdown","Evidence.citeAsReference":"Reference","Evidence.contact":"ContactDetail","Evidence.contained":"Resource","Evidence.copyright":"markdown","Evidence.copyrightLabel":"string","Evidence.date":"dateTime","Evidence.description":"markdown","Evidence.editor":"ContactDetail","Evidence.endorser":"ContactDetail","Evidence.experimental":"boolean","Evidence.extension":"Extension","Evidence.id":"System.String","Evidence.identifier":"Identifier","Evidence.implicitRules":"uri","Evidence.language":"code","Evidence.lastReviewDate":"date","Evidence.meta":"Meta","Evidence.modifierExtension":"Extension","Evidence.name":"string","Evidence.note":"Annotation","Evidence.publisher":"string","Evidence.purpose":"markdown","Evidence.relatedArtifact":"RelatedArtifact","Evidence.reviewer":"ContactDetail","Evidence.statistic":"BackboneElement","Evidence.statistic.attributeEstimate":"BackboneElement","Evidence.statistic.attributeEstimate.description":"markdown","Evidence.statistic.attributeEstimate.extension":"Extension","Evidence.statistic.attributeEstimate.id":"System.String","Evidence.statistic.attributeEstimate.level":"decimal","Evidence.statistic.attributeEstimate.modifierExtension":"Extension","Evidence.statistic.attributeEstimate.note":"Annotation","Evidence.statistic.attributeEstimate.quantity":"Quantity","Evidence.statistic.attributeEstimate.range":"Range","Evidence.statistic.attributeEstimate.type":"CodeableConcept","Evidence.statistic.category":"CodeableConcept","Evidence.statistic.description":"markdown","Evidence.statistic.extension":"Extension","Evidence.statistic.id":"System.String","Evidence.statistic.modelCharacteristic":"BackboneElement","Evidence.statistic.modelCharacteristic.code":"CodeableConcept","Evidence.statistic.modelCharacteristic.extension":"Extension","Evidence.statistic.modelCharacteristic.id":"System.String","Evidence.statistic.modelCharacteristic.modifierExtension":"Extension","Evidence.statistic.modelCharacteristic.value":"Quantity","Evidence.statistic.modelCharacteristic.variable":"BackboneElement","Evidence.statistic.modelCharacteristic.variable.extension":"Extension","Evidence.statistic.modelCharacteristic.variable.handling":"code","Evidence.statistic.modelCharacteristic.variable.id":"System.String","Evidence.statistic.modelCharacteristic.variable.modifierExtension":"Extension","Evidence.statistic.modelCharacteristic.variable.valueCategory":"CodeableConcept","Evidence.statistic.modelCharacteristic.variable.valueQuantity":"Quantity","Evidence.statistic.modelCharacteristic.variable.valueRange":"Range","Evidence.statistic.modelCharacteristic.variable.variableDefinition":"Reference","Evidence.statistic.modifierExtension":"Extension","Evidence.statistic.note":"Annotation","Evidence.statistic.numberAffected":"unsignedInt","Evidence.statistic.numberOfEvents":"unsignedInt","Evidence.statistic.quantity":"Quantity","Evidence.statistic.sampleSize":"BackboneElement","Evidence.statistic.sampleSize.description":"markdown","Evidence.statistic.sampleSize.extension":"Extension","Evidence.statistic.sampleSize.id":"System.String","Evidence.statistic.sampleSize.knownDataCount":"unsignedInt","Evidence.statistic.sampleSize.modifierExtension":"Extension","Evidence.statistic.sampleSize.note":"Annotation","Evidence.statistic.sampleSize.numberOfParticipants":"unsignedInt","Evidence.statistic.sampleSize.numberOfStudies":"unsignedInt","Evidence.statistic.statisticType":"CodeableConcept","Evidence.status":"code","Evidence.studyDesign":"CodeableConcept","Evidence.synthesisType":"CodeableConcept","Evidence.text":"Narrative","Evidence.title":"string","Evidence.url":"uri","Evidence.useContext":"UsageContext","Evidence.variableDefinition":"BackboneElement","Evidence.variableDefinition.description":"markdown","Evidence.variableDefinition.directnessMatch":"CodeableConcept","Evidence.variableDefinition.extension":"Extension","Evidence.variableDefinition.id":"System.String","Evidence.variableDefinition.intended":"Reference","Evidence.variableDefinition.modifierExtension":"Extension","Evidence.variableDefinition.note":"Annotation","Evidence.variableDefinition.observed":"Reference","Evidence.variableDefinition.variableRole":"CodeableConcept","Evidence.version":"string","Evidence.versionAlgorithmCoding":"Coding","Evidence.versionAlgorithmString":"string","EvidenceReport.author":"ContactDetail","EvidenceReport.citeAsMarkdown":"markdown","EvidenceReport.citeAsReference":"Reference","EvidenceReport.contact":"ContactDetail","EvidenceReport.contained":"Resource","EvidenceReport.editor":"ContactDetail","EvidenceReport.endorser":"ContactDetail","EvidenceReport.extension":"Extension","EvidenceReport.id":"System.String","EvidenceReport.identifier":"Identifier","EvidenceReport.implicitRules":"uri","EvidenceReport.language":"code","EvidenceReport.meta":"Meta","EvidenceReport.modifierExtension":"Extension","EvidenceReport.note":"Annotation","EvidenceReport.publisher":"string","EvidenceReport.relatedArtifact":"RelatedArtifact","EvidenceReport.relatedIdentifier":"Identifier","EvidenceReport.relatesTo":"BackboneElement","EvidenceReport.relatesTo.code":"code","EvidenceReport.relatesTo.extension":"Extension","EvidenceReport.relatesTo.id":"System.String","EvidenceReport.relatesTo.modifierExtension":"Extension","EvidenceReport.relatesTo.target":"BackboneElement","EvidenceReport.relatesTo.target.display":"markdown","EvidenceReport.relatesTo.target.extension":"Extension","EvidenceReport.relatesTo.target.id":"System.String","EvidenceReport.relatesTo.target.identifier":"Identifier","EvidenceReport.relatesTo.target.modifierExtension":"Extension","EvidenceReport.relatesTo.target.resource":"Reference","EvidenceReport.relatesTo.target.url":"uri","EvidenceReport.reviewer":"ContactDetail","EvidenceReport.section":"BackboneElement","EvidenceReport.section.author":"Reference","EvidenceReport.section.emptyReason":"CodeableConcept","EvidenceReport.section.entryClassifier":"CodeableConcept","EvidenceReport.section.entryQuantity":"Quantity","EvidenceReport.section.entryReference":"Reference","EvidenceReport.section.extension":"Extension","EvidenceReport.section.focus":"CodeableConcept","EvidenceReport.section.focusReference":"Reference","EvidenceReport.section.id":"System.String","EvidenceReport.section.mode":"code","EvidenceReport.section.modifierExtension":"Extension","EvidenceReport.section.orderedBy":"CodeableConcept","EvidenceReport.section.text":"Narrative","EvidenceReport.section.title":"string","EvidenceReport.status":"code","EvidenceReport.subject":"BackboneElement","EvidenceReport.subject.characteristic":"BackboneElement","EvidenceReport.subject.characteristic.code":"CodeableConcept","EvidenceReport.subject.characteristic.exclude":"boolean","EvidenceReport.subject.characteristic.extension":"Extension","EvidenceReport.subject.characteristic.id":"System.String","EvidenceReport.subject.characteristic.modifierExtension":"Extension","EvidenceReport.subject.characteristic.period":"Period","EvidenceReport.subject.characteristic.valueBoolean":"boolean","EvidenceReport.subject.characteristic.valueCodeableConcept":"CodeableConcept","EvidenceReport.subject.characteristic.valueQuantity":"Quantity","EvidenceReport.subject.characteristic.valueRange":"Range","EvidenceReport.subject.characteristic.valueReference":"Reference","EvidenceReport.subject.extension":"Extension","EvidenceReport.subject.id":"System.String","EvidenceReport.subject.modifierExtension":"Extension","EvidenceReport.subject.note":"Annotation","EvidenceReport.text":"Narrative","EvidenceReport.type":"CodeableConcept","EvidenceReport.url":"uri","EvidenceReport.useContext":"UsageContext","EvidenceVariable.actual":"boolean","EvidenceVariable.approvalDate":"date","EvidenceVariable.author":"ContactDetail","EvidenceVariable.category":"BackboneElement","EvidenceVariable.category.extension":"Extension","EvidenceVariable.category.id":"System.String","EvidenceVariable.category.modifierExtension":"Extension","EvidenceVariable.category.name":"string","EvidenceVariable.category.valueCodeableConcept":"CodeableConcept","EvidenceVariable.category.valueQuantity":"Quantity","EvidenceVariable.category.valueRange":"Range","EvidenceVariable.characteristic":"BackboneElement","EvidenceVariable.characteristic.definitionByCombination":"BackboneElement","EvidenceVariable.characteristic.definitionByCombination.code":"code","EvidenceVariable.characteristic.definitionByCombination.extension":"Extension","EvidenceVariable.characteristic.definitionByCombination.id":"System.String","EvidenceVariable.characteristic.definitionByCombination.modifierExtension":"Extension","EvidenceVariable.characteristic.definitionByCombination.threshold":"positiveInt","EvidenceVariable.characteristic.definitionByTypeAndValue":"BackboneElement","EvidenceVariable.characteristic.definitionByTypeAndValue.device":"Reference","EvidenceVariable.characteristic.definitionByTypeAndValue.extension":"Extension","EvidenceVariable.characteristic.definitionByTypeAndValue.id":"System.String","EvidenceVariable.characteristic.definitionByTypeAndValue.method":"CodeableConcept","EvidenceVariable.characteristic.definitionByTypeAndValue.modifierExtension":"Extension","EvidenceVariable.characteristic.definitionByTypeAndValue.offset":"CodeableConcept","EvidenceVariable.characteristic.definitionByTypeAndValue.type":"CodeableConcept","EvidenceVariable.characteristic.definitionByTypeAndValue.valueBoolean":"boolean","EvidenceVariable.characteristic.definitionByTypeAndValue.valueCodeableConcept":"CodeableConcept","EvidenceVariable.characteristic.definitionByTypeAndValue.valueId":"id","EvidenceVariable.characteristic.definitionByTypeAndValue.valueQuantity":"Quantity","EvidenceVariable.characteristic.definitionByTypeAndValue.valueRange":"Range","EvidenceVariable.characteristic.definitionByTypeAndValue.valueReference":"Reference","EvidenceVariable.characteristic.definitionCanonical":"canonical","EvidenceVariable.characteristic.definitionCodeableConcept":"CodeableConcept","EvidenceVariable.characteristic.definitionExpression":"Expression","EvidenceVariable.characteristic.definitionId":"id","EvidenceVariable.characteristic.definitionReference":"Reference","EvidenceVariable.characteristic.description":"markdown","EvidenceVariable.characteristic.durationQuantity":"Quantity","EvidenceVariable.characteristic.durationRange":"Range","EvidenceVariable.characteristic.exclude":"boolean","EvidenceVariable.characteristic.extension":"Extension","EvidenceVariable.characteristic.id":"System.String","EvidenceVariable.characteristic.instancesQuantity":"Quantity","EvidenceVariable.characteristic.instancesRange":"Range","EvidenceVariable.characteristic.linkId":"id","EvidenceVariable.characteristic.modifierExtension":"Extension","EvidenceVariable.characteristic.note":"Annotation","EvidenceVariable.characteristic.timeFromEvent":"BackboneElement","EvidenceVariable.characteristic.timeFromEvent.description":"markdown","EvidenceVariable.characteristic.timeFromEvent.eventCodeableConcept":"CodeableConcept","EvidenceVariable.characteristic.timeFromEvent.eventDateTime":"dateTime","EvidenceVariable.characteristic.timeFromEvent.eventId":"id","EvidenceVariable.characteristic.timeFromEvent.eventReference":"Reference","EvidenceVariable.characteristic.timeFromEvent.extension":"Extension","EvidenceVariable.characteristic.timeFromEvent.id":"System.String","EvidenceVariable.characteristic.timeFromEvent.modifierExtension":"Extension","EvidenceVariable.characteristic.timeFromEvent.note":"Annotation","EvidenceVariable.characteristic.timeFromEvent.quantity":"Quantity","EvidenceVariable.characteristic.timeFromEvent.range":"Range","EvidenceVariable.contact":"ContactDetail","EvidenceVariable.contained":"Resource","EvidenceVariable.copyright":"markdown","EvidenceVariable.copyrightLabel":"string","EvidenceVariable.date":"dateTime","EvidenceVariable.description":"markdown","EvidenceVariable.editor":"ContactDetail","EvidenceVariable.effectivePeriod":"Period","EvidenceVariable.endorser":"ContactDetail","EvidenceVariable.experimental":"boolean","EvidenceVariable.extension":"Extension","EvidenceVariable.handling":"code","EvidenceVariable.id":"System.String","EvidenceVariable.identifier":"Identifier","EvidenceVariable.implicitRules":"uri","EvidenceVariable.language":"code","EvidenceVariable.lastReviewDate":"date","EvidenceVariable.meta":"Meta","EvidenceVariable.modifierExtension":"Extension","EvidenceVariable.name":"string","EvidenceVariable.note":"Annotation","EvidenceVariable.publisher":"string","EvidenceVariable.purpose":"markdown","EvidenceVariable.relatedArtifact":"RelatedArtifact","EvidenceVariable.reviewer":"ContactDetail","EvidenceVariable.shortTitle":"string","EvidenceVariable.status":"code","EvidenceVariable.text":"Narrative","EvidenceVariable.title":"string","EvidenceVariable.url":"uri","EvidenceVariable.useContext":"UsageContext","EvidenceVariable.version":"string","EvidenceVariable.versionAlgorithmCoding":"Coding","EvidenceVariable.versionAlgorithmString":"string","ExampleScenario.actor":"BackboneElement","ExampleScenario.actor.description":"markdown","ExampleScenario.actor.extension":"Extension","ExampleScenario.actor.id":"System.String","ExampleScenario.actor.key":"string","ExampleScenario.actor.modifierExtension":"Extension","ExampleScenario.actor.title":"string","ExampleScenario.actor.type":"code","ExampleScenario.contact":"ContactDetail","ExampleScenario.contained":"Resource","ExampleScenario.copyright":"markdown","ExampleScenario.copyrightLabel":"string","ExampleScenario.date":"dateTime","ExampleScenario.description":"markdown","ExampleScenario.experimental":"boolean","ExampleScenario.extension":"Extension","ExampleScenario.id":"System.String","ExampleScenario.identifier":"Identifier","ExampleScenario.implicitRules":"uri","ExampleScenario.instance":"BackboneElement","ExampleScenario.instance.containedInstance":"BackboneElement","ExampleScenario.instance.containedInstance.extension":"Extension","ExampleScenario.instance.containedInstance.id":"System.String","ExampleScenario.instance.containedInstance.instanceReference":"string","ExampleScenario.instance.containedInstance.modifierExtension":"Extension","ExampleScenario.instance.containedInstance.versionReference":"string","ExampleScenario.instance.content":"Reference","ExampleScenario.instance.description":"markdown","ExampleScenario.instance.extension":"Extension","ExampleScenario.instance.id":"System.String","ExampleScenario.instance.key":"string","ExampleScenario.instance.modifierExtension":"Extension","ExampleScenario.instance.structureProfileCanonical":"canonical","ExampleScenario.instance.structureProfileUri":"uri","ExampleScenario.instance.structureType":"Coding","ExampleScenario.instance.structureVersion":"string","ExampleScenario.instance.title":"string","ExampleScenario.instance.version":"BackboneElement","ExampleScenario.instance.version.content":"Reference","ExampleScenario.instance.version.description":"markdown","ExampleScenario.instance.version.extension":"Extension","ExampleScenario.instance.version.id":"System.String","ExampleScenario.instance.version.key":"string","ExampleScenario.instance.version.modifierExtension":"Extension","ExampleScenario.instance.version.title":"string","ExampleScenario.jurisdiction":"CodeableConcept","ExampleScenario.language":"code","ExampleScenario.meta":"Meta","ExampleScenario.modifierExtension":"Extension","ExampleScenario.name":"string","ExampleScenario.process":"BackboneElement","ExampleScenario.process.description":"markdown","ExampleScenario.process.extension":"Extension","ExampleScenario.process.id":"System.String","ExampleScenario.process.modifierExtension":"Extension","ExampleScenario.process.postConditions":"markdown","ExampleScenario.process.preConditions":"markdown","ExampleScenario.process.step":"BackboneElement","ExampleScenario.process.step.alternative":"BackboneElement","ExampleScenario.process.step.alternative.description":"markdown","ExampleScenario.process.step.alternative.extension":"Extension","ExampleScenario.process.step.alternative.id":"System.String","ExampleScenario.process.step.alternative.modifierExtension":"Extension","ExampleScenario.process.step.alternative.title":"string","ExampleScenario.process.step.extension":"Extension","ExampleScenario.process.step.id":"System.String","ExampleScenario.process.step.modifierExtension":"Extension","ExampleScenario.process.step.number":"string","ExampleScenario.process.step.operation":"BackboneElement","ExampleScenario.process.step.operation.description":"markdown","ExampleScenario.process.step.operation.extension":"Extension","ExampleScenario.process.step.operation.id":"System.String","ExampleScenario.process.step.operation.initiator":"string","ExampleScenario.process.step.operation.initiatorActive":"boolean","ExampleScenario.process.step.operation.modifierExtension":"Extension","ExampleScenario.process.step.operation.receiver":"string","ExampleScenario.process.step.operation.receiverActive":"boolean","ExampleScenario.process.step.operation.title":"string","ExampleScenario.process.step.operation.type":"Coding","ExampleScenario.process.step.pause":"boolean","ExampleScenario.process.step.workflow":"canonical","ExampleScenario.process.title":"string","ExampleScenario.publisher":"string","ExampleScenario.purpose":"markdown","ExampleScenario.status":"code","ExampleScenario.text":"Narrative","ExampleScenario.title":"string","ExampleScenario.url":"uri","ExampleScenario.useContext":"UsageContext","ExampleScenario.version":"string","ExampleScenario.versionAlgorithmCoding":"Coding","ExampleScenario.versionAlgorithmString":"string","ExplanationOfBenefit.accident":"BackboneElement","ExplanationOfBenefit.accident.date":"date","ExplanationOfBenefit.accident.extension":"Extension","ExplanationOfBenefit.accident.id":"System.String","ExplanationOfBenefit.accident.locationAddress":"Address","ExplanationOfBenefit.accident.locationReference":"Reference","ExplanationOfBenefit.accident.modifierExtension":"Extension","ExplanationOfBenefit.accident.type":"CodeableConcept","ExplanationOfBenefit.addItem":"BackboneElement","ExplanationOfBenefit.addItem.bodySite":"BackboneElement","ExplanationOfBenefit.addItem.bodySite.extension":"Extension","ExplanationOfBenefit.addItem.bodySite.id":"System.String","ExplanationOfBenefit.addItem.bodySite.modifierExtension":"Extension","ExplanationOfBenefit.addItem.bodySite.site":"CodeableReference","ExplanationOfBenefit.addItem.bodySite.subSite":"CodeableConcept","ExplanationOfBenefit.addItem.detail":"BackboneElement","ExplanationOfBenefit.addItem.detail.extension":"Extension","ExplanationOfBenefit.addItem.detail.factor":"decimal","ExplanationOfBenefit.addItem.detail.id":"System.String","ExplanationOfBenefit.addItem.detail.modifier":"CodeableConcept","ExplanationOfBenefit.addItem.detail.modifierExtension":"Extension","ExplanationOfBenefit.addItem.detail.net":"Money","ExplanationOfBenefit.addItem.detail.noteNumber":"positiveInt","ExplanationOfBenefit.addItem.detail.patientPaid":"Money","ExplanationOfBenefit.addItem.detail.productOrService":"CodeableConcept","ExplanationOfBenefit.addItem.detail.productOrServiceEnd":"CodeableConcept","ExplanationOfBenefit.addItem.detail.quantity":"Quantity","ExplanationOfBenefit.addItem.detail.revenue":"CodeableConcept","ExplanationOfBenefit.addItem.detail.subDetail":"BackboneElement","ExplanationOfBenefit.addItem.detail.subDetail.extension":"Extension","ExplanationOfBenefit.addItem.detail.subDetail.factor":"decimal","ExplanationOfBenefit.addItem.detail.subDetail.id":"System.String","ExplanationOfBenefit.addItem.detail.subDetail.modifier":"CodeableConcept","ExplanationOfBenefit.addItem.detail.subDetail.modifierExtension":"Extension","ExplanationOfBenefit.addItem.detail.subDetail.net":"Money","ExplanationOfBenefit.addItem.detail.subDetail.noteNumber":"positiveInt","ExplanationOfBenefit.addItem.detail.subDetail.patientPaid":"Money","ExplanationOfBenefit.addItem.detail.subDetail.productOrService":"CodeableConcept","ExplanationOfBenefit.addItem.detail.subDetail.productOrServiceEnd":"CodeableConcept","ExplanationOfBenefit.addItem.detail.subDetail.quantity":"Quantity","ExplanationOfBenefit.addItem.detail.subDetail.revenue":"CodeableConcept","ExplanationOfBenefit.addItem.detail.subDetail.tax":"Money","ExplanationOfBenefit.addItem.detail.subDetail.traceNumber":"Identifier","ExplanationOfBenefit.addItem.detail.subDetail.unitPrice":"Money","ExplanationOfBenefit.addItem.detail.tax":"Money","ExplanationOfBenefit.addItem.detail.traceNumber":"Identifier","ExplanationOfBenefit.addItem.detail.unitPrice":"Money","ExplanationOfBenefit.addItem.detailSequence":"positiveInt","ExplanationOfBenefit.addItem.extension":"Extension","ExplanationOfBenefit.addItem.factor":"decimal","ExplanationOfBenefit.addItem.id":"System.String","ExplanationOfBenefit.addItem.itemSequence":"positiveInt","ExplanationOfBenefit.addItem.locationAddress":"Address","ExplanationOfBenefit.addItem.locationCodeableConcept":"CodeableConcept","ExplanationOfBenefit.addItem.locationReference":"Reference","ExplanationOfBenefit.addItem.modifier":"CodeableConcept","ExplanationOfBenefit.addItem.modifierExtension":"Extension","ExplanationOfBenefit.addItem.net":"Money","ExplanationOfBenefit.addItem.noteNumber":"positiveInt","ExplanationOfBenefit.addItem.patientPaid":"Money","ExplanationOfBenefit.addItem.productOrService":"CodeableConcept","ExplanationOfBenefit.addItem.productOrServiceEnd":"CodeableConcept","ExplanationOfBenefit.addItem.programCode":"CodeableConcept","ExplanationOfBenefit.addItem.provider":"Reference","ExplanationOfBenefit.addItem.quantity":"Quantity","ExplanationOfBenefit.addItem.request":"Reference","ExplanationOfBenefit.addItem.revenue":"CodeableConcept","ExplanationOfBenefit.addItem.servicedDate":"date","ExplanationOfBenefit.addItem.servicedPeriod":"Period","ExplanationOfBenefit.addItem.subDetailSequence":"positiveInt","ExplanationOfBenefit.addItem.tax":"Money","ExplanationOfBenefit.addItem.traceNumber":"Identifier","ExplanationOfBenefit.addItem.unitPrice":"Money","ExplanationOfBenefit.benefitBalance":"BackboneElement","ExplanationOfBenefit.benefitBalance.category":"CodeableConcept","ExplanationOfBenefit.benefitBalance.description":"string","ExplanationOfBenefit.benefitBalance.excluded":"boolean","ExplanationOfBenefit.benefitBalance.extension":"Extension","ExplanationOfBenefit.benefitBalance.financial":"BackboneElement","ExplanationOfBenefit.benefitBalance.financial.allowedMoney":"Money","ExplanationOfBenefit.benefitBalance.financial.allowedString":"string","ExplanationOfBenefit.benefitBalance.financial.allowedUnsignedInt":"unsignedInt","ExplanationOfBenefit.benefitBalance.financial.extension":"Extension","ExplanationOfBenefit.benefitBalance.financial.id":"System.String","ExplanationOfBenefit.benefitBalance.financial.modifierExtension":"Extension","ExplanationOfBenefit.benefitBalance.financial.type":"CodeableConcept","ExplanationOfBenefit.benefitBalance.financial.usedMoney":"Money","ExplanationOfBenefit.benefitBalance.financial.usedUnsignedInt":"unsignedInt","ExplanationOfBenefit.benefitBalance.id":"System.String","ExplanationOfBenefit.benefitBalance.modifierExtension":"Extension","ExplanationOfBenefit.benefitBalance.name":"string","ExplanationOfBenefit.benefitBalance.network":"CodeableConcept","ExplanationOfBenefit.benefitBalance.term":"CodeableConcept","ExplanationOfBenefit.benefitBalance.unit":"CodeableConcept","ExplanationOfBenefit.benefitPeriod":"Period","ExplanationOfBenefit.billablePeriod":"Period","ExplanationOfBenefit.careTeam":"BackboneElement","ExplanationOfBenefit.careTeam.extension":"Extension","ExplanationOfBenefit.careTeam.id":"System.String","ExplanationOfBenefit.careTeam.modifierExtension":"Extension","ExplanationOfBenefit.careTeam.provider":"Reference","ExplanationOfBenefit.careTeam.responsible":"boolean","ExplanationOfBenefit.careTeam.role":"CodeableConcept","ExplanationOfBenefit.careTeam.sequence":"positiveInt","ExplanationOfBenefit.careTeam.specialty":"CodeableConcept","ExplanationOfBenefit.claim":"Reference","ExplanationOfBenefit.claimResponse":"Reference","ExplanationOfBenefit.contained":"Resource","ExplanationOfBenefit.created":"dateTime","ExplanationOfBenefit.decision":"CodeableConcept","ExplanationOfBenefit.diagnosis":"BackboneElement","ExplanationOfBenefit.diagnosis.diagnosisCodeableConcept":"CodeableConcept","ExplanationOfBenefit.diagnosis.diagnosisReference":"Reference","ExplanationOfBenefit.diagnosis.extension":"Extension","ExplanationOfBenefit.diagnosis.id":"System.String","ExplanationOfBenefit.diagnosis.modifierExtension":"Extension","ExplanationOfBenefit.diagnosis.onAdmission":"CodeableConcept","ExplanationOfBenefit.diagnosis.sequence":"positiveInt","ExplanationOfBenefit.diagnosis.type":"CodeableConcept","ExplanationOfBenefit.diagnosisRelatedGroup":"CodeableConcept","ExplanationOfBenefit.disposition":"string","ExplanationOfBenefit.encounter":"Reference","ExplanationOfBenefit.enterer":"Reference","ExplanationOfBenefit.event":"BackboneElement","ExplanationOfBenefit.event.extension":"Extension","ExplanationOfBenefit.event.id":"System.String","ExplanationOfBenefit.event.modifierExtension":"Extension","ExplanationOfBenefit.event.type":"CodeableConcept","ExplanationOfBenefit.event.whenDateTime":"dateTime","ExplanationOfBenefit.event.whenPeriod":"Period","ExplanationOfBenefit.extension":"Extension","ExplanationOfBenefit.facility":"Reference","ExplanationOfBenefit.form":"Attachment","ExplanationOfBenefit.formCode":"CodeableConcept","ExplanationOfBenefit.fundsReserve":"CodeableConcept","ExplanationOfBenefit.fundsReserveRequested":"CodeableConcept","ExplanationOfBenefit.id":"System.String","ExplanationOfBenefit.identifier":"Identifier","ExplanationOfBenefit.implicitRules":"uri","ExplanationOfBenefit.insurance":"BackboneElement","ExplanationOfBenefit.insurance.coverage":"Reference","ExplanationOfBenefit.insurance.extension":"Extension","ExplanationOfBenefit.insurance.focal":"boolean","ExplanationOfBenefit.insurance.id":"System.String","ExplanationOfBenefit.insurance.modifierExtension":"Extension","ExplanationOfBenefit.insurance.preAuthRef":"string","ExplanationOfBenefit.insurer":"Reference","ExplanationOfBenefit.item":"BackboneElement","ExplanationOfBenefit.item.adjudication":"BackboneElement","ExplanationOfBenefit.item.adjudication.amount":"Money","ExplanationOfBenefit.item.adjudication.category":"CodeableConcept","ExplanationOfBenefit.item.adjudication.extension":"Extension","ExplanationOfBenefit.item.adjudication.id":"System.String","ExplanationOfBenefit.item.adjudication.modifierExtension":"Extension","ExplanationOfBenefit.item.adjudication.quantity":"Quantity","ExplanationOfBenefit.item.adjudication.reason":"CodeableConcept","ExplanationOfBenefit.item.bodySite":"BackboneElement","ExplanationOfBenefit.item.bodySite.extension":"Extension","ExplanationOfBenefit.item.bodySite.id":"System.String","ExplanationOfBenefit.item.bodySite.modifierExtension":"Extension","ExplanationOfBenefit.item.bodySite.site":"CodeableReference","ExplanationOfBenefit.item.bodySite.subSite":"CodeableConcept","ExplanationOfBenefit.item.careTeamSequence":"positiveInt","ExplanationOfBenefit.item.category":"CodeableConcept","ExplanationOfBenefit.item.detail":"BackboneElement","ExplanationOfBenefit.item.detail.category":"CodeableConcept","ExplanationOfBenefit.item.detail.extension":"Extension","ExplanationOfBenefit.item.detail.factor":"decimal","ExplanationOfBenefit.item.detail.id":"System.String","ExplanationOfBenefit.item.detail.modifier":"CodeableConcept","ExplanationOfBenefit.item.detail.modifierExtension":"Extension","ExplanationOfBenefit.item.detail.net":"Money","ExplanationOfBenefit.item.detail.noteNumber":"positiveInt","ExplanationOfBenefit.item.detail.patientPaid":"Money","ExplanationOfBenefit.item.detail.productOrService":"CodeableConcept","ExplanationOfBenefit.item.detail.productOrServiceEnd":"CodeableConcept","ExplanationOfBenefit.item.detail.programCode":"CodeableConcept","ExplanationOfBenefit.item.detail.quantity":"Quantity","ExplanationOfBenefit.item.detail.revenue":"CodeableConcept","ExplanationOfBenefit.item.detail.sequence":"positiveInt","ExplanationOfBenefit.item.detail.subDetail":"BackboneElement","ExplanationOfBenefit.item.detail.subDetail.category":"CodeableConcept","ExplanationOfBenefit.item.detail.subDetail.extension":"Extension","ExplanationOfBenefit.item.detail.subDetail.factor":"decimal","ExplanationOfBenefit.item.detail.subDetail.id":"System.String","ExplanationOfBenefit.item.detail.subDetail.modifier":"CodeableConcept","ExplanationOfBenefit.item.detail.subDetail.modifierExtension":"Extension","ExplanationOfBenefit.item.detail.subDetail.net":"Money","ExplanationOfBenefit.item.detail.subDetail.noteNumber":"positiveInt","ExplanationOfBenefit.item.detail.subDetail.patientPaid":"Money","ExplanationOfBenefit.item.detail.subDetail.productOrService":"CodeableConcept","ExplanationOfBenefit.item.detail.subDetail.productOrServiceEnd":"CodeableConcept","ExplanationOfBenefit.item.detail.subDetail.programCode":"CodeableConcept","ExplanationOfBenefit.item.detail.subDetail.quantity":"Quantity","ExplanationOfBenefit.item.detail.subDetail.revenue":"CodeableConcept","ExplanationOfBenefit.item.detail.subDetail.sequence":"positiveInt","ExplanationOfBenefit.item.detail.subDetail.tax":"Money","ExplanationOfBenefit.item.detail.subDetail.traceNumber":"Identifier","ExplanationOfBenefit.item.detail.subDetail.udi":"Reference","ExplanationOfBenefit.item.detail.subDetail.unitPrice":"Money","ExplanationOfBenefit.item.detail.tax":"Money","ExplanationOfBenefit.item.detail.traceNumber":"Identifier","ExplanationOfBenefit.item.detail.udi":"Reference","ExplanationOfBenefit.item.detail.unitPrice":"Money","ExplanationOfBenefit.item.diagnosisSequence":"positiveInt","ExplanationOfBenefit.item.encounter":"Reference","ExplanationOfBenefit.item.extension":"Extension","ExplanationOfBenefit.item.factor":"decimal","ExplanationOfBenefit.item.id":"System.String","ExplanationOfBenefit.item.informationSequence":"positiveInt","ExplanationOfBenefit.item.locationAddress":"Address","ExplanationOfBenefit.item.locationCodeableConcept":"CodeableConcept","ExplanationOfBenefit.item.locationReference":"Reference","ExplanationOfBenefit.item.modifier":"CodeableConcept","ExplanationOfBenefit.item.modifierExtension":"Extension","ExplanationOfBenefit.item.net":"Money","ExplanationOfBenefit.item.noteNumber":"positiveInt","ExplanationOfBenefit.item.patientPaid":"Money","ExplanationOfBenefit.item.procedureSequence":"positiveInt","ExplanationOfBenefit.item.productOrService":"CodeableConcept","ExplanationOfBenefit.item.productOrServiceEnd":"CodeableConcept","ExplanationOfBenefit.item.programCode":"CodeableConcept","ExplanationOfBenefit.item.quantity":"Quantity","ExplanationOfBenefit.item.request":"Reference","ExplanationOfBenefit.item.revenue":"CodeableConcept","ExplanationOfBenefit.item.reviewOutcome":"BackboneElement","ExplanationOfBenefit.item.reviewOutcome.decision":"CodeableConcept","ExplanationOfBenefit.item.reviewOutcome.extension":"Extension","ExplanationOfBenefit.item.reviewOutcome.id":"System.String","ExplanationOfBenefit.item.reviewOutcome.modifierExtension":"Extension","ExplanationOfBenefit.item.reviewOutcome.preAuthPeriod":"Period","ExplanationOfBenefit.item.reviewOutcome.preAuthRef":"string","ExplanationOfBenefit.item.reviewOutcome.reason":"CodeableConcept","ExplanationOfBenefit.item.sequence":"positiveInt","ExplanationOfBenefit.item.servicedDate":"date","ExplanationOfBenefit.item.servicedPeriod":"Period","ExplanationOfBenefit.item.tax":"Money","ExplanationOfBenefit.item.traceNumber":"Identifier","ExplanationOfBenefit.item.udi":"Reference","ExplanationOfBenefit.item.unitPrice":"Money","ExplanationOfBenefit.language":"code","ExplanationOfBenefit.meta":"Meta","ExplanationOfBenefit.modifierExtension":"Extension","ExplanationOfBenefit.originalPrescription":"Reference","ExplanationOfBenefit.outcome":"code","ExplanationOfBenefit.patient":"Reference","ExplanationOfBenefit.patientPaid":"Money","ExplanationOfBenefit.payee":"BackboneElement","ExplanationOfBenefit.payee.extension":"Extension","ExplanationOfBenefit.payee.id":"System.String","ExplanationOfBenefit.payee.modifierExtension":"Extension","ExplanationOfBenefit.payee.party":"Reference","ExplanationOfBenefit.payee.type":"CodeableConcept","ExplanationOfBenefit.payment":"BackboneElement","ExplanationOfBenefit.payment.adjustment":"Money","ExplanationOfBenefit.payment.adjustmentReason":"CodeableConcept","ExplanationOfBenefit.payment.amount":"Money","ExplanationOfBenefit.payment.date":"date","ExplanationOfBenefit.payment.extension":"Extension","ExplanationOfBenefit.payment.id":"System.String","ExplanationOfBenefit.payment.identifier":"Identifier","ExplanationOfBenefit.payment.modifierExtension":"Extension","ExplanationOfBenefit.payment.type":"CodeableConcept","ExplanationOfBenefit.preAuthRef":"string","ExplanationOfBenefit.preAuthRefPeriod":"Period","ExplanationOfBenefit.precedence":"positiveInt","ExplanationOfBenefit.prescription":"Reference","ExplanationOfBenefit.priority":"CodeableConcept","ExplanationOfBenefit.procedure":"BackboneElement","ExplanationOfBenefit.procedure.date":"dateTime","ExplanationOfBenefit.procedure.extension":"Extension","ExplanationOfBenefit.procedure.id":"System.String","ExplanationOfBenefit.procedure.modifierExtension":"Extension","ExplanationOfBenefit.procedure.procedureCodeableConcept":"CodeableConcept","ExplanationOfBenefit.procedure.procedureReference":"Reference","ExplanationOfBenefit.procedure.sequence":"positiveInt","ExplanationOfBenefit.procedure.type":"CodeableConcept","ExplanationOfBenefit.procedure.udi":"Reference","ExplanationOfBenefit.processNote":"BackboneElement","ExplanationOfBenefit.processNote.extension":"Extension","ExplanationOfBenefit.processNote.id":"System.String","ExplanationOfBenefit.processNote.language":"CodeableConcept","ExplanationOfBenefit.processNote.modifierExtension":"Extension","ExplanationOfBenefit.processNote.number":"positiveInt","ExplanationOfBenefit.processNote.text":"string","ExplanationOfBenefit.processNote.type":"CodeableConcept","ExplanationOfBenefit.provider":"Reference","ExplanationOfBenefit.referral":"Reference","ExplanationOfBenefit.related":"BackboneElement","ExplanationOfBenefit.related.claim":"Reference","ExplanationOfBenefit.related.extension":"Extension","ExplanationOfBenefit.related.id":"System.String","ExplanationOfBenefit.related.modifierExtension":"Extension","ExplanationOfBenefit.related.reference":"Identifier","ExplanationOfBenefit.related.relationship":"CodeableConcept","ExplanationOfBenefit.status":"code","ExplanationOfBenefit.subType":"CodeableConcept","ExplanationOfBenefit.supportingInfo":"BackboneElement","ExplanationOfBenefit.supportingInfo.category":"CodeableConcept","ExplanationOfBenefit.supportingInfo.code":"CodeableConcept","ExplanationOfBenefit.supportingInfo.extension":"Extension","ExplanationOfBenefit.supportingInfo.id":"System.String","ExplanationOfBenefit.supportingInfo.modifierExtension":"Extension","ExplanationOfBenefit.supportingInfo.reason":"Coding","ExplanationOfBenefit.supportingInfo.sequence":"positiveInt","ExplanationOfBenefit.supportingInfo.timingDate":"date","ExplanationOfBenefit.supportingInfo.timingPeriod":"Period","ExplanationOfBenefit.supportingInfo.valueAttachment":"Attachment","ExplanationOfBenefit.supportingInfo.valueBoolean":"boolean","ExplanationOfBenefit.supportingInfo.valueIdentifier":"Identifier","ExplanationOfBenefit.supportingInfo.valueQuantity":"Quantity","ExplanationOfBenefit.supportingInfo.valueReference":"Reference","ExplanationOfBenefit.supportingInfo.valueString":"string","ExplanationOfBenefit.text":"Narrative","ExplanationOfBenefit.total":"BackboneElement","ExplanationOfBenefit.total.amount":"Money","ExplanationOfBenefit.total.category":"CodeableConcept","ExplanationOfBenefit.total.extension":"Extension","ExplanationOfBenefit.total.id":"System.String","ExplanationOfBenefit.total.modifierExtension":"Extension","ExplanationOfBenefit.traceNumber":"Identifier","ExplanationOfBenefit.type":"CodeableConcept","ExplanationOfBenefit.use":"code","Expression.description":"string","Expression.expression":"string","Expression.extension":"Extension","Expression.id":"System.String","Expression.language":"code","Expression.name":"code","Expression.reference":"uri","ExtendedContactDetail.address":"Address","ExtendedContactDetail.extension":"Extension","ExtendedContactDetail.id":"System.String","ExtendedContactDetail.name":"HumanName","ExtendedContactDetail.organization":"Reference","ExtendedContactDetail.period":"Period","ExtendedContactDetail.purpose":"CodeableConcept","ExtendedContactDetail.telecom":"ContactPoint","Extension.extension":"Extension","Extension.id":"System.String","Extension.url":"System.String","Extension.valueAddress":"Address","Extension.valueAge":"Age","Extension.valueAnnotation":"Annotation","Extension.valueAttachment":"Attachment","Extension.valueAvailability":"Availability","Extension.valueBase64Binary":"base64Binary","Extension.valueBoolean":"boolean","Extension.valueCanonical":"canonical","Extension.valueCode":"code","Extension.valueCodeableConcept":"CodeableConcept","Extension.valueCodeableReference":"CodeableReference","Extension.valueCoding":"Coding","Extension.valueContactDetail":"ContactDetail","Extension.valueContactPoint":"ContactPoint","Extension.valueCount":"Count","Extension.valueDataRequirement":"DataRequirement","Extension.valueDate":"date","Extension.valueDateTime":"dateTime","Extension.valueDecimal":"decimal","Extension.valueDistance":"Distance","Extension.valueDosage":"Dosage","Extension.valueDuration":"Duration","Extension.valueExpression":"Expression","Extension.valueExtendedContactDetail":"ExtendedContactDetail","Extension.valueHumanName":"HumanName","Extension.valueId":"id","Extension.valueIdentifier":"Identifier","Extension.valueInstant":"instant","Extension.valueInteger":"integer","Extension.valueInteger64":"integer64","Extension.valueMarkdown":"markdown","Extension.valueMeta":"Meta","Extension.valueMoney":"Money","Extension.valueOid":"oid","Extension.valueParameterDefinition":"ParameterDefinition","Extension.valuePeriod":"Period","Extension.valuePositiveInt":"positiveInt","Extension.valueQuantity":"Quantity","Extension.valueRange":"Range","Extension.valueRatio":"Ratio","Extension.valueRatioRange":"RatioRange","Extension.valueReference":"Reference","Extension.valueRelatedArtifact":"RelatedArtifact","Extension.valueSampledData":"SampledData","Extension.valueSignature":"Signature","Extension.valueString":"string","Extension.valueTime":"time","Extension.valueTiming":"Timing","Extension.valueTriggerDefinition":"TriggerDefinition","Extension.valueUnsignedInt":"unsignedInt","Extension.valueUri":"uri","Extension.valueUrl":"url","Extension.valueUsageContext":"UsageContext","Extension.valueUuid":"uuid","FamilyMemberHistory.ageAge":"Age","FamilyMemberHistory.ageRange":"Range","FamilyMemberHistory.ageString":"string","FamilyMemberHistory.bornDate":"date","FamilyMemberHistory.bornPeriod":"Period","FamilyMemberHistory.bornString":"string","FamilyMemberHistory.condition":"BackboneElement","FamilyMemberHistory.condition.code":"CodeableConcept","FamilyMemberHistory.condition.contributedToDeath":"boolean","FamilyMemberHistory.condition.extension":"Extension","FamilyMemberHistory.condition.id":"System.String","FamilyMemberHistory.condition.modifierExtension":"Extension","FamilyMemberHistory.condition.note":"Annotation","FamilyMemberHistory.condition.onsetAge":"Age","FamilyMemberHistory.condition.onsetPeriod":"Period","FamilyMemberHistory.condition.onsetRange":"Range","FamilyMemberHistory.condition.onsetString":"string","FamilyMemberHistory.condition.outcome":"CodeableConcept","FamilyMemberHistory.contained":"Resource","FamilyMemberHistory.dataAbsentReason":"CodeableConcept","FamilyMemberHistory.date":"dateTime","FamilyMemberHistory.deceasedAge":"Age","FamilyMemberHistory.deceasedBoolean":"boolean","FamilyMemberHistory.deceasedDate":"date","FamilyMemberHistory.deceasedRange":"Range","FamilyMemberHistory.deceasedString":"string","FamilyMemberHistory.estimatedAge":"boolean","FamilyMemberHistory.extension":"Extension","FamilyMemberHistory.id":"System.String","FamilyMemberHistory.identifier":"Identifier","FamilyMemberHistory.implicitRules":"uri","FamilyMemberHistory.instantiatesCanonical":"canonical","FamilyMemberHistory.instantiatesUri":"uri","FamilyMemberHistory.language":"code","FamilyMemberHistory.meta":"Meta","FamilyMemberHistory.modifierExtension":"Extension","FamilyMemberHistory.name":"string","FamilyMemberHistory.note":"Annotation","FamilyMemberHistory.participant":"BackboneElement","FamilyMemberHistory.participant.actor":"Reference","FamilyMemberHistory.participant.extension":"Extension","FamilyMemberHistory.participant.function":"CodeableConcept","FamilyMemberHistory.participant.id":"System.String","FamilyMemberHistory.participant.modifierExtension":"Extension","FamilyMemberHistory.patient":"Reference","FamilyMemberHistory.procedure":"BackboneElement","FamilyMemberHistory.procedure.code":"CodeableConcept","FamilyMemberHistory.procedure.contributedToDeath":"boolean","FamilyMemberHistory.procedure.extension":"Extension","FamilyMemberHistory.procedure.id":"System.String","FamilyMemberHistory.procedure.modifierExtension":"Extension","FamilyMemberHistory.procedure.note":"Annotation","FamilyMemberHistory.procedure.outcome":"CodeableConcept","FamilyMemberHistory.procedure.performedAge":"Age","FamilyMemberHistory.procedure.performedDateTime":"dateTime","FamilyMemberHistory.procedure.performedPeriod":"Period","FamilyMemberHistory.procedure.performedRange":"Range","FamilyMemberHistory.procedure.performedString":"string","FamilyMemberHistory.reason":"CodeableReference","FamilyMemberHistory.relationship":"CodeableConcept","FamilyMemberHistory.sex":"CodeableConcept","FamilyMemberHistory.status":"code","FamilyMemberHistory.text":"Narrative","Flag.author":"Reference","Flag.category":"CodeableConcept","Flag.code":"CodeableConcept","Flag.contained":"Resource","Flag.encounter":"Reference","Flag.extension":"Extension","Flag.id":"System.String","Flag.identifier":"Identifier","Flag.implicitRules":"uri","Flag.language":"code","Flag.meta":"Meta","Flag.modifierExtension":"Extension","Flag.period":"Period","Flag.status":"code","Flag.subject":"Reference","Flag.text":"Narrative","FormularyItem.code":"CodeableConcept","FormularyItem.contained":"Resource","FormularyItem.extension":"Extension","FormularyItem.id":"System.String","FormularyItem.identifier":"Identifier","FormularyItem.implicitRules":"uri","FormularyItem.language":"code","FormularyItem.meta":"Meta","FormularyItem.modifierExtension":"Extension","FormularyItem.status":"code","FormularyItem.text":"Narrative","GenomicStudy.analysis":"BackboneElement","GenomicStudy.analysis.changeType":"CodeableConcept","GenomicStudy.analysis.date":"dateTime","GenomicStudy.analysis.device":"BackboneElement","GenomicStudy.analysis.device.device":"Reference","GenomicStudy.analysis.device.extension":"Extension","GenomicStudy.analysis.device.function":"CodeableConcept","GenomicStudy.analysis.device.id":"System.String","GenomicStudy.analysis.device.modifierExtension":"Extension","GenomicStudy.analysis.extension":"Extension","GenomicStudy.analysis.focus":"Reference","GenomicStudy.analysis.genomeBuild":"CodeableConcept","GenomicStudy.analysis.id":"System.String","GenomicStudy.analysis.identifier":"Identifier","GenomicStudy.analysis.input":"BackboneElement","GenomicStudy.analysis.input.extension":"Extension","GenomicStudy.analysis.input.file":"Reference","GenomicStudy.analysis.input.generatedByIdentifier":"Identifier","GenomicStudy.analysis.input.generatedByReference":"Reference","GenomicStudy.analysis.input.id":"System.String","GenomicStudy.analysis.input.modifierExtension":"Extension","GenomicStudy.analysis.input.type":"CodeableConcept","GenomicStudy.analysis.instantiatesCanonical":"canonical","GenomicStudy.analysis.instantiatesUri":"uri","GenomicStudy.analysis.methodType":"CodeableConcept","GenomicStudy.analysis.modifierExtension":"Extension","GenomicStudy.analysis.note":"Annotation","GenomicStudy.analysis.output":"BackboneElement","GenomicStudy.analysis.output.extension":"Extension","GenomicStudy.analysis.output.file":"Reference","GenomicStudy.analysis.output.id":"System.String","GenomicStudy.analysis.output.modifierExtension":"Extension","GenomicStudy.analysis.output.type":"CodeableConcept","GenomicStudy.analysis.performer":"BackboneElement","GenomicStudy.analysis.performer.actor":"Reference","GenomicStudy.analysis.performer.extension":"Extension","GenomicStudy.analysis.performer.id":"System.String","GenomicStudy.analysis.performer.modifierExtension":"Extension","GenomicStudy.analysis.performer.role":"CodeableConcept","GenomicStudy.analysis.protocolPerformed":"Reference","GenomicStudy.analysis.regionsCalled":"Reference","GenomicStudy.analysis.regionsStudied":"Reference","GenomicStudy.analysis.specimen":"Reference","GenomicStudy.analysis.title":"string","GenomicStudy.basedOn":"Reference","GenomicStudy.contained":"Resource","GenomicStudy.description":"markdown","GenomicStudy.encounter":"Reference","GenomicStudy.extension":"Extension","GenomicStudy.id":"System.String","GenomicStudy.identifier":"Identifier","GenomicStudy.implicitRules":"uri","GenomicStudy.instantiatesCanonical":"canonical","GenomicStudy.instantiatesUri":"uri","GenomicStudy.interpreter":"Reference","GenomicStudy.language":"code","GenomicStudy.meta":"Meta","GenomicStudy.modifierExtension":"Extension","GenomicStudy.note":"Annotation","GenomicStudy.reason":"CodeableReference","GenomicStudy.referrer":"Reference","GenomicStudy.startDate":"dateTime","GenomicStudy.status":"code","GenomicStudy.subject":"Reference","GenomicStudy.text":"Narrative","GenomicStudy.type":"CodeableConcept","Goal.achievementStatus":"CodeableConcept","Goal.addresses":"Reference","Goal.category":"CodeableConcept","Goal.contained":"Resource","Goal.continuous":"boolean","Goal.description":"CodeableConcept","Goal.extension":"Extension","Goal.id":"System.String","Goal.identifier":"Identifier","Goal.implicitRules":"uri","Goal.language":"code","Goal.lifecycleStatus":"code","Goal.meta":"Meta","Goal.modifierExtension":"Extension","Goal.note":"Annotation","Goal.outcome":"CodeableReference","Goal.priority":"CodeableConcept","Goal.source":"Reference","Goal.startCodeableConcept":"CodeableConcept","Goal.startDate":"date","Goal.statusDate":"date","Goal.statusReason":"string","Goal.subject":"Reference","Goal.target":"BackboneElement","Goal.target.detailBoolean":"boolean","Goal.target.detailCodeableConcept":"CodeableConcept","Goal.target.detailInteger":"integer","Goal.target.detailQuantity":"Quantity","Goal.target.detailRange":"Range","Goal.target.detailRatio":"Ratio","Goal.target.detailString":"string","Goal.target.dueDate":"date","Goal.target.dueDuration":"Duration","Goal.target.extension":"Extension","Goal.target.id":"System.String","Goal.target.measure":"CodeableConcept","Goal.target.modifierExtension":"Extension","Goal.text":"Narrative","GraphDefinition.contact":"ContactDetail","GraphDefinition.contained":"Resource","GraphDefinition.copyright":"markdown","GraphDefinition.copyrightLabel":"string","GraphDefinition.date":"dateTime","GraphDefinition.description":"markdown","GraphDefinition.experimental":"boolean","GraphDefinition.extension":"Extension","GraphDefinition.id":"System.String","GraphDefinition.identifier":"Identifier","GraphDefinition.implicitRules":"uri","GraphDefinition.jurisdiction":"CodeableConcept","GraphDefinition.language":"code","GraphDefinition.link":"BackboneElement","GraphDefinition.link.compartment":"BackboneElement","GraphDefinition.link.compartment.code":"code","GraphDefinition.link.compartment.description":"string","GraphDefinition.link.compartment.expression":"string","GraphDefinition.link.compartment.extension":"Extension","GraphDefinition.link.compartment.id":"System.String","GraphDefinition.link.compartment.modifierExtension":"Extension","GraphDefinition.link.compartment.rule":"code","GraphDefinition.link.compartment.use":"code","GraphDefinition.link.description":"string","GraphDefinition.link.extension":"Extension","GraphDefinition.link.id":"System.String","GraphDefinition.link.max":"string","GraphDefinition.link.min":"integer","GraphDefinition.link.modifierExtension":"Extension","GraphDefinition.link.params":"string","GraphDefinition.link.path":"string","GraphDefinition.link.sliceName":"string","GraphDefinition.link.sourceId":"id","GraphDefinition.link.targetId":"id","GraphDefinition.meta":"Meta","GraphDefinition.modifierExtension":"Extension","GraphDefinition.name":"string","GraphDefinition.node":"BackboneElement","GraphDefinition.node.description":"string","GraphDefinition.node.extension":"Extension","GraphDefinition.node.id":"System.String","GraphDefinition.node.modifierExtension":"Extension","GraphDefinition.node.nodeId":"id","GraphDefinition.node.profile":"canonical","GraphDefinition.node.type":"code","GraphDefinition.publisher":"string","GraphDefinition.purpose":"markdown","GraphDefinition.start":"id","GraphDefinition.status":"code","GraphDefinition.text":"Narrative","GraphDefinition.title":"string","GraphDefinition.url":"uri","GraphDefinition.useContext":"UsageContext","GraphDefinition.version":"string","GraphDefinition.versionAlgorithmCoding":"Coding","GraphDefinition.versionAlgorithmString":"string","Group.active":"boolean","Group.characteristic":"BackboneElement","Group.characteristic.code":"CodeableConcept","Group.characteristic.exclude":"boolean","Group.characteristic.extension":"Extension","Group.characteristic.id":"System.String","Group.characteristic.modifierExtension":"Extension","Group.characteristic.period":"Period","Group.characteristic.valueBoolean":"boolean","Group.characteristic.valueCodeableConcept":"CodeableConcept","Group.characteristic.valueQuantity":"Quantity","Group.characteristic.valueRange":"Range","Group.characteristic.valueReference":"Reference","Group.code":"CodeableConcept","Group.contained":"Resource","Group.description":"markdown","Group.extension":"Extension","Group.id":"System.String","Group.identifier":"Identifier","Group.implicitRules":"uri","Group.language":"code","Group.managingEntity":"Reference","Group.member":"BackboneElement","Group.member.entity":"Reference","Group.member.extension":"Extension","Group.member.id":"System.String","Group.member.inactive":"boolean","Group.member.modifierExtension":"Extension","Group.member.period":"Period","Group.membership":"code","Group.meta":"Meta","Group.modifierExtension":"Extension","Group.name":"string","Group.quantity":"unsignedInt","Group.text":"Narrative","Group.type":"code","GuidanceResponse.contained":"Resource","GuidanceResponse.dataRequirement":"DataRequirement","GuidanceResponse.encounter":"Reference","GuidanceResponse.evaluationMessage":"Reference","GuidanceResponse.extension":"Extension","GuidanceResponse.id":"System.String","GuidanceResponse.identifier":"Identifier","GuidanceResponse.implicitRules":"uri","GuidanceResponse.language":"code","GuidanceResponse.meta":"Meta","GuidanceResponse.modifierExtension":"Extension","GuidanceResponse.moduleCanonical":"canonical","GuidanceResponse.moduleCodeableConcept":"CodeableConcept","GuidanceResponse.moduleUri":"uri","GuidanceResponse.note":"Annotation","GuidanceResponse.occurrenceDateTime":"dateTime","GuidanceResponse.outputParameters":"Reference","GuidanceResponse.performer":"Reference","GuidanceResponse.reason":"CodeableReference","GuidanceResponse.requestIdentifier":"Identifier","GuidanceResponse.result":"Reference","GuidanceResponse.status":"code","GuidanceResponse.subject":"Reference","GuidanceResponse.text":"Narrative","HealthcareService.active":"boolean","HealthcareService.appointmentRequired":"boolean","HealthcareService.availability":"Availability","HealthcareService.category":"CodeableConcept","HealthcareService.characteristic":"CodeableConcept","HealthcareService.comment":"markdown","HealthcareService.communication":"CodeableConcept","HealthcareService.contact":"ExtendedContactDetail","HealthcareService.contained":"Resource","HealthcareService.coverageArea":"Reference","HealthcareService.eligibility":"BackboneElement","HealthcareService.eligibility.code":"CodeableConcept","HealthcareService.eligibility.comment":"markdown","HealthcareService.eligibility.extension":"Extension","HealthcareService.eligibility.id":"System.String","HealthcareService.eligibility.modifierExtension":"Extension","HealthcareService.endpoint":"Reference","HealthcareService.extension":"Extension","HealthcareService.extraDetails":"markdown","HealthcareService.id":"System.String","HealthcareService.identifier":"Identifier","HealthcareService.implicitRules":"uri","HealthcareService.language":"code","HealthcareService.location":"Reference","HealthcareService.meta":"Meta","HealthcareService.modifierExtension":"Extension","HealthcareService.name":"string","HealthcareService.offeredIn":"Reference","HealthcareService.photo":"Attachment","HealthcareService.program":"CodeableConcept","HealthcareService.providedBy":"Reference","HealthcareService.referralMethod":"CodeableConcept","HealthcareService.serviceProvisionCode":"CodeableConcept","HealthcareService.specialty":"CodeableConcept","HealthcareService.text":"Narrative","HealthcareService.type":"CodeableConcept","HumanName.extension":"Extension","HumanName.family":"string","HumanName.given":"string","HumanName.id":"System.String","HumanName.period":"Period","HumanName.prefix":"string","HumanName.suffix":"string","HumanName.text":"string","HumanName.use":"code","Identifier.assigner":"Reference","Identifier.extension":"Extension","Identifier.id":"System.String","Identifier.period":"Period","Identifier.system":"uri","Identifier.type":"CodeableConcept","Identifier.use":"code","Identifier.value":"string","ImagingSelection.basedOn":"Reference","ImagingSelection.bodySite":"CodeableReference","ImagingSelection.category":"CodeableConcept","ImagingSelection.code":"CodeableConcept","ImagingSelection.contained":"Resource","ImagingSelection.derivedFrom":"Reference","ImagingSelection.endpoint":"Reference","ImagingSelection.extension":"Extension","ImagingSelection.focus":"Reference","ImagingSelection.frameOfReferenceUid":"id","ImagingSelection.id":"System.String","ImagingSelection.identifier":"Identifier","ImagingSelection.implicitRules":"uri","ImagingSelection.instance":"BackboneElement","ImagingSelection.instance.extension":"Extension","ImagingSelection.instance.id":"System.String","ImagingSelection.instance.imageRegion2D":"BackboneElement","ImagingSelection.instance.imageRegion2D.coordinate":"decimal","ImagingSelection.instance.imageRegion2D.extension":"Extension","ImagingSelection.instance.imageRegion2D.id":"System.String","ImagingSelection.instance.imageRegion2D.modifierExtension":"Extension","ImagingSelection.instance.imageRegion2D.regionType":"code","ImagingSelection.instance.imageRegion3D":"BackboneElement","ImagingSelection.instance.imageRegion3D.coordinate":"decimal","ImagingSelection.instance.imageRegion3D.extension":"Extension","ImagingSelection.instance.imageRegion3D.id":"System.String","ImagingSelection.instance.imageRegion3D.modifierExtension":"Extension","ImagingSelection.instance.imageRegion3D.regionType":"code","ImagingSelection.instance.modifierExtension":"Extension","ImagingSelection.instance.number":"unsignedInt","ImagingSelection.instance.sopClass":"Coding","ImagingSelection.instance.subset":"string","ImagingSelection.instance.uid":"id","ImagingSelection.issued":"instant","ImagingSelection.language":"code","ImagingSelection.meta":"Meta","ImagingSelection.modifierExtension":"Extension","ImagingSelection.performer":"BackboneElement","ImagingSelection.performer.actor":"Reference","ImagingSelection.performer.extension":"Extension","ImagingSelection.performer.function":"CodeableConcept","ImagingSelection.performer.id":"System.String","ImagingSelection.performer.modifierExtension":"Extension","ImagingSelection.seriesNumber":"unsignedInt","ImagingSelection.seriesUid":"id","ImagingSelection.status":"code","ImagingSelection.studyUid":"id","ImagingSelection.subject":"Reference","ImagingSelection.text":"Narrative","ImagingStudy.basedOn":"Reference","ImagingStudy.contained":"Resource","ImagingStudy.description":"string","ImagingStudy.encounter":"Reference","ImagingStudy.endpoint":"Reference","ImagingStudy.extension":"Extension","ImagingStudy.id":"System.String","ImagingStudy.identifier":"Identifier","ImagingStudy.implicitRules":"uri","ImagingStudy.language":"code","ImagingStudy.location":"Reference","ImagingStudy.meta":"Meta","ImagingStudy.modality":"CodeableConcept","ImagingStudy.modifierExtension":"Extension","ImagingStudy.note":"Annotation","ImagingStudy.numberOfInstances":"unsignedInt","ImagingStudy.numberOfSeries":"unsignedInt","ImagingStudy.partOf":"Reference","ImagingStudy.procedure":"CodeableReference","ImagingStudy.reason":"CodeableReference","ImagingStudy.referrer":"Reference","ImagingStudy.series":"BackboneElement","ImagingStudy.series.bodySite":"CodeableReference","ImagingStudy.series.description":"string","ImagingStudy.series.endpoint":"Reference","ImagingStudy.series.extension":"Extension","ImagingStudy.series.id":"System.String","ImagingStudy.series.instance":"BackboneElement","ImagingStudy.series.instance.extension":"Extension","ImagingStudy.series.instance.id":"System.String","ImagingStudy.series.instance.modifierExtension":"Extension","ImagingStudy.series.instance.number":"unsignedInt","ImagingStudy.series.instance.sopClass":"Coding","ImagingStudy.series.instance.title":"string","ImagingStudy.series.instance.uid":"id","ImagingStudy.series.laterality":"CodeableConcept","ImagingStudy.series.modality":"CodeableConcept","ImagingStudy.series.modifierExtension":"Extension","ImagingStudy.series.number":"unsignedInt","ImagingStudy.series.numberOfInstances":"unsignedInt","ImagingStudy.series.performer":"BackboneElement","ImagingStudy.series.performer.actor":"Reference","ImagingStudy.series.performer.extension":"Extension","ImagingStudy.series.performer.function":"CodeableConcept","ImagingStudy.series.performer.id":"System.String","ImagingStudy.series.performer.modifierExtension":"Extension","ImagingStudy.series.specimen":"Reference","ImagingStudy.series.started":"dateTime","ImagingStudy.series.uid":"id","ImagingStudy.started":"dateTime","ImagingStudy.status":"code","ImagingStudy.subject":"Reference","ImagingStudy.text":"Narrative","Immunization.administeredProduct":"CodeableReference","Immunization.basedOn":"Reference","Immunization.contained":"Resource","Immunization.doseQuantity":"Quantity","Immunization.encounter":"Reference","Immunization.expirationDate":"date","Immunization.extension":"Extension","Immunization.fundingSource":"CodeableConcept","Immunization.id":"System.String","Immunization.identifier":"Identifier","Immunization.implicitRules":"uri","Immunization.informationSource":"CodeableReference","Immunization.isSubpotent":"boolean","Immunization.language":"code","Immunization.location":"Reference","Immunization.lotNumber":"string","Immunization.manufacturer":"CodeableReference","Immunization.meta":"Meta","Immunization.modifierExtension":"Extension","Immunization.note":"Annotation","Immunization.occurrenceDateTime":"dateTime","Immunization.occurrenceString":"string","Immunization.patient":"Reference","Immunization.performer":"BackboneElement","Immunization.performer.actor":"Reference","Immunization.performer.extension":"Extension","Immunization.performer.function":"CodeableConcept","Immunization.performer.id":"System.String","Immunization.performer.modifierExtension":"Extension","Immunization.primarySource":"boolean","Immunization.programEligibility":"BackboneElement","Immunization.programEligibility.extension":"Extension","Immunization.programEligibility.id":"System.String","Immunization.programEligibility.modifierExtension":"Extension","Immunization.programEligibility.program":"CodeableConcept","Immunization.programEligibility.programStatus":"CodeableConcept","Immunization.protocolApplied":"BackboneElement","Immunization.protocolApplied.authority":"Reference","Immunization.protocolApplied.doseNumber":"string","Immunization.protocolApplied.extension":"Extension","Immunization.protocolApplied.id":"System.String","Immunization.protocolApplied.modifierExtension":"Extension","Immunization.protocolApplied.series":"string","Immunization.protocolApplied.seriesDoses":"string","Immunization.protocolApplied.targetDisease":"CodeableConcept","Immunization.reaction":"BackboneElement","Immunization.reaction.date":"dateTime","Immunization.reaction.extension":"Extension","Immunization.reaction.id":"System.String","Immunization.reaction.manifestation":"CodeableReference","Immunization.reaction.modifierExtension":"Extension","Immunization.reaction.reported":"boolean","Immunization.reason":"CodeableReference","Immunization.route":"CodeableConcept","Immunization.site":"CodeableConcept","Immunization.status":"code","Immunization.statusReason":"CodeableConcept","Immunization.subpotentReason":"CodeableConcept","Immunization.supportingInformation":"Reference","Immunization.text":"Narrative","Immunization.vaccineCode":"CodeableConcept","ImmunizationEvaluation.authority":"Reference","ImmunizationEvaluation.contained":"Resource","ImmunizationEvaluation.date":"dateTime","ImmunizationEvaluation.description":"markdown","ImmunizationEvaluation.doseNumber":"string","ImmunizationEvaluation.doseStatus":"CodeableConcept","ImmunizationEvaluation.doseStatusReason":"CodeableConcept","ImmunizationEvaluation.extension":"Extension","ImmunizationEvaluation.id":"System.String","ImmunizationEvaluation.identifier":"Identifier","ImmunizationEvaluation.immunizationEvent":"Reference","ImmunizationEvaluation.implicitRules":"uri","ImmunizationEvaluation.language":"code","ImmunizationEvaluation.meta":"Meta","ImmunizationEvaluation.modifierExtension":"Extension","ImmunizationEvaluation.patient":"Reference","ImmunizationEvaluation.series":"string","ImmunizationEvaluation.seriesDoses":"string","ImmunizationEvaluation.status":"code","ImmunizationEvaluation.targetDisease":"CodeableConcept","ImmunizationEvaluation.text":"Narrative","ImmunizationRecommendation.authority":"Reference","ImmunizationRecommendation.contained":"Resource","ImmunizationRecommendation.date":"dateTime","ImmunizationRecommendation.extension":"Extension","ImmunizationRecommendation.id":"System.String","ImmunizationRecommendation.identifier":"Identifier","ImmunizationRecommendation.implicitRules":"uri","ImmunizationRecommendation.language":"code","ImmunizationRecommendation.meta":"Meta","ImmunizationRecommendation.modifierExtension":"Extension","ImmunizationRecommendation.patient":"Reference","ImmunizationRecommendation.recommendation":"BackboneElement","ImmunizationRecommendation.recommendation.contraindicatedVaccineCode":"CodeableConcept","ImmunizationRecommendation.recommendation.dateCriterion":"BackboneElement","ImmunizationRecommendation.recommendation.dateCriterion.code":"CodeableConcept","ImmunizationRecommendation.recommendation.dateCriterion.extension":"Extension","ImmunizationRecommendation.recommendation.dateCriterion.id":"System.String","ImmunizationRecommendation.recommendation.dateCriterion.modifierExtension":"Extension","ImmunizationRecommendation.recommendation.dateCriterion.value":"dateTime","ImmunizationRecommendation.recommendation.description":"markdown","ImmunizationRecommendation.recommendation.doseNumber":"string","ImmunizationRecommendation.recommendation.extension":"Extension","ImmunizationRecommendation.recommendation.forecastReason":"CodeableConcept","ImmunizationRecommendation.recommendation.forecastStatus":"CodeableConcept","ImmunizationRecommendation.recommendation.id":"System.String","ImmunizationRecommendation.recommendation.modifierExtension":"Extension","ImmunizationRecommendation.recommendation.series":"string","ImmunizationRecommendation.recommendation.seriesDoses":"string","ImmunizationRecommendation.recommendation.supportingImmunization":"Reference","ImmunizationRecommendation.recommendation.supportingPatientInformation":"Reference","ImmunizationRecommendation.recommendation.targetDisease":"CodeableConcept","ImmunizationRecommendation.recommendation.vaccineCode":"CodeableConcept","ImmunizationRecommendation.text":"Narrative","ImplementationGuide.contact":"ContactDetail","ImplementationGuide.contained":"Resource","ImplementationGuide.copyright":"markdown","ImplementationGuide.copyrightLabel":"string","ImplementationGuide.date":"dateTime","ImplementationGuide.definition":"BackboneElement","ImplementationGuide.definition.extension":"Extension","ImplementationGuide.definition.grouping":"BackboneElement","ImplementationGuide.definition.grouping.description":"markdown","ImplementationGuide.definition.grouping.extension":"Extension","ImplementationGuide.definition.grouping.id":"System.String","ImplementationGuide.definition.grouping.modifierExtension":"Extension","ImplementationGuide.definition.grouping.name":"string","ImplementationGuide.definition.id":"System.String","ImplementationGuide.definition.modifierExtension":"Extension","ImplementationGuide.definition.page":"BackboneElement","ImplementationGuide.definition.page.extension":"Extension","ImplementationGuide.definition.page.generation":"code","ImplementationGuide.definition.page.id":"System.String","ImplementationGuide.definition.page.modifierExtension":"Extension","ImplementationGuide.definition.page.name":"url","ImplementationGuide.definition.page.sourceMarkdown":"markdown","ImplementationGuide.definition.page.sourceString":"string","ImplementationGuide.definition.page.sourceUrl":"url","ImplementationGuide.definition.page.title":"string","ImplementationGuide.definition.parameter":"BackboneElement","ImplementationGuide.definition.parameter.code":"Coding","ImplementationGuide.definition.parameter.extension":"Extension","ImplementationGuide.definition.parameter.id":"System.String","ImplementationGuide.definition.parameter.modifierExtension":"Extension","ImplementationGuide.definition.parameter.value":"string","ImplementationGuide.definition.resource":"BackboneElement","ImplementationGuide.definition.resource.description":"markdown","ImplementationGuide.definition.resource.extension":"Extension","ImplementationGuide.definition.resource.fhirVersion":"code","ImplementationGuide.definition.resource.groupingId":"id","ImplementationGuide.definition.resource.id":"System.String","ImplementationGuide.definition.resource.isExample":"boolean","ImplementationGuide.definition.resource.modifierExtension":"Extension","ImplementationGuide.definition.resource.name":"string","ImplementationGuide.definition.resource.profile":"canonical","ImplementationGuide.definition.resource.reference":"Reference","ImplementationGuide.definition.template":"BackboneElement","ImplementationGuide.definition.template.code":"code","ImplementationGuide.definition.template.extension":"Extension","ImplementationGuide.definition.template.id":"System.String","ImplementationGuide.definition.template.modifierExtension":"Extension","ImplementationGuide.definition.template.scope":"string","ImplementationGuide.definition.template.source":"string","ImplementationGuide.dependsOn":"BackboneElement","ImplementationGuide.dependsOn.extension":"Extension","ImplementationGuide.dependsOn.id":"System.String","ImplementationGuide.dependsOn.modifierExtension":"Extension","ImplementationGuide.dependsOn.packageId":"id","ImplementationGuide.dependsOn.reason":"markdown","ImplementationGuide.dependsOn.uri":"canonical","ImplementationGuide.dependsOn.version":"string","ImplementationGuide.description":"markdown","ImplementationGuide.experimental":"boolean","ImplementationGuide.extension":"Extension","ImplementationGuide.fhirVersion":"code","ImplementationGuide.global":"BackboneElement","ImplementationGuide.global.extension":"Extension","ImplementationGuide.global.id":"System.String","ImplementationGuide.global.modifierExtension":"Extension","ImplementationGuide.global.profile":"canonical","ImplementationGuide.global.type":"code","ImplementationGuide.id":"System.String","ImplementationGuide.identifier":"Identifier","ImplementationGuide.implicitRules":"uri","ImplementationGuide.jurisdiction":"CodeableConcept","ImplementationGuide.language":"code","ImplementationGuide.license":"code","ImplementationGuide.manifest":"BackboneElement","ImplementationGuide.manifest.extension":"Extension","ImplementationGuide.manifest.id":"System.String","ImplementationGuide.manifest.image":"string","ImplementationGuide.manifest.modifierExtension":"Extension","ImplementationGuide.manifest.other":"string","ImplementationGuide.manifest.page":"BackboneElement","ImplementationGuide.manifest.page.anchor":"string","ImplementationGuide.manifest.page.extension":"Extension","ImplementationGuide.manifest.page.id":"System.String","ImplementationGuide.manifest.page.modifierExtension":"Extension","ImplementationGuide.manifest.page.name":"string","ImplementationGuide.manifest.page.title":"string","ImplementationGuide.manifest.rendering":"url","ImplementationGuide.manifest.resource":"BackboneElement","ImplementationGuide.manifest.resource.extension":"Extension","ImplementationGuide.manifest.resource.id":"System.String","ImplementationGuide.manifest.resource.isExample":"boolean","ImplementationGuide.manifest.resource.modifierExtension":"Extension","ImplementationGuide.manifest.resource.profile":"canonical","ImplementationGuide.manifest.resource.reference":"Reference","ImplementationGuide.manifest.resource.relativePath":"url","ImplementationGuide.meta":"Meta","ImplementationGuide.modifierExtension":"Extension","ImplementationGuide.name":"string","ImplementationGuide.packageId":"id","ImplementationGuide.publisher":"string","ImplementationGuide.purpose":"markdown","ImplementationGuide.status":"code","ImplementationGuide.text":"Narrative","ImplementationGuide.title":"string","ImplementationGuide.url":"uri","ImplementationGuide.useContext":"UsageContext","ImplementationGuide.version":"string","ImplementationGuide.versionAlgorithmCoding":"Coding","ImplementationGuide.versionAlgorithmString":"string","Ingredient.allergenicIndicator":"boolean","Ingredient.comment":"markdown","Ingredient.contained":"Resource","Ingredient.extension":"Extension","Ingredient.for":"Reference","Ingredient.function":"CodeableConcept","Ingredient.group":"CodeableConcept","Ingredient.id":"System.String","Ingredient.identifier":"Identifier","Ingredient.implicitRules":"uri","Ingredient.language":"code","Ingredient.manufacturer":"BackboneElement","Ingredient.manufacturer.extension":"Extension","Ingredient.manufacturer.id":"System.String","Ingredient.manufacturer.manufacturer":"Reference","Ingredient.manufacturer.modifierExtension":"Extension","Ingredient.manufacturer.role":"code","Ingredient.meta":"Meta","Ingredient.modifierExtension":"Extension","Ingredient.role":"CodeableConcept","Ingredient.status":"code","Ingredient.substance":"BackboneElement","Ingredient.substance.code":"CodeableReference","Ingredient.substance.extension":"Extension","Ingredient.substance.id":"System.String","Ingredient.substance.modifierExtension":"Extension","Ingredient.substance.strength":"BackboneElement","Ingredient.substance.strength.basis":"CodeableConcept","Ingredient.substance.strength.concentrationCodeableConcept":"CodeableConcept","Ingredient.substance.strength.concentrationQuantity":"Quantity","Ingredient.substance.strength.concentrationRatio":"Ratio","Ingredient.substance.strength.concentrationRatioRange":"RatioRange","Ingredient.substance.strength.country":"CodeableConcept","Ingredient.substance.strength.extension":"Extension","Ingredient.substance.strength.id":"System.String","Ingredient.substance.strength.measurementPoint":"string","Ingredient.substance.strength.modifierExtension":"Extension","Ingredient.substance.strength.presentationCodeableConcept":"CodeableConcept","Ingredient.substance.strength.presentationQuantity":"Quantity","Ingredient.substance.strength.presentationRatio":"Ratio","Ingredient.substance.strength.presentationRatioRange":"RatioRange","Ingredient.substance.strength.referenceStrength":"BackboneElement","Ingredient.substance.strength.referenceStrength.country":"CodeableConcept","Ingredient.substance.strength.referenceStrength.extension":"Extension","Ingredient.substance.strength.referenceStrength.id":"System.String","Ingredient.substance.strength.referenceStrength.measurementPoint":"string","Ingredient.substance.strength.referenceStrength.modifierExtension":"Extension","Ingredient.substance.strength.referenceStrength.strengthQuantity":"Quantity","Ingredient.substance.strength.referenceStrength.strengthRatio":"Ratio","Ingredient.substance.strength.referenceStrength.strengthRatioRange":"RatioRange","Ingredient.substance.strength.referenceStrength.substance":"CodeableReference","Ingredient.substance.strength.textConcentration":"string","Ingredient.substance.strength.textPresentation":"string","Ingredient.text":"Narrative","InsurancePlan.administeredBy":"Reference","InsurancePlan.alias":"string","InsurancePlan.contact":"ExtendedContactDetail","InsurancePlan.contained":"Resource","InsurancePlan.coverage":"BackboneElement","InsurancePlan.coverage.benefit":"BackboneElement","InsurancePlan.coverage.benefit.extension":"Extension","InsurancePlan.coverage.benefit.id":"System.String","InsurancePlan.coverage.benefit.limit":"BackboneElement","InsurancePlan.coverage.benefit.limit.code":"CodeableConcept","InsurancePlan.coverage.benefit.limit.extension":"Extension","InsurancePlan.coverage.benefit.limit.id":"System.String","InsurancePlan.coverage.benefit.limit.modifierExtension":"Extension","InsurancePlan.coverage.benefit.limit.value":"Quantity","InsurancePlan.coverage.benefit.modifierExtension":"Extension","InsurancePlan.coverage.benefit.requirement":"string","InsurancePlan.coverage.benefit.type":"CodeableConcept","InsurancePlan.coverage.extension":"Extension","InsurancePlan.coverage.id":"System.String","InsurancePlan.coverage.modifierExtension":"Extension","InsurancePlan.coverage.network":"Reference","InsurancePlan.coverage.type":"CodeableConcept","InsurancePlan.coverageArea":"Reference","InsurancePlan.endpoint":"Reference","InsurancePlan.extension":"Extension","InsurancePlan.id":"System.String","InsurancePlan.identifier":"Identifier","InsurancePlan.implicitRules":"uri","InsurancePlan.language":"code","InsurancePlan.meta":"Meta","InsurancePlan.modifierExtension":"Extension","InsurancePlan.name":"string","InsurancePlan.network":"Reference","InsurancePlan.ownedBy":"Reference","InsurancePlan.period":"Period","InsurancePlan.plan":"BackboneElement","InsurancePlan.plan.coverageArea":"Reference","InsurancePlan.plan.extension":"Extension","InsurancePlan.plan.generalCost":"BackboneElement","InsurancePlan.plan.generalCost.comment":"string","InsurancePlan.plan.generalCost.cost":"Money","InsurancePlan.plan.generalCost.extension":"Extension","InsurancePlan.plan.generalCost.groupSize":"positiveInt","InsurancePlan.plan.generalCost.id":"System.String","InsurancePlan.plan.generalCost.modifierExtension":"Extension","InsurancePlan.plan.generalCost.type":"CodeableConcept","InsurancePlan.plan.id":"System.String","InsurancePlan.plan.identifier":"Identifier","InsurancePlan.plan.modifierExtension":"Extension","InsurancePlan.plan.network":"Reference","InsurancePlan.plan.specificCost":"BackboneElement","InsurancePlan.plan.specificCost.benefit":"BackboneElement","InsurancePlan.plan.specificCost.benefit.cost":"BackboneElement","InsurancePlan.plan.specificCost.benefit.cost.applicability":"CodeableConcept","InsurancePlan.plan.specificCost.benefit.cost.extension":"Extension","InsurancePlan.plan.specificCost.benefit.cost.id":"System.String","InsurancePlan.plan.specificCost.benefit.cost.modifierExtension":"Extension","InsurancePlan.plan.specificCost.benefit.cost.qualifiers":"CodeableConcept","InsurancePlan.plan.specificCost.benefit.cost.type":"CodeableConcept","InsurancePlan.plan.specificCost.benefit.cost.value":"Quantity","InsurancePlan.plan.specificCost.benefit.extension":"Extension","InsurancePlan.plan.specificCost.benefit.id":"System.String","InsurancePlan.plan.specificCost.benefit.modifierExtension":"Extension","InsurancePlan.plan.specificCost.benefit.type":"CodeableConcept","InsurancePlan.plan.specificCost.category":"CodeableConcept","InsurancePlan.plan.specificCost.extension":"Extension","InsurancePlan.plan.specificCost.id":"System.String","InsurancePlan.plan.specificCost.modifierExtension":"Extension","InsurancePlan.plan.type":"CodeableConcept","InsurancePlan.status":"code","InsurancePlan.text":"Narrative","InsurancePlan.type":"CodeableConcept","InventoryItem.association":"BackboneElement","InventoryItem.association.associationType":"CodeableConcept","InventoryItem.association.extension":"Extension","InventoryItem.association.id":"System.String","InventoryItem.association.modifierExtension":"Extension","InventoryItem.association.quantity":"Ratio","InventoryItem.association.relatedItem":"Reference","InventoryItem.baseUnit":"CodeableConcept","InventoryItem.category":"CodeableConcept","InventoryItem.characteristic":"BackboneElement","InventoryItem.characteristic.characteristicType":"CodeableConcept","InventoryItem.characteristic.extension":"Extension","InventoryItem.characteristic.id":"System.String","InventoryItem.characteristic.modifierExtension":"Extension","InventoryItem.characteristic.valueAddress":"Address","InventoryItem.characteristic.valueAnnotation":"Annotation","InventoryItem.characteristic.valueBoolean":"boolean","InventoryItem.characteristic.valueCodeableConcept":"CodeableConcept","InventoryItem.characteristic.valueDateTime":"dateTime","InventoryItem.characteristic.valueDecimal":"decimal","InventoryItem.characteristic.valueDuration":"Duration","InventoryItem.characteristic.valueInteger":"integer","InventoryItem.characteristic.valueQuantity":"Quantity","InventoryItem.characteristic.valueRange":"Range","InventoryItem.characteristic.valueRatio":"Ratio","InventoryItem.characteristic.valueString":"string","InventoryItem.characteristic.valueUrl":"url","InventoryItem.code":"CodeableConcept","InventoryItem.contained":"Resource","InventoryItem.description":"BackboneElement","InventoryItem.description.description":"string","InventoryItem.description.extension":"Extension","InventoryItem.description.id":"System.String","InventoryItem.description.language":"code","InventoryItem.description.modifierExtension":"Extension","InventoryItem.extension":"Extension","InventoryItem.id":"System.String","InventoryItem.identifier":"Identifier","InventoryItem.implicitRules":"uri","InventoryItem.instance":"BackboneElement","InventoryItem.instance.expiry":"dateTime","InventoryItem.instance.extension":"Extension","InventoryItem.instance.id":"System.String","InventoryItem.instance.identifier":"Identifier","InventoryItem.instance.location":"Reference","InventoryItem.instance.lotNumber":"string","InventoryItem.instance.modifierExtension":"Extension","InventoryItem.instance.subject":"Reference","InventoryItem.inventoryStatus":"CodeableConcept","InventoryItem.language":"code","InventoryItem.meta":"Meta","InventoryItem.modifierExtension":"Extension","InventoryItem.name":"BackboneElement","InventoryItem.name.extension":"Extension","InventoryItem.name.id":"System.String","InventoryItem.name.language":"code","InventoryItem.name.modifierExtension":"Extension","InventoryItem.name.name":"string","InventoryItem.name.nameType":"Coding","InventoryItem.netContent":"Quantity","InventoryItem.productReference":"Reference","InventoryItem.responsibleOrganization":"BackboneElement","InventoryItem.responsibleOrganization.extension":"Extension","InventoryItem.responsibleOrganization.id":"System.String","InventoryItem.responsibleOrganization.modifierExtension":"Extension","InventoryItem.responsibleOrganization.organization":"Reference","InventoryItem.responsibleOrganization.role":"CodeableConcept","InventoryItem.status":"code","InventoryItem.text":"Narrative","InventoryReport.contained":"Resource","InventoryReport.countType":"code","InventoryReport.extension":"Extension","InventoryReport.id":"System.String","InventoryReport.identifier":"Identifier","InventoryReport.implicitRules":"uri","InventoryReport.inventoryListing":"BackboneElement","InventoryReport.inventoryListing.countingDateTime":"dateTime","InventoryReport.inventoryListing.extension":"Extension","InventoryReport.inventoryListing.id":"System.String","InventoryReport.inventoryListing.item":"BackboneElement","InventoryReport.inventoryListing.item.category":"CodeableConcept","InventoryReport.inventoryListing.item.extension":"Extension","InventoryReport.inventoryListing.item.id":"System.String","InventoryReport.inventoryListing.item.item":"CodeableReference","InventoryReport.inventoryListing.item.modifierExtension":"Extension","InventoryReport.inventoryListing.item.quantity":"Quantity","InventoryReport.inventoryListing.itemStatus":"CodeableConcept","InventoryReport.inventoryListing.location":"Reference","InventoryReport.inventoryListing.modifierExtension":"Extension","InventoryReport.language":"code","InventoryReport.meta":"Meta","InventoryReport.modifierExtension":"Extension","InventoryReport.note":"Annotation","InventoryReport.operationType":"CodeableConcept","InventoryReport.operationTypeReason":"CodeableConcept","InventoryReport.reportedDateTime":"dateTime","InventoryReport.reporter":"Reference","InventoryReport.reportingPeriod":"Period","InventoryReport.status":"code","InventoryReport.text":"Narrative","Invoice.account":"Reference","Invoice.cancelledReason":"string","Invoice.contained":"Resource","Invoice.creation":"dateTime","Invoice.date":"dateTime","Invoice.extension":"Extension","Invoice.id":"System.String","Invoice.identifier":"Identifier","Invoice.implicitRules":"uri","Invoice.issuer":"Reference","Invoice.language":"code","Invoice.lineItem":"BackboneElement","Invoice.lineItem.chargeItemCodeableConcept":"CodeableConcept","Invoice.lineItem.chargeItemReference":"Reference","Invoice.lineItem.extension":"Extension","Invoice.lineItem.id":"System.String","Invoice.lineItem.modifierExtension":"Extension","Invoice.lineItem.priceComponent":"MonetaryComponent","Invoice.lineItem.sequence":"positiveInt","Invoice.lineItem.servicedDate":"date","Invoice.lineItem.servicedPeriod":"Period","Invoice.meta":"Meta","Invoice.modifierExtension":"Extension","Invoice.note":"Annotation","Invoice.participant":"BackboneElement","Invoice.participant.actor":"Reference","Invoice.participant.extension":"Extension","Invoice.participant.id":"System.String","Invoice.participant.modifierExtension":"Extension","Invoice.participant.role":"CodeableConcept","Invoice.paymentTerms":"markdown","Invoice.periodDate":"date","Invoice.periodPeriod":"Period","Invoice.recipient":"Reference","Invoice.status":"code","Invoice.subject":"Reference","Invoice.text":"Narrative","Invoice.totalGross":"Money","Invoice.totalNet":"Money","Invoice.totalPriceComponent":"MonetaryComponent","Invoice.type":"CodeableConcept","Library.approvalDate":"date","Library.author":"ContactDetail","Library.contact":"ContactDetail","Library.contained":"Resource","Library.content":"Attachment","Library.copyright":"markdown","Library.copyrightLabel":"string","Library.dataRequirement":"DataRequirement","Library.date":"dateTime","Library.description":"markdown","Library.editor":"ContactDetail","Library.effectivePeriod":"Period","Library.endorser":"ContactDetail","Library.experimental":"boolean","Library.extension":"Extension","Library.id":"System.String","Library.identifier":"Identifier","Library.implicitRules":"uri","Library.jurisdiction":"CodeableConcept","Library.language":"code","Library.lastReviewDate":"date","Library.meta":"Meta","Library.modifierExtension":"Extension","Library.name":"string","Library.parameter":"ParameterDefinition","Library.publisher":"string","Library.purpose":"markdown","Library.relatedArtifact":"RelatedArtifact","Library.reviewer":"ContactDetail","Library.status":"code","Library.subjectCodeableConcept":"CodeableConcept","Library.subjectReference":"Reference","Library.subtitle":"string","Library.text":"Narrative","Library.title":"string","Library.topic":"CodeableConcept","Library.type":"CodeableConcept","Library.url":"uri","Library.usage":"markdown","Library.useContext":"UsageContext","Library.version":"string","Library.versionAlgorithmCoding":"Coding","Library.versionAlgorithmString":"string","Linkage.active":"boolean","Linkage.author":"Reference","Linkage.contained":"Resource","Linkage.extension":"Extension","Linkage.id":"System.String","Linkage.implicitRules":"uri","Linkage.item":"BackboneElement","Linkage.item.extension":"Extension","Linkage.item.id":"System.String","Linkage.item.modifierExtension":"Extension","Linkage.item.resource":"Reference","Linkage.item.type":"code","Linkage.language":"code","Linkage.meta":"Meta","Linkage.modifierExtension":"Extension","Linkage.text":"Narrative","List.code":"CodeableConcept","List.contained":"Resource","List.date":"dateTime","List.emptyReason":"CodeableConcept","List.encounter":"Reference","List.entry":"BackboneElement","List.entry.date":"dateTime","List.entry.deleted":"boolean","List.entry.extension":"Extension","List.entry.flag":"CodeableConcept","List.entry.id":"System.String","List.entry.item":"Reference","List.entry.modifierExtension":"Extension","List.extension":"Extension","List.id":"System.String","List.identifier":"Identifier","List.implicitRules":"uri","List.language":"code","List.meta":"Meta","List.mode":"code","List.modifierExtension":"Extension","List.note":"Annotation","List.orderedBy":"CodeableConcept","List.source":"Reference","List.status":"code","List.subject":"Reference","List.text":"Narrative","List.title":"string","Location.address":"Address","Location.alias":"string","Location.characteristic":"CodeableConcept","Location.contact":"ExtendedContactDetail","Location.contained":"Resource","Location.description":"markdown","Location.endpoint":"Reference","Location.extension":"Extension","Location.form":"CodeableConcept","Location.hoursOfOperation":"Availability","Location.id":"System.String","Location.identifier":"Identifier","Location.implicitRules":"uri","Location.language":"code","Location.managingOrganization":"Reference","Location.meta":"Meta","Location.mode":"code","Location.modifierExtension":"Extension","Location.name":"string","Location.operationalStatus":"Coding","Location.partOf":"Reference","Location.position":"BackboneElement","Location.position.altitude":"decimal","Location.position.extension":"Extension","Location.position.id":"System.String","Location.position.latitude":"decimal","Location.position.longitude":"decimal","Location.position.modifierExtension":"Extension","Location.status":"code","Location.text":"Narrative","Location.type":"CodeableConcept","Location.virtualService":"VirtualServiceDetail","ManufacturedItemDefinition.component":"BackboneElement","ManufacturedItemDefinition.component.amount":"Quantity","ManufacturedItemDefinition.component.constituent":"BackboneElement","ManufacturedItemDefinition.component.constituent.amount":"Quantity","ManufacturedItemDefinition.component.constituent.extension":"Extension","ManufacturedItemDefinition.component.constituent.function":"CodeableConcept","ManufacturedItemDefinition.component.constituent.hasIngredient":"CodeableReference","ManufacturedItemDefinition.component.constituent.id":"System.String","ManufacturedItemDefinition.component.constituent.location":"CodeableConcept","ManufacturedItemDefinition.component.constituent.modifierExtension":"Extension","ManufacturedItemDefinition.component.extension":"Extension","ManufacturedItemDefinition.component.function":"CodeableConcept","ManufacturedItemDefinition.component.id":"System.String","ManufacturedItemDefinition.component.modifierExtension":"Extension","ManufacturedItemDefinition.component.type":"CodeableConcept","ManufacturedItemDefinition.contained":"Resource","ManufacturedItemDefinition.extension":"Extension","ManufacturedItemDefinition.id":"System.String","ManufacturedItemDefinition.identifier":"Identifier","ManufacturedItemDefinition.implicitRules":"uri","ManufacturedItemDefinition.ingredient":"CodeableConcept","ManufacturedItemDefinition.language":"code","ManufacturedItemDefinition.manufacturedDoseForm":"CodeableConcept","ManufacturedItemDefinition.manufacturer":"Reference","ManufacturedItemDefinition.marketingStatus":"MarketingStatus","ManufacturedItemDefinition.meta":"Meta","ManufacturedItemDefinition.modifierExtension":"Extension","ManufacturedItemDefinition.name":"string","ManufacturedItemDefinition.property":"BackboneElement","ManufacturedItemDefinition.property.extension":"Extension","ManufacturedItemDefinition.property.id":"System.String","ManufacturedItemDefinition.property.modifierExtension":"Extension","ManufacturedItemDefinition.property.type":"CodeableConcept","ManufacturedItemDefinition.property.valueAttachment":"Attachment","ManufacturedItemDefinition.property.valueBoolean":"boolean","ManufacturedItemDefinition.property.valueCodeableConcept":"CodeableConcept","ManufacturedItemDefinition.property.valueDate":"date","ManufacturedItemDefinition.property.valueMarkdown":"markdown","ManufacturedItemDefinition.property.valueQuantity":"Quantity","ManufacturedItemDefinition.property.valueReference":"Reference","ManufacturedItemDefinition.status":"code","ManufacturedItemDefinition.text":"Narrative","ManufacturedItemDefinition.unitOfPresentation":"CodeableConcept","MarketingStatus.country":"CodeableConcept","MarketingStatus.dateRange":"Period","MarketingStatus.extension":"Extension","MarketingStatus.id":"System.String","MarketingStatus.jurisdiction":"CodeableConcept","MarketingStatus.modifierExtension":"Extension","MarketingStatus.restoreDate":"dateTime","MarketingStatus.status":"CodeableConcept","Measure.approvalDate":"date","Measure.author":"ContactDetail","Measure.basis":"code","Measure.clinicalRecommendationStatement":"markdown","Measure.compositeScoring":"CodeableConcept","Measure.contact":"ContactDetail","Measure.contained":"Resource","Measure.copyright":"markdown","Measure.copyrightLabel":"string","Measure.date":"dateTime","Measure.description":"markdown","Measure.disclaimer":"markdown","Measure.editor":"ContactDetail","Measure.effectivePeriod":"Period","Measure.endorser":"ContactDetail","Measure.experimental":"boolean","Measure.extension":"Extension","Measure.group":"BackboneElement","Measure.group.basis":"code","Measure.group.code":"CodeableConcept","Measure.group.description":"markdown","Measure.group.extension":"Extension","Measure.group.id":"System.String","Measure.group.improvementNotation":"CodeableConcept","Measure.group.library":"canonical","Measure.group.linkId":"string","Measure.group.modifierExtension":"Extension","Measure.group.population":"BackboneElement","Measure.group.population.aggregateMethod":"CodeableConcept","Measure.group.population.code":"CodeableConcept","Measure.group.population.criteria":"Expression","Measure.group.population.description":"markdown","Measure.group.population.extension":"Extension","Measure.group.population.groupDefinition":"Reference","Measure.group.population.id":"System.String","Measure.group.population.inputPopulationId":"string","Measure.group.population.linkId":"string","Measure.group.population.modifierExtension":"Extension","Measure.group.rateAggregation":"markdown","Measure.group.scoring":"CodeableConcept","Measure.group.scoringUnit":"CodeableConcept","Measure.group.stratifier":"BackboneElement","Measure.group.stratifier.code":"CodeableConcept","Measure.group.stratifier.component":"BackboneElement","Measure.group.stratifier.component.code":"CodeableConcept","Measure.group.stratifier.component.criteria":"Expression","Measure.group.stratifier.component.description":"markdown","Measure.group.stratifier.component.extension":"Extension","Measure.group.stratifier.component.groupDefinition":"Reference","Measure.group.stratifier.component.id":"System.String","Measure.group.stratifier.component.linkId":"string","Measure.group.stratifier.component.modifierExtension":"Extension","Measure.group.stratifier.criteria":"Expression","Measure.group.stratifier.description":"markdown","Measure.group.stratifier.extension":"Extension","Measure.group.stratifier.groupDefinition":"Reference","Measure.group.stratifier.id":"System.String","Measure.group.stratifier.linkId":"string","Measure.group.stratifier.modifierExtension":"Extension","Measure.group.subjectCodeableConcept":"CodeableConcept","Measure.group.subjectReference":"Reference","Measure.group.type":"CodeableConcept","Measure.guidance":"markdown","Measure.id":"System.String","Measure.identifier":"Identifier","Measure.implicitRules":"uri","Measure.improvementNotation":"CodeableConcept","Measure.jurisdiction":"CodeableConcept","Measure.language":"code","Measure.lastReviewDate":"date","Measure.library":"canonical","Measure.meta":"Meta","Measure.modifierExtension":"Extension","Measure.name":"string","Measure.publisher":"string","Measure.purpose":"markdown","Measure.rateAggregation":"markdown","Measure.rationale":"markdown","Measure.relatedArtifact":"RelatedArtifact","Measure.reviewer":"ContactDetail","Measure.riskAdjustment":"markdown","Measure.scoring":"CodeableConcept","Measure.scoringUnit":"CodeableConcept","Measure.status":"code","Measure.subjectCodeableConcept":"CodeableConcept","Measure.subjectReference":"Reference","Measure.subtitle":"string","Measure.supplementalData":"BackboneElement","Measure.supplementalData.code":"CodeableConcept","Measure.supplementalData.criteria":"Expression","Measure.supplementalData.description":"markdown","Measure.supplementalData.extension":"Extension","Measure.supplementalData.id":"System.String","Measure.supplementalData.linkId":"string","Measure.supplementalData.modifierExtension":"Extension","Measure.supplementalData.usage":"CodeableConcept","Measure.term":"BackboneElement","Measure.term.code":"CodeableConcept","Measure.term.definition":"markdown","Measure.term.extension":"Extension","Measure.term.id":"System.String","Measure.term.modifierExtension":"Extension","Measure.text":"Narrative","Measure.title":"string","Measure.topic":"CodeableConcept","Measure.type":"CodeableConcept","Measure.url":"uri","Measure.usage":"markdown","Measure.useContext":"UsageContext","Measure.version":"string","Measure.versionAlgorithmCoding":"Coding","Measure.versionAlgorithmString":"string","MeasureReport.contained":"Resource","MeasureReport.dataUpdateType":"code","MeasureReport.date":"dateTime","MeasureReport.evaluatedResource":"Reference","MeasureReport.extension":"Extension","MeasureReport.group":"BackboneElement","MeasureReport.group.code":"CodeableConcept","MeasureReport.group.extension":"Extension","MeasureReport.group.id":"System.String","MeasureReport.group.linkId":"string","MeasureReport.group.measureScoreCodeableConcept":"CodeableConcept","MeasureReport.group.measureScoreDateTime":"dateTime","MeasureReport.group.measureScoreDuration":"Duration","MeasureReport.group.measureScorePeriod":"Period","MeasureReport.group.measureScoreQuantity":"Quantity","MeasureReport.group.measureScoreRange":"Range","MeasureReport.group.modifierExtension":"Extension","MeasureReport.group.population":"BackboneElement","MeasureReport.group.population.code":"CodeableConcept","MeasureReport.group.population.count":"integer","MeasureReport.group.population.extension":"Extension","MeasureReport.group.population.id":"System.String","MeasureReport.group.population.linkId":"string","MeasureReport.group.population.modifierExtension":"Extension","MeasureReport.group.population.subjectReport":"Reference","MeasureReport.group.population.subjectResults":"Reference","MeasureReport.group.population.subjects":"Reference","MeasureReport.group.stratifier":"BackboneElement","MeasureReport.group.stratifier.code":"CodeableConcept","MeasureReport.group.stratifier.extension":"Extension","MeasureReport.group.stratifier.id":"System.String","MeasureReport.group.stratifier.linkId":"string","MeasureReport.group.stratifier.modifierExtension":"Extension","MeasureReport.group.stratifier.stratum":"BackboneElement","MeasureReport.group.stratifier.stratum.component":"BackboneElement","MeasureReport.group.stratifier.stratum.component.code":"CodeableConcept","MeasureReport.group.stratifier.stratum.component.extension":"Extension","MeasureReport.group.stratifier.stratum.component.id":"System.String","MeasureReport.group.stratifier.stratum.component.linkId":"string","MeasureReport.group.stratifier.stratum.component.modifierExtension":"Extension","MeasureReport.group.stratifier.stratum.component.valueBoolean":"boolean","MeasureReport.group.stratifier.stratum.component.valueCodeableConcept":"CodeableConcept","MeasureReport.group.stratifier.stratum.component.valueQuantity":"Quantity","MeasureReport.group.stratifier.stratum.component.valueRange":"Range","MeasureReport.group.stratifier.stratum.component.valueReference":"Reference","MeasureReport.group.stratifier.stratum.extension":"Extension","MeasureReport.group.stratifier.stratum.id":"System.String","MeasureReport.group.stratifier.stratum.measureScoreCodeableConcept":"CodeableConcept","MeasureReport.group.stratifier.stratum.measureScoreDateTime":"dateTime","MeasureReport.group.stratifier.stratum.measureScoreDuration":"Duration","MeasureReport.group.stratifier.stratum.measureScorePeriod":"Period","MeasureReport.group.stratifier.stratum.measureScoreQuantity":"Quantity","MeasureReport.group.stratifier.stratum.measureScoreRange":"Range","MeasureReport.group.stratifier.stratum.modifierExtension":"Extension","MeasureReport.group.stratifier.stratum.population":"BackboneElement","MeasureReport.group.stratifier.stratum.population.code":"CodeableConcept","MeasureReport.group.stratifier.stratum.population.count":"integer","MeasureReport.group.stratifier.stratum.population.extension":"Extension","MeasureReport.group.stratifier.stratum.population.id":"System.String","MeasureReport.group.stratifier.stratum.population.linkId":"string","MeasureReport.group.stratifier.stratum.population.modifierExtension":"Extension","MeasureReport.group.stratifier.stratum.population.subjectReport":"Reference","MeasureReport.group.stratifier.stratum.population.subjectResults":"Reference","MeasureReport.group.stratifier.stratum.population.subjects":"Reference","MeasureReport.group.stratifier.stratum.valueBoolean":"boolean","MeasureReport.group.stratifier.stratum.valueCodeableConcept":"CodeableConcept","MeasureReport.group.stratifier.stratum.valueQuantity":"Quantity","MeasureReport.group.stratifier.stratum.valueRange":"Range","MeasureReport.group.stratifier.stratum.valueReference":"Reference","MeasureReport.group.subject":"Reference","MeasureReport.id":"System.String","MeasureReport.identifier":"Identifier","MeasureReport.implicitRules":"uri","MeasureReport.improvementNotation":"CodeableConcept","MeasureReport.inputParameters":"Reference","MeasureReport.language":"code","MeasureReport.location":"Reference","MeasureReport.measure":"canonical","MeasureReport.meta":"Meta","MeasureReport.modifierExtension":"Extension","MeasureReport.period":"Period","MeasureReport.reporter":"Reference","MeasureReport.reportingVendor":"Reference","MeasureReport.scoring":"CodeableConcept","MeasureReport.status":"code","MeasureReport.subject":"Reference","MeasureReport.supplementalData":"Reference","MeasureReport.text":"Narrative","MeasureReport.type":"code","Medication.batch":"BackboneElement","Medication.batch.expirationDate":"dateTime","Medication.batch.extension":"Extension","Medication.batch.id":"System.String","Medication.batch.lotNumber":"string","Medication.batch.modifierExtension":"Extension","Medication.code":"CodeableConcept","Medication.contained":"Resource","Medication.definition":"Reference","Medication.doseForm":"CodeableConcept","Medication.extension":"Extension","Medication.id":"System.String","Medication.identifier":"Identifier","Medication.implicitRules":"uri","Medication.ingredient":"BackboneElement","Medication.ingredient.extension":"Extension","Medication.ingredient.id":"System.String","Medication.ingredient.isActive":"boolean","Medication.ingredient.item":"CodeableReference","Medication.ingredient.modifierExtension":"Extension","Medication.ingredient.strengthCodeableConcept":"CodeableConcept","Medication.ingredient.strengthQuantity":"Quantity","Medication.ingredient.strengthRatio":"Ratio","Medication.language":"code","Medication.marketingAuthorizationHolder":"Reference","Medication.meta":"Meta","Medication.modifierExtension":"Extension","Medication.status":"code","Medication.text":"Narrative","Medication.totalVolume":"Quantity","MedicationAdministration.basedOn":"Reference","MedicationAdministration.category":"CodeableConcept","MedicationAdministration.contained":"Resource","MedicationAdministration.device":"CodeableReference","MedicationAdministration.dosage":"BackboneElement","MedicationAdministration.dosage.dose":"Quantity","MedicationAdministration.dosage.extension":"Extension","MedicationAdministration.dosage.id":"System.String","MedicationAdministration.dosage.method":"CodeableConcept","MedicationAdministration.dosage.modifierExtension":"Extension","MedicationAdministration.dosage.rateQuantity":"Quantity","MedicationAdministration.dosage.rateRatio":"Ratio","MedicationAdministration.dosage.route":"CodeableConcept","MedicationAdministration.dosage.site":"CodeableConcept","MedicationAdministration.dosage.text":"string","MedicationAdministration.encounter":"Reference","MedicationAdministration.eventHistory":"Reference","MedicationAdministration.extension":"Extension","MedicationAdministration.id":"System.String","MedicationAdministration.identifier":"Identifier","MedicationAdministration.implicitRules":"uri","MedicationAdministration.isSubPotent":"boolean","MedicationAdministration.language":"code","MedicationAdministration.medication":"CodeableReference","MedicationAdministration.meta":"Meta","MedicationAdministration.modifierExtension":"Extension","MedicationAdministration.note":"Annotation","MedicationAdministration.occurenceDateTime":"dateTime","MedicationAdministration.occurencePeriod":"Period","MedicationAdministration.occurenceTiming":"Timing","MedicationAdministration.partOf":"Reference","MedicationAdministration.performer":"BackboneElement","MedicationAdministration.performer.actor":"CodeableReference","MedicationAdministration.performer.extension":"Extension","MedicationAdministration.performer.function":"CodeableConcept","MedicationAdministration.performer.id":"System.String","MedicationAdministration.performer.modifierExtension":"Extension","MedicationAdministration.reason":"CodeableReference","MedicationAdministration.recorded":"dateTime","MedicationAdministration.request":"Reference","MedicationAdministration.status":"code","MedicationAdministration.statusReason":"CodeableConcept","MedicationAdministration.subPotentReason":"CodeableConcept","MedicationAdministration.subject":"Reference","MedicationAdministration.supportingInformation":"Reference","MedicationAdministration.text":"Narrative","MedicationDispense.authorizingPrescription":"Reference","MedicationDispense.basedOn":"Reference","MedicationDispense.category":"CodeableConcept","MedicationDispense.contained":"Resource","MedicationDispense.daysSupply":"Quantity","MedicationDispense.destination":"Reference","MedicationDispense.dosageInstruction":"Dosage","MedicationDispense.encounter":"Reference","MedicationDispense.eventHistory":"Reference","MedicationDispense.extension":"Extension","MedicationDispense.id":"System.String","MedicationDispense.identifier":"Identifier","MedicationDispense.implicitRules":"uri","MedicationDispense.language":"code","MedicationDispense.location":"Reference","MedicationDispense.medication":"CodeableReference","MedicationDispense.meta":"Meta","MedicationDispense.modifierExtension":"Extension","MedicationDispense.notPerformedReason":"CodeableReference","MedicationDispense.note":"Annotation","MedicationDispense.partOf":"Reference","MedicationDispense.performer":"BackboneElement","MedicationDispense.performer.actor":"Reference","MedicationDispense.performer.extension":"Extension","MedicationDispense.performer.function":"CodeableConcept","MedicationDispense.performer.id":"System.String","MedicationDispense.performer.modifierExtension":"Extension","MedicationDispense.quantity":"Quantity","MedicationDispense.receiver":"Reference","MedicationDispense.recorded":"dateTime","MedicationDispense.renderedDosageInstruction":"markdown","MedicationDispense.status":"code","MedicationDispense.statusChanged":"dateTime","MedicationDispense.subject":"Reference","MedicationDispense.substitution":"BackboneElement","MedicationDispense.substitution.extension":"Extension","MedicationDispense.substitution.id":"System.String","MedicationDispense.substitution.modifierExtension":"Extension","MedicationDispense.substitution.reason":"CodeableConcept","MedicationDispense.substitution.responsibleParty":"Reference","MedicationDispense.substitution.type":"CodeableConcept","MedicationDispense.substitution.wasSubstituted":"boolean","MedicationDispense.supportingInformation":"Reference","MedicationDispense.text":"Narrative","MedicationDispense.type":"CodeableConcept","MedicationDispense.whenHandedOver":"dateTime","MedicationDispense.whenPrepared":"dateTime","MedicationKnowledge.associatedMedication":"Reference","MedicationKnowledge.author":"Reference","MedicationKnowledge.clinicalUseIssue":"Reference","MedicationKnowledge.code":"CodeableConcept","MedicationKnowledge.contained":"Resource","MedicationKnowledge.cost":"BackboneElement","MedicationKnowledge.cost.costCodeableConcept":"CodeableConcept","MedicationKnowledge.cost.costMoney":"Money","MedicationKnowledge.cost.effectiveDate":"Period","MedicationKnowledge.cost.extension":"Extension","MedicationKnowledge.cost.id":"System.String","MedicationKnowledge.cost.modifierExtension":"Extension","MedicationKnowledge.cost.source":"string","MedicationKnowledge.cost.type":"CodeableConcept","MedicationKnowledge.definitional":"BackboneElement","MedicationKnowledge.definitional.definition":"Reference","MedicationKnowledge.definitional.doseForm":"CodeableConcept","MedicationKnowledge.definitional.drugCharacteristic":"BackboneElement","MedicationKnowledge.definitional.drugCharacteristic.extension":"Extension","MedicationKnowledge.definitional.drugCharacteristic.id":"System.String","MedicationKnowledge.definitional.drugCharacteristic.modifierExtension":"Extension","MedicationKnowledge.definitional.drugCharacteristic.type":"CodeableConcept","MedicationKnowledge.definitional.drugCharacteristic.valueAttachment":"Attachment","MedicationKnowledge.definitional.drugCharacteristic.valueBase64Binary":"base64Binary","MedicationKnowledge.definitional.drugCharacteristic.valueCodeableConcept":"CodeableConcept","MedicationKnowledge.definitional.drugCharacteristic.valueQuantity":"Quantity","MedicationKnowledge.definitional.drugCharacteristic.valueString":"string","MedicationKnowledge.definitional.extension":"Extension","MedicationKnowledge.definitional.id":"System.String","MedicationKnowledge.definitional.ingredient":"BackboneElement","MedicationKnowledge.definitional.ingredient.extension":"Extension","MedicationKnowledge.definitional.ingredient.id":"System.String","MedicationKnowledge.definitional.ingredient.item":"CodeableReference","MedicationKnowledge.definitional.ingredient.modifierExtension":"Extension","MedicationKnowledge.definitional.ingredient.strengthCodeableConcept":"CodeableConcept","MedicationKnowledge.definitional.ingredient.strengthQuantity":"Quantity","MedicationKnowledge.definitional.ingredient.strengthRatio":"Ratio","MedicationKnowledge.definitional.ingredient.type":"CodeableConcept","MedicationKnowledge.definitional.intendedRoute":"CodeableConcept","MedicationKnowledge.definitional.modifierExtension":"Extension","MedicationKnowledge.extension":"Extension","MedicationKnowledge.id":"System.String","MedicationKnowledge.identifier":"Identifier","MedicationKnowledge.implicitRules":"uri","MedicationKnowledge.indicationGuideline":"BackboneElement","MedicationKnowledge.indicationGuideline.dosingGuideline":"BackboneElement","MedicationKnowledge.indicationGuideline.dosingGuideline.administrationTreatment":"CodeableConcept","MedicationKnowledge.indicationGuideline.dosingGuideline.dosage":"BackboneElement","MedicationKnowledge.indicationGuideline.dosingGuideline.dosage.dosage":"Dosage","MedicationKnowledge.indicationGuideline.dosingGuideline.dosage.extension":"Extension","MedicationKnowledge.indicationGuideline.dosingGuideline.dosage.id":"System.String","MedicationKnowledge.indicationGuideline.dosingGuideline.dosage.modifierExtension":"Extension","MedicationKnowledge.indicationGuideline.dosingGuideline.dosage.type":"CodeableConcept","MedicationKnowledge.indicationGuideline.dosingGuideline.extension":"Extension","MedicationKnowledge.indicationGuideline.dosingGuideline.id":"System.String","MedicationKnowledge.indicationGuideline.dosingGuideline.modifierExtension":"Extension","MedicationKnowledge.indicationGuideline.dosingGuideline.patientCharacteristic":"BackboneElement","MedicationKnowledge.indicationGuideline.dosingGuideline.patientCharacteristic.extension":"Extension","MedicationKnowledge.indicationGuideline.dosingGuideline.patientCharacteristic.id":"System.String","MedicationKnowledge.indicationGuideline.dosingGuideline.patientCharacteristic.modifierExtension":"Extension","MedicationKnowledge.indicationGuideline.dosingGuideline.patientCharacteristic.type":"CodeableConcept","MedicationKnowledge.indicationGuideline.dosingGuideline.patientCharacteristic.valueCodeableConcept":"CodeableConcept","MedicationKnowledge.indicationGuideline.dosingGuideline.patientCharacteristic.valueQuantity":"Quantity","MedicationKnowledge.indicationGuideline.dosingGuideline.patientCharacteristic.valueRange":"Range","MedicationKnowledge.indicationGuideline.dosingGuideline.treatmentIntent":"CodeableConcept","MedicationKnowledge.indicationGuideline.extension":"Extension","MedicationKnowledge.indicationGuideline.id":"System.String","MedicationKnowledge.indicationGuideline.indication":"CodeableReference","MedicationKnowledge.indicationGuideline.modifierExtension":"Extension","MedicationKnowledge.intendedJurisdiction":"CodeableConcept","MedicationKnowledge.language":"code","MedicationKnowledge.medicineClassification":"BackboneElement","MedicationKnowledge.medicineClassification.classification":"CodeableConcept","MedicationKnowledge.medicineClassification.extension":"Extension","MedicationKnowledge.medicineClassification.id":"System.String","MedicationKnowledge.medicineClassification.modifierExtension":"Extension","MedicationKnowledge.medicineClassification.sourceString":"string","MedicationKnowledge.medicineClassification.sourceUri":"uri","MedicationKnowledge.medicineClassification.type":"CodeableConcept","MedicationKnowledge.meta":"Meta","MedicationKnowledge.modifierExtension":"Extension","MedicationKnowledge.monitoringProgram":"BackboneElement","MedicationKnowledge.monitoringProgram.extension":"Extension","MedicationKnowledge.monitoringProgram.id":"System.String","MedicationKnowledge.monitoringProgram.modifierExtension":"Extension","MedicationKnowledge.monitoringProgram.name":"string","MedicationKnowledge.monitoringProgram.type":"CodeableConcept","MedicationKnowledge.monograph":"BackboneElement","MedicationKnowledge.monograph.extension":"Extension","MedicationKnowledge.monograph.id":"System.String","MedicationKnowledge.monograph.modifierExtension":"Extension","MedicationKnowledge.monograph.source":"Reference","MedicationKnowledge.monograph.type":"CodeableConcept","MedicationKnowledge.name":"string","MedicationKnowledge.packaging":"BackboneElement","MedicationKnowledge.packaging.extension":"Extension","MedicationKnowledge.packaging.id":"System.String","MedicationKnowledge.packaging.modifierExtension":"Extension","MedicationKnowledge.packaging.packagedProduct":"Reference","MedicationKnowledge.preparationInstruction":"markdown","MedicationKnowledge.productType":"CodeableConcept","MedicationKnowledge.regulatory":"BackboneElement","MedicationKnowledge.regulatory.extension":"Extension","MedicationKnowledge.regulatory.id":"System.String","MedicationKnowledge.regulatory.maxDispense":"BackboneElement","MedicationKnowledge.regulatory.maxDispense.extension":"Extension","MedicationKnowledge.regulatory.maxDispense.id":"System.String","MedicationKnowledge.regulatory.maxDispense.modifierExtension":"Extension","MedicationKnowledge.regulatory.maxDispense.period":"Duration","MedicationKnowledge.regulatory.maxDispense.quantity":"Quantity","MedicationKnowledge.regulatory.modifierExtension":"Extension","MedicationKnowledge.regulatory.regulatoryAuthority":"Reference","MedicationKnowledge.regulatory.schedule":"CodeableConcept","MedicationKnowledge.regulatory.substitution":"BackboneElement","MedicationKnowledge.regulatory.substitution.allowed":"boolean","MedicationKnowledge.regulatory.substitution.extension":"Extension","MedicationKnowledge.regulatory.substitution.id":"System.String","MedicationKnowledge.regulatory.substitution.modifierExtension":"Extension","MedicationKnowledge.regulatory.substitution.type":"CodeableConcept","MedicationKnowledge.relatedMedicationKnowledge":"BackboneElement","MedicationKnowledge.relatedMedicationKnowledge.extension":"Extension","MedicationKnowledge.relatedMedicationKnowledge.id":"System.String","MedicationKnowledge.relatedMedicationKnowledge.modifierExtension":"Extension","MedicationKnowledge.relatedMedicationKnowledge.reference":"Reference","MedicationKnowledge.relatedMedicationKnowledge.type":"CodeableConcept","MedicationKnowledge.status":"code","MedicationKnowledge.storageGuideline":"BackboneElement","MedicationKnowledge.storageGuideline.environmentalSetting":"BackboneElement","MedicationKnowledge.storageGuideline.environmentalSetting.extension":"Extension","MedicationKnowledge.storageGuideline.environmentalSetting.id":"System.String","MedicationKnowledge.storageGuideline.environmentalSetting.modifierExtension":"Extension","MedicationKnowledge.storageGuideline.environmentalSetting.type":"CodeableConcept","MedicationKnowledge.storageGuideline.environmentalSetting.valueCodeableConcept":"CodeableConcept","MedicationKnowledge.storageGuideline.environmentalSetting.valueQuantity":"Quantity","MedicationKnowledge.storageGuideline.environmentalSetting.valueRange":"Range","MedicationKnowledge.storageGuideline.extension":"Extension","MedicationKnowledge.storageGuideline.id":"System.String","MedicationKnowledge.storageGuideline.modifierExtension":"Extension","MedicationKnowledge.storageGuideline.note":"Annotation","MedicationKnowledge.storageGuideline.reference":"uri","MedicationKnowledge.storageGuideline.stabilityDuration":"Duration","MedicationKnowledge.text":"Narrative","MedicationRequest.authoredOn":"dateTime","MedicationRequest.basedOn":"Reference","MedicationRequest.category":"CodeableConcept","MedicationRequest.contained":"Resource","MedicationRequest.courseOfTherapyType":"CodeableConcept","MedicationRequest.device":"CodeableReference","MedicationRequest.dispenseRequest":"BackboneElement","MedicationRequest.dispenseRequest.dispenseInterval":"Duration","MedicationRequest.dispenseRequest.dispenser":"Reference","MedicationRequest.dispenseRequest.dispenserInstruction":"Annotation","MedicationRequest.dispenseRequest.doseAdministrationAid":"CodeableConcept","MedicationRequest.dispenseRequest.expectedSupplyDuration":"Duration","MedicationRequest.dispenseRequest.extension":"Extension","MedicationRequest.dispenseRequest.id":"System.String","MedicationRequest.dispenseRequest.initialFill":"BackboneElement","MedicationRequest.dispenseRequest.initialFill.duration":"Duration","MedicationRequest.dispenseRequest.initialFill.extension":"Extension","MedicationRequest.dispenseRequest.initialFill.id":"System.String","MedicationRequest.dispenseRequest.initialFill.modifierExtension":"Extension","MedicationRequest.dispenseRequest.initialFill.quantity":"Quantity","MedicationRequest.dispenseRequest.modifierExtension":"Extension","MedicationRequest.dispenseRequest.numberOfRepeatsAllowed":"unsignedInt","MedicationRequest.dispenseRequest.quantity":"Quantity","MedicationRequest.dispenseRequest.validityPeriod":"Period","MedicationRequest.doNotPerform":"boolean","MedicationRequest.dosageInstruction":"Dosage","MedicationRequest.effectiveDosePeriod":"Period","MedicationRequest.encounter":"Reference","MedicationRequest.eventHistory":"Reference","MedicationRequest.extension":"Extension","MedicationRequest.groupIdentifier":"Identifier","MedicationRequest.id":"System.String","MedicationRequest.identifier":"Identifier","MedicationRequest.implicitRules":"uri","MedicationRequest.informationSource":"Reference","MedicationRequest.insurance":"Reference","MedicationRequest.intent":"code","MedicationRequest.language":"code","MedicationRequest.medication":"CodeableReference","MedicationRequest.meta":"Meta","MedicationRequest.modifierExtension":"Extension","MedicationRequest.note":"Annotation","MedicationRequest.performer":"Reference","MedicationRequest.performerType":"CodeableConcept","MedicationRequest.priorPrescription":"Reference","MedicationRequest.priority":"code","MedicationRequest.reason":"CodeableReference","MedicationRequest.recorder":"Reference","MedicationRequest.renderedDosageInstruction":"markdown","MedicationRequest.reported":"boolean","MedicationRequest.requester":"Reference","MedicationRequest.status":"code","MedicationRequest.statusChanged":"dateTime","MedicationRequest.statusReason":"CodeableConcept","MedicationRequest.subject":"Reference","MedicationRequest.substitution":"BackboneElement","MedicationRequest.substitution.allowedBoolean":"boolean","MedicationRequest.substitution.allowedCodeableConcept":"CodeableConcept","MedicationRequest.substitution.extension":"Extension","MedicationRequest.substitution.id":"System.String","MedicationRequest.substitution.modifierExtension":"Extension","MedicationRequest.substitution.reason":"CodeableConcept","MedicationRequest.supportingInformation":"Reference","MedicationRequest.text":"Narrative","MedicationStatement.adherence":"BackboneElement","MedicationStatement.adherence.code":"CodeableConcept","MedicationStatement.adherence.extension":"Extension","MedicationStatement.adherence.id":"System.String","MedicationStatement.adherence.modifierExtension":"Extension","MedicationStatement.adherence.reason":"CodeableConcept","MedicationStatement.category":"CodeableConcept","MedicationStatement.contained":"Resource","MedicationStatement.dateAsserted":"dateTime","MedicationStatement.derivedFrom":"Reference","MedicationStatement.dosage":"Dosage","MedicationStatement.effectiveDateTime":"dateTime","MedicationStatement.effectivePeriod":"Period","MedicationStatement.effectiveTiming":"Timing","MedicationStatement.encounter":"Reference","MedicationStatement.extension":"Extension","MedicationStatement.id":"System.String","MedicationStatement.identifier":"Identifier","MedicationStatement.implicitRules":"uri","MedicationStatement.informationSource":"Reference","MedicationStatement.language":"code","MedicationStatement.medication":"CodeableReference","MedicationStatement.meta":"Meta","MedicationStatement.modifierExtension":"Extension","MedicationStatement.note":"Annotation","MedicationStatement.partOf":"Reference","MedicationStatement.reason":"CodeableReference","MedicationStatement.relatedClinicalInformation":"Reference","MedicationStatement.renderedDosageInstruction":"markdown","MedicationStatement.status":"code","MedicationStatement.subject":"Reference","MedicationStatement.text":"Narrative","MedicinalProductDefinition.additionalMonitoringIndicator":"CodeableConcept","MedicinalProductDefinition.attachedDocument":"Reference","MedicinalProductDefinition.characteristic":"BackboneElement","MedicinalProductDefinition.characteristic.extension":"Extension","MedicinalProductDefinition.characteristic.id":"System.String","MedicinalProductDefinition.characteristic.modifierExtension":"Extension","MedicinalProductDefinition.characteristic.type":"CodeableConcept","MedicinalProductDefinition.characteristic.valueAttachment":"Attachment","MedicinalProductDefinition.characteristic.valueBoolean":"boolean","MedicinalProductDefinition.characteristic.valueCodeableConcept":"CodeableConcept","MedicinalProductDefinition.characteristic.valueDate":"date","MedicinalProductDefinition.characteristic.valueInteger":"integer","MedicinalProductDefinition.characteristic.valueMarkdown":"markdown","MedicinalProductDefinition.characteristic.valueQuantity":"Quantity","MedicinalProductDefinition.classification":"CodeableConcept","MedicinalProductDefinition.clinicalTrial":"Reference","MedicinalProductDefinition.code":"Coding","MedicinalProductDefinition.combinedPharmaceuticalDoseForm":"CodeableConcept","MedicinalProductDefinition.comprisedOf":"Reference","MedicinalProductDefinition.contact":"BackboneElement","MedicinalProductDefinition.contact.contact":"Reference","MedicinalProductDefinition.contact.extension":"Extension","MedicinalProductDefinition.contact.id":"System.String","MedicinalProductDefinition.contact.modifierExtension":"Extension","MedicinalProductDefinition.contact.type":"CodeableConcept","MedicinalProductDefinition.contained":"Resource","MedicinalProductDefinition.crossReference":"BackboneElement","MedicinalProductDefinition.crossReference.extension":"Extension","MedicinalProductDefinition.crossReference.id":"System.String","MedicinalProductDefinition.crossReference.modifierExtension":"Extension","MedicinalProductDefinition.crossReference.product":"CodeableReference","MedicinalProductDefinition.crossReference.type":"CodeableConcept","MedicinalProductDefinition.description":"markdown","MedicinalProductDefinition.domain":"CodeableConcept","MedicinalProductDefinition.extension":"Extension","MedicinalProductDefinition.id":"System.String","MedicinalProductDefinition.identifier":"Identifier","MedicinalProductDefinition.implicitRules":"uri","MedicinalProductDefinition.impurity":"CodeableReference","MedicinalProductDefinition.indication":"markdown","MedicinalProductDefinition.ingredient":"CodeableConcept","MedicinalProductDefinition.language":"code","MedicinalProductDefinition.legalStatusOfSupply":"CodeableConcept","MedicinalProductDefinition.marketingStatus":"MarketingStatus","MedicinalProductDefinition.masterFile":"Reference","MedicinalProductDefinition.meta":"Meta","MedicinalProductDefinition.modifierExtension":"Extension","MedicinalProductDefinition.name":"BackboneElement","MedicinalProductDefinition.name.extension":"Extension","MedicinalProductDefinition.name.id":"System.String","MedicinalProductDefinition.name.modifierExtension":"Extension","MedicinalProductDefinition.name.part":"BackboneElement","MedicinalProductDefinition.name.part.extension":"Extension","MedicinalProductDefinition.name.part.id":"System.String","MedicinalProductDefinition.name.part.modifierExtension":"Extension","MedicinalProductDefinition.name.part.part":"string","MedicinalProductDefinition.name.part.type":"CodeableConcept","MedicinalProductDefinition.name.productName":"string","MedicinalProductDefinition.name.type":"CodeableConcept","MedicinalProductDefinition.name.usage":"BackboneElement","MedicinalProductDefinition.name.usage.country":"CodeableConcept","MedicinalProductDefinition.name.usage.extension":"Extension","MedicinalProductDefinition.name.usage.id":"System.String","MedicinalProductDefinition.name.usage.jurisdiction":"CodeableConcept","MedicinalProductDefinition.name.usage.language":"CodeableConcept","MedicinalProductDefinition.name.usage.modifierExtension":"Extension","MedicinalProductDefinition.operation":"BackboneElement","MedicinalProductDefinition.operation.confidentialityIndicator":"CodeableConcept","MedicinalProductDefinition.operation.effectiveDate":"Period","MedicinalProductDefinition.operation.extension":"Extension","MedicinalProductDefinition.operation.id":"System.String","MedicinalProductDefinition.operation.modifierExtension":"Extension","MedicinalProductDefinition.operation.organization":"Reference","MedicinalProductDefinition.operation.type":"CodeableReference","MedicinalProductDefinition.packagedMedicinalProduct":"CodeableConcept","MedicinalProductDefinition.pediatricUseIndicator":"CodeableConcept","MedicinalProductDefinition.route":"CodeableConcept","MedicinalProductDefinition.specialMeasures":"CodeableConcept","MedicinalProductDefinition.status":"CodeableConcept","MedicinalProductDefinition.statusDate":"dateTime","MedicinalProductDefinition.text":"Narrative","MedicinalProductDefinition.type":"CodeableConcept","MedicinalProductDefinition.version":"string","MessageDefinition.allowedResponse":"BackboneElement","MessageDefinition.allowedResponse.extension":"Extension","MessageDefinition.allowedResponse.id":"System.String","MessageDefinition.allowedResponse.message":"canonical","MessageDefinition.allowedResponse.modifierExtension":"Extension","MessageDefinition.allowedResponse.situation":"markdown","MessageDefinition.base":"canonical","MessageDefinition.category":"code","MessageDefinition.contact":"ContactDetail","MessageDefinition.contained":"Resource","MessageDefinition.copyright":"markdown","MessageDefinition.copyrightLabel":"string","MessageDefinition.date":"dateTime","MessageDefinition.description":"markdown","MessageDefinition.eventCoding":"Coding","MessageDefinition.eventUri":"uri","MessageDefinition.experimental":"boolean","MessageDefinition.extension":"Extension","MessageDefinition.focus":"BackboneElement","MessageDefinition.focus.code":"code","MessageDefinition.focus.extension":"Extension","MessageDefinition.focus.id":"System.String","MessageDefinition.focus.max":"string","MessageDefinition.focus.min":"unsignedInt","MessageDefinition.focus.modifierExtension":"Extension","MessageDefinition.focus.profile":"canonical","MessageDefinition.graph":"canonical","MessageDefinition.id":"System.String","MessageDefinition.identifier":"Identifier","MessageDefinition.implicitRules":"uri","MessageDefinition.jurisdiction":"CodeableConcept","MessageDefinition.language":"code","MessageDefinition.meta":"Meta","MessageDefinition.modifierExtension":"Extension","MessageDefinition.name":"string","MessageDefinition.parent":"canonical","MessageDefinition.publisher":"string","MessageDefinition.purpose":"markdown","MessageDefinition.replaces":"canonical","MessageDefinition.responseRequired":"code","MessageDefinition.status":"code","MessageDefinition.text":"Narrative","MessageDefinition.title":"string","MessageDefinition.url":"uri","MessageDefinition.useContext":"UsageContext","MessageDefinition.version":"string","MessageDefinition.versionAlgorithmCoding":"Coding","MessageDefinition.versionAlgorithmString":"string","MessageHeader.author":"Reference","MessageHeader.contained":"Resource","MessageHeader.definition":"canonical","MessageHeader.destination":"BackboneElement","MessageHeader.destination.endpointReference":"Reference","MessageHeader.destination.endpointUrl":"url","MessageHeader.destination.extension":"Extension","MessageHeader.destination.id":"System.String","MessageHeader.destination.modifierExtension":"Extension","MessageHeader.destination.name":"string","MessageHeader.destination.receiver":"Reference","MessageHeader.destination.target":"Reference","MessageHeader.eventCanonical":"canonical","MessageHeader.eventCoding":"Coding","MessageHeader.extension":"Extension","MessageHeader.focus":"Reference","MessageHeader.id":"System.String","MessageHeader.implicitRules":"uri","MessageHeader.language":"code","MessageHeader.meta":"Meta","MessageHeader.modifierExtension":"Extension","MessageHeader.reason":"CodeableConcept","MessageHeader.response":"BackboneElement","MessageHeader.response.code":"code","MessageHeader.response.details":"Reference","MessageHeader.response.extension":"Extension","MessageHeader.response.id":"System.String","MessageHeader.response.identifier":"Identifier","MessageHeader.response.modifierExtension":"Extension","MessageHeader.responsible":"Reference","MessageHeader.sender":"Reference","MessageHeader.source":"BackboneElement","MessageHeader.source.contact":"ContactPoint","MessageHeader.source.endpointReference":"Reference","MessageHeader.source.endpointUrl":"url","MessageHeader.source.extension":"Extension","MessageHeader.source.id":"System.String","MessageHeader.source.modifierExtension":"Extension","MessageHeader.source.name":"string","MessageHeader.source.software":"string","MessageHeader.source.version":"string","MessageHeader.text":"Narrative","Meta.extension":"Extension","Meta.id":"System.String","Meta.lastUpdated":"instant","Meta.profile":"canonical","Meta.security":"Coding","Meta.source":"uri","Meta.tag":"Coding","Meta.versionId":"id","MetadataResource.approvalDate":"date","MetadataResource.author":"ContactDetail","MetadataResource.contact":"ContactDetail","MetadataResource.contained":"Resource","MetadataResource.copyright":"markdown","MetadataResource.copyrightLabel":"string","MetadataResource.date":"dateTime","MetadataResource.description":"markdown","MetadataResource.editor":"ContactDetail","MetadataResource.effectivePeriod":"Period","MetadataResource.endorser":"ContactDetail","MetadataResource.experimental":"boolean","MetadataResource.extension":"Extension","MetadataResource.id":"System.String","MetadataResource.identifier":"Identifier","MetadataResource.implicitRules":"uri","MetadataResource.jurisdiction":"CodeableConcept","MetadataResource.language":"code","MetadataResource.lastReviewDate":"date","MetadataResource.meta":"Meta","MetadataResource.modifierExtension":"Extension","MetadataResource.name":"string","MetadataResource.publisher":"string","MetadataResource.purpose":"markdown","MetadataResource.relatedArtifact":"RelatedArtifact","MetadataResource.reviewer":"ContactDetail","MetadataResource.status":"code","MetadataResource.text":"Narrative","MetadataResource.title":"string","MetadataResource.topic":"CodeableConcept","MetadataResource.url":"uri","MetadataResource.useContext":"UsageContext","MetadataResource.version":"string","MetadataResource.versionAlgorithmCoding":"Coding","MetadataResource.versionAlgorithmString":"string","MolecularSequence.contained":"Resource","MolecularSequence.device":"Reference","MolecularSequence.extension":"Extension","MolecularSequence.focus":"Reference","MolecularSequence.formatted":"Attachment","MolecularSequence.id":"System.String","MolecularSequence.identifier":"Identifier","MolecularSequence.implicitRules":"uri","MolecularSequence.language":"code","MolecularSequence.literal":"string","MolecularSequence.meta":"Meta","MolecularSequence.modifierExtension":"Extension","MolecularSequence.performer":"Reference","MolecularSequence.relative":"BackboneElement","MolecularSequence.relative.coordinateSystem":"CodeableConcept","MolecularSequence.relative.edit":"BackboneElement","MolecularSequence.relative.edit.end":"integer","MolecularSequence.relative.edit.extension":"Extension","MolecularSequence.relative.edit.id":"System.String","MolecularSequence.relative.edit.modifierExtension":"Extension","MolecularSequence.relative.edit.replacedSequence":"string","MolecularSequence.relative.edit.replacementSequence":"string","MolecularSequence.relative.edit.start":"integer","MolecularSequence.relative.extension":"Extension","MolecularSequence.relative.id":"System.String","MolecularSequence.relative.modifierExtension":"Extension","MolecularSequence.relative.ordinalPosition":"integer","MolecularSequence.relative.sequenceRange":"Range","MolecularSequence.relative.startingSequence":"BackboneElement","MolecularSequence.relative.startingSequence.chromosome":"CodeableConcept","MolecularSequence.relative.startingSequence.extension":"Extension","MolecularSequence.relative.startingSequence.genomeAssembly":"CodeableConcept","MolecularSequence.relative.startingSequence.id":"System.String","MolecularSequence.relative.startingSequence.modifierExtension":"Extension","MolecularSequence.relative.startingSequence.orientation":"code","MolecularSequence.relative.startingSequence.sequenceCodeableConcept":"CodeableConcept","MolecularSequence.relative.startingSequence.sequenceReference":"Reference","MolecularSequence.relative.startingSequence.sequenceString":"string","MolecularSequence.relative.startingSequence.strand":"code","MolecularSequence.relative.startingSequence.windowEnd":"integer","MolecularSequence.relative.startingSequence.windowStart":"integer","MolecularSequence.specimen":"Reference","MolecularSequence.subject":"Reference","MolecularSequence.text":"Narrative","MolecularSequence.type":"code","MonetaryComponent.amount":"Money","MonetaryComponent.code":"CodeableConcept","MonetaryComponent.extension":"Extension","MonetaryComponent.factor":"decimal","MonetaryComponent.id":"System.String","MonetaryComponent.type":"code","Money.currency":"code","Money.extension":"Extension","Money.id":"System.String","Money.value":"decimal","NamingSystem.approvalDate":"date","NamingSystem.author":"ContactDetail","NamingSystem.contact":"ContactDetail","NamingSystem.contained":"Resource","NamingSystem.copyright":"markdown","NamingSystem.copyrightLabel":"string","NamingSystem.date":"dateTime","NamingSystem.description":"markdown","NamingSystem.editor":"ContactDetail","NamingSystem.effectivePeriod":"Period","NamingSystem.endorser":"ContactDetail","NamingSystem.experimental":"boolean","NamingSystem.extension":"Extension","NamingSystem.id":"System.String","NamingSystem.identifier":"Identifier","NamingSystem.implicitRules":"uri","NamingSystem.jurisdiction":"CodeableConcept","NamingSystem.kind":"code","NamingSystem.language":"code","NamingSystem.lastReviewDate":"date","NamingSystem.meta":"Meta","NamingSystem.modifierExtension":"Extension","NamingSystem.name":"string","NamingSystem.publisher":"string","NamingSystem.purpose":"markdown","NamingSystem.relatedArtifact":"RelatedArtifact","NamingSystem.responsible":"string","NamingSystem.reviewer":"ContactDetail","NamingSystem.status":"code","NamingSystem.text":"Narrative","NamingSystem.title":"string","NamingSystem.topic":"CodeableConcept","NamingSystem.type":"CodeableConcept","NamingSystem.uniqueId":"BackboneElement","NamingSystem.uniqueId.authoritative":"boolean","NamingSystem.uniqueId.comment":"string","NamingSystem.uniqueId.extension":"Extension","NamingSystem.uniqueId.id":"System.String","NamingSystem.uniqueId.modifierExtension":"Extension","NamingSystem.uniqueId.period":"Period","NamingSystem.uniqueId.preferred":"boolean","NamingSystem.uniqueId.type":"code","NamingSystem.uniqueId.value":"string","NamingSystem.url":"uri","NamingSystem.usage":"string","NamingSystem.useContext":"UsageContext","NamingSystem.version":"string","NamingSystem.versionAlgorithmCoding":"Coding","NamingSystem.versionAlgorithmString":"string","Narrative.div":"xhtml","Narrative.extension":"Extension","Narrative.id":"System.String","Narrative.status":"code","NutritionIntake.basedOn":"Reference","NutritionIntake.code":"CodeableConcept","NutritionIntake.consumedItem":"BackboneElement","NutritionIntake.consumedItem.amount":"Quantity","NutritionIntake.consumedItem.extension":"Extension","NutritionIntake.consumedItem.id":"System.String","NutritionIntake.consumedItem.modifierExtension":"Extension","NutritionIntake.consumedItem.notConsumed":"boolean","NutritionIntake.consumedItem.notConsumedReason":"CodeableConcept","NutritionIntake.consumedItem.nutritionProduct":"CodeableReference","NutritionIntake.consumedItem.rate":"Quantity","NutritionIntake.consumedItem.schedule":"Timing","NutritionIntake.consumedItem.type":"CodeableConcept","NutritionIntake.contained":"Resource","NutritionIntake.derivedFrom":"Reference","NutritionIntake.encounter":"Reference","NutritionIntake.extension":"Extension","NutritionIntake.id":"System.String","NutritionIntake.identifier":"Identifier","NutritionIntake.implicitRules":"uri","NutritionIntake.ingredientLabel":"BackboneElement","NutritionIntake.ingredientLabel.amount":"Quantity","NutritionIntake.ingredientLabel.extension":"Extension","NutritionIntake.ingredientLabel.id":"System.String","NutritionIntake.ingredientLabel.modifierExtension":"Extension","NutritionIntake.ingredientLabel.nutrient":"CodeableReference","NutritionIntake.instantiatesCanonical":"canonical","NutritionIntake.instantiatesUri":"uri","NutritionIntake.language":"code","NutritionIntake.location":"Reference","NutritionIntake.meta":"Meta","NutritionIntake.modifierExtension":"Extension","NutritionIntake.note":"Annotation","NutritionIntake.occurrenceDateTime":"dateTime","NutritionIntake.occurrencePeriod":"Period","NutritionIntake.partOf":"Reference","NutritionIntake.performer":"BackboneElement","NutritionIntake.performer.actor":"Reference","NutritionIntake.performer.extension":"Extension","NutritionIntake.performer.function":"CodeableConcept","NutritionIntake.performer.id":"System.String","NutritionIntake.performer.modifierExtension":"Extension","NutritionIntake.reason":"CodeableReference","NutritionIntake.recorded":"dateTime","NutritionIntake.reportedBoolean":"boolean","NutritionIntake.reportedReference":"Reference","NutritionIntake.status":"code","NutritionIntake.statusReason":"CodeableConcept","NutritionIntake.subject":"Reference","NutritionIntake.text":"Narrative","NutritionOrder.allergyIntolerance":"Reference","NutritionOrder.basedOn":"Reference","NutritionOrder.contained":"Resource","NutritionOrder.dateTime":"dateTime","NutritionOrder.encounter":"Reference","NutritionOrder.enteralFormula":"BackboneElement","NutritionOrder.enteralFormula.additive":"BackboneElement","NutritionOrder.enteralFormula.additive.extension":"Extension","NutritionOrder.enteralFormula.additive.id":"System.String","NutritionOrder.enteralFormula.additive.modifierExtension":"Extension","NutritionOrder.enteralFormula.additive.productName":"string","NutritionOrder.enteralFormula.additive.quantity":"Quantity","NutritionOrder.enteralFormula.additive.type":"CodeableReference","NutritionOrder.enteralFormula.administration":"BackboneElement","NutritionOrder.enteralFormula.administration.extension":"Extension","NutritionOrder.enteralFormula.administration.id":"System.String","NutritionOrder.enteralFormula.administration.modifierExtension":"Extension","NutritionOrder.enteralFormula.administration.quantity":"Quantity","NutritionOrder.enteralFormula.administration.rateQuantity":"Quantity","NutritionOrder.enteralFormula.administration.rateRatio":"Ratio","NutritionOrder.enteralFormula.administration.schedule":"BackboneElement","NutritionOrder.enteralFormula.administration.schedule.asNeeded":"boolean","NutritionOrder.enteralFormula.administration.schedule.asNeededFor":"CodeableConcept","NutritionOrder.enteralFormula.administration.schedule.extension":"Extension","NutritionOrder.enteralFormula.administration.schedule.id":"System.String","NutritionOrder.enteralFormula.administration.schedule.modifierExtension":"Extension","NutritionOrder.enteralFormula.administration.schedule.timing":"Timing","NutritionOrder.enteralFormula.administrationInstruction":"markdown","NutritionOrder.enteralFormula.baseFormulaProductName":"string","NutritionOrder.enteralFormula.baseFormulaType":"CodeableReference","NutritionOrder.enteralFormula.caloricDensity":"Quantity","NutritionOrder.enteralFormula.deliveryDevice":"CodeableReference","NutritionOrder.enteralFormula.extension":"Extension","NutritionOrder.enteralFormula.id":"System.String","NutritionOrder.enteralFormula.maxVolumeToDeliver":"Quantity","NutritionOrder.enteralFormula.modifierExtension":"Extension","NutritionOrder.enteralFormula.routeOfAdministration":"CodeableConcept","NutritionOrder.excludeFoodModifier":"CodeableConcept","NutritionOrder.extension":"Extension","NutritionOrder.foodPreferenceModifier":"CodeableConcept","NutritionOrder.groupIdentifier":"Identifier","NutritionOrder.id":"System.String","NutritionOrder.identifier":"Identifier","NutritionOrder.implicitRules":"uri","NutritionOrder.instantiates":"uri","NutritionOrder.instantiatesCanonical":"canonical","NutritionOrder.instantiatesUri":"uri","NutritionOrder.intent":"code","NutritionOrder.language":"code","NutritionOrder.meta":"Meta","NutritionOrder.modifierExtension":"Extension","NutritionOrder.note":"Annotation","NutritionOrder.oralDiet":"BackboneElement","NutritionOrder.oralDiet.extension":"Extension","NutritionOrder.oralDiet.fluidConsistencyType":"CodeableConcept","NutritionOrder.oralDiet.id":"System.String","NutritionOrder.oralDiet.instruction":"string","NutritionOrder.oralDiet.modifierExtension":"Extension","NutritionOrder.oralDiet.nutrient":"BackboneElement","NutritionOrder.oralDiet.nutrient.amount":"Quantity","NutritionOrder.oralDiet.nutrient.extension":"Extension","NutritionOrder.oralDiet.nutrient.id":"System.String","NutritionOrder.oralDiet.nutrient.modifier":"CodeableConcept","NutritionOrder.oralDiet.nutrient.modifierExtension":"Extension","NutritionOrder.oralDiet.schedule":"BackboneElement","NutritionOrder.oralDiet.schedule.asNeeded":"boolean","NutritionOrder.oralDiet.schedule.asNeededFor":"CodeableConcept","NutritionOrder.oralDiet.schedule.extension":"Extension","NutritionOrder.oralDiet.schedule.id":"System.String","NutritionOrder.oralDiet.schedule.modifierExtension":"Extension","NutritionOrder.oralDiet.schedule.timing":"Timing","NutritionOrder.oralDiet.texture":"BackboneElement","NutritionOrder.oralDiet.texture.extension":"Extension","NutritionOrder.oralDiet.texture.foodType":"CodeableConcept","NutritionOrder.oralDiet.texture.id":"System.String","NutritionOrder.oralDiet.texture.modifier":"CodeableConcept","NutritionOrder.oralDiet.texture.modifierExtension":"Extension","NutritionOrder.oralDiet.type":"CodeableConcept","NutritionOrder.orderer":"Reference","NutritionOrder.outsideFoodAllowed":"boolean","NutritionOrder.performer":"CodeableReference","NutritionOrder.priority":"code","NutritionOrder.status":"code","NutritionOrder.subject":"Reference","NutritionOrder.supplement":"BackboneElement","NutritionOrder.supplement.extension":"Extension","NutritionOrder.supplement.id":"System.String","NutritionOrder.supplement.instruction":"string","NutritionOrder.supplement.modifierExtension":"Extension","NutritionOrder.supplement.productName":"string","NutritionOrder.supplement.quantity":"Quantity","NutritionOrder.supplement.schedule":"BackboneElement","NutritionOrder.supplement.schedule.asNeeded":"boolean","NutritionOrder.supplement.schedule.asNeededFor":"CodeableConcept","NutritionOrder.supplement.schedule.extension":"Extension","NutritionOrder.supplement.schedule.id":"System.String","NutritionOrder.supplement.schedule.modifierExtension":"Extension","NutritionOrder.supplement.schedule.timing":"Timing","NutritionOrder.supplement.type":"CodeableReference","NutritionOrder.supportingInformation":"Reference","NutritionOrder.text":"Narrative","NutritionProduct.category":"CodeableConcept","NutritionProduct.characteristic":"BackboneElement","NutritionProduct.characteristic.extension":"Extension","NutritionProduct.characteristic.id":"System.String","NutritionProduct.characteristic.modifierExtension":"Extension","NutritionProduct.characteristic.type":"CodeableConcept","NutritionProduct.characteristic.valueAttachment":"Attachment","NutritionProduct.characteristic.valueBase64Binary":"base64Binary","NutritionProduct.characteristic.valueBoolean":"boolean","NutritionProduct.characteristic.valueCodeableConcept":"CodeableConcept","NutritionProduct.characteristic.valueQuantity":"Quantity","NutritionProduct.characteristic.valueString":"string","NutritionProduct.code":"CodeableConcept","NutritionProduct.contained":"Resource","NutritionProduct.extension":"Extension","NutritionProduct.id":"System.String","NutritionProduct.implicitRules":"uri","NutritionProduct.ingredient":"BackboneElement","NutritionProduct.ingredient.amount":"Ratio","NutritionProduct.ingredient.extension":"Extension","NutritionProduct.ingredient.id":"System.String","NutritionProduct.ingredient.item":"CodeableReference","NutritionProduct.ingredient.modifierExtension":"Extension","NutritionProduct.instance":"BackboneElement","NutritionProduct.instance.biologicalSourceEvent":"Identifier","NutritionProduct.instance.expiry":"dateTime","NutritionProduct.instance.extension":"Extension","NutritionProduct.instance.id":"System.String","NutritionProduct.instance.identifier":"Identifier","NutritionProduct.instance.lotNumber":"string","NutritionProduct.instance.modifierExtension":"Extension","NutritionProduct.instance.name":"string","NutritionProduct.instance.quantity":"Quantity","NutritionProduct.instance.useBy":"dateTime","NutritionProduct.knownAllergen":"CodeableReference","NutritionProduct.language":"code","NutritionProduct.manufacturer":"Reference","NutritionProduct.meta":"Meta","NutritionProduct.modifierExtension":"Extension","NutritionProduct.note":"Annotation","NutritionProduct.nutrient":"BackboneElement","NutritionProduct.nutrient.amount":"Ratio","NutritionProduct.nutrient.extension":"Extension","NutritionProduct.nutrient.id":"System.String","NutritionProduct.nutrient.item":"CodeableReference","NutritionProduct.nutrient.modifierExtension":"Extension","NutritionProduct.status":"code","NutritionProduct.text":"Narrative","Observation.basedOn":"Reference","Observation.bodySite":"CodeableConcept","Observation.bodyStructure":"Reference","Observation.category":"CodeableConcept","Observation.code":"CodeableConcept","Observation.component":"BackboneElement","Observation.component.code":"CodeableConcept","Observation.component.dataAbsentReason":"CodeableConcept","Observation.component.extension":"Extension","Observation.component.id":"System.String","Observation.component.interpretation":"CodeableConcept","Observation.component.modifierExtension":"Extension","Observation.component.valueAttachment":"Attachment","Observation.component.valueBoolean":"boolean","Observation.component.valueCodeableConcept":"CodeableConcept","Observation.component.valueDateTime":"dateTime","Observation.component.valueInteger":"integer","Observation.component.valuePeriod":"Period","Observation.component.valueQuantity":"Quantity","Observation.component.valueRange":"Range","Observation.component.valueRatio":"Ratio","Observation.component.valueReference":"Reference","Observation.component.valueSampledData":"SampledData","Observation.component.valueString":"string","Observation.component.valueTime":"time","Observation.contained":"Resource","Observation.dataAbsentReason":"CodeableConcept","Observation.derivedFrom":"Reference","Observation.device":"Reference","Observation.effectiveDateTime":"dateTime","Observation.effectiveInstant":"instant","Observation.effectivePeriod":"Period","Observation.effectiveTiming":"Timing","Observation.encounter":"Reference","Observation.extension":"Extension","Observation.focus":"Reference","Observation.hasMember":"Reference","Observation.id":"System.String","Observation.identifier":"Identifier","Observation.implicitRules":"uri","Observation.instantiatesCanonical":"canonical","Observation.instantiatesReference":"Reference","Observation.interpretation":"CodeableConcept","Observation.issued":"instant","Observation.language":"code","Observation.meta":"Meta","Observation.method":"CodeableConcept","Observation.modifierExtension":"Extension","Observation.note":"Annotation","Observation.partOf":"Reference","Observation.performer":"Reference","Observation.referenceRange":"BackboneElement","Observation.referenceRange.age":"Range","Observation.referenceRange.appliesTo":"CodeableConcept","Observation.referenceRange.extension":"Extension","Observation.referenceRange.high":"Quantity","Observation.referenceRange.id":"System.String","Observation.referenceRange.low":"Quantity","Observation.referenceRange.modifierExtension":"Extension","Observation.referenceRange.normalValue":"CodeableConcept","Observation.referenceRange.text":"markdown","Observation.referenceRange.type":"CodeableConcept","Observation.specimen":"Reference","Observation.status":"code","Observation.subject":"Reference","Observation.text":"Narrative","Observation.triggeredBy":"BackboneElement","Observation.triggeredBy.extension":"Extension","Observation.triggeredBy.id":"System.String","Observation.triggeredBy.modifierExtension":"Extension","Observation.triggeredBy.observation":"Reference","Observation.triggeredBy.reason":"string","Observation.triggeredBy.type":"code","Observation.valueAttachment":"Attachment","Observation.valueBoolean":"boolean","Observation.valueCodeableConcept":"CodeableConcept","Observation.valueDateTime":"dateTime","Observation.valueInteger":"integer","Observation.valuePeriod":"Period","Observation.valueQuantity":"Quantity","Observation.valueRange":"Range","Observation.valueRatio":"Ratio","Observation.valueReference":"Reference","Observation.valueSampledData":"SampledData","Observation.valueString":"string","Observation.valueTime":"time","ObservationDefinition.approvalDate":"date","ObservationDefinition.bodySite":"CodeableConcept","ObservationDefinition.category":"CodeableConcept","ObservationDefinition.code":"CodeableConcept","ObservationDefinition.component":"BackboneElement","ObservationDefinition.component.code":"CodeableConcept","ObservationDefinition.component.extension":"Extension","ObservationDefinition.component.id":"System.String","ObservationDefinition.component.modifierExtension":"Extension","ObservationDefinition.component.permittedDataType":"code","ObservationDefinition.component.permittedUnit":"Coding","ObservationDefinition.contact":"ContactDetail","ObservationDefinition.contained":"Resource","ObservationDefinition.copyright":"markdown","ObservationDefinition.copyrightLabel":"string","ObservationDefinition.date":"dateTime","ObservationDefinition.derivedFromCanonical":"canonical","ObservationDefinition.derivedFromUri":"uri","ObservationDefinition.description":"markdown","ObservationDefinition.device":"Reference","ObservationDefinition.effectivePeriod":"Period","ObservationDefinition.experimental":"boolean","ObservationDefinition.extension":"Extension","ObservationDefinition.hasMember":"Reference","ObservationDefinition.id":"System.String","ObservationDefinition.identifier":"Identifier","ObservationDefinition.implicitRules":"uri","ObservationDefinition.jurisdiction":"CodeableConcept","ObservationDefinition.language":"code","ObservationDefinition.lastReviewDate":"date","ObservationDefinition.meta":"Meta","ObservationDefinition.method":"CodeableConcept","ObservationDefinition.modifierExtension":"Extension","ObservationDefinition.multipleResultsAllowed":"boolean","ObservationDefinition.name":"string","ObservationDefinition.performerType":"CodeableConcept","ObservationDefinition.permittedDataType":"code","ObservationDefinition.permittedUnit":"Coding","ObservationDefinition.preferredReportName":"string","ObservationDefinition.publisher":"string","ObservationDefinition.purpose":"markdown","ObservationDefinition.qualifiedValue":"BackboneElement","ObservationDefinition.qualifiedValue.abnormalCodedValueSet":"canonical","ObservationDefinition.qualifiedValue.age":"Range","ObservationDefinition.qualifiedValue.appliesTo":"CodeableConcept","ObservationDefinition.qualifiedValue.condition":"string","ObservationDefinition.qualifiedValue.context":"CodeableConcept","ObservationDefinition.qualifiedValue.criticalCodedValueSet":"canonical","ObservationDefinition.qualifiedValue.extension":"Extension","ObservationDefinition.qualifiedValue.gender":"code","ObservationDefinition.qualifiedValue.gestationalAge":"Range","ObservationDefinition.qualifiedValue.id":"System.String","ObservationDefinition.qualifiedValue.modifierExtension":"Extension","ObservationDefinition.qualifiedValue.normalCodedValueSet":"canonical","ObservationDefinition.qualifiedValue.range":"Range","ObservationDefinition.qualifiedValue.rangeCategory":"code","ObservationDefinition.qualifiedValue.validCodedValueSet":"canonical","ObservationDefinition.specimen":"Reference","ObservationDefinition.status":"code","ObservationDefinition.subject":"CodeableConcept","ObservationDefinition.text":"Narrative","ObservationDefinition.title":"string","ObservationDefinition.url":"uri","ObservationDefinition.useContext":"UsageContext","ObservationDefinition.version":"string","ObservationDefinition.versionAlgorithmCoding":"Coding","ObservationDefinition.versionAlgorithmString":"string","OperationDefinition.affectsState":"boolean","OperationDefinition.base":"canonical","OperationDefinition.code":"code","OperationDefinition.comment":"markdown","OperationDefinition.contact":"ContactDetail","OperationDefinition.contained":"Resource","OperationDefinition.copyright":"markdown","OperationDefinition.copyrightLabel":"string","OperationDefinition.date":"dateTime","OperationDefinition.description":"markdown","OperationDefinition.experimental":"boolean","OperationDefinition.extension":"Extension","OperationDefinition.id":"System.String","OperationDefinition.identifier":"Identifier","OperationDefinition.implicitRules":"uri","OperationDefinition.inputProfile":"canonical","OperationDefinition.instance":"boolean","OperationDefinition.jurisdiction":"CodeableConcept","OperationDefinition.kind":"code","OperationDefinition.language":"code","OperationDefinition.meta":"Meta","OperationDefinition.modifierExtension":"Extension","OperationDefinition.name":"string","OperationDefinition.outputProfile":"canonical","OperationDefinition.overload":"BackboneElement","OperationDefinition.overload.comment":"string","OperationDefinition.overload.extension":"Extension","OperationDefinition.overload.id":"System.String","OperationDefinition.overload.modifierExtension":"Extension","OperationDefinition.overload.parameterName":"string","OperationDefinition.parameter":"BackboneElement","OperationDefinition.parameter.allowedType":"code","OperationDefinition.parameter.binding":"BackboneElement","OperationDefinition.parameter.binding.extension":"Extension","OperationDefinition.parameter.binding.id":"System.String","OperationDefinition.parameter.binding.modifierExtension":"Extension","OperationDefinition.parameter.binding.strength":"code","OperationDefinition.parameter.binding.valueSet":"canonical","OperationDefinition.parameter.documentation":"markdown","OperationDefinition.parameter.extension":"Extension","OperationDefinition.parameter.id":"System.String","OperationDefinition.parameter.max":"string","OperationDefinition.parameter.min":"integer","OperationDefinition.parameter.modifierExtension":"Extension","OperationDefinition.parameter.name":"code","OperationDefinition.parameter.referencedFrom":"BackboneElement","OperationDefinition.parameter.referencedFrom.extension":"Extension","OperationDefinition.parameter.referencedFrom.id":"System.String","OperationDefinition.parameter.referencedFrom.modifierExtension":"Extension","OperationDefinition.parameter.referencedFrom.source":"string","OperationDefinition.parameter.referencedFrom.sourceId":"string","OperationDefinition.parameter.scope":"code","OperationDefinition.parameter.searchType":"code","OperationDefinition.parameter.targetProfile":"canonical","OperationDefinition.parameter.type":"code","OperationDefinition.parameter.use":"code","OperationDefinition.publisher":"string","OperationDefinition.purpose":"markdown","OperationDefinition.resource":"code","OperationDefinition.status":"code","OperationDefinition.system":"boolean","OperationDefinition.text":"Narrative","OperationDefinition.title":"string","OperationDefinition.type":"boolean","OperationDefinition.url":"uri","OperationDefinition.useContext":"UsageContext","OperationDefinition.version":"string","OperationDefinition.versionAlgorithmCoding":"Coding","OperationDefinition.versionAlgorithmString":"string","OperationOutcome.contained":"Resource","OperationOutcome.extension":"Extension","OperationOutcome.id":"System.String","OperationOutcome.implicitRules":"uri","OperationOutcome.issue":"BackboneElement","OperationOutcome.issue.code":"code","OperationOutcome.issue.details":"CodeableConcept","OperationOutcome.issue.diagnostics":"string","OperationOutcome.issue.expression":"string","OperationOutcome.issue.extension":"Extension","OperationOutcome.issue.id":"System.String","OperationOutcome.issue.location":"string","OperationOutcome.issue.modifierExtension":"Extension","OperationOutcome.issue.severity":"code","OperationOutcome.language":"code","OperationOutcome.meta":"Meta","OperationOutcome.modifierExtension":"Extension","OperationOutcome.text":"Narrative","Organization.active":"boolean","Organization.alias":"string","Organization.contact":"ExtendedContactDetail","Organization.contained":"Resource","Organization.description":"markdown","Organization.endpoint":"Reference","Organization.extension":"Extension","Organization.id":"System.String","Organization.identifier":"Identifier","Organization.implicitRules":"uri","Organization.language":"code","Organization.meta":"Meta","Organization.modifierExtension":"Extension","Organization.name":"string","Organization.partOf":"Reference","Organization.qualification":"BackboneElement","Organization.qualification.code":"CodeableConcept","Organization.qualification.extension":"Extension","Organization.qualification.id":"System.String","Organization.qualification.identifier":"Identifier","Organization.qualification.issuer":"Reference","Organization.qualification.modifierExtension":"Extension","Organization.qualification.period":"Period","Organization.text":"Narrative","Organization.type":"CodeableConcept","OrganizationAffiliation.active":"boolean","OrganizationAffiliation.code":"CodeableConcept","OrganizationAffiliation.contact":"ExtendedContactDetail","OrganizationAffiliation.contained":"Resource","OrganizationAffiliation.endpoint":"Reference","OrganizationAffiliation.extension":"Extension","OrganizationAffiliation.healthcareService":"Reference","OrganizationAffiliation.id":"System.String","OrganizationAffiliation.identifier":"Identifier","OrganizationAffiliation.implicitRules":"uri","OrganizationAffiliation.language":"code","OrganizationAffiliation.location":"Reference","OrganizationAffiliation.meta":"Meta","OrganizationAffiliation.modifierExtension":"Extension","OrganizationAffiliation.network":"Reference","OrganizationAffiliation.organization":"Reference","OrganizationAffiliation.participatingOrganization":"Reference","OrganizationAffiliation.period":"Period","OrganizationAffiliation.specialty":"CodeableConcept","OrganizationAffiliation.text":"Narrative","PackagedProductDefinition.attachedDocument":"Reference","PackagedProductDefinition.contained":"Resource","PackagedProductDefinition.containedItemQuantity":"Quantity","PackagedProductDefinition.copackagedIndicator":"boolean","PackagedProductDefinition.description":"markdown","PackagedProductDefinition.extension":"Extension","PackagedProductDefinition.id":"System.String","PackagedProductDefinition.identifier":"Identifier","PackagedProductDefinition.implicitRules":"uri","PackagedProductDefinition.language":"code","PackagedProductDefinition.legalStatusOfSupply":"BackboneElement","PackagedProductDefinition.legalStatusOfSupply.code":"CodeableConcept","PackagedProductDefinition.legalStatusOfSupply.extension":"Extension","PackagedProductDefinition.legalStatusOfSupply.id":"System.String","PackagedProductDefinition.legalStatusOfSupply.jurisdiction":"CodeableConcept","PackagedProductDefinition.legalStatusOfSupply.modifierExtension":"Extension","PackagedProductDefinition.manufacturer":"Reference","PackagedProductDefinition.marketingStatus":"MarketingStatus","PackagedProductDefinition.meta":"Meta","PackagedProductDefinition.modifierExtension":"Extension","PackagedProductDefinition.name":"string","PackagedProductDefinition.packageFor":"Reference","PackagedProductDefinition.packaging":"BackboneElement","PackagedProductDefinition.packaging.alternateMaterial":"CodeableConcept","PackagedProductDefinition.packaging.componentPart":"boolean","PackagedProductDefinition.packaging.containedItem":"BackboneElement","PackagedProductDefinition.packaging.containedItem.amount":"Quantity","PackagedProductDefinition.packaging.containedItem.extension":"Extension","PackagedProductDefinition.packaging.containedItem.id":"System.String","PackagedProductDefinition.packaging.containedItem.item":"CodeableReference","PackagedProductDefinition.packaging.containedItem.modifierExtension":"Extension","PackagedProductDefinition.packaging.extension":"Extension","PackagedProductDefinition.packaging.id":"System.String","PackagedProductDefinition.packaging.identifier":"Identifier","PackagedProductDefinition.packaging.manufacturer":"Reference","PackagedProductDefinition.packaging.material":"CodeableConcept","PackagedProductDefinition.packaging.modifierExtension":"Extension","PackagedProductDefinition.packaging.property":"BackboneElement","PackagedProductDefinition.packaging.property.extension":"Extension","PackagedProductDefinition.packaging.property.id":"System.String","PackagedProductDefinition.packaging.property.modifierExtension":"Extension","PackagedProductDefinition.packaging.property.type":"CodeableConcept","PackagedProductDefinition.packaging.property.valueAttachment":"Attachment","PackagedProductDefinition.packaging.property.valueBoolean":"boolean","PackagedProductDefinition.packaging.property.valueCodeableConcept":"CodeableConcept","PackagedProductDefinition.packaging.property.valueDate":"date","PackagedProductDefinition.packaging.property.valueQuantity":"Quantity","PackagedProductDefinition.packaging.quantity":"integer","PackagedProductDefinition.packaging.shelfLifeStorage":"ProductShelfLife","PackagedProductDefinition.packaging.type":"CodeableConcept","PackagedProductDefinition.status":"CodeableConcept","PackagedProductDefinition.statusDate":"dateTime","PackagedProductDefinition.text":"Narrative","PackagedProductDefinition.type":"CodeableConcept","ParameterDefinition.documentation":"string","ParameterDefinition.extension":"Extension","ParameterDefinition.id":"System.String","ParameterDefinition.max":"string","ParameterDefinition.min":"integer","ParameterDefinition.name":"code","ParameterDefinition.profile":"canonical","ParameterDefinition.type":"code","ParameterDefinition.use":"code","Parameters.id":"System.String","Parameters.implicitRules":"uri","Parameters.language":"code","Parameters.meta":"Meta","Parameters.parameter":"BackboneElement","Parameters.parameter.extension":"Extension","Parameters.parameter.id":"System.String","Parameters.parameter.modifierExtension":"Extension","Parameters.parameter.name":"string","Parameters.parameter.resource":"Resource","Parameters.parameter.valueAddress":"Address","Parameters.parameter.valueAge":"Age","Parameters.parameter.valueAnnotation":"Annotation","Parameters.parameter.valueAttachment":"Attachment","Parameters.parameter.valueAvailability":"Availability","Parameters.parameter.valueBase64Binary":"base64Binary","Parameters.parameter.valueBoolean":"boolean","Parameters.parameter.valueCanonical":"canonical","Parameters.parameter.valueCode":"code","Parameters.parameter.valueCodeableConcept":"CodeableConcept","Parameters.parameter.valueCodeableReference":"CodeableReference","Parameters.parameter.valueCoding":"Coding","Parameters.parameter.valueContactDetail":"ContactDetail","Parameters.parameter.valueContactPoint":"ContactPoint","Parameters.parameter.valueCount":"Count","Parameters.parameter.valueDataRequirement":"DataRequirement","Parameters.parameter.valueDate":"date","Parameters.parameter.valueDateTime":"dateTime","Parameters.parameter.valueDecimal":"decimal","Parameters.parameter.valueDistance":"Distance","Parameters.parameter.valueDosage":"Dosage","Parameters.parameter.valueDuration":"Duration","Parameters.parameter.valueExpression":"Expression","Parameters.parameter.valueExtendedContactDetail":"ExtendedContactDetail","Parameters.parameter.valueHumanName":"HumanName","Parameters.parameter.valueId":"id","Parameters.parameter.valueIdentifier":"Identifier","Parameters.parameter.valueInstant":"instant","Parameters.parameter.valueInteger":"integer","Parameters.parameter.valueInteger64":"integer64","Parameters.parameter.valueMarkdown":"markdown","Parameters.parameter.valueMeta":"Meta","Parameters.parameter.valueMoney":"Money","Parameters.parameter.valueOid":"oid","Parameters.parameter.valueParameterDefinition":"ParameterDefinition","Parameters.parameter.valuePeriod":"Period","Parameters.parameter.valuePositiveInt":"positiveInt","Parameters.parameter.valueQuantity":"Quantity","Parameters.parameter.valueRange":"Range","Parameters.parameter.valueRatio":"Ratio","Parameters.parameter.valueRatioRange":"RatioRange","Parameters.parameter.valueReference":"Reference","Parameters.parameter.valueRelatedArtifact":"RelatedArtifact","Parameters.parameter.valueSampledData":"SampledData","Parameters.parameter.valueSignature":"Signature","Parameters.parameter.valueString":"string","Parameters.parameter.valueTime":"time","Parameters.parameter.valueTiming":"Timing","Parameters.parameter.valueTriggerDefinition":"TriggerDefinition","Parameters.parameter.valueUnsignedInt":"unsignedInt","Parameters.parameter.valueUri":"uri","Parameters.parameter.valueUrl":"url","Parameters.parameter.valueUsageContext":"UsageContext","Parameters.parameter.valueUuid":"uuid","Patient.active":"boolean","Patient.address":"Address","Patient.birthDate":"date","Patient.communication":"BackboneElement","Patient.communication.extension":"Extension","Patient.communication.id":"System.String","Patient.communication.language":"CodeableConcept","Patient.communication.modifierExtension":"Extension","Patient.communication.preferred":"boolean","Patient.contact":"BackboneElement","Patient.contact.address":"Address","Patient.contact.extension":"Extension","Patient.contact.gender":"code","Patient.contact.id":"System.String","Patient.contact.modifierExtension":"Extension","Patient.contact.name":"HumanName","Patient.contact.organization":"Reference","Patient.contact.period":"Period","Patient.contact.relationship":"CodeableConcept","Patient.contact.telecom":"ContactPoint","Patient.contained":"Resource","Patient.deceasedBoolean":"boolean","Patient.deceasedDateTime":"dateTime","Patient.extension":"Extension","Patient.gender":"code","Patient.generalPractitioner":"Reference","Patient.id":"System.String","Patient.identifier":"Identifier","Patient.implicitRules":"uri","Patient.language":"code","Patient.link":"BackboneElement","Patient.link.extension":"Extension","Patient.link.id":"System.String","Patient.link.modifierExtension":"Extension","Patient.link.other":"Reference","Patient.link.type":"code","Patient.managingOrganization":"Reference","Patient.maritalStatus":"CodeableConcept","Patient.meta":"Meta","Patient.modifierExtension":"Extension","Patient.multipleBirthBoolean":"boolean","Patient.multipleBirthInteger":"integer","Patient.name":"HumanName","Patient.photo":"Attachment","Patient.telecom":"ContactPoint","Patient.text":"Narrative","PaymentNotice.amount":"Money","PaymentNotice.contained":"Resource","PaymentNotice.created":"dateTime","PaymentNotice.extension":"Extension","PaymentNotice.id":"System.String","PaymentNotice.identifier":"Identifier","PaymentNotice.implicitRules":"uri","PaymentNotice.language":"code","PaymentNotice.meta":"Meta","PaymentNotice.modifierExtension":"Extension","PaymentNotice.payee":"Reference","PaymentNotice.payment":"Reference","PaymentNotice.paymentDate":"date","PaymentNotice.paymentStatus":"CodeableConcept","PaymentNotice.recipient":"Reference","PaymentNotice.reporter":"Reference","PaymentNotice.request":"Reference","PaymentNotice.response":"Reference","PaymentNotice.status":"code","PaymentNotice.text":"Narrative","PaymentReconciliation.accountNumber":"string","PaymentReconciliation.allocation":"BackboneElement","PaymentReconciliation.allocation.account":"Reference","PaymentReconciliation.allocation.amount":"Money","PaymentReconciliation.allocation.date":"date","PaymentReconciliation.allocation.encounter":"Reference","PaymentReconciliation.allocation.extension":"Extension","PaymentReconciliation.allocation.id":"System.String","PaymentReconciliation.allocation.identifier":"Identifier","PaymentReconciliation.allocation.modifierExtension":"Extension","PaymentReconciliation.allocation.payee":"Reference","PaymentReconciliation.allocation.predecessor":"Identifier","PaymentReconciliation.allocation.response":"Reference","PaymentReconciliation.allocation.responsible":"Reference","PaymentReconciliation.allocation.submitter":"Reference","PaymentReconciliation.allocation.target":"Reference","PaymentReconciliation.allocation.targetItemIdentifier":"Identifier","PaymentReconciliation.allocation.targetItemPositiveInt":"positiveInt","PaymentReconciliation.allocation.targetItemString":"string","PaymentReconciliation.allocation.type":"CodeableConcept","PaymentReconciliation.amount":"Money","PaymentReconciliation.authorization":"string","PaymentReconciliation.cardBrand":"string","PaymentReconciliation.contained":"Resource","PaymentReconciliation.created":"dateTime","PaymentReconciliation.date":"date","PaymentReconciliation.disposition":"string","PaymentReconciliation.enterer":"Reference","PaymentReconciliation.expirationDate":"date","PaymentReconciliation.extension":"Extension","PaymentReconciliation.formCode":"CodeableConcept","PaymentReconciliation.id":"System.String","PaymentReconciliation.identifier":"Identifier","PaymentReconciliation.implicitRules":"uri","PaymentReconciliation.issuerType":"CodeableConcept","PaymentReconciliation.kind":"CodeableConcept","PaymentReconciliation.language":"code","PaymentReconciliation.location":"Reference","PaymentReconciliation.meta":"Meta","PaymentReconciliation.method":"CodeableConcept","PaymentReconciliation.modifierExtension":"Extension","PaymentReconciliation.outcome":"code","PaymentReconciliation.paymentIdentifier":"Identifier","PaymentReconciliation.paymentIssuer":"Reference","PaymentReconciliation.period":"Period","PaymentReconciliation.processNote":"BackboneElement","PaymentReconciliation.processNote.extension":"Extension","PaymentReconciliation.processNote.id":"System.String","PaymentReconciliation.processNote.modifierExtension":"Extension","PaymentReconciliation.processNote.text":"string","PaymentReconciliation.processNote.type":"code","PaymentReconciliation.processor":"string","PaymentReconciliation.referenceNumber":"string","PaymentReconciliation.request":"Reference","PaymentReconciliation.requestor":"Reference","PaymentReconciliation.returnedAmount":"Money","PaymentReconciliation.status":"code","PaymentReconciliation.tenderedAmount":"Money","PaymentReconciliation.text":"Narrative","PaymentReconciliation.type":"CodeableConcept","Period.end":"dateTime","Period.extension":"Extension","Period.id":"System.String","Period.start":"dateTime","Permission.asserter":"Reference","Permission.combining":"code","Permission.contained":"Resource","Permission.date":"dateTime","Permission.extension":"Extension","Permission.id":"System.String","Permission.implicitRules":"uri","Permission.justification":"BackboneElement","Permission.justification.basis":"CodeableConcept","Permission.justification.evidence":"Reference","Permission.justification.extension":"Extension","Permission.justification.id":"System.String","Permission.justification.modifierExtension":"Extension","Permission.language":"code","Permission.meta":"Meta","Permission.modifierExtension":"Extension","Permission.rule":"BackboneElement","Permission.rule.activity":"BackboneElement","Permission.rule.activity.action":"CodeableConcept","Permission.rule.activity.actor":"Reference","Permission.rule.activity.extension":"Extension","Permission.rule.activity.id":"System.String","Permission.rule.activity.modifierExtension":"Extension","Permission.rule.activity.purpose":"CodeableConcept","Permission.rule.data":"BackboneElement","Permission.rule.data.expression":"Expression","Permission.rule.data.extension":"Extension","Permission.rule.data.id":"System.String","Permission.rule.data.modifierExtension":"Extension","Permission.rule.data.period":"Period","Permission.rule.data.resource":"BackboneElement","Permission.rule.data.resource.extension":"Extension","Permission.rule.data.resource.id":"System.String","Permission.rule.data.resource.meaning":"code","Permission.rule.data.resource.modifierExtension":"Extension","Permission.rule.data.resource.reference":"Reference","Permission.rule.data.security":"Coding","Permission.rule.extension":"Extension","Permission.rule.id":"System.String","Permission.rule.limit":"CodeableConcept","Permission.rule.modifierExtension":"Extension","Permission.rule.type":"code","Permission.status":"code","Permission.text":"Narrative","Permission.validity":"Period","Person.active":"boolean","Person.address":"Address","Person.birthDate":"date","Person.communication":"BackboneElement","Person.communication.extension":"Extension","Person.communication.id":"System.String","Person.communication.language":"CodeableConcept","Person.communication.modifierExtension":"Extension","Person.communication.preferred":"boolean","Person.contained":"Resource","Person.deceasedBoolean":"boolean","Person.deceasedDateTime":"dateTime","Person.extension":"Extension","Person.gender":"code","Person.id":"System.String","Person.identifier":"Identifier","Person.implicitRules":"uri","Person.language":"code","Person.link":"BackboneElement","Person.link.assurance":"code","Person.link.extension":"Extension","Person.link.id":"System.String","Person.link.modifierExtension":"Extension","Person.link.target":"Reference","Person.managingOrganization":"Reference","Person.maritalStatus":"CodeableConcept","Person.meta":"Meta","Person.modifierExtension":"Extension","Person.name":"HumanName","Person.photo":"Attachment","Person.telecom":"ContactPoint","Person.text":"Narrative","PlanDefinition.action":"BackboneElement","PlanDefinition.action.cardinalityBehavior":"code","PlanDefinition.action.code":"CodeableConcept","PlanDefinition.action.condition":"BackboneElement","PlanDefinition.action.condition.expression":"Expression","PlanDefinition.action.condition.extension":"Extension","PlanDefinition.action.condition.id":"System.String","PlanDefinition.action.condition.kind":"code","PlanDefinition.action.condition.modifierExtension":"Extension","PlanDefinition.action.definitionCanonical":"canonical","PlanDefinition.action.definitionUri":"uri","PlanDefinition.action.description":"markdown","PlanDefinition.action.documentation":"RelatedArtifact","PlanDefinition.action.dynamicValue":"BackboneElement","PlanDefinition.action.dynamicValue.expression":"Expression","PlanDefinition.action.dynamicValue.extension":"Extension","PlanDefinition.action.dynamicValue.id":"System.String","PlanDefinition.action.dynamicValue.modifierExtension":"Extension","PlanDefinition.action.dynamicValue.path":"string","PlanDefinition.action.extension":"Extension","PlanDefinition.action.goalId":"id","PlanDefinition.action.groupingBehavior":"code","PlanDefinition.action.id":"System.String","PlanDefinition.action.input":"BackboneElement","PlanDefinition.action.input.extension":"Extension","PlanDefinition.action.input.id":"System.String","PlanDefinition.action.input.modifierExtension":"Extension","PlanDefinition.action.input.relatedData":"id","PlanDefinition.action.input.requirement":"DataRequirement","PlanDefinition.action.input.title":"string","PlanDefinition.action.linkId":"string","PlanDefinition.action.location":"CodeableReference","PlanDefinition.action.modifierExtension":"Extension","PlanDefinition.action.output":"BackboneElement","PlanDefinition.action.output.extension":"Extension","PlanDefinition.action.output.id":"System.String","PlanDefinition.action.output.modifierExtension":"Extension","PlanDefinition.action.output.relatedData":"string","PlanDefinition.action.output.requirement":"DataRequirement","PlanDefinition.action.output.title":"string","PlanDefinition.action.participant":"BackboneElement","PlanDefinition.action.participant.actorId":"string","PlanDefinition.action.participant.extension":"Extension","PlanDefinition.action.participant.function":"CodeableConcept","PlanDefinition.action.participant.id":"System.String","PlanDefinition.action.participant.modifierExtension":"Extension","PlanDefinition.action.participant.role":"CodeableConcept","PlanDefinition.action.participant.type":"code","PlanDefinition.action.participant.typeCanonical":"canonical","PlanDefinition.action.participant.typeReference":"Reference","PlanDefinition.action.precheckBehavior":"code","PlanDefinition.action.prefix":"string","PlanDefinition.action.priority":"code","PlanDefinition.action.reason":"CodeableConcept","PlanDefinition.action.relatedAction":"BackboneElement","PlanDefinition.action.relatedAction.endRelationship":"code","PlanDefinition.action.relatedAction.extension":"Extension","PlanDefinition.action.relatedAction.id":"System.String","PlanDefinition.action.relatedAction.modifierExtension":"Extension","PlanDefinition.action.relatedAction.offsetDuration":"Duration","PlanDefinition.action.relatedAction.offsetRange":"Range","PlanDefinition.action.relatedAction.relationship":"code","PlanDefinition.action.relatedAction.targetId":"id","PlanDefinition.action.requiredBehavior":"code","PlanDefinition.action.selectionBehavior":"code","PlanDefinition.action.subjectCanonical":"canonical","PlanDefinition.action.subjectCodeableConcept":"CodeableConcept","PlanDefinition.action.subjectReference":"Reference","PlanDefinition.action.textEquivalent":"markdown","PlanDefinition.action.timingAge":"Age","PlanDefinition.action.timingDuration":"Duration","PlanDefinition.action.timingRange":"Range","PlanDefinition.action.timingTiming":"Timing","PlanDefinition.action.title":"string","PlanDefinition.action.transform":"canonical","PlanDefinition.action.trigger":"TriggerDefinition","PlanDefinition.action.type":"CodeableConcept","PlanDefinition.actor":"BackboneElement","PlanDefinition.actor.description":"markdown","PlanDefinition.actor.extension":"Extension","PlanDefinition.actor.id":"System.String","PlanDefinition.actor.modifierExtension":"Extension","PlanDefinition.actor.option":"BackboneElement","PlanDefinition.actor.option.extension":"Extension","PlanDefinition.actor.option.id":"System.String","PlanDefinition.actor.option.modifierExtension":"Extension","PlanDefinition.actor.option.role":"CodeableConcept","PlanDefinition.actor.option.type":"code","PlanDefinition.actor.option.typeCanonical":"canonical","PlanDefinition.actor.option.typeReference":"Reference","PlanDefinition.actor.title":"string","PlanDefinition.approvalDate":"date","PlanDefinition.asNeededBoolean":"boolean","PlanDefinition.asNeededCodeableConcept":"CodeableConcept","PlanDefinition.author":"ContactDetail","PlanDefinition.contact":"ContactDetail","PlanDefinition.contained":"Resource","PlanDefinition.copyright":"markdown","PlanDefinition.copyrightLabel":"string","PlanDefinition.date":"dateTime","PlanDefinition.description":"markdown","PlanDefinition.editor":"ContactDetail","PlanDefinition.effectivePeriod":"Period","PlanDefinition.endorser":"ContactDetail","PlanDefinition.experimental":"boolean","PlanDefinition.extension":"Extension","PlanDefinition.goal":"BackboneElement","PlanDefinition.goal.addresses":"CodeableConcept","PlanDefinition.goal.category":"CodeableConcept","PlanDefinition.goal.description":"CodeableConcept","PlanDefinition.goal.documentation":"RelatedArtifact","PlanDefinition.goal.extension":"Extension","PlanDefinition.goal.id":"System.String","PlanDefinition.goal.modifierExtension":"Extension","PlanDefinition.goal.priority":"CodeableConcept","PlanDefinition.goal.start":"CodeableConcept","PlanDefinition.goal.target":"BackboneElement","PlanDefinition.goal.target.detailBoolean":"boolean","PlanDefinition.goal.target.detailCodeableConcept":"CodeableConcept","PlanDefinition.goal.target.detailInteger":"integer","PlanDefinition.goal.target.detailQuantity":"Quantity","PlanDefinition.goal.target.detailRange":"Range","PlanDefinition.goal.target.detailRatio":"Ratio","PlanDefinition.goal.target.detailString":"string","PlanDefinition.goal.target.due":"Duration","PlanDefinition.goal.target.extension":"Extension","PlanDefinition.goal.target.id":"System.String","PlanDefinition.goal.target.measure":"CodeableConcept","PlanDefinition.goal.target.modifierExtension":"Extension","PlanDefinition.id":"System.String","PlanDefinition.identifier":"Identifier","PlanDefinition.implicitRules":"uri","PlanDefinition.jurisdiction":"CodeableConcept","PlanDefinition.language":"code","PlanDefinition.lastReviewDate":"date","PlanDefinition.library":"canonical","PlanDefinition.meta":"Meta","PlanDefinition.modifierExtension":"Extension","PlanDefinition.name":"string","PlanDefinition.publisher":"string","PlanDefinition.purpose":"markdown","PlanDefinition.relatedArtifact":"RelatedArtifact","PlanDefinition.reviewer":"ContactDetail","PlanDefinition.status":"code","PlanDefinition.subjectCanonical":"canonical","PlanDefinition.subjectCodeableConcept":"CodeableConcept","PlanDefinition.subjectReference":"Reference","PlanDefinition.subtitle":"string","PlanDefinition.text":"Narrative","PlanDefinition.title":"string","PlanDefinition.topic":"CodeableConcept","PlanDefinition.type":"CodeableConcept","PlanDefinition.url":"uri","PlanDefinition.usage":"markdown","PlanDefinition.useContext":"UsageContext","PlanDefinition.version":"string","PlanDefinition.versionAlgorithmCoding":"Coding","PlanDefinition.versionAlgorithmString":"string","Practitioner.active":"boolean","Practitioner.address":"Address","Practitioner.birthDate":"date","Practitioner.communication":"BackboneElement","Practitioner.communication.extension":"Extension","Practitioner.communication.id":"System.String","Practitioner.communication.language":"CodeableConcept","Practitioner.communication.modifierExtension":"Extension","Practitioner.communication.preferred":"boolean","Practitioner.contained":"Resource","Practitioner.deceasedBoolean":"boolean","Practitioner.deceasedDateTime":"dateTime","Practitioner.extension":"Extension","Practitioner.gender":"code","Practitioner.id":"System.String","Practitioner.identifier":"Identifier","Practitioner.implicitRules":"uri","Practitioner.language":"code","Practitioner.meta":"Meta","Practitioner.modifierExtension":"Extension","Practitioner.name":"HumanName","Practitioner.photo":"Attachment","Practitioner.qualification":"BackboneElement","Practitioner.qualification.code":"CodeableConcept","Practitioner.qualification.extension":"Extension","Practitioner.qualification.id":"System.String","Practitioner.qualification.identifier":"Identifier","Practitioner.qualification.issuer":"Reference","Practitioner.qualification.modifierExtension":"Extension","Practitioner.qualification.period":"Period","Practitioner.telecom":"ContactPoint","Practitioner.text":"Narrative","PractitionerRole.active":"boolean","PractitionerRole.availability":"Availability","PractitionerRole.characteristic":"CodeableConcept","PractitionerRole.code":"CodeableConcept","PractitionerRole.communication":"CodeableConcept","PractitionerRole.contact":"ExtendedContactDetail","PractitionerRole.contained":"Resource","PractitionerRole.endpoint":"Reference","PractitionerRole.extension":"Extension","PractitionerRole.healthcareService":"Reference","PractitionerRole.id":"System.String","PractitionerRole.identifier":"Identifier","PractitionerRole.implicitRules":"uri","PractitionerRole.language":"code","PractitionerRole.location":"Reference","PractitionerRole.meta":"Meta","PractitionerRole.modifierExtension":"Extension","PractitionerRole.organization":"Reference","PractitionerRole.period":"Period","PractitionerRole.practitioner":"Reference","PractitionerRole.specialty":"CodeableConcept","PractitionerRole.text":"Narrative","PrimitiveType.extension":"Extension","PrimitiveType.id":"System.String","Procedure.basedOn":"Reference","Procedure.bodySite":"CodeableConcept","Procedure.category":"CodeableConcept","Procedure.code":"CodeableConcept","Procedure.complication":"CodeableReference","Procedure.contained":"Resource","Procedure.encounter":"Reference","Procedure.extension":"Extension","Procedure.focalDevice":"BackboneElement","Procedure.focalDevice.action":"CodeableConcept","Procedure.focalDevice.extension":"Extension","Procedure.focalDevice.id":"System.String","Procedure.focalDevice.manipulated":"Reference","Procedure.focalDevice.modifierExtension":"Extension","Procedure.focus":"Reference","Procedure.followUp":"CodeableConcept","Procedure.id":"System.String","Procedure.identifier":"Identifier","Procedure.implicitRules":"uri","Procedure.instantiatesCanonical":"canonical","Procedure.instantiatesUri":"uri","Procedure.language":"code","Procedure.location":"Reference","Procedure.meta":"Meta","Procedure.modifierExtension":"Extension","Procedure.note":"Annotation","Procedure.occurrenceAge":"Age","Procedure.occurrenceDateTime":"dateTime","Procedure.occurrencePeriod":"Period","Procedure.occurrenceRange":"Range","Procedure.occurrenceString":"string","Procedure.occurrenceTiming":"Timing","Procedure.outcome":"CodeableConcept","Procedure.partOf":"Reference","Procedure.performer":"BackboneElement","Procedure.performer.actor":"Reference","Procedure.performer.extension":"Extension","Procedure.performer.function":"CodeableConcept","Procedure.performer.id":"System.String","Procedure.performer.modifierExtension":"Extension","Procedure.performer.onBehalfOf":"Reference","Procedure.performer.period":"Period","Procedure.reason":"CodeableReference","Procedure.recorded":"dateTime","Procedure.recorder":"Reference","Procedure.report":"Reference","Procedure.reportedBoolean":"boolean","Procedure.reportedReference":"Reference","Procedure.status":"code","Procedure.statusReason":"CodeableConcept","Procedure.subject":"Reference","Procedure.supportingInfo":"Reference","Procedure.text":"Narrative","Procedure.used":"CodeableReference","ProductShelfLife.extension":"Extension","ProductShelfLife.id":"System.String","ProductShelfLife.modifierExtension":"Extension","ProductShelfLife.periodDuration":"Duration","ProductShelfLife.periodString":"string","ProductShelfLife.specialPrecautionsForStorage":"CodeableConcept","ProductShelfLife.type":"CodeableConcept","Provenance.activity":"CodeableConcept","Provenance.agent":"BackboneElement","Provenance.agent.extension":"Extension","Provenance.agent.id":"System.String","Provenance.agent.modifierExtension":"Extension","Provenance.agent.onBehalfOf":"Reference","Provenance.agent.role":"CodeableConcept","Provenance.agent.type":"CodeableConcept","Provenance.agent.who":"Reference","Provenance.authorization":"CodeableReference","Provenance.basedOn":"Reference","Provenance.contained":"Resource","Provenance.encounter":"Reference","Provenance.entity":"BackboneElement","Provenance.entity.extension":"Extension","Provenance.entity.id":"System.String","Provenance.entity.modifierExtension":"Extension","Provenance.entity.role":"code","Provenance.entity.what":"Reference","Provenance.extension":"Extension","Provenance.id":"System.String","Provenance.implicitRules":"uri","Provenance.language":"code","Provenance.location":"Reference","Provenance.meta":"Meta","Provenance.modifierExtension":"Extension","Provenance.occurredDateTime":"dateTime","Provenance.occurredPeriod":"Period","Provenance.patient":"Reference","Provenance.policy":"uri","Provenance.recorded":"instant","Provenance.signature":"Signature","Provenance.target":"Reference","Provenance.text":"Narrative","Quantity.code":"code","Quantity.comparator":"code","Quantity.extension":"Extension","Quantity.id":"System.String","Quantity.system":"uri","Quantity.unit":"string","Quantity.value":"decimal","Questionnaire.approvalDate":"date","Questionnaire.code":"Coding","Questionnaire.contact":"ContactDetail","Questionnaire.contained":"Resource","Questionnaire.copyright":"markdown","Questionnaire.copyrightLabel":"string","Questionnaire.date":"dateTime","Questionnaire.derivedFrom":"canonical","Questionnaire.description":"markdown","Questionnaire.effectivePeriod":"Period","Questionnaire.experimental":"boolean","Questionnaire.extension":"Extension","Questionnaire.id":"System.String","Questionnaire.identifier":"Identifier","Questionnaire.implicitRules":"uri","Questionnaire.item":"BackboneElement","Questionnaire.item.answerConstraint":"code","Questionnaire.item.answerOption":"BackboneElement","Questionnaire.item.answerOption.extension":"Extension","Questionnaire.item.answerOption.id":"System.String","Questionnaire.item.answerOption.initialSelected":"boolean","Questionnaire.item.answerOption.modifierExtension":"Extension","Questionnaire.item.answerOption.valueCoding":"Coding","Questionnaire.item.answerOption.valueDate":"date","Questionnaire.item.answerOption.valueInteger":"integer","Questionnaire.item.answerOption.valueReference":"Reference","Questionnaire.item.answerOption.valueString":"string","Questionnaire.item.answerOption.valueTime":"time","Questionnaire.item.answerValueSet":"canonical","Questionnaire.item.code":"Coding","Questionnaire.item.definition":"uri","Questionnaire.item.disabledDisplay":"code","Questionnaire.item.enableBehavior":"code","Questionnaire.item.enableWhen":"BackboneElement","Questionnaire.item.enableWhen.answerBoolean":"boolean","Questionnaire.item.enableWhen.answerCoding":"Coding","Questionnaire.item.enableWhen.answerDate":"date","Questionnaire.item.enableWhen.answerDateTime":"dateTime","Questionnaire.item.enableWhen.answerDecimal":"decimal","Questionnaire.item.enableWhen.answerInteger":"integer","Questionnaire.item.enableWhen.answerQuantity":"Quantity","Questionnaire.item.enableWhen.answerReference":"Reference","Questionnaire.item.enableWhen.answerString":"string","Questionnaire.item.enableWhen.answerTime":"time","Questionnaire.item.enableWhen.extension":"Extension","Questionnaire.item.enableWhen.id":"System.String","Questionnaire.item.enableWhen.modifierExtension":"Extension","Questionnaire.item.enableWhen.operator":"code","Questionnaire.item.enableWhen.question":"string","Questionnaire.item.extension":"Extension","Questionnaire.item.id":"System.String","Questionnaire.item.initial":"BackboneElement","Questionnaire.item.initial.extension":"Extension","Questionnaire.item.initial.id":"System.String","Questionnaire.item.initial.modifierExtension":"Extension","Questionnaire.item.initial.valueAttachment":"Attachment","Questionnaire.item.initial.valueBoolean":"boolean","Questionnaire.item.initial.valueCoding":"Coding","Questionnaire.item.initial.valueDate":"date","Questionnaire.item.initial.valueDateTime":"dateTime","Questionnaire.item.initial.valueDecimal":"decimal","Questionnaire.item.initial.valueInteger":"integer","Questionnaire.item.initial.valueQuantity":"Quantity","Questionnaire.item.initial.valueReference":"Reference","Questionnaire.item.initial.valueString":"string","Questionnaire.item.initial.valueTime":"time","Questionnaire.item.initial.valueUri":"uri","Questionnaire.item.linkId":"string","Questionnaire.item.maxLength":"integer","Questionnaire.item.modifierExtension":"Extension","Questionnaire.item.prefix":"string","Questionnaire.item.readOnly":"boolean","Questionnaire.item.repeats":"boolean","Questionnaire.item.required":"boolean","Questionnaire.item.text":"string","Questionnaire.item.type":"code","Questionnaire.jurisdiction":"CodeableConcept","Questionnaire.language":"code","Questionnaire.lastReviewDate":"date","Questionnaire.meta":"Meta","Questionnaire.modifierExtension":"Extension","Questionnaire.name":"string","Questionnaire.publisher":"string","Questionnaire.purpose":"markdown","Questionnaire.status":"code","Questionnaire.subjectType":"code","Questionnaire.text":"Narrative","Questionnaire.title":"string","Questionnaire.url":"uri","Questionnaire.useContext":"UsageContext","Questionnaire.version":"string","Questionnaire.versionAlgorithmCoding":"Coding","Questionnaire.versionAlgorithmString":"string","QuestionnaireResponse.author":"Reference","QuestionnaireResponse.authored":"dateTime","QuestionnaireResponse.basedOn":"Reference","QuestionnaireResponse.contained":"Resource","QuestionnaireResponse.encounter":"Reference","QuestionnaireResponse.extension":"Extension","QuestionnaireResponse.id":"System.String","QuestionnaireResponse.identifier":"Identifier","QuestionnaireResponse.implicitRules":"uri","QuestionnaireResponse.item":"BackboneElement","QuestionnaireResponse.item.answer":"BackboneElement","QuestionnaireResponse.item.answer.extension":"Extension","QuestionnaireResponse.item.answer.id":"System.String","QuestionnaireResponse.item.answer.modifierExtension":"Extension","QuestionnaireResponse.item.answer.valueAttachment":"Attachment","QuestionnaireResponse.item.answer.valueBoolean":"boolean","QuestionnaireResponse.item.answer.valueCoding":"Coding","QuestionnaireResponse.item.answer.valueDate":"date","QuestionnaireResponse.item.answer.valueDateTime":"dateTime","QuestionnaireResponse.item.answer.valueDecimal":"decimal","QuestionnaireResponse.item.answer.valueInteger":"integer","QuestionnaireResponse.item.answer.valueQuantity":"Quantity","QuestionnaireResponse.item.answer.valueReference":"Reference","QuestionnaireResponse.item.answer.valueString":"string","QuestionnaireResponse.item.answer.valueTime":"time","QuestionnaireResponse.item.answer.valueUri":"uri","QuestionnaireResponse.item.definition":"uri","QuestionnaireResponse.item.extension":"Extension","QuestionnaireResponse.item.id":"System.String","QuestionnaireResponse.item.linkId":"string","QuestionnaireResponse.item.modifierExtension":"Extension","QuestionnaireResponse.item.text":"string","QuestionnaireResponse.language":"code","QuestionnaireResponse.meta":"Meta","QuestionnaireResponse.modifierExtension":"Extension","QuestionnaireResponse.partOf":"Reference","QuestionnaireResponse.questionnaire":"canonical","QuestionnaireResponse.source":"Reference","QuestionnaireResponse.status":"code","QuestionnaireResponse.subject":"Reference","QuestionnaireResponse.text":"Narrative","Range.extension":"Extension","Range.high":"Quantity","Range.id":"System.String","Range.low":"Quantity","Ratio.denominator":"Quantity","Ratio.extension":"Extension","Ratio.id":"System.String","Ratio.numerator":"Quantity","RatioRange.denominator":"Quantity","RatioRange.extension":"Extension","RatioRange.highNumerator":"Quantity","RatioRange.id":"System.String","RatioRange.lowNumerator":"Quantity","Reference.display":"string","Reference.extension":"Extension","Reference.id":"System.String","Reference.identifier":"Identifier","Reference.reference":"string","Reference.type":"uri","RegulatedAuthorization.attachedDocument":"Reference","RegulatedAuthorization.basis":"CodeableConcept","RegulatedAuthorization.case":"BackboneElement","RegulatedAuthorization.case.dateDateTime":"dateTime","RegulatedAuthorization.case.datePeriod":"Period","RegulatedAuthorization.case.extension":"Extension","RegulatedAuthorization.case.id":"System.String","RegulatedAuthorization.case.identifier":"Identifier","RegulatedAuthorization.case.modifierExtension":"Extension","RegulatedAuthorization.case.status":"CodeableConcept","RegulatedAuthorization.case.type":"CodeableConcept","RegulatedAuthorization.contained":"Resource","RegulatedAuthorization.description":"markdown","RegulatedAuthorization.extension":"Extension","RegulatedAuthorization.holder":"Reference","RegulatedAuthorization.id":"System.String","RegulatedAuthorization.identifier":"Identifier","RegulatedAuthorization.implicitRules":"uri","RegulatedAuthorization.indication":"CodeableReference","RegulatedAuthorization.intendedUse":"CodeableConcept","RegulatedAuthorization.language":"code","RegulatedAuthorization.meta":"Meta","RegulatedAuthorization.modifierExtension":"Extension","RegulatedAuthorization.region":"CodeableConcept","RegulatedAuthorization.regulator":"Reference","RegulatedAuthorization.status":"CodeableConcept","RegulatedAuthorization.statusDate":"dateTime","RegulatedAuthorization.subject":"Reference","RegulatedAuthorization.text":"Narrative","RegulatedAuthorization.type":"CodeableConcept","RegulatedAuthorization.validityPeriod":"Period","RelatedArtifact.citation":"markdown","RelatedArtifact.classifier":"CodeableConcept","RelatedArtifact.display":"string","RelatedArtifact.document":"Attachment","RelatedArtifact.extension":"Extension","RelatedArtifact.id":"System.String","RelatedArtifact.label":"string","RelatedArtifact.publicationDate":"date","RelatedArtifact.publicationStatus":"code","RelatedArtifact.resource":"canonical","RelatedArtifact.resourceReference":"Reference","RelatedArtifact.type":"code","RelatedPerson.active":"boolean","RelatedPerson.address":"Address","RelatedPerson.birthDate":"date","RelatedPerson.communication":"BackboneElement","RelatedPerson.communication.extension":"Extension","RelatedPerson.communication.id":"System.String","RelatedPerson.communication.language":"CodeableConcept","RelatedPerson.communication.modifierExtension":"Extension","RelatedPerson.communication.preferred":"boolean","RelatedPerson.contained":"Resource","RelatedPerson.extension":"Extension","RelatedPerson.gender":"code","RelatedPerson.id":"System.String","RelatedPerson.identifier":"Identifier","RelatedPerson.implicitRules":"uri","RelatedPerson.language":"code","RelatedPerson.meta":"Meta","RelatedPerson.modifierExtension":"Extension","RelatedPerson.name":"HumanName","RelatedPerson.patient":"Reference","RelatedPerson.period":"Period","RelatedPerson.photo":"Attachment","RelatedPerson.relationship":"CodeableConcept","RelatedPerson.telecom":"ContactPoint","RelatedPerson.text":"Narrative","RequestOrchestration.action":"BackboneElement","RequestOrchestration.action.cardinalityBehavior":"code","RequestOrchestration.action.code":"CodeableConcept","RequestOrchestration.action.condition":"BackboneElement","RequestOrchestration.action.condition.expression":"Expression","RequestOrchestration.action.condition.extension":"Extension","RequestOrchestration.action.condition.id":"System.String","RequestOrchestration.action.condition.kind":"code","RequestOrchestration.action.condition.modifierExtension":"Extension","RequestOrchestration.action.definitionCanonical":"canonical","RequestOrchestration.action.definitionUri":"uri","RequestOrchestration.action.description":"markdown","RequestOrchestration.action.documentation":"RelatedArtifact","RequestOrchestration.action.dynamicValue":"BackboneElement","RequestOrchestration.action.dynamicValue.expression":"Expression","RequestOrchestration.action.dynamicValue.extension":"Extension","RequestOrchestration.action.dynamicValue.id":"System.String","RequestOrchestration.action.dynamicValue.modifierExtension":"Extension","RequestOrchestration.action.dynamicValue.path":"string","RequestOrchestration.action.extension":"Extension","RequestOrchestration.action.goal":"Reference","RequestOrchestration.action.groupingBehavior":"code","RequestOrchestration.action.id":"System.String","RequestOrchestration.action.input":"BackboneElement","RequestOrchestration.action.input.extension":"Extension","RequestOrchestration.action.input.id":"System.String","RequestOrchestration.action.input.modifierExtension":"Extension","RequestOrchestration.action.input.relatedData":"id","RequestOrchestration.action.input.requirement":"DataRequirement","RequestOrchestration.action.input.title":"string","RequestOrchestration.action.linkId":"string","RequestOrchestration.action.location":"CodeableReference","RequestOrchestration.action.modifierExtension":"Extension","RequestOrchestration.action.output":"BackboneElement","RequestOrchestration.action.output.extension":"Extension","RequestOrchestration.action.output.id":"System.String","RequestOrchestration.action.output.modifierExtension":"Extension","RequestOrchestration.action.output.relatedData":"string","RequestOrchestration.action.output.requirement":"DataRequirement","RequestOrchestration.action.output.title":"string","RequestOrchestration.action.participant":"BackboneElement","RequestOrchestration.action.participant.actorCanonical":"canonical","RequestOrchestration.action.participant.actorReference":"Reference","RequestOrchestration.action.participant.extension":"Extension","RequestOrchestration.action.participant.function":"CodeableConcept","RequestOrchestration.action.participant.id":"System.String","RequestOrchestration.action.participant.modifierExtension":"Extension","RequestOrchestration.action.participant.role":"CodeableConcept","RequestOrchestration.action.participant.type":"code","RequestOrchestration.action.participant.typeCanonical":"canonical","RequestOrchestration.action.participant.typeReference":"Reference","RequestOrchestration.action.precheckBehavior":"code","RequestOrchestration.action.prefix":"string","RequestOrchestration.action.priority":"code","RequestOrchestration.action.relatedAction":"BackboneElement","RequestOrchestration.action.relatedAction.endRelationship":"code","RequestOrchestration.action.relatedAction.extension":"Extension","RequestOrchestration.action.relatedAction.id":"System.String","RequestOrchestration.action.relatedAction.modifierExtension":"Extension","RequestOrchestration.action.relatedAction.offsetDuration":"Duration","RequestOrchestration.action.relatedAction.offsetRange":"Range","RequestOrchestration.action.relatedAction.relationship":"code","RequestOrchestration.action.relatedAction.targetId":"id","RequestOrchestration.action.requiredBehavior":"code","RequestOrchestration.action.resource":"Reference","RequestOrchestration.action.selectionBehavior":"code","RequestOrchestration.action.textEquivalent":"markdown","RequestOrchestration.action.timingAge":"Age","RequestOrchestration.action.timingDateTime":"dateTime","RequestOrchestration.action.timingDuration":"Duration","RequestOrchestration.action.timingPeriod":"Period","RequestOrchestration.action.timingRange":"Range","RequestOrchestration.action.timingTiming":"Timing","RequestOrchestration.action.title":"string","RequestOrchestration.action.transform":"canonical","RequestOrchestration.action.type":"CodeableConcept","RequestOrchestration.author":"Reference","RequestOrchestration.authoredOn":"dateTime","RequestOrchestration.basedOn":"Reference","RequestOrchestration.code":"CodeableConcept","RequestOrchestration.contained":"Resource","RequestOrchestration.encounter":"Reference","RequestOrchestration.extension":"Extension","RequestOrchestration.goal":"Reference","RequestOrchestration.groupIdentifier":"Identifier","RequestOrchestration.id":"System.String","RequestOrchestration.identifier":"Identifier","RequestOrchestration.implicitRules":"uri","RequestOrchestration.instantiatesCanonical":"canonical","RequestOrchestration.instantiatesUri":"uri","RequestOrchestration.intent":"code","RequestOrchestration.language":"code","RequestOrchestration.meta":"Meta","RequestOrchestration.modifierExtension":"Extension","RequestOrchestration.note":"Annotation","RequestOrchestration.priority":"code","RequestOrchestration.reason":"CodeableReference","RequestOrchestration.replaces":"Reference","RequestOrchestration.status":"code","RequestOrchestration.subject":"Reference","RequestOrchestration.text":"Narrative","Requirements.actor":"canonical","Requirements.contact":"ContactDetail","Requirements.contained":"Resource","Requirements.copyright":"markdown","Requirements.copyrightLabel":"string","Requirements.date":"dateTime","Requirements.derivedFrom":"canonical","Requirements.description":"markdown","Requirements.experimental":"boolean","Requirements.extension":"Extension","Requirements.id":"System.String","Requirements.identifier":"Identifier","Requirements.implicitRules":"uri","Requirements.jurisdiction":"CodeableConcept","Requirements.language":"code","Requirements.meta":"Meta","Requirements.modifierExtension":"Extension","Requirements.name":"string","Requirements.publisher":"string","Requirements.purpose":"markdown","Requirements.reference":"url","Requirements.statement":"BackboneElement","Requirements.statement.conditionality":"boolean","Requirements.statement.conformance":"code","Requirements.statement.derivedFrom":"string","Requirements.statement.extension":"Extension","Requirements.statement.id":"System.String","Requirements.statement.key":"id","Requirements.statement.label":"string","Requirements.statement.modifierExtension":"Extension","Requirements.statement.parent":"string","Requirements.statement.reference":"url","Requirements.statement.requirement":"markdown","Requirements.statement.satisfiedBy":"url","Requirements.statement.source":"Reference","Requirements.status":"code","Requirements.text":"Narrative","Requirements.title":"string","Requirements.url":"uri","Requirements.useContext":"UsageContext","Requirements.version":"string","Requirements.versionAlgorithmCoding":"Coding","Requirements.versionAlgorithmString":"string","ResearchStudy.associatedParty":"BackboneElement","ResearchStudy.associatedParty.classifier":"CodeableConcept","ResearchStudy.associatedParty.extension":"Extension","ResearchStudy.associatedParty.id":"System.String","ResearchStudy.associatedParty.modifierExtension":"Extension","ResearchStudy.associatedParty.name":"string","ResearchStudy.associatedParty.party":"Reference","ResearchStudy.associatedParty.period":"Period","ResearchStudy.associatedParty.role":"CodeableConcept","ResearchStudy.classifier":"CodeableConcept","ResearchStudy.comparisonGroup":"BackboneElement","ResearchStudy.comparisonGroup.description":"markdown","ResearchStudy.comparisonGroup.extension":"Extension","ResearchStudy.comparisonGroup.id":"System.String","ResearchStudy.comparisonGroup.intendedExposure":"Reference","ResearchStudy.comparisonGroup.linkId":"id","ResearchStudy.comparisonGroup.modifierExtension":"Extension","ResearchStudy.comparisonGroup.name":"string","ResearchStudy.comparisonGroup.observedGroup":"Reference","ResearchStudy.comparisonGroup.type":"CodeableConcept","ResearchStudy.condition":"CodeableConcept","ResearchStudy.contained":"Resource","ResearchStudy.date":"dateTime","ResearchStudy.description":"markdown","ResearchStudy.descriptionSummary":"markdown","ResearchStudy.extension":"Extension","ResearchStudy.focus":"CodeableReference","ResearchStudy.id":"System.String","ResearchStudy.identifier":"Identifier","ResearchStudy.implicitRules":"uri","ResearchStudy.keyword":"CodeableConcept","ResearchStudy.label":"BackboneElement","ResearchStudy.label.extension":"Extension","ResearchStudy.label.id":"System.String","ResearchStudy.label.modifierExtension":"Extension","ResearchStudy.label.type":"CodeableConcept","ResearchStudy.label.value":"string","ResearchStudy.language":"code","ResearchStudy.meta":"Meta","ResearchStudy.modifierExtension":"Extension","ResearchStudy.name":"string","ResearchStudy.note":"Annotation","ResearchStudy.objective":"BackboneElement","ResearchStudy.objective.description":"markdown","ResearchStudy.objective.extension":"Extension","ResearchStudy.objective.id":"System.String","ResearchStudy.objective.modifierExtension":"Extension","ResearchStudy.objective.name":"string","ResearchStudy.objective.type":"CodeableConcept","ResearchStudy.outcomeMeasure":"BackboneElement","ResearchStudy.outcomeMeasure.description":"markdown","ResearchStudy.outcomeMeasure.extension":"Extension","ResearchStudy.outcomeMeasure.id":"System.String","ResearchStudy.outcomeMeasure.modifierExtension":"Extension","ResearchStudy.outcomeMeasure.name":"string","ResearchStudy.outcomeMeasure.reference":"Reference","ResearchStudy.outcomeMeasure.type":"CodeableConcept","ResearchStudy.partOf":"Reference","ResearchStudy.period":"Period","ResearchStudy.phase":"CodeableConcept","ResearchStudy.primaryPurposeType":"CodeableConcept","ResearchStudy.progressStatus":"BackboneElement","ResearchStudy.progressStatus.actual":"boolean","ResearchStudy.progressStatus.extension":"Extension","ResearchStudy.progressStatus.id":"System.String","ResearchStudy.progressStatus.modifierExtension":"Extension","ResearchStudy.progressStatus.period":"Period","ResearchStudy.progressStatus.state":"CodeableConcept","ResearchStudy.protocol":"Reference","ResearchStudy.recruitment":"BackboneElement","ResearchStudy.recruitment.actualGroup":"Reference","ResearchStudy.recruitment.actualNumber":"unsignedInt","ResearchStudy.recruitment.eligibility":"Reference","ResearchStudy.recruitment.extension":"Extension","ResearchStudy.recruitment.id":"System.String","ResearchStudy.recruitment.modifierExtension":"Extension","ResearchStudy.recruitment.targetNumber":"unsignedInt","ResearchStudy.region":"CodeableConcept","ResearchStudy.relatedArtifact":"RelatedArtifact","ResearchStudy.result":"Reference","ResearchStudy.site":"Reference","ResearchStudy.status":"code","ResearchStudy.studyDesign":"CodeableConcept","ResearchStudy.text":"Narrative","ResearchStudy.title":"string","ResearchStudy.url":"uri","ResearchStudy.version":"string","ResearchStudy.whyStopped":"CodeableConcept","ResearchSubject.actualComparisonGroup":"id","ResearchSubject.assignedComparisonGroup":"id","ResearchSubject.consent":"Reference","ResearchSubject.contained":"Resource","ResearchSubject.extension":"Extension","ResearchSubject.id":"System.String","ResearchSubject.identifier":"Identifier","ResearchSubject.implicitRules":"uri","ResearchSubject.language":"code","ResearchSubject.meta":"Meta","ResearchSubject.modifierExtension":"Extension","ResearchSubject.period":"Period","ResearchSubject.progress":"BackboneElement","ResearchSubject.progress.endDate":"dateTime","ResearchSubject.progress.extension":"Extension","ResearchSubject.progress.id":"System.String","ResearchSubject.progress.milestone":"CodeableConcept","ResearchSubject.progress.modifierExtension":"Extension","ResearchSubject.progress.reason":"CodeableConcept","ResearchSubject.progress.startDate":"dateTime","ResearchSubject.progress.subjectState":"CodeableConcept","ResearchSubject.progress.type":"CodeableConcept","ResearchSubject.status":"code","ResearchSubject.study":"Reference","ResearchSubject.subject":"Reference","ResearchSubject.text":"Narrative","Resource.id":"System.String","Resource.implicitRules":"uri","Resource.language":"code","Resource.meta":"Meta","RiskAssessment.basedOn":"Reference","RiskAssessment.basis":"Reference","RiskAssessment.code":"CodeableConcept","RiskAssessment.condition":"Reference","RiskAssessment.contained":"Resource","RiskAssessment.encounter":"Reference","RiskAssessment.extension":"Extension","RiskAssessment.id":"System.String","RiskAssessment.identifier":"Identifier","RiskAssessment.implicitRules":"uri","RiskAssessment.language":"code","RiskAssessment.meta":"Meta","RiskAssessment.method":"CodeableConcept","RiskAssessment.mitigation":"string","RiskAssessment.modifierExtension":"Extension","RiskAssessment.note":"Annotation","RiskAssessment.occurrenceDateTime":"dateTime","RiskAssessment.occurrencePeriod":"Period","RiskAssessment.parent":"Reference","RiskAssessment.performer":"Reference","RiskAssessment.prediction":"BackboneElement","RiskAssessment.prediction.extension":"Extension","RiskAssessment.prediction.id":"System.String","RiskAssessment.prediction.modifierExtension":"Extension","RiskAssessment.prediction.outcome":"CodeableConcept","RiskAssessment.prediction.probabilityDecimal":"decimal","RiskAssessment.prediction.probabilityRange":"Range","RiskAssessment.prediction.qualitativeRisk":"CodeableConcept","RiskAssessment.prediction.rationale":"string","RiskAssessment.prediction.relativeRisk":"decimal","RiskAssessment.prediction.whenPeriod":"Period","RiskAssessment.prediction.whenRange":"Range","RiskAssessment.reason":"CodeableReference","RiskAssessment.status":"code","RiskAssessment.subject":"Reference","RiskAssessment.text":"Narrative","SampledData.codeMap":"canonical","SampledData.data":"string","SampledData.dimensions":"positiveInt","SampledData.extension":"Extension","SampledData.factor":"decimal","SampledData.id":"System.String","SampledData.interval":"decimal","SampledData.intervalUnit":"code","SampledData.lowerLimit":"decimal","SampledData.offsets":"string","SampledData.origin":"Quantity","SampledData.upperLimit":"decimal","Schedule.active":"boolean","Schedule.actor":"Reference","Schedule.comment":"markdown","Schedule.contained":"Resource","Schedule.extension":"Extension","Schedule.id":"System.String","Schedule.identifier":"Identifier","Schedule.implicitRules":"uri","Schedule.language":"code","Schedule.meta":"Meta","Schedule.modifierExtension":"Extension","Schedule.name":"string","Schedule.planningHorizon":"Period","Schedule.serviceCategory":"CodeableConcept","Schedule.serviceType":"CodeableReference","Schedule.specialty":"CodeableConcept","Schedule.text":"Narrative","SearchParameter.base":"code","SearchParameter.chain":"string","SearchParameter.code":"code","SearchParameter.comparator":"code","SearchParameter.component":"BackboneElement","SearchParameter.component.definition":"canonical","SearchParameter.component.expression":"string","SearchParameter.component.extension":"Extension","SearchParameter.component.id":"System.String","SearchParameter.component.modifierExtension":"Extension","SearchParameter.constraint":"string","SearchParameter.contact":"ContactDetail","SearchParameter.contained":"Resource","SearchParameter.copyright":"markdown","SearchParameter.copyrightLabel":"string","SearchParameter.date":"dateTime","SearchParameter.derivedFrom":"canonical","SearchParameter.description":"markdown","SearchParameter.experimental":"boolean","SearchParameter.expression":"string","SearchParameter.extension":"Extension","SearchParameter.id":"System.String","SearchParameter.identifier":"Identifier","SearchParameter.implicitRules":"uri","SearchParameter.jurisdiction":"CodeableConcept","SearchParameter.language":"code","SearchParameter.meta":"Meta","SearchParameter.modifier":"code","SearchParameter.modifierExtension":"Extension","SearchParameter.multipleAnd":"boolean","SearchParameter.multipleOr":"boolean","SearchParameter.name":"string","SearchParameter.processingMode":"code","SearchParameter.publisher":"string","SearchParameter.purpose":"markdown","SearchParameter.status":"code","SearchParameter.target":"code","SearchParameter.text":"Narrative","SearchParameter.title":"string","SearchParameter.type":"code","SearchParameter.url":"uri","SearchParameter.useContext":"UsageContext","SearchParameter.version":"string","SearchParameter.versionAlgorithmCoding":"Coding","SearchParameter.versionAlgorithmString":"string","ServiceRequest.asNeededBoolean":"boolean","ServiceRequest.asNeededCodeableConcept":"CodeableConcept","ServiceRequest.authoredOn":"dateTime","ServiceRequest.basedOn":"Reference","ServiceRequest.bodySite":"CodeableConcept","ServiceRequest.bodyStructure":"Reference","ServiceRequest.category":"CodeableConcept","ServiceRequest.code":"CodeableReference","ServiceRequest.contained":"Resource","ServiceRequest.doNotPerform":"boolean","ServiceRequest.encounter":"Reference","ServiceRequest.extension":"Extension","ServiceRequest.focus":"Reference","ServiceRequest.id":"System.String","ServiceRequest.identifier":"Identifier","ServiceRequest.implicitRules":"uri","ServiceRequest.instantiatesCanonical":"canonical","ServiceRequest.instantiatesUri":"uri","ServiceRequest.insurance":"Reference","ServiceRequest.intent":"code","ServiceRequest.language":"code","ServiceRequest.location":"CodeableReference","ServiceRequest.meta":"Meta","ServiceRequest.modifierExtension":"Extension","ServiceRequest.note":"Annotation","ServiceRequest.occurrenceDateTime":"dateTime","ServiceRequest.occurrencePeriod":"Period","ServiceRequest.occurrenceTiming":"Timing","ServiceRequest.orderDetail":"BackboneElement","ServiceRequest.orderDetail.extension":"Extension","ServiceRequest.orderDetail.id":"System.String","ServiceRequest.orderDetail.modifierExtension":"Extension","ServiceRequest.orderDetail.parameter":"BackboneElement","ServiceRequest.orderDetail.parameter.code":"CodeableConcept","ServiceRequest.orderDetail.parameter.extension":"Extension","ServiceRequest.orderDetail.parameter.id":"System.String","ServiceRequest.orderDetail.parameter.modifierExtension":"Extension","ServiceRequest.orderDetail.parameter.valueBoolean":"boolean","ServiceRequest.orderDetail.parameter.valueCodeableConcept":"CodeableConcept","ServiceRequest.orderDetail.parameter.valuePeriod":"Period","ServiceRequest.orderDetail.parameter.valueQuantity":"Quantity","ServiceRequest.orderDetail.parameter.valueRange":"Range","ServiceRequest.orderDetail.parameter.valueRatio":"Ratio","ServiceRequest.orderDetail.parameter.valueString":"string","ServiceRequest.orderDetail.parameterFocus":"CodeableReference","ServiceRequest.patientInstruction":"BackboneElement","ServiceRequest.patientInstruction.extension":"Extension","ServiceRequest.patientInstruction.id":"System.String","ServiceRequest.patientInstruction.instructionMarkdown":"markdown","ServiceRequest.patientInstruction.instructionReference":"Reference","ServiceRequest.patientInstruction.modifierExtension":"Extension","ServiceRequest.performer":"Reference","ServiceRequest.performerType":"CodeableConcept","ServiceRequest.priority":"code","ServiceRequest.quantityQuantity":"Quantity","ServiceRequest.quantityRange":"Range","ServiceRequest.quantityRatio":"Ratio","ServiceRequest.reason":"CodeableReference","ServiceRequest.relevantHistory":"Reference","ServiceRequest.replaces":"Reference","ServiceRequest.requester":"Reference","ServiceRequest.requisition":"Identifier","ServiceRequest.specimen":"Reference","ServiceRequest.status":"code","ServiceRequest.subject":"Reference","ServiceRequest.supportingInfo":"CodeableReference","ServiceRequest.text":"Narrative","Signature.data":"base64Binary","Signature.extension":"Extension","Signature.id":"System.String","Signature.onBehalfOf":"Reference","Signature.sigFormat":"code","Signature.targetFormat":"code","Signature.type":"Coding","Signature.when":"instant","Signature.who":"Reference","Slot.appointmentType":"CodeableConcept","Slot.comment":"string","Slot.contained":"Resource","Slot.end":"instant","Slot.extension":"Extension","Slot.id":"System.String","Slot.identifier":"Identifier","Slot.implicitRules":"uri","Slot.language":"code","Slot.meta":"Meta","Slot.modifierExtension":"Extension","Slot.overbooked":"boolean","Slot.schedule":"Reference","Slot.serviceCategory":"CodeableConcept","Slot.serviceType":"CodeableReference","Slot.specialty":"CodeableConcept","Slot.start":"instant","Slot.status":"code","Slot.text":"Narrative","Specimen.accessionIdentifier":"Identifier","Specimen.collection":"BackboneElement","Specimen.collection.bodySite":"CodeableReference","Specimen.collection.collectedDateTime":"dateTime","Specimen.collection.collectedPeriod":"Period","Specimen.collection.collector":"Reference","Specimen.collection.device":"CodeableReference","Specimen.collection.duration":"Duration","Specimen.collection.extension":"Extension","Specimen.collection.fastingStatusCodeableConcept":"CodeableConcept","Specimen.collection.fastingStatusDuration":"Duration","Specimen.collection.id":"System.String","Specimen.collection.method":"CodeableConcept","Specimen.collection.modifierExtension":"Extension","Specimen.collection.procedure":"Reference","Specimen.collection.quantity":"Quantity","Specimen.combined":"code","Specimen.condition":"CodeableConcept","Specimen.contained":"Resource","Specimen.container":"BackboneElement","Specimen.container.device":"Reference","Specimen.container.extension":"Extension","Specimen.container.id":"System.String","Specimen.container.location":"Reference","Specimen.container.modifierExtension":"Extension","Specimen.container.specimenQuantity":"Quantity","Specimen.extension":"Extension","Specimen.feature":"BackboneElement","Specimen.feature.description":"string","Specimen.feature.extension":"Extension","Specimen.feature.id":"System.String","Specimen.feature.modifierExtension":"Extension","Specimen.feature.type":"CodeableConcept","Specimen.id":"System.String","Specimen.identifier":"Identifier","Specimen.implicitRules":"uri","Specimen.language":"code","Specimen.meta":"Meta","Specimen.modifierExtension":"Extension","Specimen.note":"Annotation","Specimen.parent":"Reference","Specimen.processing":"BackboneElement","Specimen.processing.additive":"Reference","Specimen.processing.description":"string","Specimen.processing.extension":"Extension","Specimen.processing.id":"System.String","Specimen.processing.method":"CodeableConcept","Specimen.processing.modifierExtension":"Extension","Specimen.processing.timeDateTime":"dateTime","Specimen.processing.timePeriod":"Period","Specimen.receivedTime":"dateTime","Specimen.request":"Reference","Specimen.role":"CodeableConcept","Specimen.status":"code","Specimen.subject":"Reference","Specimen.text":"Narrative","Specimen.type":"CodeableConcept","SpecimenDefinition.approvalDate":"date","SpecimenDefinition.collection":"CodeableConcept","SpecimenDefinition.contact":"ContactDetail","SpecimenDefinition.contained":"Resource","SpecimenDefinition.copyright":"markdown","SpecimenDefinition.copyrightLabel":"string","SpecimenDefinition.date":"dateTime","SpecimenDefinition.derivedFromCanonical":"canonical","SpecimenDefinition.derivedFromUri":"uri","SpecimenDefinition.description":"markdown","SpecimenDefinition.effectivePeriod":"Period","SpecimenDefinition.experimental":"boolean","SpecimenDefinition.extension":"Extension","SpecimenDefinition.id":"System.String","SpecimenDefinition.identifier":"Identifier","SpecimenDefinition.implicitRules":"uri","SpecimenDefinition.jurisdiction":"CodeableConcept","SpecimenDefinition.language":"code","SpecimenDefinition.lastReviewDate":"date","SpecimenDefinition.meta":"Meta","SpecimenDefinition.modifierExtension":"Extension","SpecimenDefinition.name":"string","SpecimenDefinition.patientPreparation":"CodeableConcept","SpecimenDefinition.publisher":"string","SpecimenDefinition.purpose":"markdown","SpecimenDefinition.status":"code","SpecimenDefinition.subjectCodeableConcept":"CodeableConcept","SpecimenDefinition.subjectReference":"Reference","SpecimenDefinition.text":"Narrative","SpecimenDefinition.timeAspect":"string","SpecimenDefinition.title":"string","SpecimenDefinition.typeCollected":"CodeableConcept","SpecimenDefinition.typeTested":"BackboneElement","SpecimenDefinition.typeTested.container":"BackboneElement","SpecimenDefinition.typeTested.container.additive":"BackboneElement","SpecimenDefinition.typeTested.container.additive.additiveCodeableConcept":"CodeableConcept","SpecimenDefinition.typeTested.container.additive.additiveReference":"Reference","SpecimenDefinition.typeTested.container.additive.extension":"Extension","SpecimenDefinition.typeTested.container.additive.id":"System.String","SpecimenDefinition.typeTested.container.additive.modifierExtension":"Extension","SpecimenDefinition.typeTested.container.cap":"CodeableConcept","SpecimenDefinition.typeTested.container.capacity":"Quantity","SpecimenDefinition.typeTested.container.description":"markdown","SpecimenDefinition.typeTested.container.extension":"Extension","SpecimenDefinition.typeTested.container.id":"System.String","SpecimenDefinition.typeTested.container.material":"CodeableConcept","SpecimenDefinition.typeTested.container.minimumVolumeQuantity":"Quantity","SpecimenDefinition.typeTested.container.minimumVolumeString":"string","SpecimenDefinition.typeTested.container.modifierExtension":"Extension","SpecimenDefinition.typeTested.container.preparation":"markdown","SpecimenDefinition.typeTested.container.type":"CodeableConcept","SpecimenDefinition.typeTested.extension":"Extension","SpecimenDefinition.typeTested.handling":"BackboneElement","SpecimenDefinition.typeTested.handling.extension":"Extension","SpecimenDefinition.typeTested.handling.id":"System.String","SpecimenDefinition.typeTested.handling.instruction":"markdown","SpecimenDefinition.typeTested.handling.maxDuration":"Duration","SpecimenDefinition.typeTested.handling.modifierExtension":"Extension","SpecimenDefinition.typeTested.handling.temperatureQualifier":"CodeableConcept","SpecimenDefinition.typeTested.handling.temperatureRange":"Range","SpecimenDefinition.typeTested.id":"System.String","SpecimenDefinition.typeTested.isDerived":"boolean","SpecimenDefinition.typeTested.modifierExtension":"Extension","SpecimenDefinition.typeTested.preference":"code","SpecimenDefinition.typeTested.rejectionCriterion":"CodeableConcept","SpecimenDefinition.typeTested.requirement":"markdown","SpecimenDefinition.typeTested.retentionTime":"Duration","SpecimenDefinition.typeTested.singleUse":"boolean","SpecimenDefinition.typeTested.testingDestination":"CodeableConcept","SpecimenDefinition.typeTested.type":"CodeableConcept","SpecimenDefinition.url":"uri","SpecimenDefinition.useContext":"UsageContext","SpecimenDefinition.version":"string","SpecimenDefinition.versionAlgorithmCoding":"Coding","SpecimenDefinition.versionAlgorithmString":"string","StructureDefinition.abstract":"boolean","StructureDefinition.baseDefinition":"canonical","StructureDefinition.contact":"ContactDetail","StructureDefinition.contained":"Resource","StructureDefinition.context":"BackboneElement","StructureDefinition.context.expression":"string","StructureDefinition.context.extension":"Extension","StructureDefinition.context.id":"System.String","StructureDefinition.context.modifierExtension":"Extension","StructureDefinition.context.type":"code","StructureDefinition.contextInvariant":"string","StructureDefinition.copyright":"markdown","StructureDefinition.copyrightLabel":"string","StructureDefinition.date":"dateTime","StructureDefinition.derivation":"code","StructureDefinition.description":"markdown","StructureDefinition.differential":"BackboneElement","StructureDefinition.differential.element":"ElementDefinition","StructureDefinition.differential.extension":"Extension","StructureDefinition.differential.id":"System.String","StructureDefinition.differential.modifierExtension":"Extension","StructureDefinition.experimental":"boolean","StructureDefinition.extension":"Extension","StructureDefinition.fhirVersion":"code","StructureDefinition.id":"System.String","StructureDefinition.identifier":"Identifier","StructureDefinition.implicitRules":"uri","StructureDefinition.jurisdiction":"CodeableConcept","StructureDefinition.keyword":"Coding","StructureDefinition.kind":"code","StructureDefinition.language":"code","StructureDefinition.mapping":"BackboneElement","StructureDefinition.mapping.comment":"string","StructureDefinition.mapping.extension":"Extension","StructureDefinition.mapping.id":"System.String","StructureDefinition.mapping.identity":"id","StructureDefinition.mapping.modifierExtension":"Extension","StructureDefinition.mapping.name":"string","StructureDefinition.mapping.uri":"uri","StructureDefinition.meta":"Meta","StructureDefinition.modifierExtension":"Extension","StructureDefinition.name":"string","StructureDefinition.publisher":"string","StructureDefinition.purpose":"markdown","StructureDefinition.snapshot":"BackboneElement","StructureDefinition.snapshot.element":"ElementDefinition","StructureDefinition.snapshot.extension":"Extension","StructureDefinition.snapshot.id":"System.String","StructureDefinition.snapshot.modifierExtension":"Extension","StructureDefinition.status":"code","StructureDefinition.text":"Narrative","StructureDefinition.title":"string","StructureDefinition.type":"uri","StructureDefinition.url":"uri","StructureDefinition.useContext":"UsageContext","StructureDefinition.version":"string","StructureDefinition.versionAlgorithmCoding":"Coding","StructureDefinition.versionAlgorithmString":"string","StructureMap.const":"BackboneElement","StructureMap.const.extension":"Extension","StructureMap.const.id":"System.String","StructureMap.const.modifierExtension":"Extension","StructureMap.const.name":"id","StructureMap.const.value":"string","StructureMap.contact":"ContactDetail","StructureMap.contained":"Resource","StructureMap.copyright":"markdown","StructureMap.copyrightLabel":"string","StructureMap.date":"dateTime","StructureMap.description":"markdown","StructureMap.experimental":"boolean","StructureMap.extension":"Extension","StructureMap.group":"BackboneElement","StructureMap.group.documentation":"string","StructureMap.group.extends":"id","StructureMap.group.extension":"Extension","StructureMap.group.id":"System.String","StructureMap.group.input":"BackboneElement","StructureMap.group.input.documentation":"string","StructureMap.group.input.extension":"Extension","StructureMap.group.input.id":"System.String","StructureMap.group.input.mode":"code","StructureMap.group.input.modifierExtension":"Extension","StructureMap.group.input.name":"id","StructureMap.group.input.type":"string","StructureMap.group.modifierExtension":"Extension","StructureMap.group.name":"id","StructureMap.group.rule":"BackboneElement","StructureMap.group.rule.dependent":"BackboneElement","StructureMap.group.rule.dependent.extension":"Extension","StructureMap.group.rule.dependent.id":"System.String","StructureMap.group.rule.dependent.modifierExtension":"Extension","StructureMap.group.rule.dependent.name":"id","StructureMap.group.rule.documentation":"string","StructureMap.group.rule.extension":"Extension","StructureMap.group.rule.id":"System.String","StructureMap.group.rule.modifierExtension":"Extension","StructureMap.group.rule.name":"id","StructureMap.group.rule.source":"BackboneElement","StructureMap.group.rule.source.check":"string","StructureMap.group.rule.source.condition":"string","StructureMap.group.rule.source.context":"id","StructureMap.group.rule.source.defaultValue":"string","StructureMap.group.rule.source.element":"string","StructureMap.group.rule.source.extension":"Extension","StructureMap.group.rule.source.id":"System.String","StructureMap.group.rule.source.listMode":"code","StructureMap.group.rule.source.logMessage":"string","StructureMap.group.rule.source.max":"string","StructureMap.group.rule.source.min":"integer","StructureMap.group.rule.source.modifierExtension":"Extension","StructureMap.group.rule.source.type":"string","StructureMap.group.rule.source.variable":"id","StructureMap.group.rule.target":"BackboneElement","StructureMap.group.rule.target.context":"string","StructureMap.group.rule.target.element":"string","StructureMap.group.rule.target.extension":"Extension","StructureMap.group.rule.target.id":"System.String","StructureMap.group.rule.target.listMode":"code","StructureMap.group.rule.target.listRuleId":"id","StructureMap.group.rule.target.modifierExtension":"Extension","StructureMap.group.rule.target.parameter":"BackboneElement","StructureMap.group.rule.target.parameter.extension":"Extension","StructureMap.group.rule.target.parameter.id":"System.String","StructureMap.group.rule.target.parameter.modifierExtension":"Extension","StructureMap.group.rule.target.parameter.valueBoolean":"boolean","StructureMap.group.rule.target.parameter.valueDate":"date","StructureMap.group.rule.target.parameter.valueDateTime":"dateTime","StructureMap.group.rule.target.parameter.valueDecimal":"decimal","StructureMap.group.rule.target.parameter.valueId":"id","StructureMap.group.rule.target.parameter.valueInteger":"integer","StructureMap.group.rule.target.parameter.valueString":"string","StructureMap.group.rule.target.parameter.valueTime":"time","StructureMap.group.rule.target.transform":"code","StructureMap.group.rule.target.variable":"id","StructureMap.group.typeMode":"code","StructureMap.id":"System.String","StructureMap.identifier":"Identifier","StructureMap.implicitRules":"uri","StructureMap.import":"canonical","StructureMap.jurisdiction":"CodeableConcept","StructureMap.language":"code","StructureMap.meta":"Meta","StructureMap.modifierExtension":"Extension","StructureMap.name":"string","StructureMap.publisher":"string","StructureMap.purpose":"markdown","StructureMap.status":"code","StructureMap.structure":"BackboneElement","StructureMap.structure.alias":"string","StructureMap.structure.documentation":"string","StructureMap.structure.extension":"Extension","StructureMap.structure.id":"System.String","StructureMap.structure.mode":"code","StructureMap.structure.modifierExtension":"Extension","StructureMap.structure.url":"canonical","StructureMap.text":"Narrative","StructureMap.title":"string","StructureMap.url":"uri","StructureMap.useContext":"UsageContext","StructureMap.version":"string","StructureMap.versionAlgorithmCoding":"Coding","StructureMap.versionAlgorithmString":"string","Subscription.channelType":"Coding","Subscription.contact":"ContactPoint","Subscription.contained":"Resource","Subscription.content":"code","Subscription.contentType":"code","Subscription.end":"instant","Subscription.endpoint":"url","Subscription.extension":"Extension","Subscription.filterBy":"BackboneElement","Subscription.filterBy.comparator":"code","Subscription.filterBy.extension":"Extension","Subscription.filterBy.filterParameter":"string","Subscription.filterBy.id":"System.String","Subscription.filterBy.modifier":"code","Subscription.filterBy.modifierExtension":"Extension","Subscription.filterBy.resourceType":"uri","Subscription.filterBy.value":"string","Subscription.heartbeatPeriod":"unsignedInt","Subscription.id":"System.String","Subscription.identifier":"Identifier","Subscription.implicitRules":"uri","Subscription.language":"code","Subscription.managingEntity":"Reference","Subscription.maxCount":"positiveInt","Subscription.meta":"Meta","Subscription.modifierExtension":"Extension","Subscription.name":"string","Subscription.parameter":"BackboneElement","Subscription.parameter.extension":"Extension","Subscription.parameter.id":"System.String","Subscription.parameter.modifierExtension":"Extension","Subscription.parameter.name":"string","Subscription.parameter.value":"string","Subscription.reason":"string","Subscription.status":"code","Subscription.text":"Narrative","Subscription.timeout":"unsignedInt","Subscription.topic":"canonical","SubscriptionStatus.contained":"Resource","SubscriptionStatus.error":"CodeableConcept","SubscriptionStatus.eventsSinceSubscriptionStart":"integer64","SubscriptionStatus.extension":"Extension","SubscriptionStatus.id":"System.String","SubscriptionStatus.implicitRules":"uri","SubscriptionStatus.language":"code","SubscriptionStatus.meta":"Meta","SubscriptionStatus.modifierExtension":"Extension","SubscriptionStatus.notificationEvent":"BackboneElement","SubscriptionStatus.notificationEvent.additionalContext":"Reference","SubscriptionStatus.notificationEvent.eventNumber":"integer64","SubscriptionStatus.notificationEvent.extension":"Extension","SubscriptionStatus.notificationEvent.focus":"Reference","SubscriptionStatus.notificationEvent.id":"System.String","SubscriptionStatus.notificationEvent.modifierExtension":"Extension","SubscriptionStatus.notificationEvent.timestamp":"instant","SubscriptionStatus.status":"code","SubscriptionStatus.subscription":"Reference","SubscriptionStatus.text":"Narrative","SubscriptionStatus.topic":"canonical","SubscriptionStatus.type":"code","SubscriptionTopic.approvalDate":"date","SubscriptionTopic.canFilterBy":"BackboneElement","SubscriptionTopic.canFilterBy.comparator":"code","SubscriptionTopic.canFilterBy.description":"markdown","SubscriptionTopic.canFilterBy.extension":"Extension","SubscriptionTopic.canFilterBy.filterDefinition":"uri","SubscriptionTopic.canFilterBy.filterParameter":"string","SubscriptionTopic.canFilterBy.id":"System.String","SubscriptionTopic.canFilterBy.modifier":"code","SubscriptionTopic.canFilterBy.modifierExtension":"Extension","SubscriptionTopic.canFilterBy.resource":"uri","SubscriptionTopic.contact":"ContactDetail","SubscriptionTopic.contained":"Resource","SubscriptionTopic.copyright":"markdown","SubscriptionTopic.copyrightLabel":"string","SubscriptionTopic.date":"dateTime","SubscriptionTopic.derivedFrom":"canonical","SubscriptionTopic.description":"markdown","SubscriptionTopic.effectivePeriod":"Period","SubscriptionTopic.eventTrigger":"BackboneElement","SubscriptionTopic.eventTrigger.description":"markdown","SubscriptionTopic.eventTrigger.event":"CodeableConcept","SubscriptionTopic.eventTrigger.extension":"Extension","SubscriptionTopic.eventTrigger.id":"System.String","SubscriptionTopic.eventTrigger.modifierExtension":"Extension","SubscriptionTopic.eventTrigger.resource":"uri","SubscriptionTopic.experimental":"boolean","SubscriptionTopic.extension":"Extension","SubscriptionTopic.id":"System.String","SubscriptionTopic.identifier":"Identifier","SubscriptionTopic.implicitRules":"uri","SubscriptionTopic.jurisdiction":"CodeableConcept","SubscriptionTopic.language":"code","SubscriptionTopic.lastReviewDate":"date","SubscriptionTopic.meta":"Meta","SubscriptionTopic.modifierExtension":"Extension","SubscriptionTopic.name":"string","SubscriptionTopic.notificationShape":"BackboneElement","SubscriptionTopic.notificationShape.extension":"Extension","SubscriptionTopic.notificationShape.id":"System.String","SubscriptionTopic.notificationShape.include":"string","SubscriptionTopic.notificationShape.modifierExtension":"Extension","SubscriptionTopic.notificationShape.resource":"uri","SubscriptionTopic.notificationShape.revInclude":"string","SubscriptionTopic.publisher":"string","SubscriptionTopic.purpose":"markdown","SubscriptionTopic.resourceTrigger":"BackboneElement","SubscriptionTopic.resourceTrigger.description":"markdown","SubscriptionTopic.resourceTrigger.extension":"Extension","SubscriptionTopic.resourceTrigger.fhirPathCriteria":"string","SubscriptionTopic.resourceTrigger.id":"System.String","SubscriptionTopic.resourceTrigger.modifierExtension":"Extension","SubscriptionTopic.resourceTrigger.queryCriteria":"BackboneElement","SubscriptionTopic.resourceTrigger.queryCriteria.current":"string","SubscriptionTopic.resourceTrigger.queryCriteria.extension":"Extension","SubscriptionTopic.resourceTrigger.queryCriteria.id":"System.String","SubscriptionTopic.resourceTrigger.queryCriteria.modifierExtension":"Extension","SubscriptionTopic.resourceTrigger.queryCriteria.previous":"string","SubscriptionTopic.resourceTrigger.queryCriteria.requireBoth":"boolean","SubscriptionTopic.resourceTrigger.queryCriteria.resultForCreate":"code","SubscriptionTopic.resourceTrigger.queryCriteria.resultForDelete":"code","SubscriptionTopic.resourceTrigger.resource":"uri","SubscriptionTopic.resourceTrigger.supportedInteraction":"code","SubscriptionTopic.status":"code","SubscriptionTopic.text":"Narrative","SubscriptionTopic.title":"string","SubscriptionTopic.url":"uri","SubscriptionTopic.useContext":"UsageContext","SubscriptionTopic.version":"string","SubscriptionTopic.versionAlgorithmCoding":"Coding","SubscriptionTopic.versionAlgorithmString":"string","Substance.category":"CodeableConcept","Substance.code":"CodeableReference","Substance.contained":"Resource","Substance.description":"markdown","Substance.expiry":"dateTime","Substance.extension":"Extension","Substance.id":"System.String","Substance.identifier":"Identifier","Substance.implicitRules":"uri","Substance.ingredient":"BackboneElement","Substance.ingredient.extension":"Extension","Substance.ingredient.id":"System.String","Substance.ingredient.modifierExtension":"Extension","Substance.ingredient.quantity":"Ratio","Substance.ingredient.substanceCodeableConcept":"CodeableConcept","Substance.ingredient.substanceReference":"Reference","Substance.instance":"boolean","Substance.language":"code","Substance.meta":"Meta","Substance.modifierExtension":"Extension","Substance.quantity":"Quantity","Substance.status":"code","Substance.text":"Narrative","SubstanceDefinition.characterization":"BackboneElement","SubstanceDefinition.characterization.description":"markdown","SubstanceDefinition.characterization.extension":"Extension","SubstanceDefinition.characterization.file":"Attachment","SubstanceDefinition.characterization.form":"CodeableConcept","SubstanceDefinition.characterization.id":"System.String","SubstanceDefinition.characterization.modifierExtension":"Extension","SubstanceDefinition.characterization.technique":"CodeableConcept","SubstanceDefinition.classification":"CodeableConcept","SubstanceDefinition.code":"BackboneElement","SubstanceDefinition.code.code":"CodeableConcept","SubstanceDefinition.code.extension":"Extension","SubstanceDefinition.code.id":"System.String","SubstanceDefinition.code.modifierExtension":"Extension","SubstanceDefinition.code.note":"Annotation","SubstanceDefinition.code.source":"Reference","SubstanceDefinition.code.status":"CodeableConcept","SubstanceDefinition.code.statusDate":"dateTime","SubstanceDefinition.contained":"Resource","SubstanceDefinition.description":"markdown","SubstanceDefinition.domain":"CodeableConcept","SubstanceDefinition.extension":"Extension","SubstanceDefinition.grade":"CodeableConcept","SubstanceDefinition.id":"System.String","SubstanceDefinition.identifier":"Identifier","SubstanceDefinition.implicitRules":"uri","SubstanceDefinition.informationSource":"Reference","SubstanceDefinition.language":"code","SubstanceDefinition.manufacturer":"Reference","SubstanceDefinition.meta":"Meta","SubstanceDefinition.modifierExtension":"Extension","SubstanceDefinition.moiety":"BackboneElement","SubstanceDefinition.moiety.amountQuantity":"Quantity","SubstanceDefinition.moiety.amountString":"string","SubstanceDefinition.moiety.extension":"Extension","SubstanceDefinition.moiety.id":"System.String","SubstanceDefinition.moiety.identifier":"Identifier","SubstanceDefinition.moiety.measurementType":"CodeableConcept","SubstanceDefinition.moiety.modifierExtension":"Extension","SubstanceDefinition.moiety.molecularFormula":"string","SubstanceDefinition.moiety.name":"string","SubstanceDefinition.moiety.opticalActivity":"CodeableConcept","SubstanceDefinition.moiety.role":"CodeableConcept","SubstanceDefinition.moiety.stereochemistry":"CodeableConcept","SubstanceDefinition.molecularWeight":"BackboneElement","SubstanceDefinition.molecularWeight.amount":"Quantity","SubstanceDefinition.molecularWeight.extension":"Extension","SubstanceDefinition.molecularWeight.id":"System.String","SubstanceDefinition.molecularWeight.method":"CodeableConcept","SubstanceDefinition.molecularWeight.modifierExtension":"Extension","SubstanceDefinition.molecularWeight.type":"CodeableConcept","SubstanceDefinition.name":"BackboneElement","SubstanceDefinition.name.domain":"CodeableConcept","SubstanceDefinition.name.extension":"Extension","SubstanceDefinition.name.id":"System.String","SubstanceDefinition.name.jurisdiction":"CodeableConcept","SubstanceDefinition.name.language":"CodeableConcept","SubstanceDefinition.name.modifierExtension":"Extension","SubstanceDefinition.name.name":"string","SubstanceDefinition.name.official":"BackboneElement","SubstanceDefinition.name.official.authority":"CodeableConcept","SubstanceDefinition.name.official.date":"dateTime","SubstanceDefinition.name.official.extension":"Extension","SubstanceDefinition.name.official.id":"System.String","SubstanceDefinition.name.official.modifierExtension":"Extension","SubstanceDefinition.name.official.status":"CodeableConcept","SubstanceDefinition.name.preferred":"boolean","SubstanceDefinition.name.source":"Reference","SubstanceDefinition.name.status":"CodeableConcept","SubstanceDefinition.name.type":"CodeableConcept","SubstanceDefinition.note":"Annotation","SubstanceDefinition.nucleicAcid":"Reference","SubstanceDefinition.polymer":"Reference","SubstanceDefinition.property":"BackboneElement","SubstanceDefinition.property.extension":"Extension","SubstanceDefinition.property.id":"System.String","SubstanceDefinition.property.modifierExtension":"Extension","SubstanceDefinition.property.type":"CodeableConcept","SubstanceDefinition.property.valueAttachment":"Attachment","SubstanceDefinition.property.valueBoolean":"boolean","SubstanceDefinition.property.valueCodeableConcept":"CodeableConcept","SubstanceDefinition.property.valueDate":"date","SubstanceDefinition.property.valueQuantity":"Quantity","SubstanceDefinition.protein":"Reference","SubstanceDefinition.referenceInformation":"Reference","SubstanceDefinition.relationship":"BackboneElement","SubstanceDefinition.relationship.amountQuantity":"Quantity","SubstanceDefinition.relationship.amountRatio":"Ratio","SubstanceDefinition.relationship.amountString":"string","SubstanceDefinition.relationship.comparator":"CodeableConcept","SubstanceDefinition.relationship.extension":"Extension","SubstanceDefinition.relationship.id":"System.String","SubstanceDefinition.relationship.isDefining":"boolean","SubstanceDefinition.relationship.modifierExtension":"Extension","SubstanceDefinition.relationship.ratioHighLimitAmount":"Ratio","SubstanceDefinition.relationship.source":"Reference","SubstanceDefinition.relationship.substanceDefinitionCodeableConcept":"CodeableConcept","SubstanceDefinition.relationship.substanceDefinitionReference":"Reference","SubstanceDefinition.relationship.type":"CodeableConcept","SubstanceDefinition.sourceMaterial":"BackboneElement","SubstanceDefinition.sourceMaterial.countryOfOrigin":"CodeableConcept","SubstanceDefinition.sourceMaterial.extension":"Extension","SubstanceDefinition.sourceMaterial.genus":"CodeableConcept","SubstanceDefinition.sourceMaterial.id":"System.String","SubstanceDefinition.sourceMaterial.modifierExtension":"Extension","SubstanceDefinition.sourceMaterial.part":"CodeableConcept","SubstanceDefinition.sourceMaterial.species":"CodeableConcept","SubstanceDefinition.sourceMaterial.type":"CodeableConcept","SubstanceDefinition.status":"CodeableConcept","SubstanceDefinition.structure":"BackboneElement","SubstanceDefinition.structure.extension":"Extension","SubstanceDefinition.structure.id":"System.String","SubstanceDefinition.structure.modifierExtension":"Extension","SubstanceDefinition.structure.molecularFormula":"string","SubstanceDefinition.structure.molecularFormulaByMoiety":"string","SubstanceDefinition.structure.opticalActivity":"CodeableConcept","SubstanceDefinition.structure.representation":"BackboneElement","SubstanceDefinition.structure.representation.document":"Reference","SubstanceDefinition.structure.representation.extension":"Extension","SubstanceDefinition.structure.representation.format":"CodeableConcept","SubstanceDefinition.structure.representation.id":"System.String","SubstanceDefinition.structure.representation.modifierExtension":"Extension","SubstanceDefinition.structure.representation.representation":"string","SubstanceDefinition.structure.representation.type":"CodeableConcept","SubstanceDefinition.structure.sourceDocument":"Reference","SubstanceDefinition.structure.stereochemistry":"CodeableConcept","SubstanceDefinition.structure.technique":"CodeableConcept","SubstanceDefinition.supplier":"Reference","SubstanceDefinition.text":"Narrative","SubstanceDefinition.version":"string","SubstanceNucleicAcid.areaOfHybridisation":"string","SubstanceNucleicAcid.contained":"Resource","SubstanceNucleicAcid.extension":"Extension","SubstanceNucleicAcid.id":"System.String","SubstanceNucleicAcid.implicitRules":"uri","SubstanceNucleicAcid.language":"code","SubstanceNucleicAcid.meta":"Meta","SubstanceNucleicAcid.modifierExtension":"Extension","SubstanceNucleicAcid.numberOfSubunits":"integer","SubstanceNucleicAcid.oligoNucleotideType":"CodeableConcept","SubstanceNucleicAcid.sequenceType":"CodeableConcept","SubstanceNucleicAcid.subunit":"BackboneElement","SubstanceNucleicAcid.subunit.extension":"Extension","SubstanceNucleicAcid.subunit.fivePrime":"CodeableConcept","SubstanceNucleicAcid.subunit.id":"System.String","SubstanceNucleicAcid.subunit.length":"integer","SubstanceNucleicAcid.subunit.linkage":"BackboneElement","SubstanceNucleicAcid.subunit.linkage.connectivity":"string","SubstanceNucleicAcid.subunit.linkage.extension":"Extension","SubstanceNucleicAcid.subunit.linkage.id":"System.String","SubstanceNucleicAcid.subunit.linkage.identifier":"Identifier","SubstanceNucleicAcid.subunit.linkage.modifierExtension":"Extension","SubstanceNucleicAcid.subunit.linkage.name":"string","SubstanceNucleicAcid.subunit.linkage.residueSite":"string","SubstanceNucleicAcid.subunit.modifierExtension":"Extension","SubstanceNucleicAcid.subunit.sequence":"string","SubstanceNucleicAcid.subunit.sequenceAttachment":"Attachment","SubstanceNucleicAcid.subunit.subunit":"integer","SubstanceNucleicAcid.subunit.sugar":"BackboneElement","SubstanceNucleicAcid.subunit.sugar.extension":"Extension","SubstanceNucleicAcid.subunit.sugar.id":"System.String","SubstanceNucleicAcid.subunit.sugar.identifier":"Identifier","SubstanceNucleicAcid.subunit.sugar.modifierExtension":"Extension","SubstanceNucleicAcid.subunit.sugar.name":"string","SubstanceNucleicAcid.subunit.sugar.residueSite":"string","SubstanceNucleicAcid.subunit.threePrime":"CodeableConcept","SubstanceNucleicAcid.text":"Narrative","SubstancePolymer.class":"CodeableConcept","SubstancePolymer.contained":"Resource","SubstancePolymer.copolymerConnectivity":"CodeableConcept","SubstancePolymer.extension":"Extension","SubstancePolymer.geometry":"CodeableConcept","SubstancePolymer.id":"System.String","SubstancePolymer.identifier":"Identifier","SubstancePolymer.implicitRules":"uri","SubstancePolymer.language":"code","SubstancePolymer.meta":"Meta","SubstancePolymer.modification":"string","SubstancePolymer.modifierExtension":"Extension","SubstancePolymer.monomerSet":"BackboneElement","SubstancePolymer.monomerSet.extension":"Extension","SubstancePolymer.monomerSet.id":"System.String","SubstancePolymer.monomerSet.modifierExtension":"Extension","SubstancePolymer.monomerSet.ratioType":"CodeableConcept","SubstancePolymer.monomerSet.startingMaterial":"BackboneElement","SubstancePolymer.monomerSet.startingMaterial.amount":"Quantity","SubstancePolymer.monomerSet.startingMaterial.category":"CodeableConcept","SubstancePolymer.monomerSet.startingMaterial.code":"CodeableConcept","SubstancePolymer.monomerSet.startingMaterial.extension":"Extension","SubstancePolymer.monomerSet.startingMaterial.id":"System.String","SubstancePolymer.monomerSet.startingMaterial.isDefining":"boolean","SubstancePolymer.monomerSet.startingMaterial.modifierExtension":"Extension","SubstancePolymer.repeat":"BackboneElement","SubstancePolymer.repeat.averageMolecularFormula":"string","SubstancePolymer.repeat.extension":"Extension","SubstancePolymer.repeat.id":"System.String","SubstancePolymer.repeat.modifierExtension":"Extension","SubstancePolymer.repeat.repeatUnit":"BackboneElement","SubstancePolymer.repeat.repeatUnit.amount":"integer","SubstancePolymer.repeat.repeatUnit.degreeOfPolymerisation":"BackboneElement","SubstancePolymer.repeat.repeatUnit.degreeOfPolymerisation.average":"integer","SubstancePolymer.repeat.repeatUnit.degreeOfPolymerisation.extension":"Extension","SubstancePolymer.repeat.repeatUnit.degreeOfPolymerisation.high":"integer","SubstancePolymer.repeat.repeatUnit.degreeOfPolymerisation.id":"System.String","SubstancePolymer.repeat.repeatUnit.degreeOfPolymerisation.low":"integer","SubstancePolymer.repeat.repeatUnit.degreeOfPolymerisation.modifierExtension":"Extension","SubstancePolymer.repeat.repeatUnit.degreeOfPolymerisation.type":"CodeableConcept","SubstancePolymer.repeat.repeatUnit.extension":"Extension","SubstancePolymer.repeat.repeatUnit.id":"System.String","SubstancePolymer.repeat.repeatUnit.modifierExtension":"Extension","SubstancePolymer.repeat.repeatUnit.orientation":"CodeableConcept","SubstancePolymer.repeat.repeatUnit.structuralRepresentation":"BackboneElement","SubstancePolymer.repeat.repeatUnit.structuralRepresentation.attachment":"Attachment","SubstancePolymer.repeat.repeatUnit.structuralRepresentation.extension":"Extension","SubstancePolymer.repeat.repeatUnit.structuralRepresentation.format":"CodeableConcept","SubstancePolymer.repeat.repeatUnit.structuralRepresentation.id":"System.String","SubstancePolymer.repeat.repeatUnit.structuralRepresentation.modifierExtension":"Extension","SubstancePolymer.repeat.repeatUnit.structuralRepresentation.representation":"string","SubstancePolymer.repeat.repeatUnit.structuralRepresentation.type":"CodeableConcept","SubstancePolymer.repeat.repeatUnit.unit":"string","SubstancePolymer.repeat.repeatUnitAmountType":"CodeableConcept","SubstancePolymer.text":"Narrative","SubstanceProtein.contained":"Resource","SubstanceProtein.disulfideLinkage":"string","SubstanceProtein.extension":"Extension","SubstanceProtein.id":"System.String","SubstanceProtein.implicitRules":"uri","SubstanceProtein.language":"code","SubstanceProtein.meta":"Meta","SubstanceProtein.modifierExtension":"Extension","SubstanceProtein.numberOfSubunits":"integer","SubstanceProtein.sequenceType":"CodeableConcept","SubstanceProtein.subunit":"BackboneElement","SubstanceProtein.subunit.cTerminalModification":"string","SubstanceProtein.subunit.cTerminalModificationId":"Identifier","SubstanceProtein.subunit.extension":"Extension","SubstanceProtein.subunit.id":"System.String","SubstanceProtein.subunit.length":"integer","SubstanceProtein.subunit.modifierExtension":"Extension","SubstanceProtein.subunit.nTerminalModification":"string","SubstanceProtein.subunit.nTerminalModificationId":"Identifier","SubstanceProtein.subunit.sequence":"string","SubstanceProtein.subunit.sequenceAttachment":"Attachment","SubstanceProtein.subunit.subunit":"integer","SubstanceProtein.text":"Narrative","SubstanceReferenceInformation.comment":"string","SubstanceReferenceInformation.contained":"Resource","SubstanceReferenceInformation.extension":"Extension","SubstanceReferenceInformation.gene":"BackboneElement","SubstanceReferenceInformation.gene.extension":"Extension","SubstanceReferenceInformation.gene.gene":"CodeableConcept","SubstanceReferenceInformation.gene.geneSequenceOrigin":"CodeableConcept","SubstanceReferenceInformation.gene.id":"System.String","SubstanceReferenceInformation.gene.modifierExtension":"Extension","SubstanceReferenceInformation.gene.source":"Reference","SubstanceReferenceInformation.geneElement":"BackboneElement","SubstanceReferenceInformation.geneElement.element":"Identifier","SubstanceReferenceInformation.geneElement.extension":"Extension","SubstanceReferenceInformation.geneElement.id":"System.String","SubstanceReferenceInformation.geneElement.modifierExtension":"Extension","SubstanceReferenceInformation.geneElement.source":"Reference","SubstanceReferenceInformation.geneElement.type":"CodeableConcept","SubstanceReferenceInformation.id":"System.String","SubstanceReferenceInformation.implicitRules":"uri","SubstanceReferenceInformation.language":"code","SubstanceReferenceInformation.meta":"Meta","SubstanceReferenceInformation.modifierExtension":"Extension","SubstanceReferenceInformation.target":"BackboneElement","SubstanceReferenceInformation.target.amountQuantity":"Quantity","SubstanceReferenceInformation.target.amountRange":"Range","SubstanceReferenceInformation.target.amountString":"string","SubstanceReferenceInformation.target.amountType":"CodeableConcept","SubstanceReferenceInformation.target.extension":"Extension","SubstanceReferenceInformation.target.id":"System.String","SubstanceReferenceInformation.target.interaction":"CodeableConcept","SubstanceReferenceInformation.target.modifierExtension":"Extension","SubstanceReferenceInformation.target.organism":"CodeableConcept","SubstanceReferenceInformation.target.organismType":"CodeableConcept","SubstanceReferenceInformation.target.source":"Reference","SubstanceReferenceInformation.target.target":"Identifier","SubstanceReferenceInformation.target.type":"CodeableConcept","SubstanceReferenceInformation.text":"Narrative","SubstanceSourceMaterial.contained":"Resource","SubstanceSourceMaterial.countryOfOrigin":"CodeableConcept","SubstanceSourceMaterial.developmentStage":"CodeableConcept","SubstanceSourceMaterial.extension":"Extension","SubstanceSourceMaterial.fractionDescription":"BackboneElement","SubstanceSourceMaterial.fractionDescription.extension":"Extension","SubstanceSourceMaterial.fractionDescription.fraction":"string","SubstanceSourceMaterial.fractionDescription.id":"System.String","SubstanceSourceMaterial.fractionDescription.materialType":"CodeableConcept","SubstanceSourceMaterial.fractionDescription.modifierExtension":"Extension","SubstanceSourceMaterial.geographicalLocation":"string","SubstanceSourceMaterial.id":"System.String","SubstanceSourceMaterial.implicitRules":"uri","SubstanceSourceMaterial.language":"code","SubstanceSourceMaterial.meta":"Meta","SubstanceSourceMaterial.modifierExtension":"Extension","SubstanceSourceMaterial.organism":"BackboneElement","SubstanceSourceMaterial.organism.author":"BackboneElement","SubstanceSourceMaterial.organism.author.authorDescription":"string","SubstanceSourceMaterial.organism.author.authorType":"CodeableConcept","SubstanceSourceMaterial.organism.author.extension":"Extension","SubstanceSourceMaterial.organism.author.id":"System.String","SubstanceSourceMaterial.organism.author.modifierExtension":"Extension","SubstanceSourceMaterial.organism.extension":"Extension","SubstanceSourceMaterial.organism.family":"CodeableConcept","SubstanceSourceMaterial.organism.genus":"CodeableConcept","SubstanceSourceMaterial.organism.hybrid":"BackboneElement","SubstanceSourceMaterial.organism.hybrid.extension":"Extension","SubstanceSourceMaterial.organism.hybrid.hybridType":"CodeableConcept","SubstanceSourceMaterial.organism.hybrid.id":"System.String","SubstanceSourceMaterial.organism.hybrid.maternalOrganismId":"string","SubstanceSourceMaterial.organism.hybrid.maternalOrganismName":"string","SubstanceSourceMaterial.organism.hybrid.modifierExtension":"Extension","SubstanceSourceMaterial.organism.hybrid.paternalOrganismId":"string","SubstanceSourceMaterial.organism.hybrid.paternalOrganismName":"string","SubstanceSourceMaterial.organism.id":"System.String","SubstanceSourceMaterial.organism.intraspecificDescription":"string","SubstanceSourceMaterial.organism.intraspecificType":"CodeableConcept","SubstanceSourceMaterial.organism.modifierExtension":"Extension","SubstanceSourceMaterial.organism.organismGeneral":"BackboneElement","SubstanceSourceMaterial.organism.organismGeneral.class":"CodeableConcept","SubstanceSourceMaterial.organism.organismGeneral.extension":"Extension","SubstanceSourceMaterial.organism.organismGeneral.id":"System.String","SubstanceSourceMaterial.organism.organismGeneral.kingdom":"CodeableConcept","SubstanceSourceMaterial.organism.organismGeneral.modifierExtension":"Extension","SubstanceSourceMaterial.organism.organismGeneral.order":"CodeableConcept","SubstanceSourceMaterial.organism.organismGeneral.phylum":"CodeableConcept","SubstanceSourceMaterial.organism.species":"CodeableConcept","SubstanceSourceMaterial.organismId":"Identifier","SubstanceSourceMaterial.organismName":"string","SubstanceSourceMaterial.parentSubstanceId":"Identifier","SubstanceSourceMaterial.parentSubstanceName":"string","SubstanceSourceMaterial.partDescription":"BackboneElement","SubstanceSourceMaterial.partDescription.extension":"Extension","SubstanceSourceMaterial.partDescription.id":"System.String","SubstanceSourceMaterial.partDescription.modifierExtension":"Extension","SubstanceSourceMaterial.partDescription.part":"CodeableConcept","SubstanceSourceMaterial.partDescription.partLocation":"CodeableConcept","SubstanceSourceMaterial.sourceMaterialClass":"CodeableConcept","SubstanceSourceMaterial.sourceMaterialState":"CodeableConcept","SubstanceSourceMaterial.sourceMaterialType":"CodeableConcept","SubstanceSourceMaterial.text":"Narrative","SupplyDelivery.basedOn":"Reference","SupplyDelivery.contained":"Resource","SupplyDelivery.destination":"Reference","SupplyDelivery.extension":"Extension","SupplyDelivery.id":"System.String","SupplyDelivery.identifier":"Identifier","SupplyDelivery.implicitRules":"uri","SupplyDelivery.language":"code","SupplyDelivery.meta":"Meta","SupplyDelivery.modifierExtension":"Extension","SupplyDelivery.occurrenceDateTime":"dateTime","SupplyDelivery.occurrencePeriod":"Period","SupplyDelivery.occurrenceTiming":"Timing","SupplyDelivery.partOf":"Reference","SupplyDelivery.patient":"Reference","SupplyDelivery.receiver":"Reference","SupplyDelivery.status":"code","SupplyDelivery.suppliedItem":"BackboneElement","SupplyDelivery.suppliedItem.extension":"Extension","SupplyDelivery.suppliedItem.id":"System.String","SupplyDelivery.suppliedItem.itemCodeableConcept":"CodeableConcept","SupplyDelivery.suppliedItem.itemReference":"Reference","SupplyDelivery.suppliedItem.modifierExtension":"Extension","SupplyDelivery.suppliedItem.quantity":"Quantity","SupplyDelivery.supplier":"Reference","SupplyDelivery.text":"Narrative","SupplyDelivery.type":"CodeableConcept","SupplyRequest.authoredOn":"dateTime","SupplyRequest.basedOn":"Reference","SupplyRequest.category":"CodeableConcept","SupplyRequest.contained":"Resource","SupplyRequest.deliverFor":"Reference","SupplyRequest.deliverFrom":"Reference","SupplyRequest.deliverTo":"Reference","SupplyRequest.extension":"Extension","SupplyRequest.id":"System.String","SupplyRequest.identifier":"Identifier","SupplyRequest.implicitRules":"uri","SupplyRequest.item":"CodeableReference","SupplyRequest.language":"code","SupplyRequest.meta":"Meta","SupplyRequest.modifierExtension":"Extension","SupplyRequest.occurrenceDateTime":"dateTime","SupplyRequest.occurrencePeriod":"Period","SupplyRequest.occurrenceTiming":"Timing","SupplyRequest.parameter":"BackboneElement","SupplyRequest.parameter.code":"CodeableConcept","SupplyRequest.parameter.extension":"Extension","SupplyRequest.parameter.id":"System.String","SupplyRequest.parameter.modifierExtension":"Extension","SupplyRequest.parameter.valueBoolean":"boolean","SupplyRequest.parameter.valueCodeableConcept":"CodeableConcept","SupplyRequest.parameter.valueQuantity":"Quantity","SupplyRequest.parameter.valueRange":"Range","SupplyRequest.priority":"code","SupplyRequest.quantity":"Quantity","SupplyRequest.reason":"CodeableReference","SupplyRequest.requester":"Reference","SupplyRequest.status":"code","SupplyRequest.supplier":"Reference","SupplyRequest.text":"Narrative","Task.authoredOn":"dateTime","Task.basedOn":"Reference","Task.businessStatus":"CodeableConcept","Task.code":"CodeableConcept","Task.contained":"Resource","Task.description":"string","Task.doNotPerform":"boolean","Task.encounter":"Reference","Task.executionPeriod":"Period","Task.extension":"Extension","Task.focus":"Reference","Task.for":"Reference","Task.groupIdentifier":"Identifier","Task.id":"System.String","Task.identifier":"Identifier","Task.implicitRules":"uri","Task.input":"BackboneElement","Task.input.extension":"Extension","Task.input.id":"System.String","Task.input.modifierExtension":"Extension","Task.input.type":"CodeableConcept","Task.input.valueAddress":"Address","Task.input.valueAge":"Age","Task.input.valueAnnotation":"Annotation","Task.input.valueAttachment":"Attachment","Task.input.valueAvailability":"Availability","Task.input.valueBase64Binary":"base64Binary","Task.input.valueBoolean":"boolean","Task.input.valueCanonical":"canonical","Task.input.valueCode":"code","Task.input.valueCodeableConcept":"CodeableConcept","Task.input.valueCodeableReference":"CodeableReference","Task.input.valueCoding":"Coding","Task.input.valueContactDetail":"ContactDetail","Task.input.valueContactPoint":"ContactPoint","Task.input.valueCount":"Count","Task.input.valueDataRequirement":"DataRequirement","Task.input.valueDate":"date","Task.input.valueDateTime":"dateTime","Task.input.valueDecimal":"decimal","Task.input.valueDistance":"Distance","Task.input.valueDosage":"Dosage","Task.input.valueDuration":"Duration","Task.input.valueExpression":"Expression","Task.input.valueExtendedContactDetail":"ExtendedContactDetail","Task.input.valueHumanName":"HumanName","Task.input.valueId":"id","Task.input.valueIdentifier":"Identifier","Task.input.valueInstant":"instant","Task.input.valueInteger":"integer","Task.input.valueInteger64":"integer64","Task.input.valueMarkdown":"markdown","Task.input.valueMeta":"Meta","Task.input.valueMoney":"Money","Task.input.valueOid":"oid","Task.input.valueParameterDefinition":"ParameterDefinition","Task.input.valuePeriod":"Period","Task.input.valuePositiveInt":"positiveInt","Task.input.valueQuantity":"Quantity","Task.input.valueRange":"Range","Task.input.valueRatio":"Ratio","Task.input.valueRatioRange":"RatioRange","Task.input.valueReference":"Reference","Task.input.valueRelatedArtifact":"RelatedArtifact","Task.input.valueSampledData":"SampledData","Task.input.valueSignature":"Signature","Task.input.valueString":"string","Task.input.valueTime":"time","Task.input.valueTiming":"Timing","Task.input.valueTriggerDefinition":"TriggerDefinition","Task.input.valueUnsignedInt":"unsignedInt","Task.input.valueUri":"uri","Task.input.valueUrl":"url","Task.input.valueUsageContext":"UsageContext","Task.input.valueUuid":"uuid","Task.instantiatesCanonical":"canonical","Task.instantiatesUri":"uri","Task.insurance":"Reference","Task.intent":"code","Task.language":"code","Task.lastModified":"dateTime","Task.location":"Reference","Task.meta":"Meta","Task.modifierExtension":"Extension","Task.note":"Annotation","Task.output":"BackboneElement","Task.output.extension":"Extension","Task.output.id":"System.String","Task.output.modifierExtension":"Extension","Task.output.type":"CodeableConcept","Task.output.valueAddress":"Address","Task.output.valueAge":"Age","Task.output.valueAnnotation":"Annotation","Task.output.valueAttachment":"Attachment","Task.output.valueAvailability":"Availability","Task.output.valueBase64Binary":"base64Binary","Task.output.valueBoolean":"boolean","Task.output.valueCanonical":"canonical","Task.output.valueCode":"code","Task.output.valueCodeableConcept":"CodeableConcept","Task.output.valueCodeableReference":"CodeableReference","Task.output.valueCoding":"Coding","Task.output.valueContactDetail":"ContactDetail","Task.output.valueContactPoint":"ContactPoint","Task.output.valueCount":"Count","Task.output.valueDataRequirement":"DataRequirement","Task.output.valueDate":"date","Task.output.valueDateTime":"dateTime","Task.output.valueDecimal":"decimal","Task.output.valueDistance":"Distance","Task.output.valueDosage":"Dosage","Task.output.valueDuration":"Duration","Task.output.valueExpression":"Expression","Task.output.valueExtendedContactDetail":"ExtendedContactDetail","Task.output.valueHumanName":"HumanName","Task.output.valueId":"id","Task.output.valueIdentifier":"Identifier","Task.output.valueInstant":"instant","Task.output.valueInteger":"integer","Task.output.valueInteger64":"integer64","Task.output.valueMarkdown":"markdown","Task.output.valueMeta":"Meta","Task.output.valueMoney":"Money","Task.output.valueOid":"oid","Task.output.valueParameterDefinition":"ParameterDefinition","Task.output.valuePeriod":"Period","Task.output.valuePositiveInt":"positiveInt","Task.output.valueQuantity":"Quantity","Task.output.valueRange":"Range","Task.output.valueRatio":"Ratio","Task.output.valueRatioRange":"RatioRange","Task.output.valueReference":"Reference","Task.output.valueRelatedArtifact":"RelatedArtifact","Task.output.valueSampledData":"SampledData","Task.output.valueSignature":"Signature","Task.output.valueString":"string","Task.output.valueTime":"time","Task.output.valueTiming":"Timing","Task.output.valueTriggerDefinition":"TriggerDefinition","Task.output.valueUnsignedInt":"unsignedInt","Task.output.valueUri":"uri","Task.output.valueUrl":"url","Task.output.valueUsageContext":"UsageContext","Task.output.valueUuid":"uuid","Task.owner":"Reference","Task.partOf":"Reference","Task.performer":"BackboneElement","Task.performer.actor":"Reference","Task.performer.extension":"Extension","Task.performer.function":"CodeableConcept","Task.performer.id":"System.String","Task.performer.modifierExtension":"Extension","Task.priority":"code","Task.reason":"CodeableReference","Task.relevantHistory":"Reference","Task.requestedPerformer":"CodeableReference","Task.requestedPeriod":"Period","Task.requester":"Reference","Task.restriction":"BackboneElement","Task.restriction.extension":"Extension","Task.restriction.id":"System.String","Task.restriction.modifierExtension":"Extension","Task.restriction.period":"Period","Task.restriction.recipient":"Reference","Task.restriction.repetitions":"positiveInt","Task.status":"code","Task.statusReason":"CodeableReference","Task.text":"Narrative","TerminologyCapabilities.closure":"BackboneElement","TerminologyCapabilities.closure.extension":"Extension","TerminologyCapabilities.closure.id":"System.String","TerminologyCapabilities.closure.modifierExtension":"Extension","TerminologyCapabilities.closure.translation":"boolean","TerminologyCapabilities.codeSearch":"code","TerminologyCapabilities.codeSystem":"BackboneElement","TerminologyCapabilities.codeSystem.content":"code","TerminologyCapabilities.codeSystem.extension":"Extension","TerminologyCapabilities.codeSystem.id":"System.String","TerminologyCapabilities.codeSystem.modifierExtension":"Extension","TerminologyCapabilities.codeSystem.subsumption":"boolean","TerminologyCapabilities.codeSystem.uri":"canonical","TerminologyCapabilities.codeSystem.version":"BackboneElement","TerminologyCapabilities.codeSystem.version.code":"string","TerminologyCapabilities.codeSystem.version.compositional":"boolean","TerminologyCapabilities.codeSystem.version.extension":"Extension","TerminologyCapabilities.codeSystem.version.filter":"BackboneElement","TerminologyCapabilities.codeSystem.version.filter.code":"code","TerminologyCapabilities.codeSystem.version.filter.extension":"Extension","TerminologyCapabilities.codeSystem.version.filter.id":"System.String","TerminologyCapabilities.codeSystem.version.filter.modifierExtension":"Extension","TerminologyCapabilities.codeSystem.version.filter.op":"code","TerminologyCapabilities.codeSystem.version.id":"System.String","TerminologyCapabilities.codeSystem.version.isDefault":"boolean","TerminologyCapabilities.codeSystem.version.language":"code","TerminologyCapabilities.codeSystem.version.modifierExtension":"Extension","TerminologyCapabilities.codeSystem.version.property":"code","TerminologyCapabilities.contact":"ContactDetail","TerminologyCapabilities.contained":"Resource","TerminologyCapabilities.copyright":"markdown","TerminologyCapabilities.copyrightLabel":"string","TerminologyCapabilities.date":"dateTime","TerminologyCapabilities.description":"markdown","TerminologyCapabilities.expansion":"BackboneElement","TerminologyCapabilities.expansion.extension":"Extension","TerminologyCapabilities.expansion.hierarchical":"boolean","TerminologyCapabilities.expansion.id":"System.String","TerminologyCapabilities.expansion.incomplete":"boolean","TerminologyCapabilities.expansion.modifierExtension":"Extension","TerminologyCapabilities.expansion.paging":"boolean","TerminologyCapabilities.expansion.parameter":"BackboneElement","TerminologyCapabilities.expansion.parameter.documentation":"string","TerminologyCapabilities.expansion.parameter.extension":"Extension","TerminologyCapabilities.expansion.parameter.id":"System.String","TerminologyCapabilities.expansion.parameter.modifierExtension":"Extension","TerminologyCapabilities.expansion.parameter.name":"code","TerminologyCapabilities.expansion.textFilter":"markdown","TerminologyCapabilities.experimental":"boolean","TerminologyCapabilities.extension":"Extension","TerminologyCapabilities.id":"System.String","TerminologyCapabilities.identifier":"Identifier","TerminologyCapabilities.implementation":"BackboneElement","TerminologyCapabilities.implementation.description":"string","TerminologyCapabilities.implementation.extension":"Extension","TerminologyCapabilities.implementation.id":"System.String","TerminologyCapabilities.implementation.modifierExtension":"Extension","TerminologyCapabilities.implementation.url":"url","TerminologyCapabilities.implicitRules":"uri","TerminologyCapabilities.jurisdiction":"CodeableConcept","TerminologyCapabilities.kind":"code","TerminologyCapabilities.language":"code","TerminologyCapabilities.lockedDate":"boolean","TerminologyCapabilities.meta":"Meta","TerminologyCapabilities.modifierExtension":"Extension","TerminologyCapabilities.name":"string","TerminologyCapabilities.publisher":"string","TerminologyCapabilities.purpose":"markdown","TerminologyCapabilities.software":"BackboneElement","TerminologyCapabilities.software.extension":"Extension","TerminologyCapabilities.software.id":"System.String","TerminologyCapabilities.software.modifierExtension":"Extension","TerminologyCapabilities.software.name":"string","TerminologyCapabilities.software.version":"string","TerminologyCapabilities.status":"code","TerminologyCapabilities.text":"Narrative","TerminologyCapabilities.title":"string","TerminologyCapabilities.translation":"BackboneElement","TerminologyCapabilities.translation.extension":"Extension","TerminologyCapabilities.translation.id":"System.String","TerminologyCapabilities.translation.modifierExtension":"Extension","TerminologyCapabilities.translation.needsMap":"boolean","TerminologyCapabilities.url":"uri","TerminologyCapabilities.useContext":"UsageContext","TerminologyCapabilities.validateCode":"BackboneElement","TerminologyCapabilities.validateCode.extension":"Extension","TerminologyCapabilities.validateCode.id":"System.String","TerminologyCapabilities.validateCode.modifierExtension":"Extension","TerminologyCapabilities.validateCode.translations":"boolean","TerminologyCapabilities.version":"string","TerminologyCapabilities.versionAlgorithmCoding":"Coding","TerminologyCapabilities.versionAlgorithmString":"string","TestPlan.category":"CodeableConcept","TestPlan.contact":"ContactDetail","TestPlan.contained":"Resource","TestPlan.copyright":"markdown","TestPlan.copyrightLabel":"string","TestPlan.date":"dateTime","TestPlan.dependency":"BackboneElement","TestPlan.dependency.description":"markdown","TestPlan.dependency.extension":"Extension","TestPlan.dependency.id":"System.String","TestPlan.dependency.modifierExtension":"Extension","TestPlan.dependency.predecessor":"Reference","TestPlan.description":"markdown","TestPlan.exitCriteria":"markdown","TestPlan.experimental":"boolean","TestPlan.extension":"Extension","TestPlan.id":"System.String","TestPlan.identifier":"Identifier","TestPlan.implicitRules":"uri","TestPlan.jurisdiction":"CodeableConcept","TestPlan.language":"code","TestPlan.meta":"Meta","TestPlan.modifierExtension":"Extension","TestPlan.name":"string","TestPlan.publisher":"string","TestPlan.purpose":"markdown","TestPlan.scope":"Reference","TestPlan.status":"code","TestPlan.testCase":"BackboneElement","TestPlan.testCase.assertion":"BackboneElement","TestPlan.testCase.assertion.extension":"Extension","TestPlan.testCase.assertion.id":"System.String","TestPlan.testCase.assertion.modifierExtension":"Extension","TestPlan.testCase.assertion.object":"CodeableReference","TestPlan.testCase.assertion.result":"CodeableReference","TestPlan.testCase.assertion.type":"CodeableConcept","TestPlan.testCase.dependency":"BackboneElement","TestPlan.testCase.dependency.description":"markdown","TestPlan.testCase.dependency.extension":"Extension","TestPlan.testCase.dependency.id":"System.String","TestPlan.testCase.dependency.modifierExtension":"Extension","TestPlan.testCase.dependency.predecessor":"Reference","TestPlan.testCase.extension":"Extension","TestPlan.testCase.id":"System.String","TestPlan.testCase.modifierExtension":"Extension","TestPlan.testCase.scope":"Reference","TestPlan.testCase.sequence":"integer","TestPlan.testCase.testData":"BackboneElement","TestPlan.testCase.testData.content":"Reference","TestPlan.testCase.testData.extension":"Extension","TestPlan.testCase.testData.id":"System.String","TestPlan.testCase.testData.modifierExtension":"Extension","TestPlan.testCase.testData.sourceReference":"Reference","TestPlan.testCase.testData.sourceString":"string","TestPlan.testCase.testData.type":"Coding","TestPlan.testCase.testRun":"BackboneElement","TestPlan.testCase.testRun.extension":"Extension","TestPlan.testCase.testRun.id":"System.String","TestPlan.testCase.testRun.modifierExtension":"Extension","TestPlan.testCase.testRun.narrative":"markdown","TestPlan.testCase.testRun.script":"BackboneElement","TestPlan.testCase.testRun.script.extension":"Extension","TestPlan.testCase.testRun.script.id":"System.String","TestPlan.testCase.testRun.script.language":"CodeableConcept","TestPlan.testCase.testRun.script.modifierExtension":"Extension","TestPlan.testCase.testRun.script.sourceReference":"Reference","TestPlan.testCase.testRun.script.sourceString":"string","TestPlan.testTools":"markdown","TestPlan.text":"Narrative","TestPlan.title":"string","TestPlan.url":"uri","TestPlan.useContext":"UsageContext","TestPlan.version":"string","TestPlan.versionAlgorithmCoding":"Coding","TestPlan.versionAlgorithmString":"string","TestReport.contained":"Resource","TestReport.extension":"Extension","TestReport.id":"System.String","TestReport.identifier":"Identifier","TestReport.implicitRules":"uri","TestReport.issued":"dateTime","TestReport.language":"code","TestReport.meta":"Meta","TestReport.modifierExtension":"Extension","TestReport.name":"string","TestReport.participant":"BackboneElement","TestReport.participant.display":"string","TestReport.participant.extension":"Extension","TestReport.participant.id":"System.String","TestReport.participant.modifierExtension":"Extension","TestReport.participant.type":"code","TestReport.participant.uri":"uri","TestReport.result":"code","TestReport.score":"decimal","TestReport.setup":"BackboneElement","TestReport.setup.action":"BackboneElement","TestReport.setup.action.assert":"BackboneElement","TestReport.setup.action.assert.detail":"string","TestReport.setup.action.assert.extension":"Extension","TestReport.setup.action.assert.id":"System.String","TestReport.setup.action.assert.message":"markdown","TestReport.setup.action.assert.modifierExtension":"Extension","TestReport.setup.action.assert.requirement":"BackboneElement","TestReport.setup.action.assert.requirement.extension":"Extension","TestReport.setup.action.assert.requirement.id":"System.String","TestReport.setup.action.assert.requirement.linkCanonical":"canonical","TestReport.setup.action.assert.requirement.linkUri":"uri","TestReport.setup.action.assert.requirement.modifierExtension":"Extension","TestReport.setup.action.assert.result":"code","TestReport.setup.action.extension":"Extension","TestReport.setup.action.id":"System.String","TestReport.setup.action.modifierExtension":"Extension","TestReport.setup.action.operation":"BackboneElement","TestReport.setup.action.operation.detail":"uri","TestReport.setup.action.operation.extension":"Extension","TestReport.setup.action.operation.id":"System.String","TestReport.setup.action.operation.message":"markdown","TestReport.setup.action.operation.modifierExtension":"Extension","TestReport.setup.action.operation.result":"code","TestReport.setup.extension":"Extension","TestReport.setup.id":"System.String","TestReport.setup.modifierExtension":"Extension","TestReport.status":"code","TestReport.teardown":"BackboneElement","TestReport.teardown.action":"BackboneElement","TestReport.teardown.action.extension":"Extension","TestReport.teardown.action.id":"System.String","TestReport.teardown.action.modifierExtension":"Extension","TestReport.teardown.extension":"Extension","TestReport.teardown.id":"System.String","TestReport.teardown.modifierExtension":"Extension","TestReport.test":"BackboneElement","TestReport.test.action":"BackboneElement","TestReport.test.action.extension":"Extension","TestReport.test.action.id":"System.String","TestReport.test.action.modifierExtension":"Extension","TestReport.test.description":"string","TestReport.test.extension":"Extension","TestReport.test.id":"System.String","TestReport.test.modifierExtension":"Extension","TestReport.test.name":"string","TestReport.testScript":"canonical","TestReport.tester":"string","TestReport.text":"Narrative","TestScript.contact":"ContactDetail","TestScript.contained":"Resource","TestScript.copyright":"markdown","TestScript.copyrightLabel":"string","TestScript.date":"dateTime","TestScript.description":"markdown","TestScript.destination":"BackboneElement","TestScript.destination.extension":"Extension","TestScript.destination.id":"System.String","TestScript.destination.index":"integer","TestScript.destination.modifierExtension":"Extension","TestScript.destination.profile":"Coding","TestScript.destination.url":"url","TestScript.experimental":"boolean","TestScript.extension":"Extension","TestScript.fixture":"BackboneElement","TestScript.fixture.autocreate":"boolean","TestScript.fixture.autodelete":"boolean","TestScript.fixture.extension":"Extension","TestScript.fixture.id":"System.String","TestScript.fixture.modifierExtension":"Extension","TestScript.fixture.resource":"Reference","TestScript.id":"System.String","TestScript.identifier":"Identifier","TestScript.implicitRules":"uri","TestScript.jurisdiction":"CodeableConcept","TestScript.language":"code","TestScript.meta":"Meta","TestScript.metadata":"BackboneElement","TestScript.metadata.capability":"BackboneElement","TestScript.metadata.capability.capabilities":"canonical","TestScript.metadata.capability.description":"string","TestScript.metadata.capability.destination":"integer","TestScript.metadata.capability.extension":"Extension","TestScript.metadata.capability.id":"System.String","TestScript.metadata.capability.link":"uri","TestScript.metadata.capability.modifierExtension":"Extension","TestScript.metadata.capability.origin":"integer","TestScript.metadata.capability.required":"boolean","TestScript.metadata.capability.validated":"boolean","TestScript.metadata.extension":"Extension","TestScript.metadata.id":"System.String","TestScript.metadata.link":"BackboneElement","TestScript.metadata.link.description":"string","TestScript.metadata.link.extension":"Extension","TestScript.metadata.link.id":"System.String","TestScript.metadata.link.modifierExtension":"Extension","TestScript.metadata.link.url":"uri","TestScript.metadata.modifierExtension":"Extension","TestScript.modifierExtension":"Extension","TestScript.name":"string","TestScript.origin":"BackboneElement","TestScript.origin.extension":"Extension","TestScript.origin.id":"System.String","TestScript.origin.index":"integer","TestScript.origin.modifierExtension":"Extension","TestScript.origin.profile":"Coding","TestScript.origin.url":"url","TestScript.profile":"canonical","TestScript.publisher":"string","TestScript.purpose":"markdown","TestScript.scope":"BackboneElement","TestScript.scope.artifact":"canonical","TestScript.scope.conformance":"CodeableConcept","TestScript.scope.extension":"Extension","TestScript.scope.id":"System.String","TestScript.scope.modifierExtension":"Extension","TestScript.scope.phase":"CodeableConcept","TestScript.setup":"BackboneElement","TestScript.setup.action":"BackboneElement","TestScript.setup.action.assert":"BackboneElement","TestScript.setup.action.assert.compareToSourceExpression":"string","TestScript.setup.action.assert.compareToSourceId":"string","TestScript.setup.action.assert.compareToSourcePath":"string","TestScript.setup.action.assert.contentType":"code","TestScript.setup.action.assert.defaultManualCompletion":"code","TestScript.setup.action.assert.description":"string","TestScript.setup.action.assert.direction":"code","TestScript.setup.action.assert.expression":"string","TestScript.setup.action.assert.extension":"Extension","TestScript.setup.action.assert.headerField":"string","TestScript.setup.action.assert.id":"System.String","TestScript.setup.action.assert.label":"string","TestScript.setup.action.assert.minimumId":"string","TestScript.setup.action.assert.modifierExtension":"Extension","TestScript.setup.action.assert.navigationLinks":"boolean","TestScript.setup.action.assert.operator":"code","TestScript.setup.action.assert.path":"string","TestScript.setup.action.assert.requestMethod":"code","TestScript.setup.action.assert.requestURL":"string","TestScript.setup.action.assert.requirement":"BackboneElement","TestScript.setup.action.assert.requirement.extension":"Extension","TestScript.setup.action.assert.requirement.id":"System.String","TestScript.setup.action.assert.requirement.linkCanonical":"canonical","TestScript.setup.action.assert.requirement.linkUri":"uri","TestScript.setup.action.assert.requirement.modifierExtension":"Extension","TestScript.setup.action.assert.resource":"uri","TestScript.setup.action.assert.response":"code","TestScript.setup.action.assert.responseCode":"string","TestScript.setup.action.assert.sourceId":"id","TestScript.setup.action.assert.stopTestOnFail":"boolean","TestScript.setup.action.assert.validateProfileId":"id","TestScript.setup.action.assert.value":"string","TestScript.setup.action.assert.warningOnly":"boolean","TestScript.setup.action.extension":"Extension","TestScript.setup.action.id":"System.String","TestScript.setup.action.modifierExtension":"Extension","TestScript.setup.action.operation":"BackboneElement","TestScript.setup.action.operation.accept":"code","TestScript.setup.action.operation.contentType":"code","TestScript.setup.action.operation.description":"string","TestScript.setup.action.operation.destination":"integer","TestScript.setup.action.operation.encodeRequestUrl":"boolean","TestScript.setup.action.operation.extension":"Extension","TestScript.setup.action.operation.id":"System.String","TestScript.setup.action.operation.label":"string","TestScript.setup.action.operation.method":"code","TestScript.setup.action.operation.modifierExtension":"Extension","TestScript.setup.action.operation.origin":"integer","TestScript.setup.action.operation.params":"string","TestScript.setup.action.operation.requestHeader":"BackboneElement","TestScript.setup.action.operation.requestHeader.extension":"Extension","TestScript.setup.action.operation.requestHeader.field":"string","TestScript.setup.action.operation.requestHeader.id":"System.String","TestScript.setup.action.operation.requestHeader.modifierExtension":"Extension","TestScript.setup.action.operation.requestHeader.value":"string","TestScript.setup.action.operation.requestId":"id","TestScript.setup.action.operation.resource":"uri","TestScript.setup.action.operation.responseId":"id","TestScript.setup.action.operation.sourceId":"id","TestScript.setup.action.operation.targetId":"id","TestScript.setup.action.operation.type":"Coding","TestScript.setup.action.operation.url":"string","TestScript.setup.extension":"Extension","TestScript.setup.id":"System.String","TestScript.setup.modifierExtension":"Extension","TestScript.status":"code","TestScript.teardown":"BackboneElement","TestScript.teardown.action":"BackboneElement","TestScript.teardown.action.extension":"Extension","TestScript.teardown.action.id":"System.String","TestScript.teardown.action.modifierExtension":"Extension","TestScript.teardown.extension":"Extension","TestScript.teardown.id":"System.String","TestScript.teardown.modifierExtension":"Extension","TestScript.test":"BackboneElement","TestScript.test.action":"BackboneElement","TestScript.test.action.extension":"Extension","TestScript.test.action.id":"System.String","TestScript.test.action.modifierExtension":"Extension","TestScript.test.description":"string","TestScript.test.extension":"Extension","TestScript.test.id":"System.String","TestScript.test.modifierExtension":"Extension","TestScript.test.name":"string","TestScript.text":"Narrative","TestScript.title":"string","TestScript.url":"uri","TestScript.useContext":"UsageContext","TestScript.variable":"BackboneElement","TestScript.variable.defaultValue":"string","TestScript.variable.description":"string","TestScript.variable.expression":"string","TestScript.variable.extension":"Extension","TestScript.variable.headerField":"string","TestScript.variable.hint":"string","TestScript.variable.id":"System.String","TestScript.variable.modifierExtension":"Extension","TestScript.variable.name":"string","TestScript.variable.path":"string","TestScript.variable.sourceId":"id","TestScript.version":"string","TestScript.versionAlgorithmCoding":"Coding","TestScript.versionAlgorithmString":"string","Timing.code":"CodeableConcept","Timing.event":"dateTime","Timing.extension":"Extension","Timing.id":"System.String","Timing.modifierExtension":"Extension","Timing.repeat":"Element","Timing.repeat.boundsDuration":"Duration","Timing.repeat.boundsPeriod":"Period","Timing.repeat.boundsRange":"Range","Timing.repeat.count":"positiveInt","Timing.repeat.countMax":"positiveInt","Timing.repeat.dayOfWeek":"code","Timing.repeat.duration":"decimal","Timing.repeat.durationMax":"decimal","Timing.repeat.durationUnit":"code","Timing.repeat.extension":"Extension","Timing.repeat.frequency":"positiveInt","Timing.repeat.frequencyMax":"positiveInt","Timing.repeat.id":"System.String","Timing.repeat.offset":"unsignedInt","Timing.repeat.period":"decimal","Timing.repeat.periodMax":"decimal","Timing.repeat.periodUnit":"code","Timing.repeat.timeOfDay":"time","Timing.repeat.when":"code","Transport.authoredOn":"dateTime","Transport.basedOn":"Reference","Transport.code":"CodeableConcept","Transport.completionTime":"dateTime","Transport.contained":"Resource","Transport.currentLocation":"Reference","Transport.description":"string","Transport.encounter":"Reference","Transport.extension":"Extension","Transport.focus":"Reference","Transport.for":"Reference","Transport.groupIdentifier":"Identifier","Transport.history":"Reference","Transport.id":"System.String","Transport.identifier":"Identifier","Transport.implicitRules":"uri","Transport.input":"BackboneElement","Transport.input.extension":"Extension","Transport.input.id":"System.String","Transport.input.modifierExtension":"Extension","Transport.input.type":"CodeableConcept","Transport.input.valueAddress":"Address","Transport.input.valueAge":"Age","Transport.input.valueAnnotation":"Annotation","Transport.input.valueAttachment":"Attachment","Transport.input.valueAvailability":"Availability","Transport.input.valueBase64Binary":"base64Binary","Transport.input.valueBoolean":"boolean","Transport.input.valueCanonical":"canonical","Transport.input.valueCode":"code","Transport.input.valueCodeableConcept":"CodeableConcept","Transport.input.valueCodeableReference":"CodeableReference","Transport.input.valueCoding":"Coding","Transport.input.valueContactDetail":"ContactDetail","Transport.input.valueContactPoint":"ContactPoint","Transport.input.valueCount":"Count","Transport.input.valueDataRequirement":"DataRequirement","Transport.input.valueDate":"date","Transport.input.valueDateTime":"dateTime","Transport.input.valueDecimal":"decimal","Transport.input.valueDistance":"Distance","Transport.input.valueDosage":"Dosage","Transport.input.valueDuration":"Duration","Transport.input.valueExpression":"Expression","Transport.input.valueExtendedContactDetail":"ExtendedContactDetail","Transport.input.valueHumanName":"HumanName","Transport.input.valueId":"id","Transport.input.valueIdentifier":"Identifier","Transport.input.valueInstant":"instant","Transport.input.valueInteger":"integer","Transport.input.valueInteger64":"integer64","Transport.input.valueMarkdown":"markdown","Transport.input.valueMeta":"Meta","Transport.input.valueMoney":"Money","Transport.input.valueOid":"oid","Transport.input.valueParameterDefinition":"ParameterDefinition","Transport.input.valuePeriod":"Period","Transport.input.valuePositiveInt":"positiveInt","Transport.input.valueQuantity":"Quantity","Transport.input.valueRange":"Range","Transport.input.valueRatio":"Ratio","Transport.input.valueRatioRange":"RatioRange","Transport.input.valueReference":"Reference","Transport.input.valueRelatedArtifact":"RelatedArtifact","Transport.input.valueSampledData":"SampledData","Transport.input.valueSignature":"Signature","Transport.input.valueString":"string","Transport.input.valueTime":"time","Transport.input.valueTiming":"Timing","Transport.input.valueTriggerDefinition":"TriggerDefinition","Transport.input.valueUnsignedInt":"unsignedInt","Transport.input.valueUri":"uri","Transport.input.valueUrl":"url","Transport.input.valueUsageContext":"UsageContext","Transport.input.valueUuid":"uuid","Transport.instantiatesCanonical":"canonical","Transport.instantiatesUri":"uri","Transport.insurance":"Reference","Transport.intent":"code","Transport.language":"code","Transport.lastModified":"dateTime","Transport.location":"Reference","Transport.meta":"Meta","Transport.modifierExtension":"Extension","Transport.note":"Annotation","Transport.output":"BackboneElement","Transport.output.extension":"Extension","Transport.output.id":"System.String","Transport.output.modifierExtension":"Extension","Transport.output.type":"CodeableConcept","Transport.output.valueAddress":"Address","Transport.output.valueAge":"Age","Transport.output.valueAnnotation":"Annotation","Transport.output.valueAttachment":"Attachment","Transport.output.valueAvailability":"Availability","Transport.output.valueBase64Binary":"base64Binary","Transport.output.valueBoolean":"boolean","Transport.output.valueCanonical":"canonical","Transport.output.valueCode":"code","Transport.output.valueCodeableConcept":"CodeableConcept","Transport.output.valueCodeableReference":"CodeableReference","Transport.output.valueCoding":"Coding","Transport.output.valueContactDetail":"ContactDetail","Transport.output.valueContactPoint":"ContactPoint","Transport.output.valueCount":"Count","Transport.output.valueDataRequirement":"DataRequirement","Transport.output.valueDate":"date","Transport.output.valueDateTime":"dateTime","Transport.output.valueDecimal":"decimal","Transport.output.valueDistance":"Distance","Transport.output.valueDosage":"Dosage","Transport.output.valueDuration":"Duration","Transport.output.valueExpression":"Expression","Transport.output.valueExtendedContactDetail":"ExtendedContactDetail","Transport.output.valueHumanName":"HumanName","Transport.output.valueId":"id","Transport.output.valueIdentifier":"Identifier","Transport.output.valueInstant":"instant","Transport.output.valueInteger":"integer","Transport.output.valueInteger64":"integer64","Transport.output.valueMarkdown":"markdown","Transport.output.valueMeta":"Meta","Transport.output.valueMoney":"Money","Transport.output.valueOid":"oid","Transport.output.valueParameterDefinition":"ParameterDefinition","Transport.output.valuePeriod":"Period","Transport.output.valuePositiveInt":"positiveInt","Transport.output.valueQuantity":"Quantity","Transport.output.valueRange":"Range","Transport.output.valueRatio":"Ratio","Transport.output.valueRatioRange":"RatioRange","Transport.output.valueReference":"Reference","Transport.output.valueRelatedArtifact":"RelatedArtifact","Transport.output.valueSampledData":"SampledData","Transport.output.valueSignature":"Signature","Transport.output.valueString":"string","Transport.output.valueTime":"time","Transport.output.valueTiming":"Timing","Transport.output.valueTriggerDefinition":"TriggerDefinition","Transport.output.valueUnsignedInt":"unsignedInt","Transport.output.valueUri":"uri","Transport.output.valueUrl":"url","Transport.output.valueUsageContext":"UsageContext","Transport.output.valueUuid":"uuid","Transport.owner":"Reference","Transport.partOf":"Reference","Transport.performerType":"CodeableConcept","Transport.priority":"code","Transport.reason":"CodeableReference","Transport.relevantHistory":"Reference","Transport.requestedLocation":"Reference","Transport.requester":"Reference","Transport.restriction":"BackboneElement","Transport.restriction.extension":"Extension","Transport.restriction.id":"System.String","Transport.restriction.modifierExtension":"Extension","Transport.restriction.period":"Period","Transport.restriction.recipient":"Reference","Transport.restriction.repetitions":"positiveInt","Transport.status":"code","Transport.statusReason":"CodeableConcept","Transport.text":"Narrative","TriggerDefinition.code":"CodeableConcept","TriggerDefinition.condition":"Expression","TriggerDefinition.data":"DataRequirement","TriggerDefinition.extension":"Extension","TriggerDefinition.id":"System.String","TriggerDefinition.name":"string","TriggerDefinition.subscriptionTopic":"canonical","TriggerDefinition.timingDate":"date","TriggerDefinition.timingDateTime":"dateTime","TriggerDefinition.timingReference":"Reference","TriggerDefinition.timingTiming":"Timing","TriggerDefinition.type":"code","UsageContext.code":"Coding","UsageContext.extension":"Extension","UsageContext.id":"System.String","UsageContext.valueCodeableConcept":"CodeableConcept","UsageContext.valueQuantity":"Quantity","UsageContext.valueRange":"Range","UsageContext.valueReference":"Reference","ValueSet.approvalDate":"date","ValueSet.author":"ContactDetail","ValueSet.compose":"BackboneElement","ValueSet.compose.extension":"Extension","ValueSet.compose.id":"System.String","ValueSet.compose.inactive":"boolean","ValueSet.compose.include":"BackboneElement","ValueSet.compose.include.concept":"BackboneElement","ValueSet.compose.include.concept.code":"code","ValueSet.compose.include.concept.designation":"BackboneElement","ValueSet.compose.include.concept.designation.additionalUse":"Coding","ValueSet.compose.include.concept.designation.extension":"Extension","ValueSet.compose.include.concept.designation.id":"System.String","ValueSet.compose.include.concept.designation.language":"code","ValueSet.compose.include.concept.designation.modifierExtension":"Extension","ValueSet.compose.include.concept.designation.use":"Coding","ValueSet.compose.include.concept.designation.value":"string","ValueSet.compose.include.concept.display":"string","ValueSet.compose.include.concept.extension":"Extension","ValueSet.compose.include.concept.id":"System.String","ValueSet.compose.include.concept.modifierExtension":"Extension","ValueSet.compose.include.copyright":"string","ValueSet.compose.include.extension":"Extension","ValueSet.compose.include.filter":"BackboneElement","ValueSet.compose.include.filter.extension":"Extension","ValueSet.compose.include.filter.id":"System.String","ValueSet.compose.include.filter.modifierExtension":"Extension","ValueSet.compose.include.filter.op":"code","ValueSet.compose.include.filter.property":"code","ValueSet.compose.include.filter.value":"string","ValueSet.compose.include.id":"System.String","ValueSet.compose.include.modifierExtension":"Extension","ValueSet.compose.include.system":"uri","ValueSet.compose.include.valueSet":"canonical","ValueSet.compose.include.version":"string","ValueSet.compose.lockedDate":"date","ValueSet.compose.modifierExtension":"Extension","ValueSet.compose.property":"string","ValueSet.contact":"ContactDetail","ValueSet.contained":"Resource","ValueSet.copyright":"markdown","ValueSet.copyrightLabel":"string","ValueSet.date":"dateTime","ValueSet.description":"markdown","ValueSet.editor":"ContactDetail","ValueSet.effectivePeriod":"Period","ValueSet.endorser":"ContactDetail","ValueSet.expansion":"BackboneElement","ValueSet.expansion.contains":"BackboneElement","ValueSet.expansion.contains.abstract":"boolean","ValueSet.expansion.contains.code":"code","ValueSet.expansion.contains.display":"string","ValueSet.expansion.contains.extension":"Extension","ValueSet.expansion.contains.id":"System.String","ValueSet.expansion.contains.inactive":"boolean","ValueSet.expansion.contains.modifierExtension":"Extension","ValueSet.expansion.contains.property":"BackboneElement","ValueSet.expansion.contains.property.code":"code","ValueSet.expansion.contains.property.extension":"Extension","ValueSet.expansion.contains.property.id":"System.String","ValueSet.expansion.contains.property.modifierExtension":"Extension","ValueSet.expansion.contains.property.subProperty":"BackboneElement","ValueSet.expansion.contains.property.subProperty.code":"code","ValueSet.expansion.contains.property.subProperty.extension":"Extension","ValueSet.expansion.contains.property.subProperty.id":"System.String","ValueSet.expansion.contains.property.subProperty.modifierExtension":"Extension","ValueSet.expansion.contains.property.subProperty.valueBoolean":"boolean","ValueSet.expansion.contains.property.subProperty.valueCode":"code","ValueSet.expansion.contains.property.subProperty.valueCoding":"Coding","ValueSet.expansion.contains.property.subProperty.valueDateTime":"dateTime","ValueSet.expansion.contains.property.subProperty.valueDecimal":"decimal","ValueSet.expansion.contains.property.subProperty.valueInteger":"integer","ValueSet.expansion.contains.property.subProperty.valueString":"string","ValueSet.expansion.contains.property.valueBoolean":"boolean","ValueSet.expansion.contains.property.valueCode":"code","ValueSet.expansion.contains.property.valueCoding":"Coding","ValueSet.expansion.contains.property.valueDateTime":"dateTime","ValueSet.expansion.contains.property.valueDecimal":"decimal","ValueSet.expansion.contains.property.valueInteger":"integer","ValueSet.expansion.contains.property.valueString":"string","ValueSet.expansion.contains.system":"uri","ValueSet.expansion.contains.version":"string","ValueSet.expansion.extension":"Extension","ValueSet.expansion.id":"System.String","ValueSet.expansion.identifier":"uri","ValueSet.expansion.modifierExtension":"Extension","ValueSet.expansion.next":"uri","ValueSet.expansion.offset":"integer","ValueSet.expansion.parameter":"BackboneElement","ValueSet.expansion.parameter.extension":"Extension","ValueSet.expansion.parameter.id":"System.String","ValueSet.expansion.parameter.modifierExtension":"Extension","ValueSet.expansion.parameter.name":"string","ValueSet.expansion.parameter.valueBoolean":"boolean","ValueSet.expansion.parameter.valueCode":"code","ValueSet.expansion.parameter.valueDateTime":"dateTime","ValueSet.expansion.parameter.valueDecimal":"decimal","ValueSet.expansion.parameter.valueInteger":"integer","ValueSet.expansion.parameter.valueString":"string","ValueSet.expansion.parameter.valueUri":"uri","ValueSet.expansion.property":"BackboneElement","ValueSet.expansion.property.code":"code","ValueSet.expansion.property.extension":"Extension","ValueSet.expansion.property.id":"System.String","ValueSet.expansion.property.modifierExtension":"Extension","ValueSet.expansion.property.uri":"uri","ValueSet.expansion.timestamp":"dateTime","ValueSet.expansion.total":"integer","ValueSet.experimental":"boolean","ValueSet.extension":"Extension","ValueSet.id":"System.String","ValueSet.identifier":"Identifier","ValueSet.immutable":"boolean","ValueSet.implicitRules":"uri","ValueSet.jurisdiction":"CodeableConcept","ValueSet.language":"code","ValueSet.lastReviewDate":"date","ValueSet.meta":"Meta","ValueSet.modifierExtension":"Extension","ValueSet.name":"string","ValueSet.publisher":"string","ValueSet.purpose":"markdown","ValueSet.relatedArtifact":"RelatedArtifact","ValueSet.reviewer":"ContactDetail","ValueSet.scope":"BackboneElement","ValueSet.scope.exclusionCriteria":"string","ValueSet.scope.extension":"Extension","ValueSet.scope.id":"System.String","ValueSet.scope.inclusionCriteria":"string","ValueSet.scope.modifierExtension":"Extension","ValueSet.status":"code","ValueSet.text":"Narrative","ValueSet.title":"string","ValueSet.topic":"CodeableConcept","ValueSet.url":"uri","ValueSet.useContext":"UsageContext","ValueSet.version":"string","ValueSet.versionAlgorithmCoding":"Coding","ValueSet.versionAlgorithmString":"string","VerificationResult.attestation":"BackboneElement","VerificationResult.attestation.communicationMethod":"CodeableConcept","VerificationResult.attestation.date":"date","VerificationResult.attestation.extension":"Extension","VerificationResult.attestation.id":"System.String","VerificationResult.attestation.modifierExtension":"Extension","VerificationResult.attestation.onBehalfOf":"Reference","VerificationResult.attestation.proxyIdentityCertificate":"string","VerificationResult.attestation.proxySignature":"Signature","VerificationResult.attestation.sourceIdentityCertificate":"string","VerificationResult.attestation.sourceSignature":"Signature","VerificationResult.attestation.who":"Reference","VerificationResult.contained":"Resource","VerificationResult.extension":"Extension","VerificationResult.failureAction":"CodeableConcept","VerificationResult.frequency":"Timing","VerificationResult.id":"System.String","VerificationResult.implicitRules":"uri","VerificationResult.language":"code","VerificationResult.lastPerformed":"dateTime","VerificationResult.meta":"Meta","VerificationResult.modifierExtension":"Extension","VerificationResult.need":"CodeableConcept","VerificationResult.nextScheduled":"date","VerificationResult.primarySource":"BackboneElement","VerificationResult.primarySource.canPushUpdates":"CodeableConcept","VerificationResult.primarySource.communicationMethod":"CodeableConcept","VerificationResult.primarySource.extension":"Extension","VerificationResult.primarySource.id":"System.String","VerificationResult.primarySource.modifierExtension":"Extension","VerificationResult.primarySource.pushTypeAvailable":"CodeableConcept","VerificationResult.primarySource.type":"CodeableConcept","VerificationResult.primarySource.validationDate":"dateTime","VerificationResult.primarySource.validationStatus":"CodeableConcept","VerificationResult.primarySource.who":"Reference","VerificationResult.status":"code","VerificationResult.statusDate":"dateTime","VerificationResult.target":"Reference","VerificationResult.targetLocation":"string","VerificationResult.text":"Narrative","VerificationResult.validationProcess":"CodeableConcept","VerificationResult.validationType":"CodeableConcept","VerificationResult.validator":"BackboneElement","VerificationResult.validator.attestationSignature":"Signature","VerificationResult.validator.extension":"Extension","VerificationResult.validator.id":"System.String","VerificationResult.validator.identityCertificate":"string","VerificationResult.validator.modifierExtension":"Extension","VerificationResult.validator.organization":"Reference","VirtualServiceDetail.additionalInfo":"url","VirtualServiceDetail.addressContactPoint":"ContactPoint","VirtualServiceDetail.addressExtendedContactDetail":"ExtendedContactDetail","VirtualServiceDetail.addressString":"string","VirtualServiceDetail.addressUrl":"url","VirtualServiceDetail.channelType":"Coding","VirtualServiceDetail.extension":"Extension","VirtualServiceDetail.id":"System.String","VirtualServiceDetail.maxParticipants":"positiveInt","VirtualServiceDetail.sessionKey":"string","VisionPrescription.contained":"Resource","VisionPrescription.created":"dateTime","VisionPrescription.dateWritten":"dateTime","VisionPrescription.encounter":"Reference","VisionPrescription.extension":"Extension","VisionPrescription.id":"System.String","VisionPrescription.identifier":"Identifier","VisionPrescription.implicitRules":"uri","VisionPrescription.language":"code","VisionPrescription.lensSpecification":"BackboneElement","VisionPrescription.lensSpecification.add":"decimal","VisionPrescription.lensSpecification.axis":"integer","VisionPrescription.lensSpecification.backCurve":"decimal","VisionPrescription.lensSpecification.brand":"string","VisionPrescription.lensSpecification.color":"string","VisionPrescription.lensSpecification.cylinder":"decimal","VisionPrescription.lensSpecification.diameter":"decimal","VisionPrescription.lensSpecification.duration":"Quantity","VisionPrescription.lensSpecification.extension":"Extension","VisionPrescription.lensSpecification.eye":"code","VisionPrescription.lensSpecification.id":"System.String","VisionPrescription.lensSpecification.modifierExtension":"Extension","VisionPrescription.lensSpecification.note":"Annotation","VisionPrescription.lensSpecification.power":"decimal","VisionPrescription.lensSpecification.prism":"BackboneElement","VisionPrescription.lensSpecification.prism.amount":"decimal","VisionPrescription.lensSpecification.prism.base":"code","VisionPrescription.lensSpecification.prism.extension":"Extension","VisionPrescription.lensSpecification.prism.id":"System.String","VisionPrescription.lensSpecification.prism.modifierExtension":"Extension","VisionPrescription.lensSpecification.product":"CodeableConcept","VisionPrescription.lensSpecification.sphere":"decimal","VisionPrescription.meta":"Meta","VisionPrescription.modifierExtension":"Extension","VisionPrescription.patient":"Reference","VisionPrescription.prescriber":"Reference","VisionPrescription.status":"code","VisionPrescription.text":"Narrative","base64Binary.extension":"Extension","base64Binary.id":"System.String","base64Binary.value":"System.String","boolean.extension":"Extension","boolean.id":"System.String","boolean.value":"System.Boolean","canonical.extension":"Extension","canonical.id":"System.String","canonical.value":"System.String","code.extension":"Extension","code.id":"System.String","code.value":"System.String","date.extension":"Extension","date.id":"System.String","date.value":"System.Date","dateTime.extension":"Extension","dateTime.id":"System.String","dateTime.value":"System.DateTime","decimal.extension":"Extension","decimal.id":"System.String","decimal.value":"System.Decimal","id.extension":"Extension","id.id":"System.String","id.value":"System.String","instant.extension":"Extension","instant.id":"System.String","instant.value":"System.DateTime","integer.extension":"Extension","integer.id":"System.String","integer.value":"System.Integer","integer64.extension":"Extension","integer64.id":"System.String","integer64.value":"System.Integer","markdown.extension":"Extension","markdown.id":"System.String","markdown.value":"System.String","oid.extension":"Extension","oid.id":"System.String","oid.value":"System.String","positiveInt.extension":"Extension","positiveInt.id":"System.String","positiveInt.value":"System.Integer","string.extension":"Extension","string.id":"System.String","string.value":"System.String","time.extension":"Extension","time.id":"System.String","time.value":"System.Time","unsignedInt.extension":"Extension","unsignedInt.id":"System.String","unsignedInt.value":"System.Integer","uri.extension":"Extension","uri.id":"System.String","uri.value":"System.String","url.extension":"Extension","url.id":"System.String","url.value":"System.String","uuid.extension":"Extension","uuid.id":"System.String","uuid.value":"System.String","xhtml.extension":"Extension","xhtml.id":"System.String","xhtml.value":"System.String"}');

/***/ }),
/* 95 */
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _import_common_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(96);


/**
 * A package to handle FHIR DiagnosticReport for LForms
 * https://www.hl7.org/fhir/diagnosticreport.html
 *
 * Note that this was written for DSTU2 and has not been updated.
 *
 * It provides the following functions:
 * createDiagnosticReport()
 * -- Convert existing LOINC panels/forms data in LForms format into FHIR DiagnosticReport data
 * mergeDiagnosticReportToLForms()
 * -- Merge FHIR SDC DiagnosticReport data into corresponding LForms data
 */

var dr = {
  // a prefix for references to Observation resources
  _OBX_REF_PREFIX: "Observation/",
  /**
   * Functions for creating a DiagnosticReport instance from an LFormsData object
   */

  /** Get date in a standard string format
   * @param dateObj, a date object
   * @returns {string} a formatted date string
   * @private
   */
  _getFormattedDate: function (dateObj) {
    //"2013-01-27T11:45:33+11:00",
    return dateObj ? LForms.Util.dateToDTMString(dateObj) : "";
  },
  /**
   * A recursive function that generates the DiagnosticReport content by
   * going through the LForms form data structure
   * @param item an LForms item
   * @param contained the "contained" field in a DiagnosticReport where all the Observation instances are kept.
   * @returns {{result: Array, resultObj: Array}} the content part of a Diagnostic Report instance
   * @private
   */
  _createDiagnosticReportContent: function (item, contained) {
    // return the content of "result" and "contained"
    var content = {
      result: [],
      resultObj: []
    };
    for (var i = 0, iLen = item.items.length; i < iLen; i++) {
      var subItem = item.items[i];
      if (subItem) {
        var obx = this._commonExport._createObservation(subItem, true);
        if (subItem.items && subItem.items.length > 0) {
          // single obx returned if it is a header item
          obx[0].related = [];
          var ret = this._createDiagnosticReportContent(subItem, contained);
          for (var j = 0, jLen = ret.result.length; j < jLen; j++) {
            var subObxRef = ret.result[j];
            obx[0].related.push({
              type: "has-member",
              target: {
                reference: subObxRef.reference
              }
            });
          }
        }
        for (var l = 0, lLen = obx.length; l < lLen; l++) {
          contained.push(obx[l]);
          content.result.push({
            reference: "#" + obx[l].id
          });
          content.resultObj.push(obx[l]);
        }
      }
    }
    return content;
  },
  /**
   * Convert a DiagnosticReport resource with contained Observation resources to
   * a FHIR Bundle resource that includes a DiagnosticReport resource and associated Observation resources
   * @param dr a DiagnosticReport resource with contained Observation resources
   * @param bundleType the FHIR Bundle type. Only "transaction" and "collection" types are allowed.
   * @returns {{}} a Bundle resource that includes a DiagnosticReport resource and associated Observation resources
   */
  _convertFromContainedToBundle: function (dr, bundleType) {
    var bundleDr = {};

    // default bundleType
    if (!bundleType) {
      bundleType = "transaction";
    }
    if (dr) {
      switch (bundleType) {
        case "transaction":
          bundleDr = this._convertContainedToTransactionBundle(dr);
          break;
        case "collection":
          bundleDr = this._convertContainedToCollectionBundle(dr);
          break;
        default:
          console.log("Bundle type not supported: " + bundleType);
      }
    }
    return bundleDr;
  },
  /**
   * Convert a DiagnosticReport resource with contained Observation resources to
   * a FHIR "transaction" typed Bundle resource that includes a DiagnosticReport resource
   * and associated Observation resources
   * @param dr a DiagnosticReport resource with contained Observation resources
   * @returns {{}} a Bundle resource that includes a DiagnosticReport resource and associated Observation resources
   * @private
   */
  _convertContainedToTransactionBundle: function (dr) {
    var bundleDr = {
      resourceType: "Bundle",
      type: "transaction",
      entry: []
    };
    var contained = dr.contained;
    delete dr.contained;

    // update reference to Observation resources
    for (var i = 0, iLen = dr.result.length; i < iLen; i++) {
      var ref = dr.result[i];
      ref.reference = this._OBX_REF_PREFIX + ref.reference.slice(1);
    }
    // add DiagnosticReport resource into Bundle entry
    bundleDr.entry.push({
      resource: dr,
      request: {
        method: "POST",
        url: "DiagnosticReport"
      }
    });

    // add Observation resources into Bundle entry
    for (var j = 0, jLen = contained.length; j < jLen; j++) {
      var res = contained[j];

      // if it has related Observation resources (as it is a section in LForms)
      // update values of the references to the related Observation resources
      if (res.related) {
        for (var k = 0, kLen = res.related.length; k < kLen; k++) {
          var targetObservation = res.related[k];
          targetObservation.target.reference = this._OBX_REF_PREFIX + targetObservation.target.reference.slice(1);
        }
      }

      // add to the Bundle entry
      bundleDr.entry.push({
        resource: res,
        request: {
          method: "POST",
          url: "Observation"
        }
      });
    }
    return bundleDr;
  },
  /**
   * Convert a DiagnosticReport resource with contained Observation resources to
   * a FHIR "collection" typed Bundle resource that includes a DiagnosticReport resource
   * and associated Observation resources
   * @param dr a DiagnosticReport resource with contained Observation resources
   * @returns {{}} a Bundle resource that includes a DiagnosticReport resource and associated Observation resources
   * @private
   */
  _convertContainedToCollectionBundle: function (dr) {
    var bundleDr = {
      resourceType: "Bundle",
      type: "collection",
      entry: []
    };
    var contained = dr.contained;
    delete dr.contained;

    // add DiagnosticReport resource into Bundle entry
    bundleDr.entry.push({
      resource: dr
    });

    // add Observation resources into Bundle entry
    for (var j = 0, jLen = contained.length; j < jLen; j++) {
      var res = contained[j];
      // add to the Bundle entry
      bundleDr.entry.push({
        resource: res
      });
    }
    return bundleDr;
  },
  /**
   * Generate FHIR DiagnosticReport data from an LForms form data
   * @param formData an LFormsData object
   * @param subject optional, A local FHIR resource that is the subject for this
   *  DiagnoticReport.
   * @param inBundle optional, a flag that a DiagnosticReport resources and associated Observation resources
   *        should be placed into a FHIR Bundle. The default is false.
   * @param bundleType, optional, the FHIR Bundle type if inBundle is true.
   *        Only "transaction" and "collection" types are allowed.
   * @returns {{}} a Diagnostic Report instance
   */
  createDiagnosticReport: function (formData, subject, inBundle, bundleType) {
    var dr = null,
      contained = [];
    if (formData) {
      var formAndUserData = formData.getFormData(true, true, true);
      var drContent = this._createDiagnosticReportContent(formAndUserData, contained);
      dr = {
        resourceType: "DiagnosticReport",
        id: this._commonExport._getUniqueId(formAndUserData.code),
        status: "final",
        code: {
          "coding": [{
            "system": formAndUserData.codeSystem,
            "code": formAndUserData.code,
            "display": formAndUserData.name
          }],
          "text": formAndUserData.name
        },
        result: drContent.result,
        contained: contained
      };
      this._commonExport._addVersionTag(dr);
      if (subject) dr.subject = LForms.Util.createLocalFHIRReference(subject);

      // issued
      dr["issued"] = this._getFormattedDate(new Date());
    }
    var ret = inBundle ? this._convertFromContainedToBundle(dr, bundleType) : dr;
    LForms.Util.pruneNulls(ret);
    return ret;
  },
  /**
   * Functions for merging a DiagnosticReport instance into an LFormsData object
   */

  /**
   * Find an observation from the "contained" list by an observation id
   * @param refId an observation instance's id
   * @param contained the "contained" field in a DiagnosticReport instance
   * @returns {{}} an observation instance
   * @private
   */
  _findObxById: function (refId, contained) {
    var obx = null;
    if (refId) {
      var id = refId[0] === "#" ? refId.slice(1) : refId;
      for (var i = 0, iLen = contained.length; i < iLen; i++) {
        if (contained[i].id === id) {
          obx = contained[i];
          break;
        }
      }
    }
    return obx;
  },
  /**
   * Merge an Observation instance into an item object
   * @param obx an observation instance
   * @param item an item in an LForms object
   * @private
   */
  _setupItemValueAndUnit: function (obx, item) {
    if (item && obx.code.coding[0].code === item.questionCode) {
      var dataType = item.dataType;
      // any one has a unit must be a numerical type, let use REAL for now.
      // dataType conversion should be handled when panel data are added to lforms-service.
      if ((!dataType || dataType === "ST") && item.units && item.units.length > 0) {
        dataType = "REAL";
      }
      switch (dataType) {
        case "INT":
          if (obx.valueInteger) {
            item.value = obx.valueInteger;
            break;
          }
        // else handle as Quantity
        case "REAL": // handle as Quantity
        case "QTY":
          let qty = (0,_import_common_js__WEBPACK_IMPORTED_MODULE_0__.importFHIRQuantity)(obx.valueQuantity);
          item.value = qty.value;
          delete qty.value;
          if (qty.name || qty.code || qty.system) item.unit = qty;
          break;
        case "DT":
          item.value = LForms.Util.stringToDTDateISO(obx.valueDate);
          break;
        case "DTM":
          item.value = LForms.Util.stringToDate(obx.valueDateTime);
          break;
        case "CODING":
          // get the value from Observation resource.
          // for multiple-selected answers/values in LForms, each selected answer is exported as
          // a separated Observation resource
          var itemValue;
          if (obx.valueCodeableConcept) {
            itemValue = {
              "code": obx.valueCodeableConcept.coding[0].code,
              "text": obx.valueCodeableConcept.coding[0].display,
              "system": obx.valueCodeableConcept.coding[0].system
            };
          } else if (obx.valueString) {
            itemValue = obx.valueString;
          }
          if (item.answerCardinality && (item.answerCardinality.max === "*" || parseInt(item.answerCardinality.max) > 1)) {
            if (!item.value) {
              item.value = [];
            }
            item.value.push(itemValue);
          } else {
            item.value = itemValue;
          }
          break;
        case "SECTION":
        case "TITLE":
        case "":
          // do nothing
          break;
        default:
          item.value = obx.valueString;
      }
    }
  },
  /**
   * Find the number of the repeating items that have the same code
   * in the "contained" field of a DiagnosticReport instance
   * @param refIdList a list Observation instance IDs to be checked
   * @param code an item code
   * @param contained a list of Observation instances (in the "contained")
   * @returns a structural info object for a repeating item
   * of the repeating items
   * @private
   */
  _findTotalRepeatingNum: function (refIdList, code, contained) {
    var total = 0;
    var refIds = [];
    for (var i = 0, iLen = refIdList.length; i < iLen; i++) {
      var obx = this._findObxById(refIdList[i], contained);
      if (obx.code.coding[0].code === code) {
        refIds.push(refIdList[i]);
        total += 1;
      }
    }
    return {
      total: total,
      refIds: refIds
    };
  },
  /**
   * Get structural info of a DiagnosticReport by going though each level of observations
   * @param parentObxInfo the structural info of a parent Observation
   * @param parentRefId the instance ID of a parent Observation
   * @param diagnosticReport a DiagnosticReport instance
   * @private
   */
  _checkRepeatingItems: function (parentObxInfo, parentRefId, diagnosticReport) {
    var obxInfoList = [];
    var repeatingItemInfo = {};
    var obxIdList = [];

    // the report level
    if (!parentRefId && diagnosticReport.result) {
      for (var i = 0, iLen = diagnosticReport.result.length; i < iLen; i++) {
        obxIdList.push(diagnosticReport.result[i].reference);
      }
    }
    // obx level
    else {
      var parentObx = this._findObxById(parentRefId, diagnosticReport.contained);
      if (parentObx && parentObx.related) {
        for (var i = 0, iLen = parentObx.related.length; i < iLen; i++) {
          obxIdList.push(parentObx.related[i].target.reference);
        }
      }
    }

    // go through each observation instance
    for (var i = 0, iLen = obxIdList.length; i < iLen; i++) {
      var refId = obxIdList[i];
      var obx = this._findObxById(refId, diagnosticReport.contained);
      var itemCode = obx.code.coding[0].code;
      // first obx that has the same item code, either repeating or non-repeating
      if (!repeatingItemInfo[itemCode]) {
        var repeatingInfo = this._findTotalRepeatingNum(obxIdList, itemCode, diagnosticReport.contained);
        repeatingItemInfo[itemCode] = {
          total: repeatingInfo.total,
          refIds: repeatingInfo.refIds
        };
      }
      // create structure info for the obx
      var repeatingRefIds = repeatingItemInfo[itemCode].refIds;
      for (var j = 0, jLen = repeatingRefIds.length; j < jLen; j++) {
        if (refId === repeatingRefIds[j]) {
          var obxInfo = {
            code: itemCode,
            refId: refId,
            index: j,
            total: repeatingItemInfo[itemCode].total
          };
          // check observation instances in the sub level
          this._checkRepeatingItems(obxInfo, refId, diagnosticReport);
          obxInfoList.push(obxInfo);
        }
      }
    }
    parentObxInfo.obxInfoList = obxInfoList;
  },
  /**
   * Get structure information of a DiagnosticReport instance
   * @param diagnosticReport a DiagnosticReport instance
   * @returns {{}} a Diagnostic Report data structure object
   * @private
   */
  _getReportStructure: function (diagnosticReport) {
    var reportStructure = {
      obxInfoList: []
    };
    if (diagnosticReport) {
      this._checkRepeatingItems(reportStructure, null, diagnosticReport);
    }
    return reportStructure;
  },
  /**
   * Find a matching repeating item
   * @param parentItem a parent item
   * @param itemCode code of a repeating (or non-repeating) item
   * @param index index of the item in the sub item array of the parent item
   * @returns {{}} a matching item
   * @private
   */
  _findTheMatchingItemByCodeAndIndex: function (parentItem, itemCode, index) {
    var item = null;
    var idx = 0;
    if (parentItem.items) {
      for (var i = 0, iLen = parentItem.items.length; i < iLen; i++) {
        var subItem = parentItem.items[i];
        if (itemCode === subItem.questionCode) {
          if (subItem.dataType === "CODING" && subItem.answerCardinality && (subItem.answerCardinality.max === "*" || parseInt(subItem.answerCardinality.max) > 1)) {
            item = subItem;
            break;
          } else if (idx === index) {
            item = subItem;
            break;
          } else {
            idx += 1;
          }
        }
      }
    }
    return item;
  },
  /**
   * Add repeating items
   * @param parentItem a parent item
   * @param itemCode code of a repeating item
   * @param total total number of the repeating item with the same code
   * @private
   */
  _addRepeatingItems: function (parentItem, itemCode, total) {
    // find the first (and the only one) item
    var item = null;
    if (parentItem.items) {
      for (var i = 0, iLen = parentItem.items.length; i < iLen; i++) {
        if (itemCode === parentItem.items[i].questionCode) {
          item = parentItem.items[i];
          break;
        }
      }
      // insert new items unless it is a CODING and has multiple answers.
      if (item && !(item.dataType === "CODING" && item.answerCardinality && (item.answerCardinality.max === "*" || parseInt(item.answerCardinality.max) > 1))) {
        while (total > 1) {
          var newItem = LForms.Util.deepCopy(item);
          parentItem.items.splice(i, 0, newItem);
          total -= 1;
        }
      }
    }
  },
  /**
   * Merge Observation instances into items on the same level
   * @param parentObxInfo structural information of a parent item
   * @param parentItem a parent item
   * @param diagnosticReport a DiagnosticReport instance
   * @private
   */
  _processObxAndItem: function (parentObxInfo, parentItem, diagnosticReport) {
    for (var i = 0, iLen = parentObxInfo.obxInfoList.length; i < iLen; i++) {
      var obxInfo = parentObxInfo.obxInfoList[i];
      var obx = this._findObxById(obxInfo.refId, diagnosticReport.contained);
      if (obx) {
        // first repeating obx
        if (obxInfo.total > 1 && obxInfo.index === 0) {
          // add repeating items in form data
          this._addRepeatingItems(parentItem, obxInfo.code, obxInfo.total);
        }
        var item = this._findTheMatchingItemByCodeAndIndex(parentItem, obxInfo.code, obxInfo.index);
        this._setupItemValueAndUnit(obx, item);

        // process items on sub level
        if (obxInfo.obxInfoList && obxInfo.obxInfoList.length > 0) {
          this._processObxAndItem(obxInfo, item, diagnosticReport);
        }
      }
    }
  },
  /**
   * Convert a FHIR Bundle resource that includes a DiagnosticReport resource and associated Observation resources
   * to a DiagnosticReport resource with contained Observation resources
   * @param bundleDr a Bundle that includes a DiagnosticReport resource and associated Observation resources.
   *        Only "searchset" type is allowed.
   * @returns {{}} a DiagnosticReport resource with contained Observation resources
   */
  _convertFromBundleToContained: function (bundleDr) {
    var containedDr;
    // "searchset" is the only supported type at this point.
    if (bundleDr && bundleDr.type === "searchset") {
      var entry = bundleDr.entry;
      // find the DiagnosticReport in the bundle
      for (var i = 0, iLen = entry.length; i < iLen; i++) {
        if (entry[i].resource.resourceType === "DiagnosticReport") {
          containedDr = entry[i].resource;
          // change reference ids in result
          for (var j = 0, jLen = containedDr.result.length; j < jLen; j++) {
            var ref = containedDr.result[j];
            if (ref.reference && ref.reference.match(new RegExp(this._OBX_REF_PREFIX))) {
              ref.reference = ref.reference.slice(this._OBX_REF_PREFIX.length);
            }
          }
          containedDr.contained = [];
          break;
        }
      }
      // if DiagnosticReport is found
      if (containedDr) {
        // Move all Observation resource into "contained" field of the DiagnosticReport resource
        for (var i = 0, iLen = entry.length; i < iLen; i++) {
          if (entry[i].resource.resourceType === "Observation") {
            var obx = entry[i].resource;
            // change reference ids in related
            if (obx.related) {
              for (var j = 0, jLen = obx.related.length; j < jLen; j++) {
                var related = obx.related[j];
                if (related.target && related.target.reference && related.target.reference.match(new RegExp(this._OBX_REF_PREFIX))) {
                  related.target.reference = related.target.reference.slice(this._OBX_REF_PREFIX.length);
                }
              }
            }
            containedDr.contained.push(obx);
          }
        }
      }
    }
    return containedDr;
  },
  /**
   * Merge a DiagnosticReport instance into an LForms form definition or LFormsData object
   * @param formData an LForms form definition or LFormsData object.
   * @param diagnosticReport a DiagnosticReport resource with contained Observation resources,
   * or a Bundle that includes a DiagnosticReport resource and associated Observation resources
   * @param bundleType, optional, the FHIR Bundle type if inBundle is true.
   * @returns {{}} an updated LForms form definition, with answer data
   */
  mergeDiagnosticReportToLForms: function (formData, diagnosticReport) {
    if (!(formData instanceof LForms.LFormsData)) {
      // get the default settings in case they are missing in the form data
      // not to set item values by default values for saved forms with user data
      formData.hasSavedData = true;
      formData = new LForms.LFormsData(formData).getFormData();
    }
    var inBundle = diagnosticReport && diagnosticReport.resourceType === "Bundle";

    // move Observation resources in Bundle to be in "contained" in DiagnosticReport resource
    // as a base data structure for converting
    var dr = inBundle ? this._convertFromBundleToContained(diagnosticReport) : diagnosticReport;
    var reportStructure = this._getReportStructure(dr);
    this._processObxAndItem(reportStructure, formData, dr);
    return formData;
  }
};
/* harmony default export */ __webpack_exports__["default"] = (dr);

/***/ }),
/* 96 */
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   importFHIRQuantity: function() { return /* binding */ importFHIRQuantity; }
/* harmony export */ });
/*
 *  Defines import functions that are the same across the different FHIR
 *  versions and that are used by both the SDC and DiagnosticReport imports.
 */

/**
 *  Converts a FHIR Quantity to the an an LForms equivalent-- essentially, the
 *  unit object plus 'value' field.
 * @param quantity the quantity to be converted.
 * @return the quantity data with field labels appropriate for LForms.
 */
function importFHIRQuantity(quantity) {
  const rtn = {
    _type: 'Quantity',
    value: quantity.value
  };
  const unitOrCode = quantity.unit || quantity.code;
  if (unitOrCode) {
    rtn.name = unitOrCode; // in some data 'unit' is undefined
    if (quantity.code) rtn.code = quantity.code;
    if (quantity.system) rtn.system = quantity.system;
  }
  return rtn;
}

/***/ }),
/* 97 */
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _common_export_common_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(98);
// R4/R5-specific export code common to DiagnosticReport and SDC.


let self = Object.create(_common_export_common_js__WEBPACK_IMPORTED_MODULE_0__["default"]); // copies properties to self.prototype
Object.assign(self, {
  /**
   *  Creates a structure for use by _createObservation() in constructing an
   *  Observation value for the given integer value.
   * @param item an LForms item with the integer value to be represented in an Observation.
   *  It is assumed that the caller has already checked the data type.
   * @return an object with a "key" property that will be the property name for
   *  the value in the Observation object, and a "val" property that holds the
   *  value (formatted for the Observation).
   */
  _createObsIntValue: function (item) {
    // R4 added valueInteger to Observation, so we use that unless the item has
    // a unit, in which case we use valueQuantity.
    // valueQuantity.
    let rtn;
    if (item.unit) {
      let quantity = {
        value: item.value
      };
      this._setFHIRQuantityUnit(quantity, item.unit);
      rtn = {
        key: 'valueQuantity',
        val: quantity
      };
    } else rtn = {
      key: 'valueInteger',
      val: item.value
    };
    return rtn;
  }
});
/* harmony default export */ __webpack_exports__["default"] = (self);

/***/ }),
/* 98 */
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _fhir_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(1);
/* jshint -W097 */ // suppress jshint warning about strict
/* jshint node: true */ // suppress warning about "require"



var _versionTagStr = 'lformsVersion: ';

/**
 *  Defines export functions that are the same across the different FHIR
 *  versions and that are used by both the SDC and DiagnosticReport exports.
 */
var self = {
  /**
   *  Creates Observation resources from an LForms item object
   * @param item an LForms item object
   * @param setId (optional) a flag indicating if a unique ID should be set on the Observation resource
   * @returns {{}} an array of observation resources representing the values
   *  stored in the item.
   * @private
   */
  _createObservation: function (item, setId) {
    var values = [];
    var dataType = item.dataType;
    // any item has a unit must be a numerical type, let use REAL for now.
    if ((!dataType || dataType === "ST") && item.units && item.units.length > 0) {
      dataType = "REAL";
    }
    switch (dataType) {
      case "INT":
        values = [this._createObsIntValue(item)];
        break;
      case "REAL":
      // A "real" data type should be exported as valueQuantity, because
      // there is no valueDecimal for Observation (as of R4).
      case "QTY":
        var valValue = {
          value: item.value
        };
        this._setFHIRQuantityUnit(valValue, item.unit);
        values = [{
          key: "valueQuantity",
          val: valValue
        }];
        break;
      case "DT":
        values = [{
          key: "valueDate",
          val: item.value
        }];
        break;
      case "DTM":
        values = [{
          key: "valueDateTime",
          val: item.value
        }];
        break;
      case "CODING":
        var max = item.answerCardinality.max;
        // multiple values, each value creates a separate Observation resource
        var itemValues;
        if (max && (max === "*" || parseInt(max) > 1)) {
          itemValues = item.value;
        } else {
          itemValues = [item.value];
        }
        for (var j = 0, jLen = itemValues.length; j < jLen; j++) {
          var val = itemValues[j];
          if (typeof val === "object") {
            var coding = {};
            if (val.code) coding.code = val.code;
            if (val.text) coding.display = val.text;
            var codeSystem = val.system;
            if (codeSystem) coding.system = LForms.Util.getCodeSystem(codeSystem);
            values.push({
              key: "valueCodeableConcept",
              val: {
                "coding": [coding],
                "text": coding.display
              }
            });
          } else if (typeof val === "string") {
            if (val !== "") {
              values.push({
                key: "valueString",
                val: val
              });
            }
          }
        }
        break;
      case "attachment":
        values = [{
          key: "valueAttachment",
          val: item.value
        }];
        break;
      case "BL":
        values = [{
          key: "valueBoolean",
          val: item.value // undefined, null, or '' values should have been skipped before calling this function
        }];
        break;
      default:
        values = [{
          key: "valueString",
          val: item.value
        }];
    }
    var obxs = [];
    for (var i = 0, iLen = values.length; i < iLen; i++) {
      var obx = {
        "resourceType": "Observation",
        "status": "final",
        "code": {
          "coding": item._codesToExtract || item.codeList,
          "text": item.question
        }
      };
      this._addVersionTag(obx);
      if (setId) {
        obx.id = this._getUniqueId(item.questionCode);
      }
      if (!item.header) {
        obx[values[i].key] = values[i].val;
      }
      obxs.push(obx);
    }
    return obxs;
  },
  /**
   * Generate an almost unique ID for a given Observation code
   * @param prefix A prefix for the ID (e.g. a code or resource name)
   * @returns {string} a unique id
   * @private
   */
  _getUniqueId: function (prefix) {
    this._idCtr || (this._idCtr = 0);
    return prefix + "-" + Date.now() + '-' + ++this._idCtr + '-' + Math.random().toString(16).substr(2);
  },
  /**
   *  Sets the unit for a Quantity.
   * @param qty the FHIR Quantity structure whose unit will be set.  This
   *  function assumes there is no unit information already set.
   * @param unit An LForms unit object.
   */
  _setFHIRQuantityUnit: function (qty, unit) {
    if (unit) {
      if (unit.name) qty.unit = unit.name;
      if (unit.code) qty.code = unit.code;
      if (unit.system) qty.system = unit.system;
    }
  },
  /**
   *  Returns and creates if necessary the tag array object on the resource.  If
   *  created, the given resource will be modified.
   * @param res the resource whose tag array is needed.
   */
  _resTags: function (res) {
    var meta = res.meta;
    if (!meta) meta = res.meta = {};
    var tag = meta.tag;
    if (!tag) tag = meta.tag = [];
    return tag;
  },
  /**
   *  Sets the LForms version tag on a FHIR resource to indicate the LForms version used to
   *  export it.  This will replace any version tag already present.
   * @param res the resource object to be tagged.
   */
  _setVersionTag: function (res) {
    var tags = this._resTags(res);
    // Delete any lformsVersion tag present.  There should be at most one
    for (var i = 0, len = tags.length; i < len; ++i) {
      var t = tags[i];
      if (t.code && t.code.indexOf(_versionTagStr) === 0) {
        tags.splice(i, 1);
        break;
      }
    }
    this._addVersionTag(res);
  },
  /**
   *  Adds a tag to a FHIR resource to indicate the LForms version used to
   *  export it.  Assumes the version tag does not already exist.
   * @param res the resource object to be tagged.
   */
  _addVersionTag: function (res) {
    var tag = this._resTags(res);
    tag.push({
      code: _versionTagStr + LForms.lformsVersion
    });
  }
};
/* harmony default export */ __webpack_exports__["default"] = (self);

/***/ }),
/* 99 */
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/**
 * A package to handle FHIR Questionnaire and SDC Questionnaire and QuestionnaireResponse for LForms
 *
 * FHIR Questionnaire:
 * https://hl7.org/fhir/R5/questionnaire.html
 * https://hl7.org/fhir/R4/questionnaire.html
 *
 * SDC STU3 Questionnaire and QuestionnaireResponse:
 * https://hl7.org/fhir/uv/sdc/STU3/
 *
 */

var self = {
  /**
   *  Convert LForms captured data to a bundle consisting of a FHIR SDC
   *  QuestionnaireResponse and any extractable resources. (Currently this means
   *  any Observations that can be extracted via the observationLinkPeriod
   *  extension).
   *
   * @param lfData a LForms form object
   * @param noExtensions a flag that a standard FHIR Questionnaire is to be created without
   *  any extensions. The default is false.
   * @param subject A local FHIR resource that is the subject of the output resource.
   *  If provided, a reference to this resource will be added to the output FHIR
   *  resource when applicable.
   * @returns an array of QuestionnaireResponse and Observations.  Observations
   *  will have derivedFrom set to a temporary reference created for the returned
   *  QuestionnaireResponse (the first element of the array). The caller may
   *  wish to put all of the returned resources into a transaction Bundle for
   *  creating them on a FHIR server.
   */
  convertLFormsToQRAndExtractFHIRData: function (lfData, noExtensions, subject) {
    var qr = this.convertLFormsToQuestionnaireResponse(lfData, noExtensions, subject);
    if (!qr.id) {
      qr.id = this._commonExport._getUniqueId(qr.identifier && qr.identifier.value || "QR");
    }
    var qrRef = "QuestionnaireResponse/" + qr.id;
    var rtn = [qr];
    for (var i = 0, len = lfData.itemList.length; i < len; ++i) {
      var item = lfData.itemList[i];
      if (this._getExtractValue(item) && this._hasItemValue(item)) {
        const categCodeableConcepts = [];
        var ancestor = item;
        while (ancestor && !categCodeableConcepts.length) {
          if (ancestor.extension) {
            const categExts = LForms.Util.findObjectInArray(ancestor.extension, 'url', this.fhirExtObsExtractCategory, 0, true);
            categExts.forEach(x => categCodeableConcepts.push(x.valueCodeableConcept));
          }
          ancestor = ancestor._parentItem;
        }
        var obs = this._commonExport._createObservation(item);
        for (var j = 0, jLen = obs.length; j < jLen; j++) {
          // Following
          // http://hl7.org/fhir/uv/sdc/2019May/extraction.html#observation-based-extraction
          if (qr.basedOn) obs[j].basedOn = qr.basedOn;
          if (qr.partOf) obs[j].partOf = qr.partOf;
          if (qr.subject) obs[j].subject = qr.subject;
          if (qr.encounter) obs[j].encounter = qr.encounter;
          if (qr.authored) {
            obs[j].effectiveDateTime = qr.authored;
            obs[j].issued = qr.authored;
          }
          if (qr.author) obs[j].performer = qr.author;
          obs[j].derivedFrom = [{
            reference: qrRef
          }];
          if (categCodeableConcepts.length) obs[j].category = categCodeableConcepts;
          rtn.push(obs[j]);
        }
      }
    }
    return rtn;
  },
  /**
   *  Proceses the LForms questionCardinality into FHIR.
   * @param targetItem an item in Questionnaire
   * @param item a LForms item
   */
  _processQuestionCardinality: function (targetItem, item) {
    if (item.questionCardinality) {
      if (item.questionCardinality.max === "*") {
        targetItem.repeats = true;
      } else if (parseInt(item.questionCardinality.max) > 1) {
        targetItem.repeats = true;
        targetItem.extension.push({
          url: "http://hl7.org/fhir/StructureDefinition/questionnaire-maxOccurs",
          valueInteger: parseInt(item.questionCardinality.max)
        });
      }
    } else {
      // No default in R4
      // targetItem.repeats = false;
    }
  },
  /**
   * Handle special requirements for 'display' items
   * @param targetItem an item in Questionnaire
   * @param item a LForms item
   * @private
   */
  _handleSpecialConstraints: function (targetItem, item) {
    //Display items cannot have a "code" asserted
    //Required and repeat aren't permitted for display items
    //Read-only can't be specified for "display" items
    if (targetItem && item.dataType === "TITLE") {
      delete targetItem.code;
      delete targetItem.required;
      delete targetItem.repeats;
      delete targetItem.readOnly;
    }
  },
  /**
   * Process various restriction settings
   * @param targetItem an item in FHIR SDC Questionnaire object
   * @param item an item in LForms form object
   * @private
   */
  _handleRestrictions: function (targetItem, item) {
    // http://hl7.org/fhir/StructureDefinition/minLength
    // http://hl7.org/fhir/StructureDefinition/regex
    // http://hl7.org/fhir/StructureDefinition/minValue
    // http://hl7.org/fhir/StructureDefinition/maxValue
    // http://hl7.org/fhir/StructureDefinition/maxDecimalPlaces
    // http://hl7.org/fhir/StructureDefinition/maxSize, for attachment, not supported yet
    // maxLength
    if (item.restrictions) {
      for (var key in item.restrictions) {
        var value = item.restrictions[key];
        var extValue = null;
        var dataType = this._getAssumedDataTypeForExport(item);
        var valueKey = this._getValueKeyByDataType("value", item);
        switch (key) {
          // http://hl7.org/fhir/StructureDefinition/minValue
          // { // Must be >= this value
          //   // from Element: extension
          //   "url" : "http://hl7.org/fhir/StructureDefinition/minValue", // R!
          //   // value[x]: Value of extension. One of these 6:
          //   "valueDate" : "<date>" // R! Value of extension
          //   "valueDateTime" : "<dateTime>", // R! Value of extension
          //   "valueTime" : "<time>", // R! Value of extension
          //   "valueInstant" : "<instant>", // R! Value of extension
          //   "valueDecimal" : <decimal>, // R! Value of extension
          //   "valueInteger" : <integer>, // R! Value of extension
          // }
          case "minExclusive":
          case "minInclusive":
          // http://hl7.org/fhir/StructureDefinition/maxValue
          case "maxExclusive":
          case "maxInclusive":
            extValue = this._exportMinMax(dataType, value, valueKey, key);
            break;
          // http://hl7.org/fhir/StructureDefinition/minLength
          case "minLength":
            if (dataType === "ST" || dataType === "TX" || dataType === "URL" || dataType === "QTY") {
              extValue = {
                url: "http://hl7.org/fhir/StructureDefinition/minLength",
                valueInteger: parseInt(value)
              };
            }
            break;
          // maxLength, not an extension, directly on item
          case "maxLength":
            if (dataType === "ST" || dataType === "TX" || dataType === "URL" || dataType === "QTY") {
              targetItem.maxLength = parseInt(value);
            }
            break;
          // http://hl7.org/fhir/StructureDefinition/regex
          case "pattern":
            if (dataType === "ST" || dataType === "TX") {
              extValue = {
                url: "http://hl7.org/fhir/StructureDefinition/regex",
                valueString: value
              };
            }
            break;
          // http://hl7.org/fhir/StructureDefinition/maxDecimalPlaces
          case "maxDecimalPlaces":
            if (dataType === "REAL") {
              extValue = {
                // You can't use self.fhirExtUrlMaxDecimalPlaces. The self object won't have
                // the property because it goes through Object.assign() in fhirRequire.js.
                url: this.fhirExtUrlMaxDecimalPlaces,
                valueInteger: value
              };
            }
            break;
        }
        if (extValue) {
          targetItem.extension.push(extValue);
        }
      }
    }
  },
  /**
   *  Processes settings for a list field with choices.
   * @param targetItem an item in FHIR SDC Questionnaire object
   * @param item an item in the LForms form object
   */
  _handleChoiceField: function (targetItem, item) {
    // an extension for the search url of the auto-complete field.
    if (item.externallyDefined) {
      this._handleExternallyDefined(targetItem, item);
    }
    // option, for answer list
    else if (item.answerValueSet) {
      targetItem.answerValueSet = item.answerValueSet;
    } else if (item._answerValueSet) {
      // Restore answerValueSet property.
      targetItem.answerValueSet = item._answerValueSet;
    } else if (item.answers) {
      // Make sure the answers did not come from answerExpression.
      if (!item._fhirExt || !item._fhirExt[this.fhirExtAnswerExp]) targetItem.answerOption = this._handleAnswers(item);
    }
  },
  /**
   * Process an item's answer list
   * @param item an item in the LForms form object
   * @returns {Array}
   * @private
   */
  _handleAnswers: function (item) {
    var optionArray = [];
    for (var i = 0, iLen = item.answers.length; i < iLen; i++) {
      var answer = item.answers[i];
      var option = {};

      // when option's values are Coding
      if (item.dataType === "CODING") {
        option.valueCoding = {};
        if (answer.code) option.valueCoding.code = answer.code;
        if (answer.text) option.valueCoding.display = answer.text;
        if (answer.system) {
          option.valueCoding.system = LForms.Util.getCodeSystem(answer.system);
        }

        // Restore rendering-xhtml and rendering-style extensions on valueCoding._display.
        if (answer.obj_valueCoding_display) {
          option.valueCoding._display = answer.obj_valueCoding_display;
        }

        // check default answers, coding only for now
        if (item.defaultAnswer && item.dataType === "CODING") {
          var defaultAnswers = this._answerRepeats(item) && Array.isArray(item.defaultAnswer) ? item.defaultAnswer : [item.defaultAnswer];

          // go through each default value and set the initialSelected on the matching answer item
          for (var j = 0, jLen = defaultAnswers.length; j < jLen; j++) {
            if (LForms.Util.areTwoAnswersSame(defaultAnswers[j], answer, item)) {
              option.initialSelected = true;
            }
          }
        }
      }
      // when option's values are string, integer, date or time
      else if (item.dataType === "ST" || item.dataType === "INT" || item.dataType === "DT" || item.dataType === "TM") {
        var valueKey = this._getValueKeyByDataType("value", item);
        option[valueKey] = answer.text;
        // Restore rendering-xhtml and rendering-style extensions on _valueString,
        // _valueInteger, _valueDate, or _valueTime.
        if (answer[`obj_${valueKey}`]) {
          option[`_${valueKey}`] = answer[`obj_${valueKey}`];
        }
      }

      // label
      var ext = [];
      if (answer.label) {
        ext.push({
          url: "http://hl7.org/fhir/StructureDefinition/questionnaire-optionPrefix",
          valueString: answer.label
        });
      }
      if (answer.score !== null && answer.score !== undefined) {
        ext.push({
          url: this.fhirExtUrlOptionScore,
          valueDecimal: answer.score
        });
      }
      if (ext.length > 0) {
        option.extension = ext;
      }
      optionArray.push(option);
    }
    return optionArray;
  },
  /**
   * Process units list
   * @param targetItem an item in FHIR SDC Questionnaire object
   * @param item an item in LForms form object
   * @private
   */
  _handleLFormsUnits: function (targetItem, item) {
    if (item.units && item.units.length > 0) {
      var dataType = this._getAssumedDataTypeForExport(item);
      if (dataType === "REAL" || dataType === "INT") {
        targetItem.extension.push({
          url: this.fhirExtUrlUnit,
          // Datatype with multiple units is quantity. There is only one unit here.
          valueCoding: this._createFhirUnitCoding(item.units[0])
        });
      } else if (dataType === "QTY") {
        var defUnit = this._getDefaultUnit(item.units);
        // Skip if units are already set in default answer conversion.
        if (defUnit && defUnit.default && !(targetItem.initial && targetItem.initial.length > 0)) {
          // Use initial[].valueQuantity.unit to export the default unit.
          if (!targetItem.initial) {
            targetItem.initial = [];
          }
          var qty = {};
          this._setUnitAttributesToFhirQuantity(qty, defUnit);
          targetItem.initial.push({
            valueQuantity: qty
          });
        }
        for (var i = 0, iLen = item.units.length; i < iLen; i++) {
          var unit = item.units[i];
          var fhirUnitExt = {
            url: this.fhirExtUrlUnitOption,
            valueCoding: this._createFhirUnitCoding(unit)
          };
          targetItem.extension.push(fhirUnitExt);
        }
      }
    }
  },
  /**
   * Process skip logic
   * @param targetItem an item in FHIR SDC Questionnaire object
   * @param item an item in LForms form object
   * @param source a LForms form object
   * @private
   */
  _handleSkipLogic: function (targetItem, item, source) {
    if (item.skipLogic) {
      var enableWhen = [];
      var rangeFound = false;

      // ignore "ANY", "ALL" on item.skipLogic.logic
      // ignore "show" on item.skipLogic.action

      for (var i = 0, iLen = item.skipLogic.conditions.length; i < iLen; i++) {
        var condition = item.skipLogic.conditions[i];
        var sourceItem = source._getSkipLogicSourceItem(item, condition.source);
        let enableWhenRules = this._createEnableWhenRulesForSkipLogicCondition(condition, sourceItem);
        if (enableWhenRules.length > 1) {
          rangeFound = true;
        }
        enableWhen = enableWhen.concat(enableWhenRules);
      }
      if (rangeFound && item.skipLogic.conditions.length > 1) {
        // TODO: Multiple skip logic conditons included with range specification is not supported with core FHIR.
        // Use SDC extensions with fhirpath expressions, but not all fhirpath functionality is
        // available yet. Revisit after implementation of variables, %resource etc. in fhirpath.
        throw new Error("Multiple skip logic conditons included with range specification is not supported yet.");
      }
      targetItem.enableWhen = enableWhen;
      if (item.skipLogic.logic === "ALL" || rangeFound) {
        targetItem.enableBehavior = "all";
      } else if (enableWhen.length > 1) {
        targetItem.enableBehavior = "any";
      }
    }
  },
  /**
   * Set the qr.questionnaire
   * @param {*} target a FHIR QuestionnaireResponse object
   * @param {*} source a LForms form object
   */
  _processQRQuestionnaire: function (target, source) {
    if (source.url) {
      target.questionnaire = source.version ? source.url + "|" + source.version : source.url;
    }
  }
};
/* harmony default export */ __webpack_exports__["default"] = (self);

/***/ }),
/* 100 */
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/**
 *  Defines SDC export functions that are the same across the different FHIR
 *  versions.  The function takes the SDC namespace object defined in the sdc export
 *  code, and adds additional functions to it.
 */
function addCommonSDCExportFns(ns) {
  "use strict";

  var self = ns;

  /**
   * Convert LForms captured data to FHIR SDC QuestionnaireResponse
   * @param lfData a LForms form object
   * @param noExtensions a flag that a standard FHIR Questionnaire is to be created without any extensions.
   *  The default is false.
   * @param subject A local FHIR resource that is the subject of the output resource.
   *  If provided, a reference to this resource will be added to the output FHIR
   *  resource when applicable.
   * @returns {{}} a QuestionnaireResponse, or null if there is no valid QuestionnaireResponse.
   */
  self.convertLFormsToQuestionnaireResponse = function (lfData, noExtensions, subject) {
    var target = null;
    if (lfData) {
      var source = lfData.getFormData(true, true, true);
      if (!lfData._invalidData) {
        target = {};
        this._processRepeatingItemValues(source);
        this._setResponseFormLevelFields(target, source, noExtensions);
        if (this._processQRQuestionnaire) {
          this._processQRQuestionnaire(target, source);
        }
        if (source.items && Array.isArray(source.items)) {
          var tmp = this._processResponseItem(source, true);
          if (tmp && tmp.item && tmp.item.length) {
            target.item = tmp.item;
          }
        }

        // FHIR doesn't allow null values, strip them out.
        LForms.Util.pruneNulls(target);
        if (subject) target["subject"] = LForms.Util.createLocalFHIRReference(subject);
        this._commonExport._setVersionTag(target);
      }
    }
    return target;
  };

  /**
   * Convert LForms form definition to standard FHIR Questionnaire or FHIR SDC Questionnaire
   * @param lfData a LForms form object
   * @returns {{}}
   */
  self.convertLFormsToQuestionnaire = function (lfData) {
    var target = {};
    if (lfData) {
      var source = LForms.Util.deepCopy(lfData);
      if (!(source instanceof LForms.LFormsData)) {
        source = new LForms.LFormsData(source);
      }
      this._removeRepeatingItems(source);
      this._setFormLevelFields(target, source);
      if (source.items && Array.isArray(source.items)) {
        target.item = [];
        for (var i = 0, iLen = source.items.length; i < iLen; i++) {
          var newItem = this._processItem(source.items[i], source);
          target.item.push(newItem);
        }
      }
    }

    // FHIR doesn't allow null values, strip them out.
    LForms.Util.pruneNulls(target);
    this._commonExport._setVersionTag(target);
    return target;
  };

  /**
   * Process an item of the form
   * @param item an item in LForms form object
   * @param source a LForms form object
   * @returns {{}}
   * @private
   */
  self._processItem = function (item, source) {
    var targetItem = {};

    // type
    targetItem.type = this._getFhirDataType(item);

    // answerConstraint
    if (this._handleAnswerConstraint) {
      this._handleAnswerConstraint(targetItem, item);
    }

    // id (empty for new record)

    // code
    if (item.codeList && item.codeList.length > 0) {
      targetItem.code = item.codeList;
    }

    // extension
    targetItem.extension = item.extension || []; // later we delete if empty

    // required, the default value is false
    if (item._answerRequired === true) {
      targetItem.required = item._answerRequired;
    }

    // http://hl7.org/fhir/StructureDefinition/questionnaire-minOccurs
    if (targetItem.required) {
      var minOccurInt = parseInt(item.questionCardinality.min);
      if (minOccurInt > 1) {
        targetItem.extension.push({
          "url": "http://hl7.org/fhir/StructureDefinition/questionnaire-minOccurs",
          "valueInteger": minOccurInt
        });
      }
    }

    // question/answer repeats
    // http://hl7.org/fhir/StructureDefinition/questionnaire-maxOccurs
    this._processQuestionAndAnswerCardinality(targetItem, item);

    // http://hl7.org/fhir/StructureDefinition/questionnaire-itemControl
    this._handleItemControl(targetItem, item);

    // check restrictions
    this._handleRestrictions(targetItem, item);

    // http://hl7.org/fhir/StructureDefinition/entryFormat
    // looks like tooltip, TBD

    if (item.isHiddenInDef) {
      targetItem.extension.push({
        url: "http://hl7.org/fhir/StructureDefinition/questionnaire-hidden",
        valueBoolean: true
      });
    }

    // linkId
    targetItem.linkId = item.linkId;

    // Text & prefix
    targetItem.text = item.question;
    if (item.prefix) {
      targetItem.prefix = item.prefix;
    }
    // Copy item extensions
    for (let extField of ['_prefix', '_text']) {
      let extFieldData = item['obj' + extField];
      if (extFieldData) targetItem[extField] = extFieldData;
    }

    // enableWhen
    if (item.skipLogic) {
      this._handleSkipLogic(targetItem, item, source);
    }

    // repeats, handled above
    // readonly, (editable)
    if (item.dataType !== "SECTION" && item.dataType !== "TITLE" && item.editable === "0") {
      targetItem.readOnly = true;
    }
    this._handleChoiceField(targetItem, item);
    this._handleTerminologyServer(targetItem, item);

    // initialValue, for default values
    this._handleInitialValues(targetItem, item);
    // add LForms Extension to units list. Process units after handling initial values.
    if (item.units) {
      this._handleLFormsUnits(targetItem, item);
    }
    // data control
    this._handleDataControl(targetItem, item);

    // disabledDisplay
    if (this._handleDisabledDisplay) {
      this._handleDisabledDisplay(targetItem, item);
    }
    if (item.items && Array.isArray(item.items)) {
      targetItem.item = [];
      for (var i = 0, iLen = item.items.length; i < iLen; i++) {
        var newItem = this._processItem(item.items[i], source);
        targetItem.item.push(newItem);
      }
    }

    // the coding instruction is a sub item with a "display" type, and an item-control value as "help"
    // it is added as a sub item of this item.
    // http://hl7.org/fhir/StructureDefinition/questionnaire-itemControl, for instructions
    if (item.codingInstructions) {
      let helpItem = {
        "text": item.codingInstructionsPlain ? item.codingInstructionsPlain : item.codingInstructions,
        "type": "display",
        "linkId": item.codingInstructionsLinkId || targetItem.linkId + "-help",
        "extension": [{
          "url": "http://hl7.org/fhir/StructureDefinition/questionnaire-itemControl",
          "valueCodeableConcept": {
            "text": "Help-Button",
            "coding": [{
              "code": "help",
              "display": "Help-Button",
              "system": "http://hl7.org/fhir/questionnaire-item-control"
            }]
          }
        }]
      };

      // format could be 'html' or 'text'
      if (item.codingInstructionsFormat === 'html') {
        // add a "_text" field to contain the extension for the string value in the 'text' field
        // see http://hl7.org/fhir/R4/json.html#primitive
        helpItem._text = {
          "extension": [{
            "url": "http://hl7.org/fhir/StructureDefinition/rendering-xhtml",
            "valueString": item.codingInstructions
          }]
        };
      }

      // rendering-style extension
      if (item._obj_helpCSS) {
        helpItem._text = helpItem._text || {
          "extension": []
        };
        helpItem._text.extension.push({
          "url": "http://hl7.org/fhir/StructureDefinition/rendering-style",
          "valueString": item._obj_helpCSS
        });
      }
      if (Array.isArray(targetItem.item)) {
        targetItem.item.push(helpItem);
      } else {
        targetItem.item = [helpItem];
      }
    }

    // the legal is a sub item with a "display" type, and an item-control value as "legal"
    // it is added as a sub item of this item.
    // http://hl7.org/fhir/StructureDefinition/questionnaire-itemControl, for instructions
    if (item.legal) {
      let legalItem = {
        "text": item.legalPlain ? item.legalPlain : item.legal,
        "type": "display",
        "linkId": item.legalLinkId || targetItem.linkId + "-legal",
        "extension": [{
          "url": "http://hl7.org/fhir/StructureDefinition/questionnaire-itemControl",
          "valueCodeableConcept": {
            "text": "Legal-Button",
            "coding": [{
              "code": "legal",
              "display": "Legal-Button",
              "system": "http://hl7.org/fhir/questionnaire-item-control"
            }]
          }
        }]
      };

      // format could be 'html' or 'text'
      if (item.legalFormat === 'html') {
        // add a "_text" field to contain the extension for the string value in the 'text' field
        // see http://hl7.org/fhir/R4/json.html#primitive
        legalItem._text = {
          "extension": [{
            "url": "http://hl7.org/fhir/StructureDefinition/rendering-xhtml",
            "valueString": item.legal
          }]
        };
      }

      // rendering-style extension
      if (item._obj_legalCSS) {
        legalItem._text = legalItem._text || {
          "extension": []
        };
        legalItem._text.extension.push({
          "url": "http://hl7.org/fhir/StructureDefinition/rendering-style",
          "valueString": item._obj_legalCSS
        });
      }
      if (Array.isArray(targetItem.item)) {
        targetItem.item.push(legalItem);
      } else {
        targetItem.item = [legalItem];
      }
    }
    if (item.maxAttachmentSize) {
      var exts = targetItem.extension || (targetItem.extension = []);
      exts.push({
        url: self.fhirExtMaxSize,
        valueDecimal: item.maxAttachmentSize
      });
    }
    if (item.allowedAttachmentTypes) {
      exts = targetItem.extension || (targetItem.extension = []);
      for (let type of item.allowedAttachmentTypes) {
        exts.push({
          url: self.fhirExtMimeType,
          valueCode: type
        });
      }
    }

    // handle special constraints for "display" item
    this._handleSpecialConstraints(targetItem, item);

    // if there is no extension, remove it
    if (targetItem.extension.length === 0) delete targetItem.extension;
    this.copyFields(item, targetItem, this.itemLevelIgnoredFields);
    return targetItem;
  };

  /**
   * Process the LForms questionCardinality and answerCardinality into FHIR.
   * @param targetItem an item in Questionnaire
   * @param item a LForms item
   */
  self._processQuestionAndAnswerCardinality = function (targetItem, item) {
    var maxOccurs = 0;
    var qCard = item.questionCardinality,
      aCard = item.answerCardinality;
    var qCardMax = qCard && qCard.max !== undefined ? qCard.max : null;
    var aCardMax = aCard && aCard.max !== undefined ? aCard.max : null;

    // unlimited repeats, no need to set maxOccurs
    if (qCardMax === "*" || aCardMax === "*") {
      if (item.dataType !== "TITLE") {
        targetItem.repeats = true;
      }
    }
    // not unlimited repeats
    else {
      var intQCardMax = parseInt(qCardMax),
        intACardMax = parseInt(aCardMax);
      // has a maxOcurrs value
      if (intQCardMax > 1 || intACardMax > 1) {
        if (item.dataType !== "TITLE") {
          targetItem.repeats = true;

          // get the maxOccurs value
          if (!isNaN(intQCardMax) && !isNaN(intACardMax)) {
            maxOccurs = Math.max(intQCardMax, intACardMax);
          } else if (!isNaN(intQCardMax)) {
            maxOccurs = intQCardMax;
          } else if (!isNaN(intACardMax)) {
            maxOccurs = intACardMax;
          }
          if (maxOccurs > 1) {
            targetItem.extension.push({
              "url": self.fhirExtUrlCardinalityMax,
              "valueInteger": maxOccurs
            });
          }
        }
      }
    }
  };

  /**
   * Process an item's externally defined answer list
   * @param targetItem an item in FHIR SDC Questionnaire object
   * @param item an item in the LForms form object
   * @returns {*}
   * @private
   */
  self._handleExternallyDefined = function (targetItem, item) {
    if (item.externallyDefined) {
      targetItem.extension.push({
        "url": self.fhirExtUrlExternallyDefined,
        "valueUri": item.externallyDefined
      });
    }
  };

  /**
   * Process an item's data control
   * @param targetItem an item in FHIR SDC Questionnaire object
   * @param item an item in the LForms form object
   * @returns {*}
   * @private
   */
  self._handleDataControl = function (targetItem, item) {
    if (item.dataControl) {
      targetItem.extension.push({
        "url": "http://lhcforms.nlm.nih.gov/fhirExt/dataControl",
        "valueString": JSON.stringify(item.dataControl)
      });
    }
  };

  /**
   * Remove repeating items in a form data object
   * @param source a LForms form data object
   * @private
   */
  self._removeRepeatingItems = function (source) {
    if (source.items && Array.isArray(source.items)) {
      for (var i = source.items.length - 1; i >= 0; i--) {
        // if it is a repeating item, whose _id is not 1
        if (source.items[i]._id > 1) {
          source.items.splice(i, 1);
        } else {
          this._removeRepeatingItems(source.items[i]);
        }
      }
    }
  };

  /**
   * Set form level attributes
   * @param target a Questionnaire object
   * @param source a LForms form object
   * @private
   */
  self._setFormLevelFields = function (target, source) {
    this.copyFields(source, target, this.formLevelFields);
    // Handle title and name.  In LForms, "name" is the "title", but FHIR
    // defines both.
    target.name = source.shortName; // computer friendly
    target.title = source.name;

    // Handle extensions on title
    if (source.obj_title) target._title = source.obj_title;
    target.code = source.codeList;

    // resourceType
    target.resourceType = "Questionnaire";
    target.status = target.status ? target.status : "draft";

    // handle lforms copyright
    if (source.copyrightNotice) {
      target.copyright = source.copyrightNotice;
    }

    // meta
    this._handleMeta(target);
  };

  /**
   * Handle Questionnaire.meta field
   */
  self._handleMeta = function (targetFhirQ) {
    targetFhirQ.meta = targetFhirQ.meta ? targetFhirQ.meta : {};
    // Handle profiles
    this._handleMetaProfile(targetFhirQ.meta);
  };

  /**
   * Handle Questionnaire.meta field
   *
   * Follows these rules:
   * -------------
   * 1) For new questionnaires, we just export with the standard profile
   * 2) When we import and questionnaire which had meta.profile set, look for the highest version of
   *      FHIR listed in meta.profile.
   * 3) User will (optionally) be able to say which version of FHIR they want when uploading a file
   *      (or using the lforms API)
   * 4) When we export a questionnaire that we imported and which had meta.profile set,
   *      we will set the standard profile for that FHIR version, and remove known conflicting profile URIs.
   *  ------------
   * @param meta - The target questionnaire.meta to update.
   * @private
   */
  self._handleMetaProfile = function (meta) {
    const thisVersion = this.fhirVersion;
    const retainedProfiles = [];
    if (meta.profile?.length > 0) {
      for (let i = 0; i < meta.profile.length; i++) {
        const ver = LForms.Util.detectFHIRVersionFromProfiles([meta.profile[i]]);
        if (!ver || ver === thisVersion && meta.profile[i] !== this.stdQProfile) {
          // Keep profiles of this version and unknown. Others are conflicting, discard them.
          retainedProfiles.push(meta.profile[i]);
        }
      }
    }
    retainedProfiles.push(this.stdQProfile);
    meta.profile = retainedProfiles;
  };

  /**
   * Process itemControl based on LForms item's answerLayout and questionLayout
   * @param targetItem an item in FHIR SDC Questionnaire object
   * @param item an item in LForms form object
   * @private
   */
  self._handleItemControl = function (targetItem, item) {
    // http://hl7.org/fhir/StructureDefinition/questionnaire-itemControl
    var itemControlType = "";
    var itemControlDisplay, answerChoiceOrientation;
    // Fly-over, Table, Checkbox, Combo-box, Lookup
    if (!LForms.jQuery.isEmptyObject(item.displayControl)) {
      var dataType = this._getAssumedDataTypeForExport(item);
      // for answers
      if (item.displayControl.answerLayout && (item.dataType === "CODING" || item.answers && (item.dataType === "ST" || item.dataType === "INT" || item.dataType === "DT" || item.dataType === "TM"))) {
        // search field
        if (item.externallyDefined || item.answerValueSet && item.isSearchAutocomplete) {
          itemControlType = "autocomplete";
          itemControlDisplay = "Auto-complete";
        }
        // prefetch list
        // combo-box
        else if (item.displayControl.answerLayout.type === "COMBO_BOX") {
          itemControlType = "drop-down";
          itemControlDisplay = "Drop down";
        }
        // radio or checkbox
        else if (item.displayControl.answerLayout.type === "RADIO_CHECKBOX") {
          if (item.answerCardinality && (item.answerCardinality.max === "*" || parseInt(item.answerCardinality.max) > 1)) {
            itemControlType = "check-box";
            itemControlDisplay = "Check-box";
          } else {
            itemControlType = "radio-button";
            itemControlDisplay = "Radio Button";
          }
          // answer choice orientation
          if (item.displayControl.answerLayout.columns === "0") {
            answerChoiceOrientation = "horizontal";
          } else if (item.displayControl.answerLayout.columns === "1") {
            answerChoiceOrientation = "vertical";
          }
        }
      }
      // for section item
      else if (item.displayControl.questionLayout && dataType === "SECTION") {
        if (item.displayControl.questionLayout === "horizontal") {
          itemControlType = "gtable"; // Not in STU3, but the binding is extensible, so we can use it
          itemControlDisplay = "Group Table";
        } else if (item.displayControl.questionLayout === "matrix") {
          itemControlType = "table";
          itemControlDisplay = "Vertical Answer Table";
        }
        // else {
        //   itemControlType = "List";
        // }
      }
      if (itemControlType) {
        targetItem.extension.push({
          "url": "http://hl7.org/fhir/StructureDefinition/questionnaire-itemControl",
          "valueCodeableConcept": {
            "coding": [{
              //"system" : "<uri>", // Identity of the terminology system
              //"version" : "<string>", // Version of the system - if relevant
              //"code" : "<code>", // Symbol in syntax defined by the system
              //"display" : "<string>", // Representation defined by the system
              //"userSelected" : <boolean> // If this coding was chosen directly by the user
              "system": "http://hl7.org/fhir/questionnaire-item-control",
              "code": itemControlType,
              "display": itemControlDisplay
            }],
            "text": itemControlDisplay || itemControlType
          }
        });
        // answer choice orientation
        if (answerChoiceOrientation) {
          targetItem.extension.push({
            "url": "http://hl7.org/fhir/StructureDefinition/questionnaire-choiceOrientation",
            "valueCode": answerChoiceOrientation
          });
        }
      }
    }
  };

  /**
   * Process an item's terminology server setting.
   * @param targetItem a QuestionnaireResponse object
   * @param item an item in the LForms form object
   * @returns {*}
   * @private
   */
  self._handleTerminologyServer = function (targetItem, item) {
    if (item.terminologyServer) {
      targetItem.extension.push({
        "url": self.fhirExtTerminologyServer,
        "valueUrl": item.terminologyServer
      });
    }
  };

  /**
   * Determine how an item's data type should be for export.
    If number type has multiple units, change it to quantity type. In such a case,
   multiple units are converted to quesionnaire-unitOption extension and the default unit
   would go into initial.valueQuantity.unit.
   For single unit numbers, use the same type, whose unit will be in questionnaire-unit extension.
    * @param item an item in the LForms form object
   * @returns {string} dataType - Data type in lforms
   * @private
   */
  self._getAssumedDataTypeForExport = function (item) {
    var dataType = item.dataType;
    if ((item.dataType === 'REAL' || item.dataType === 'INT') && item.units && item.units.length > 1) {
      dataType = 'QTY';
    }
    return dataType;
  };

  /**
   * Make a FHIR Quantity for the given value and unit info.
   * @param value optional, must be an integer or decimal
   * @param itemUnit optional, lform data item.unit (that has a name property)
   * @param unitSystem optional, overrides any system in itemUnit.
   * @return a FHIR quantity or null IFF the given value is not a number (parseFloat() returns NaN).
   * @private
   */
  self._makeValueQuantity = function (value, itemUnit, unitSystem) {
    let fhirQuantity = {};
    let floatValue = parseFloat(value);
    if (!isNaN(floatValue)) {
      fhirQuantity.value = floatValue;
    }
    if (itemUnit) {
      self._setUnitAttributesToFhirQuantity(fhirQuantity, itemUnit);
      if (unitSystem) {
        fhirQuantity.system = unitSystem;
      }
    }
    return Object.keys(fhirQuantity).length > 0 ? fhirQuantity : null;
  };

  /**
   * Make a FHIR Quantity for the given value and unit info.
   * @param value required, must be an integer or decimal
   * @param itemUnits optional, lform data item.units (An array of units)
   * @param unitSystem optional.
   * @return a FHIR quantity or null IFF the given value is not a number (parseFloat() returns NaN).
   * @private
   */
  self._makeQuantity = function (value, itemUnits, unitSystem) {
    var defaultUnit = this._getDefaultUnit(itemUnits);
    return this._makeValueQuantity(value, defaultUnit, unitSystem);
  };

  /**
   * Pick a default unit if found, otherwise return first one as default. Will return
   * null, if passed with empty list.
   * @param lformsUnits - Array of lforms units i.e with {name, default}
   * @returns {*} Return lforms unit if found otherwise null.
   * @private
   */
  self._getDefaultUnit = function (lformsUnits) {
    if (!lformsUnits || lformsUnits.length === 0) {
      return null;
    }
    var ret = null;
    for (var i = 0; i < lformsUnits.length; i++) {
      if (lformsUnits[i].default) {
        ret = lformsUnits[i];
        break;
      }
    }
    if (!ret) {
      ret = lformsUnits[0];
    }
    return ret;
  };

  /**
   * Create a key from data type to be used in a hash
   * @param prefix a prefix to be added to the key
   * @param item a LForms item
   * @returns {*}
   * @private
   */
  self._getValueKeyByDataType = function (prefix, item) {
    // prefix could be 'value', 'initial', 'answer'
    if (!prefix) {
      prefix = "value";
    }
    var fhirType = this._getFhirDataType(item);
    var dataType = fhirType === 'quantity' ? 'QTY' : item.dataType;
    var valueKey = this._lformsTypesToFHIRFields[dataType];
    return prefix + valueKey;
  };

  /**
   * Convert the minInclusive/minExclusive, maxInclusive/maxExclusive to FHIR. See the
   * the function _handleRestrictions() in sdc-export.js for more details on the context.
   * @param dataType Lforms data type, currently supporting DT, DTM, TM, REAL, and INT.
   * @param value the value (in the lforms system, either a number or a string).
   * @param valueKey the valueKey in FHIR minValue/maxValue extension (e.g., valueInteger)
   * @param minMaxKey must be one of minInclusive, minExclusive, maxInclusive, maxExclusive
   * @return The FHIR extension element. Specifically, undefined is returned if:
   *         - the given value is null or undefined, or
   *         - the dataType is not one of those listed above, or
   *         - the minMaxKey is not one of those listed above
   * @private
   */
  self._MIN_MAX_TYPES = ['DT', 'DTM', 'TM', 'REAL', 'INT'].reduce((map, t) => {
    map[t] = t;
    return map;
  }, {});
  self._MIN_MAX_KEYS = ['minExclusive', 'minInclusive', 'maxExclusive', 'maxInclusive'].reduce((map, t) => {
    map[t] = t;
    return map;
  }, {});
  self._exportMinMax = function (dataType, value, valueKey, minMaxKey) {
    if (value === null || value === undefined || !self._MIN_MAX_TYPES[dataType] || !self._MIN_MAX_KEYS[minMaxKey]) {
      return undefined;
    }
    var isoDateStr = dataType === "DT" || dataType === "DTM" ? new Date(value).toISOString() : dataType == "TM" ? new Date('1970-01-01T' + value + 'Z').toISOString() : null;
    var fhirValue = dataType === "DT" ? isoDateStr.substring(0, 10) : dataType === "DTM" ? isoDateStr : dataType === "TM" ? isoDateStr.substring(11, isoDateStr.length - 1) : dataType === "REAL" ? parseFloat(value) : parseInt(value);
    var fhirExtUrl = minMaxKey.indexOf('min') === 0 ? 'http://hl7.org/fhir/StructureDefinition/minValue' : 'http://hl7.org/fhir/StructureDefinition/maxValue';
    return {
      url: fhirExtUrl,
      [valueKey]: fhirValue
    };
  };

  // known source data types (besides CODING) in skip logic export handling,
  // see _createEnableWhenRulesForSkipLogicCondition below
  self._skipLogicValueDataTypes = ["BL", "REAL", "INT", 'QTY', "DT", "DTM", "TM", "ST", "TX", "URL"].reduce((map, type) => {
    map[type] = type;
    return map;
  }, {});

  /**
   * @param skipLogicCondition - Lforms skip logic condition object
   * @param sourceItem - Skip logic source item in lforms.
   * @return {Array} FHIR enableWhen array
   * @private
   */
  self._createEnableWhenRulesForSkipLogicCondition = function (skipLogicCondition, sourceItem) {
    // dataTypes:
    // boolean, decimal, integer, date, dateTime, instant, time, string, uri,
    // Attachment, Coding, Quantity, Reference(Resource)
    let sourceDataType = this._getAssumedDataTypeForExport(sourceItem);
    let sourceValueKey = this._getValueKeyByDataType("answer", sourceItem);
    let enableWhenRules = [];

    // Per lforms spec, the trigger keys can be:
    // exists, value, minExclusive, minInclusive, maxExclusive, maxInclusive
    Object.keys(skipLogicCondition.trigger).forEach(function (key) {
      let operator = self._operatorMapping[key];
      let triggerValue = skipLogicCondition.trigger[key];
      if (!operator || triggerValue !== 0 && triggerValue !== false && !triggerValue) {
        throw new Error('Invalid lforms skip logic trigger: ' + JSON.stringify(skipLogicCondition.trigger, null, 4));
      }
      let rule = null;
      if (operator === 'exists') {
        rule = {
          answerBoolean: triggerValue
        };
      }
      // for Coding
      // multiple selections, item.value is an array
      // NO support of multiple selections in FHIR SDC, just pick one
      else if (sourceDataType === 'CODING') {
        let answerCoding = self._copyTriggerCoding(triggerValue, null, true);
        if (!answerCoding) {
          throw new Error('Invalid CODING trigger, key=' + key + '; value=' + triggerValue);
        }
        rule = {
          answerCoding: answerCoding
        };
      } else if (sourceDataType && self._skipLogicValueDataTypes[sourceDataType]) {
        let answer = triggerValue;
        if (sourceValueKey === 'answerQuantity') {
          answer = self._makeQuantity(answer, sourceItem.units);
        }
        if (answer === 0 || answer === false || answer) {
          rule = {
            [sourceValueKey]: answer
          };
        } else {
          throw new Error('Invalid value for trigger ' + key + ': ' + triggerValue);
        }
      } else {
        throw new Error('Unsupported data type for skip logic export: ' + sourceDataType);
      }
      rule.question = sourceItem.linkId;
      rule.operator = operator;
      enableWhenRules.push(rule);
    });
    return enableWhenRules;
  };

  /**
   * Set form level attribute
   * @param target a QuestionnaireResponse object
   * @param source a LForms form object
   * @param noExtensions  a flag that a standard FHIR Questionnaire is to be created without any extensions.
   *        The default is false.
   * @private
   */
  self._setResponseFormLevelFields = function (target, source, noExtensions) {
    // resourceType
    target.resourceType = "QuestionnaireResponse";

    // meta.profile - set the standard profile
    target.meta = target.meta ? target.meta : {};
    target.meta.profile = [this.stdQRProfile];

    // "identifier": - not including identifier in QuestionnaireResponse per LF-1183
    //target.identifier = {
    //  "system": LForms.Util.getCodeSystem(source.codeSystem),
    //  "value": source.code
    //};

    // status, required
    // "in-progress", "completed", "amended"
    target.status = "completed";

    // authored, required
    target.authored = LForms.Util.dateToDTMString(new Date());

    // questionnaire , required
    // We do not have the ID at this point, so leave it unset for now.  Note
    // that the format has also changed from Reference to canonical in R4.
    /*
    target.questionnaire = {
      // questionnaireId should be an id of a related existing questionnaire resource stored in the server
      "reference": "Questionnaire/{{questionnaireId}}"
    };
    */
  };

  /**
   * Set unit attributes to a given FHIR quantity.
   *
   * @param fhirQuantity - FHIR Quantity object
   * @param lfUnit - Lforms unit, which includes name, code and system.
   * @private
   */
  self._setUnitAttributesToFhirQuantity = function (fhirQuantity, lfUnit) {
    if (fhirQuantity && lfUnit) {
      if (lfUnit.name) {
        fhirQuantity.unit = lfUnit.name;
      }
      if (lfUnit.code) {
        fhirQuantity.code = lfUnit.code;
      }

      // Unit system is optional. It was using a default system before,
      // Now we have an defined system field, read it from data and
      // not assume a default.
      if (lfUnit.system) {
        fhirQuantity.system = lfUnit.system;
      }
    }
  };

  /**
   * Create a FHIR coding object for a unit.
   *
   * @param lfUnit - Lforms unit, which includes name, code and system.
   * @returns FHIR coding object
   * @private
   */
  self._createFhirUnitCoding = function (lfUnit) {
    var ret = null;
    if (lfUnit) {
      ret = {};
      if (lfUnit.code) {
        ret.code = lfUnit.code;
      }
      if (lfUnit.name) {
        ret.display = lfUnit.name;
      }
      if (lfUnit.system) {
        ret.system = lfUnit.system;
      }
    }
    return ret;
  };

  /**
   * Check if an lform item has sub-items, that is, having an "items" field whose value is an array with non-zero length.
   * @param item the item to be checked for the presense of sub-items.
   * @return {*|boolean} true if the item has sub-items, false otherwise.
   * @private
   */
  self._lfHasSubItems = function (item) {
    return item && item.items && Array.isArray(item.items) && item.items.length > 0;
  };

  /**
   * Process an item of the form or the form itself - if it's the form itself, the form-level
   * properties will not be set here and will need to be managed outside of this function.
   * If the lforms item is repeatable, this function handles one particular occurrence of the item.
   * @param lfItem an item in LForms form object, or the form object itself
   * @param isForm optional, default false. If true, the given item is the form object itself.
   * @returns {{}} the converted FHIR item, or null if the QuestionnaireResponse should not contain
   *  a corresponding item.
   * @private
   */
  self._processResponseItem = function (lfItem, isForm) {
    if (isForm && typeof isForm !== 'boolean') {
      // just in case some are invoking it the old way.
      throw new Error('_processResponseItem function signature has been changed, please check/fix.');
    }
    let targetItem = null;

    // just handle/convert the current item's value, no-recursion to sub-items at this step.
    let isUnansweredQuestion = false;
    if (!isForm && lfItem.dataType !== 'TITLE' && lfItem.dataType !== 'SECTION') {
      targetItem = this._setIfHasValue(targetItem, 'answer', this._lfItemValueToFhirAnswer(lfItem));
      isUnansweredQuestion = !targetItem?.answer;
    }
    if (!isUnansweredQuestion) {
      if (!targetItem) targetItem = {};
      if (!isForm && lfItem.dataType != 'TITLE') {
        targetItem.linkId = lfItem.linkId, targetItem.text = lfItem.question;
      }

      // Process sub-items
      if (this._lfHasSubItems(lfItem)) {
        var fhirItems = [];
        for (var i = 0; i < lfItem.items.length; ++i) {
          var lfSubItem = lfItem.items[i];
          if (!lfSubItem._isProcessed) {
            var linkId = lfSubItem.linkId;
            var repeats = lfItem._repeatingItems && lfItem._repeatingItems[linkId];
            if (repeats) {
              // Can only be questions here per _processRepeatingItemValues
              let fhirItem = {
                // one FHIR item for all repeats with the same linkId
                linkId: linkId,
                text: lfSubItem.question,
                answer: []
              };
              for (var rpt = 0; rpt < repeats.length; ++rpt) {
                var rptItem = repeats[rpt];
                var tmpFhirItem = this._processResponseItem(rptItem);
                if (tmpFhirItem?.answer) {
                  // TODO: not sure how to handle cases when both (lforms) question and answer repeat.
                  // For now, just put all the answers from question and answer repeats into the answer (array).
                  Array.prototype.push.apply(fhirItem.answer, tmpFhirItem.answer);
                }
                rptItem._isProcessed = true;
              }
              if (fhirItem.answer.length > 0) fhirItems.push(fhirItem);
              delete lfItem._repeatingItems[linkId]; // cleanup, no longer needed
            } else {
              let fhirItem = this._processResponseItem(lfSubItem);
              if (fhirItem) fhirItems.push(fhirItem);
            }
          }
          if (lfSubItem._isProcessed) {
            delete lfSubItem._isProcessed; // cleanup, no longer needed
          }
        }
        if (fhirItems.length > 0) {
          if (!isForm && lfItem.dataType !== 'SECTION') {
            // Question repeat is handled at the "parent level"; TODO: not sure how to handle answer repeat here,
            // assuming it isn't possible for an item to have answer repeat and sub-items at the same time.
            // (TODO:  The above is an incorrect assumption.)
            targetItem.answer = targetItem.answer || [];
            targetItem.answer[0] = targetItem.answer[0] || {};
            targetItem.answer[0].item = fhirItems;
          } else {
            targetItem.item = fhirItems;
          }
        }
      }
    }
    return targetItem;
  };

  /**
   * Group values of the questions that have the same linkId
   * @param item an item in the LForms form object or a form item object
   * @private
   *
   */
  self._processRepeatingItemValues = function (item) {
    if (item.items) {
      for (var i = 0, iLen = item.items.length; i < iLen; i++) {
        var subItem = item.items[i];
        // if it is a question and it repeats
        if (subItem.dataType !== 'TITLE' && subItem.dataType !== 'SECTION' && this._questionRepeats(subItem)) {
          var linkId = subItem.linkId;
          item._repeatingItems = item._repeatingItems || {};
          item._repeatingItems[linkId] = item._repeatingItems[linkId] || [];
          item._repeatingItems[linkId].push(subItem);
        }
        // if it's a section or a question that has children items
        if (this._lfHasSubItems(subItem)) {
          this._processRepeatingItemValues(subItem);
        }
      }
    }
  };

  /**
   * Get the extract value for the item.
   * If the item is extractable, item._codesToExtract is set which will be used
   * later when creating extracted Observations.
   * @param item an item in Questionnaire
   * @return true if self._getExtractValueFromItemAndParentLevel() returns true
   * for the item, or code-level observationExtract=true is found on the item.
   */
  self._getExtractValue = function (item) {
    if (self._getExtractValueFromItemAndParentLevel(item)) {
      // Check ObsExtract extension at item level and above. If the item is deemed
      // extractable and some codes have ObsExtract=false, the item is still
      // extractable (extracts all codes except those with ObsExtract=false). See
      // https://chat.fhir.org/#narrow/channel/179255-questionnaire/topic/Observation.20extraction.20with.20both.20item.20and.20item.2Ecode/with/517623297.
      return true;
    } else {
      return self._getExtractedObsCodes(item);
    }
  };

  /**
   * Get the extract value for the item, not considering code-level extensions.
   * @param item an item in Questionnaire
   * @return true if observationExtract=true is found on the item or nearest parent
   * that has the extension;
   * false if no observationExtract extension is found in the parent tree, or
   * observationExtract=false is specified on the nearest parent that has the extension.
   */
  self._getExtractValueFromItemAndParentLevel = function (item) {
    let currentItem = item;
    while (currentItem) {
      if (currentItem._fhirExt && currentItem._fhirExt[this.fhirExtObsExtract]) {
        const obsExtractValueBoolean = currentItem._fhirExt[this.fhirExtObsExtract][0].valueBoolean;
        if (obsExtractValueBoolean === true) {
          // Before returning true (item deemed extractable), cache the list in
          // item._codesToExtract so we don't need to look for them when creating Observations.
          self._getExtractedObsCodes(item, true);
          return true;
        } else if (obsExtractValueBoolean === false) {
          return false;
        }
      }
      currentItem = currentItem._parentItem;
    }
    return false;
  };

  /**
   * Gets the list of Questionnaire.item.code that will be extracted into
   * Observation.code.coding, and sets the _codesToExtract property on the item.
   * @param item an item in Questionnaire
   * @param hasItemLevelObsExtractTrue whether the item is deemed extractable
   * from the item level and above, not considering code-level ObsExtract extensions.
   * @returns a boolean flag indicating whether ObsExtract=true extension is found
   * at code level.
   */
  self._getExtractedObsCodes = function (item, hasItemLevelObsExtractTrue = false) {
    if (!item.codeList || !item.codeList.length) {
      return false;
    }
    let hasCodeLevelObsExtractTrue = false;
    let extractedCodes = [];
    for (let i = 0; i < item.codeList.length; i++) {
      const code = item.codeList[i];
      const obsExtractBooleanValue = code.extension?.find(x => x.url === this.fhirExtObsExtract)?.valueBoolean;
      if (hasItemLevelObsExtractTrue && obsExtractBooleanValue !== false) {
        // If the item is deemed extractable, we extract all the codes that
        // doesn't explicitly have ObsExtract=false.
        extractedCodes.push(code);
      } else if (!hasItemLevelObsExtractTrue && obsExtractBooleanValue === true) {
        // If the item is not deemed extractable by item level or up, and
        // a code with ObsExtract=true is found, we only add those codes
        // explicitly with ObservationExtract=true.
        extractedCodes.push(code);
        hasCodeLevelObsExtractTrue = true;
      }
    }
    if (hasItemLevelObsExtractTrue || hasCodeLevelObsExtractTrue) {
      item._codesToExtract = extractedCodes;
    }
    // If any item.code has extension ObsExtract=true, mark it since the item
    // should be extracted. In this case, ObsExtract=true extension is not
    // necessary on item level.
    return hasCodeLevelObsExtractTrue;
  };

  /**
   * Check if the item has a value
   * @param {*} item  an item in lforms with attritues set by lforms
   * @returns {boolean}
   */
  self._hasItemValue = function (item) {
    // not a group item, or a display item
    // not hidden by skip logic
    // has values
    return item.dataType !== "SECTION" && item.dataType !== "TITLE" && item._skipLogicStatus !== "target-disabled" && !LForms.Util.isItemValueEmpty(item.value) ? true : false;
  };
}
/* harmony default export */ __webpack_exports__["default"] = (addCommonSDCExportFns);

/***/ }),
/* 101 */
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _lib_lforms_internal_utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(102);
/* harmony import */ var _import_common_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(96);


const fhirpath = __webpack_require__(2);

/**
 *  Defines SDC import functions that are the same across the different FHIR
 *  versions.  The function takes SDC namespace object defined in the sdc export
 *  code, and adds additional functions to it.
 */
function addCommonSDCImportFns(ns) {
  "use strict";

  var self = ns;
  var errorMessages = LForms.Util._internalUtil.errorMessages;

  // FHIR extension urls
  self.fhirExtUrlCardinalityMin = "http://hl7.org/fhir/StructureDefinition/questionnaire-minOccurs";
  self.fhirExtUrlCardinalityMax = "http://hl7.org/fhir/StructureDefinition/questionnaire-maxOccurs";
  self.fhirExtUrlItemControl = "http://hl7.org/fhir/StructureDefinition/questionnaire-itemControl";
  self.fhirExtUrlUnit = "http://hl7.org/fhir/StructureDefinition/questionnaire-unit";
  self.fhirExtUrlUnitOption = "http://hl7.org/fhir/StructureDefinition/questionnaire-unitOption";
  self.fhirExtUrlOptionPrefix = "http://hl7.org/fhir/StructureDefinition/questionnaire-optionPrefix";
  self.fhirExtVariable = "http://hl7.org/fhir/StructureDefinition/variable";
  self.fhirExtUrlMinValue = "http://hl7.org/fhir/StructureDefinition/minValue";
  self.fhirExtUrlMaxValue = "http://hl7.org/fhir/StructureDefinition/maxValue";
  self.fhirExtUrlMinLength = "http://hl7.org/fhir/StructureDefinition/minLength";
  self.fhirExtUrlRegex = "http://hl7.org/fhir/StructureDefinition/regex";
  self.fhirExtUrlAnswerRepeats = "http://hl7.org/fhir/StructureDefinition/questionnaire-answerRepeats";
  self.fhirExtUrlExternallyDefined = "http://lhcforms.nlm.nih.gov/fhir/StructureDefinition/questionnaire-externallydefined";
  self.argonautExtUrlExtensionScore = "http://fhir.org/guides/argonaut-questionnaire/StructureDefinition/extension-score";
  self.fhirExtUrlHidden = "http://hl7.org/fhir/StructureDefinition/questionnaire-hidden";
  self.fhirExtTerminologyServer = "http://hl7.org/fhir/StructureDefinition/preferredTerminologyServer";
  self.fhirExtUrlDataControl = "http://lhcforms.nlm.nih.gov/fhirExt/dataControl";
  self.fhirExtCalculatedExp = "http://hl7.org/fhir/uv/sdc/StructureDefinition/sdc-questionnaire-calculatedExpression";
  self.fhirExtInitialExp = "http://hl7.org/fhir/uv/sdc/StructureDefinition/sdc-questionnaire-initialExpression";
  self.fhirExtObsLinkPeriod = "http://hl7.org/fhir/uv/sdc/StructureDefinition/sdc-questionnaire-observationLinkPeriod";
  self.fhirExtObsExtract = 'http://hl7.org/fhir/uv/sdc/StructureDefinition/sdc-questionnaire-observationExtract';
  self.fhirExtObsExtractCategory = "http://hl7.org/fhir/uv/sdc/StructureDefinition/sdc-questionnaire-observation-extract-category";
  self.fhirExtAnswerExp = "http://hl7.org/fhir/uv/sdc/StructureDefinition/sdc-questionnaire-answerExpression";
  self.fhirExtEnableWhenExp = "http://hl7.org/fhir/uv/sdc/StructureDefinition/sdc-questionnaire-enableWhenExpression";
  self.fhirExtChoiceOrientation = "http://hl7.org/fhir/StructureDefinition/questionnaire-choiceOrientation";
  self.fhirExtLaunchContext = "http://hl7.org/fhir/uv/sdc/StructureDefinition/sdc-questionnaire-launchContext";
  self.fhirExtMaxSize = "http://hl7.org/fhir/StructureDefinition/maxSize";
  self.fhirExtMimeType = "http://hl7.org/fhir/StructureDefinition/mimeType";
  self.fhirExtUnitOpen = "http://hl7.org/fhir/uv/sdc/StructureDefinition/sdc-questionnaire-unitOpen";
  self.fhirExtUnitSuppSystem = "http://hl7.org/fhir/uv/sdc/StructureDefinition/sdc-questionnaire-unitSupplementalSystem";
  self.fhirExtEntryFormat = "http://hl7.org/fhir/StructureDefinition/entryFormat";
  self.fhirExtUrlMaxDecimalPlaces = "http://hl7.org/fhir/StructureDefinition/maxDecimalPlaces";
  self.fhirExtUrlOptionScoreLookup = {
    'STU3': "http://hl7.org/fhir/StructureDefinition/questionnaire-ordinalValue",
    'R4': "http://hl7.org/fhir/StructureDefinition/ordinalValue",
    'R5': "http://hl7.org/fhir/StructureDefinition/itemWeight"
  };
  self.fhirExtUrlOptionScoreUrlSet = new Set(Object.values(self.fhirExtUrlOptionScoreLookup));
  self.fhirExtUrlRestrictionArray = [self.fhirExtUrlMinValue, self.fhirExtUrlMaxValue, self.fhirExtUrlMinLength, self.fhirExtUrlRegex, self.fhirExtUrlMaxDecimalPlaces];

  // One way or the other, the following extensions are converted to lforms internal fields.
  // Any extensions not listed here will be copied over to lforms as is, unless it has an
  // entry in extensionHandlers that does not return true (meaning specifically not to copy).
  self.handledExtensionSet = new Set([self.fhirExtUrlCardinalityMin, self.fhirExtUrlCardinalityMax, self.fhirExtUrlItemControl, self.fhirExtUrlUnit, self.fhirExtUrlUnitOption, self.fhirExtUrlOptionPrefix, self.fhirExtUrlMinValue, self.fhirExtUrlMaxValue, self.fhirExtUrlMinLength, self.fhirExtUrlRegex, self.fhirExtUrlAnswerRepeats, self.argonautExtUrlExtensionScore, self.fhirExtUrlHidden, self.fhirExtTerminologyServer, self.fhirExtUrlDataControl, self.fhirExtChoiceOrientation, self.fhirExtUrlMaxDecimalPlaces]);

  // Simple functions for mapping extensions to properties in the internal structure.
  // Parameters:
  //   extension: the FHIR extension object
  //   item:  The LForms item to be updated
  // Returns:  true if the extension should still be added to the LForms item
  //   extension array, and false/undefined otherwise.
  //
  self.extensionHandlers = {};
  self.extensionHandlers[self.fhirExtMaxSize] = function (extension, item) {
    item.maxAttachmentSize = extension.valueDecimal || extension.valueInteger; // not sure why it is decimal
  };
  self.extensionHandlers[self.fhirExtMimeType] = function (extension, item) {
    item.allowedAttachmentTypes || (item.allowedAttachmentTypes = []);
    item.allowedAttachmentTypes.push(extension.valueCode);
  };
  self.extensionHandlers["http://hl7.org/fhir/StructureDefinition/questionnaire-initialExpression"] = function (extension, item) {
    // Update the URI to the current one.
    extension.url = self.fhirExtInitialExp;
    return true; // add extension to LForms item
  };
  // Below are two old, deprecated terminology server urls.
  self.extensionHandlers["http://hl7.org/fhir/uv/sdc/StructureDefinition/sdc-questionnaire-preferredTerminologyServer"] = self.extensionHandlers["http://hl7.org/fhir/StructureDefinition/terminology-server"] = function (extension, item) {
    extension.url = self.fhirExtTerminologyServer;
  };
  self.extensionHandlers[self.fhirExtUnitOpen] = function (extension, item) {
    item._unitOpen = extension.valueCode;
  };
  self.extensionHandlers[self.fhirExtUnitSuppSystem] = function (extension, item) {
    item._unitSuppSystem = extension.valueCanonical;
  };
  self.extensionHandlers[self.fhirExtUrlExternallyDefined] =
  // (also handle old URL below)
  self.extensionHandlers["http://hl7.org/fhir/StructureDefinition/questionnaire-externallydefined"] = function (extension, item) {
    if (extension.valueUri) {
      item.externallyDefined = extension.valueUri;
    }
  };
  self.extensionHandlers[self.fhirExtEntryFormat] = function (extension, item) {
    if (extension.valueString) {
      item._entryFormat = extension.valueString;
      return true; // add extension to LForms item
    }
  };
  self.formLevelFields = [
  // Resource
  'id', 'meta', 'implicitRules', 'language',
  // Domain Resource
  'text', 'contained', 'extension', 'modifiedExtension',
  // Questionnaire
  'date', 'version', 'identifier', 'code',
  // code in FHIR clashes with previous definition in lforms. It needs special handling.
  'subjectType', 'derivedFrom',
  // New in R4
  'status', 'experimental', 'publisher', 'contact', 'description', 'useContext', 'jurisdiction', 'purpose', 'approvalDate', 'reviewDate', 'effectivePeriod', 'url'];

  // Item-level fields that are simply copied from the FHIR Questionnaire format to the LHC-Forms format, and back.
  self.itemLevelIgnoredFields = ['definition', 'id'];

  /**
   * Convert FHIR SQC Questionnaire to LForms definition
   *
   * @param fhirData - FHIR Questionnaire object
   * @param options - LForms options object
   * @returns {{}} - LForms json object
   */
  self.convertQuestionnaireToLForms = function (fhirData, options) {
    var target = null;
    if (options) self._widgetOptions = options;
    if (fhirData) {
      target = LForms.Util.baseFormDef();
      self._processFormLevelFields(target, fhirData);
      var containedVS = self._extractContainedVS(fhirData);
      var containedImages = self.buildContainedImageMap(fhirData.contained);
      if (fhirData.item && fhirData.item.length > 0) {
        var linkIdItemMap = self._createLinkIdItemMap(fhirData);
        target.items = [];
        for (var i = 0; i < fhirData.item.length; i++) {
          var item = self._processQuestionnaireItem(fhirData.item[i], containedVS, linkIdItemMap, containedImages);
          // no instructions on the questionnaire level
          target.items.push(item);
        }
      }
      target.fhirVersion = self.fhirVersion;
    }
    return target;
  };

  /**
   * Parse form level fields from FHIR questionnaire and assign to LForms object.
   *
   * @param lfData - LForms object to assign the extracted fields
   * @param questionnaire - FHIR questionnaire resource object to parse for the fields.
   * @private
   */
  self._processFormLevelFields = function (lfData, questionnaire) {
    self.copyFields(questionnaire, lfData, self.formLevelFields);
    self._processExtensions(lfData, questionnaire);
    self._processTerminologyServer(lfData, questionnaire);

    // Handle title and name.  In LForms, "name" is the "title", but FHIR
    // defines both.
    lfData.shortName = questionnaire.name; // computer friendly
    lfData.name = questionnaire.title;

    // Handle extensions on title
    if (questionnaire._title) lfData.obj_title = questionnaire._title;

    // For backward compatibility, we keep lforms.code as it is, and use lforms.codeList
    // for storing questionnaire.code. While exporting, merge lforms.code and lforms.codeList
    // into questionnaire.code. While importing, convert first of questionnaire.code
    // as lforms.code, and copy questionnaire.code to lforms.codeList.
    if (questionnaire.code && questionnaire.code.length > 0) {
      // Rename questionnaire code to codeList
      lfData.codeList = questionnaire.code;
    }

    // copy over the copyright
    if (questionnaire.copyright) {
      lfData.copyrightNotice = questionnaire.copyright;
    }
    var codeAndSystemObj = self._getCode(questionnaire);
    if (codeAndSystemObj) {
      lfData.code = codeAndSystemObj.code;
      lfData.codeSystem = codeAndSystemObj.system;
    }
  };

  /**
   * Process questionnaire item recursively
   *
   * @param qItem - item object as defined in FHIR Questionnaire.
   * @param containedVS - contained ValueSet info, see _extractContainedVS() for data format details
   * @param linkIdItemMap - Map of items from link ID to item from the imported resource.
   * @param containedImages - contained images info, see buildContainedImageMap() for details.
   * @returns {{}} - Converted 'item' field object as defined by LForms definition.
   * @private
   */
  self._processQuestionnaireItem = function (qItem, containedVS, linkIdItemMap, containedImages) {
    var targetItem = {};
    //A lot of parsing depends on data type. Extract it first.
    self._processExtensions(targetItem, qItem);
    self._processDataType(targetItem, qItem);
    if (self._processAnswerConstraint) self._processAnswerConstraint(targetItem, qItem);
    self._processTextAndPrefix(targetItem, qItem);
    self._processCodeAndLinkId(targetItem, qItem);
    self._processDisplayItemCode(targetItem, qItem);
    self._processEditable(targetItem, qItem);
    self._processFHIRQuestionAndAnswerCardinality(targetItem, qItem);
    self._processDisplayControl(targetItem, qItem);
    self._processDataControl(targetItem, qItem);
    self._processRestrictions(targetItem, qItem);
    self._processHiddenItem(targetItem, qItem);
    self._processUnitList(targetItem, qItem);
    self._processAnswers(targetItem, qItem, containedVS, containedImages);
    self._processDefaultAnswer(targetItem, qItem);
    self._processTerminologyServer(targetItem, qItem);
    self._processSkipLogic(targetItem, qItem, linkIdItemMap);
    self.copyFields(qItem, targetItem, self.itemLevelIgnoredFields);
    self._processChildItems(targetItem, qItem, containedVS, linkIdItemMap, containedImages);
    if (self._processDisabledDisplay) self._processDisabledDisplay(targetItem, qItem);
    return targetItem;
  };

  /**
   *  Returns the number of sinificant digits in the number after, ignoring
   *  trailing zeros.  (I am including this on "self" so we can have tests for it.)
   */
  self._significantDigits = function (x) {
    // Based on https://stackoverflow.com/a/9539746/360782
    // Make sure it is a number and use the builtin number -> string.
    var s = "" + +x;
    // The following RegExp include the exponent, which we don't need
    //var match = /(\d+)(?:\.(\d+))?(?:[eE]([+-]?\d+))?$/.exec(s);
    var match = /(\d+)(?:\.(\d+))?/.exec(s);
    // NaN or Infinity or integer.
    // We arbitrarily decide that Infinity is integral.
    if (!match) {
      return 0;
    }
    var wholeNum = match[1];
    var fraction = match[2];
    //var exponent = match[3];
    return wholeNum === '0' ? 0 : wholeNum.length + (fraction ? fraction.length : 0);
  };

  /**
   *  Imports an observation's values into the given LForms item.
   * @param lfItem the LForms item to which a value will be assigned.
   * @param obs the observation whose value will be assigned to lfItem.  It
   *  assumed that obs has an appropriate data type for its value.
   */
  self.importObsValue = function (lfItem, obs) {
    // Get the value from obs, based on lfItem's data type.  (The alternative
    // seems to be looping through the keys on obs looking for something that
    // starts with "value".
    var val = null;
    var lfDataType = lfItem.dataType;
    var fhirValType = this._lformsTypesToFHIRFields[lfDataType];
    // fhirValType is now the FHIR data type for a Questionnaire.  However,
    // where Questionnaire uses Coding, Observation uses CodeableConcept.
    if (fhirValType === 'Coding') fhirValType = 'CodeableConcept';
    if (fhirValType) val = obs['value' + fhirValType];
    if (!val && (lfDataType === 'REAL' || lfDataType === 'INT')) {
      // Accept initial value of type Quantity for these types.
      val = obs.valueQuantity;
      if (val) val._type = 'Quantity';
    }
    if (val) {
      if (!val._type && typeof val === 'object') val._type = fhirValType;

      // Before importing, confirm val contains a valid unit from the
      // item's unit list.
      var unitOkay = true;
      if (val._type === 'Quantity') {
        if (lfItem.units) {
          var matchingUnit;
          var valSystem = val.system;
          // On SMART sandbox, val.system might have a trailing slash (which is wrong, at least
          // for UCUM).  For now, just remove it.
          if (valSystem && valSystem[valSystem.length - 1] === '/') valSystem = valSystem.slice(0, -1);
          var isUCUMUnit = valSystem === self.UCUM_URI;
          var ucumUnit;
          for (var i = 0, len = lfItem.units.length; i < len && !matchingUnit; ++i) {
            var lfUnit = lfItem.units[i];
            if (lfUnit.system && lfUnit.system === valSystem && lfUnit.code === val.code || !lfUnit.system && lfUnit.name === val.unit) {
              matchingUnit = lfUnit;
            }
            if (isUCUMUnit && !matchingUnit && !ucumUnit && lfUnit.system === self.UCUM_URI) ucumUnit = lfUnit;
          }
          if (!matchingUnit && ucumUnit) {
            // See if we can convert to the ucumUnit we found
            var result = LForms.ucumPkg.UcumLhcUtils.getInstance().convertUnitTo(val.code, val.value, ucumUnit.code);
            if (result.status === 'succeeded') {
              matchingUnit = ucumUnit;
              // Round the result to the same number of significant digits as the
              // input value.
              var originalSD = this._significantDigits(val.value);
              if (originalSD > 0) val.value = parseFloat(result.toVal.toPrecision(originalSD));else val.value = result.toVal;
              val.code = ucumUnit.code;
              val.unit = ucumUnit.name || ucumUnit.code; // name can be undefined
            }
          }
          if (!matchingUnit) unitOkay = false;else lfItem.unit = matchingUnit;
        }
      }
      if (unitOkay) {
        this._processFHIRValues(lfItem, [val]);
      }
    }
  };

  /**
   *   Converts FHIR values to an LForms item values, but does not assign the
   *   values to the item.  (For a function that assigns values, call _processFHIRValues).
   *  @param lfItem the LForms item to for which these are new values
   *  @param fhirVals an array of FHIR values (e.g.  Quantity, Coding, string, etc.).
   *   Complex types like Quantity should have _type set to the type, if
   *   possible, or an attempt will be made to guess the FHIR type from the
   *   lfItem's data type.
   *  @param forDefault if true, the intented target of the values is the item's
   *   default value instead of the item value.
   *  @return an array of the processed/converted values, and an array of any error/warning/info
   *   messages for each of those messages.  For each item in the messages
   *   array, if there is a message there will be an object with keys "errors",
   *   "warnings", and "info" (if those exist), the values of which will will be
   *   an object with message ID keys (from error-messages.js) and message text
   *   values in the currently selected language.  Regarding the answers, note
   *   that Quantities will be returned as is, because those go into more than
   *   one field on the item, but some error checking will be done for them.
   */
  self._convertFHIRValues = function (lfItem, fhirVals, forDefault) {
    // Note that this is used by the import process, and so lfItem is an item
    // from the lforms definition object in that case, not an item from LFormsData.
    // On the other hand, it is also used by the ExpressionProcessor, an in that
    // case lfItem is an item from LFormsData.
    var lfDataType = lfItem.dataType;
    var answers = [];
    const messages = [];
    const types = fhirpath.types(fhirVals);
    for (let i = 0, len = fhirVals.length; i < len; ++i) {
      let fhirVal = fhirVals[i];
      if (typeof fhirVal === 'object') {
        // types[i] is a string with a namespaced data type, such as
        // "FHIR.Quantity", "FHIR.date", "System.String"
        fhirVal._type = fhirVal._type || types[i]?.split('.')[1];
      }
      var answer = undefined; // reset back to undefined each iteration
      let errors = {};
      let hasMessages = false;
      if (_lib_lforms_internal_utils_js__WEBPACK_IMPORTED_MODULE_0__.InternalUtil.hasAnswerList(lfItem)) {
        if (lfDataType === "CODING") {
          var codings = null;
          if (fhirVal._type === 'CodeableConcept') {
            codings = fhirVal.coding;
          } else if (fhirVal._type === 'Coding' || typeof fhirVal === 'object') {
            codings = [fhirVal];
          }
          if (!codings) {
            // the value or the default value could be a string for optionsOrString
            if (lfItem.answerConstraint === 'optionsOrString') {
              answer = fhirVal;
            }
          } else {
            // Pick a Coding that is appropriate for this list item.
            // Note:  It could be an off list Coding.
            if (lfItem.answers) {
              var itemAnswers = lfItem.answers;
              for (var k = 0, kLen = codings.length; k < kLen && !answer; ++k) {
                var coding = codings[k];
                for (var j = 0, jLen = itemAnswers.length; j < jLen && !answer; ++j) {
                  var listAnswer = itemAnswers[j];
                  var listAnswerSystem = listAnswer.system ? LForms.Util.getCodeSystem(listAnswer.system) : null;
                  if ((!coding.system && !listAnswerSystem || coding.system === listAnswerSystem) && (coding.hasOwnProperty('code') && listAnswer.hasOwnProperty('code') && coding.code === listAnswer.code || coding.hasOwnProperty('display') && listAnswer.hasOwnProperty('text') && coding.display === listAnswer.text)) {
                    answer = itemAnswers[j]; // include label in answer text
                  }
                }
              }
            }
            if (!answer && lfItem.answerConstraint === 'optionsOrString') {
              // no match in the list.
              answer = self._processCODINGValueInQR({
                valueCoding: fhirVal
              }, lfItem, true);
            }
          }
        }
        // answerOption is string, integer, date or time
        else if (lfItem.answers) {
          answer = self._processNonCodingAnswerValueInQR(fhirVal, lfItem, forDefault);
        }
      } else {
        if ((lfDataType === 'QTY' || lfDataType === 'REAL' || lfDataType === 'INT') && fhirVal._type === 'Quantity') {
          [answer, errors] = this._convertFHIRQuantity(lfItem, fhirVal);
          hasMessages = !!errors;
        }
        // For date types, convert them to date objects, but only for values.
        // If we're setting defaultAnswer, leave them as strings.
        else if (!forDefault && lfItem.dataType === 'DTM' && typeof fhirVal === 'string') answer = new Date(fhirVal);else if (!forDefault && lfItem.dataType === 'DT' && typeof fhirVal === 'string') answer = LForms.Util.stringToDTDateISO(fhirVal);else {
          answer = fhirVal;
        }
      }
      if (answer !== undefined || answer !== null) answers.push(answer);
      messages.push(hasMessages ? {
        errors
      } : null);
    }
    return [answers, messages];
  };

  /**
   *  Checks a FHIR Quantity for suitability for the given lfItem, converts
   *  its units as necessary, and sets error messages.
   * @param lfItem the LForms item to for which these are new values
   * @param quantity the FHIR Quantity value for the item
   * @param forDefault if true, the intented target of the values is the item's
   *  default value instead of the item value.
   * @return an array of two elements:  the processed/converted value (possibly
   *  null if there were an error), and an error/warning/info messages object
   *  (see _convertFHIRValues for the format) if there were messages.  In the
   *  case of an error, the converted value will be undefined.  Otherwise, the
   *  converted value will have fields for item.unit plus a 'value' field for
   *  the value.
   */
  self._convertFHIRQuantity = function (lfItem, quantity, forDefault) {
    let answer, errors;
    if (quantity.comparator !== undefined) {
      errors = {};
      errorMessages.addMsg(errors, 'comparatorInQuantity');
    } else {
      // The unit must match one of the provided units list, or be convertible
      // to such, unless the extensions unitOpen and unitSupplementalSystem are
      // specified. (These are R5 features, but we are including support for any
      // version.)

      if (!lfItem.units) {
        // In this case the quantity should not have a unit.
        if (quantity.unit) {
          errorMessages.addMsg(errors, 'nonMatchingQuantityUnit');
        } else answer = (0,_import_common_js__WEBPACK_IMPORTED_MODULE_1__.importFHIRQuantity)(quantity);
      } else {
        // Try to find a matching unit
        var matchingUnit;
        var valSystem = quantity.system;
        // On SMART sandbox, quantity.system might have a trailing slash (which is wrong, at least
        // for UCUM).  For now, just remove it.
        if (valSystem && valSystem[valSystem.length - 1] === '/') valSystem = valSystem.slice(0, -1);
        var isUCUMUnit = valSystem === self.UCUM_URI;
        var ucumUnit;
        for (var i = 0, len = lfItem.units.length; i < len && !matchingUnit; ++i) {
          var lfUnit = lfItem.units[i];
          if (lfUnit.system && lfUnit.system === valSystem && lfUnit.code === quantity.code || !lfUnit.system && lfUnit.name === quantity.unit) {
            matchingUnit = lfUnit;
          }
          if (isUCUMUnit && !matchingUnit && !ucumUnit && lfUnit.system === self.UCUM_URI) ucumUnit = lfUnit;
        }
        quantity = LForms.Util.deepCopy(quantity); // so we don't change the input argument
        if (!matchingUnit && ucumUnit) {
          // See if we can convert to the ucumUnit we found
          var result = LForms.ucumPkg.UcumLhcUtils.getInstance().convertUnitTo(quantity.code, quantity.value, ucumUnit.code);
          if (result.status === 'succeeded') {
            matchingUnit = ucumUnit;
            // Round the result to the same number of significant digits as the
            // input value.
            var originalSD = this._significantDigits(quantity.value);
            if (originalSD > 0) quantity.value = parseFloat(result.toVal.toPrecision(originalSD));else quantity.value = result.toVal;
            quantity.code = ucumUnit.code;
            quantity.unit = ucumUnit.name || ucumUnit.code; // name can be undefined
          }
        }
        if (!matchingUnit) {
          if (lfItem._unitOpen == 'optionsOrString') {
            // Then accept the nonmatching unit, but only as a string
            delete quantity.code;
            delete quantity.system;
          } else if (!(lfItem._unitSuppSystem && lfItem._unitOpen == 'optionsOrType' && lfItem._unitSuppSystem == quantity.system)) {
            errors = {};
            errorMessages.addMsg(errors, 'nonMatchingQuantityUnit');
          }
        }
      }
      if (!errors) {
        answer = (0,_import_common_js__WEBPACK_IMPORTED_MODULE_1__.importFHIRQuantity)(quantity);
      }
    }
    return [answer, errors];
  };

  /**
   *   Assigns FHIR values to an LForms item.
   *  @param lfItem the LForms item to receive the values from fhirVals
   *  @param fhirVals an array of FHIR values (e.g.  Quantity, Coding, string, etc.).
   *   Complex types like Quantity should have _type set to the type, if
   *   possible, or an attempt will be made to guess the FHIR type from the
   *   lfItem's data type.
   *  @param setDefault if true, the default value in lfItem will be set instead
   *   of the value.
   */
  self._processFHIRValues = function (lfItem, fhirVals, setDefault) {
    // Currently this is called for:
    //   - importing an Observation value (prepop) (a single value, but could
    //     have components referred to by child items)
    //   - processing default answers during an import.  For default answers, we
    //     do not assign the value here, but just put it in defaultAnswer.
    // Note that when importing, we are creating a LForms form definition, but
    // not and LFormsData object.
    let [answers, messages] = this._convertFHIRValues(lfItem, fhirVals, setDefault);
    let val = LForms.Util._hasMultipleAnswers(lfItem) ? answers : answers[0];
    if (setDefault) {
      lfItem.defaultAnswer = val;
      LForms.Util._internalUtil.setItemMessagesArray(lfItem, messages, 'default answers');
    } else {
      LForms.Util._internalUtil.assignValueToItem(lfItem, val);
      LForms.Util._internalUtil.setItemMessagesArray(lfItem, messages, '_processFHIRValues');
    }
  };

  /**
   * Get a FHIR value from an object given a partial string of hash key.
   * Use it where at most only one key matches.
   *
   * @param obj {object} - Object to search
   * @param keyRegex {regex} - Regular expression to match a key.  This should
   *  be the beginning part of the key up to the type (e.g., /^value/, to match
   *  "valueQuantity").
   * @returns {*} - Corresponding value of matching key.  For complex types,
   *  such as Quantity, the type of the returned object will be present under
   *  a _type attribute.
   * @private
   */
  self._getFHIRValueWithPrefixKey = function (obj, keyRegex) {
    var ret = null;
    if (typeof obj === 'object') {
      for (var key in obj) {
        var matchData = key.match(keyRegex);
        if (matchData) {
          ret = obj[key];
          if (ret && typeof ret === 'object') {
            ret = LForms.Util.deepCopy(ret); // Work with clone
            ret._type = key.substring(matchData[0].length);
          }
          break;
        }
      }
    }
    return ret;
  };

  /**
   *  Process the text and prefix data.
   * @param lfItem {object} - LForms item object to receive the data
   * @param qItem {object} - Questionnaire item object (as the source)
   */
  self._processTextAndPrefix = function (lfItem, qItem) {
    // prefix
    if (qItem.prefix) lfItem.prefix = qItem.prefix;
    // text
    lfItem.question = qItem.text;

    // process extensions on item._text and item._prefix
    for (let extField of ['_prefix', '_text']) {
      let itemAttr = 'obj' + extField;
      // copy over the extensions
      let extFieldData = qItem[extField];
      if (extFieldData) lfItem['obj' + extField] = extFieldData;
      let htmlAttrName = itemAttr == 'obj_text' ? '_displayTextHTML' : '_prefixHTML';
      let invalidFlagName = itemAttr == 'obj_text' ? '_hasInvalidHTMLTagInText' : '_hasInvalidHTMLTagInPrefix';

      // process rendering-xhtml extension
      const xhtmlFormat = lfItem[itemAttr] ? LForms.Util.findObjectInArray(lfItem[itemAttr].extension, 'url', "http://hl7.org/fhir/StructureDefinition/rendering-xhtml") : null;
      if (xhtmlFormat) {
        lfItem[htmlAttrName] = xhtmlFormat.valueString;
        if (self._widgetOptions?.allowHTML) {
          let invalidTagsAttributes = LForms.Util._internalUtil.checkForInvalidHtmlTags(xhtmlFormat.valueString);
          if (invalidTagsAttributes && invalidTagsAttributes.length > 0) {
            lfItem[invalidFlagName] = true;
            let errors = {};
            errorMessages.addMsg(errors, 'invalidTagInHTMLContent');
            const messages = [{
              errors
            }];
            LForms.Util._internalUtil.printInvalidHtmlToConsole(invalidTagsAttributes);
            LForms.Util._internalUtil.setItemMessagesArray(lfItem, messages, '_processTextAndPrefix');
          }
        }
      }
    }
  };

  /**
   * Parse questionnaire item for code and code system
   * @param lfItem {object} - LForms item object to assign question code
   * @param qItem {object} - Questionnaire item object
   * @private
   */
  self._processCodeAndLinkId = function (lfItem, qItem) {
    if (qItem.code) {
      lfItem.codeList = qItem.code;
    }
    var code = self._getCode(qItem);
    if (code) {
      lfItem.questionCode = code.code;
      lfItem.questionCodeSystem = code.system;
    }
    // use linkId as questionCode, which should not be exported as code
    else {
      lfItem.questionCode = qItem.linkId;
      lfItem.questionCodeSystem = "LinkId";
    }
    lfItem.linkId = qItem.linkId;
  };

  /**
   * Parse questionnaire item for units list
   *
   * @param lfItem {object} - LForms item object to assign units
   * @param qItem {object} - Questionnaire item object
   * @private
   */
  self._processUnitList = function (lfItem, qItem) {
    var lformsUnits = [];
    var lformsDefaultUnit = null;
    // The questionnaire-unitOption extension is only for item.type = quantity
    var unitOption = LForms.Util.findObjectInArray(qItem.extension, 'url', self.fhirExtUrlUnitOption, 0, true);
    if (unitOption && unitOption.length > 0) {
      if (qItem.type !== 'quantity') {
        throw new Error('The extension ' + self.fhirExtUrlUnitOption + ' can only be used with type quantity.  Question "' + qItem.text + '" is of type ' + qItem.type);
      }
      for (var i = 0; i < unitOption.length; i++) {
        var coding = unitOption[i].valueCoding;
        var lUnit = {
          name: coding.display,
          code: coding.code,
          system: coding.system
        };
        lformsUnits.push(lUnit);
      }
    }

    // The questionnaire-unit extension is only for item.type = integer or decimal
    var unit = LForms.Util.findObjectInArray(qItem.extension, 'url', self.fhirExtUrlUnit);
    if (unit) {
      if (qItem.type !== 'integer' && qItem.type !== 'decimal') {
        throw new Error('The extension ' + self.fhirExtUrlUnit + ' can only be used with types integer or decimal.  Question "' + qItem.text + '" is of type ' + qItem.type);
      }
      lformsDefaultUnit = {
        name: unit.valueCoding.display,
        code: unit.valueCoding.code,
        system: unit.valueCoding.system,
        default: true
      };
      lformsUnits.push(lformsDefaultUnit);
    }
    if (qItem.type === 'quantity') {
      let initialQ = this.getFirstInitialQuantity(qItem);
      if (initialQ && initialQ.unit) {
        lformsDefaultUnit = LForms.Util.findItem(lformsUnits, 'name', initialQ.unit);
        if (lformsDefaultUnit) {
          lformsDefaultUnit.default = true;
        } else {
          lformsDefaultUnit = {
            name: initialQ.unit,
            code: initialQ.code,
            system: initialQ.system,
            default: true
          };
          lformsUnits.push(lformsDefaultUnit);
        }
      }
    }
    if (lformsUnits.length > 0) {
      if (!lformsDefaultUnit) {
        lformsUnits[0].default = true;
      }
      lfItem.units = lformsUnits;
    }
  };

  /**
   * Parse questionnaire item for display control
   *
   * @param lfItem {object} - LForms item object to assign display control
   * @param qItem {object} - Questionnaire item object
   * @private
   */
  self._processDisplayControl = function (lfItem, qItem) {
    var itemControlType = LForms.Util.findObjectInArray(qItem.extension, 'url', self.fhirExtUrlItemControl);
    if (itemControlType) {
      var displayControl = {};
      switch (itemControlType.valueCodeableConcept.coding[0].code) {
        case 'Lookup': // backward-compatibility with old export
        case 'Combo-box': // backward-compatibility with old export
        case 'autocomplete':
          lfItem.isSearchAutocomplete = true;
        // continue to drop-down case
        case 'drop-down':
          displayControl.answerLayout = {
            type: 'COMBO_BOX'
          };
          break;
        case 'Checkbox': // backward-compatibility with old export
        case 'check-box':
        case 'Radio': // backward-compatibility with old export
        case 'radio-button':
          displayControl.answerLayout = {
            type: 'RADIO_CHECKBOX'
          };
          var answerChoiceOrientation = LForms.Util.findObjectInArray(qItem.extension, 'url', self.fhirExtChoiceOrientation);
          if (answerChoiceOrientation) {
            if (answerChoiceOrientation.valueCode === "vertical") {
              displayControl.answerLayout.columns = "1";
            } else if (answerChoiceOrientation.valueCode === "horizontal") {
              displayControl.answerLayout.columns = "0";
            }
          }
          break;
        case 'Table': // backward-compatibility with old export
        case 'gtable':
          // Not in STU3, but we'll accept it
          if (lfItem.dataType === 'SECTION') {
            displayControl.questionLayout = "horizontal";
          }
          break;
        case 'Matrix': // backward-compatibility with old export
        case 'table':
          if (lfItem.dataType === 'SECTION') {
            displayControl.questionLayout = "matrix";
          }
          break;
        default:
          displayControl = null;
      }
      if (displayControl && !LForms.jQuery.isEmptyObject(displayControl)) {
        lfItem.displayControl = displayControl;
      }
    }
  };

  /**
   * Parse questionnaire item for data control
   *
   * @param lfItem {object} - LForms item object to assign data control
   * @param qItem {object} - Questionnaire item object
   * @private
   */
  self._processDataControl = function (lfItem, qItem) {
    var dataControlType = LForms.Util.findObjectInArray(qItem.extension, 'url', self.fhirExtUrlDataControl);
    if (dataControlType && dataControlType.valueString) {
      try {
        var dataControl = JSON.parse(dataControlType.valueString);
        if (dataControl) {
          lfItem.dataControl = dataControl;
        }
      } catch (e) {
        console.log("Invalid dataControl data!");
      }
    }
  };

  /**
   * Parse questionnaire item for "hidden" extension
   *
   * @param lfItem {object} - LForms item object to be assigned the isHiddenInDef flag if the item is to be hidden.
   * @param qItem {object} - Questionnaire item object
   * @private
   * @return true if the item is hidden or if its ancestor is hidden, false otherwise
   */
  self._processHiddenItem = function (lfItem, qItem) {
    var ci = LForms.Util.findObjectInArray(qItem.extension, 'url', self.fhirExtUrlHidden);
    if (ci) {
      lfItem.isHiddenInDef = typeof ci.valueBoolean === 'boolean' ? ci.valueBoolean : ci.valueBoolean === 'true';
    }
    return lfItem.isHiddenInDef;
  };

  // ---------------- QuestionnaireResponse Import ---------------

  var qrImport = self._mergeQR = {};

  /**
   * Merge a QuestionnaireResponse instance into an LForms form object
   * @param formData an LForms form definition or LFormsData object.
   * @param qr a QuestionnaireResponse instance
   * @returns {{}} an updated LForms form definition, with answer data
   */
  qrImport.mergeQuestionnaireResponseToLForms = function (formData, qr) {
    if (!(formData instanceof LForms.LFormsData)) {
      // get the default settings in case they are missing in the form data
      // not to set item values by default values for saved forms with user data
      formData.hasSavedData = true;
      formData = new LForms.LFormsData(formData).getFormData();
    }
    // The reference to _mergeQR below is here because this function gets copied to
    // the containing object to be a part of the public API.
    var qrInfo = qrImport._getQRStructure(qr);
    qrImport._processQRItemAndLFormsItem(qrInfo, formData);
    return formData;
  };

  /**
   * Merge data into items on the same level
   * @param parentQRItemInfo structural information of a parent item
   * @param parentLFormsItem a parent item, could be a LForms form object or a form item object.
   * @private
   */
  qrImport._processQRItemAndLFormsItem = function (parentQRItemInfo, parentLFormsItem) {
    // note: parentQRItemInfo.qrItemInfo.length will increase when new data is inserted into the array
    for (var i = 0; i < parentQRItemInfo.qrItemsInfo.length; i++) {
      var qrItemInfo = parentQRItemInfo.qrItemsInfo[i];
      var qrItem = qrItemInfo.item;
      if (qrItem) {
        // first repeating qrItem
        if (qrItemInfo.total > 1 && qrItemInfo.index === 0) {
          var defItem = this._findTheMatchingItemByLinkId(parentLFormsItem, qrItemInfo.linkId);
          // add repeating items in form data
          // if it is a case of repeating questions, not repeating answers
          if (ns._questionRepeats(defItem)) {
            this._addRepeatingItems(parentLFormsItem, qrItemInfo.linkId, qrItemInfo.total);
            // add missing qrItemInfo nodes for the newly added repeating LForms items (questions, not sections)
            if (defItem.dataType !== 'SECTION' && defItem.dataType !== 'TITLE') {
              for (var j = 1; j < qrItemInfo.total; j++) {
                var newQRItemInfo = LForms.Util.deepCopy(qrItemInfo);
                newQRItemInfo.index = j;
                newQRItemInfo.item.answer = [newQRItemInfo.item.answer[j]];
                if (qrItemInfo.qrAnswersItemsInfo && qrItemInfo.qrAnswersItemsInfo[j]) {
                  newQRItemInfo.qrAnswersItemsInfo = [qrItemInfo.qrAnswersItemsInfo[j]];
                }
                parentQRItemInfo.qrItemsInfo.splice(i + j, 0, newQRItemInfo);
              }
              // change the first qr item's answer too
              qrItemInfo.item.answer = [qrItemInfo.item.answer[0]];
              if (qrItemInfo.qrAnswersItemsInfo && qrItemInfo.qrAnswersItemsInfo[0]) {
                qrItemInfo.qrAnswersItemsInfo = [qrItemInfo.qrAnswersItemsInfo[0]];
              } else {
                delete qrItemInfo.qrAnswersItemsInfo;
              }
            }
          }
          // reset the total number of questions when it is the answers that repeats
          else if (ns._answerRepeats(defItem)) {
            qrItemInfo.total = 1;
          }
        }
        // find the matching LForms item
        var item = this._findTheMatchingItemByLinkIdAndIndex(parentLFormsItem, qrItemInfo.linkId, qrItemInfo.index);

        // set up value and units if it is a question
        if (item.dataType !== 'SECTION' && item.dataType !== 'TITLE') {
          var qrAnswer = qrItem.answer;
          if (qrAnswer && qrAnswer.length > 0) {
            this._setupItemValueAndUnit(qrItem.linkId, qrAnswer, item);
            // process item.answer.item, if applicable
            if (qrItemInfo.qrAnswersItemsInfo) {
              // _setupItemValueAndUnit seems to assume single-answer except for multiple choices on CODING
              // moreover, each answer has already got its own item above if question repeats
              if (qrItemInfo.qrAnswersItemsInfo.length > 1) {
                throw new Error('item.answer.item with item.answer.length > 1 is not yet supported');
              }
              this._processQRItemAndLFormsItem(qrItemInfo.qrAnswersItemsInfo[0], item);
            }
          }
        }

        // process items on the sub-level
        if (qrItemInfo.qrItemsInfo && qrItemInfo.qrItemsInfo.length > 0) {
          this._processQRItemAndLFormsItem(qrItemInfo, item);
        }
      }
    }
  };

  /**
   * Set value and units on a LForms item
   * @param linkId a QuestionnaireResponse item's linkId
   * @param answer value for the item in QuestionnaireResponse
   * @param item a LForms item
   * @private
   */
  qrImport._setupItemValueAndUnit = function (linkId, answer, item) {
    if (item && linkId === item.linkId && item.dataType !== 'SECTION' && item.dataType !== 'TITLE') {
      var dataType = item.dataType;

      // any one has a unit must be a numerical type, let use REAL for now.
      // dataType conversion should be handled when panel data are added to lforms-service.
      if ((!dataType || dataType === "ST") && item.units && item.units.length > 0) {
        item.dataType = dataType = "REAL";
      }
      var qrValue = answer[0];
      switch (dataType) {
        case "BL":
          if (qrValue.valueBoolean === true || qrValue.valueBoolean === false) {
            item.value = qrValue.valueBoolean;
          }
          break;
        case "INT":
          // has an answer list
          if (_lib_lforms_internal_utils_js__WEBPACK_IMPORTED_MODULE_0__.InternalUtil.hasAnswerList(item)) {
            // answer repeats (autocomplete or checkboxes)
            ns._processOtherAnswerOptionValueInQR(answer, item);
          }
          // normal item
          else {
            if (qrValue.hasOwnProperty('valueQuantity')) {
              item.value = qrValue.valueQuantity.value;
              if (qrValue.valueQuantity.code) {
                item.unit = {
                  name: qrValue.valueQuantity.code
                };
              }
            } else if (qrValue.hasOwnProperty('valueInteger')) {
              item.value = qrValue.valueInteger;
            }
          }
          break;
        case "REAL":
        case "QTY":
          if (qrValue.hasOwnProperty('valueQuantity')) {
            var quantity = qrValue.valueQuantity;
            var lformsQuantity = (0,_import_common_js__WEBPACK_IMPORTED_MODULE_1__.importFHIRQuantity)(quantity);
            LForms.Util._internalUtil.assignValueToItem(item, lformsQuantity, 'Quantity');
          } else if (qrValue.hasOwnProperty('valueDecimal')) {
            item.value = qrValue.valueDecimal;
          }
          break;
        case "DT":
          // has an answer list
          if (_lib_lforms_internal_utils_js__WEBPACK_IMPORTED_MODULE_0__.InternalUtil.hasAnswerList(item)) {
            // answer repeats (autocomplete or checkboxes)
            ns._processOtherAnswerOptionValueInQR(answer, item);
          }
          // normal item
          else if (qrValue.hasOwnProperty('valueDate')) {
            item.value = qrValue.valueDate;
          }
          break;
        case "TM":
          // has an answer list
          if (_lib_lforms_internal_utils_js__WEBPACK_IMPORTED_MODULE_0__.InternalUtil.hasAnswerList(item)) {
            // answer repeats (autocomplete or checkboxes)
            ns._processOtherAnswerOptionValueInQR(answer, item);
          }
          // normal item
          else if (qrValue.hasOwnProperty('valueTime')) {
            item.value = qrValue.valueTime;
          }
          break;
        case "DTM":
          item.value = qrValue.valueDateTime;
          break;
        case "CODING":
          if (ns._answerRepeats(item)) {
            var value = [];
            for (var j = 0, jLen = answer.length; j < jLen; j++) {
              var val = ns._processCODINGValueInQR(answer[j], item);
              if (val) {
                value.push(val);
              }
            }
            item.value = value;
          } else {
            var val = ns._processCODINGValueInQR(qrValue, item);
            if (val) {
              item.value = val;
            }
          }
          break;
        case "ST":
          // has an answer list
          if (_lib_lforms_internal_utils_js__WEBPACK_IMPORTED_MODULE_0__.InternalUtil.hasAnswerList(item)) {
            // answer repeats (autocomplete or checkboxes)
            ns._processOtherAnswerOptionValueInQR(answer, item);
          }
          // normal item
          else if (qrValue.hasOwnProperty('valueString')) {
            item.value = qrValue.valueString;
          }
          break;
        case "TX":
          item.value = qrValue.valueString;
          break;
        case "attachment":
          item.value = qrValue.valueAttachment;
          break;
        case "SECTION":
        case "TITLE":
        case "":
          // do nothing
          break;
        default:
          item.value = qrValue.valueString;
      }
    }
  };

  /**
   * Build a map of items to linkid from a questionnaire resource.
   * @param qResource - FHIR Questionnaire resource
   * @returns {*} - Hash object with link id keys pointing to their respective items.
   * @private
   */
  self._createLinkIdItemMap = function (qResource) {
    var traverse = function (itemArray, collection) {
      itemArray.forEach(function (item) {
        collection[item.linkId] = item;
        if (item.item) {
          traverse(item.item, collection);
        }
      });
      return collection;
    };
    var ret = {};
    if (qResource.item) {
      ret = traverse(qResource.item, ret);
    }
    return ret;
  };

  /**
   * Get an object with code and code system
   *
   * @param questionnaireItemOrResource {object} - question
   * @private
   */
  self._getCode = function (questionnaireItemOrResource) {
    var code = null;
    if (questionnaireItemOrResource && Array.isArray(questionnaireItemOrResource.code) && questionnaireItemOrResource.code.length) {
      code = {
        code: questionnaireItemOrResource.code[0].code,
        system: self._toLfCodeSystem(questionnaireItemOrResource.code[0].system)
      };
    }
    // If code is missing look for identifier.
    else if (questionnaireItemOrResource && Array.isArray(questionnaireItemOrResource.identifier) && questionnaireItemOrResource.identifier.length) {
      code = {
        code: questionnaireItemOrResource.identifier[0].value,
        system: self._toLfCodeSystem(questionnaireItemOrResource.identifier[0].system)
      };
    }
    return code;
  };

  /**
   * Convert the given code system to LForms internal code system. Currently
   * only converts 'http://loinc.org' to 'LOINC' and returns all other input as is.
   * @param codeSystem
   * @private
   */
  self._toLfCodeSystem = function (codeSystem) {
    var ret = codeSystem;
    switch (codeSystem) {
      case 'http://loinc.org':
        ret = 'LOINC';
        break;
    }
    return ret;
  };

  // Copy the main merge function to preserve the same API usage.
  self.mergeQuestionnaireResponseToLForms = qrImport.mergeQuestionnaireResponseToLForms;

  /**
   *  Processes the terminology server setting, if any.
   *
   * @param lfItem - LForms form or item object to receive the terminology
   *  server setting.
   * @param qItem - Questionnaire or Questionnaire item object
   * @private
   */
  self._processTerminologyServer = function (lfItem, qItem) {
    var tServer = LForms.Util.findObjectInArray(qItem.extension, 'url', self.fhirExtTerminologyServer);
    if (tServer && tServer.valueUrl) {
      lfItem.terminologyServer = tServer.valueUrl;
    }
  };

  /**
   * Parse Questionnaire item for externallyDefined url
   *
   * @param lfItem - LForms item object to assign externallyDefined
   * @param qItem - Questionnaire item object
   * @private
   */
  self._processExternallyDefined = function (lfItem, qItem) {
    var externallyDefined = LForms.Util.findObjectInArray(qItem.extension, 'url', self.fhirExtUrlExternallyDefined);
    if (externallyDefined && externallyDefined.valueUri) {
      lfItem.externallyDefined = externallyDefined.valueUri;
    }
  };

  /**
   *  Finds the terminology server URL (if any) for the given item.
   * @param item a question, title, or group in the form (in the LFormsData
   *  structure, not the Questionnaire).
   * @return the base terminology server URL, or undefined if there isn't one
   *  for this item.
   */
  self._getTerminologyServer = function (item) {
    var terminologyServer = item.terminologyServer;
    var parent = item._parentItem;
    while (!terminologyServer && parent) {
      terminologyServer = parent.terminologyServer;
      parent = parent._parentItem;
    }
    return terminologyServer;
  };

  /**
   *  Returns the URL for performing a ValueSet expansion for the given item,
   *  if the given item has a terminology server and answerValueSet
   *  configured; otherwise it returns undefined.
   * @param item a question, title, or group in the form
   */
  self._getExpansionURL = function (item) {
    var rtn;
    if (item.answerValueSet) {
      var terminologyServer = this._getTerminologyServer(item);
      if (terminologyServer) rtn = terminologyServer + '/ValueSet/$expand?url=' + encodeURIComponent(item.answerValueSet) + '&_format=json';
    }
    return rtn;
  };

  /**
   *  Loads answerValueSets for prefetched lists.
   * @param lfData the LFormsData for the form
   * @return an array of promise objects which resolve when the answer valuesets
   * have been loaded and imported.
   */
  self.loadAnswerValueSets = function (lfData) {
    var pendingPromises = [];
    var items = lfData.itemList;
    for (var i = 0, len = items.length; i < len; ++i) {
      let item = items[i];
      let expURL, vsKey;
      // Skip over answerValueSet if item.answers is already present (e.g.,
      // loaded from a package (see lhc-form-data.ts: _loadAnswerValueSetsFromPackage).
      if (!item.answers && item.answerValueSet && !item.isSearchAutocomplete) {
        if (item.answerValueSet.startsWith('#')) {
          vsKey = item.answerValueSet;
        } else {
          expURL = this._getExpansionURL(item);
          vsKey = expURL ? expURL : item.answerValueSet;
        }
        if (!LForms._valueSetAnswerCache) LForms._valueSetAnswerCache = {};
        let answersOrPromise = LForms._valueSetAnswerCache[vsKey];
        if (answersOrPromise) {
          if (typeof answersOrPromise.then === 'function') {
            // A promise is cached but not yet returned.
            answersOrPromise.then(function (answers) {
              if (answers) {
                self._updateAnswersFromValueSetResponse(answers, lfData, item);
              }
              return answers;
            });
          } else {
            // answers list is cached.
            self._updateAnswersFromValueSetResponse(answersOrPromise, lfData, item);
          }
        } else {
          // if not already loaded
          if (item.answerValueSet.startsWith('#')) {
            self._expandContainedValueSet(lfData, item, pendingPromises);
          } else if (expURL) {
            const p = fetch(expURL, {
              headers: {
                'Accept': 'application/fhir+json'
              }
            }).then(function (response) {
              return response.json();
            }).then(function (parsedJSON) {
              if (parsedJSON.resourceType === "OperationOutcome") {
                var errorOrFatal = parsedJSON.issue.find(item => item.severity === "error" || item.severity === "fatal");
                if (errorOrFatal) {
                  let errors = {};
                  errorMessages.addMsg(errors, 'answerValueSetLoadingError');
                  const messages = [{
                    errors
                  }];
                  LForms.Util._internalUtil.setItemMessagesArray(item, messages, 'loadAnswerValueSets');
                  // Do not cache the result if expansion fails.
                  delete LForms._valueSetAnswerCache[vsKey];
                  throw new Error(errorOrFatal.diagnostics);
                }
              } else {
                var answers = self.answersFromVS(parsedJSON);
                if (answers) {
                  self._updateAnswersFromValueSetResponse(answers, lfData, item);
                  LForms._valueSetAnswerCache[vsKey] = answers;
                }
                return answers;
              }
            }).catch(function (error) {
              let errors = {};
              errorMessages.addMsg(errors, 'answerValueSetLoadingError');
              const messages = [{
                errors
              }];
              LForms.Util._internalUtil.setItemMessagesArray(item, messages, 'loadAnswerValueSets');
              const msg = `Unable to load ValueSet ${item.answerValueSet} from ${expURL}`;
              // Do not cache the result if expansion fails.
              delete LForms._valueSetAnswerCache[vsKey];
              throw new Error(msg);
            });
            pendingPromises.push(p);
            LForms._valueSetAnswerCache[vsKey] = p;
          } else {
            // use FHIR context
            var fhirClient = LForms.fhirContext?.client;
            if (!fhirClient) {
              const p = Promise.reject(new Error("Unable to load ValueSet " + item.answerValueSet + ".  A terminology server or a FHIR server is needed.  FHIR Questionnaires " + "can specify a preferred terminology server for loading value sets."));
              pendingPromises.push(p);
              // Cache the rejected Promise so the same vsKey don't need to be processed again,
              // and we return only one rejected promise for the same vsKey.
              LForms._valueSetAnswerCache[vsKey] = p;
            } else {
              const p = fhirClient.request({
                url: lfData._buildURL(['ValueSet', '$expand'], {
                  url: item.answerValueSet,
                  _format: 'json'
                }),
                headers: {
                  'Accept': 'application/fhir+json'
                }
              }).then(function (response) {
                var valueSet = response;
                var answers = self.answersFromVS(valueSet);
                if (answers) {
                  self._updateAnswersFromValueSetResponse(answers, lfData, item);
                  LForms._valueSetAnswerCache[vsKey] = answers;
                }
                return answers;
              }).catch(function (error) {
                throw new Error("Unable to load ValueSet " + item.answerValueSet + " from FHIR server");
              });
              pendingPromises.push(p);
              LForms._valueSetAnswerCache[vsKey] = p;
            }
          }
        }
      }
    }
    return pendingPromises;
  };

  /**
   * Expands contained valueset against terminology server.
   * Here we take care of the scenario of contained valuesets without an expansion.
   * If the contained valueset had an expansion, the answers list would already have been set
   * on the item from _processAnswers(), while answerValueSet property would not have been set.
   * @param lfData the LFormsData for the form
   * @param item an item in ltemList
   * @param pendingPromises pending promises list for loading answerValueSets
   * @private
   */
  self._expandContainedValueSet = function (lfData, item, pendingPromises) {
    const containedVS = lfData.contained.find(x => x.resourceType === 'ValueSet' && x.id === item.answerValueSet.substring(1));
    const terminologyServer = this._getTerminologyServer(item);
    if (terminologyServer) {
      const p = fetch(terminologyServer + '/ValueSet/$expand', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json'
        },
        body: JSON.stringify(containedVS)
      }).then(function (response) {
        return response.json();
      }).then(function (parsedJSON) {
        if (parsedJSON.resourceType === "OperationOutcome") {
          var errorOrFatal = parsedJSON.issue.find(item => item.severity === "error" || item.severity === "fatal");
          if (errorOrFatal) {
            throw new Error(errorOrFatal.diagnostics);
          }
        } else {
          if (self._widgetOptions?.allowHTML) {
            self._copyExtensionsToExpansion(parsedJSON);
          }
          var answers = self.answersFromVS(parsedJSON);
          if (answers) {
            self._updateAnswersFromValueSetResponse(answers, lfData, item);
            LForms._valueSetAnswerCache[item.answerValueSet] = answers;
          }
          return answers;
        }
      }).catch(function (error) {
        throw new Error("Unable to load ValueSet from " + terminologyServer + " for contained ValueSet " + item.answerValueSet);
      });
      pendingPromises.push(p);
      LForms._valueSetAnswerCache[item.answerValueSet] = p;
    } else {
      // use FHIR context
      var fhirClient = LForms.fhirContext?.client;
      if (!fhirClient) {
        const p = Promise.reject(new Error('Cannot load ValueSet "' + item.answerValueSet + '" because it requires either a terminology ' + 'server to be specified or LForms.Util.setFHIRContext(...) ' + 'to have been called to provide access to a FHIR server.'));
        pendingPromises.push(p);
        // Cache the rejected Promise so the same vsKey don't need to be processed again,
        // and we return only one rejected promise for the same vsKey.
        LForms._valueSetAnswerCache[item.answerValueSet] = p;
      } else {
        const p = fhirClient.request({
          url: 'ValueSet/$expand?_format=json',
          method: 'POST',
          headers: {
            'Content-Type': 'application/json'
          },
          body: JSON.stringify(containedVS)
        }).then(function (parsedJSON) {
          if (self._widgetOptions?.allowHTML) {
            self._copyExtensionsToExpansion(parsedJSON);
          }
          var answers = self.answersFromVS(parsedJSON);
          if (answers) {
            self._updateAnswersFromValueSetResponse(answers, lfData, item);
            LForms._valueSetAnswerCache[item.answerValueSet] = answers;
          }
          return answers;
        }).catch(function (error) {
          throw new Error("Unable to load ValueSet " + item.answerValueSet + " from FHIR server");
        });
        pendingPromises.push(p);
        LForms._valueSetAnswerCache[item.answerValueSet] = p;
      }
    }
  };

  /**
   * Updates item.answers based on the response of the answerValueSet $expand operation.
   * @param answers answers list extracted from answersFromVS()
   * @param lfData the LFormsData for the form
   * @param item an item in ltemList
   * @private
   */
  self._updateAnswersFromValueSetResponse = function (answers, lfData, item) {
    item.answers = answers;
    lfData._updateAutocompOptions(item);
    lfData._resetItemValueWithAnswers(item);
  };

  /**
   * When we do an $expand POST operation, the returned expansion may not have the
   * rendering-xhtml on _display. compose.include.concept may have the extension. Copy
   * _display to expansion.contains if there are matches in comose.include.concept.
   * @param parsedJSON the returned JSON object from an $expand POST operation
   */
  self._copyExtensionsToExpansion = function (parsedJSON) {
    if (!parsedJSON.expansion?.contains || !parsedJSON.compose?.include) {
      return;
    }
    parsedJSON.expansion.contains.forEach(function (vsItem) {
      // compose.include should have a system, but if both systems are undefined, they are considered a match.
      const matchingSytem = parsedJSON.compose.include.find(include => include.system === vsItem.system);
      if (matchingSytem) {
        const matchingCode = matchingSytem.concept?.find(concept => concept.code === vsItem.code);
        if (matchingCode?._display) {
          vsItem._display = matchingCode._display;
        }
      }
    });
  };

  /**
   * Handle the item.value in QuestionnaireResponse for CODING typed items
   * @param qrItemValue a value of item in QuestionnaireResponse
   * @param lfItem an item in lforms
   * @param notOnList a flag indicates if the item's value is known to be not any of the answers
   * in the answer list. If false or undefined, a check of the answers will be made.
   * @returns {{code: *, text: *}}
   * @private
   */
  self._processCODINGValueInQR = function (qrItemValue, lfItem, notOnList) {
    var retValue;
    // a valueCoding, which is one of the answers
    if (qrItemValue.valueCoding) {
      var c = qrItemValue.valueCoding;
      retValue = {};
      if (c.code) retValue.code = c.code;
      if (c.display) retValue.text = c.display;
      if (c.system) retValue.system = c.system;
      if (notOnList) {
        retValue._notOnList = true;
      }
      // compare retValue to the item.answers
      // if not same, add "_notOnList: true" to retValue
      else if (lfItem.answerConstraint === 'optionsOrString' && lfItem.answers) {
        var found = false;
        for (var i = 0, len = lfItem.answers.length; i < len; i++) {
          if (LForms.Util.areTwoAnswersSame(retValue, lfItem.answers[i], lfItem)) {
            found = true;
            break;
          }
        }
        if (!found) {
          retValue._notOnList = true;
        }
      }
    }
    // a valueString, which is a user supplied value that is not in the answers
    else if (qrItemValue.valueString && lfItem.answerConstraint === 'optionsOrString') {
      retValue = qrItemValue.valueString;
    }
    return retValue;
  };

  /**
   * Handle the item.value in QuestionnaireResponse for ST/INT/DT/TM typed items
   * that have an answer list.
   * @param {*} answer an answer of an item in QuestionnaireResponse
   * @param {*} lfItem an item in lforms
   * @returns
   */
  self._processOtherAnswerOptionValueInQR = function (answer, item) {
    // has an answer list
    if (_lib_lforms_internal_utils_js__WEBPACK_IMPORTED_MODULE_0__.InternalUtil.hasAnswerList(item)) {
      // answer repeats (autocomplete or checkboxes)
      if (ns._answerRepeats(item)) {
        var value = [];
        for (var j = 0, jLen = answer.length; j < jLen; j++) {
          var val = ns._convertOtherAnswerOptionValueInQR(answer[j], item);
          if (val) {
            value.push(val);
          }
        }
        item.value = value;
      }
      // answer not repeats, (autocomplete or radiobuttons)
      else {
        item.value = ns._convertOtherAnswerOptionValueInQR(answer[0], item);
      }
    }
  };

  /**
   * Convert FHIR values in QuestionnaireResponse for ST/INT/DT/TM typed items
   * that have an answer list, to lforms values
   * @param {*} qrItemValue a value of item in QuestionnaireResponse
   * @param {*} lfItem an item in lforms
   * @returns
   */
  self._convertOtherAnswerOptionValueInQR = function (qrItemValue, lfItem) {
    let retValue;
    let dataType = lfItem.dataType;
    if (lfItem.answers && (dataType === "ST" || dataType === "INT" || dataType === "DT" || dataType === "TM")) {
      let answerText;
      switch (dataType) {
        case "ST":
          answerText = qrItemValue.valueString;
          break;
        case "INT":
          answerText = qrItemValue.valueInteger;
          break;
        case "DT":
          answerText = qrItemValue.valueDate;
          break;
        case "TM":
          answerText = qrItemValue.valueTime;
          break;
      }
      if (answerText) {
        retValue = {
          text: answerText
        };
      } else if (lfItem.answerConstraint === "optionsOrString" && qrItemValue.valueString) {
        retValue = qrItemValue.valueString;
      }
    }
    return retValue; // retValue might not be in the answers? R5 allows that.
  };

  /**
   * Parse questionnaire item for coding instructions
   * @param targetItem the LForms node being populated with data
   * @param qItem {object} - Questionnaire item object
   * @return {boolean} true if the item is a help text item, false otherwise.
   * @private
   */
  self._processCodingInstructionsAndLegal = function (targetItem, qItem) {
    // if the qItem is a "display" typed item with a item-control extension, then it meant to be a help message,
    // which in LForms is an attribute of the parent item, not a separate item.
    // use one coding instruction if there are multiple ones in Questionnaire.
    let helpOrLegal, legal, errors, messages;
    let ci = LForms.Util.findObjectInArray(qItem.extension, 'url', self.fhirExtUrlItemControl);
    let xhtmlFormat;
    if (qItem.type === "display" && ci) {
      // true if it's a legal extension, false if it's a help extension.
      let isLegal = ci.valueCodeableConcept?.coding?.[0]?.code === 'legal';

      // only "rendering-xhtml" is supported. others are default to text
      if (qItem._text) {
        xhtmlFormat = LForms.Util.findObjectInArray(qItem._text.extension, 'url', "http://hl7.org/fhir/StructureDefinition/rendering-xhtml");
        const renderingStyle = LForms.Util.findObjectInArray(qItem._text.extension, 'url', "http://hl7.org/fhir/StructureDefinition/rendering-style");
        if (renderingStyle) {
          if (isLegal) {
            targetItem._obj_legalCSS = renderingStyle.valueString;
          } else {
            targetItem._obj_helpCSS = renderingStyle.valueString;
          }
        }
      }

      // there is a xhtml extension
      if (xhtmlFormat) {
        helpOrLegal = isLegal ? {
          legalFormat: "html",
          legal: xhtmlFormat.valueString,
          legalLinkId: qItem.linkId,
          legalPlain: qItem.text // this always contains the legal in plain text
        } : {
          codingInstructionsFormat: "html",
          codingInstructions: xhtmlFormat.valueString,
          codingInstructionsLinkId: qItem.linkId,
          codingInstructionsPlain: qItem.text // this always contains the coding instructions in plain text
        };
        // check if html string contains invalid html tags, when the html version needs to be displayed
        if (self._widgetOptions?.allowHTML) {
          let invalidTagsAttributes = LForms.Util._internalUtil.checkForInvalidHtmlTags(xhtmlFormat.valueString);
          if (invalidTagsAttributes && invalidTagsAttributes.length > 0) {
            if (isLegal) helpOrLegal.legalHasInvalidHtmlTag = true;else helpOrLegal.codingInstructionsHasInvalidHtmlTag = true;
            errors = {};
            errorMessages.addMsg(errors, isLegal ? 'invalidTagInLegalHTMLContent' : 'invalidTagInHelpHTMLContent');
            messages = [{
              errors
            }];
            LForms.Util._internalUtil.printInvalidHtmlToConsole(invalidTagsAttributes);
          }
        }
      }
      // no xhtml extension, default to 'text'
      else {
        helpOrLegal = isLegal ? {
          legalFormat: "text",
          legal: qItem.text,
          legalinkId: qItem.linkId,
          legalPlain: qItem.text // this always contains the legal in plain text
        } : {
          codingInstructionsFormat: "text",
          codingInstructions: qItem.text,
          codingInstructionsLinkId: qItem.linkId,
          codingInstructionsPlain: qItem.text // this always contains the coding instructions in plain text
        };
      }
      if (messages) {
        LForms.Util._internalUtil.setItemMessagesArray(targetItem, messages, '_processCodingInstructionsAndLegal');
      }
      if (helpOrLegal) {
        if (isLegal) {
          targetItem.legal = helpOrLegal.legal;
          targetItem.legalFormat = helpOrLegal.legalFormat;
          targetItem.legalPlain = helpOrLegal.legalPlain;
          targetItem.legalHasInvalidHtmlTag = helpOrLegal.legalHasInvalidHtmlTag;
          targetItem.legalLinkId = helpOrLegal.legalLinkId;
        } else {
          targetItem.codingInstructions = helpOrLegal.codingInstructions;
          targetItem.codingInstructionsFormat = helpOrLegal.codingInstructionsFormat;
          targetItem.codingInstructionsPlain = helpOrLegal.codingInstructionsPlain;
          targetItem.codingInstructionsHasInvalidHtmlTag = helpOrLegal.codingInstructionsHasInvalidHtmlTag;
          targetItem.codingInstructionsLinkId = helpOrLegal.codingInstructionsLinkId;
        }
      }
      return !!helpOrLegal;
    }
  };

  /**
   *  Processes the child items of the item.
   * @param targetItem the LForms node being populated with data
   * @param qItem the Questionnaire (item) node being imported
   * @param linkIdItemMap - Map of items from link ID to item from the imported resource.
   * @param containedVS - contained ValueSet info, see _extractContainedVS() for data format details
   * @param containedImages - contained images info, see buildContainedImageMap() for details.
   */
  self._processChildItems = function (targetItem, qItem, containedVS, linkIdItemMap, containedImages) {
    if (Array.isArray(qItem.item)) {
      targetItem.items = [];
      for (var i = 0; i < qItem.item.length; i++) {
        let isHelpTextItem = self._processCodingInstructionsAndLegal(targetItem, qItem.item[i]);
        if (!isHelpTextItem) {
          var item = self._processQuestionnaireItem(qItem.item[i], containedVS, linkIdItemMap, containedImages);
          targetItem.items.push(item);
        }
      }
    }
  };

  /**
   *  Copy extensions that haven't been handled before.
   *
   * @param lfItem the LForms node being populated with data
   * @param qItem the Questionnaire (item) node being imported
   */
  self._processExtensions = function (lfItem, qItem) {
    var extensions = [];
    if (Array.isArray(qItem.extension)) {
      for (var i = 0; i < qItem.extension.length; i++) {
        var ext = qItem.extension[i];
        var extHandler = self.extensionHandlers[ext.url];
        // Extensions should be copied if they aren't handled, which means
        // 1) there isn't an extension handler or there is one that returns true (the signal to copy),  and
        // 2) they are not in the handledExtensions list.
        if ((!extHandler || extHandler && extHandler(ext, lfItem)) && !self.handledExtensionSet.has(qItem.extension[i].url)) {
          extensions.push(qItem.extension[i]);
        }
      }
    }
    if (extensions.length > 0) {
      lfItem.extension = extensions;
    }
  };

  /**
   * If the given entity is an array, it will return the array length, return -1 otherwise.
   * @param entity the given entity (can be anything) that needs to be tested to see if it's an array
   * @return {number} the array length or -1 if the given entity is not an array.
   * @private
   */
  self._arrayLen = function (entity) {
    return entity && Array.isArray(entity) ? entity.length : -1;
  };

  /**
   * Get structural info of a QuestionnaireResponse item.answer.item in a way similar to that of item.item.
   * If any answer entry in item.answer has items, the qrItemInfo.qrAnswersItemsInfo will be assigned, which
   * will be an array where each element corresponds to one answer element in item.answer. When an answer entry
   * does not have any items, null will be used to fill the position.
   * @param qrItemInfo the structural info of the given item
   * @param item the item in a QuestionnaireResponse object whose answer.item structure is to be created.
   * @private
   */
  self._checkQRItemAnswerItems = function (qrItemInfo, item) {
    var answerLen = self._arrayLen(item.answer);
    if (answerLen < 1) {
      return;
    }
    var numAnswersWithItems = 0;
    var answersItemsInfo = []; // one entry for each answer; each entry is an qrItemsInfo array for the answer.item
    for (var i = 0; i < answerLen; i++) {
      if (this._arrayLen(item.answer[i].item) > 0) {
        answersItemsInfo.push({});
        self._mergeQR._checkQRItems(answersItemsInfo[i], item.answer[i]);
        ++numAnswersWithItems;
      } else {
        answersItemsInfo.push(null);
      }
    }
    if (numAnswersWithItems > 0) {
      qrItemInfo.numAnswersWithItems = numAnswersWithItems;
      qrItemInfo.qrAnswersItemsInfo = answersItemsInfo;
    }
  };

  /**
   * Parse questionnaire item for restrictions
   *
   * @param lfItem {object} - LForms item object to assign restrictions
   * @param qItem {object} - Questionnaire item object
   * @private
   */
  self._processRestrictions = function (lfItem, qItem) {
    var restrictions = {};
    if (typeof qItem.maxLength !== 'undefined') {
      restrictions['maxLength'] = qItem.maxLength.toString();
    }
    for (var i = 0; i < self.fhirExtUrlRestrictionArray.length; i++) {
      var restriction = LForms.Util.findObjectInArray(qItem.extension, 'url', self.fhirExtUrlRestrictionArray[i]);
      var val = self._getFHIRValueWithPrefixKey(restriction, /^value/);
      if (val !== undefined && val !== null) {
        if (restriction.url.match(/minValue$/)) {
          // TODO -
          // There is no distinction between inclusive and exclusive.
          // Lforms looses this information when converting back and forth.
          restrictions['minInclusive'] = val;
        } else if (restriction.url.match(/maxValue$/)) {
          restrictions['maxInclusive'] = val;
        } else if (restriction.url.match(/minLength$/)) {
          restrictions['minLength'] = val;
        } else if (restriction.url.match(/regex$/)) {
          restrictions['pattern'] = val;
        } else if (restriction.url.match(/maxDecimalPlaces$/)) {
          restrictions['maxDecimalPlaces'] = parseInt(val);
        }
      }
    }
    if (!LForms.jQuery.isEmptyObject(restrictions)) {
      lfItem.restrictions = restrictions;
    }
  };
}
/* harmony default export */ __webpack_exports__["default"] = (addCommonSDCImportFns);

/***/ }),
/* 102 */
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   InternalUtil: function() { return /* binding */ InternalUtil; }
/* harmony export */ });
/* harmony import */ var _error_messages_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(103);
/* harmony import */ var _lforms_lhc_common_utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(104);
/* harmony import */ var _lhc_form_datatypes_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(337);
/* harmony import */ var htmlparser2__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(338);
/* harmony import */ var style_to_object__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(362);
// Utility functions for files in the lforms project, not intended to be called
// by application code.





/**
 *  A default message source identifier (for when the messageSource parameter
 *  below is optional and not provided.
 */
const defaultMsgSource = 'Other message source';
const InternalUtil = {
  /**
   *  Sets the value of the item, which is the case of a quantity, involves more
   *  than one field (at present -- that might change.)
   * @param item the item receiving the value.
   * @param val the new value, which if it its origin was FHIR, should have
   *  already been processed and converted.  A quantity value is expected to be an Object with
   *  a _type key set to Quantity but with the LForms fields for units ('name',
   *  'code', and 'system'), plus a "value" field.
   * @param type (optional) the type of the value, e.g. 'Quantity'.  If this is
   *  set, then val._type will not be checked.
   * @return {boolean} whether the item.value or item.unit has changed.
   */
  assignValueToItem: function (item, val, type) {
    var changed = false;
    type = type || val && val._type;
    if (val && type === 'Quantity') {
      if (item.value !== val.value) {
        item.value = val.value;
        changed = true;
      }
      var newUnit = {
        name: val.name
      };
      if (val.code) {
        newUnit.code = val.code;
        if (val.system) newUnit.system = val.system;
      }
      if (!_lforms_lhc_common_utils_js__WEBPACK_IMPORTED_MODULE_1__["default"].deepEqual(item.unit, newUnit)) {
        item.unit = newUnit;
        changed = true;
      }
    } else if (!_lforms_lhc_common_utils_js__WEBPACK_IMPORTED_MODULE_1__["default"].deepEqual(item.value, val)) {
      item.value = val;
      changed = true;
    }
    return changed;
  },
  /**
   *  Constructs a model object for an off-list unit.
   * @param unitText the text the user typed for the off-list unit
   * @return an object suitable for item.unit.
   */
  modelForOffListUnit: function (text) {
    return text ? {
      "name": text,
      "_displayUnit": text
    } : undefined;
  },
  /**
   * Sets answer.textHTML from the rendering-xhtml extension.
   * @param answer an answer object in Lforms item.
   * @param xhtmlFormat the "rendering-xhtml" extension from Questionnaire.
   * @param allowHTML widget option of whether to allow HTML in forms.
   * @param containedImages contained images info, see buildContainedImageMap() for details.
   */
  setAnswerTextHTML: function (answer, xhtmlFormat, allowHTML, containedImages) {
    answer.textHTML = xhtmlFormat.valueString;
    if (allowHTML) {
      // process contained images
      if (containedImages && xhtmlFormat.valueString.match(/img/) && xhtmlFormat.valueString.match(/src/)) {
        answer.textHTML = this._getHtmlStringWithContainedImages(containedImages, xhtmlFormat.valueString) || answer.textHTML;
      }
      let invalidTagsAttributes = this.checkForInvalidHtmlTags(answer.textHTML);
      if (invalidTagsAttributes && invalidTagsAttributes.length > 0) {
        answer._hasInvalidHTMLTagInText = true;
        this.printInvalidHtmlToConsole(invalidTagsAttributes);
      }
    }
  },
  /**
   * Check and return not allowed tags within the HTML version of the help text.
   * See https://build.fhir.org/ig/HL7/sdc/rendering.html and
   * https://hl7.org/fhir/R4/narrative.html for allowed subset of the HTML tags.
   * @param {*} htmlNarrative
   * @return [{array}] an array of invalid tags and attributes
   */
  checkForInvalidHtmlTags: function (htmlNarrative) {
    let invalidTagsAttributes = [];
    let forbiddenTags = ['html', 'head', 'body', 'ref', 'script', 'form', 'base', 'link', 'xlink', 'iframe', 'object'];
    let deprecatedTags = ['applet', 'basefont', 'blink', 'center', 'dir', 'embed', 'font', 'frame', 'frameset', 'isindex', 'noframes', 'marquee', 'menu', 'plaintext', 's', 'strike', 'u'];
    const FORBIDDEN_TAGS = forbiddenTags.concat(deprecatedTags);
    const ALLOWED_URI_REGEXP = /^(?:data:|#|\/)/i;
    const FORBIDDEN_ATTR = [];
    // https://developer.mozilla.org/en-US/docs/Web/CSS/url_function
    const CSS_PROPERTIES_WITH_URL = ["background", "background-image", "border", "border-image", "border-image-source", "content", "cursor", "filter", "list-style", "list-style-image", "mask", "mask-image", "offset-path", "clip-path"];

    // Tags (not in the FORBIDDEN_TAGS list above) that could have a URL value.
    // See https://stackoverflow.com/questions/2725156/complete-list-of-html-tag-attributes-which-have-a-url-value
    // TBD: A full url in 'cite' might not be invalid.
    const TAGS_WITH_URL = {
      "a": ["href"],
      "area": ["href"],
      "blockquote": ["cite"],
      "del": ["cite"],
      "img": ["langdesc", "src", "usemap"],
      "input": ["src", "usemap"],
      "ins": ["cite"],
      "q": ["cite"],
      "audio": ["src"],
      "button": ["formaction"],
      "input": ["formaction"],
      "source": ["src"],
      "tract": ["src"],
      "video": ["poster", "src"]
    };
    // Some tags have multiple URL values in an attributes. For example:
    // <img srcset="/image4x.jpg 4x, /image3x.jpg 3x, /image2x.jpg 2x, /image1x.jpg 1x"
    //      src="/image.jpg">
    const TAGS_WITH_MULTIPLE_URLS_IN_ONE_ATTR = {
      "img": "srcset",
      "source": "srcset" //'srcset' has one URL when <source> is included in <picture> and <video> (where multiple <source> tags are used instead).
    };
    let that = this;
    const parser = new htmlparser2__WEBPACK_IMPORTED_MODULE_3__.Parser({
      onopentag(name, attributes) {
        // check tags
        FORBIDDEN_TAGS.forEach(tag => {
          if (name.toLocaleLowerCase() === tag) {
            invalidTagsAttributes.push({
              "tag": tag
            });
          }
        });
        // check attributes with one URL value
        for (const [tag, urlAttrs] of Object.entries(TAGS_WITH_URL)) {
          if (name.toLocaleLowerCase() === tag) {
            for (const [attr, value] of Object.entries(attributes)) {
              urlAttrs.forEach(urlAttr => {
                if (attr === urlAttr && !value.match(ALLOWED_URI_REGEXP)) {
                  invalidTagsAttributes.push({
                    "tag": tag,
                    "attribute": urlAttr
                  });
                }
              });
            }
          }
        }
        ;
        // check attributes that could have multiple URL values
        for (const [tag, urlAttr] of Object.entries(TAGS_WITH_MULTIPLE_URLS_IN_ONE_ATTR)) {
          if (name.toLocaleLowerCase() === tag) {
            for (const [attr, value] of Object.entries(attributes)) {
              if (attr === urlAttr) {
                let urlValues = value.split(",");
                urlValues.forEach(urlValue => {
                  if (!urlValue.trim().match(ALLOWED_URI_REGEXP)) {
                    invalidTagsAttributes.push({
                      "tag": tag,
                      "attribute": urlAttr
                    });
                  }
                });
              }
            }
          }
        }
        ;
        // check attributes (not FORBIDDEN_ATTR for now)
        // for (const [attr, value] of Object.entries(attributes)) {
        //   FORBIDDEN_ATTR.forEach(forbiddenAttr => {
        //     if(attr === forbiddenAttr) {
        //       invalidTagsAttributes.push({"tag": name.toLocaleLowerCase(), "attribute": forbiddenAttr });
        //     }
        //   });
        // }

        // check "style" attribute for URLs
        for (const [attr, value] of Object.entries(attributes)) {
          if (attr === "style") {
            // parse the CSS string
            let cssObj = (0,style_to_object__WEBPACK_IMPORTED_MODULE_4__["default"])(value);
            for (const [cssProp, cssValue] of Object.entries(cssObj)) {
              CSS_PROPERTIES_WITH_URL.forEach(styleProp => {
                if (cssProp.toLocaleLowerCase() === styleProp) {
                  let forbiddenURLs = that._hasForbiddenCssUrl(cssValue);
                  forbiddenURLs.forEach(urlString => {
                    invalidTagsAttributes.push({
                      "tag": name.toLocaleLowerCase(),
                      "attribute": "style",
                      "cssPropertyValue": styleProp + " : " + urlString
                    });
                  });
                }
              });
            }
          }
        }
      }
      // Do nothing on onclosetag(name, attributes) {}
    });
    parser.write(htmlNarrative);
    parser.end();
    return invalidTagsAttributes;
  },
  /** Check if URLs in CSS have values that are not allowed by FHIR specs
   * (Remote URLs are not allowed)
   * @param {*} cssValue CSS value on the 'style' attribute of a DOM element
   * @returns A array of URLs that are not allowed.
   */
  _hasForbiddenCssUrl: function (cssValue) {
    // possible usage of url() in the cssValue
    // Note: css property name is case-sensitive.
    //
    // //No url(\'https://example.com/images/myImg.jpg\');
    // url("https://example.com/images/myImg.jpg");
    // url(\"https://example.com/images/myImg.jpg\");
    // url('https://example.com/images/myImg.jpg');
    // url(https://example.com/images/myImg.jpg);
    // url("data:image/jpg;base64,iRxVB0");
    // url(\"data:image/jpg;base64,iRxVB0\");
    // url('data:image/jpg;base64,iRxVB0');
    // url(data:image/jpg;base64,iRxVB0);
    // url(myImg.jpg);
    // url(#IDofSVGpath);

    // Any external URLs are not allowed, including http, https, file
    // or other protocols.
    // url("https://...");
    // url(\"https://...");
    // url('https://...');
    // url(https://...);
    // url("http://...");
    // url(\"http://...");
    // url('http://...');
    // url(http://...);
    // url("file://...");
    // url(\"file://...");
    // url('file://...');
    // url(file://...);

    // sample output:
    //  css= "url(\"img_tree.gif\"), url('file://local.jpg'),url('paper.gif'),url(http://google.com), url(\"example_with_url_inside.gif\"),url('url(123.png)')"
    //  [
    //   "url(\"img_tree.gif\")",
    //   "url('paper.gif')",
    //   "url('file://local.jpg')",
    //   "url(http://google.com)",
    //   "url(\"example_with_url_inside.gif\")",
    //   "url('url(123.png)"
    //  ]

    let forbiddenURLs = [];
    const CSS_URL_REGEXP = /url\(\s*["']?(.*?)["']?\s*\)/g;
    let matched = cssValue.match(CSS_URL_REGEXP);
    const URL_PARAM_REGEXP = /^url\(\s*[\\"']?[A-Za-z0-9]*\:\/\//;
    if (matched) {
      for (let i = 0; i < matched.length; i++) {
        let urlString = matched[i];
        if (urlString.match(URL_PARAM_REGEXP)) {
          forbiddenURLs.push(urlString);
        }
      }
    }
    return forbiddenURLs;
  },
  /**
   * Prints detailed errors about invalid HTML in console.
   * @param invalidTagsAttributes object of invalid HTML tag and attributes
   * returned from checkForInvalidHtmlTags().
   */
  printInvalidHtmlToConsole: function (invalidTagsAttributes) {
    console.log("Possible invalid HTML tags/attributes:");
    invalidTagsAttributes.forEach(ele => {
      if (ele.attributeValue) {
        console.log("  - Attribute value: " + ele.attributeValue + " of " + ele.attribute + " in " + ele.tag);
      } else if (ele.attribute) console.log("  - Attribute: " + ele.attribute + " in " + ele.tag);else if (ele.tag) console.log("  - Element: " + ele.tag);
    });
  },
  /**
   *  Sets the "messages" attribute of the given item.  If the given array of
   *  messages object only consists of nulls (no messages), then the messages
   *  attribute will be removed from the item.
   * @param item an item from and lforms form definition
   * @param messages an array of message objects (see _convertFHIRValues for
   * details)
   * @param messageSource a string indentifier for the source of these messages,
   *  to distinguish them from messages from other sources.
   */
  setItemMessagesArray: function (item, messages, messageSource) {
    // Consolidate the array of message objects into one object for this item.
    // The code below is optimized for the usual case where there are no messages.
    let itemMsg, msgTypes;
    for (let m of messages) {
      if (m) {
        if (!itemMsg) {
          itemMsg = {
            errors: {},
            warnings: {},
            info: {}
          };
          msgTypes = Object.keys(itemMsg);
        }
        for (let t of msgTypes) {
          if (m[t]) {
            Object.assign(itemMsg[t], m[t]);
          }
        }
      }
    }
    this.setItemMessages(item, itemMsg, messageSource);
  },
  /**
   *  Updates the "messages" attribute of the given item.  Any extisting
   *  messages are preserved, and new messages are added.  Note that these
   *  messages are statements about things that happened, not validation.
   * @param item an item from and lforms form definition
   * @param messages a message object (see _convertFHIRValues for
   *  details).  May be null or undefined to remove the messages for
   *  messageSource.
   * @param messageSource a string indentifier for the source of these messages,
   *  to distinguish them from messages from other sources.
   */
  setItemMessages: function (item, messages, messageSource) {
    if (messages) {
      if (!item.messages) item.messages = {};
      item.messages[messageSource] = messages;
    } else if (item.messages) {
      delete item.messages[messageSource];
      if (!Object.keys(item.messages).length) delete item.messages;
    }
  },
  /**
   *  Adds a warning message to the given item.
   * @param item the item which should get the warning.
   * @param messageID the ID of the warning message
   * @param messageSource (optional) a string indentifier for the source of these messages,
   *  to distinguish them from messages from other sources.  If not provided a
   *  default source identifier will be used
   */
  addItemWarning: function (item, messageID, messageSource) {
    if (!messageSource) messageSource = 'Other message source';
    let msgObj = item.messages;
    if (!msgObj) msgObj = item.messages = {};
    let msgsFromSource = msgObj[messageSource];
    if (!msgsFromSource) msgsFromSource = msgObj[messageSource] = {};
    let warnings = msgsFromSource.warnings;
    if (!warnings) warnings = msgsFromSource.warnings = {};
    warnings[messageID] = _error_messages_js__WEBPACK_IMPORTED_MODULE_0__.ErrorMessages.getMsg(messageID);
    console.log(JSON.stringify(item.messages));
  },
  /**
   *  Removes a warning message from the given item.
   * @param item the item which has the warning.
   * @param messageID the ID of the warning message
   * @param messageSource (optional) a string indentifier for the source of these messages,
   *  to distinguish them from messages from other sources.  If not provided a
   *  default source identifier will be used
   */
  removeItemWarning: function (item, messageID, messageSource) {
    if (!messageSource) messageSource = 'Other message source';
    let msgs, msgsFromSource, warnings;
    if ((msgs = item.messages) && (msgsFromSource = msgs[messageSource]) && (warnings = msgsFromSource.warnings)) {
      delete warnings[messageID];
    }
  },
  /**
   *  Check if the lforms item has an answer list
   * @param {*} item
   * @returns
   */
  hasAnswerList: function (item) {
    return item.dataType === "CODING" || item.answers && (item.dataType === "ST" || item.dataType === "INT" || item.dataType === "DT" || item.dataType === "TM");
  },
  /**
   * Get the rendering-xhtml string, replacing local ids in the 'src' attributes of
   * the 'img' tags if the local ids are in the 'contained' with image data,
   * @param containedImages a hashmap of image data from the "contained" in FHIR questionnaire
   * @param value an HTML string
   */
  _getHtmlStringWithContainedImages: function (containedImages, value) {
    if (containedImages) {
      // go though each image in the html string and replace local ids in image source
      // with contained data
      let parser = new DOMParser();
      let doc = parser.parseFromString(value, "text/html");
      let imgs = doc.getElementsByTagName("img");
      for (let i = 0; i < imgs.length; i++) {
        let urlValue = imgs[i].getAttribute("src");
        if (urlValue && urlValue.match(/^#/)) {
          let localId = urlValue.substring(1);
          let imageData = containedImages[localId];
          if (imageData) {
            imgs[i].setAttribute("src", imageData);
          }
        }
      }
      return doc.body.innerHTML;
    } else {
      return '';
    }
  },
  /**
   * Check an item's skip logic status to decide if the item is enabled
   * @param item an item
   * @returns {boolean}
   */
  targetEnabled: function (item) {
    return item._enableWhenExpVal !== false && item._skipLogicStatus !== _lhc_form_datatypes_js__WEBPACK_IMPORTED_MODULE_2__["default"].SKIP_LOGIC.STATUS_DISABLED;
  },
  /**
   * Check an item's skip logic status to decide if the item is disabled and
   * protected.
   * @param item an item
   * @returns {boolean}
   */
  targetDisabledAndProtected: function (item) {
    return item._disabledDisplayStatus === 'protected' && !this.targetEnabled(item);
  },
  /**
   * Check if the item should be displayed.
   * @param item an item
   * @return {boolean}
  */
  targetShown: function (item) {
    return item._disabledDisplayStatus === 'protected' || this.targetEnabled(item);
  },
  /**
   * Construct an id for an answer when it is rendered as a radio button
   * or a checkbox.
   * @param item an item in lhc-forms
   * @param answer an answer in the item's answer list.  If this is a
   *  string  an id for an "Other" option element is created.
   * @returns the constructed id
   */
  getItemAnswerId(item, answer) {
    // A code can contain spaces, but an id cannot.
    // Replace spaces with %20, but first replace % with %25.
    // We have to do the same replacement with answer.text if the code is
    // missing.
    // Also, combine the system with the code as a token (using |).  We will need to
    // escape the | and \ characters .  (See
    // https://www.hl7.org/fhir/R4/search.html#escaping)
    // We should not need to escape the | characters in _elementId for an
    // answer ID, because, the goal is just to make the IDs unique.  However,
    // since the format for an "other" element ID is similar (missing the system
    // component) we do need to escape the | in the element ID in that case.
    let rtn;
    const elemId = item._elementId;
    if (typeof answer != 'string') {
      const system = answer.system ? answer.system.replaceAll('\\', '\\\\').replaceAll('|', '\\|') : '';
      const answerCodeOrText = (answer.code || answer.text.toString()).replaceAll('%', '%25').replaceAll(' ', '%20').replaceAll('\\', '\\\\').replaceAll('|', '\\|');
      rtn = elemId + '|' + system + '|' + answerCodeOrText;
    } else rtn = elemId.replaceAll('\\', '\\\\').replaceAll('|', '\\|') + '|' + answer;
    return rtn;
  }
};
InternalUtil.errorMessages = _error_messages_js__WEBPACK_IMPORTED_MODULE_0__.ErrorMessages;
// Set the default language for error messages.  Apps can call this with a
// different language code, if error-messages.js has messages in that language.
InternalUtil.errorMessages.setLanguage('en');

/***/ }),
/* 103 */
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ErrorMessages: function() { return /* binding */ ErrorMessages; }
/* harmony export */ });
/**
 *  A class for retrieving error messages (or warnings or info messages).
 *  These messages are intended to be about things that happened, not about
 *  validation, because there is no good way to remove the old messages when
 *  they don't apply without adversely impacting peformance.
 */

const ErrorMessages = {
  messages: {
    'comparatorInQuantity': {
      'en': 'This item cannot accept a quantity with a comparator'
    },
    'nonMatchingQuantityUnit': {
      'en': 'An attempt was made to assign a quantity with a non-matching unit.'
    },
    'MultipleValuesForNonRepeat': {
      'en': 'An attempt was made to assign multiple values to a non-repeating item.'
    },
    'invalidTagInHelpHTMLContent': {
      'en': 'Invalid HTML tags/attributes found in the help text.'
    },
    'invalidTagInLegalHTMLContent': {
      'en': 'Invalid HTML tags/attributes found in the legal text.'
    },
    'invalidTagInHTMLContent': {
      'en': 'Invalid HTML tags/attributes found in item text/prefix.'
    },
    'answerValueSetLoadingError': {
      'en': 'Unable to load the answer list for this question.'
    }
  },
  /**
   *  Returns the text for a message.
   * @param messageID the id of the message
   * @return the text corresponding to messageID.
   */
  getMsg: function (messageID) {
    const messageData = this.messages[messageID];
    if (!messageData) throw new Error('Unknown message ID "' + messageID + '"');
    const message = messageData[this.language];
    if (!message) throw new Error('Unknown language code "' + this.language + '" for message ID "' + messageID + '"');
    return message;
  },
  /**
   *  Adds the message with the given ID to the given message object.
   * @param msgObj an object to which the message will be added, with the given
   * messageID as the key and the text as the value.
   * @param messageID the id of the message
   */
  addMsg: function (msgObj, messageID) {
    msgObj[messageID] = this.getMsg(messageID);
  },
  /**
   *  Sets the language code used by getMsg.
   * @param language the language code for the message.  This must be one of the
   *  languages of the messages above.
   */
  setLanguage: function (language) {
    this.language = language;
  }
};

/***/ }),
/* 104 */
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var moment__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(105);
/* harmony import */ var moment__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(moment__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var fast_copy__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(242);
/* harmony import */ var deep_equal__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(243);
/* harmony import */ var deep_equal__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(deep_equal__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _language_config_json__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(336);
/**
 * Common utility functions
 */




const CommonUtils = {
  // Acceptable date formats

  // Strict parsing -
  parseDateFormats: [..._language_config_json__WEBPACK_IMPORTED_MODULE_3__.parsedDateFormats, (moment__WEBPACK_IMPORTED_MODULE_0___default().ISO_8601)],
  intRegex: /^\s*(\+|-)?\d+\s*$/,
  decRegex: new RegExp(_language_config_json__WEBPACK_IMPORTED_MODULE_3__.decimalRegex),
  /**
   * Check if two answers can be treated as same
   * @param answer an answer item that could have part of the attributes set.
   * It should be an object, or this function will return false.
   * @param completeAnswer an answer in the answer list that usually has more attributes set
   * @param item the lforms item that has the completeAnswer in the answer list
   * @return {boolean} whether two answers are considered same.
   */
  areTwoAnswersSame: function (answer, completeAnswer, item) {
    let standardAnswerAttr = ['label', 'code', 'text', 'score', 'other'];
    //let standardAnswerAttr = ['label', 'code', '_displayText', 'score', 'other'];

    if (typeof answer !== "object") {
      return false;
    }
    // answer in LForms might not have a codeSystem, check item.answerCodeSystem and form's codeSystem
    let completeAnswerCodeSystem = completeAnswer.system ? completeAnswer.system : item.answerCodeSystem;

    // check answers' attributes if they have the same code system
    let same = false;
    // if no code system or same code system
    if (!answer.system && !completeAnswer.system || answer.system === completeAnswerCodeSystem) {
      // check all fields in answer
      same = true;
      let fields = Object.keys(answer);
      for (var i = 0, iLen = fields.length; i < iLen; i++) {
        // not to check extra attributes not specified in specs.
        if (standardAnswerAttr.indexOf(fields[i]) >= 0 && answer[fields[i]] !== completeAnswer[fields[i]]) {
          same = false;
          break;
        }
      }
    }
    return same;
  },
  /**
    * This function and stringToDTDateISO are meant to work as a pair on DT (or FHIR date) data type.
    * The idea is that DT/date type does not have timezone info, as a result, the string value could be
    * off by a day during either way of conversion depending on the time zone the code is executed.
    * The solution here is to keep the literal values of the year, month, and date components remain
    * unchanged regardless of the time zones.
    * Convert the given date object into a DT type date string, in "yyyy-mm-dd" format, where the
    * year, month, and date are based on the "local time zone" as the users can see on the display.
    * @param dateObj the date object to be converted.
    * @return date string in yyyy-mm-dd format with year, month, and date values corresponding to that
    * at the local timezone.
    */
  dateToDTStringISO: function (dateObj) {
    return !dateObj || !(dateObj instanceof Date) || isNaN(dateObj.getTime()) ? undefined : [(10000 + dateObj.getFullYear()).toString().substr(1), (101 + dateObj.getMonth()).toString().substr(1), (100 + dateObj.getDate()).toString().substr(1)].join('-');
  },
  /**
   * Parse the given iso date string, that is, a string of format "yyyy[-mm[-dd]]", into a Date object,
   * and then, adjust the year, month, and day so that when displayed (as local date) the literal values of
   * the year, month, and date components remain unchanged.
   * See the comments/docs for function dateToDTStringISO().
   * @param isoDateString
   */
  stringToDTDateISO: function (isoDateString) {
    var d = new Date(isoDateString);
    return isNaN(d.getTime()) ? undefined : new Date(d.getUTCFullYear(), d.getUTCMonth(), d.getUTCDate());
  },
  /**
   * Get a formatted date string from a date object
   * for example: "2016-10-31T14:42:12Z"
   * @param objDate a date object, or a valid string representation of date.
   * @returns a formatted date string
   */
  dateToDTMString: function (objDate) {
    if (typeof objDate === 'string') {
      objDate = this.stringToDate(objDate, true);
    }
    return objDate.toISOString();
  },
  // TODO: move to lhc-form-utils.js
  /**
   * Parse a formatted date string and create a date object
   * @param strDate a formatted date string
   * @param looseParsing {boolean} - Do default parsing. Intended to parse output
   * from native date object, typically from programmatic output from widgets. Default is false.
   * @returns a date object
   */
  stringToDate: function (strDate, looseParsing) {
    if (!strDate || typeof strDate != 'string') {
      // maybe already a date object.
      return strDate;
    }
    if (strDate.trim() === 't') {
      return new Date();
    }
    let m = moment__WEBPACK_IMPORTED_MODULE_0___default()(strDate, this.parseDateFormats, true);
    if (looseParsing && !m.isValid()) {
      // Make another attempt for loose parsing.
      m = moment__WEBPACK_IMPORTED_MODULE_0___default()(strDate);
    }
    return m.isValid() ? m.toDate() : null;
  },
  /**
   * Validate date object or date string. If string, check to see if it is in acceptable formats.
   * See stringToDate() for acceptable formats.
   * @param date {Date | string} - Potential date object or date string
   * @returns boolean
   */
  isValidDate: function (date) {
    return !!this.stringToDate(date);
  },
  /**
   * Format a date object with given format. Refer to momentjs documentation for
   * format specification.
   *
   * @param date - Date object
   * @param format - Format string
   * @returns {string}
   */
  formatDate: function (date, format) {
    return moment__WEBPACK_IMPORTED_MODULE_0___default()(date).format(format);
  },
  /**
   * Get the letter (or letters) indicator for the next repeating instance
   * The letters returned are in the pattern of:
   * 'a','b',...,'z','aa','ab',...,'az','ba','bb',...
   * for index that is:
   *  1,  2, ..., 26, 27,  28, ..., 52,  53,  54, ...
   * @param index the index for the current repeating instance, starting with 1
   */
  getNextLetter: function (index) {
    var letters = "abcdefghijklmnopqrstuvqxyz";
    var positions = [];
    var wkIndex = index;
    while (wkIndex > 0) {
      var letterIndex = wkIndex % 26;
      letterIndex = letterIndex === 0 ? 25 : letterIndex - 1;
      positions.push(letterIndex);
      wkIndex = Math.floor((wkIndex - 1) / 26);
    }
    var nextLetter = "";
    for (var i = positions.length - 1; i >= 0; i--) {
      nextLetter += letters.charAt(positions[i]);
    }
    return nextLetter;
  },
  // TODO: move to lhc-form-utils.js
  /**
   * Finds an object from an array using key/value pair with an optional start index.
   * The matching value should be a primitive type. If start index is not specified,
   * it is assumed to be 0.
   *
   * Only returns the first matched object in the array.
   *
   * @param targetObjects - Array of objects to search using key and value
   * @param key - Key of the target object to match the value.
   * @param matchingValue - Matching value of the specified key.
   * @param starting_index - Optional start index to lookup. Negative number indicates index from end.
   *   The absolute value should be less than the length of items in the array. If not
   *   the starting index is assumed to be 0.
   * @param all - If true, then an array will be returned containing all
   *  matches.
   *
   * @returns {*} - If "all" is false (default), then this returns the first matched
   *  object, or null if none matched.  If "all" is true, then this will return
   *  an array containing any matched objects.
   */
  findObjectInArray: function (targetObjects, key, matchingValue, starting_index, all) {
    var ret = all ? [] : null;
    if (Array.isArray(targetObjects)) {
      var start = 0;
      // Figure out start index.
      if (starting_index && Math.abs(starting_index) < targetObjects.length) {
        if (starting_index < 0) {
          start = targetObjects.length + starting_index;
        } else {
          start = starting_index;
        }
      }
      var len = targetObjects.length;
      for (var i = start; i < len; i++) {
        if (targetObjects[i][key] === matchingValue) {
          var match = targetObjects[i];
          if (all) ret.push(match);else {
            ret = match;
            break;
          }
        }
      }
    }
    return ret;
  },
  /**
   * Remove key/values from an object based on a regular expression of key.
   *
   * @param obj {object} - Object to prune
   * @param keyRegex {regex} - A regular expression to match the keys for deletion
   * @param recursiveKey {optional|string} - Key of the recursive field. The value
   *                                of this should be an object or an Array of objects.
   * @private
   */
  _pruneObject: function (keyRegex, obj, recursiveKey) {
    if (typeof obj === 'object') {
      for (var k in obj) {
        if (k.match(keyRegex)) {
          delete obj[k];
        } else if (recursiveKey && k === recursiveKey) {
          var val = obj[k];
          if (Array.isArray(val)) {
            var len = val.length;
            for (var i = 0; i < len; i++) {
              this._pruneObject(keyRegex, val[i], recursiveKey);
            }
          } else {
            this._pruneObject(keyRegex, val, recursiveKey);
          }
        }
      }
    }
  },
  // TODO: move to lhc-form-utils.js
  /**
   * Utility to walkthrough recurively through each element in a collection
   *
   * @param collectionObj
   */
  pruneNulls: function (collectionObj) {
    if (Array.isArray(collectionObj)) {
      for (var i = collectionObj.length - 1; i >= 0; i--) {
        if (collectionObj[i] === null || collectionObj[i] === undefined) {
          collectionObj.splice(i, 1);
        } else if (typeof collectionObj[i] === 'object') {
          this.pruneNulls(collectionObj[i]);
        }
      }
    } else if (collectionObj && typeof collectionObj === 'object') {
      var keys = Object.keys(collectionObj);
      keys.forEach(function (key) {
        if (collectionObj[key] === null || collectionObj[key] === undefined) {
          delete collectionObj[key];
        } else if (typeof collectionObj[key] === 'object') {
          this.pruneNulls(collectionObj[key]);
        }
      }, this);
    }
  },
  /**
   * deep copy of an object
   * @param {*} sourceObj an object
   * @returns an copied new object
   */
  deepCopy: function (sourceObj) {
    return (0,fast_copy__WEBPACK_IMPORTED_MODULE_1__["default"])(sourceObj);
  },
  /**
   * deep comparison of two objects
   * @param {*} obj1 an object
   * @param {*} obj2 an object
   * @returns
   */
  deepEqual: function (obj1, obj2) {
    return deep_equal__WEBPACK_IMPORTED_MODULE_2___default()(obj1, obj2);
  },
  /**
   * Shallowly compares two JavaScript objects to see if their keys and values are equal.
   * @param obj1
   * @param obj2
   * @returns {boolean}
   * @private
   */
  shallowEqual: function (obj1, obj2) {
    var ret = true;

    // different type
    if (typeof obj1 !== typeof obj2) {
      ret = false;
    }
    // not object
    else if (typeof obj1 !== "object") {
      if (obj1 !== obj2) {
        ret = false;
      }
    }
    // object
    else {
      var keys1 = Object.keys(obj1);
      var keys2 = Object.keys(obj2);
      if (keys1.length !== keys2.length) {
        ret = false;
      } else {
        // comparison from obj1 to obj2
        for (var i = 0, iLen = keys1.length; i < iLen; i++) {
          if (obj1[keys1[i]] !== obj2[keys1[i]]) {
            ret = false;
            break;
          }
        }
        // comparison from obj2 to obj1
        // is not necessary once the lengths have been checked.
      }
    }
    return ret;
  },
  /**
   *  Shows a warning message, typically about some problem with the form
   *  definition.
   * @param msg the message to show
   * @param item (optional) the item in the form to which the message applies.
   */
  showWarning: function (msg, item) {
    if (item) msg = 'The question "' + item.text + '" produced the following warning:  ' + msg;
    console.log(msg);
    // TBD: add a warning visible on the page.
  },
  /**
   * Check if a value is an integer or if it can be correctly converted to a valid float number
   * @param {*} Value a string or numeric value to be tested
   * @returns {boolean}
   */
  isInteger(value) {
    return Number.isInteger(value) ? true : typeof value === "number" ? false : this.intRegex.test(value);
  },
  /**
   * Check if a value is a number or if it can be correctly converted to a valid float number
   * @param {*} value a string or numeric value to be tested
   * @returns {boolean}
   */
  isDecimal(value) {
    return typeof value === "number" ? true : this.decRegex.test(value);
  }
};
/* harmony default export */ __webpack_exports__["default"] = (CommonUtils);

/***/ }),
/* 105 */
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

/* module decorator */ module = __webpack_require__.nmd(module);
//! moment.js
//! version : 2.29.4
//! authors : Tim Wood, Iskren Chernev, Moment.js contributors
//! license : MIT
//! momentjs.com

;
(function (global, factory) {
   true ? module.exports = factory() : 0;
})(this, function () {
  'use strict';

  var hookCallback;
  function hooks() {
    return hookCallback.apply(null, arguments);
  }

  // This is done to register the method called with moment()
  // without creating circular dependencies.
  function setHookCallback(callback) {
    hookCallback = callback;
  }
  function isArray(input) {
    return input instanceof Array || Object.prototype.toString.call(input) === '[object Array]';
  }
  function isObject(input) {
    // IE8 will treat undefined and null as object if it wasn't for
    // input != null
    return input != null && Object.prototype.toString.call(input) === '[object Object]';
  }
  function hasOwnProp(a, b) {
    return Object.prototype.hasOwnProperty.call(a, b);
  }
  function isObjectEmpty(obj) {
    if (Object.getOwnPropertyNames) {
      return Object.getOwnPropertyNames(obj).length === 0;
    } else {
      var k;
      for (k in obj) {
        if (hasOwnProp(obj, k)) {
          return false;
        }
      }
      return true;
    }
  }
  function isUndefined(input) {
    return input === void 0;
  }
  function isNumber(input) {
    return typeof input === 'number' || Object.prototype.toString.call(input) === '[object Number]';
  }
  function isDate(input) {
    return input instanceof Date || Object.prototype.toString.call(input) === '[object Date]';
  }
  function map(arr, fn) {
    var res = [],
      i,
      arrLen = arr.length;
    for (i = 0; i < arrLen; ++i) {
      res.push(fn(arr[i], i));
    }
    return res;
  }
  function extend(a, b) {
    for (var i in b) {
      if (hasOwnProp(b, i)) {
        a[i] = b[i];
      }
    }
    if (hasOwnProp(b, 'toString')) {
      a.toString = b.toString;
    }
    if (hasOwnProp(b, 'valueOf')) {
      a.valueOf = b.valueOf;
    }
    return a;
  }
  function createUTC(input, format, locale, strict) {
    return createLocalOrUTC(input, format, locale, strict, true).utc();
  }
  function defaultParsingFlags() {
    // We need to deep clone this object.
    return {
      empty: false,
      unusedTokens: [],
      unusedInput: [],
      overflow: -2,
      charsLeftOver: 0,
      nullInput: false,
      invalidEra: null,
      invalidMonth: null,
      invalidFormat: false,
      userInvalidated: false,
      iso: false,
      parsedDateParts: [],
      era: null,
      meridiem: null,
      rfc2822: false,
      weekdayMismatch: false
    };
  }
  function getParsingFlags(m) {
    if (m._pf == null) {
      m._pf = defaultParsingFlags();
    }
    return m._pf;
  }
  var some;
  if (Array.prototype.some) {
    some = Array.prototype.some;
  } else {
    some = function (fun) {
      var t = Object(this),
        len = t.length >>> 0,
        i;
      for (i = 0; i < len; i++) {
        if (i in t && fun.call(this, t[i], i, t)) {
          return true;
        }
      }
      return false;
    };
  }
  function isValid(m) {
    if (m._isValid == null) {
      var flags = getParsingFlags(m),
        parsedParts = some.call(flags.parsedDateParts, function (i) {
          return i != null;
        }),
        isNowValid = !isNaN(m._d.getTime()) && flags.overflow < 0 && !flags.empty && !flags.invalidEra && !flags.invalidMonth && !flags.invalidWeekday && !flags.weekdayMismatch && !flags.nullInput && !flags.invalidFormat && !flags.userInvalidated && (!flags.meridiem || flags.meridiem && parsedParts);
      if (m._strict) {
        isNowValid = isNowValid && flags.charsLeftOver === 0 && flags.unusedTokens.length === 0 && flags.bigHour === undefined;
      }
      if (Object.isFrozen == null || !Object.isFrozen(m)) {
        m._isValid = isNowValid;
      } else {
        return isNowValid;
      }
    }
    return m._isValid;
  }
  function createInvalid(flags) {
    var m = createUTC(NaN);
    if (flags != null) {
      extend(getParsingFlags(m), flags);
    } else {
      getParsingFlags(m).userInvalidated = true;
    }
    return m;
  }

  // Plugins that add properties should also add the key here (null value),
  // so we can properly clone ourselves.
  var momentProperties = hooks.momentProperties = [],
    updateInProgress = false;
  function copyConfig(to, from) {
    var i,
      prop,
      val,
      momentPropertiesLen = momentProperties.length;
    if (!isUndefined(from._isAMomentObject)) {
      to._isAMomentObject = from._isAMomentObject;
    }
    if (!isUndefined(from._i)) {
      to._i = from._i;
    }
    if (!isUndefined(from._f)) {
      to._f = from._f;
    }
    if (!isUndefined(from._l)) {
      to._l = from._l;
    }
    if (!isUndefined(from._strict)) {
      to._strict = from._strict;
    }
    if (!isUndefined(from._tzm)) {
      to._tzm = from._tzm;
    }
    if (!isUndefined(from._isUTC)) {
      to._isUTC = from._isUTC;
    }
    if (!isUndefined(from._offset)) {
      to._offset = from._offset;
    }
    if (!isUndefined(from._pf)) {
      to._pf = getParsingFlags(from);
    }
    if (!isUndefined(from._locale)) {
      to._locale = from._locale;
    }
    if (momentPropertiesLen > 0) {
      for (i = 0; i < momentPropertiesLen; i++) {
        prop = momentProperties[i];
        val = from[prop];
        if (!isUndefined(val)) {
          to[prop] = val;
        }
      }
    }
    return to;
  }

  // Moment prototype object
  function Moment(config) {
    copyConfig(this, config);
    this._d = new Date(config._d != null ? config._d.getTime() : NaN);
    if (!this.isValid()) {
      this._d = new Date(NaN);
    }
    // Prevent infinite loop in case updateOffset creates new moment
    // objects.
    if (updateInProgress === false) {
      updateInProgress = true;
      hooks.updateOffset(this);
      updateInProgress = false;
    }
  }
  function isMoment(obj) {
    return obj instanceof Moment || obj != null && obj._isAMomentObject != null;
  }
  function warn(msg) {
    if (hooks.suppressDeprecationWarnings === false && typeof console !== 'undefined' && console.warn) {
      console.warn('Deprecation warning: ' + msg);
    }
  }
  function deprecate(msg, fn) {
    var firstTime = true;
    return extend(function () {
      if (hooks.deprecationHandler != null) {
        hooks.deprecationHandler(null, msg);
      }
      if (firstTime) {
        var args = [],
          arg,
          i,
          key,
          argLen = arguments.length;
        for (i = 0; i < argLen; i++) {
          arg = '';
          if (typeof arguments[i] === 'object') {
            arg += '\n[' + i + '] ';
            for (key in arguments[0]) {
              if (hasOwnProp(arguments[0], key)) {
                arg += key + ': ' + arguments[0][key] + ', ';
              }
            }
            arg = arg.slice(0, -2); // Remove trailing comma and space
          } else {
            arg = arguments[i];
          }
          args.push(arg);
        }
        warn(msg + '\nArguments: ' + Array.prototype.slice.call(args).join('') + '\n' + new Error().stack);
        firstTime = false;
      }
      return fn.apply(this, arguments);
    }, fn);
  }
  var deprecations = {};
  function deprecateSimple(name, msg) {
    if (hooks.deprecationHandler != null) {
      hooks.deprecationHandler(name, msg);
    }
    if (!deprecations[name]) {
      warn(msg);
      deprecations[name] = true;
    }
  }
  hooks.suppressDeprecationWarnings = false;
  hooks.deprecationHandler = null;
  function isFunction(input) {
    return typeof Function !== 'undefined' && input instanceof Function || Object.prototype.toString.call(input) === '[object Function]';
  }
  function set(config) {
    var prop, i;
    for (i in config) {
      if (hasOwnProp(config, i)) {
        prop = config[i];
        if (isFunction(prop)) {
          this[i] = prop;
        } else {
          this['_' + i] = prop;
        }
      }
    }
    this._config = config;
    // Lenient ordinal parsing accepts just a number in addition to
    // number + (possibly) stuff coming from _dayOfMonthOrdinalParse.
    // TODO: Remove "ordinalParse" fallback in next major release.
    this._dayOfMonthOrdinalParseLenient = new RegExp((this._dayOfMonthOrdinalParse.source || this._ordinalParse.source) + '|' + /\d{1,2}/.source);
  }
  function mergeConfigs(parentConfig, childConfig) {
    var res = extend({}, parentConfig),
      prop;
    for (prop in childConfig) {
      if (hasOwnProp(childConfig, prop)) {
        if (isObject(parentConfig[prop]) && isObject(childConfig[prop])) {
          res[prop] = {};
          extend(res[prop], parentConfig[prop]);
          extend(res[prop], childConfig[prop]);
        } else if (childConfig[prop] != null) {
          res[prop] = childConfig[prop];
        } else {
          delete res[prop];
        }
      }
    }
    for (prop in parentConfig) {
      if (hasOwnProp(parentConfig, prop) && !hasOwnProp(childConfig, prop) && isObject(parentConfig[prop])) {
        // make sure changes to properties don't modify parent config
        res[prop] = extend({}, res[prop]);
      }
    }
    return res;
  }
  function Locale(config) {
    if (config != null) {
      this.set(config);
    }
  }
  var keys;
  if (Object.keys) {
    keys = Object.keys;
  } else {
    keys = function (obj) {
      var i,
        res = [];
      for (i in obj) {
        if (hasOwnProp(obj, i)) {
          res.push(i);
        }
      }
      return res;
    };
  }
  var defaultCalendar = {
    sameDay: '[Today at] LT',
    nextDay: '[Tomorrow at] LT',
    nextWeek: 'dddd [at] LT',
    lastDay: '[Yesterday at] LT',
    lastWeek: '[Last] dddd [at] LT',
    sameElse: 'L'
  };
  function calendar(key, mom, now) {
    var output = this._calendar[key] || this._calendar['sameElse'];
    return isFunction(output) ? output.call(mom, now) : output;
  }
  function zeroFill(number, targetLength, forceSign) {
    var absNumber = '' + Math.abs(number),
      zerosToFill = targetLength - absNumber.length,
      sign = number >= 0;
    return (sign ? forceSign ? '+' : '' : '-') + Math.pow(10, Math.max(0, zerosToFill)).toString().substr(1) + absNumber;
  }
  var formattingTokens = /(\[[^\[]*\])|(\\)?([Hh]mm(ss)?|Mo|MM?M?M?|Do|DDDo|DD?D?D?|ddd?d?|do?|w[o|w]?|W[o|W]?|Qo?|N{1,5}|YYYYYY|YYYYY|YYYY|YY|y{2,4}|yo?|gg(ggg?)?|GG(GGG?)?|e|E|a|A|hh?|HH?|kk?|mm?|ss?|S{1,9}|x|X|zz?|ZZ?|.)/g,
    localFormattingTokens = /(\[[^\[]*\])|(\\)?(LTS|LT|LL?L?L?|l{1,4})/g,
    formatFunctions = {},
    formatTokenFunctions = {};

  // token:    'M'
  // padded:   ['MM', 2]
  // ordinal:  'Mo'
  // callback: function () { this.month() + 1 }
  function addFormatToken(token, padded, ordinal, callback) {
    var func = callback;
    if (typeof callback === 'string') {
      func = function () {
        return this[callback]();
      };
    }
    if (token) {
      formatTokenFunctions[token] = func;
    }
    if (padded) {
      formatTokenFunctions[padded[0]] = function () {
        return zeroFill(func.apply(this, arguments), padded[1], padded[2]);
      };
    }
    if (ordinal) {
      formatTokenFunctions[ordinal] = function () {
        return this.localeData().ordinal(func.apply(this, arguments), token);
      };
    }
  }
  function removeFormattingTokens(input) {
    if (input.match(/\[[\s\S]/)) {
      return input.replace(/^\[|\]$/g, '');
    }
    return input.replace(/\\/g, '');
  }
  function makeFormatFunction(format) {
    var array = format.match(formattingTokens),
      i,
      length;
    for (i = 0, length = array.length; i < length; i++) {
      if (formatTokenFunctions[array[i]]) {
        array[i] = formatTokenFunctions[array[i]];
      } else {
        array[i] = removeFormattingTokens(array[i]);
      }
    }
    return function (mom) {
      var output = '',
        i;
      for (i = 0; i < length; i++) {
        output += isFunction(array[i]) ? array[i].call(mom, format) : array[i];
      }
      return output;
    };
  }

  // format date using native date object
  function formatMoment(m, format) {
    if (!m.isValid()) {
      return m.localeData().invalidDate();
    }
    format = expandFormat(format, m.localeData());
    formatFunctions[format] = formatFunctions[format] || makeFormatFunction(format);
    return formatFunctions[format](m);
  }
  function expandFormat(format, locale) {
    var i = 5;
    function replaceLongDateFormatTokens(input) {
      return locale.longDateFormat(input) || input;
    }
    localFormattingTokens.lastIndex = 0;
    while (i >= 0 && localFormattingTokens.test(format)) {
      format = format.replace(localFormattingTokens, replaceLongDateFormatTokens);
      localFormattingTokens.lastIndex = 0;
      i -= 1;
    }
    return format;
  }
  var defaultLongDateFormat = {
    LTS: 'h:mm:ss A',
    LT: 'h:mm A',
    L: 'MM/DD/YYYY',
    LL: 'MMMM D, YYYY',
    LLL: 'MMMM D, YYYY h:mm A',
    LLLL: 'dddd, MMMM D, YYYY h:mm A'
  };
  function longDateFormat(key) {
    var format = this._longDateFormat[key],
      formatUpper = this._longDateFormat[key.toUpperCase()];
    if (format || !formatUpper) {
      return format;
    }
    this._longDateFormat[key] = formatUpper.match(formattingTokens).map(function (tok) {
      if (tok === 'MMMM' || tok === 'MM' || tok === 'DD' || tok === 'dddd') {
        return tok.slice(1);
      }
      return tok;
    }).join('');
    return this._longDateFormat[key];
  }
  var defaultInvalidDate = 'Invalid date';
  function invalidDate() {
    return this._invalidDate;
  }
  var defaultOrdinal = '%d',
    defaultDayOfMonthOrdinalParse = /\d{1,2}/;
  function ordinal(number) {
    return this._ordinal.replace('%d', number);
  }
  var defaultRelativeTime = {
    future: 'in %s',
    past: '%s ago',
    s: 'a few seconds',
    ss: '%d seconds',
    m: 'a minute',
    mm: '%d minutes',
    h: 'an hour',
    hh: '%d hours',
    d: 'a day',
    dd: '%d days',
    w: 'a week',
    ww: '%d weeks',
    M: 'a month',
    MM: '%d months',
    y: 'a year',
    yy: '%d years'
  };
  function relativeTime(number, withoutSuffix, string, isFuture) {
    var output = this._relativeTime[string];
    return isFunction(output) ? output(number, withoutSuffix, string, isFuture) : output.replace(/%d/i, number);
  }
  function pastFuture(diff, output) {
    var format = this._relativeTime[diff > 0 ? 'future' : 'past'];
    return isFunction(format) ? format(output) : format.replace(/%s/i, output);
  }
  var aliases = {};
  function addUnitAlias(unit, shorthand) {
    var lowerCase = unit.toLowerCase();
    aliases[lowerCase] = aliases[lowerCase + 's'] = aliases[shorthand] = unit;
  }
  function normalizeUnits(units) {
    return typeof units === 'string' ? aliases[units] || aliases[units.toLowerCase()] : undefined;
  }
  function normalizeObjectUnits(inputObject) {
    var normalizedInput = {},
      normalizedProp,
      prop;
    for (prop in inputObject) {
      if (hasOwnProp(inputObject, prop)) {
        normalizedProp = normalizeUnits(prop);
        if (normalizedProp) {
          normalizedInput[normalizedProp] = inputObject[prop];
        }
      }
    }
    return normalizedInput;
  }
  var priorities = {};
  function addUnitPriority(unit, priority) {
    priorities[unit] = priority;
  }
  function getPrioritizedUnits(unitsObj) {
    var units = [],
      u;
    for (u in unitsObj) {
      if (hasOwnProp(unitsObj, u)) {
        units.push({
          unit: u,
          priority: priorities[u]
        });
      }
    }
    units.sort(function (a, b) {
      return a.priority - b.priority;
    });
    return units;
  }
  function isLeapYear(year) {
    return year % 4 === 0 && year % 100 !== 0 || year % 400 === 0;
  }
  function absFloor(number) {
    if (number < 0) {
      // -0 -> 0
      return Math.ceil(number) || 0;
    } else {
      return Math.floor(number);
    }
  }
  function toInt(argumentForCoercion) {
    var coercedNumber = +argumentForCoercion,
      value = 0;
    if (coercedNumber !== 0 && isFinite(coercedNumber)) {
      value = absFloor(coercedNumber);
    }
    return value;
  }
  function makeGetSet(unit, keepTime) {
    return function (value) {
      if (value != null) {
        set$1(this, unit, value);
        hooks.updateOffset(this, keepTime);
        return this;
      } else {
        return get(this, unit);
      }
    };
  }
  function get(mom, unit) {
    return mom.isValid() ? mom._d['get' + (mom._isUTC ? 'UTC' : '') + unit]() : NaN;
  }
  function set$1(mom, unit, value) {
    if (mom.isValid() && !isNaN(value)) {
      if (unit === 'FullYear' && isLeapYear(mom.year()) && mom.month() === 1 && mom.date() === 29) {
        value = toInt(value);
        mom._d['set' + (mom._isUTC ? 'UTC' : '') + unit](value, mom.month(), daysInMonth(value, mom.month()));
      } else {
        mom._d['set' + (mom._isUTC ? 'UTC' : '') + unit](value);
      }
    }
  }

  // MOMENTS

  function stringGet(units) {
    units = normalizeUnits(units);
    if (isFunction(this[units])) {
      return this[units]();
    }
    return this;
  }
  function stringSet(units, value) {
    if (typeof units === 'object') {
      units = normalizeObjectUnits(units);
      var prioritized = getPrioritizedUnits(units),
        i,
        prioritizedLen = prioritized.length;
      for (i = 0; i < prioritizedLen; i++) {
        this[prioritized[i].unit](units[prioritized[i].unit]);
      }
    } else {
      units = normalizeUnits(units);
      if (isFunction(this[units])) {
        return this[units](value);
      }
    }
    return this;
  }
  var match1 = /\d/,
    //       0 - 9
    match2 = /\d\d/,
    //      00 - 99
    match3 = /\d{3}/,
    //     000 - 999
    match4 = /\d{4}/,
    //    0000 - 9999
    match6 = /[+-]?\d{6}/,
    // -999999 - 999999
    match1to2 = /\d\d?/,
    //       0 - 99
    match3to4 = /\d\d\d\d?/,
    //     999 - 9999
    match5to6 = /\d\d\d\d\d\d?/,
    //   99999 - 999999
    match1to3 = /\d{1,3}/,
    //       0 - 999
    match1to4 = /\d{1,4}/,
    //       0 - 9999
    match1to6 = /[+-]?\d{1,6}/,
    // -999999 - 999999
    matchUnsigned = /\d+/,
    //       0 - inf
    matchSigned = /[+-]?\d+/,
    //    -inf - inf
    matchOffset = /Z|[+-]\d\d:?\d\d/gi,
    // +00:00 -00:00 +0000 -0000 or Z
    matchShortOffset = /Z|[+-]\d\d(?::?\d\d)?/gi,
    // +00 -00 +00:00 -00:00 +0000 -0000 or Z
    matchTimestamp = /[+-]?\d+(\.\d{1,3})?/,
    // 123456789 123456789.123
    // any word (or two) characters or numbers including two/three word month in arabic.
    // includes scottish gaelic two word and hyphenated months
    matchWord = /[0-9]{0,256}['a-z\u00A0-\u05FF\u0700-\uD7FF\uF900-\uFDCF\uFDF0-\uFF07\uFF10-\uFFEF]{1,256}|[\u0600-\u06FF\/]{1,256}(\s*?[\u0600-\u06FF]{1,256}){1,2}/i,
    regexes;
  regexes = {};
  function addRegexToken(token, regex, strictRegex) {
    regexes[token] = isFunction(regex) ? regex : function (isStrict, localeData) {
      return isStrict && strictRegex ? strictRegex : regex;
    };
  }
  function getParseRegexForToken(token, config) {
    if (!hasOwnProp(regexes, token)) {
      return new RegExp(unescapeFormat(token));
    }
    return regexes[token](config._strict, config._locale);
  }

  // Code from http://stackoverflow.com/questions/3561493/is-there-a-regexp-escape-function-in-javascript
  function unescapeFormat(s) {
    return regexEscape(s.replace('\\', '').replace(/\\(\[)|\\(\])|\[([^\]\[]*)\]|\\(.)/g, function (matched, p1, p2, p3, p4) {
      return p1 || p2 || p3 || p4;
    }));
  }
  function regexEscape(s) {
    return s.replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&');
  }
  var tokens = {};
  function addParseToken(token, callback) {
    var i,
      func = callback,
      tokenLen;
    if (typeof token === 'string') {
      token = [token];
    }
    if (isNumber(callback)) {
      func = function (input, array) {
        array[callback] = toInt(input);
      };
    }
    tokenLen = token.length;
    for (i = 0; i < tokenLen; i++) {
      tokens[token[i]] = func;
    }
  }
  function addWeekParseToken(token, callback) {
    addParseToken(token, function (input, array, config, token) {
      config._w = config._w || {};
      callback(input, config._w, config, token);
    });
  }
  function addTimeToArrayFromToken(token, input, config) {
    if (input != null && hasOwnProp(tokens, token)) {
      tokens[token](input, config._a, config, token);
    }
  }
  var YEAR = 0,
    MONTH = 1,
    DATE = 2,
    HOUR = 3,
    MINUTE = 4,
    SECOND = 5,
    MILLISECOND = 6,
    WEEK = 7,
    WEEKDAY = 8;
  function mod(n, x) {
    return (n % x + x) % x;
  }
  var indexOf;
  if (Array.prototype.indexOf) {
    indexOf = Array.prototype.indexOf;
  } else {
    indexOf = function (o) {
      // I know
      var i;
      for (i = 0; i < this.length; ++i) {
        if (this[i] === o) {
          return i;
        }
      }
      return -1;
    };
  }
  function daysInMonth(year, month) {
    if (isNaN(year) || isNaN(month)) {
      return NaN;
    }
    var modMonth = mod(month, 12);
    year += (month - modMonth) / 12;
    return modMonth === 1 ? isLeapYear(year) ? 29 : 28 : 31 - modMonth % 7 % 2;
  }

  // FORMATTING

  addFormatToken('M', ['MM', 2], 'Mo', function () {
    return this.month() + 1;
  });
  addFormatToken('MMM', 0, 0, function (format) {
    return this.localeData().monthsShort(this, format);
  });
  addFormatToken('MMMM', 0, 0, function (format) {
    return this.localeData().months(this, format);
  });

  // ALIASES

  addUnitAlias('month', 'M');

  // PRIORITY

  addUnitPriority('month', 8);

  // PARSING

  addRegexToken('M', match1to2);
  addRegexToken('MM', match1to2, match2);
  addRegexToken('MMM', function (isStrict, locale) {
    return locale.monthsShortRegex(isStrict);
  });
  addRegexToken('MMMM', function (isStrict, locale) {
    return locale.monthsRegex(isStrict);
  });
  addParseToken(['M', 'MM'], function (input, array) {
    array[MONTH] = toInt(input) - 1;
  });
  addParseToken(['MMM', 'MMMM'], function (input, array, config, token) {
    var month = config._locale.monthsParse(input, token, config._strict);
    // if we didn't find a month name, mark the date as invalid.
    if (month != null) {
      array[MONTH] = month;
    } else {
      getParsingFlags(config).invalidMonth = input;
    }
  });

  // LOCALES

  var defaultLocaleMonths = 'January_February_March_April_May_June_July_August_September_October_November_December'.split('_'),
    defaultLocaleMonthsShort = 'Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec'.split('_'),
    MONTHS_IN_FORMAT = /D[oD]?(\[[^\[\]]*\]|\s)+MMMM?/,
    defaultMonthsShortRegex = matchWord,
    defaultMonthsRegex = matchWord;
  function localeMonths(m, format) {
    if (!m) {
      return isArray(this._months) ? this._months : this._months['standalone'];
    }
    return isArray(this._months) ? this._months[m.month()] : this._months[(this._months.isFormat || MONTHS_IN_FORMAT).test(format) ? 'format' : 'standalone'][m.month()];
  }
  function localeMonthsShort(m, format) {
    if (!m) {
      return isArray(this._monthsShort) ? this._monthsShort : this._monthsShort['standalone'];
    }
    return isArray(this._monthsShort) ? this._monthsShort[m.month()] : this._monthsShort[MONTHS_IN_FORMAT.test(format) ? 'format' : 'standalone'][m.month()];
  }
  function handleStrictParse(monthName, format, strict) {
    var i,
      ii,
      mom,
      llc = monthName.toLocaleLowerCase();
    if (!this._monthsParse) {
      // this is not used
      this._monthsParse = [];
      this._longMonthsParse = [];
      this._shortMonthsParse = [];
      for (i = 0; i < 12; ++i) {
        mom = createUTC([2000, i]);
        this._shortMonthsParse[i] = this.monthsShort(mom, '').toLocaleLowerCase();
        this._longMonthsParse[i] = this.months(mom, '').toLocaleLowerCase();
      }
    }
    if (strict) {
      if (format === 'MMM') {
        ii = indexOf.call(this._shortMonthsParse, llc);
        return ii !== -1 ? ii : null;
      } else {
        ii = indexOf.call(this._longMonthsParse, llc);
        return ii !== -1 ? ii : null;
      }
    } else {
      if (format === 'MMM') {
        ii = indexOf.call(this._shortMonthsParse, llc);
        if (ii !== -1) {
          return ii;
        }
        ii = indexOf.call(this._longMonthsParse, llc);
        return ii !== -1 ? ii : null;
      } else {
        ii = indexOf.call(this._longMonthsParse, llc);
        if (ii !== -1) {
          return ii;
        }
        ii = indexOf.call(this._shortMonthsParse, llc);
        return ii !== -1 ? ii : null;
      }
    }
  }
  function localeMonthsParse(monthName, format, strict) {
    var i, mom, regex;
    if (this._monthsParseExact) {
      return handleStrictParse.call(this, monthName, format, strict);
    }
    if (!this._monthsParse) {
      this._monthsParse = [];
      this._longMonthsParse = [];
      this._shortMonthsParse = [];
    }

    // TODO: add sorting
    // Sorting makes sure if one month (or abbr) is a prefix of another
    // see sorting in computeMonthsParse
    for (i = 0; i < 12; i++) {
      // make the regex if we don't have it already
      mom = createUTC([2000, i]);
      if (strict && !this._longMonthsParse[i]) {
        this._longMonthsParse[i] = new RegExp('^' + this.months(mom, '').replace('.', '') + '$', 'i');
        this._shortMonthsParse[i] = new RegExp('^' + this.monthsShort(mom, '').replace('.', '') + '$', 'i');
      }
      if (!strict && !this._monthsParse[i]) {
        regex = '^' + this.months(mom, '') + '|^' + this.monthsShort(mom, '');
        this._monthsParse[i] = new RegExp(regex.replace('.', ''), 'i');
      }
      // test the regex
      if (strict && format === 'MMMM' && this._longMonthsParse[i].test(monthName)) {
        return i;
      } else if (strict && format === 'MMM' && this._shortMonthsParse[i].test(monthName)) {
        return i;
      } else if (!strict && this._monthsParse[i].test(monthName)) {
        return i;
      }
    }
  }

  // MOMENTS

  function setMonth(mom, value) {
    var dayOfMonth;
    if (!mom.isValid()) {
      // No op
      return mom;
    }
    if (typeof value === 'string') {
      if (/^\d+$/.test(value)) {
        value = toInt(value);
      } else {
        value = mom.localeData().monthsParse(value);
        // TODO: Another silent failure?
        if (!isNumber(value)) {
          return mom;
        }
      }
    }
    dayOfMonth = Math.min(mom.date(), daysInMonth(mom.year(), value));
    mom._d['set' + (mom._isUTC ? 'UTC' : '') + 'Month'](value, dayOfMonth);
    return mom;
  }
  function getSetMonth(value) {
    if (value != null) {
      setMonth(this, value);
      hooks.updateOffset(this, true);
      return this;
    } else {
      return get(this, 'Month');
    }
  }
  function getDaysInMonth() {
    return daysInMonth(this.year(), this.month());
  }
  function monthsShortRegex(isStrict) {
    if (this._monthsParseExact) {
      if (!hasOwnProp(this, '_monthsRegex')) {
        computeMonthsParse.call(this);
      }
      if (isStrict) {
        return this._monthsShortStrictRegex;
      } else {
        return this._monthsShortRegex;
      }
    } else {
      if (!hasOwnProp(this, '_monthsShortRegex')) {
        this._monthsShortRegex = defaultMonthsShortRegex;
      }
      return this._monthsShortStrictRegex && isStrict ? this._monthsShortStrictRegex : this._monthsShortRegex;
    }
  }
  function monthsRegex(isStrict) {
    if (this._monthsParseExact) {
      if (!hasOwnProp(this, '_monthsRegex')) {
        computeMonthsParse.call(this);
      }
      if (isStrict) {
        return this._monthsStrictRegex;
      } else {
        return this._monthsRegex;
      }
    } else {
      if (!hasOwnProp(this, '_monthsRegex')) {
        this._monthsRegex = defaultMonthsRegex;
      }
      return this._monthsStrictRegex && isStrict ? this._monthsStrictRegex : this._monthsRegex;
    }
  }
  function computeMonthsParse() {
    function cmpLenRev(a, b) {
      return b.length - a.length;
    }
    var shortPieces = [],
      longPieces = [],
      mixedPieces = [],
      i,
      mom;
    for (i = 0; i < 12; i++) {
      // make the regex if we don't have it already
      mom = createUTC([2000, i]);
      shortPieces.push(this.monthsShort(mom, ''));
      longPieces.push(this.months(mom, ''));
      mixedPieces.push(this.months(mom, ''));
      mixedPieces.push(this.monthsShort(mom, ''));
    }
    // Sorting makes sure if one month (or abbr) is a prefix of another it
    // will match the longer piece.
    shortPieces.sort(cmpLenRev);
    longPieces.sort(cmpLenRev);
    mixedPieces.sort(cmpLenRev);
    for (i = 0; i < 12; i++) {
      shortPieces[i] = regexEscape(shortPieces[i]);
      longPieces[i] = regexEscape(longPieces[i]);
    }
    for (i = 0; i < 24; i++) {
      mixedPieces[i] = regexEscape(mixedPieces[i]);
    }
    this._monthsRegex = new RegExp('^(' + mixedPieces.join('|') + ')', 'i');
    this._monthsShortRegex = this._monthsRegex;
    this._monthsStrictRegex = new RegExp('^(' + longPieces.join('|') + ')', 'i');
    this._monthsShortStrictRegex = new RegExp('^(' + shortPieces.join('|') + ')', 'i');
  }

  // FORMATTING

  addFormatToken('Y', 0, 0, function () {
    var y = this.year();
    return y <= 9999 ? zeroFill(y, 4) : '+' + y;
  });
  addFormatToken(0, ['YY', 2], 0, function () {
    return this.year() % 100;
  });
  addFormatToken(0, ['YYYY', 4], 0, 'year');
  addFormatToken(0, ['YYYYY', 5], 0, 'year');
  addFormatToken(0, ['YYYYYY', 6, true], 0, 'year');

  // ALIASES

  addUnitAlias('year', 'y');

  // PRIORITIES

  addUnitPriority('year', 1);

  // PARSING

  addRegexToken('Y', matchSigned);
  addRegexToken('YY', match1to2, match2);
  addRegexToken('YYYY', match1to4, match4);
  addRegexToken('YYYYY', match1to6, match6);
  addRegexToken('YYYYYY', match1to6, match6);
  addParseToken(['YYYYY', 'YYYYYY'], YEAR);
  addParseToken('YYYY', function (input, array) {
    array[YEAR] = input.length === 2 ? hooks.parseTwoDigitYear(input) : toInt(input);
  });
  addParseToken('YY', function (input, array) {
    array[YEAR] = hooks.parseTwoDigitYear(input);
  });
  addParseToken('Y', function (input, array) {
    array[YEAR] = parseInt(input, 10);
  });

  // HELPERS

  function daysInYear(year) {
    return isLeapYear(year) ? 366 : 365;
  }

  // HOOKS

  hooks.parseTwoDigitYear = function (input) {
    return toInt(input) + (toInt(input) > 68 ? 1900 : 2000);
  };

  // MOMENTS

  var getSetYear = makeGetSet('FullYear', true);
  function getIsLeapYear() {
    return isLeapYear(this.year());
  }
  function createDate(y, m, d, h, M, s, ms) {
    // can't just apply() to create a date:
    // https://stackoverflow.com/q/181348
    var date;
    // the date constructor remaps years 0-99 to 1900-1999
    if (y < 100 && y >= 0) {
      // preserve leap years using a full 400 year cycle, then reset
      date = new Date(y + 400, m, d, h, M, s, ms);
      if (isFinite(date.getFullYear())) {
        date.setFullYear(y);
      }
    } else {
      date = new Date(y, m, d, h, M, s, ms);
    }
    return date;
  }
  function createUTCDate(y) {
    var date, args;
    // the Date.UTC function remaps years 0-99 to 1900-1999
    if (y < 100 && y >= 0) {
      args = Array.prototype.slice.call(arguments);
      // preserve leap years using a full 400 year cycle, then reset
      args[0] = y + 400;
      date = new Date(Date.UTC.apply(null, args));
      if (isFinite(date.getUTCFullYear())) {
        date.setUTCFullYear(y);
      }
    } else {
      date = new Date(Date.UTC.apply(null, arguments));
    }
    return date;
  }

  // start-of-first-week - start-of-year
  function firstWeekOffset(year, dow, doy) {
    var
      // first-week day -- which january is always in the first week (4 for iso, 1 for other)
      fwd = 7 + dow - doy,
      // first-week day local weekday -- which local weekday is fwd
      fwdlw = (7 + createUTCDate(year, 0, fwd).getUTCDay() - dow) % 7;
    return -fwdlw + fwd - 1;
  }

  // https://en.wikipedia.org/wiki/ISO_week_date#Calculating_a_date_given_the_year.2C_week_number_and_weekday
  function dayOfYearFromWeeks(year, week, weekday, dow, doy) {
    var localWeekday = (7 + weekday - dow) % 7,
      weekOffset = firstWeekOffset(year, dow, doy),
      dayOfYear = 1 + 7 * (week - 1) + localWeekday + weekOffset,
      resYear,
      resDayOfYear;
    if (dayOfYear <= 0) {
      resYear = year - 1;
      resDayOfYear = daysInYear(resYear) + dayOfYear;
    } else if (dayOfYear > daysInYear(year)) {
      resYear = year + 1;
      resDayOfYear = dayOfYear - daysInYear(year);
    } else {
      resYear = year;
      resDayOfYear = dayOfYear;
    }
    return {
      year: resYear,
      dayOfYear: resDayOfYear
    };
  }
  function weekOfYear(mom, dow, doy) {
    var weekOffset = firstWeekOffset(mom.year(), dow, doy),
      week = Math.floor((mom.dayOfYear() - weekOffset - 1) / 7) + 1,
      resWeek,
      resYear;
    if (week < 1) {
      resYear = mom.year() - 1;
      resWeek = week + weeksInYear(resYear, dow, doy);
    } else if (week > weeksInYear(mom.year(), dow, doy)) {
      resWeek = week - weeksInYear(mom.year(), dow, doy);
      resYear = mom.year() + 1;
    } else {
      resYear = mom.year();
      resWeek = week;
    }
    return {
      week: resWeek,
      year: resYear
    };
  }
  function weeksInYear(year, dow, doy) {
    var weekOffset = firstWeekOffset(year, dow, doy),
      weekOffsetNext = firstWeekOffset(year + 1, dow, doy);
    return (daysInYear(year) - weekOffset + weekOffsetNext) / 7;
  }

  // FORMATTING

  addFormatToken('w', ['ww', 2], 'wo', 'week');
  addFormatToken('W', ['WW', 2], 'Wo', 'isoWeek');

  // ALIASES

  addUnitAlias('week', 'w');
  addUnitAlias('isoWeek', 'W');

  // PRIORITIES

  addUnitPriority('week', 5);
  addUnitPriority('isoWeek', 5);

  // PARSING

  addRegexToken('w', match1to2);
  addRegexToken('ww', match1to2, match2);
  addRegexToken('W', match1to2);
  addRegexToken('WW', match1to2, match2);
  addWeekParseToken(['w', 'ww', 'W', 'WW'], function (input, week, config, token) {
    week[token.substr(0, 1)] = toInt(input);
  });

  // HELPERS

  // LOCALES

  function localeWeek(mom) {
    return weekOfYear(mom, this._week.dow, this._week.doy).week;
  }
  var defaultLocaleWeek = {
    dow: 0,
    // Sunday is the first day of the week.
    doy: 6 // The week that contains Jan 6th is the first week of the year.
  };
  function localeFirstDayOfWeek() {
    return this._week.dow;
  }
  function localeFirstDayOfYear() {
    return this._week.doy;
  }

  // MOMENTS

  function getSetWeek(input) {
    var week = this.localeData().week(this);
    return input == null ? week : this.add((input - week) * 7, 'd');
  }
  function getSetISOWeek(input) {
    var week = weekOfYear(this, 1, 4).week;
    return input == null ? week : this.add((input - week) * 7, 'd');
  }

  // FORMATTING

  addFormatToken('d', 0, 'do', 'day');
  addFormatToken('dd', 0, 0, function (format) {
    return this.localeData().weekdaysMin(this, format);
  });
  addFormatToken('ddd', 0, 0, function (format) {
    return this.localeData().weekdaysShort(this, format);
  });
  addFormatToken('dddd', 0, 0, function (format) {
    return this.localeData().weekdays(this, format);
  });
  addFormatToken('e', 0, 0, 'weekday');
  addFormatToken('E', 0, 0, 'isoWeekday');

  // ALIASES

  addUnitAlias('day', 'd');
  addUnitAlias('weekday', 'e');
  addUnitAlias('isoWeekday', 'E');

  // PRIORITY
  addUnitPriority('day', 11);
  addUnitPriority('weekday', 11);
  addUnitPriority('isoWeekday', 11);

  // PARSING

  addRegexToken('d', match1to2);
  addRegexToken('e', match1to2);
  addRegexToken('E', match1to2);
  addRegexToken('dd', function (isStrict, locale) {
    return locale.weekdaysMinRegex(isStrict);
  });
  addRegexToken('ddd', function (isStrict, locale) {
    return locale.weekdaysShortRegex(isStrict);
  });
  addRegexToken('dddd', function (isStrict, locale) {
    return locale.weekdaysRegex(isStrict);
  });
  addWeekParseToken(['dd', 'ddd', 'dddd'], function (input, week, config, token) {
    var weekday = config._locale.weekdaysParse(input, token, config._strict);
    // if we didn't get a weekday name, mark the date as invalid
    if (weekday != null) {
      week.d = weekday;
    } else {
      getParsingFlags(config).invalidWeekday = input;
    }
  });
  addWeekParseToken(['d', 'e', 'E'], function (input, week, config, token) {
    week[token] = toInt(input);
  });

  // HELPERS

  function parseWeekday(input, locale) {
    if (typeof input !== 'string') {
      return input;
    }
    if (!isNaN(input)) {
      return parseInt(input, 10);
    }
    input = locale.weekdaysParse(input);
    if (typeof input === 'number') {
      return input;
    }
    return null;
  }
  function parseIsoWeekday(input, locale) {
    if (typeof input === 'string') {
      return locale.weekdaysParse(input) % 7 || 7;
    }
    return isNaN(input) ? null : input;
  }

  // LOCALES
  function shiftWeekdays(ws, n) {
    return ws.slice(n, 7).concat(ws.slice(0, n));
  }
  var defaultLocaleWeekdays = 'Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday'.split('_'),
    defaultLocaleWeekdaysShort = 'Sun_Mon_Tue_Wed_Thu_Fri_Sat'.split('_'),
    defaultLocaleWeekdaysMin = 'Su_Mo_Tu_We_Th_Fr_Sa'.split('_'),
    defaultWeekdaysRegex = matchWord,
    defaultWeekdaysShortRegex = matchWord,
    defaultWeekdaysMinRegex = matchWord;
  function localeWeekdays(m, format) {
    var weekdays = isArray(this._weekdays) ? this._weekdays : this._weekdays[m && m !== true && this._weekdays.isFormat.test(format) ? 'format' : 'standalone'];
    return m === true ? shiftWeekdays(weekdays, this._week.dow) : m ? weekdays[m.day()] : weekdays;
  }
  function localeWeekdaysShort(m) {
    return m === true ? shiftWeekdays(this._weekdaysShort, this._week.dow) : m ? this._weekdaysShort[m.day()] : this._weekdaysShort;
  }
  function localeWeekdaysMin(m) {
    return m === true ? shiftWeekdays(this._weekdaysMin, this._week.dow) : m ? this._weekdaysMin[m.day()] : this._weekdaysMin;
  }
  function handleStrictParse$1(weekdayName, format, strict) {
    var i,
      ii,
      mom,
      llc = weekdayName.toLocaleLowerCase();
    if (!this._weekdaysParse) {
      this._weekdaysParse = [];
      this._shortWeekdaysParse = [];
      this._minWeekdaysParse = [];
      for (i = 0; i < 7; ++i) {
        mom = createUTC([2000, 1]).day(i);
        this._minWeekdaysParse[i] = this.weekdaysMin(mom, '').toLocaleLowerCase();
        this._shortWeekdaysParse[i] = this.weekdaysShort(mom, '').toLocaleLowerCase();
        this._weekdaysParse[i] = this.weekdays(mom, '').toLocaleLowerCase();
      }
    }
    if (strict) {
      if (format === 'dddd') {
        ii = indexOf.call(this._weekdaysParse, llc);
        return ii !== -1 ? ii : null;
      } else if (format === 'ddd') {
        ii = indexOf.call(this._shortWeekdaysParse, llc);
        return ii !== -1 ? ii : null;
      } else {
        ii = indexOf.call(this._minWeekdaysParse, llc);
        return ii !== -1 ? ii : null;
      }
    } else {
      if (format === 'dddd') {
        ii = indexOf.call(this._weekdaysParse, llc);
        if (ii !== -1) {
          return ii;
        }
        ii = indexOf.call(this._shortWeekdaysParse, llc);
        if (ii !== -1) {
          return ii;
        }
        ii = indexOf.call(this._minWeekdaysParse, llc);
        return ii !== -1 ? ii : null;
      } else if (format === 'ddd') {
        ii = indexOf.call(this._shortWeekdaysParse, llc);
        if (ii !== -1) {
          return ii;
        }
        ii = indexOf.call(this._weekdaysParse, llc);
        if (ii !== -1) {
          return ii;
        }
        ii = indexOf.call(this._minWeekdaysParse, llc);
        return ii !== -1 ? ii : null;
      } else {
        ii = indexOf.call(this._minWeekdaysParse, llc);
        if (ii !== -1) {
          return ii;
        }
        ii = indexOf.call(this._weekdaysParse, llc);
        if (ii !== -1) {
          return ii;
        }
        ii = indexOf.call(this._shortWeekdaysParse, llc);
        return ii !== -1 ? ii : null;
      }
    }
  }
  function localeWeekdaysParse(weekdayName, format, strict) {
    var i, mom, regex;
    if (this._weekdaysParseExact) {
      return handleStrictParse$1.call(this, weekdayName, format, strict);
    }
    if (!this._weekdaysParse) {
      this._weekdaysParse = [];
      this._minWeekdaysParse = [];
      this._shortWeekdaysParse = [];
      this._fullWeekdaysParse = [];
    }
    for (i = 0; i < 7; i++) {
      // make the regex if we don't have it already

      mom = createUTC([2000, 1]).day(i);
      if (strict && !this._fullWeekdaysParse[i]) {
        this._fullWeekdaysParse[i] = new RegExp('^' + this.weekdays(mom, '').replace('.', '\\.?') + '$', 'i');
        this._shortWeekdaysParse[i] = new RegExp('^' + this.weekdaysShort(mom, '').replace('.', '\\.?') + '$', 'i');
        this._minWeekdaysParse[i] = new RegExp('^' + this.weekdaysMin(mom, '').replace('.', '\\.?') + '$', 'i');
      }
      if (!this._weekdaysParse[i]) {
        regex = '^' + this.weekdays(mom, '') + '|^' + this.weekdaysShort(mom, '') + '|^' + this.weekdaysMin(mom, '');
        this._weekdaysParse[i] = new RegExp(regex.replace('.', ''), 'i');
      }
      // test the regex
      if (strict && format === 'dddd' && this._fullWeekdaysParse[i].test(weekdayName)) {
        return i;
      } else if (strict && format === 'ddd' && this._shortWeekdaysParse[i].test(weekdayName)) {
        return i;
      } else if (strict && format === 'dd' && this._minWeekdaysParse[i].test(weekdayName)) {
        return i;
      } else if (!strict && this._weekdaysParse[i].test(weekdayName)) {
        return i;
      }
    }
  }

  // MOMENTS

  function getSetDayOfWeek(input) {
    if (!this.isValid()) {
      return input != null ? this : NaN;
    }
    var day = this._isUTC ? this._d.getUTCDay() : this._d.getDay();
    if (input != null) {
      input = parseWeekday(input, this.localeData());
      return this.add(input - day, 'd');
    } else {
      return day;
    }
  }
  function getSetLocaleDayOfWeek(input) {
    if (!this.isValid()) {
      return input != null ? this : NaN;
    }
    var weekday = (this.day() + 7 - this.localeData()._week.dow) % 7;
    return input == null ? weekday : this.add(input - weekday, 'd');
  }
  function getSetISODayOfWeek(input) {
    if (!this.isValid()) {
      return input != null ? this : NaN;
    }

    // behaves the same as moment#day except
    // as a getter, returns 7 instead of 0 (1-7 range instead of 0-6)
    // as a setter, sunday should belong to the previous week.

    if (input != null) {
      var weekday = parseIsoWeekday(input, this.localeData());
      return this.day(this.day() % 7 ? weekday : weekday - 7);
    } else {
      return this.day() || 7;
    }
  }
  function weekdaysRegex(isStrict) {
    if (this._weekdaysParseExact) {
      if (!hasOwnProp(this, '_weekdaysRegex')) {
        computeWeekdaysParse.call(this);
      }
      if (isStrict) {
        return this._weekdaysStrictRegex;
      } else {
        return this._weekdaysRegex;
      }
    } else {
      if (!hasOwnProp(this, '_weekdaysRegex')) {
        this._weekdaysRegex = defaultWeekdaysRegex;
      }
      return this._weekdaysStrictRegex && isStrict ? this._weekdaysStrictRegex : this._weekdaysRegex;
    }
  }
  function weekdaysShortRegex(isStrict) {
    if (this._weekdaysParseExact) {
      if (!hasOwnProp(this, '_weekdaysRegex')) {
        computeWeekdaysParse.call(this);
      }
      if (isStrict) {
        return this._weekdaysShortStrictRegex;
      } else {
        return this._weekdaysShortRegex;
      }
    } else {
      if (!hasOwnProp(this, '_weekdaysShortRegex')) {
        this._weekdaysShortRegex = defaultWeekdaysShortRegex;
      }
      return this._weekdaysShortStrictRegex && isStrict ? this._weekdaysShortStrictRegex : this._weekdaysShortRegex;
    }
  }
  function weekdaysMinRegex(isStrict) {
    if (this._weekdaysParseExact) {
      if (!hasOwnProp(this, '_weekdaysRegex')) {
        computeWeekdaysParse.call(this);
      }
      if (isStrict) {
        return this._weekdaysMinStrictRegex;
      } else {
        return this._weekdaysMinRegex;
      }
    } else {
      if (!hasOwnProp(this, '_weekdaysMinRegex')) {
        this._weekdaysMinRegex = defaultWeekdaysMinRegex;
      }
      return this._weekdaysMinStrictRegex && isStrict ? this._weekdaysMinStrictRegex : this._weekdaysMinRegex;
    }
  }
  function computeWeekdaysParse() {
    function cmpLenRev(a, b) {
      return b.length - a.length;
    }
    var minPieces = [],
      shortPieces = [],
      longPieces = [],
      mixedPieces = [],
      i,
      mom,
      minp,
      shortp,
      longp;
    for (i = 0; i < 7; i++) {
      // make the regex if we don't have it already
      mom = createUTC([2000, 1]).day(i);
      minp = regexEscape(this.weekdaysMin(mom, ''));
      shortp = regexEscape(this.weekdaysShort(mom, ''));
      longp = regexEscape(this.weekdays(mom, ''));
      minPieces.push(minp);
      shortPieces.push(shortp);
      longPieces.push(longp);
      mixedPieces.push(minp);
      mixedPieces.push(shortp);
      mixedPieces.push(longp);
    }
    // Sorting makes sure if one weekday (or abbr) is a prefix of another it
    // will match the longer piece.
    minPieces.sort(cmpLenRev);
    shortPieces.sort(cmpLenRev);
    longPieces.sort(cmpLenRev);
    mixedPieces.sort(cmpLenRev);
    this._weekdaysRegex = new RegExp('^(' + mixedPieces.join('|') + ')', 'i');
    this._weekdaysShortRegex = this._weekdaysRegex;
    this._weekdaysMinRegex = this._weekdaysRegex;
    this._weekdaysStrictRegex = new RegExp('^(' + longPieces.join('|') + ')', 'i');
    this._weekdaysShortStrictRegex = new RegExp('^(' + shortPieces.join('|') + ')', 'i');
    this._weekdaysMinStrictRegex = new RegExp('^(' + minPieces.join('|') + ')', 'i');
  }

  // FORMATTING

  function hFormat() {
    return this.hours() % 12 || 12;
  }
  function kFormat() {
    return this.hours() || 24;
  }
  addFormatToken('H', ['HH', 2], 0, 'hour');
  addFormatToken('h', ['hh', 2], 0, hFormat);
  addFormatToken('k', ['kk', 2], 0, kFormat);
  addFormatToken('hmm', 0, 0, function () {
    return '' + hFormat.apply(this) + zeroFill(this.minutes(), 2);
  });
  addFormatToken('hmmss', 0, 0, function () {
    return '' + hFormat.apply(this) + zeroFill(this.minutes(), 2) + zeroFill(this.seconds(), 2);
  });
  addFormatToken('Hmm', 0, 0, function () {
    return '' + this.hours() + zeroFill(this.minutes(), 2);
  });
  addFormatToken('Hmmss', 0, 0, function () {
    return '' + this.hours() + zeroFill(this.minutes(), 2) + zeroFill(this.seconds(), 2);
  });
  function meridiem(token, lowercase) {
    addFormatToken(token, 0, 0, function () {
      return this.localeData().meridiem(this.hours(), this.minutes(), lowercase);
    });
  }
  meridiem('a', true);
  meridiem('A', false);

  // ALIASES

  addUnitAlias('hour', 'h');

  // PRIORITY
  addUnitPriority('hour', 13);

  // PARSING

  function matchMeridiem(isStrict, locale) {
    return locale._meridiemParse;
  }
  addRegexToken('a', matchMeridiem);
  addRegexToken('A', matchMeridiem);
  addRegexToken('H', match1to2);
  addRegexToken('h', match1to2);
  addRegexToken('k', match1to2);
  addRegexToken('HH', match1to2, match2);
  addRegexToken('hh', match1to2, match2);
  addRegexToken('kk', match1to2, match2);
  addRegexToken('hmm', match3to4);
  addRegexToken('hmmss', match5to6);
  addRegexToken('Hmm', match3to4);
  addRegexToken('Hmmss', match5to6);
  addParseToken(['H', 'HH'], HOUR);
  addParseToken(['k', 'kk'], function (input, array, config) {
    var kInput = toInt(input);
    array[HOUR] = kInput === 24 ? 0 : kInput;
  });
  addParseToken(['a', 'A'], function (input, array, config) {
    config._isPm = config._locale.isPM(input);
    config._meridiem = input;
  });
  addParseToken(['h', 'hh'], function (input, array, config) {
    array[HOUR] = toInt(input);
    getParsingFlags(config).bigHour = true;
  });
  addParseToken('hmm', function (input, array, config) {
    var pos = input.length - 2;
    array[HOUR] = toInt(input.substr(0, pos));
    array[MINUTE] = toInt(input.substr(pos));
    getParsingFlags(config).bigHour = true;
  });
  addParseToken('hmmss', function (input, array, config) {
    var pos1 = input.length - 4,
      pos2 = input.length - 2;
    array[HOUR] = toInt(input.substr(0, pos1));
    array[MINUTE] = toInt(input.substr(pos1, 2));
    array[SECOND] = toInt(input.substr(pos2));
    getParsingFlags(config).bigHour = true;
  });
  addParseToken('Hmm', function (input, array, config) {
    var pos = input.length - 2;
    array[HOUR] = toInt(input.substr(0, pos));
    array[MINUTE] = toInt(input.substr(pos));
  });
  addParseToken('Hmmss', function (input, array, config) {
    var pos1 = input.length - 4,
      pos2 = input.length - 2;
    array[HOUR] = toInt(input.substr(0, pos1));
    array[MINUTE] = toInt(input.substr(pos1, 2));
    array[SECOND] = toInt(input.substr(pos2));
  });

  // LOCALES

  function localeIsPM(input) {
    // IE8 Quirks Mode & IE7 Standards Mode do not allow accessing strings like arrays
    // Using charAt should be more compatible.
    return (input + '').toLowerCase().charAt(0) === 'p';
  }
  var defaultLocaleMeridiemParse = /[ap]\.?m?\.?/i,
    // Setting the hour should keep the time, because the user explicitly
    // specified which hour they want. So trying to maintain the same hour (in
    // a new timezone) makes sense. Adding/subtracting hours does not follow
    // this rule.
    getSetHour = makeGetSet('Hours', true);
  function localeMeridiem(hours, minutes, isLower) {
    if (hours > 11) {
      return isLower ? 'pm' : 'PM';
    } else {
      return isLower ? 'am' : 'AM';
    }
  }
  var baseConfig = {
    calendar: defaultCalendar,
    longDateFormat: defaultLongDateFormat,
    invalidDate: defaultInvalidDate,
    ordinal: defaultOrdinal,
    dayOfMonthOrdinalParse: defaultDayOfMonthOrdinalParse,
    relativeTime: defaultRelativeTime,
    months: defaultLocaleMonths,
    monthsShort: defaultLocaleMonthsShort,
    week: defaultLocaleWeek,
    weekdays: defaultLocaleWeekdays,
    weekdaysMin: defaultLocaleWeekdaysMin,
    weekdaysShort: defaultLocaleWeekdaysShort,
    meridiemParse: defaultLocaleMeridiemParse
  };

  // internal storage for locale config files
  var locales = {},
    localeFamilies = {},
    globalLocale;
  function commonPrefix(arr1, arr2) {
    var i,
      minl = Math.min(arr1.length, arr2.length);
    for (i = 0; i < minl; i += 1) {
      if (arr1[i] !== arr2[i]) {
        return i;
      }
    }
    return minl;
  }
  function normalizeLocale(key) {
    return key ? key.toLowerCase().replace('_', '-') : key;
  }

  // pick the locale from the array
  // try ['en-au', 'en-gb'] as 'en-au', 'en-gb', 'en', as in move through the list trying each
  // substring from most specific to least, but move to the next array item if it's a more specific variant than the current root
  function chooseLocale(names) {
    var i = 0,
      j,
      next,
      locale,
      split;
    while (i < names.length) {
      split = normalizeLocale(names[i]).split('-');
      j = split.length;
      next = normalizeLocale(names[i + 1]);
      next = next ? next.split('-') : null;
      while (j > 0) {
        locale = loadLocale(split.slice(0, j).join('-'));
        if (locale) {
          return locale;
        }
        if (next && next.length >= j && commonPrefix(split, next) >= j - 1) {
          //the next array item is better than a shallower substring of this one
          break;
        }
        j--;
      }
      i++;
    }
    return globalLocale;
  }
  function isLocaleNameSane(name) {
    // Prevent names that look like filesystem paths, i.e contain '/' or '\'
    return name.match('^[^/\\\\]*$') != null;
  }
  function loadLocale(name) {
    var oldLocale = null,
      aliasedRequire;
    // TODO: Find a better way to register and load all the locales in Node
    if (locales[name] === undefined && "object" !== 'undefined' && module && module.exports && isLocaleNameSane(name)) {
      try {
        oldLocale = globalLocale._abbr;
        aliasedRequire = undefined;
        __webpack_require__(106)("./" + name);
        getSetGlobalLocale(oldLocale);
      } catch (e) {
        // mark as not found to avoid repeating expensive file require call causing high CPU
        // when trying to find en-US, en_US, en-us for every format call
        locales[name] = null; // null means not found
      }
    }
    return locales[name];
  }

  // This function will load locale and then set the global locale.  If
  // no arguments are passed in, it will simply return the current global
  // locale key.
  function getSetGlobalLocale(key, values) {
    var data;
    if (key) {
      if (isUndefined(values)) {
        data = getLocale(key);
      } else {
        data = defineLocale(key, values);
      }
      if (data) {
        // moment.duration._locale = moment._locale = data;
        globalLocale = data;
      } else {
        if (typeof console !== 'undefined' && console.warn) {
          //warn user if arguments are passed but the locale could not be set
          console.warn('Locale ' + key + ' not found. Did you forget to load it?');
        }
      }
    }
    return globalLocale._abbr;
  }
  function defineLocale(name, config) {
    if (config !== null) {
      var locale,
        parentConfig = baseConfig;
      config.abbr = name;
      if (locales[name] != null) {
        deprecateSimple('defineLocaleOverride', 'use moment.updateLocale(localeName, config) to change ' + 'an existing locale. moment.defineLocale(localeName, ' + 'config) should only be used for creating a new locale ' + 'See http://momentjs.com/guides/#/warnings/define-locale/ for more info.');
        parentConfig = locales[name]._config;
      } else if (config.parentLocale != null) {
        if (locales[config.parentLocale] != null) {
          parentConfig = locales[config.parentLocale]._config;
        } else {
          locale = loadLocale(config.parentLocale);
          if (locale != null) {
            parentConfig = locale._config;
          } else {
            if (!localeFamilies[config.parentLocale]) {
              localeFamilies[config.parentLocale] = [];
            }
            localeFamilies[config.parentLocale].push({
              name: name,
              config: config
            });
            return null;
          }
        }
      }
      locales[name] = new Locale(mergeConfigs(parentConfig, config));
      if (localeFamilies[name]) {
        localeFamilies[name].forEach(function (x) {
          defineLocale(x.name, x.config);
        });
      }

      // backwards compat for now: also set the locale
      // make sure we set the locale AFTER all child locales have been
      // created, so we won't end up with the child locale set.
      getSetGlobalLocale(name);
      return locales[name];
    } else {
      // useful for testing
      delete locales[name];
      return null;
    }
  }
  function updateLocale(name, config) {
    if (config != null) {
      var locale,
        tmpLocale,
        parentConfig = baseConfig;
      if (locales[name] != null && locales[name].parentLocale != null) {
        // Update existing child locale in-place to avoid memory-leaks
        locales[name].set(mergeConfigs(locales[name]._config, config));
      } else {
        // MERGE
        tmpLocale = loadLocale(name);
        if (tmpLocale != null) {
          parentConfig = tmpLocale._config;
        }
        config = mergeConfigs(parentConfig, config);
        if (tmpLocale == null) {
          // updateLocale is called for creating a new locale
          // Set abbr so it will have a name (getters return
          // undefined otherwise).
          config.abbr = name;
        }
        locale = new Locale(config);
        locale.parentLocale = locales[name];
        locales[name] = locale;
      }

      // backwards compat for now: also set the locale
      getSetGlobalLocale(name);
    } else {
      // pass null for config to unupdate, useful for tests
      if (locales[name] != null) {
        if (locales[name].parentLocale != null) {
          locales[name] = locales[name].parentLocale;
          if (name === getSetGlobalLocale()) {
            getSetGlobalLocale(name);
          }
        } else if (locales[name] != null) {
          delete locales[name];
        }
      }
    }
    return locales[name];
  }

  // returns locale data
  function getLocale(key) {
    var locale;
    if (key && key._locale && key._locale._abbr) {
      key = key._locale._abbr;
    }
    if (!key) {
      return globalLocale;
    }
    if (!isArray(key)) {
      //short-circuit everything else
      locale = loadLocale(key);
      if (locale) {
        return locale;
      }
      key = [key];
    }
    return chooseLocale(key);
  }
  function listLocales() {
    return keys(locales);
  }
  function checkOverflow(m) {
    var overflow,
      a = m._a;
    if (a && getParsingFlags(m).overflow === -2) {
      overflow = a[MONTH] < 0 || a[MONTH] > 11 ? MONTH : a[DATE] < 1 || a[DATE] > daysInMonth(a[YEAR], a[MONTH]) ? DATE : a[HOUR] < 0 || a[HOUR] > 24 || a[HOUR] === 24 && (a[MINUTE] !== 0 || a[SECOND] !== 0 || a[MILLISECOND] !== 0) ? HOUR : a[MINUTE] < 0 || a[MINUTE] > 59 ? MINUTE : a[SECOND] < 0 || a[SECOND] > 59 ? SECOND : a[MILLISECOND] < 0 || a[MILLISECOND] > 999 ? MILLISECOND : -1;
      if (getParsingFlags(m)._overflowDayOfYear && (overflow < YEAR || overflow > DATE)) {
        overflow = DATE;
      }
      if (getParsingFlags(m)._overflowWeeks && overflow === -1) {
        overflow = WEEK;
      }
      if (getParsingFlags(m)._overflowWeekday && overflow === -1) {
        overflow = WEEKDAY;
      }
      getParsingFlags(m).overflow = overflow;
    }
    return m;
  }

  // iso 8601 regex
  // 0000-00-00 0000-W00 or 0000-W00-0 + T + 00 or 00:00 or 00:00:00 or 00:00:00.000 + +00:00 or +0000 or +00)
  var extendedIsoRegex = /^\s*((?:[+-]\d{6}|\d{4})-(?:\d\d-\d\d|W\d\d-\d|W\d\d|\d\d\d|\d\d))(?:(T| )(\d\d(?::\d\d(?::\d\d(?:[.,]\d+)?)?)?)([+-]\d\d(?::?\d\d)?|\s*Z)?)?$/,
    basicIsoRegex = /^\s*((?:[+-]\d{6}|\d{4})(?:\d\d\d\d|W\d\d\d|W\d\d|\d\d\d|\d\d|))(?:(T| )(\d\d(?:\d\d(?:\d\d(?:[.,]\d+)?)?)?)([+-]\d\d(?::?\d\d)?|\s*Z)?)?$/,
    tzRegex = /Z|[+-]\d\d(?::?\d\d)?/,
    isoDates = [['YYYYYY-MM-DD', /[+-]\d{6}-\d\d-\d\d/], ['YYYY-MM-DD', /\d{4}-\d\d-\d\d/], ['GGGG-[W]WW-E', /\d{4}-W\d\d-\d/], ['GGGG-[W]WW', /\d{4}-W\d\d/, false], ['YYYY-DDD', /\d{4}-\d{3}/], ['YYYY-MM', /\d{4}-\d\d/, false], ['YYYYYYMMDD', /[+-]\d{10}/], ['YYYYMMDD', /\d{8}/], ['GGGG[W]WWE', /\d{4}W\d{3}/], ['GGGG[W]WW', /\d{4}W\d{2}/, false], ['YYYYDDD', /\d{7}/], ['YYYYMM', /\d{6}/, false], ['YYYY', /\d{4}/, false]],
    // iso time formats and regexes
    isoTimes = [['HH:mm:ss.SSSS', /\d\d:\d\d:\d\d\.\d+/], ['HH:mm:ss,SSSS', /\d\d:\d\d:\d\d,\d+/], ['HH:mm:ss', /\d\d:\d\d:\d\d/], ['HH:mm', /\d\d:\d\d/], ['HHmmss.SSSS', /\d\d\d\d\d\d\.\d+/], ['HHmmss,SSSS', /\d\d\d\d\d\d,\d+/], ['HHmmss', /\d\d\d\d\d\d/], ['HHmm', /\d\d\d\d/], ['HH', /\d\d/]],
    aspNetJsonRegex = /^\/?Date\((-?\d+)/i,
    // RFC 2822 regex: For details see https://tools.ietf.org/html/rfc2822#section-3.3
    rfc2822 = /^(?:(Mon|Tue|Wed|Thu|Fri|Sat|Sun),?\s)?(\d{1,2})\s(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\s(\d{2,4})\s(\d\d):(\d\d)(?::(\d\d))?\s(?:(UT|GMT|[ECMP][SD]T)|([Zz])|([+-]\d{4}))$/,
    obsOffsets = {
      UT: 0,
      GMT: 0,
      EDT: -4 * 60,
      EST: -5 * 60,
      CDT: -5 * 60,
      CST: -6 * 60,
      MDT: -6 * 60,
      MST: -7 * 60,
      PDT: -7 * 60,
      PST: -8 * 60
    };

  // date from iso format
  function configFromISO(config) {
    var i,
      l,
      string = config._i,
      match = extendedIsoRegex.exec(string) || basicIsoRegex.exec(string),
      allowTime,
      dateFormat,
      timeFormat,
      tzFormat,
      isoDatesLen = isoDates.length,
      isoTimesLen = isoTimes.length;
    if (match) {
      getParsingFlags(config).iso = true;
      for (i = 0, l = isoDatesLen; i < l; i++) {
        if (isoDates[i][1].exec(match[1])) {
          dateFormat = isoDates[i][0];
          allowTime = isoDates[i][2] !== false;
          break;
        }
      }
      if (dateFormat == null) {
        config._isValid = false;
        return;
      }
      if (match[3]) {
        for (i = 0, l = isoTimesLen; i < l; i++) {
          if (isoTimes[i][1].exec(match[3])) {
            // match[2] should be 'T' or space
            timeFormat = (match[2] || ' ') + isoTimes[i][0];
            break;
          }
        }
        if (timeFormat == null) {
          config._isValid = false;
          return;
        }
      }
      if (!allowTime && timeFormat != null) {
        config._isValid = false;
        return;
      }
      if (match[4]) {
        if (tzRegex.exec(match[4])) {
          tzFormat = 'Z';
        } else {
          config._isValid = false;
          return;
        }
      }
      config._f = dateFormat + (timeFormat || '') + (tzFormat || '');
      configFromStringAndFormat(config);
    } else {
      config._isValid = false;
    }
  }
  function extractFromRFC2822Strings(yearStr, monthStr, dayStr, hourStr, minuteStr, secondStr) {
    var result = [untruncateYear(yearStr), defaultLocaleMonthsShort.indexOf(monthStr), parseInt(dayStr, 10), parseInt(hourStr, 10), parseInt(minuteStr, 10)];
    if (secondStr) {
      result.push(parseInt(secondStr, 10));
    }
    return result;
  }
  function untruncateYear(yearStr) {
    var year = parseInt(yearStr, 10);
    if (year <= 49) {
      return 2000 + year;
    } else if (year <= 999) {
      return 1900 + year;
    }
    return year;
  }
  function preprocessRFC2822(s) {
    // Remove comments and folding whitespace and replace multiple-spaces with a single space
    return s.replace(/\([^()]*\)|[\n\t]/g, ' ').replace(/(\s\s+)/g, ' ').replace(/^\s\s*/, '').replace(/\s\s*$/, '');
  }
  function checkWeekday(weekdayStr, parsedInput, config) {
    if (weekdayStr) {
      // TODO: Replace the vanilla JS Date object with an independent day-of-week check.
      var weekdayProvided = defaultLocaleWeekdaysShort.indexOf(weekdayStr),
        weekdayActual = new Date(parsedInput[0], parsedInput[1], parsedInput[2]).getDay();
      if (weekdayProvided !== weekdayActual) {
        getParsingFlags(config).weekdayMismatch = true;
        config._isValid = false;
        return false;
      }
    }
    return true;
  }
  function calculateOffset(obsOffset, militaryOffset, numOffset) {
    if (obsOffset) {
      return obsOffsets[obsOffset];
    } else if (militaryOffset) {
      // the only allowed military tz is Z
      return 0;
    } else {
      var hm = parseInt(numOffset, 10),
        m = hm % 100,
        h = (hm - m) / 100;
      return h * 60 + m;
    }
  }

  // date and time from ref 2822 format
  function configFromRFC2822(config) {
    var match = rfc2822.exec(preprocessRFC2822(config._i)),
      parsedArray;
    if (match) {
      parsedArray = extractFromRFC2822Strings(match[4], match[3], match[2], match[5], match[6], match[7]);
      if (!checkWeekday(match[1], parsedArray, config)) {
        return;
      }
      config._a = parsedArray;
      config._tzm = calculateOffset(match[8], match[9], match[10]);
      config._d = createUTCDate.apply(null, config._a);
      config._d.setUTCMinutes(config._d.getUTCMinutes() - config._tzm);
      getParsingFlags(config).rfc2822 = true;
    } else {
      config._isValid = false;
    }
  }

  // date from 1) ASP.NET, 2) ISO, 3) RFC 2822 formats, or 4) optional fallback if parsing isn't strict
  function configFromString(config) {
    var matched = aspNetJsonRegex.exec(config._i);
    if (matched !== null) {
      config._d = new Date(+matched[1]);
      return;
    }
    configFromISO(config);
    if (config._isValid === false) {
      delete config._isValid;
    } else {
      return;
    }
    configFromRFC2822(config);
    if (config._isValid === false) {
      delete config._isValid;
    } else {
      return;
    }
    if (config._strict) {
      config._isValid = false;
    } else {
      // Final attempt, use Input Fallback
      hooks.createFromInputFallback(config);
    }
  }
  hooks.createFromInputFallback = deprecate('value provided is not in a recognized RFC2822 or ISO format. moment construction falls back to js Date(), ' + 'which is not reliable across all browsers and versions. Non RFC2822/ISO date formats are ' + 'discouraged. Please refer to http://momentjs.com/guides/#/warnings/js-date/ for more info.', function (config) {
    config._d = new Date(config._i + (config._useUTC ? ' UTC' : ''));
  });

  // Pick the first defined of two or three arguments.
  function defaults(a, b, c) {
    if (a != null) {
      return a;
    }
    if (b != null) {
      return b;
    }
    return c;
  }
  function currentDateArray(config) {
    // hooks is actually the exported moment object
    var nowValue = new Date(hooks.now());
    if (config._useUTC) {
      return [nowValue.getUTCFullYear(), nowValue.getUTCMonth(), nowValue.getUTCDate()];
    }
    return [nowValue.getFullYear(), nowValue.getMonth(), nowValue.getDate()];
  }

  // convert an array to a date.
  // the array should mirror the parameters below
  // note: all values past the year are optional and will default to the lowest possible value.
  // [year, month, day , hour, minute, second, millisecond]
  function configFromArray(config) {
    var i,
      date,
      input = [],
      currentDate,
      expectedWeekday,
      yearToUse;
    if (config._d) {
      return;
    }
    currentDate = currentDateArray(config);

    //compute day of the year from weeks and weekdays
    if (config._w && config._a[DATE] == null && config._a[MONTH] == null) {
      dayOfYearFromWeekInfo(config);
    }

    //if the day of the year is set, figure out what it is
    if (config._dayOfYear != null) {
      yearToUse = defaults(config._a[YEAR], currentDate[YEAR]);
      if (config._dayOfYear > daysInYear(yearToUse) || config._dayOfYear === 0) {
        getParsingFlags(config)._overflowDayOfYear = true;
      }
      date = createUTCDate(yearToUse, 0, config._dayOfYear);
      config._a[MONTH] = date.getUTCMonth();
      config._a[DATE] = date.getUTCDate();
    }

    // Default to current date.
    // * if no year, month, day of month are given, default to today
    // * if day of month is given, default month and year
    // * if month is given, default only year
    // * if year is given, don't default anything
    for (i = 0; i < 3 && config._a[i] == null; ++i) {
      config._a[i] = input[i] = currentDate[i];
    }

    // Zero out whatever was not defaulted, including time
    for (; i < 7; i++) {
      config._a[i] = input[i] = config._a[i] == null ? i === 2 ? 1 : 0 : config._a[i];
    }

    // Check for 24:00:00.000
    if (config._a[HOUR] === 24 && config._a[MINUTE] === 0 && config._a[SECOND] === 0 && config._a[MILLISECOND] === 0) {
      config._nextDay = true;
      config._a[HOUR] = 0;
    }
    config._d = (config._useUTC ? createUTCDate : createDate).apply(null, input);
    expectedWeekday = config._useUTC ? config._d.getUTCDay() : config._d.getDay();

    // Apply timezone offset from input. The actual utcOffset can be changed
    // with parseZone.
    if (config._tzm != null) {
      config._d.setUTCMinutes(config._d.getUTCMinutes() - config._tzm);
    }
    if (config._nextDay) {
      config._a[HOUR] = 24;
    }

    // check for mismatching day of week
    if (config._w && typeof config._w.d !== 'undefined' && config._w.d !== expectedWeekday) {
      getParsingFlags(config).weekdayMismatch = true;
    }
  }
  function dayOfYearFromWeekInfo(config) {
    var w, weekYear, week, weekday, dow, doy, temp, weekdayOverflow, curWeek;
    w = config._w;
    if (w.GG != null || w.W != null || w.E != null) {
      dow = 1;
      doy = 4;

      // TODO: We need to take the current isoWeekYear, but that depends on
      // how we interpret now (local, utc, fixed offset). So create
      // a now version of current config (take local/utc/offset flags, and
      // create now).
      weekYear = defaults(w.GG, config._a[YEAR], weekOfYear(createLocal(), 1, 4).year);
      week = defaults(w.W, 1);
      weekday = defaults(w.E, 1);
      if (weekday < 1 || weekday > 7) {
        weekdayOverflow = true;
      }
    } else {
      dow = config._locale._week.dow;
      doy = config._locale._week.doy;
      curWeek = weekOfYear(createLocal(), dow, doy);
      weekYear = defaults(w.gg, config._a[YEAR], curWeek.year);

      // Default to current week.
      week = defaults(w.w, curWeek.week);
      if (w.d != null) {
        // weekday -- low day numbers are considered next week
        weekday = w.d;
        if (weekday < 0 || weekday > 6) {
          weekdayOverflow = true;
        }
      } else if (w.e != null) {
        // local weekday -- counting starts from beginning of week
        weekday = w.e + dow;
        if (w.e < 0 || w.e > 6) {
          weekdayOverflow = true;
        }
      } else {
        // default to beginning of week
        weekday = dow;
      }
    }
    if (week < 1 || week > weeksInYear(weekYear, dow, doy)) {
      getParsingFlags(config)._overflowWeeks = true;
    } else if (weekdayOverflow != null) {
      getParsingFlags(config)._overflowWeekday = true;
    } else {
      temp = dayOfYearFromWeeks(weekYear, week, weekday, dow, doy);
      config._a[YEAR] = temp.year;
      config._dayOfYear = temp.dayOfYear;
    }
  }

  // constant that refers to the ISO standard
  hooks.ISO_8601 = function () {};

  // constant that refers to the RFC 2822 form
  hooks.RFC_2822 = function () {};

  // date from string and format string
  function configFromStringAndFormat(config) {
    // TODO: Move this to another part of the creation flow to prevent circular deps
    if (config._f === hooks.ISO_8601) {
      configFromISO(config);
      return;
    }
    if (config._f === hooks.RFC_2822) {
      configFromRFC2822(config);
      return;
    }
    config._a = [];
    getParsingFlags(config).empty = true;

    // This array is used to make a Date, either with `new Date` or `Date.UTC`
    var string = '' + config._i,
      i,
      parsedInput,
      tokens,
      token,
      skipped,
      stringLength = string.length,
      totalParsedInputLength = 0,
      era,
      tokenLen;
    tokens = expandFormat(config._f, config._locale).match(formattingTokens) || [];
    tokenLen = tokens.length;
    for (i = 0; i < tokenLen; i++) {
      token = tokens[i];
      parsedInput = (string.match(getParseRegexForToken(token, config)) || [])[0];
      if (parsedInput) {
        skipped = string.substr(0, string.indexOf(parsedInput));
        if (skipped.length > 0) {
          getParsingFlags(config).unusedInput.push(skipped);
        }
        string = string.slice(string.indexOf(parsedInput) + parsedInput.length);
        totalParsedInputLength += parsedInput.length;
      }
      // don't parse if it's not a known token
      if (formatTokenFunctions[token]) {
        if (parsedInput) {
          getParsingFlags(config).empty = false;
        } else {
          getParsingFlags(config).unusedTokens.push(token);
        }
        addTimeToArrayFromToken(token, parsedInput, config);
      } else if (config._strict && !parsedInput) {
        getParsingFlags(config).unusedTokens.push(token);
      }
    }

    // add remaining unparsed input length to the string
    getParsingFlags(config).charsLeftOver = stringLength - totalParsedInputLength;
    if (string.length > 0) {
      getParsingFlags(config).unusedInput.push(string);
    }

    // clear _12h flag if hour is <= 12
    if (config._a[HOUR] <= 12 && getParsingFlags(config).bigHour === true && config._a[HOUR] > 0) {
      getParsingFlags(config).bigHour = undefined;
    }
    getParsingFlags(config).parsedDateParts = config._a.slice(0);
    getParsingFlags(config).meridiem = config._meridiem;
    // handle meridiem
    config._a[HOUR] = meridiemFixWrap(config._locale, config._a[HOUR], config._meridiem);

    // handle era
    era = getParsingFlags(config).era;
    if (era !== null) {
      config._a[YEAR] = config._locale.erasConvertYear(era, config._a[YEAR]);
    }
    configFromArray(config);
    checkOverflow(config);
  }
  function meridiemFixWrap(locale, hour, meridiem) {
    var isPm;
    if (meridiem == null) {
      // nothing to do
      return hour;
    }
    if (locale.meridiemHour != null) {
      return locale.meridiemHour(hour, meridiem);
    } else if (locale.isPM != null) {
      // Fallback
      isPm = locale.isPM(meridiem);
      if (isPm && hour < 12) {
        hour += 12;
      }
      if (!isPm && hour === 12) {
        hour = 0;
      }
      return hour;
    } else {
      // this is not supposed to happen
      return hour;
    }
  }

  // date from string and array of format strings
  function configFromStringAndArray(config) {
    var tempConfig,
      bestMoment,
      scoreToBeat,
      i,
      currentScore,
      validFormatFound,
      bestFormatIsValid = false,
      configfLen = config._f.length;
    if (configfLen === 0) {
      getParsingFlags(config).invalidFormat = true;
      config._d = new Date(NaN);
      return;
    }
    for (i = 0; i < configfLen; i++) {
      currentScore = 0;
      validFormatFound = false;
      tempConfig = copyConfig({}, config);
      if (config._useUTC != null) {
        tempConfig._useUTC = config._useUTC;
      }
      tempConfig._f = config._f[i];
      configFromStringAndFormat(tempConfig);
      if (isValid(tempConfig)) {
        validFormatFound = true;
      }

      // if there is any input that was not parsed add a penalty for that format
      currentScore += getParsingFlags(tempConfig).charsLeftOver;

      //or tokens
      currentScore += getParsingFlags(tempConfig).unusedTokens.length * 10;
      getParsingFlags(tempConfig).score = currentScore;
      if (!bestFormatIsValid) {
        if (scoreToBeat == null || currentScore < scoreToBeat || validFormatFound) {
          scoreToBeat = currentScore;
          bestMoment = tempConfig;
          if (validFormatFound) {
            bestFormatIsValid = true;
          }
        }
      } else {
        if (currentScore < scoreToBeat) {
          scoreToBeat = currentScore;
          bestMoment = tempConfig;
        }
      }
    }
    extend(config, bestMoment || tempConfig);
  }
  function configFromObject(config) {
    if (config._d) {
      return;
    }
    var i = normalizeObjectUnits(config._i),
      dayOrDate = i.day === undefined ? i.date : i.day;
    config._a = map([i.year, i.month, dayOrDate, i.hour, i.minute, i.second, i.millisecond], function (obj) {
      return obj && parseInt(obj, 10);
    });
    configFromArray(config);
  }
  function createFromConfig(config) {
    var res = new Moment(checkOverflow(prepareConfig(config)));
    if (res._nextDay) {
      // Adding is smart enough around DST
      res.add(1, 'd');
      res._nextDay = undefined;
    }
    return res;
  }
  function prepareConfig(config) {
    var input = config._i,
      format = config._f;
    config._locale = config._locale || getLocale(config._l);
    if (input === null || format === undefined && input === '') {
      return createInvalid({
        nullInput: true
      });
    }
    if (typeof input === 'string') {
      config._i = input = config._locale.preparse(input);
    }
    if (isMoment(input)) {
      return new Moment(checkOverflow(input));
    } else if (isDate(input)) {
      config._d = input;
    } else if (isArray(format)) {
      configFromStringAndArray(config);
    } else if (format) {
      configFromStringAndFormat(config);
    } else {
      configFromInput(config);
    }
    if (!isValid(config)) {
      config._d = null;
    }
    return config;
  }
  function configFromInput(config) {
    var input = config._i;
    if (isUndefined(input)) {
      config._d = new Date(hooks.now());
    } else if (isDate(input)) {
      config._d = new Date(input.valueOf());
    } else if (typeof input === 'string') {
      configFromString(config);
    } else if (isArray(input)) {
      config._a = map(input.slice(0), function (obj) {
        return parseInt(obj, 10);
      });
      configFromArray(config);
    } else if (isObject(input)) {
      configFromObject(config);
    } else if (isNumber(input)) {
      // from milliseconds
      config._d = new Date(input);
    } else {
      hooks.createFromInputFallback(config);
    }
  }
  function createLocalOrUTC(input, format, locale, strict, isUTC) {
    var c = {};
    if (format === true || format === false) {
      strict = format;
      format = undefined;
    }
    if (locale === true || locale === false) {
      strict = locale;
      locale = undefined;
    }
    if (isObject(input) && isObjectEmpty(input) || isArray(input) && input.length === 0) {
      input = undefined;
    }
    // object construction must be done this way.
    // https://github.com/moment/moment/issues/1423
    c._isAMomentObject = true;
    c._useUTC = c._isUTC = isUTC;
    c._l = locale;
    c._i = input;
    c._f = format;
    c._strict = strict;
    return createFromConfig(c);
  }
  function createLocal(input, format, locale, strict) {
    return createLocalOrUTC(input, format, locale, strict, false);
  }
  var prototypeMin = deprecate('moment().min is deprecated, use moment.max instead. http://momentjs.com/guides/#/warnings/min-max/', function () {
      var other = createLocal.apply(null, arguments);
      if (this.isValid() && other.isValid()) {
        return other < this ? this : other;
      } else {
        return createInvalid();
      }
    }),
    prototypeMax = deprecate('moment().max is deprecated, use moment.min instead. http://momentjs.com/guides/#/warnings/min-max/', function () {
      var other = createLocal.apply(null, arguments);
      if (this.isValid() && other.isValid()) {
        return other > this ? this : other;
      } else {
        return createInvalid();
      }
    });

  // Pick a moment m from moments so that m[fn](other) is true for all
  // other. This relies on the function fn to be transitive.
  //
  // moments should either be an array of moment objects or an array, whose
  // first element is an array of moment objects.
  function pickBy(fn, moments) {
    var res, i;
    if (moments.length === 1 && isArray(moments[0])) {
      moments = moments[0];
    }
    if (!moments.length) {
      return createLocal();
    }
    res = moments[0];
    for (i = 1; i < moments.length; ++i) {
      if (!moments[i].isValid() || moments[i][fn](res)) {
        res = moments[i];
      }
    }
    return res;
  }

  // TODO: Use [].sort instead?
  function min() {
    var args = [].slice.call(arguments, 0);
    return pickBy('isBefore', args);
  }
  function max() {
    var args = [].slice.call(arguments, 0);
    return pickBy('isAfter', args);
  }
  var now = function () {
    return Date.now ? Date.now() : +new Date();
  };
  var ordering = ['year', 'quarter', 'month', 'week', 'day', 'hour', 'minute', 'second', 'millisecond'];
  function isDurationValid(m) {
    var key,
      unitHasDecimal = false,
      i,
      orderLen = ordering.length;
    for (key in m) {
      if (hasOwnProp(m, key) && !(indexOf.call(ordering, key) !== -1 && (m[key] == null || !isNaN(m[key])))) {
        return false;
      }
    }
    for (i = 0; i < orderLen; ++i) {
      if (m[ordering[i]]) {
        if (unitHasDecimal) {
          return false; // only allow non-integers for smallest unit
        }
        if (parseFloat(m[ordering[i]]) !== toInt(m[ordering[i]])) {
          unitHasDecimal = true;
        }
      }
    }
    return true;
  }
  function isValid$1() {
    return this._isValid;
  }
  function createInvalid$1() {
    return createDuration(NaN);
  }
  function Duration(duration) {
    var normalizedInput = normalizeObjectUnits(duration),
      years = normalizedInput.year || 0,
      quarters = normalizedInput.quarter || 0,
      months = normalizedInput.month || 0,
      weeks = normalizedInput.week || normalizedInput.isoWeek || 0,
      days = normalizedInput.day || 0,
      hours = normalizedInput.hour || 0,
      minutes = normalizedInput.minute || 0,
      seconds = normalizedInput.second || 0,
      milliseconds = normalizedInput.millisecond || 0;
    this._isValid = isDurationValid(normalizedInput);

    // representation for dateAddRemove
    this._milliseconds = +milliseconds + seconds * 1e3 +
    // 1000
    minutes * 6e4 +
    // 1000 * 60
    hours * 1000 * 60 * 60; //using 1000 * 60 * 60 instead of 36e5 to avoid floating point rounding errors https://github.com/moment/moment/issues/2978
    // Because of dateAddRemove treats 24 hours as different from a
    // day when working around DST, we need to store them separately
    this._days = +days + weeks * 7;
    // It is impossible to translate months into days without knowing
    // which months you are are talking about, so we have to store
    // it separately.
    this._months = +months + quarters * 3 + years * 12;
    this._data = {};
    this._locale = getLocale();
    this._bubble();
  }
  function isDuration(obj) {
    return obj instanceof Duration;
  }
  function absRound(number) {
    if (number < 0) {
      return Math.round(-1 * number) * -1;
    } else {
      return Math.round(number);
    }
  }

  // compare two arrays, return the number of differences
  function compareArrays(array1, array2, dontConvert) {
    var len = Math.min(array1.length, array2.length),
      lengthDiff = Math.abs(array1.length - array2.length),
      diffs = 0,
      i;
    for (i = 0; i < len; i++) {
      if (dontConvert && array1[i] !== array2[i] || !dontConvert && toInt(array1[i]) !== toInt(array2[i])) {
        diffs++;
      }
    }
    return diffs + lengthDiff;
  }

  // FORMATTING

  function offset(token, separator) {
    addFormatToken(token, 0, 0, function () {
      var offset = this.utcOffset(),
        sign = '+';
      if (offset < 0) {
        offset = -offset;
        sign = '-';
      }
      return sign + zeroFill(~~(offset / 60), 2) + separator + zeroFill(~~offset % 60, 2);
    });
  }
  offset('Z', ':');
  offset('ZZ', '');

  // PARSING

  addRegexToken('Z', matchShortOffset);
  addRegexToken('ZZ', matchShortOffset);
  addParseToken(['Z', 'ZZ'], function (input, array, config) {
    config._useUTC = true;
    config._tzm = offsetFromString(matchShortOffset, input);
  });

  // HELPERS

  // timezone chunker
  // '+10:00' > ['10',  '00']
  // '-1530'  > ['-15', '30']
  var chunkOffset = /([\+\-]|\d\d)/gi;
  function offsetFromString(matcher, string) {
    var matches = (string || '').match(matcher),
      chunk,
      parts,
      minutes;
    if (matches === null) {
      return null;
    }
    chunk = matches[matches.length - 1] || [];
    parts = (chunk + '').match(chunkOffset) || ['-', 0, 0];
    minutes = +(parts[1] * 60) + toInt(parts[2]);
    return minutes === 0 ? 0 : parts[0] === '+' ? minutes : -minutes;
  }

  // Return a moment from input, that is local/utc/zone equivalent to model.
  function cloneWithOffset(input, model) {
    var res, diff;
    if (model._isUTC) {
      res = model.clone();
      diff = (isMoment(input) || isDate(input) ? input.valueOf() : createLocal(input).valueOf()) - res.valueOf();
      // Use low-level api, because this fn is low-level api.
      res._d.setTime(res._d.valueOf() + diff);
      hooks.updateOffset(res, false);
      return res;
    } else {
      return createLocal(input).local();
    }
  }
  function getDateOffset(m) {
    // On Firefox.24 Date#getTimezoneOffset returns a floating point.
    // https://github.com/moment/moment/pull/1871
    return -Math.round(m._d.getTimezoneOffset());
  }

  // HOOKS

  // This function will be called whenever a moment is mutated.
  // It is intended to keep the offset in sync with the timezone.
  hooks.updateOffset = function () {};

  // MOMENTS

  // keepLocalTime = true means only change the timezone, without
  // affecting the local hour. So 5:31:26 +0300 --[utcOffset(2, true)]-->
  // 5:31:26 +0200 It is possible that 5:31:26 doesn't exist with offset
  // +0200, so we adjust the time as needed, to be valid.
  //
  // Keeping the time actually adds/subtracts (one hour)
  // from the actual represented time. That is why we call updateOffset
  // a second time. In case it wants us to change the offset again
  // _changeInProgress == true case, then we have to adjust, because
  // there is no such time in the given timezone.
  function getSetOffset(input, keepLocalTime, keepMinutes) {
    var offset = this._offset || 0,
      localAdjust;
    if (!this.isValid()) {
      return input != null ? this : NaN;
    }
    if (input != null) {
      if (typeof input === 'string') {
        input = offsetFromString(matchShortOffset, input);
        if (input === null) {
          return this;
        }
      } else if (Math.abs(input) < 16 && !keepMinutes) {
        input = input * 60;
      }
      if (!this._isUTC && keepLocalTime) {
        localAdjust = getDateOffset(this);
      }
      this._offset = input;
      this._isUTC = true;
      if (localAdjust != null) {
        this.add(localAdjust, 'm');
      }
      if (offset !== input) {
        if (!keepLocalTime || this._changeInProgress) {
          addSubtract(this, createDuration(input - offset, 'm'), 1, false);
        } else if (!this._changeInProgress) {
          this._changeInProgress = true;
          hooks.updateOffset(this, true);
          this._changeInProgress = null;
        }
      }
      return this;
    } else {
      return this._isUTC ? offset : getDateOffset(this);
    }
  }
  function getSetZone(input, keepLocalTime) {
    if (input != null) {
      if (typeof input !== 'string') {
        input = -input;
      }
      this.utcOffset(input, keepLocalTime);
      return this;
    } else {
      return -this.utcOffset();
    }
  }
  function setOffsetToUTC(keepLocalTime) {
    return this.utcOffset(0, keepLocalTime);
  }
  function setOffsetToLocal(keepLocalTime) {
    if (this._isUTC) {
      this.utcOffset(0, keepLocalTime);
      this._isUTC = false;
      if (keepLocalTime) {
        this.subtract(getDateOffset(this), 'm');
      }
    }
    return this;
  }
  function setOffsetToParsedOffset() {
    if (this._tzm != null) {
      this.utcOffset(this._tzm, false, true);
    } else if (typeof this._i === 'string') {
      var tZone = offsetFromString(matchOffset, this._i);
      if (tZone != null) {
        this.utcOffset(tZone);
      } else {
        this.utcOffset(0, true);
      }
    }
    return this;
  }
  function hasAlignedHourOffset(input) {
    if (!this.isValid()) {
      return false;
    }
    input = input ? createLocal(input).utcOffset() : 0;
    return (this.utcOffset() - input) % 60 === 0;
  }
  function isDaylightSavingTime() {
    return this.utcOffset() > this.clone().month(0).utcOffset() || this.utcOffset() > this.clone().month(5).utcOffset();
  }
  function isDaylightSavingTimeShifted() {
    if (!isUndefined(this._isDSTShifted)) {
      return this._isDSTShifted;
    }
    var c = {},
      other;
    copyConfig(c, this);
    c = prepareConfig(c);
    if (c._a) {
      other = c._isUTC ? createUTC(c._a) : createLocal(c._a);
      this._isDSTShifted = this.isValid() && compareArrays(c._a, other.toArray()) > 0;
    } else {
      this._isDSTShifted = false;
    }
    return this._isDSTShifted;
  }
  function isLocal() {
    return this.isValid() ? !this._isUTC : false;
  }
  function isUtcOffset() {
    return this.isValid() ? this._isUTC : false;
  }
  function isUtc() {
    return this.isValid() ? this._isUTC && this._offset === 0 : false;
  }

  // ASP.NET json date format regex
  var aspNetRegex = /^(-|\+)?(?:(\d*)[. ])?(\d+):(\d+)(?::(\d+)(\.\d*)?)?$/,
    // from http://docs.closure-library.googlecode.com/git/closure_goog_date_date.js.source.html
    // somewhat more in line with 4.4.3.2 2004 spec, but allows decimal anywhere
    // and further modified to allow for strings containing both week and day
    isoRegex = /^(-|\+)?P(?:([-+]?[0-9,.]*)Y)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)W)?(?:([-+]?[0-9,.]*)D)?(?:T(?:([-+]?[0-9,.]*)H)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)S)?)?$/;
  function createDuration(input, key) {
    var duration = input,
      // matching against regexp is expensive, do it on demand
      match = null,
      sign,
      ret,
      diffRes;
    if (isDuration(input)) {
      duration = {
        ms: input._milliseconds,
        d: input._days,
        M: input._months
      };
    } else if (isNumber(input) || !isNaN(+input)) {
      duration = {};
      if (key) {
        duration[key] = +input;
      } else {
        duration.milliseconds = +input;
      }
    } else if (match = aspNetRegex.exec(input)) {
      sign = match[1] === '-' ? -1 : 1;
      duration = {
        y: 0,
        d: toInt(match[DATE]) * sign,
        h: toInt(match[HOUR]) * sign,
        m: toInt(match[MINUTE]) * sign,
        s: toInt(match[SECOND]) * sign,
        ms: toInt(absRound(match[MILLISECOND] * 1000)) * sign // the millisecond decimal point is included in the match
      };
    } else if (match = isoRegex.exec(input)) {
      sign = match[1] === '-' ? -1 : 1;
      duration = {
        y: parseIso(match[2], sign),
        M: parseIso(match[3], sign),
        w: parseIso(match[4], sign),
        d: parseIso(match[5], sign),
        h: parseIso(match[6], sign),
        m: parseIso(match[7], sign),
        s: parseIso(match[8], sign)
      };
    } else if (duration == null) {
      // checks for null or undefined
      duration = {};
    } else if (typeof duration === 'object' && ('from' in duration || 'to' in duration)) {
      diffRes = momentsDifference(createLocal(duration.from), createLocal(duration.to));
      duration = {};
      duration.ms = diffRes.milliseconds;
      duration.M = diffRes.months;
    }
    ret = new Duration(duration);
    if (isDuration(input) && hasOwnProp(input, '_locale')) {
      ret._locale = input._locale;
    }
    if (isDuration(input) && hasOwnProp(input, '_isValid')) {
      ret._isValid = input._isValid;
    }
    return ret;
  }
  createDuration.fn = Duration.prototype;
  createDuration.invalid = createInvalid$1;
  function parseIso(inp, sign) {
    // We'd normally use ~~inp for this, but unfortunately it also
    // converts floats to ints.
    // inp may be undefined, so careful calling replace on it.
    var res = inp && parseFloat(inp.replace(',', '.'));
    // apply sign while we're at it
    return (isNaN(res) ? 0 : res) * sign;
  }
  function positiveMomentsDifference(base, other) {
    var res = {};
    res.months = other.month() - base.month() + (other.year() - base.year()) * 12;
    if (base.clone().add(res.months, 'M').isAfter(other)) {
      --res.months;
    }
    res.milliseconds = +other - +base.clone().add(res.months, 'M');
    return res;
  }
  function momentsDifference(base, other) {
    var res;
    if (!(base.isValid() && other.isValid())) {
      return {
        milliseconds: 0,
        months: 0
      };
    }
    other = cloneWithOffset(other, base);
    if (base.isBefore(other)) {
      res = positiveMomentsDifference(base, other);
    } else {
      res = positiveMomentsDifference(other, base);
      res.milliseconds = -res.milliseconds;
      res.months = -res.months;
    }
    return res;
  }

  // TODO: remove 'name' arg after deprecation is removed
  function createAdder(direction, name) {
    return function (val, period) {
      var dur, tmp;
      //invert the arguments, but complain about it
      if (period !== null && !isNaN(+period)) {
        deprecateSimple(name, 'moment().' + name + '(period, number) is deprecated. Please use moment().' + name + '(number, period). ' + 'See http://momentjs.com/guides/#/warnings/add-inverted-param/ for more info.');
        tmp = val;
        val = period;
        period = tmp;
      }
      dur = createDuration(val, period);
      addSubtract(this, dur, direction);
      return this;
    };
  }
  function addSubtract(mom, duration, isAdding, updateOffset) {
    var milliseconds = duration._milliseconds,
      days = absRound(duration._days),
      months = absRound(duration._months);
    if (!mom.isValid()) {
      // No op
      return;
    }
    updateOffset = updateOffset == null ? true : updateOffset;
    if (months) {
      setMonth(mom, get(mom, 'Month') + months * isAdding);
    }
    if (days) {
      set$1(mom, 'Date', get(mom, 'Date') + days * isAdding);
    }
    if (milliseconds) {
      mom._d.setTime(mom._d.valueOf() + milliseconds * isAdding);
    }
    if (updateOffset) {
      hooks.updateOffset(mom, days || months);
    }
  }
  var add = createAdder(1, 'add'),
    subtract = createAdder(-1, 'subtract');
  function isString(input) {
    return typeof input === 'string' || input instanceof String;
  }

  // type MomentInput = Moment | Date | string | number | (number | string)[] | MomentInputObject | void; // null | undefined
  function isMomentInput(input) {
    return isMoment(input) || isDate(input) || isString(input) || isNumber(input) || isNumberOrStringArray(input) || isMomentInputObject(input) || input === null || input === undefined;
  }
  function isMomentInputObject(input) {
    var objectTest = isObject(input) && !isObjectEmpty(input),
      propertyTest = false,
      properties = ['years', 'year', 'y', 'months', 'month', 'M', 'days', 'day', 'd', 'dates', 'date', 'D', 'hours', 'hour', 'h', 'minutes', 'minute', 'm', 'seconds', 'second', 's', 'milliseconds', 'millisecond', 'ms'],
      i,
      property,
      propertyLen = properties.length;
    for (i = 0; i < propertyLen; i += 1) {
      property = properties[i];
      propertyTest = propertyTest || hasOwnProp(input, property);
    }
    return objectTest && propertyTest;
  }
  function isNumberOrStringArray(input) {
    var arrayTest = isArray(input),
      dataTypeTest = false;
    if (arrayTest) {
      dataTypeTest = input.filter(function (item) {
        return !isNumber(item) && isString(input);
      }).length === 0;
    }
    return arrayTest && dataTypeTest;
  }
  function isCalendarSpec(input) {
    var objectTest = isObject(input) && !isObjectEmpty(input),
      propertyTest = false,
      properties = ['sameDay', 'nextDay', 'lastDay', 'nextWeek', 'lastWeek', 'sameElse'],
      i,
      property;
    for (i = 0; i < properties.length; i += 1) {
      property = properties[i];
      propertyTest = propertyTest || hasOwnProp(input, property);
    }
    return objectTest && propertyTest;
  }
  function getCalendarFormat(myMoment, now) {
    var diff = myMoment.diff(now, 'days', true);
    return diff < -6 ? 'sameElse' : diff < -1 ? 'lastWeek' : diff < 0 ? 'lastDay' : diff < 1 ? 'sameDay' : diff < 2 ? 'nextDay' : diff < 7 ? 'nextWeek' : 'sameElse';
  }
  function calendar$1(time, formats) {
    // Support for single parameter, formats only overload to the calendar function
    if (arguments.length === 1) {
      if (!arguments[0]) {
        time = undefined;
        formats = undefined;
      } else if (isMomentInput(arguments[0])) {
        time = arguments[0];
        formats = undefined;
      } else if (isCalendarSpec(arguments[0])) {
        formats = arguments[0];
        time = undefined;
      }
    }
    // We want to compare the start of today, vs this.
    // Getting start-of-today depends on whether we're local/utc/offset or not.
    var now = time || createLocal(),
      sod = cloneWithOffset(now, this).startOf('day'),
      format = hooks.calendarFormat(this, sod) || 'sameElse',
      output = formats && (isFunction(formats[format]) ? formats[format].call(this, now) : formats[format]);
    return this.format(output || this.localeData().calendar(format, this, createLocal(now)));
  }
  function clone() {
    return new Moment(this);
  }
  function isAfter(input, units) {
    var localInput = isMoment(input) ? input : createLocal(input);
    if (!(this.isValid() && localInput.isValid())) {
      return false;
    }
    units = normalizeUnits(units) || 'millisecond';
    if (units === 'millisecond') {
      return this.valueOf() > localInput.valueOf();
    } else {
      return localInput.valueOf() < this.clone().startOf(units).valueOf();
    }
  }
  function isBefore(input, units) {
    var localInput = isMoment(input) ? input : createLocal(input);
    if (!(this.isValid() && localInput.isValid())) {
      return false;
    }
    units = normalizeUnits(units) || 'millisecond';
    if (units === 'millisecond') {
      return this.valueOf() < localInput.valueOf();
    } else {
      return this.clone().endOf(units).valueOf() < localInput.valueOf();
    }
  }
  function isBetween(from, to, units, inclusivity) {
    var localFrom = isMoment(from) ? from : createLocal(from),
      localTo = isMoment(to) ? to : createLocal(to);
    if (!(this.isValid() && localFrom.isValid() && localTo.isValid())) {
      return false;
    }
    inclusivity = inclusivity || '()';
    return (inclusivity[0] === '(' ? this.isAfter(localFrom, units) : !this.isBefore(localFrom, units)) && (inclusivity[1] === ')' ? this.isBefore(localTo, units) : !this.isAfter(localTo, units));
  }
  function isSame(input, units) {
    var localInput = isMoment(input) ? input : createLocal(input),
      inputMs;
    if (!(this.isValid() && localInput.isValid())) {
      return false;
    }
    units = normalizeUnits(units) || 'millisecond';
    if (units === 'millisecond') {
      return this.valueOf() === localInput.valueOf();
    } else {
      inputMs = localInput.valueOf();
      return this.clone().startOf(units).valueOf() <= inputMs && inputMs <= this.clone().endOf(units).valueOf();
    }
  }
  function isSameOrAfter(input, units) {
    return this.isSame(input, units) || this.isAfter(input, units);
  }
  function isSameOrBefore(input, units) {
    return this.isSame(input, units) || this.isBefore(input, units);
  }
  function diff(input, units, asFloat) {
    var that, zoneDelta, output;
    if (!this.isValid()) {
      return NaN;
    }
    that = cloneWithOffset(input, this);
    if (!that.isValid()) {
      return NaN;
    }
    zoneDelta = (that.utcOffset() - this.utcOffset()) * 6e4;
    units = normalizeUnits(units);
    switch (units) {
      case 'year':
        output = monthDiff(this, that) / 12;
        break;
      case 'month':
        output = monthDiff(this, that);
        break;
      case 'quarter':
        output = monthDiff(this, that) / 3;
        break;
      case 'second':
        output = (this - that) / 1e3;
        break;
      // 1000
      case 'minute':
        output = (this - that) / 6e4;
        break;
      // 1000 * 60
      case 'hour':
        output = (this - that) / 36e5;
        break;
      // 1000 * 60 * 60
      case 'day':
        output = (this - that - zoneDelta) / 864e5;
        break;
      // 1000 * 60 * 60 * 24, negate dst
      case 'week':
        output = (this - that - zoneDelta) / 6048e5;
        break;
      // 1000 * 60 * 60 * 24 * 7, negate dst
      default:
        output = this - that;
    }
    return asFloat ? output : absFloor(output);
  }
  function monthDiff(a, b) {
    if (a.date() < b.date()) {
      // end-of-month calculations work correct when the start month has more
      // days than the end month.
      return -monthDiff(b, a);
    }
    // difference in months
    var wholeMonthDiff = (b.year() - a.year()) * 12 + (b.month() - a.month()),
      // b is in (anchor - 1 month, anchor + 1 month)
      anchor = a.clone().add(wholeMonthDiff, 'months'),
      anchor2,
      adjust;
    if (b - anchor < 0) {
      anchor2 = a.clone().add(wholeMonthDiff - 1, 'months');
      // linear across the month
      adjust = (b - anchor) / (anchor - anchor2);
    } else {
      anchor2 = a.clone().add(wholeMonthDiff + 1, 'months');
      // linear across the month
      adjust = (b - anchor) / (anchor2 - anchor);
    }

    //check for negative zero, return zero if negative zero
    return -(wholeMonthDiff + adjust) || 0;
  }
  hooks.defaultFormat = 'YYYY-MM-DDTHH:mm:ssZ';
  hooks.defaultFormatUtc = 'YYYY-MM-DDTHH:mm:ss[Z]';
  function toString() {
    return this.clone().locale('en').format('ddd MMM DD YYYY HH:mm:ss [GMT]ZZ');
  }
  function toISOString(keepOffset) {
    if (!this.isValid()) {
      return null;
    }
    var utc = keepOffset !== true,
      m = utc ? this.clone().utc() : this;
    if (m.year() < 0 || m.year() > 9999) {
      return formatMoment(m, utc ? 'YYYYYY-MM-DD[T]HH:mm:ss.SSS[Z]' : 'YYYYYY-MM-DD[T]HH:mm:ss.SSSZ');
    }
    if (isFunction(Date.prototype.toISOString)) {
      // native implementation is ~50x faster, use it when we can
      if (utc) {
        return this.toDate().toISOString();
      } else {
        return new Date(this.valueOf() + this.utcOffset() * 60 * 1000).toISOString().replace('Z', formatMoment(m, 'Z'));
      }
    }
    return formatMoment(m, utc ? 'YYYY-MM-DD[T]HH:mm:ss.SSS[Z]' : 'YYYY-MM-DD[T]HH:mm:ss.SSSZ');
  }

  /**
   * Return a human readable representation of a moment that can
   * also be evaluated to get a new moment which is the same
   *
   * @link https://nodejs.org/dist/latest/docs/api/util.html#util_custom_inspect_function_on_objects
   */
  function inspect() {
    if (!this.isValid()) {
      return 'moment.invalid(/* ' + this._i + ' */)';
    }
    var func = 'moment',
      zone = '',
      prefix,
      year,
      datetime,
      suffix;
    if (!this.isLocal()) {
      func = this.utcOffset() === 0 ? 'moment.utc' : 'moment.parseZone';
      zone = 'Z';
    }
    prefix = '[' + func + '("]';
    year = 0 <= this.year() && this.year() <= 9999 ? 'YYYY' : 'YYYYYY';
    datetime = '-MM-DD[T]HH:mm:ss.SSS';
    suffix = zone + '[")]';
    return this.format(prefix + year + datetime + suffix);
  }
  function format(inputString) {
    if (!inputString) {
      inputString = this.isUtc() ? hooks.defaultFormatUtc : hooks.defaultFormat;
    }
    var output = formatMoment(this, inputString);
    return this.localeData().postformat(output);
  }
  function from(time, withoutSuffix) {
    if (this.isValid() && (isMoment(time) && time.isValid() || createLocal(time).isValid())) {
      return createDuration({
        to: this,
        from: time
      }).locale(this.locale()).humanize(!withoutSuffix);
    } else {
      return this.localeData().invalidDate();
    }
  }
  function fromNow(withoutSuffix) {
    return this.from(createLocal(), withoutSuffix);
  }
  function to(time, withoutSuffix) {
    if (this.isValid() && (isMoment(time) && time.isValid() || createLocal(time).isValid())) {
      return createDuration({
        from: this,
        to: time
      }).locale(this.locale()).humanize(!withoutSuffix);
    } else {
      return this.localeData().invalidDate();
    }
  }
  function toNow(withoutSuffix) {
    return this.to(createLocal(), withoutSuffix);
  }

  // If passed a locale key, it will set the locale for this
  // instance.  Otherwise, it will return the locale configuration
  // variables for this instance.
  function locale(key) {
    var newLocaleData;
    if (key === undefined) {
      return this._locale._abbr;
    } else {
      newLocaleData = getLocale(key);
      if (newLocaleData != null) {
        this._locale = newLocaleData;
      }
      return this;
    }
  }
  var lang = deprecate('moment().lang() is deprecated. Instead, use moment().localeData() to get the language configuration. Use moment().locale() to change languages.', function (key) {
    if (key === undefined) {
      return this.localeData();
    } else {
      return this.locale(key);
    }
  });
  function localeData() {
    return this._locale;
  }
  var MS_PER_SECOND = 1000,
    MS_PER_MINUTE = 60 * MS_PER_SECOND,
    MS_PER_HOUR = 60 * MS_PER_MINUTE,
    MS_PER_400_YEARS = (365 * 400 + 97) * 24 * MS_PER_HOUR;

  // actual modulo - handles negative numbers (for dates before 1970):
  function mod$1(dividend, divisor) {
    return (dividend % divisor + divisor) % divisor;
  }
  function localStartOfDate(y, m, d) {
    // the date constructor remaps years 0-99 to 1900-1999
    if (y < 100 && y >= 0) {
      // preserve leap years using a full 400 year cycle, then reset
      return new Date(y + 400, m, d) - MS_PER_400_YEARS;
    } else {
      return new Date(y, m, d).valueOf();
    }
  }
  function utcStartOfDate(y, m, d) {
    // Date.UTC remaps years 0-99 to 1900-1999
    if (y < 100 && y >= 0) {
      // preserve leap years using a full 400 year cycle, then reset
      return Date.UTC(y + 400, m, d) - MS_PER_400_YEARS;
    } else {
      return Date.UTC(y, m, d);
    }
  }
  function startOf(units) {
    var time, startOfDate;
    units = normalizeUnits(units);
    if (units === undefined || units === 'millisecond' || !this.isValid()) {
      return this;
    }
    startOfDate = this._isUTC ? utcStartOfDate : localStartOfDate;
    switch (units) {
      case 'year':
        time = startOfDate(this.year(), 0, 1);
        break;
      case 'quarter':
        time = startOfDate(this.year(), this.month() - this.month() % 3, 1);
        break;
      case 'month':
        time = startOfDate(this.year(), this.month(), 1);
        break;
      case 'week':
        time = startOfDate(this.year(), this.month(), this.date() - this.weekday());
        break;
      case 'isoWeek':
        time = startOfDate(this.year(), this.month(), this.date() - (this.isoWeekday() - 1));
        break;
      case 'day':
      case 'date':
        time = startOfDate(this.year(), this.month(), this.date());
        break;
      case 'hour':
        time = this._d.valueOf();
        time -= mod$1(time + (this._isUTC ? 0 : this.utcOffset() * MS_PER_MINUTE), MS_PER_HOUR);
        break;
      case 'minute':
        time = this._d.valueOf();
        time -= mod$1(time, MS_PER_MINUTE);
        break;
      case 'second':
        time = this._d.valueOf();
        time -= mod$1(time, MS_PER_SECOND);
        break;
    }
    this._d.setTime(time);
    hooks.updateOffset(this, true);
    return this;
  }
  function endOf(units) {
    var time, startOfDate;
    units = normalizeUnits(units);
    if (units === undefined || units === 'millisecond' || !this.isValid()) {
      return this;
    }
    startOfDate = this._isUTC ? utcStartOfDate : localStartOfDate;
    switch (units) {
      case 'year':
        time = startOfDate(this.year() + 1, 0, 1) - 1;
        break;
      case 'quarter':
        time = startOfDate(this.year(), this.month() - this.month() % 3 + 3, 1) - 1;
        break;
      case 'month':
        time = startOfDate(this.year(), this.month() + 1, 1) - 1;
        break;
      case 'week':
        time = startOfDate(this.year(), this.month(), this.date() - this.weekday() + 7) - 1;
        break;
      case 'isoWeek':
        time = startOfDate(this.year(), this.month(), this.date() - (this.isoWeekday() - 1) + 7) - 1;
        break;
      case 'day':
      case 'date':
        time = startOfDate(this.year(), this.month(), this.date() + 1) - 1;
        break;
      case 'hour':
        time = this._d.valueOf();
        time += MS_PER_HOUR - mod$1(time + (this._isUTC ? 0 : this.utcOffset() * MS_PER_MINUTE), MS_PER_HOUR) - 1;
        break;
      case 'minute':
        time = this._d.valueOf();
        time += MS_PER_MINUTE - mod$1(time, MS_PER_MINUTE) - 1;
        break;
      case 'second':
        time = this._d.valueOf();
        time += MS_PER_SECOND - mod$1(time, MS_PER_SECOND) - 1;
        break;
    }
    this._d.setTime(time);
    hooks.updateOffset(this, true);
    return this;
  }
  function valueOf() {
    return this._d.valueOf() - (this._offset || 0) * 60000;
  }
  function unix() {
    return Math.floor(this.valueOf() / 1000);
  }
  function toDate() {
    return new Date(this.valueOf());
  }
  function toArray() {
    var m = this;
    return [m.year(), m.month(), m.date(), m.hour(), m.minute(), m.second(), m.millisecond()];
  }
  function toObject() {
    var m = this;
    return {
      years: m.year(),
      months: m.month(),
      date: m.date(),
      hours: m.hours(),
      minutes: m.minutes(),
      seconds: m.seconds(),
      milliseconds: m.milliseconds()
    };
  }
  function toJSON() {
    // new Date(NaN).toJSON() === null
    return this.isValid() ? this.toISOString() : null;
  }
  function isValid$2() {
    return isValid(this);
  }
  function parsingFlags() {
    return extend({}, getParsingFlags(this));
  }
  function invalidAt() {
    return getParsingFlags(this).overflow;
  }
  function creationData() {
    return {
      input: this._i,
      format: this._f,
      locale: this._locale,
      isUTC: this._isUTC,
      strict: this._strict
    };
  }
  addFormatToken('N', 0, 0, 'eraAbbr');
  addFormatToken('NN', 0, 0, 'eraAbbr');
  addFormatToken('NNN', 0, 0, 'eraAbbr');
  addFormatToken('NNNN', 0, 0, 'eraName');
  addFormatToken('NNNNN', 0, 0, 'eraNarrow');
  addFormatToken('y', ['y', 1], 'yo', 'eraYear');
  addFormatToken('y', ['yy', 2], 0, 'eraYear');
  addFormatToken('y', ['yyy', 3], 0, 'eraYear');
  addFormatToken('y', ['yyyy', 4], 0, 'eraYear');
  addRegexToken('N', matchEraAbbr);
  addRegexToken('NN', matchEraAbbr);
  addRegexToken('NNN', matchEraAbbr);
  addRegexToken('NNNN', matchEraName);
  addRegexToken('NNNNN', matchEraNarrow);
  addParseToken(['N', 'NN', 'NNN', 'NNNN', 'NNNNN'], function (input, array, config, token) {
    var era = config._locale.erasParse(input, token, config._strict);
    if (era) {
      getParsingFlags(config).era = era;
    } else {
      getParsingFlags(config).invalidEra = input;
    }
  });
  addRegexToken('y', matchUnsigned);
  addRegexToken('yy', matchUnsigned);
  addRegexToken('yyy', matchUnsigned);
  addRegexToken('yyyy', matchUnsigned);
  addRegexToken('yo', matchEraYearOrdinal);
  addParseToken(['y', 'yy', 'yyy', 'yyyy'], YEAR);
  addParseToken(['yo'], function (input, array, config, token) {
    var match;
    if (config._locale._eraYearOrdinalRegex) {
      match = input.match(config._locale._eraYearOrdinalRegex);
    }
    if (config._locale.eraYearOrdinalParse) {
      array[YEAR] = config._locale.eraYearOrdinalParse(input, match);
    } else {
      array[YEAR] = parseInt(input, 10);
    }
  });
  function localeEras(m, format) {
    var i,
      l,
      date,
      eras = this._eras || getLocale('en')._eras;
    for (i = 0, l = eras.length; i < l; ++i) {
      switch (typeof eras[i].since) {
        case 'string':
          // truncate time
          date = hooks(eras[i].since).startOf('day');
          eras[i].since = date.valueOf();
          break;
      }
      switch (typeof eras[i].until) {
        case 'undefined':
          eras[i].until = +Infinity;
          break;
        case 'string':
          // truncate time
          date = hooks(eras[i].until).startOf('day').valueOf();
          eras[i].until = date.valueOf();
          break;
      }
    }
    return eras;
  }
  function localeErasParse(eraName, format, strict) {
    var i,
      l,
      eras = this.eras(),
      name,
      abbr,
      narrow;
    eraName = eraName.toUpperCase();
    for (i = 0, l = eras.length; i < l; ++i) {
      name = eras[i].name.toUpperCase();
      abbr = eras[i].abbr.toUpperCase();
      narrow = eras[i].narrow.toUpperCase();
      if (strict) {
        switch (format) {
          case 'N':
          case 'NN':
          case 'NNN':
            if (abbr === eraName) {
              return eras[i];
            }
            break;
          case 'NNNN':
            if (name === eraName) {
              return eras[i];
            }
            break;
          case 'NNNNN':
            if (narrow === eraName) {
              return eras[i];
            }
            break;
        }
      } else if ([name, abbr, narrow].indexOf(eraName) >= 0) {
        return eras[i];
      }
    }
  }
  function localeErasConvertYear(era, year) {
    var dir = era.since <= era.until ? +1 : -1;
    if (year === undefined) {
      return hooks(era.since).year();
    } else {
      return hooks(era.since).year() + (year - era.offset) * dir;
    }
  }
  function getEraName() {
    var i,
      l,
      val,
      eras = this.localeData().eras();
    for (i = 0, l = eras.length; i < l; ++i) {
      // truncate time
      val = this.clone().startOf('day').valueOf();
      if (eras[i].since <= val && val <= eras[i].until) {
        return eras[i].name;
      }
      if (eras[i].until <= val && val <= eras[i].since) {
        return eras[i].name;
      }
    }
    return '';
  }
  function getEraNarrow() {
    var i,
      l,
      val,
      eras = this.localeData().eras();
    for (i = 0, l = eras.length; i < l; ++i) {
      // truncate time
      val = this.clone().startOf('day').valueOf();
      if (eras[i].since <= val && val <= eras[i].until) {
        return eras[i].narrow;
      }
      if (eras[i].until <= val && val <= eras[i].since) {
        return eras[i].narrow;
      }
    }
    return '';
  }
  function getEraAbbr() {
    var i,
      l,
      val,
      eras = this.localeData().eras();
    for (i = 0, l = eras.length; i < l; ++i) {
      // truncate time
      val = this.clone().startOf('day').valueOf();
      if (eras[i].since <= val && val <= eras[i].until) {
        return eras[i].abbr;
      }
      if (eras[i].until <= val && val <= eras[i].since) {
        return eras[i].abbr;
      }
    }
    return '';
  }
  function getEraYear() {
    var i,
      l,
      dir,
      val,
      eras = this.localeData().eras();
    for (i = 0, l = eras.length; i < l; ++i) {
      dir = eras[i].since <= eras[i].until ? +1 : -1;

      // truncate time
      val = this.clone().startOf('day').valueOf();
      if (eras[i].since <= val && val <= eras[i].until || eras[i].until <= val && val <= eras[i].since) {
        return (this.year() - hooks(eras[i].since).year()) * dir + eras[i].offset;
      }
    }
    return this.year();
  }
  function erasNameRegex(isStrict) {
    if (!hasOwnProp(this, '_erasNameRegex')) {
      computeErasParse.call(this);
    }
    return isStrict ? this._erasNameRegex : this._erasRegex;
  }
  function erasAbbrRegex(isStrict) {
    if (!hasOwnProp(this, '_erasAbbrRegex')) {
      computeErasParse.call(this);
    }
    return isStrict ? this._erasAbbrRegex : this._erasRegex;
  }
  function erasNarrowRegex(isStrict) {
    if (!hasOwnProp(this, '_erasNarrowRegex')) {
      computeErasParse.call(this);
    }
    return isStrict ? this._erasNarrowRegex : this._erasRegex;
  }
  function matchEraAbbr(isStrict, locale) {
    return locale.erasAbbrRegex(isStrict);
  }
  function matchEraName(isStrict, locale) {
    return locale.erasNameRegex(isStrict);
  }
  function matchEraNarrow(isStrict, locale) {
    return locale.erasNarrowRegex(isStrict);
  }
  function matchEraYearOrdinal(isStrict, locale) {
    return locale._eraYearOrdinalRegex || matchUnsigned;
  }
  function computeErasParse() {
    var abbrPieces = [],
      namePieces = [],
      narrowPieces = [],
      mixedPieces = [],
      i,
      l,
      eras = this.eras();
    for (i = 0, l = eras.length; i < l; ++i) {
      namePieces.push(regexEscape(eras[i].name));
      abbrPieces.push(regexEscape(eras[i].abbr));
      narrowPieces.push(regexEscape(eras[i].narrow));
      mixedPieces.push(regexEscape(eras[i].name));
      mixedPieces.push(regexEscape(eras[i].abbr));
      mixedPieces.push(regexEscape(eras[i].narrow));
    }
    this._erasRegex = new RegExp('^(' + mixedPieces.join('|') + ')', 'i');
    this._erasNameRegex = new RegExp('^(' + namePieces.join('|') + ')', 'i');
    this._erasAbbrRegex = new RegExp('^(' + abbrPieces.join('|') + ')', 'i');
    this._erasNarrowRegex = new RegExp('^(' + narrowPieces.join('|') + ')', 'i');
  }

  // FORMATTING

  addFormatToken(0, ['gg', 2], 0, function () {
    return this.weekYear() % 100;
  });
  addFormatToken(0, ['GG', 2], 0, function () {
    return this.isoWeekYear() % 100;
  });
  function addWeekYearFormatToken(token, getter) {
    addFormatToken(0, [token, token.length], 0, getter);
  }
  addWeekYearFormatToken('gggg', 'weekYear');
  addWeekYearFormatToken('ggggg', 'weekYear');
  addWeekYearFormatToken('GGGG', 'isoWeekYear');
  addWeekYearFormatToken('GGGGG', 'isoWeekYear');

  // ALIASES

  addUnitAlias('weekYear', 'gg');
  addUnitAlias('isoWeekYear', 'GG');

  // PRIORITY

  addUnitPriority('weekYear', 1);
  addUnitPriority('isoWeekYear', 1);

  // PARSING

  addRegexToken('G', matchSigned);
  addRegexToken('g', matchSigned);
  addRegexToken('GG', match1to2, match2);
  addRegexToken('gg', match1to2, match2);
  addRegexToken('GGGG', match1to4, match4);
  addRegexToken('gggg', match1to4, match4);
  addRegexToken('GGGGG', match1to6, match6);
  addRegexToken('ggggg', match1to6, match6);
  addWeekParseToken(['gggg', 'ggggg', 'GGGG', 'GGGGG'], function (input, week, config, token) {
    week[token.substr(0, 2)] = toInt(input);
  });
  addWeekParseToken(['gg', 'GG'], function (input, week, config, token) {
    week[token] = hooks.parseTwoDigitYear(input);
  });

  // MOMENTS

  function getSetWeekYear(input) {
    return getSetWeekYearHelper.call(this, input, this.week(), this.weekday(), this.localeData()._week.dow, this.localeData()._week.doy);
  }
  function getSetISOWeekYear(input) {
    return getSetWeekYearHelper.call(this, input, this.isoWeek(), this.isoWeekday(), 1, 4);
  }
  function getISOWeeksInYear() {
    return weeksInYear(this.year(), 1, 4);
  }
  function getISOWeeksInISOWeekYear() {
    return weeksInYear(this.isoWeekYear(), 1, 4);
  }
  function getWeeksInYear() {
    var weekInfo = this.localeData()._week;
    return weeksInYear(this.year(), weekInfo.dow, weekInfo.doy);
  }
  function getWeeksInWeekYear() {
    var weekInfo = this.localeData()._week;
    return weeksInYear(this.weekYear(), weekInfo.dow, weekInfo.doy);
  }
  function getSetWeekYearHelper(input, week, weekday, dow, doy) {
    var weeksTarget;
    if (input == null) {
      return weekOfYear(this, dow, doy).year;
    } else {
      weeksTarget = weeksInYear(input, dow, doy);
      if (week > weeksTarget) {
        week = weeksTarget;
      }
      return setWeekAll.call(this, input, week, weekday, dow, doy);
    }
  }
  function setWeekAll(weekYear, week, weekday, dow, doy) {
    var dayOfYearData = dayOfYearFromWeeks(weekYear, week, weekday, dow, doy),
      date = createUTCDate(dayOfYearData.year, 0, dayOfYearData.dayOfYear);
    this.year(date.getUTCFullYear());
    this.month(date.getUTCMonth());
    this.date(date.getUTCDate());
    return this;
  }

  // FORMATTING

  addFormatToken('Q', 0, 'Qo', 'quarter');

  // ALIASES

  addUnitAlias('quarter', 'Q');

  // PRIORITY

  addUnitPriority('quarter', 7);

  // PARSING

  addRegexToken('Q', match1);
  addParseToken('Q', function (input, array) {
    array[MONTH] = (toInt(input) - 1) * 3;
  });

  // MOMENTS

  function getSetQuarter(input) {
    return input == null ? Math.ceil((this.month() + 1) / 3) : this.month((input - 1) * 3 + this.month() % 3);
  }

  // FORMATTING

  addFormatToken('D', ['DD', 2], 'Do', 'date');

  // ALIASES

  addUnitAlias('date', 'D');

  // PRIORITY
  addUnitPriority('date', 9);

  // PARSING

  addRegexToken('D', match1to2);
  addRegexToken('DD', match1to2, match2);
  addRegexToken('Do', function (isStrict, locale) {
    // TODO: Remove "ordinalParse" fallback in next major release.
    return isStrict ? locale._dayOfMonthOrdinalParse || locale._ordinalParse : locale._dayOfMonthOrdinalParseLenient;
  });
  addParseToken(['D', 'DD'], DATE);
  addParseToken('Do', function (input, array) {
    array[DATE] = toInt(input.match(match1to2)[0]);
  });

  // MOMENTS

  var getSetDayOfMonth = makeGetSet('Date', true);

  // FORMATTING

  addFormatToken('DDD', ['DDDD', 3], 'DDDo', 'dayOfYear');

  // ALIASES

  addUnitAlias('dayOfYear', 'DDD');

  // PRIORITY
  addUnitPriority('dayOfYear', 4);

  // PARSING

  addRegexToken('DDD', match1to3);
  addRegexToken('DDDD', match3);
  addParseToken(['DDD', 'DDDD'], function (input, array, config) {
    config._dayOfYear = toInt(input);
  });

  // HELPERS

  // MOMENTS

  function getSetDayOfYear(input) {
    var dayOfYear = Math.round((this.clone().startOf('day') - this.clone().startOf('year')) / 864e5) + 1;
    return input == null ? dayOfYear : this.add(input - dayOfYear, 'd');
  }

  // FORMATTING

  addFormatToken('m', ['mm', 2], 0, 'minute');

  // ALIASES

  addUnitAlias('minute', 'm');

  // PRIORITY

  addUnitPriority('minute', 14);

  // PARSING

  addRegexToken('m', match1to2);
  addRegexToken('mm', match1to2, match2);
  addParseToken(['m', 'mm'], MINUTE);

  // MOMENTS

  var getSetMinute = makeGetSet('Minutes', false);

  // FORMATTING

  addFormatToken('s', ['ss', 2], 0, 'second');

  // ALIASES

  addUnitAlias('second', 's');

  // PRIORITY

  addUnitPriority('second', 15);

  // PARSING

  addRegexToken('s', match1to2);
  addRegexToken('ss', match1to2, match2);
  addParseToken(['s', 'ss'], SECOND);

  // MOMENTS

  var getSetSecond = makeGetSet('Seconds', false);

  // FORMATTING

  addFormatToken('S', 0, 0, function () {
    return ~~(this.millisecond() / 100);
  });
  addFormatToken(0, ['SS', 2], 0, function () {
    return ~~(this.millisecond() / 10);
  });
  addFormatToken(0, ['SSS', 3], 0, 'millisecond');
  addFormatToken(0, ['SSSS', 4], 0, function () {
    return this.millisecond() * 10;
  });
  addFormatToken(0, ['SSSSS', 5], 0, function () {
    return this.millisecond() * 100;
  });
  addFormatToken(0, ['SSSSSS', 6], 0, function () {
    return this.millisecond() * 1000;
  });
  addFormatToken(0, ['SSSSSSS', 7], 0, function () {
    return this.millisecond() * 10000;
  });
  addFormatToken(0, ['SSSSSSSS', 8], 0, function () {
    return this.millisecond() * 100000;
  });
  addFormatToken(0, ['SSSSSSSSS', 9], 0, function () {
    return this.millisecond() * 1000000;
  });

  // ALIASES

  addUnitAlias('millisecond', 'ms');

  // PRIORITY

  addUnitPriority('millisecond', 16);

  // PARSING

  addRegexToken('S', match1to3, match1);
  addRegexToken('SS', match1to3, match2);
  addRegexToken('SSS', match1to3, match3);
  var token, getSetMillisecond;
  for (token = 'SSSS'; token.length <= 9; token += 'S') {
    addRegexToken(token, matchUnsigned);
  }
  function parseMs(input, array) {
    array[MILLISECOND] = toInt(('0.' + input) * 1000);
  }
  for (token = 'S'; token.length <= 9; token += 'S') {
    addParseToken(token, parseMs);
  }
  getSetMillisecond = makeGetSet('Milliseconds', false);

  // FORMATTING

  addFormatToken('z', 0, 0, 'zoneAbbr');
  addFormatToken('zz', 0, 0, 'zoneName');

  // MOMENTS

  function getZoneAbbr() {
    return this._isUTC ? 'UTC' : '';
  }
  function getZoneName() {
    return this._isUTC ? 'Coordinated Universal Time' : '';
  }
  var proto = Moment.prototype;
  proto.add = add;
  proto.calendar = calendar$1;
  proto.clone = clone;
  proto.diff = diff;
  proto.endOf = endOf;
  proto.format = format;
  proto.from = from;
  proto.fromNow = fromNow;
  proto.to = to;
  proto.toNow = toNow;
  proto.get = stringGet;
  proto.invalidAt = invalidAt;
  proto.isAfter = isAfter;
  proto.isBefore = isBefore;
  proto.isBetween = isBetween;
  proto.isSame = isSame;
  proto.isSameOrAfter = isSameOrAfter;
  proto.isSameOrBefore = isSameOrBefore;
  proto.isValid = isValid$2;
  proto.lang = lang;
  proto.locale = locale;
  proto.localeData = localeData;
  proto.max = prototypeMax;
  proto.min = prototypeMin;
  proto.parsingFlags = parsingFlags;
  proto.set = stringSet;
  proto.startOf = startOf;
  proto.subtract = subtract;
  proto.toArray = toArray;
  proto.toObject = toObject;
  proto.toDate = toDate;
  proto.toISOString = toISOString;
  proto.inspect = inspect;
  if (typeof Symbol !== 'undefined' && Symbol.for != null) {
    proto[Symbol.for('nodejs.util.inspect.custom')] = function () {
      return 'Moment<' + this.format() + '>';
    };
  }
  proto.toJSON = toJSON;
  proto.toString = toString;
  proto.unix = unix;
  proto.valueOf = valueOf;
  proto.creationData = creationData;
  proto.eraName = getEraName;
  proto.eraNarrow = getEraNarrow;
  proto.eraAbbr = getEraAbbr;
  proto.eraYear = getEraYear;
  proto.year = getSetYear;
  proto.isLeapYear = getIsLeapYear;
  proto.weekYear = getSetWeekYear;
  proto.isoWeekYear = getSetISOWeekYear;
  proto.quarter = proto.quarters = getSetQuarter;
  proto.month = getSetMonth;
  proto.daysInMonth = getDaysInMonth;
  proto.week = proto.weeks = getSetWeek;
  proto.isoWeek = proto.isoWeeks = getSetISOWeek;
  proto.weeksInYear = getWeeksInYear;
  proto.weeksInWeekYear = getWeeksInWeekYear;
  proto.isoWeeksInYear = getISOWeeksInYear;
  proto.isoWeeksInISOWeekYear = getISOWeeksInISOWeekYear;
  proto.date = getSetDayOfMonth;
  proto.day = proto.days = getSetDayOfWeek;
  proto.weekday = getSetLocaleDayOfWeek;
  proto.isoWeekday = getSetISODayOfWeek;
  proto.dayOfYear = getSetDayOfYear;
  proto.hour = proto.hours = getSetHour;
  proto.minute = proto.minutes = getSetMinute;
  proto.second = proto.seconds = getSetSecond;
  proto.millisecond = proto.milliseconds = getSetMillisecond;
  proto.utcOffset = getSetOffset;
  proto.utc = setOffsetToUTC;
  proto.local = setOffsetToLocal;
  proto.parseZone = setOffsetToParsedOffset;
  proto.hasAlignedHourOffset = hasAlignedHourOffset;
  proto.isDST = isDaylightSavingTime;
  proto.isLocal = isLocal;
  proto.isUtcOffset = isUtcOffset;
  proto.isUtc = isUtc;
  proto.isUTC = isUtc;
  proto.zoneAbbr = getZoneAbbr;
  proto.zoneName = getZoneName;
  proto.dates = deprecate('dates accessor is deprecated. Use date instead.', getSetDayOfMonth);
  proto.months = deprecate('months accessor is deprecated. Use month instead', getSetMonth);
  proto.years = deprecate('years accessor is deprecated. Use year instead', getSetYear);
  proto.zone = deprecate('moment().zone is deprecated, use moment().utcOffset instead. http://momentjs.com/guides/#/warnings/zone/', getSetZone);
  proto.isDSTShifted = deprecate('isDSTShifted is deprecated. See http://momentjs.com/guides/#/warnings/dst-shifted/ for more information', isDaylightSavingTimeShifted);
  function createUnix(input) {
    return createLocal(input * 1000);
  }
  function createInZone() {
    return createLocal.apply(null, arguments).parseZone();
  }
  function preParsePostFormat(string) {
    return string;
  }
  var proto$1 = Locale.prototype;
  proto$1.calendar = calendar;
  proto$1.longDateFormat = longDateFormat;
  proto$1.invalidDate = invalidDate;
  proto$1.ordinal = ordinal;
  proto$1.preparse = preParsePostFormat;
  proto$1.postformat = preParsePostFormat;
  proto$1.relativeTime = relativeTime;
  proto$1.pastFuture = pastFuture;
  proto$1.set = set;
  proto$1.eras = localeEras;
  proto$1.erasParse = localeErasParse;
  proto$1.erasConvertYear = localeErasConvertYear;
  proto$1.erasAbbrRegex = erasAbbrRegex;
  proto$1.erasNameRegex = erasNameRegex;
  proto$1.erasNarrowRegex = erasNarrowRegex;
  proto$1.months = localeMonths;
  proto$1.monthsShort = localeMonthsShort;
  proto$1.monthsParse = localeMonthsParse;
  proto$1.monthsRegex = monthsRegex;
  proto$1.monthsShortRegex = monthsShortRegex;
  proto$1.week = localeWeek;
  proto$1.firstDayOfYear = localeFirstDayOfYear;
  proto$1.firstDayOfWeek = localeFirstDayOfWeek;
  proto$1.weekdays = localeWeekdays;
  proto$1.weekdaysMin = localeWeekdaysMin;
  proto$1.weekdaysShort = localeWeekdaysShort;
  proto$1.weekdaysParse = localeWeekdaysParse;
  proto$1.weekdaysRegex = weekdaysRegex;
  proto$1.weekdaysShortRegex = weekdaysShortRegex;
  proto$1.weekdaysMinRegex = weekdaysMinRegex;
  proto$1.isPM = localeIsPM;
  proto$1.meridiem = localeMeridiem;
  function get$1(format, index, field, setter) {
    var locale = getLocale(),
      utc = createUTC().set(setter, index);
    return locale[field](utc, format);
  }
  function listMonthsImpl(format, index, field) {
    if (isNumber(format)) {
      index = format;
      format = undefined;
    }
    format = format || '';
    if (index != null) {
      return get$1(format, index, field, 'month');
    }
    var i,
      out = [];
    for (i = 0; i < 12; i++) {
      out[i] = get$1(format, i, field, 'month');
    }
    return out;
  }

  // ()
  // (5)
  // (fmt, 5)
  // (fmt)
  // (true)
  // (true, 5)
  // (true, fmt, 5)
  // (true, fmt)
  function listWeekdaysImpl(localeSorted, format, index, field) {
    if (typeof localeSorted === 'boolean') {
      if (isNumber(format)) {
        index = format;
        format = undefined;
      }
      format = format || '';
    } else {
      format = localeSorted;
      index = format;
      localeSorted = false;
      if (isNumber(format)) {
        index = format;
        format = undefined;
      }
      format = format || '';
    }
    var locale = getLocale(),
      shift = localeSorted ? locale._week.dow : 0,
      i,
      out = [];
    if (index != null) {
      return get$1(format, (index + shift) % 7, field, 'day');
    }
    for (i = 0; i < 7; i++) {
      out[i] = get$1(format, (i + shift) % 7, field, 'day');
    }
    return out;
  }
  function listMonths(format, index) {
    return listMonthsImpl(format, index, 'months');
  }
  function listMonthsShort(format, index) {
    return listMonthsImpl(format, index, 'monthsShort');
  }
  function listWeekdays(localeSorted, format, index) {
    return listWeekdaysImpl(localeSorted, format, index, 'weekdays');
  }
  function listWeekdaysShort(localeSorted, format, index) {
    return listWeekdaysImpl(localeSorted, format, index, 'weekdaysShort');
  }
  function listWeekdaysMin(localeSorted, format, index) {
    return listWeekdaysImpl(localeSorted, format, index, 'weekdaysMin');
  }
  getSetGlobalLocale('en', {
    eras: [{
      since: '0001-01-01',
      until: +Infinity,
      offset: 1,
      name: 'Anno Domini',
      narrow: 'AD',
      abbr: 'AD'
    }, {
      since: '0000-12-31',
      until: -Infinity,
      offset: 1,
      name: 'Before Christ',
      narrow: 'BC',
      abbr: 'BC'
    }],
    dayOfMonthOrdinalParse: /\d{1,2}(th|st|nd|rd)/,
    ordinal: function (number) {
      var b = number % 10,
        output = toInt(number % 100 / 10) === 1 ? 'th' : b === 1 ? 'st' : b === 2 ? 'nd' : b === 3 ? 'rd' : 'th';
      return number + output;
    }
  });

  // Side effect imports

  hooks.lang = deprecate('moment.lang is deprecated. Use moment.locale instead.', getSetGlobalLocale);
  hooks.langData = deprecate('moment.langData is deprecated. Use moment.localeData instead.', getLocale);
  var mathAbs = Math.abs;
  function abs() {
    var data = this._data;
    this._milliseconds = mathAbs(this._milliseconds);
    this._days = mathAbs(this._days);
    this._months = mathAbs(this._months);
    data.milliseconds = mathAbs(data.milliseconds);
    data.seconds = mathAbs(data.seconds);
    data.minutes = mathAbs(data.minutes);
    data.hours = mathAbs(data.hours);
    data.months = mathAbs(data.months);
    data.years = mathAbs(data.years);
    return this;
  }
  function addSubtract$1(duration, input, value, direction) {
    var other = createDuration(input, value);
    duration._milliseconds += direction * other._milliseconds;
    duration._days += direction * other._days;
    duration._months += direction * other._months;
    return duration._bubble();
  }

  // supports only 2.0-style add(1, 's') or add(duration)
  function add$1(input, value) {
    return addSubtract$1(this, input, value, 1);
  }

  // supports only 2.0-style subtract(1, 's') or subtract(duration)
  function subtract$1(input, value) {
    return addSubtract$1(this, input, value, -1);
  }
  function absCeil(number) {
    if (number < 0) {
      return Math.floor(number);
    } else {
      return Math.ceil(number);
    }
  }
  function bubble() {
    var milliseconds = this._milliseconds,
      days = this._days,
      months = this._months,
      data = this._data,
      seconds,
      minutes,
      hours,
      years,
      monthsFromDays;

    // if we have a mix of positive and negative values, bubble down first
    // check: https://github.com/moment/moment/issues/2166
    if (!(milliseconds >= 0 && days >= 0 && months >= 0 || milliseconds <= 0 && days <= 0 && months <= 0)) {
      milliseconds += absCeil(monthsToDays(months) + days) * 864e5;
      days = 0;
      months = 0;
    }

    // The following code bubbles up values, see the tests for
    // examples of what that means.
    data.milliseconds = milliseconds % 1000;
    seconds = absFloor(milliseconds / 1000);
    data.seconds = seconds % 60;
    minutes = absFloor(seconds / 60);
    data.minutes = minutes % 60;
    hours = absFloor(minutes / 60);
    data.hours = hours % 24;
    days += absFloor(hours / 24);

    // convert days to months
    monthsFromDays = absFloor(daysToMonths(days));
    months += monthsFromDays;
    days -= absCeil(monthsToDays(monthsFromDays));

    // 12 months -> 1 year
    years = absFloor(months / 12);
    months %= 12;
    data.days = days;
    data.months = months;
    data.years = years;
    return this;
  }
  function daysToMonths(days) {
    // 400 years have 146097 days (taking into account leap year rules)
    // 400 years have 12 months === 4800
    return days * 4800 / 146097;
  }
  function monthsToDays(months) {
    // the reverse of daysToMonths
    return months * 146097 / 4800;
  }
  function as(units) {
    if (!this.isValid()) {
      return NaN;
    }
    var days,
      months,
      milliseconds = this._milliseconds;
    units = normalizeUnits(units);
    if (units === 'month' || units === 'quarter' || units === 'year') {
      days = this._days + milliseconds / 864e5;
      months = this._months + daysToMonths(days);
      switch (units) {
        case 'month':
          return months;
        case 'quarter':
          return months / 3;
        case 'year':
          return months / 12;
      }
    } else {
      // handle milliseconds separately because of floating point math errors (issue #1867)
      days = this._days + Math.round(monthsToDays(this._months));
      switch (units) {
        case 'week':
          return days / 7 + milliseconds / 6048e5;
        case 'day':
          return days + milliseconds / 864e5;
        case 'hour':
          return days * 24 + milliseconds / 36e5;
        case 'minute':
          return days * 1440 + milliseconds / 6e4;
        case 'second':
          return days * 86400 + milliseconds / 1000;
        // Math.floor prevents floating point math errors here
        case 'millisecond':
          return Math.floor(days * 864e5) + milliseconds;
        default:
          throw new Error('Unknown unit ' + units);
      }
    }
  }

  // TODO: Use this.as('ms')?
  function valueOf$1() {
    if (!this.isValid()) {
      return NaN;
    }
    return this._milliseconds + this._days * 864e5 + this._months % 12 * 2592e6 + toInt(this._months / 12) * 31536e6;
  }
  function makeAs(alias) {
    return function () {
      return this.as(alias);
    };
  }
  var asMilliseconds = makeAs('ms'),
    asSeconds = makeAs('s'),
    asMinutes = makeAs('m'),
    asHours = makeAs('h'),
    asDays = makeAs('d'),
    asWeeks = makeAs('w'),
    asMonths = makeAs('M'),
    asQuarters = makeAs('Q'),
    asYears = makeAs('y');
  function clone$1() {
    return createDuration(this);
  }
  function get$2(units) {
    units = normalizeUnits(units);
    return this.isValid() ? this[units + 's']() : NaN;
  }
  function makeGetter(name) {
    return function () {
      return this.isValid() ? this._data[name] : NaN;
    };
  }
  var milliseconds = makeGetter('milliseconds'),
    seconds = makeGetter('seconds'),
    minutes = makeGetter('minutes'),
    hours = makeGetter('hours'),
    days = makeGetter('days'),
    months = makeGetter('months'),
    years = makeGetter('years');
  function weeks() {
    return absFloor(this.days() / 7);
  }
  var round = Math.round,
    thresholds = {
      ss: 44,
      // a few seconds to seconds
      s: 45,
      // seconds to minute
      m: 45,
      // minutes to hour
      h: 22,
      // hours to day
      d: 26,
      // days to month/week
      w: null,
      // weeks to month
      M: 11 // months to year
    };

  // helper function for moment.fn.from, moment.fn.fromNow, and moment.duration.fn.humanize
  function substituteTimeAgo(string, number, withoutSuffix, isFuture, locale) {
    return locale.relativeTime(number || 1, !!withoutSuffix, string, isFuture);
  }
  function relativeTime$1(posNegDuration, withoutSuffix, thresholds, locale) {
    var duration = createDuration(posNegDuration).abs(),
      seconds = round(duration.as('s')),
      minutes = round(duration.as('m')),
      hours = round(duration.as('h')),
      days = round(duration.as('d')),
      months = round(duration.as('M')),
      weeks = round(duration.as('w')),
      years = round(duration.as('y')),
      a = seconds <= thresholds.ss && ['s', seconds] || seconds < thresholds.s && ['ss', seconds] || minutes <= 1 && ['m'] || minutes < thresholds.m && ['mm', minutes] || hours <= 1 && ['h'] || hours < thresholds.h && ['hh', hours] || days <= 1 && ['d'] || days < thresholds.d && ['dd', days];
    if (thresholds.w != null) {
      a = a || weeks <= 1 && ['w'] || weeks < thresholds.w && ['ww', weeks];
    }
    a = a || months <= 1 && ['M'] || months < thresholds.M && ['MM', months] || years <= 1 && ['y'] || ['yy', years];
    a[2] = withoutSuffix;
    a[3] = +posNegDuration > 0;
    a[4] = locale;
    return substituteTimeAgo.apply(null, a);
  }

  // This function allows you to set the rounding function for relative time strings
  function getSetRelativeTimeRounding(roundingFunction) {
    if (roundingFunction === undefined) {
      return round;
    }
    if (typeof roundingFunction === 'function') {
      round = roundingFunction;
      return true;
    }
    return false;
  }

  // This function allows you to set a threshold for relative time strings
  function getSetRelativeTimeThreshold(threshold, limit) {
    if (thresholds[threshold] === undefined) {
      return false;
    }
    if (limit === undefined) {
      return thresholds[threshold];
    }
    thresholds[threshold] = limit;
    if (threshold === 's') {
      thresholds.ss = limit - 1;
    }
    return true;
  }
  function humanize(argWithSuffix, argThresholds) {
    if (!this.isValid()) {
      return this.localeData().invalidDate();
    }
    var withSuffix = false,
      th = thresholds,
      locale,
      output;
    if (typeof argWithSuffix === 'object') {
      argThresholds = argWithSuffix;
      argWithSuffix = false;
    }
    if (typeof argWithSuffix === 'boolean') {
      withSuffix = argWithSuffix;
    }
    if (typeof argThresholds === 'object') {
      th = Object.assign({}, thresholds, argThresholds);
      if (argThresholds.s != null && argThresholds.ss == null) {
        th.ss = argThresholds.s - 1;
      }
    }
    locale = this.localeData();
    output = relativeTime$1(this, !withSuffix, th, locale);
    if (withSuffix) {
      output = locale.pastFuture(+this, output);
    }
    return locale.postformat(output);
  }
  var abs$1 = Math.abs;
  function sign(x) {
    return (x > 0) - (x < 0) || +x;
  }
  function toISOString$1() {
    // for ISO strings we do not use the normal bubbling rules:
    //  * milliseconds bubble up until they become hours
    //  * days do not bubble at all
    //  * months bubble up until they become years
    // This is because there is no context-free conversion between hours and days
    // (think of clock changes)
    // and also not between days and months (28-31 days per month)
    if (!this.isValid()) {
      return this.localeData().invalidDate();
    }
    var seconds = abs$1(this._milliseconds) / 1000,
      days = abs$1(this._days),
      months = abs$1(this._months),
      minutes,
      hours,
      years,
      s,
      total = this.asSeconds(),
      totalSign,
      ymSign,
      daysSign,
      hmsSign;
    if (!total) {
      // this is the same as C#'s (Noda) and python (isodate)...
      // but not other JS (goog.date)
      return 'P0D';
    }

    // 3600 seconds -> 60 minutes -> 1 hour
    minutes = absFloor(seconds / 60);
    hours = absFloor(minutes / 60);
    seconds %= 60;
    minutes %= 60;

    // 12 months -> 1 year
    years = absFloor(months / 12);
    months %= 12;

    // inspired by https://github.com/dordille/moment-isoduration/blob/master/moment.isoduration.js
    s = seconds ? seconds.toFixed(3).replace(/\.?0+$/, '') : '';
    totalSign = total < 0 ? '-' : '';
    ymSign = sign(this._months) !== sign(total) ? '-' : '';
    daysSign = sign(this._days) !== sign(total) ? '-' : '';
    hmsSign = sign(this._milliseconds) !== sign(total) ? '-' : '';
    return totalSign + 'P' + (years ? ymSign + years + 'Y' : '') + (months ? ymSign + months + 'M' : '') + (days ? daysSign + days + 'D' : '') + (hours || minutes || seconds ? 'T' : '') + (hours ? hmsSign + hours + 'H' : '') + (minutes ? hmsSign + minutes + 'M' : '') + (seconds ? hmsSign + s + 'S' : '');
  }
  var proto$2 = Duration.prototype;
  proto$2.isValid = isValid$1;
  proto$2.abs = abs;
  proto$2.add = add$1;
  proto$2.subtract = subtract$1;
  proto$2.as = as;
  proto$2.asMilliseconds = asMilliseconds;
  proto$2.asSeconds = asSeconds;
  proto$2.asMinutes = asMinutes;
  proto$2.asHours = asHours;
  proto$2.asDays = asDays;
  proto$2.asWeeks = asWeeks;
  proto$2.asMonths = asMonths;
  proto$2.asQuarters = asQuarters;
  proto$2.asYears = asYears;
  proto$2.valueOf = valueOf$1;
  proto$2._bubble = bubble;
  proto$2.clone = clone$1;
  proto$2.get = get$2;
  proto$2.milliseconds = milliseconds;
  proto$2.seconds = seconds;
  proto$2.minutes = minutes;
  proto$2.hours = hours;
  proto$2.days = days;
  proto$2.weeks = weeks;
  proto$2.months = months;
  proto$2.years = years;
  proto$2.humanize = humanize;
  proto$2.toISOString = toISOString$1;
  proto$2.toString = toISOString$1;
  proto$2.toJSON = toISOString$1;
  proto$2.locale = locale;
  proto$2.localeData = localeData;
  proto$2.toIsoString = deprecate('toIsoString() is deprecated. Please use toISOString() instead (notice the capitals)', toISOString$1);
  proto$2.lang = lang;

  // FORMATTING

  addFormatToken('X', 0, 0, 'unix');
  addFormatToken('x', 0, 0, 'valueOf');

  // PARSING

  addRegexToken('x', matchSigned);
  addRegexToken('X', matchTimestamp);
  addParseToken('X', function (input, array, config) {
    config._d = new Date(parseFloat(input) * 1000);
  });
  addParseToken('x', function (input, array, config) {
    config._d = new Date(toInt(input));
  });

  //! moment.js

  hooks.version = '2.29.4';
  setHookCallback(createLocal);
  hooks.fn = proto;
  hooks.min = min;
  hooks.max = max;
  hooks.now = now;
  hooks.utc = createUTC;
  hooks.unix = createUnix;
  hooks.months = listMonths;
  hooks.isDate = isDate;
  hooks.locale = getSetGlobalLocale;
  hooks.invalid = createInvalid;
  hooks.duration = createDuration;
  hooks.isMoment = isMoment;
  hooks.weekdays = listWeekdays;
  hooks.parseZone = createInZone;
  hooks.localeData = getLocale;
  hooks.isDuration = isDuration;
  hooks.monthsShort = listMonthsShort;
  hooks.weekdaysMin = listWeekdaysMin;
  hooks.defineLocale = defineLocale;
  hooks.updateLocale = updateLocale;
  hooks.locales = listLocales;
  hooks.weekdaysShort = listWeekdaysShort;
  hooks.normalizeUnits = normalizeUnits;
  hooks.relativeTimeRounding = getSetRelativeTimeRounding;
  hooks.relativeTimeThreshold = getSetRelativeTimeThreshold;
  hooks.calendarFormat = getCalendarFormat;
  hooks.prototype = proto;

  // currently HTML5 input type only supports 24-hour formats
  hooks.HTML5_FMT = {
    DATETIME_LOCAL: 'YYYY-MM-DDTHH:mm',
    // <input type="datetime-local" />
    DATETIME_LOCAL_SECONDS: 'YYYY-MM-DDTHH:mm:ss',
    // <input type="datetime-local" step="1" />
    DATETIME_LOCAL_MS: 'YYYY-MM-DDTHH:mm:ss.SSS',
    // <input type="datetime-local" step="0.001" />
    DATE: 'YYYY-MM-DD',
    // <input type="date" />
    TIME: 'HH:mm',
    // <input type="time" />
    TIME_SECONDS: 'HH:mm:ss',
    // <input type="time" step="1" />
    TIME_MS: 'HH:mm:ss.SSS',
    // <input type="time" step="0.001" />
    WEEK: 'GGGG-[W]WW',
    // <input type="week" />
    MONTH: 'YYYY-MM' // <input type="month" />
  };
  return hooks;
});

/***/ }),
/* 106 */
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var map = {
	"./af": 107,
	"./af.js": 107,
	"./ar": 108,
	"./ar-dz": 109,
	"./ar-dz.js": 109,
	"./ar-kw": 110,
	"./ar-kw.js": 110,
	"./ar-ly": 111,
	"./ar-ly.js": 111,
	"./ar-ma": 112,
	"./ar-ma.js": 112,
	"./ar-sa": 113,
	"./ar-sa.js": 113,
	"./ar-tn": 114,
	"./ar-tn.js": 114,
	"./ar.js": 108,
	"./az": 115,
	"./az.js": 115,
	"./be": 116,
	"./be.js": 116,
	"./bg": 117,
	"./bg.js": 117,
	"./bm": 118,
	"./bm.js": 118,
	"./bn": 119,
	"./bn-bd": 120,
	"./bn-bd.js": 120,
	"./bn.js": 119,
	"./bo": 121,
	"./bo.js": 121,
	"./br": 122,
	"./br.js": 122,
	"./bs": 123,
	"./bs.js": 123,
	"./ca": 124,
	"./ca.js": 124,
	"./cs": 125,
	"./cs.js": 125,
	"./cv": 126,
	"./cv.js": 126,
	"./cy": 127,
	"./cy.js": 127,
	"./da": 128,
	"./da.js": 128,
	"./de": 129,
	"./de-at": 130,
	"./de-at.js": 130,
	"./de-ch": 131,
	"./de-ch.js": 131,
	"./de.js": 129,
	"./dv": 132,
	"./dv.js": 132,
	"./el": 133,
	"./el.js": 133,
	"./en-au": 134,
	"./en-au.js": 134,
	"./en-ca": 135,
	"./en-ca.js": 135,
	"./en-gb": 136,
	"./en-gb.js": 136,
	"./en-ie": 137,
	"./en-ie.js": 137,
	"./en-il": 138,
	"./en-il.js": 138,
	"./en-in": 139,
	"./en-in.js": 139,
	"./en-nz": 140,
	"./en-nz.js": 140,
	"./en-sg": 141,
	"./en-sg.js": 141,
	"./eo": 142,
	"./eo.js": 142,
	"./es": 143,
	"./es-do": 144,
	"./es-do.js": 144,
	"./es-mx": 145,
	"./es-mx.js": 145,
	"./es-us": 146,
	"./es-us.js": 146,
	"./es.js": 143,
	"./et": 147,
	"./et.js": 147,
	"./eu": 148,
	"./eu.js": 148,
	"./fa": 149,
	"./fa.js": 149,
	"./fi": 150,
	"./fi.js": 150,
	"./fil": 151,
	"./fil.js": 151,
	"./fo": 152,
	"./fo.js": 152,
	"./fr": 153,
	"./fr-ca": 154,
	"./fr-ca.js": 154,
	"./fr-ch": 155,
	"./fr-ch.js": 155,
	"./fr.js": 153,
	"./fy": 156,
	"./fy.js": 156,
	"./ga": 157,
	"./ga.js": 157,
	"./gd": 158,
	"./gd.js": 158,
	"./gl": 159,
	"./gl.js": 159,
	"./gom-deva": 160,
	"./gom-deva.js": 160,
	"./gom-latn": 161,
	"./gom-latn.js": 161,
	"./gu": 162,
	"./gu.js": 162,
	"./he": 163,
	"./he.js": 163,
	"./hi": 164,
	"./hi.js": 164,
	"./hr": 165,
	"./hr.js": 165,
	"./hu": 166,
	"./hu.js": 166,
	"./hy-am": 167,
	"./hy-am.js": 167,
	"./id": 168,
	"./id.js": 168,
	"./is": 169,
	"./is.js": 169,
	"./it": 170,
	"./it-ch": 171,
	"./it-ch.js": 171,
	"./it.js": 170,
	"./ja": 172,
	"./ja.js": 172,
	"./jv": 173,
	"./jv.js": 173,
	"./ka": 174,
	"./ka.js": 174,
	"./kk": 175,
	"./kk.js": 175,
	"./km": 176,
	"./km.js": 176,
	"./kn": 177,
	"./kn.js": 177,
	"./ko": 178,
	"./ko.js": 178,
	"./ku": 179,
	"./ku.js": 179,
	"./ky": 180,
	"./ky.js": 180,
	"./lb": 181,
	"./lb.js": 181,
	"./lo": 182,
	"./lo.js": 182,
	"./lt": 183,
	"./lt.js": 183,
	"./lv": 184,
	"./lv.js": 184,
	"./me": 185,
	"./me.js": 185,
	"./mi": 186,
	"./mi.js": 186,
	"./mk": 187,
	"./mk.js": 187,
	"./ml": 188,
	"./ml.js": 188,
	"./mn": 189,
	"./mn.js": 189,
	"./mr": 190,
	"./mr.js": 190,
	"./ms": 191,
	"./ms-my": 192,
	"./ms-my.js": 192,
	"./ms.js": 191,
	"./mt": 193,
	"./mt.js": 193,
	"./my": 194,
	"./my.js": 194,
	"./nb": 195,
	"./nb.js": 195,
	"./ne": 196,
	"./ne.js": 196,
	"./nl": 197,
	"./nl-be": 198,
	"./nl-be.js": 198,
	"./nl.js": 197,
	"./nn": 199,
	"./nn.js": 199,
	"./oc-lnc": 200,
	"./oc-lnc.js": 200,
	"./pa-in": 201,
	"./pa-in.js": 201,
	"./pl": 202,
	"./pl.js": 202,
	"./pt": 203,
	"./pt-br": 204,
	"./pt-br.js": 204,
	"./pt.js": 203,
	"./ro": 205,
	"./ro.js": 205,
	"./ru": 206,
	"./ru.js": 206,
	"./sd": 207,
	"./sd.js": 207,
	"./se": 208,
	"./se.js": 208,
	"./si": 209,
	"./si.js": 209,
	"./sk": 210,
	"./sk.js": 210,
	"./sl": 211,
	"./sl.js": 211,
	"./sq": 212,
	"./sq.js": 212,
	"./sr": 213,
	"./sr-cyrl": 214,
	"./sr-cyrl.js": 214,
	"./sr.js": 213,
	"./ss": 215,
	"./ss.js": 215,
	"./sv": 216,
	"./sv.js": 216,
	"./sw": 217,
	"./sw.js": 217,
	"./ta": 218,
	"./ta.js": 218,
	"./te": 219,
	"./te.js": 219,
	"./tet": 220,
	"./tet.js": 220,
	"./tg": 221,
	"./tg.js": 221,
	"./th": 222,
	"./th.js": 222,
	"./tk": 223,
	"./tk.js": 223,
	"./tl-ph": 224,
	"./tl-ph.js": 224,
	"./tlh": 225,
	"./tlh.js": 225,
	"./tr": 226,
	"./tr.js": 226,
	"./tzl": 227,
	"./tzl.js": 227,
	"./tzm": 228,
	"./tzm-latn": 229,
	"./tzm-latn.js": 229,
	"./tzm.js": 228,
	"./ug-cn": 230,
	"./ug-cn.js": 230,
	"./uk": 231,
	"./uk.js": 231,
	"./ur": 232,
	"./ur.js": 232,
	"./uz": 233,
	"./uz-latn": 234,
	"./uz-latn.js": 234,
	"./uz.js": 233,
	"./vi": 235,
	"./vi.js": 235,
	"./x-pseudo": 236,
	"./x-pseudo.js": 236,
	"./yo": 237,
	"./yo.js": 237,
	"./zh-cn": 238,
	"./zh-cn.js": 238,
	"./zh-hk": 239,
	"./zh-hk.js": 239,
	"./zh-mo": 240,
	"./zh-mo.js": 240,
	"./zh-tw": 241,
	"./zh-tw.js": 241
};


function webpackContext(req) {
	var id = webpackContextResolve(req);
	return __webpack_require__(id);
}
function webpackContextResolve(req) {
	if(!__webpack_require__.o(map, req)) {
		var e = new Error("Cannot find module '" + req + "'");
		e.code = 'MODULE_NOT_FOUND';
		throw e;
	}
	return map[req];
}
webpackContext.keys = function webpackContextKeys() {
	return Object.keys(map);
};
webpackContext.resolve = webpackContextResolve;
module.exports = webpackContext;
webpackContext.id = 106;

/***/ }),
/* 107 */
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Afrikaans [af]
//! author : Werner Mollentze : https://github.com/wernerm

;
(function (global, factory) {
   true ? factory(__webpack_require__(105)) : 0;
})(this, function (moment) {
  'use strict';

  //! moment.js locale configuration
  var af = moment.defineLocale('af', {
    months: 'Januarie_Februarie_Maart_April_Mei_Junie_Julie_Augustus_September_Oktober_November_Desember'.split('_'),
    monthsShort: 'Jan_Feb_Mrt_Apr_Mei_Jun_Jul_Aug_Sep_Okt_Nov_Des'.split('_'),
    weekdays: 'Sondag_Maandag_Dinsdag_Woensdag_Donderdag_Vrydag_Saterdag'.split('_'),
    weekdaysShort: 'Son_Maa_Din_Woe_Don_Vry_Sat'.split('_'),
    weekdaysMin: 'So_Ma_Di_Wo_Do_Vr_Sa'.split('_'),
    meridiemParse: /vm|nm/i,
    isPM: function (input) {
      return /^nm$/i.test(input);
    },
    meridiem: function (hours, minutes, isLower) {
      if (hours < 12) {
        return isLower ? 'vm' : 'VM';
      } else {
        return isLower ? 'nm' : 'NM';
      }
    },
    longDateFormat: {
      LT: 'HH:mm',
      LTS: 'HH:mm:ss',
      L: 'DD/MM/YYYY',
      LL: 'D MMMM YYYY',
      LLL: 'D MMMM YYYY HH:mm',
      LLLL: 'dddd, D MMMM YYYY HH:mm'
    },
    calendar: {
      sameDay: '[Vandag om] LT',
      nextDay: '[Mre om] LT',
      nextWeek: 'dddd [om] LT',
      lastDay: '[Gister om] LT',
      lastWeek: '[Laas] dddd [om] LT',
      sameElse: 'L'
    },
    relativeTime: {
      future: 'oor %s',
      past: '%s gelede',
      s: "'n paar sekondes",
      ss: '%d sekondes',
      m: "'n minuut",
      mm: '%d minute',
      h: "'n uur",
      hh: '%d ure',
      d: "'n dag",
      dd: '%d dae',
      M: "'n maand",
      MM: '%d maande',
      y: "'n jaar",
      yy: '%d jaar'
    },
    dayOfMonthOrdinalParse: /\d{1,2}(ste|de)/,
    ordinal: function (number) {
      return number + (number === 1 || number === 8 || number >= 20 ? 'ste' : 'de'); // Thanks to Joris Rling : https://github.com/jjupiter
    },
    week: {
      dow: 1,
      // Maandag is die eerste dag van die week.
      doy: 4 // Die week wat die 4de Januarie bevat is die eerste week van die jaar.
    }
  });
  return af;
});

/***/ }),
/* 108 */
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Arabic [ar]
//! author : Abdel Said: https://github.com/abdelsaid
//! author : Ahmed Elkhatib
//! author : forabi https://github.com/forabi

;
(function (global, factory) {
   true ? factory(__webpack_require__(105)) : 0;
})(this, function (moment) {
  'use strict';

  //! moment.js locale configuration
  var symbolMap = {
      1: '',
      2: '',
      3: '',
      4: '',
      5: '',
      6: '',
      7: '',
      8: '',
      9: '',
      0: ''
    },
    numberMap = {
      '': '1',
      '': '2',
      '': '3',
      '': '4',
      '': '5',
      '': '6',
      '': '7',
      '': '8',
      '': '9',
      '': '0'
    },
    pluralForm = function (n) {
      return n === 0 ? 0 : n === 1 ? 1 : n === 2 ? 2 : n % 100 >= 3 && n % 100 <= 10 ? 3 : n % 100 >= 11 ? 4 : 5;
    },
    plurals = {
      s: ['  ', ' ', ['', ''], '%d ', '%d ', '%d '],
      m: ['  ', ' ', ['', ''], '%d ', '%d ', '%d '],
      h: ['  ', ' ', ['', ''], '%d ', '%d ', '%d '],
      d: ['  ', ' ', ['', ''], '%d ', '%d ', '%d '],
      M: ['  ', ' ', ['', ''], '%d ', '%d ', '%d '],
      y: ['  ', ' ', ['', ''], '%d ', '%d ', '%d ']
    },
    pluralize = function (u) {
      return function (number, withoutSuffix, string, isFuture) {
        var f = pluralForm(number),
          str = plurals[u][pluralForm(number)];
        if (f === 2) {
          str = str[withoutSuffix ? 0 : 1];
        }
        return str.replace(/%d/i, number);
      };
    },
    months = ['', '', '', '', '', '', '', '', '', '', '', ''];
  var ar = moment.defineLocale('ar', {
    months: months,
    monthsShort: months,
    weekdays: '______'.split('_'),
    weekdaysShort: '______'.split('_'),
    weekdaysMin: '______'.split('_'),
    weekdaysParseExact: true,
    longDateFormat: {
      LT: 'HH:mm',
      LTS: 'HH:mm:ss',
      L: 'D/\u200FM/\u200FYYYY',
      LL: 'D MMMM YYYY',
      LLL: 'D MMMM YYYY HH:mm',
      LLLL: 'dddd D MMMM YYYY HH:mm'
    },
    meridiemParse: /|/,
    isPM: function (input) {
      return '' === input;
    },
    meridiem: function (hour, minute, isLower) {
      if (hour < 12) {
        return '';
      } else {
        return '';
      }
    },
    calendar: {
      sameDay: '[  ] LT',
      nextDay: '[  ] LT',
      nextWeek: 'dddd [ ] LT',
      lastDay: '[  ] LT',
      lastWeek: 'dddd [ ] LT',
      sameElse: 'L'
    },
    relativeTime: {
      future: ' %s',
      past: ' %s',
      s: pluralize('s'),
      ss: pluralize('s'),
      m: pluralize('m'),
      mm: pluralize('m'),
      h: pluralize('h'),
      hh: pluralize('h'),
      d: pluralize('d'),
      dd: pluralize('d'),
      M: pluralize('M'),
      MM: pluralize('M'),
      y: pluralize('y'),
      yy: pluralize('y')
    },
    preparse: function (string) {
      return string.replace(/[]/g, function (match) {
        return numberMap[match];
      }).replace(//g, ',');
    },
    postformat: function (string) {
      return string.replace(/\d/g, function (match) {
        return symbolMap[match];
      }).replace(/,/g, '');
    },
    week: {
      dow: 6,
      // Saturday is the first day of the week.
      doy: 12 // The week that contains Jan 12th is the first week of the year.
    }
  });
  return ar;
});

/***/ }),
/* 109 */
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Arabic (Algeria) [ar-dz]
//! author : Amine Roukh: https://github.com/Amine27
//! author : Abdel Said: https://github.com/abdelsaid
//! author : Ahmed Elkhatib
//! author : forabi https://github.com/forabi
//! author : Noureddine LOUAHEDJ : https://github.com/noureddinem

;
(function (global, factory) {
   true ? factory(__webpack_require__(105)) : 0;
})(this, function (moment) {
  'use strict';

  //! moment.js locale configuration
  var pluralForm = function (n) {
      return n === 0 ? 0 : n === 1 ? 1 : n === 2 ? 2 : n % 100 >= 3 && n % 100 <= 10 ? 3 : n % 100 >= 11 ? 4 : 5;
    },
    plurals = {
      s: ['  ', ' ', ['', ''], '%d ', '%d ', '%d '],
      m: ['  ', ' ', ['', ''], '%d ', '%d ', '%d '],
      h: ['  ', ' ', ['', ''], '%d ', '%d ', '%d '],
      d: ['  ', ' ', ['', ''], '%d ', '%d ', '%d '],
      M: ['  ', ' ', ['', ''], '%d ', '%d ', '%d '],
      y: ['  ', ' ', ['', ''], '%d ', '%d ', '%d ']
    },
    pluralize = function (u) {
      return function (number, withoutSuffix, string, isFuture) {
        var f = pluralForm(number),
          str = plurals[u][pluralForm(number)];
        if (f === 2) {
          str = str[withoutSuffix ? 0 : 1];
        }
        return str.replace(/%d/i, number);
      };
    },
    months = ['', '', '', '', '', '', '', '', '', '', '', ''];
  var arDz = moment.defineLocale('ar-dz', {
    months: months,
    monthsShort: months,
    weekdays: '______'.split('_'),
    weekdaysShort: '______'.split('_'),
    weekdaysMin: '______'.split('_'),
    weekdaysParseExact: true,
    longDateFormat: {
      LT: 'HH:mm',
      LTS: 'HH:mm:ss',
      L: 'D/\u200FM/\u200FYYYY',
      LL: 'D MMMM YYYY',
      LLL: 'D MMMM YYYY HH:mm',
      LLLL: 'dddd D MMMM YYYY HH:mm'
    },
    meridiemParse: /|/,
    isPM: function (input) {
      return '' === input;
    },
    meridiem: function (hour, minute, isLower) {
      if (hour < 12) {
        return '';
      } else {
        return '';
      }
    },
    calendar: {
      sameDay: '[  ] LT',
      nextDay: '[  ] LT',
      nextWeek: 'dddd [ ] LT',
      lastDay: '[  ] LT',
      lastWeek: 'dddd [ ] LT',
      sameElse: 'L'
    },
    relativeTime: {
      future: ' %s',
      past: ' %s',
      s: pluralize('s'),
      ss: pluralize('s'),
      m: pluralize('m'),
      mm: pluralize('m'),
      h: pluralize('h'),
      hh: pluralize('h'),
      d: pluralize('d'),
      dd: pluralize('d'),
      M: pluralize('M'),
      MM: pluralize('M'),
      y: pluralize('y'),
      yy: pluralize('y')
    },
    postformat: function (string) {
      return string.replace(/,/g, '');
    },
    week: {
      dow: 0,
      // Sunday is the first day of the week.
      doy: 4 // The week that contains Jan 4th is the first week of the year.
    }
  });
  return arDz;
});

/***/ }),
/* 110 */
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Arabic (Kuwait) [ar-kw]
//! author : Nusret Parlak: https://github.com/nusretparlak

;
(function (global, factory) {
   true ? factory(__webpack_require__(105)) : 0;
})(this, function (moment) {
  'use strict';

  //! moment.js locale configuration
  var arKw = moment.defineLocale('ar-kw', {
    months: '___________'.split('_'),
    monthsShort: '___________'.split('_'),
    weekdays: '______'.split('_'),
    weekdaysShort: '______'.split('_'),
    weekdaysMin: '______'.split('_'),
    weekdaysParseExact: true,
    longDateFormat: {
      LT: 'HH:mm',
      LTS: 'HH:mm:ss',
      L: 'DD/MM/YYYY',
      LL: 'D MMMM YYYY',
      LLL: 'D MMMM YYYY HH:mm',
      LLLL: 'dddd D MMMM YYYY HH:mm'
    },
    calendar: {
      sameDay: '[  ] LT',
      nextDay: '[  ] LT',
      nextWeek: 'dddd [ ] LT',
      lastDay: '[  ] LT',
      lastWeek: 'dddd [ ] LT',
      sameElse: 'L'
    },
    relativeTime: {
      future: ' %s',
      past: ' %s',
      s: '',
      ss: '%d ',
      m: '',
      mm: '%d ',
      h: '',
      hh: '%d ',
      d: '',
      dd: '%d ',
      M: '',
      MM: '%d ',
      y: '',
      yy: '%d '
    },
    week: {
      dow: 0,
      // Sunday is the first day of the week.
      doy: 12 // The week that contains Jan 12th is the first week of the year.
    }
  });
  return arKw;
});

/***/ }),
/* 111 */
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Arabic (Libya) [ar-ly]
//! author : Ali Hmer: https://github.com/kikoanis

;
(function (global, factory) {
   true ? factory(__webpack_require__(105)) : 0;
})(this, function (moment) {
  'use strict';

  //! moment.js locale configuration
  var symbolMap = {
      1: '1',
      2: '2',
      3: '3',
      4: '4',
      5: '5',
      6: '6',
      7: '7',
      8: '8',
      9: '9',
      0: '0'
    },
    pluralForm = function (n) {
      return n === 0 ? 0 : n === 1 ? 1 : n === 2 ? 2 : n % 100 >= 3 && n % 100 <= 10 ? 3 : n % 100 >= 11 ? 4 : 5;
    },
    plurals = {
      s: ['  ', ' ', ['', ''], '%d ', '%d ', '%d '],
      m: ['  ', ' ', ['', ''], '%d ', '%d ', '%d '],
      h: ['  ', ' ', ['', ''], '%d ', '%d ', '%d '],
      d: ['  ', ' ', ['', ''], '%d ', '%d ', '%d '],
      M: ['  ', ' ', ['', ''], '%d ', '%d ', '%d '],
      y: ['  ', ' ', ['', ''], '%d ', '%d ', '%d ']
    },
    pluralize = function (u) {
      return function (number, withoutSuffix, string, isFuture) {
        var f = pluralForm(number),
          str = plurals[u][pluralForm(number)];
        if (f === 2) {
          str = str[withoutSuffix ? 0 : 1];
        }
        return str.replace(/%d/i, number);
      };
    },
    months = ['', '', '', '', '', '', '', '', '', '', '', ''];
  var arLy = moment.defineLocale('ar-ly', {
    months: months,
    monthsShort: months,
    weekdays: '______'.split('_'),
    weekdaysShort: '______'.split('_'),
    weekdaysMin: '______'.split('_'),
    weekdaysParseExact: true,
    longDateFormat: {
      LT: 'HH:mm',
      LTS: 'HH:mm:ss',
      L: 'D/\u200FM/\u200FYYYY',
      LL: 'D MMMM YYYY',
      LLL: 'D MMMM YYYY HH:mm',
      LLLL: 'dddd D MMMM YYYY HH:mm'
    },
    meridiemParse: /|/,
    isPM: function (input) {
      return '' === input;
    },
    meridiem: function (hour, minute, isLower) {
      if (hour < 12) {
        return '';
      } else {
        return '';
      }
    },
    calendar: {
      sameDay: '[  ] LT',
      nextDay: '[  ] LT',
      nextWeek: 'dddd [ ] LT',
      lastDay: '[  ] LT',
      lastWeek: 'dddd [ ] LT',
      sameElse: 'L'
    },
    relativeTime: {
      future: ' %s',
      past: ' %s',
      s: pluralize('s'),
      ss: pluralize('s'),
      m: pluralize('m'),
      mm: pluralize('m'),
      h: pluralize('h'),
      hh: pluralize('h'),
      d: pluralize('d'),
      dd: pluralize('d'),
      M: pluralize('M'),
      MM: pluralize('M'),
      y: pluralize('y'),
      yy: pluralize('y')
    },
    preparse: function (string) {
      return string.replace(//g, ',');
    },
    postformat: function (string) {
      return string.replace(/\d/g, function (match) {
        return symbolMap[match];
      }).replace(/,/g, '');
    },
    week: {
      dow: 6,
      // Saturday is the first day of the week.
      doy: 12 // The week that contains Jan 12th is the first week of the year.
    }
  });
  return arLy;
});

/***/ }),
/* 112 */
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Arabic (Morocco) [ar-ma]
//! author : ElFadili Yassine : https://github.com/ElFadiliY
//! author : Abdel Said : https://github.com/abdelsaid

;
(function (global, factory) {
   true ? factory(__webpack_require__(105)) : 0;
})(this, function (moment) {
  'use strict';

  //! moment.js locale configuration
  var arMa = moment.defineLocale('ar-ma', {
    months: '___________'.split('_'),
    monthsShort: '___________'.split('_'),
    weekdays: '______'.split('_'),
    weekdaysShort: '______'.split('_'),
    weekdaysMin: '______'.split('_'),
    weekdaysParseExact: true,
    longDateFormat: {
      LT: 'HH:mm',
      LTS: 'HH:mm:ss',
      L: 'DD/MM/YYYY',
      LL: 'D MMMM YYYY',
      LLL: 'D MMMM YYYY HH:mm',
      LLLL: 'dddd D MMMM YYYY HH:mm'
    },
    calendar: {
      sameDay: '[  ] LT',
      nextDay: '[  ] LT',
      nextWeek: 'dddd [ ] LT',
      lastDay: '[  ] LT',
      lastWeek: 'dddd [ ] LT',
      sameElse: 'L'
    },
    relativeTime: {
      future: ' %s',
      past: ' %s',
      s: '',
      ss: '%d ',
      m: '',
      mm: '%d ',
      h: '',
      hh: '%d ',
      d: '',
      dd: '%d ',
      M: '',
      MM: '%d ',
      y: '',
      yy: '%d '
    },
    week: {
      dow: 1,
      // Monday is the first day of the week.
      doy: 4 // The week that contains Jan 4th is the first week of the year.
    }
  });
  return arMa;
});

/***/ }),
/* 113 */
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Arabic (Saudi Arabia) [ar-sa]
//! author : Suhail Alkowaileet : https://github.com/xsoh

;
(function (global, factory) {
   true ? factory(__webpack_require__(105)) : 0;
})(this, function (moment) {
  'use strict';

  //! moment.js locale configuration
  var symbolMap = {
      1: '',
      2: '',
      3: '',
      4: '',
      5: '',
      6: '',
      7: '',
      8: '',
      9: '',
      0: ''
    },
    numberMap = {
      '': '1',
      '': '2',
      '': '3',
      '': '4',
      '': '5',
      '': '6',
      '': '7',
      '': '8',
      '': '9',
      '': '0'
    };
  var arSa = moment.defineLocale('ar-sa', {
    months: '___________'.split('_'),
    monthsShort: '___________'.split('_'),
    weekdays: '______'.split('_'),
    weekdaysShort: '______'.split('_'),
    weekdaysMin: '______'.split('_'),
    weekdaysParseExact: true,
    longDateFormat: {
      LT: 'HH:mm',
      LTS: 'HH:mm:ss',
      L: 'DD/MM/YYYY',
      LL: 'D MMMM YYYY',
      LLL: 'D MMMM YYYY HH:mm',
      LLLL: 'dddd D MMMM YYYY HH:mm'
    },
    meridiemParse: /|/,
    isPM: function (input) {
      return '' === input;
    },
    meridiem: function (hour, minute, isLower) {
      if (hour < 12) {
        return '';
      } else {
        return '';
      }
    },
    calendar: {
      sameDay: '[  ] LT',
      nextDay: '[  ] LT',
      nextWeek: 'dddd [ ] LT',
      lastDay: '[  ] LT',
      lastWeek: 'dddd [ ] LT',
      sameElse: 'L'
    },
    relativeTime: {
      future: ' %s',
      past: ' %s',
      s: '',
      ss: '%d ',
      m: '',
      mm: '%d ',
      h: '',
      hh: '%d ',
      d: '',
      dd: '%d ',
      M: '',
      MM: '%d ',
      y: '',
      yy: '%d '
    },
    preparse: function (string) {
      return string.replace(/[]/g, function (match) {
        return numberMap[match];
      }).replace(//g, ',');
    },
    postformat: function (string) {
      return string.replace(/\d/g, function (match) {
        return symbolMap[match];
      }).replace(/,/g, '');
    },
    week: {
      dow: 0,
      // Sunday is the first day of the week.
      doy: 6 // The week that contains Jan 6th is the first week of the year.
    }
  });
  return arSa;
});

/***/ }),
/* 114 */
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

//! moment.js locale configuration
//! locale  :  Arabic (Tunisia) [ar-tn]
//! author : Nader Toukabri : https://github.com/naderio

;
(function (global, factory) {
   true ? factory(__webpack_require__(105)) : 0;
})(this, function (moment) {
  'use strict';

  //! moment.js locale configuration
  var arTn = moment.defineLocale('ar-tn', {
    months: '___________'.split('_'),
    monthsShort: '___________'.split('_'),
    weekdays: '______'.split('_'),
    weekdaysShort: '______'.split('_'),
    weekdaysMin: '______'.split('_'),
    weekdaysParseExact: true,
    longDateFormat: {
      LT: 'HH:mm',
      LTS: 'HH:mm:ss',
      L: 'DD/MM/YYYY',
      LL: 'D MMMM YYYY',
      LLL: 'D MMMM YYYY HH:mm',
      LLLL: 'dddd D MMMM YYYY HH:mm'
    },
    calendar: {
      sameDay: '[  ] LT',
      nextDay: '[  ] LT',
      nextWeek: 'dddd [ ] LT',
      lastDay: '[  ] LT',
      lastWeek: 'dddd [ ] LT',
      sameElse: 'L'
    },
    relativeTime: {
      future: ' %s',
      past: ' %s',
      s: '',
      ss: '%d ',
      m: '',
      mm: '%d ',
      h: '',
      hh: '%d ',
      d: '',
      dd: '%d ',
      M: '',
      MM: '%d ',
      y: '',
      yy: '%d '
    },
    week: {
      dow: 1,
      // Monday is the first day of the week.
      doy: 4 // The week that contains Jan 4th is the first week of the year.
    }
  });
  return arTn;
});

/***/ }),
/* 115 */
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Azerbaijani [az]
//! author : topchiyev : https://github.com/topchiyev

;
(function (global, factory) {
   true ? factory(__webpack_require__(105)) : 0;
})(this, function (moment) {
  'use strict';

  //! moment.js locale configuration
  var suffixes = {
    1: '-inci',
    5: '-inci',
    8: '-inci',
    70: '-inci',
    80: '-inci',
    2: '-nci',
    7: '-nci',
    20: '-nci',
    50: '-nci',
    3: '-nc',
    4: '-nc',
    100: '-nc',
    6: '-nc',
    9: '-uncu',
    10: '-uncu',
    30: '-uncu',
    60: '-nc',
    90: '-nc'
  };
  var az = moment.defineLocale('az', {
    months: 'yanvar_fevral_mart_aprel_may_iyun_iyul_avqust_sentyabr_oktyabr_noyabr_dekabr'.split('_'),
    monthsShort: 'yan_fev_mar_apr_may_iyn_iyl_avq_sen_okt_noy_dek'.split('_'),
    weekdays: 'Bazar_Bazar ertsi_rnb axam_rnb_Cm axam_Cm_nb'.split('_'),
    weekdaysShort: 'Baz_BzE_Ax_r_CAx_Cm_n'.split('_'),
    weekdaysMin: 'Bz_BE_A__CA_C_'.split('_'),
    weekdaysParseExact: true,
    longDateFormat: {
      LT: 'HH:mm',
      LTS: 'HH:mm:ss',
      L: 'DD.MM.YYYY',
      LL: 'D MMMM YYYY',
      LLL: 'D MMMM YYYY HH:mm',
      LLLL: 'dddd, D MMMM YYYY HH:mm'
    },
    calendar: {
      sameDay: '[bugn saat] LT',
      nextDay: '[sabah saat] LT',
      nextWeek: '[gln hft] dddd [saat] LT',
      lastDay: '[dnn] LT',
      lastWeek: '[ken hft] dddd [saat] LT',
      sameElse: 'L'
    },
    relativeTime: {
      future: '%s sonra',
      past: '%s vvl',
      s: 'bir ne saniy',
      ss: '%d saniy',
      m: 'bir dqiq',
      mm: '%d dqiq',
      h: 'bir saat',
      hh: '%d saat',
      d: 'bir gn',
      dd: '%d gn',
      M: 'bir ay',
      MM: '%d ay',
      y: 'bir il',
      yy: '%d il'
    },
    meridiemParse: /gec|shr|gndz|axam/,
    isPM: function (input) {
      return /^(gndz|axam)$/.test(input);
    },
    meridiem: function (hour, minute, isLower) {
      if (hour < 4) {
        return 'gec';
      } else if (hour < 12) {
        return 'shr';
      } else if (hour < 17) {
        return 'gndz';
      } else {
        return 'axam';
      }
    },
    dayOfMonthOrdinalParse: /\d{1,2}-(nc|inci|nci|nc|nc|uncu)/,
    ordinal: function (number) {
      if (number === 0) {
        // special case for zero
        return number + '-nc';
      }
      var a = number % 10,
        b = number % 100 - a,
        c = number >= 100 ? 100 : null;
      return number + (suffixes[a] || suffixes[b] || suffixes[c]);
    },
    week: {
      dow: 1,
      // Monday is the first day of the week.
      doy: 7 // The week that contains Jan 7th is the first week of the year.
    }
  });
  return az;
});

/***/ }),
/* 116 */
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Belarusian [be]
//! author : Dmitry Demidov : https://github.com/demidov91
//! author: Praleska: http://praleska.pro/
//! Author : Menelion Elensle : https://github.com/Oire

;
(function (global, factory) {
   true ? factory(__webpack_require__(105)) : 0;
})(this, function (moment) {
  'use strict';

  //! moment.js locale configuration
  function plural(word, num) {
    var forms = word.split('_');
    return num % 10 === 1 && num % 100 !== 11 ? forms[0] : num % 10 >= 2 && num % 10 <= 4 && (num % 100 < 10 || num % 100 >= 20) ? forms[1] : forms[2];
  }
  function relativeTimeWithPlural(number, withoutSuffix, key) {
    var format = {
      ss: withoutSuffix ? '__' : '__',
      mm: withoutSuffix ? '__' : '__',
      hh: withoutSuffix ? '__' : '__',
      dd: '__',
      MM: '__',
      yy: '__'
    };
    if (key === 'm') {
      return withoutSuffix ? '' : '';
    } else if (key === 'h') {
      return withoutSuffix ? '' : '';
    } else {
      return number + ' ' + plural(format[key], +number);
    }
  }
  var be = moment.defineLocale('be', {
    months: {
      format: '___________'.split('_'),
      standalone: '___________'.split('_')
    },
    monthsShort: '___________'.split('_'),
    weekdays: {
      format: '______'.split('_'),
      standalone: '______'.split('_'),
      isFormat: /\[ ?[] ?(?:|)? ?\] ?dddd/
    },
    weekdaysShort: '______'.split('_'),
    weekdaysMin: '______'.split('_'),
    longDateFormat: {
      LT: 'HH:mm',
      LTS: 'HH:mm:ss',
      L: 'DD.MM.YYYY',
      LL: 'D MMMM YYYY .',
      LLL: 'D MMMM YYYY ., HH:mm',
      LLLL: 'dddd, D MMMM YYYY ., HH:mm'
    },
    calendar: {
      sameDay: '[ ] LT',
      nextDay: '[ ] LT',
      lastDay: '[ ] LT',
      nextWeek: function () {
        return '[] dddd [] LT';
      },
      lastWeek: function () {
        switch (this.day()) {
          case 0:
          case 3:
          case 5:
          case 6:
            return '[ ] dddd [] LT';
          case 1:
          case 2:
          case 4:
            return '[ ] dddd [] LT';
        }
      },
      sameElse: 'L'
    },
    relativeTime: {
      future: ' %s',
      past: '%s ',
      s: ' ',
      m: relativeTimeWithPlural,
      mm: relativeTimeWithPlural,
      h: relativeTimeWithPlural,
      hh: relativeTimeWithPlural,
      d: '',
      dd: relativeTimeWithPlural,
      M: '',
      MM: relativeTimeWithPlural,
      y: '',
      yy: relativeTimeWithPlural
    },
    meridiemParse: /|||/,
    isPM: function (input) {
      return /^(|)$/.test(input);
    },
    meridiem: function (hour, minute, isLower) {
      if (hour < 4) {
        return '';
      } else if (hour < 12) {
        return '';
      } else if (hour < 17) {
        return '';
      } else {
        return '';
      }
    },
    dayOfMonthOrdinalParse: /\d{1,2}-(||)/,
    ordinal: function (number, period) {
      switch (period) {
        case 'M':
        case 'd':
        case 'DDD':
        case 'w':
        case 'W':
          return (number % 10 === 2 || number % 10 === 3) && number % 100 !== 12 && number % 100 !== 13 ? number + '-' : number + '-';
        case 'D':
          return number + '-';
        default:
          return number;
      }
    },
    week: {
      dow: 1,
      // Monday is the first day of the week.
      doy: 7 // The week that contains Jan 7th is the first week of the year.
    }
  });
  return be;
});

/***/ }),
/* 117 */
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Bulgarian [bg]
//! author : Krasen Borisov : https://github.com/kraz

;
(function (global, factory) {
   true ? factory(__webpack_require__(105)) : 0;
})(this, function (moment) {
  'use strict';

  //! moment.js locale configuration
  var bg = moment.defineLocale('bg', {
    months: '___________'.split('_'),
    monthsShort: '___________'.split('_'),
    weekdays: '______'.split('_'),
    weekdaysShort: '______'.split('_'),
    weekdaysMin: '______'.split('_'),
    longDateFormat: {
      LT: 'H:mm',
      LTS: 'H:mm:ss',
      L: 'D.MM.YYYY',
      LL: 'D MMMM YYYY',
      LLL: 'D MMMM YYYY H:mm',
      LLLL: 'dddd, D MMMM YYYY H:mm'
    },
    calendar: {
      sameDay: '[ ] LT',
      nextDay: '[ ] LT',
      nextWeek: 'dddd [] LT',
      lastDay: '[ ] LT',
      lastWeek: function () {
        switch (this.day()) {
          case 0:
          case 3:
          case 6:
            return '[] dddd [] LT';
          case 1:
          case 2:
          case 4:
          case 5:
            return '[] dddd [] LT';
        }
      },
      sameElse: 'L'
    },
    relativeTime: {
      future: ' %s',
      past: ' %s',
      s: ' ',
      ss: '%d ',
      m: '',
      mm: '%d ',
      h: '',
      hh: '%d ',
      d: '',
      dd: '%d ',
      w: '',
      ww: '%d ',
      M: '',
      MM: '%d ',
      y: '',
      yy: '%d '
    },
    dayOfMonthOrdinalParse: /\d{1,2}-(|||||)/,
    ordinal: function (number) {
      var lastDigit = number % 10,
        last2Digits = number % 100;
      if (number === 0) {
        return number + '-';
      } else if (last2Digits === 0) {
        return number + '-';
      } else if (last2Digits > 10 && last2Digits < 20) {
        return number + '-';
      } else if (lastDigit === 1) {
        return number + '-';
      } else if (lastDigit === 2) {
        return number + '-';
      } else if (lastDigit === 7 || lastDigit === 8) {
        return number + '-';
      } else {
        return number + '-';
      }
    },
    week: {
      dow: 1,
      // Monday is the first day of the week.
      doy: 7 // The week that contains Jan 7th is the first week of the year.
    }
  });
  return bg;
});

/***/ }),
/* 118 */
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Bambara [bm]
//! author : Estelle Comment : https://github.com/estellecomment

;
(function (global, factory) {
   true ? factory(__webpack_require__(105)) : 0;
})(this, function (moment) {
  'use strict';

  //! moment.js locale configuration
  var bm = moment.defineLocale('bm', {
    months: 'Zanwuyekalo_Fewuruyekalo_Marisikalo_Awirilikalo_Mkalo_Zuwnkalo_Zuluyekalo_Utikalo_Stanburukalo_kutburukalo_Nowanburukalo_Desanburukalo'.split('_'),
    monthsShort: 'Zan_Few_Mar_Awi_M_Zuw_Zul_Uti_St_ku_Now_Des'.split('_'),
    weekdays: 'Kari_Ntnn_Tarata_Araba_Alamisa_Juma_Sibiri'.split('_'),
    weekdaysShort: 'Kar_Nt_Tar_Ara_Ala_Jum_Sib'.split('_'),
    weekdaysMin: 'Ka_Nt_Ta_Ar_Al_Ju_Si'.split('_'),
    longDateFormat: {
      LT: 'HH:mm',
      LTS: 'HH:mm:ss',
      L: 'DD/MM/YYYY',
      LL: 'MMMM [tile] D [san] YYYY',
      LLL: 'MMMM [tile] D [san] YYYY [lr] HH:mm',
      LLLL: 'dddd MMMM [tile] D [san] YYYY [lr] HH:mm'
    },
    calendar: {
      sameDay: '[Bi lr] LT',
      nextDay: '[Sini lr] LT',
      nextWeek: 'dddd [don lr] LT',
      lastDay: '[Kunu lr] LT',
      lastWeek: 'dddd [tmnen lr] LT',
      sameElse: 'L'
    },
    relativeTime: {
      future: '%s kn',
      past: 'a b %s b',
      s: 'sanga dama dama',
      ss: 'sekondi %d',
      m: 'miniti kelen',
      mm: 'miniti %d',
      h: 'lr kelen',
      hh: 'lr %d',
      d: 'tile kelen',
      dd: 'tile %d',
      M: 'kalo kelen',
      MM: 'kalo %d',
      y: 'san kelen',
      yy: 'san %d'
    },
    week: {
      dow: 1,
      // Monday is the first day of the week.
      doy: 4 // The week that contains Jan 4th is the first week of the year.
    }
  });
  return bm;
});

/***/ }),
/* 119 */
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Bengali [bn]
//! author : Kaushik Gandhi : https://github.com/kaushikgandhi

;
(function (global, factory) {
   true ? factory(__webpack_require__(105)) : 0;
})(this, function (moment) {
  'use strict';

  //! moment.js locale configuration
  var symbolMap = {
      1: '',
      2: '',
      3: '',
      4: '',
      5: '',
      6: '',
      7: '',
      8: '',
      9: '',
      0: ''
    },
    numberMap = {
      '': '1',
      '': '2',
      '': '3',
      '': '4',
      '': '5',
      '': '6',
      '': '7',
      '': '8',
      '': '9',
      '': '0'
    };
  var bn = moment.defineLocale('bn', {
    months: '___________'.split('_'),
    monthsShort: '___________'.split('_'),
    weekdays: '______'.split('_'),
    weekdaysShort: '______'.split('_'),
    weekdaysMin: '______'.split('_'),
    longDateFormat: {
      LT: 'A h:mm ',
      LTS: 'A h:mm:ss ',
      L: 'DD/MM/YYYY',
      LL: 'D MMMM YYYY',
      LLL: 'D MMMM YYYY, A h:mm ',
      LLLL: 'dddd, D MMMM YYYY, A h:mm '
    },
    calendar: {
      sameDay: '[] LT',
      nextDay: '[] LT',
      nextWeek: 'dddd, LT',
      lastDay: '[] LT',
      lastWeek: '[] dddd, LT',
      sameElse: 'L'
    },
    relativeTime: {
      future: '%s ',
      past: '%s ',
      s: ' ',
      ss: '%d ',
      m: ' ',
      mm: '%d ',
      h: ' ',
      hh: '%d ',
      d: ' ',
      dd: '%d ',
      M: ' ',
      MM: '%d ',
      y: ' ',
      yy: '%d '
    },
    preparse: function (string) {
      return string.replace(/[]/g, function (match) {
        return numberMap[match];
      });
    },
    postformat: function (string) {
      return string.replace(/\d/g, function (match) {
        return symbolMap[match];
      });
    },
    meridiemParse: /||||/,
    meridiemHour: function (hour, meridiem) {
      if (hour === 12) {
        hour = 0;
      }
      if (meridiem === '' && hour >= 4 || meridiem === '' && hour < 5 || meridiem === '') {
        return hour + 12;
      } else {
        return hour;
      }
    },
    meridiem: function (hour, minute, isLower) {
      if (hour < 4) {
        return '';
      } else if (hour < 10) {
        return '';
      } else if (hour < 17) {
        return '';
      } else if (hour < 20) {
        return '';
      } else {
        return '';
      }
    },
    week: {
      dow: 0,
      // Sunday is the first day of the week.
      doy: 6 // The week that contains Jan 6th is the first week of the year.
    }
  });
  return bn;
});

/***/ }),
/* 120 */
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Bengali (Bangladesh) [bn-bd]
//! author : Asraf Hossain Patoary : https://github.com/ashwoolford

;
(function (global, factory) {
   true ? factory(__webpack_require__(105)) : 0;
})(this, function (moment) {
  'use strict';

  //! moment.js locale configuration
  var symbolMap = {
      1: '',
      2: '',
      3: '',
      4: '',
      5: '',
      6: '',
      7: '',
      8: '',
      9: '',
      0: ''
    },
    numberMap = {
      '': '1',
      '': '2',
      '': '3',
      '': '4',
      '': '5',
      '': '6',
      '': '7',
      '': '8',
      '': '9',
      '': '0'
    };
  var bnBd = moment.defineLocale('bn-bd', {
    months: '___________'.split('_'),
    monthsShort: '___________'.split('_'),
    weekdays: '______'.split('_'),
    weekdaysShort: '______'.split('_'),
    weekdaysMin: '______'.split('_'),
    longDateFormat: {
      LT: 'A h:mm ',
      LTS: 'A h:mm:ss ',
      L: 'DD/MM/YYYY',
      LL: 'D MMMM YYYY',
      LLL: 'D MMMM YYYY, A h:mm ',
      LLLL: 'dddd, D MMMM YYYY, A h:mm '
    },
    calendar: {
      sameDay: '[] LT',
      nextDay: '[] LT',
      nextWeek: 'dddd, LT',
      lastDay: '[] LT',
      lastWeek: '[] dddd, LT',
      sameElse: 'L'
    },
    relativeTime: {
      future: '%s ',
      past: '%s ',
      s: ' ',
      ss: '%d ',
      m: ' ',
      mm: '%d ',
      h: ' ',
      hh: '%d ',
      d: ' ',
      dd: '%d ',
      M: ' ',
      MM: '%d ',
      y: ' ',
      yy: '%d '
    },
    preparse: function (string) {
      return string.replace(/[]/g, function (match) {
        return numberMap[match];
      });
    },
    postformat: function (string) {
      return string.replace(/\d/g, function (match) {
        return symbolMap[match];
      });
    },
    meridiemParse: /||||||/,
    meridiemHour: function (hour, meridiem) {
      if (hour === 12) {
        hour = 0;
      }
      if (meridiem === '') {
        return hour < 4 ? hour : hour + 12;
      } else if (meridiem === '') {
        return hour;
      } else if (meridiem === '') {
        return hour;
      } else if (meridiem === '') {
        return hour >= 3 ? hour : hour + 12;
      } else if (meridiem === '') {
        return hour + 12;
      } else if (meridiem === '') {
        return hour + 12;
      }
    },
    meridiem: function (hour, minute, isLower) {
      if (hour < 4) {
        return '';
      } else if (hour < 6) {
        return '';
      } else if (hour < 12) {
        return '';
      } else if (hour < 15) {
        return '';
      } else if (hour < 18) {
        return '';
      } else if (hour < 20) {
        return '';
      } else {
        return '';
      }
    },
    week: {
      dow: 0,
      // Sunday is the first day of the week.
      doy: 6 // The week that contains Jan 6th is the first week of the year.
    }
  });
  return bnBd;
});

/***/ }),
/* 121 */
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Tibetan [bo]
//! author : Thupten N. Chakrishar : https://github.com/vajradog

;
(function (global, factory) {
   true ? factory(__webpack_require__(105)) : 0;
})(this, function (moment) {
  'use strict';

  //! moment.js locale configuration
  var symbolMap = {
      1: '',
      2: '',
      3: '',
      4: '',
      5: '',
      6: '',
      7: '',
      8: '',
      9: '',
      0: ''
    },
    numberMap = {
      '': '1',
      '': '2',
      '': '3',
      '': '4',
      '': '5',
      '': '6',
      '': '7',
      '': '8',
      '': '9',
      '': '0'
    };
  var bo = moment.defineLocale('bo', {
    months: '___________'.split('_'),
    monthsShort: '1_2_3_4_5_6_7_8_9_10_11_12'.split('_'),
    monthsShortRegex: /^(\d{1,2})/,
    monthsParseExact: true,
    weekdays: '______'.split('_'),
    weekdaysShort: '______'.split('_'),
    weekdaysMin: '______'.split('_'),
    longDateFormat: {
      LT: 'A h:mm',
      LTS: 'A h:mm:ss',
      L: 'DD/MM/YYYY',
      LL: 'D MMMM YYYY',
      LLL: 'D MMMM YYYY, A h:mm',
      LLLL: 'dddd, D MMMM YYYY, A h:mm'
    },
    calendar: {
      sameDay: '[] LT',
      nextDay: '[] LT',
      nextWeek: '[], LT',
      lastDay: '[] LT',
      lastWeek: '[] dddd, LT',
      sameElse: 'L'
    },
    relativeTime: {
      future: '%s ',
      past: '%s ',
      s: '',
      ss: '%d ',
      m: '',
      mm: '%d ',
      h: '',
      hh: '%d ',
      d: '',
      dd: '%d ',
      M: '',
      MM: '%d ',
      y: '',
      yy: '%d '
    },
    preparse: function (string) {
      return string.replace(/[]/g, function (match) {
        return numberMap[match];
      });
    },
    postformat: function (string) {
      return string.replace(/\d/g, function (match) {
        return symbolMap[match];
      });
    },
    meridiemParse: /||||/,
    meridiemHour: function (hour, meridiem) {
      if (hour === 12) {
        hour = 0;
      }
      if (meridiem === '' && hour >= 4 || meridiem === '' && hour < 5 || meridiem === '') {
        return hour + 12;
      } else {
        return hour;
      }
    },
    meridiem: function (hour, minute, isLower) {
      if (hour < 4) {
        return '';
      } else if (hour < 10) {
        return '';
      } else if (hour < 17) {
        return '';
      } else if (hour < 20) {
        return '';
      } else {
        return '';
      }
    },
    week: {
      dow: 0,
      // Sunday is the first day of the week.
      doy: 6 // The week that contains Jan 6th is the first week of the year.
    }
  });
  return bo;
});

/***/ }),
/* 122 */
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Breton [br]
//! author : Jean-Baptiste Le Duigou : https://github.com/jbleduigou

;
(function (global, factory) {
   true ? factory(__webpack_require__(105)) : 0;
})(this, function (moment) {
  'use strict';

  //! moment.js locale configuration
  function relativeTimeWithMutation(number, withoutSuffix, key) {
    var format = {
      mm: 'munutenn',
      MM: 'miz',
      dd: 'devezh'
    };
    return number + ' ' + mutation(format[key], number);
  }
  function specialMutationForYears(number) {
    switch (lastNumber(number)) {
      case 1:
      case 3:
      case 4:
      case 5:
      case 9:
        return number + ' bloaz';
      default:
        return number + ' vloaz';
    }
  }
  function lastNumber(number) {
    if (number > 9) {
      return lastNumber(number % 10);
    }
    return number;
  }
  function mutation(text, number) {
    if (number === 2) {
      return softMutation(text);
    }
    return text;
  }
  function softMutation(text) {
    var mutationTable = {
      m: 'v',
      b: 'v',
      d: 'z'
    };
    if (mutationTable[text.charAt(0)] === undefined) {
      return text;
    }
    return mutationTable[text.charAt(0)] + text.substring(1);
  }
  var monthsParse = [/^gen/i, /^c[\']hwe/i, /^meu/i, /^ebr/i, /^mae/i, /^(mez|eve)/i, /^gou/i, /^eos/i, /^gwe/i, /^her/i, /^du/i, /^ker/i],
    monthsRegex = /^(genver|c[\']hwevrer|meurzh|ebrel|mae|mezheven|gouere|eost|gwengolo|here|du|kerzu|gen|c[\']hwe|meu|ebr|mae|eve|gou|eos|gwe|her|du|ker)/i,
    monthsStrictRegex = /^(genver|c[\']hwevrer|meurzh|ebrel|mae|mezheven|gouere|eost|gwengolo|here|du|kerzu)/i,
    monthsShortStrictRegex = /^(gen|c[\']hwe|meu|ebr|mae|eve|gou|eos|gwe|her|du|ker)/i,
    fullWeekdaysParse = [/^sul/i, /^lun/i, /^meurzh/i, /^merc[\']her/i, /^yaou/i, /^gwener/i, /^sadorn/i],
    shortWeekdaysParse = [/^Sul/i, /^Lun/i, /^Meu/i, /^Mer/i, /^Yao/i, /^Gwe/i, /^Sad/i],
    minWeekdaysParse = [/^Su/i, /^Lu/i, /^Me([^r]|$)/i, /^Mer/i, /^Ya/i, /^Gw/i, /^Sa/i];
  var br = moment.defineLocale('br', {
    months: 'Genver_Chwevrer_Meurzh_Ebrel_Mae_Mezheven_Gouere_Eost_Gwengolo_Here_Du_Kerzu'.split('_'),
    monthsShort: 'Gen_Chwe_Meu_Ebr_Mae_Eve_Gou_Eos_Gwe_Her_Du_Ker'.split('_'),
    weekdays: 'Sul_Lun_Meurzh_Mercher_Yaou_Gwener_Sadorn'.split('_'),
    weekdaysShort: 'Sul_Lun_Meu_Mer_Yao_Gwe_Sad'.split('_'),
    weekdaysMin: 'Su_Lu_Me_Mer_Ya_Gw_Sa'.split('_'),
    weekdaysParse: minWeekdaysParse,
    fullWeekdaysParse: fullWeekdaysParse,
    shortWeekdaysParse: shortWeekdaysParse,
    minWeekdaysParse: minWeekdaysParse,
    monthsRegex: monthsRegex,
    monthsShortRegex: monthsRegex,
    monthsStrictRegex: monthsStrictRegex,
    monthsShortStrictRegex: monthsShortStrictRegex,
    monthsParse: monthsParse,
    longMonthsParse: monthsParse,
    shortMonthsParse: monthsParse,
    longDateFormat: {
      LT: 'HH:mm',
      LTS: 'HH:mm:ss',
      L: 'DD/MM/YYYY',
      LL: 'D [a viz] MMMM YYYY',
      LLL: 'D [a viz] MMMM YYYY HH:mm',
      LLLL: 'dddd, D [a viz] MMMM YYYY HH:mm'
    },
    calendar: {
      sameDay: '[Hiziv da] LT',
      nextDay: '[Warchoazh da] LT',
      nextWeek: 'dddd [da] LT',
      lastDay: '[Dech da] LT',
      lastWeek: 'dddd [paset da] LT',
      sameElse: 'L'
    },
    relativeTime: {
      future: 'a-benn %s',
      past: '%s zo',
      s: 'un nebeud segondenno',
      ss: '%d eilenn',
      m: 'ur vunutenn',
      mm: relativeTimeWithMutation,
      h: 'un eur',
      hh: '%d eur',
      d: 'un devezh',
      dd: relativeTimeWithMutation,
      M: 'ur miz',
      MM: relativeTimeWithMutation,
      y: 'ur bloaz',
      yy: specialMutationForYears
    },
    dayOfMonthOrdinalParse: /\d{1,2}(a|vet)/,
    ordinal: function (number) {
      var output = number === 1 ? 'a' : 'vet';
      return number + output;
    },
    week: {
      dow: 1,
      // Monday is the first day of the week.
      doy: 4 // The week that contains Jan 4th is the first week of the year.
    },
    meridiemParse: /a.m.|g.m./,
    // goude merenn | a-raok merenn
    isPM: function (token) {
      return token === 'g.m.';
    },
    meridiem: function (hour, minute, isLower) {
      return hour < 12 ? 'a.m.' : 'g.m.';
    }
  });
  return br;
});

/***/ }),
/* 123 */
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Bosnian [bs]
//! author : Nedim Cholich : https://github.com/frontyard
//! based on (hr) translation by Bojan Markovi

;
(function (global, factory) {
   true ? factory(__webpack_require__(105)) : 0;
})(this, function (moment) {
  'use strict';

  //! moment.js locale configuration
  function translate(number, withoutSuffix, key) {
    var result = number + ' ';
    switch (key) {
      case 'ss':
        if (number === 1) {
          result += 'sekunda';
        } else if (number === 2 || number === 3 || number === 4) {
          result += 'sekunde';
        } else {
          result += 'sekundi';
        }
        return result;
      case 'm':
        return withoutSuffix ? 'jedna minuta' : 'jedne minute';
      case 'mm':
        if (number === 1) {
          result += 'minuta';
        } else if (number === 2 || number === 3 || number === 4) {
          result += 'minute';
        } else {
          result += 'minuta';
        }
        return result;
      case 'h':
        return withoutSuffix ? 'jedan sat' : 'jednog sata';
      case 'hh':
        if (number === 1) {
          result += 'sat';
        } else if (number === 2 || number === 3 || number === 4) {
          result += 'sata';
        } else {
          result += 'sati';
        }
        return result;
      case 'dd':
        if (number === 1) {
          result += 'dan';
        } else {
          result += 'dana';
        }
        return result;
      case 'MM':
        if (number === 1) {
          result += 'mjesec';
        } else if (number === 2 || number === 3 || number === 4) {
          result += 'mjeseca';
        } else {
          result += 'mjeseci';
        }
        return result;
      case 'yy':
        if (number === 1) {
          result += 'godina';
        } else if (number === 2 || number === 3 || number === 4) {
          result += 'godine';
        } else {
          result += 'godina';
        }
        return result;
    }
  }
  var bs = moment.defineLocale('bs', {
    months: 'januar_februar_mart_april_maj_juni_juli_august_septembar_oktobar_novembar_decembar'.split('_'),
    monthsShort: 'jan._feb._mar._apr._maj._jun._jul._aug._sep._okt._nov._dec.'.split('_'),
    monthsParseExact: true,
    weekdays: 'nedjelja_ponedjeljak_utorak_srijeda_etvrtak_petak_subota'.split('_'),
    weekdaysShort: 'ned._pon._uto._sri._et._pet._sub.'.split('_'),
    weekdaysMin: 'ne_po_ut_sr_e_pe_su'.split('_'),
    weekdaysParseExact: true,
    longDateFormat: {
      LT: 'H:mm',
      LTS: 'H:mm:ss',
      L: 'DD.MM.YYYY',
      LL: 'D. MMMM YYYY',
      LLL: 'D. MMMM YYYY H:mm',
      LLLL: 'dddd, D. MMMM YYYY H:mm'
    },
    calendar: {
      sameDay: '[danas u] LT',
      nextDay: '[sutra u] LT',
      nextWeek: function () {
        switch (this.day()) {
          case 0:
            return '[u] [nedjelju] [u] LT';
          case 3:
            return '[u] [srijedu] [u] LT';
          case 6:
            return '[u] [subotu] [u] LT';
          case 1:
          case 2:
          case 4:
          case 5:
            return '[u] dddd [u] LT';
        }
      },
      lastDay: '[juer u] LT',
      lastWeek: function () {
        switch (this.day()) {
          case 0:
          case 3:
            return '[prolu] dddd [u] LT';
          case 6:
            return '[prole] [subote] [u] LT';
          case 1:
          case 2:
          case 4:
          case 5:
            return '[proli] dddd [u] LT';
        }
      },
      sameElse: 'L'
    },
    relativeTime: {
      future: 'za %s',
      past: 'prije %s',
      s: 'par sekundi',
      ss: translate,
      m: translate,
      mm: translate,
      h: translate,
      hh: translate,
      d: 'dan',
      dd: translate,
      M: 'mjesec',
      MM: translate,
      y: 'godinu',
      yy: translate
    },
    dayOfMonthOrdinalParse: /\d{1,2}\./,
    ordinal: '%d.',
    week: {
      dow: 1,
      // Monday is the first day of the week.
      doy: 7 // The week that contains Jan 7th is the first week of the year.
    }
  });
  return bs;
});

/***/ }),
/* 124 */
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Catalan [ca]
//! author : Juan G. Hurtado : https://github.com/juanghurtado

;
(function (global, factory) {
   true ? factory(__webpack_require__(105)) : 0;
})(this, function (moment) {
  'use strict';

  //! moment.js locale configuration
  var ca = moment.defineLocale('ca', {
    months: {
      standalone: 'gener_febrer_mar_abril_maig_juny_juliol_agost_setembre_octubre_novembre_desembre'.split('_'),
      format: "de gener_de febrer_de mar_d'abril_de maig_de juny_de juliol_d'agost_de setembre_d'octubre_de novembre_de desembre".split('_'),
      isFormat: /D[oD]?(\s)+MMMM/
    },
    monthsShort: 'gen._febr._mar_abr._maig_juny_jul._ag._set._oct._nov._des.'.split('_'),
    monthsParseExact: true,
    weekdays: 'diumenge_dilluns_dimarts_dimecres_dijous_divendres_dissabte'.split('_'),
    weekdaysShort: 'dg._dl._dt._dc._dj._dv._ds.'.split('_'),
    weekdaysMin: 'dg_dl_dt_dc_dj_dv_ds'.split('_'),
    weekdaysParseExact: true,
    longDateFormat: {
      LT: 'H:mm',
      LTS: 'H:mm:ss',
      L: 'DD/MM/YYYY',
      LL: 'D MMMM [de] YYYY',
      ll: 'D MMM YYYY',
      LLL: 'D MMMM [de] YYYY [a les] H:mm',
      lll: 'D MMM YYYY, H:mm',
      LLLL: 'dddd D MMMM [de] YYYY [a les] H:mm',
      llll: 'ddd D MMM YYYY, H:mm'
    },
    calendar: {
      sameDay: function () {
        return '[avui a ' + (this.hours() !== 1 ? 'les' : 'la') + '] LT';
      },
      nextDay: function () {
        return '[dem a ' + (this.hours() !== 1 ? 'les' : 'la') + '] LT';
      },
      nextWeek: function () {
        return 'dddd [a ' + (this.hours() !== 1 ? 'les' : 'la') + '] LT';
      },
      lastDay: function () {
        return '[ahir a ' + (this.hours() !== 1 ? 'les' : 'la') + '] LT';
      },
      lastWeek: function () {
        return '[el] dddd [passat a ' + (this.hours() !== 1 ? 'les' : 'la') + '] LT';
      },
      sameElse: 'L'
    },
    relativeTime: {
      future: "d'aqu %s",
      past: 'fa %s',
      s: 'uns segons',
      ss: '%d segons',
      m: 'un minut',
      mm: '%d minuts',
      h: 'una hora',
      hh: '%d hores',
      d: 'un dia',
      dd: '%d dies',
      M: 'un mes',
      MM: '%d mesos',
      y: 'un any',
      yy: '%d anys'
    },
    dayOfMonthOrdinalParse: /\d{1,2}(r|n|t||a)/,
    ordinal: function (number, period) {
      var output = number === 1 ? 'r' : number === 2 ? 'n' : number === 3 ? 'r' : number === 4 ? 't' : '';
      if (period === 'w' || period === 'W') {
        output = 'a';
      }
      return number + output;
    },
    week: {
      dow: 1,
      // Monday is the first day of the week.
      doy: 4 // The week that contains Jan 4th is the first week of the year.
    }
  });
  return ca;
});

/***/ }),
/* 125 */
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Czech [cs]
//! author : petrbela : https://github.com/petrbela

;
(function (global, factory) {
   true ? factory(__webpack_require__(105)) : 0;
})(this, function (moment) {
  'use strict';

  //! moment.js locale configuration
  var months = {
      format: 'leden_nor_bezen_duben_kvten_erven_ervenec_srpen_z_jen_listopad_prosinec'.split('_'),
      standalone: 'ledna_nora_bezna_dubna_kvtna_ervna_ervence_srpna_z_jna_listopadu_prosince'.split('_')
    },
    monthsShort = 'led_no_be_dub_kv_vn_vc_srp_z_j_lis_pro'.split('_'),
    monthsParse = [/^led/i, /^no/i, /^be/i, /^dub/i, /^kv/i, /^(vn|erven$|ervna)/i, /^(vc|ervenec|ervence)/i, /^srp/i, /^z/i, /^j/i, /^lis/i, /^pro/i],
    // NOTE: 'erven' is substring of 'ervenec'; therefore 'ervenec' must precede 'erven' in the regex to be fully matched.
    // Otherwise parser matches '1. ervenec' as '1. erven' + 'ec'.
    monthsRegex = /^(leden|nor|bezen|duben|kvten|ervenec|ervence|erven|ervna|srpen|z|jen|listopad|prosinec|led|no|be|dub|kv|vn|vc|srp|z|j|lis|pro)/i;
  function plural(n) {
    return n > 1 && n < 5 && ~~(n / 10) !== 1;
  }
  function translate(number, withoutSuffix, key, isFuture) {
    var result = number + ' ';
    switch (key) {
      case 's':
        // a few seconds / in a few seconds / a few seconds ago
        return withoutSuffix || isFuture ? 'pr sekund' : 'pr sekundami';
      case 'ss':
        // 9 seconds / in 9 seconds / 9 seconds ago
        if (withoutSuffix || isFuture) {
          return result + (plural(number) ? 'sekundy' : 'sekund');
        } else {
          return result + 'sekundami';
        }
      case 'm':
        // a minute / in a minute / a minute ago
        return withoutSuffix ? 'minuta' : isFuture ? 'minutu' : 'minutou';
      case 'mm':
        // 9 minutes / in 9 minutes / 9 minutes ago
        if (withoutSuffix || isFuture) {
          return result + (plural(number) ? 'minuty' : 'minut');
        } else {
          return result + 'minutami';
        }
      case 'h':
        // an hour / in an hour / an hour ago
        return withoutSuffix ? 'hodina' : isFuture ? 'hodinu' : 'hodinou';
      case 'hh':
        // 9 hours / in 9 hours / 9 hours ago
        if (withoutSuffix || isFuture) {
          return result + (plural(number) ? 'hodiny' : 'hodin');
        } else {
          return result + 'hodinami';
        }
      case 'd':
        // a day / in a day / a day ago
        return withoutSuffix || isFuture ? 'den' : 'dnem';
      case 'dd':
        // 9 days / in 9 days / 9 days ago
        if (withoutSuffix || isFuture) {
          return result + (plural(number) ? 'dny' : 'dn');
        } else {
          return result + 'dny';
        }
      case 'M':
        // a month / in a month / a month ago
        return withoutSuffix || isFuture ? 'msc' : 'mscem';
      case 'MM':
        // 9 months / in 9 months / 9 months ago
        if (withoutSuffix || isFuture) {
          return result + (plural(number) ? 'msce' : 'msc');
        } else {
          return result + 'msci';
        }
      case 'y':
        // a year / in a year / a year ago
        return withoutSuffix || isFuture ? 'rok' : 'rokem';
      case 'yy':
        // 9 years / in 9 years / 9 years ago
        if (withoutSuffix || isFuture) {
          return result + (plural(number) ? 'roky' : 'let');
        } else {
          return result + 'lety';
        }
    }
  }
  var cs = moment.defineLocale('cs', {
    months: months,
    monthsShort: monthsShort,
    monthsRegex: monthsRegex,
    monthsShortRegex: monthsRegex,
    // NOTE: 'erven' is substring of 'ervenec'; therefore 'ervenec' must precede 'erven' in the regex to be fully matched.
    // Otherwise parser matches '1. ervenec' as '1. erven' + 'ec'.
    monthsStrictRegex: /^(leden|ledna|nora|nor|bezen|bezna|duben|dubna|kvten|kvtna|ervenec|ervence|erven|ervna|srpen|srpna|z|jen|jna|listopadu|listopad|prosinec|prosince)/i,
    monthsShortStrictRegex: /^(led|no|be|dub|kv|vn|vc|srp|z|j|lis|pro)/i,
    monthsParse: monthsParse,
    longMonthsParse: monthsParse,
    shortMonthsParse: monthsParse,
    weekdays: 'nedle_pondl_ter_steda_tvrtek_ptek_sobota'.split('_'),
    weekdaysShort: 'ne_po_t_st_t_p_so'.split('_'),
    weekdaysMin: 'ne_po_t_st_t_p_so'.split('_'),
    longDateFormat: {
      LT: 'H:mm',
      LTS: 'H:mm:ss',
      L: 'DD.MM.YYYY',
      LL: 'D. MMMM YYYY',
      LLL: 'D. MMMM YYYY H:mm',
      LLLL: 'dddd D. MMMM YYYY H:mm',
      l: 'D. M. YYYY'
    },
    calendar: {
      sameDay: '[dnes v] LT',
      nextDay: '[ztra v] LT',
      nextWeek: function () {
        switch (this.day()) {
          case 0:
            return '[v nedli v] LT';
          case 1:
          case 2:
            return '[v] dddd [v] LT';
          case 3:
            return '[ve stedu v] LT';
          case 4:
            return '[ve tvrtek v] LT';
          case 5:
            return '[v ptek v] LT';
          case 6:
            return '[v sobotu v] LT';
        }
      },
      lastDay: '[vera v] LT',
      lastWeek: function () {
        switch (this.day()) {
          case 0:
            return '[minulou nedli v] LT';
          case 1:
          case 2:
            return '[minul] dddd [v] LT';
          case 3:
            return '[minulou stedu v] LT';
          case 4:
          case 5:
            return '[minul] dddd [v] LT';
          case 6:
            return '[minulou sobotu v] LT';
        }
      },
      sameElse: 'L'
    },
    relativeTime: {
      future: 'za %s',
      past: 'ped %s',
      s: translate,
      ss: translate,
      m: translate,
      mm: translate,
      h: translate,
      hh: translate,
      d: translate,
      dd: translate,
      M: translate,
      MM: translate,
      y: translate,
      yy: translate
    },
    dayOfMonthOrdinalParse: /\d{1,2}\./,
    ordinal: '%d.',
    week: {
      dow: 1,
      // Monday is the first day of the week.
      doy: 4 // The week that contains Jan 4th is the first week of the year.
    }
  });
  return cs;
});

/***/ }),
/* 126 */
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Chuvash [cv]
//! author : Anatoly Mironov : https://github.com/mirontoli

;
(function (global, factory) {
   true ? factory(__webpack_require__(105)) : 0;
})(this, function (moment) {
  'use strict';

  //! moment.js locale configuration
  var cv = moment.defineLocale('cv', {
    months: '___________'.split('_'),
    monthsShort: '___________'.split('_'),
    weekdays: '______'.split('_'),
    weekdaysShort: '______'.split('_'),
    weekdaysMin: '______'.split('_'),
    longDateFormat: {
      LT: 'HH:mm',
      LTS: 'HH:mm:ss',
      L: 'DD-MM-YYYY',
      LL: 'YYYY [] MMMM [] D[-]',
      LLL: 'YYYY [] MMMM [] D[-], HH:mm',
      LLLL: 'dddd, YYYY [] MMMM [] D[-], HH:mm'
    },
    calendar: {
      sameDay: '[] LT []',
      nextDay: '[] LT []',
      lastDay: '[] LT []',
      nextWeek: '[] dddd LT []',
      lastWeek: '[] dddd LT []',
      sameElse: 'L'
    },
    relativeTime: {
      future: function (output) {
        var affix = /$/i.exec(output) ? '' : /$/i.exec(output) ? '' : '';
        return output + affix;
      },
      past: '%s ',
      s: '- ',
      ss: '%d ',
      m: ' ',
      mm: '%d ',
      h: ' ',
      hh: '%d ',
      d: ' ',
      dd: '%d ',
      M: ' ',
      MM: '%d ',
      y: ' ',
      yy: '%d '
    },
    dayOfMonthOrdinalParse: /\d{1,2}-/,
    ordinal: '%d-',
    week: {
      dow: 1,
      // Monday is the first day of the week.
      doy: 7 // The week that contains Jan 7th is the first week of the year.
    }
  });
  return cv;
});

/***/ }),
/* 127 */
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Welsh [cy]
//! author : Robert Allen : https://github.com/robgallen
//! author : https://github.com/ryangreaves

;
(function (global, factory) {
   true ? factory(__webpack_require__(105)) : 0;
})(this, function (moment) {
  'use strict';

  //! moment.js locale configuration
  var cy = moment.defineLocale('cy', {
    months: 'Ionawr_Chwefror_Mawrth_Ebrill_Mai_Mehefin_Gorffennaf_Awst_Medi_Hydref_Tachwedd_Rhagfyr'.split('_'),
    monthsShort: 'Ion_Chwe_Maw_Ebr_Mai_Meh_Gor_Aws_Med_Hyd_Tach_Rhag'.split('_'),
    weekdays: 'Dydd Sul_Dydd Llun_Dydd Mawrth_Dydd Mercher_Dydd Iau_Dydd Gwener_Dydd Sadwrn'.split('_'),
    weekdaysShort: 'Sul_Llun_Maw_Mer_Iau_Gwe_Sad'.split('_'),
    weekdaysMin: 'Su_Ll_Ma_Me_Ia_Gw_Sa'.split('_'),
    weekdaysParseExact: true,
    // time formats are the same as en-gb
    longDateFormat: {
      LT: 'HH:mm',
      LTS: 'HH:mm:ss',
      L: 'DD/MM/YYYY',
      LL: 'D MMMM YYYY',
      LLL: 'D MMMM YYYY HH:mm',
      LLLL: 'dddd, D MMMM YYYY HH:mm'
    },
    calendar: {
      sameDay: '[Heddiw am] LT',
      nextDay: '[Yfory am] LT',
      nextWeek: 'dddd [am] LT',
      lastDay: '[Ddoe am] LT',
      lastWeek: 'dddd [diwethaf am] LT',
      sameElse: 'L'
    },
    relativeTime: {
      future: 'mewn %s',
      past: '%s yn l',
      s: 'ychydig eiliadau',
      ss: '%d eiliad',
      m: 'munud',
      mm: '%d munud',
      h: 'awr',
      hh: '%d awr',
      d: 'diwrnod',
      dd: '%d diwrnod',
      M: 'mis',
      MM: '%d mis',
      y: 'blwyddyn',
      yy: '%d flynedd'
    },
    dayOfMonthOrdinalParse: /\d{1,2}(fed|ain|af|il|ydd|ed|eg)/,
    // traditional ordinal numbers above 31 are not commonly used in colloquial Welsh
    ordinal: function (number) {
      var b = number,
        output = '',
        lookup = ['', 'af', 'il', 'ydd', 'ydd', 'ed', 'ed', 'ed', 'fed', 'fed', 'fed',
        // 1af to 10fed
        'eg', 'fed', 'eg', 'eg', 'fed', 'eg', 'eg', 'fed', 'eg', 'fed' // 11eg to 20fed
        ];
      if (b > 20) {
        if (b === 40 || b === 50 || b === 60 || b === 80 || b === 100) {
          output = 'fed'; // not 30ain, 70ain or 90ain
        } else {
          output = 'ain';
        }
      } else if (b > 0) {
        output = lookup[b];
      }
      return number + output;
    },
    week: {
      dow: 1,
      // Monday is the first day of the week.
      doy: 4 // The week that contains Jan 4th is the first week of the year.
    }
  });
  return cy;
});

/***/ }),
/* 128 */
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Danish [da]
//! author : Ulrik Nielsen : https://github.com/mrbase

;
(function (global, factory) {
   true ? factory(__webpack_require__(105)) : 0;
})(this, function (moment) {
  'use strict';

  //! moment.js locale configuration
  var da = moment.defineLocale('da', {
    months: 'januar_februar_marts_april_maj_juni_juli_august_september_oktober_november_december'.split('_'),
    monthsShort: 'jan_feb_mar_apr_maj_jun_jul_aug_sep_okt_nov_dec'.split('_'),
    weekdays: 'sndag_mandag_tirsdag_onsdag_torsdag_fredag_lrdag'.split('_'),
    weekdaysShort: 'sn_man_tir_ons_tor_fre_lr'.split('_'),
    weekdaysMin: 's_ma_ti_on_to_fr_l'.split('_'),
    longDateFormat: {
      LT: 'HH:mm',
      LTS: 'HH:mm:ss',
      L: 'DD.MM.YYYY',
      LL: 'D. MMMM YYYY',
      LLL: 'D. MMMM YYYY HH:mm',
      LLLL: 'dddd [d.] D. MMMM YYYY [kl.] HH:mm'
    },
    calendar: {
      sameDay: '[i dag kl.] LT',
      nextDay: '[i morgen kl.] LT',
      nextWeek: 'p dddd [kl.] LT',
      lastDay: '[i gr kl.] LT',
      lastWeek: '[i] dddd[s kl.] LT',
      sameElse: 'L'
    },
    relativeTime: {
      future: 'om %s',
      past: '%s siden',
      s: 'f sekunder',
      ss: '%d sekunder',
      m: 'et minut',
      mm: '%d minutter',
      h: 'en time',
      hh: '%d timer',
      d: 'en dag',
      dd: '%d dage',
      M: 'en mned',
      MM: '%d mneder',
      y: 'et r',
      yy: '%d r'
    },
    dayOfMonthOrdinalParse: /\d{1,2}\./,
    ordinal: '%d.',
    week: {
      dow: 1,
      // Monday is the first day of the week.
      doy: 4 // The week that contains Jan 4th is the first week of the year.
    }
  });
  return da;
});

/***/ }),
/* 129 */
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : German [de]
//! author : lluchs : https://github.com/lluchs
//! author: Menelion Elensle: https://github.com/Oire
//! author : Mikolaj Dadela : https://github.com/mik01aj

;
(function (global, factory) {
   true ? factory(__webpack_require__(105)) : 0;
})(this, function (moment) {
  'use strict';

  //! moment.js locale configuration
  function processRelativeTime(number, withoutSuffix, key, isFuture) {
    var format = {
      m: ['eine Minute', 'einer Minute'],
      h: ['eine Stunde', 'einer Stunde'],
      d: ['ein Tag', 'einem Tag'],
      dd: [number + ' Tage', number + ' Tagen'],
      w: ['eine Woche', 'einer Woche'],
      M: ['ein Monat', 'einem Monat'],
      MM: [number + ' Monate', number + ' Monaten'],
      y: ['ein Jahr', 'einem Jahr'],
      yy: [number + ' Jahre', number + ' Jahren']
    };
    return withoutSuffix ? format[key][0] : format[key][1];
  }
  var de = moment.defineLocale('de', {
    months: 'Januar_Februar_Mrz_April_Mai_Juni_Juli_August_September_Oktober_November_Dezember'.split('_'),
    monthsShort: 'Jan._Feb._Mrz_Apr._Mai_Juni_Juli_Aug._Sep._Okt._Nov._Dez.'.split('_'),
    monthsParseExact: true,
    weekdays: 'Sonntag_Montag_Dienstag_Mittwoch_Donnerstag_Freitag_Samstag'.split('_'),
    weekdaysShort: 'So._Mo._Di._Mi._Do._Fr._Sa.'.split('_'),
    weekdaysMin: 'So_Mo_Di_Mi_Do_Fr_Sa'.split('_'),
    weekdaysParseExact: true,
    longDateFormat: {
      LT: 'HH:mm',
      LTS: 'HH:mm:ss',
      L: 'DD.MM.YYYY',
      LL: 'D. MMMM YYYY',
      LLL: 'D. MMMM YYYY HH:mm',
      LLLL: 'dddd, D. MMMM YYYY HH:mm'
    },
    calendar: {
      sameDay: '[heute um] LT [Uhr]',
      sameElse: 'L',
      nextDay: '[morgen um] LT [Uhr]',
      nextWeek: 'dddd [um] LT [Uhr]',
      lastDay: '[gestern um] LT [Uhr]',
      lastWeek: '[letzten] dddd [um] LT [Uhr]'
    },
    relativeTime: {
      future: 'in %s',
      past: 'vor %s',
      s: 'ein paar Sekunden',
      ss: '%d Sekunden',
      m: processRelativeTime,
      mm: '%d Minuten',
      h: processRelativeTime,
      hh: '%d Stunden',
      d: processRelativeTime,
      dd: processRelativeTime,
      w: processRelativeTime,
      ww: '%d Wochen',
      M: processRelativeTime,
      MM: processRelativeTime,
      y: processRelativeTime,
      yy: processRelativeTime
    },
    dayOfMonthOrdinalParse: /\d{1,2}\./,
    ordinal: '%d.',
    week: {
      dow: 1,
      // Monday is the first day of the week.
      doy: 4 // The week that contains Jan 4th is the first week of the year.
    }
  });
  return de;
});

/***/ }),
/* 130 */
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : German (Austria) [de-at]
//! author : lluchs : https://github.com/lluchs
//! author: Menelion Elensle: https://github.com/Oire
//! author : Martin Groller : https://github.com/MadMG
//! author : Mikolaj Dadela : https://github.com/mik01aj

;
(function (global, factory) {
   true ? factory(__webpack_require__(105)) : 0;
})(this, function (moment) {
  'use strict';

  //! moment.js locale configuration
  function processRelativeTime(number, withoutSuffix, key, isFuture) {
    var format = {
      m: ['eine Minute', 'einer Minute'],
      h: ['eine Stunde', 'einer Stunde'],
      d: ['ein Tag', 'einem Tag'],
      dd: [number + ' Tage', number + ' Tagen'],
      w: ['eine Woche', 'einer Woche'],
      M: ['ein Monat', 'einem Monat'],
      MM: [number + ' Monate', number + ' Monaten'],
      y: ['ein Jahr', 'einem Jahr'],
      yy: [number + ' Jahre', number + ' Jahren']
    };
    return withoutSuffix ? format[key][0] : format[key][1];
  }
  var deAt = moment.defineLocale('de-at', {
    months: 'Jnner_Februar_Mrz_April_Mai_Juni_Juli_August_September_Oktober_November_Dezember'.split('_'),
    monthsShort: 'Jn._Feb._Mrz_Apr._Mai_Juni_Juli_Aug._Sep._Okt._Nov._Dez.'.split('_'),
    monthsParseExact: true,
    weekdays: 'Sonntag_Montag_Dienstag_Mittwoch_Donnerstag_Freitag_Samstag'.split('_'),
    weekdaysShort: 'So._Mo._Di._Mi._Do._Fr._Sa.'.split('_'),
    weekdaysMin: 'So_Mo_Di_Mi_Do_Fr_Sa'.split('_'),
    weekdaysParseExact: true,
    longDateFormat: {
      LT: 'HH:mm',
      LTS: 'HH:mm:ss',
      L: 'DD.MM.YYYY',
      LL: 'D. MMMM YYYY',
      LLL: 'D. MMMM YYYY HH:mm',
      LLLL: 'dddd, D. MMMM YYYY HH:mm'
    },
    calendar: {
      sameDay: '[heute um] LT [Uhr]',
      sameElse: 'L',
      nextDay: '[morgen um] LT [Uhr]',
      nextWeek: 'dddd [um] LT [Uhr]',
      lastDay: '[gestern um] LT [Uhr]',
      lastWeek: '[letzten] dddd [um] LT [Uhr]'
    },
    relativeTime: {
      future: 'in %s',
      past: 'vor %s',
      s: 'ein paar Sekunden',
      ss: '%d Sekunden',
      m: processRelativeTime,
      mm: '%d Minuten',
      h: processRelativeTime,
      hh: '%d Stunden',
      d: processRelativeTime,
      dd: processRelativeTime,
      w: processRelativeTime,
      ww: '%d Wochen',
      M: processRelativeTime,
      MM: processRelativeTime,
      y: processRelativeTime,
      yy: processRelativeTime
    },
    dayOfMonthOrdinalParse: /\d{1,2}\./,
    ordinal: '%d.',
    week: {
      dow: 1,
      // Monday is the first day of the week.
      doy: 4 // The week that contains Jan 4th is the first week of the year.
    }
  });
  return deAt;
});

/***/ }),
/* 131 */
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : German (Switzerland) [de-ch]
//! author : sschueller : https://github.com/sschueller

;
(function (global, factory) {
   true ? factory(__webpack_require__(105)) : 0;
})(this, function (moment) {
  'use strict';

  //! moment.js locale configuration
  function processRelativeTime(number, withoutSuffix, key, isFuture) {
    var format = {
      m: ['eine Minute', 'einer Minute'],
      h: ['eine Stunde', 'einer Stunde'],
      d: ['ein Tag', 'einem Tag'],
      dd: [number + ' Tage', number + ' Tagen'],
      w: ['eine Woche', 'einer Woche'],
      M: ['ein Monat', 'einem Monat'],
      MM: [number + ' Monate', number + ' Monaten'],
      y: ['ein Jahr', 'einem Jahr'],
      yy: [number + ' Jahre', number + ' Jahren']
    };
    return withoutSuffix ? format[key][0] : format[key][1];
  }
  var deCh = moment.defineLocale('de-ch', {
    months: 'Januar_Februar_Mrz_April_Mai_Juni_Juli_August_September_Oktober_November_Dezember'.split('_'),
    monthsShort: 'Jan._Feb._Mrz_Apr._Mai_Juni_Juli_Aug._Sep._Okt._Nov._Dez.'.split('_'),
    monthsParseExact: true,
    weekdays: 'Sonntag_Montag_Dienstag_Mittwoch_Donnerstag_Freitag_Samstag'.split('_'),
    weekdaysShort: 'So_Mo_Di_Mi_Do_Fr_Sa'.split('_'),
    weekdaysMin: 'So_Mo_Di_Mi_Do_Fr_Sa'.split('_'),
    weekdaysParseExact: true,
    longDateFormat: {
      LT: 'HH:mm',
      LTS: 'HH:mm:ss',
      L: 'DD.MM.YYYY',
      LL: 'D. MMMM YYYY',
      LLL: 'D. MMMM YYYY HH:mm',
      LLLL: 'dddd, D. MMMM YYYY HH:mm'
    },
    calendar: {
      sameDay: '[heute um] LT [Uhr]',
      sameElse: 'L',
      nextDay: '[morgen um] LT [Uhr]',
      nextWeek: 'dddd [um] LT [Uhr]',
      lastDay: '[gestern um] LT [Uhr]',
      lastWeek: '[letzten] dddd [um] LT [Uhr]'
    },
    relativeTime: {
      future: 'in %s',
      past: 'vor %s',
      s: 'ein paar Sekunden',
      ss: '%d Sekunden',
      m: processRelativeTime,
      mm: '%d Minuten',
      h: processRelativeTime,
      hh: '%d Stunden',
      d: processRelativeTime,
      dd: processRelativeTime,
      w: processRelativeTime,
      ww: '%d Wochen',
      M: processRelativeTime,
      MM: processRelativeTime,
      y: processRelativeTime,
      yy: processRelativeTime
    },
    dayOfMonthOrdinalParse: /\d{1,2}\./,
    ordinal: '%d.',
    week: {
      dow: 1,
      // Monday is the first day of the week.
      doy: 4 // The week that contains Jan 4th is the first week of the year.
    }
  });
  return deCh;
});

/***/ }),
/* 132 */
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Maldivian [dv]
//! author : Jawish Hameed : https://github.com/jawish

;
(function (global, factory) {
   true ? factory(__webpack_require__(105)) : 0;
})(this, function (moment) {
  'use strict';

  //! moment.js locale configuration
  var months = ['', '', '', '', '', '', '', '', '', '', '', ''],
    weekdays = ['', '', '', '', '', '', ''];
  var dv = moment.defineLocale('dv', {
    months: months,
    monthsShort: months,
    weekdays: weekdays,
    weekdaysShort: weekdays,
    weekdaysMin: '______'.split('_'),
    longDateFormat: {
      LT: 'HH:mm',
      LTS: 'HH:mm:ss',
      L: 'D/M/YYYY',
      LL: 'D MMMM YYYY',
      LLL: 'D MMMM YYYY HH:mm',
      LLLL: 'dddd D MMMM YYYY HH:mm'
    },
    meridiemParse: /|/,
    isPM: function (input) {
      return '' === input;
    },
    meridiem: function (hour, minute, isLower) {
      if (hour < 12) {
        return '';
      } else {
        return '';
      }
    },
    calendar: {
      sameDay: '[] LT',
      nextDay: '[] LT',
      nextWeek: 'dddd LT',
      lastDay: '[] LT',
      lastWeek: '[] dddd LT',
      sameElse: 'L'
    },
    relativeTime: {
      future: ' %s',
      past: ' %s',
      s: '',
      ss: 'd% ',
      m: '',
      mm: ' %d',
      h: '',
      hh: ' %d',
      d: '',
      dd: ' %d',
      M: '',
      MM: ' %d',
      y: '',
      yy: ' %d'
    },
    preparse: function (string) {
      return string.replace(//g, ',');
    },
    postformat: function (string) {
      return string.replace(/,/g, '');
    },
    week: {
      dow: 7,
      // Sunday is the first day of the week.
      doy: 12 // The week that contains Jan 12th is the first week of the year.
    }
  });
  return dv;
});

/***/ }),
/* 133 */
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Greek [el]
//! author : Aggelos Karalias : https://github.com/mehiel

;
(function (global, factory) {
   true ? factory(__webpack_require__(105)) : 0;
})(this, function (moment) {
  'use strict';

  //! moment.js locale configuration
  function isFunction(input) {
    return typeof Function !== 'undefined' && input instanceof Function || Object.prototype.toString.call(input) === '[object Function]';
  }
  var el = moment.defineLocale('el', {
    monthsNominativeEl: '___________'.split('_'),
    monthsGenitiveEl: '___________'.split('_'),
    months: function (momentToFormat, format) {
      if (!momentToFormat) {
        return this._monthsNominativeEl;
      } else if (typeof format === 'string' && /D/.test(format.substring(0, format.indexOf('MMMM')))) {
        // if there is a day number before 'MMMM'
        return this._monthsGenitiveEl[momentToFormat.month()];
      } else {
        return this._monthsNominativeEl[momentToFormat.month()];
      }
    },
    monthsShort: '___________'.split('_'),
    weekdays: '______'.split('_'),
    weekdaysShort: '______'.split('_'),
    weekdaysMin: '______'.split('_'),
    meridiem: function (hours, minutes, isLower) {
      if (hours > 11) {
        return isLower ? '' : '';
      } else {
        return isLower ? '' : '';
      }
    },
    isPM: function (input) {
      return (input + '').toLowerCase()[0] === '';
    },
    meridiemParse: /[]\.??\.?/i,
    longDateFormat: {
      LT: 'h:mm A',
      LTS: 'h:mm:ss A',
      L: 'DD/MM/YYYY',
      LL: 'D MMMM YYYY',
      LLL: 'D MMMM YYYY h:mm A',
      LLLL: 'dddd, D MMMM YYYY h:mm A'
    },
    calendarEl: {
      sameDay: '[ {}] LT',
      nextDay: '[ {}] LT',
      nextWeek: 'dddd [{}] LT',
      lastDay: '[ {}] LT',
      lastWeek: function () {
        switch (this.day()) {
          case 6:
            return '[ ] dddd [{}] LT';
          default:
            return '[ ] dddd [{}] LT';
        }
      },
      sameElse: 'L'
    },
    calendar: function (key, mom) {
      var output = this._calendarEl[key],
        hours = mom && mom.hours();
      if (isFunction(output)) {
        output = output.apply(mom);
      }
      return output.replace('{}', hours % 12 === 1 ? '' : '');
    },
    relativeTime: {
      future: ' %s',
      past: '%s ',
      s: ' ',
      ss: '%d ',
      m: ' ',
      mm: '%d ',
      h: ' ',
      hh: '%d ',
      d: ' ',
      dd: '%d ',
      M: ' ',
      MM: '%d ',
      y: ' ',
      yy: '%d '
    },
    dayOfMonthOrdinalParse: /\d{1,2}/,
    ordinal: '%d',
    week: {
      dow: 1,
      // Monday is the first day of the week.
      doy: 4 // The week that contains Jan 4st is the first week of the year.
    }
  });
  return el;
});

/***/ }),
/* 134 */
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : English (Australia) [en-au]
//! author : Jared Morse : https://github.com/jarcoal

;
(function (global, factory) {
   true ? factory(__webpack_require__(105)) : 0;
})(this, function (moment) {
  'use strict';

  //! moment.js locale configuration
  var enAu = moment.defineLocale('en-au', {
    months: 'January_February_March_April_May_June_July_August_September_October_November_December'.split('_'),
    monthsShort: 'Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec'.split('_'),
    weekdays: 'Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday'.split('_'),
    weekdaysShort: 'Sun_Mon_Tue_Wed_Thu_Fri_Sat'.split('_'),
    weekdaysMin: 'Su_Mo_Tu_We_Th_Fr_Sa'.split('_'),
    longDateFormat: {
      LT: 'h:mm A',
      LTS: 'h:mm:ss A',
      L: 'DD/MM/YYYY',
      LL: 'D MMMM YYYY',
      LLL: 'D MMMM YYYY h:mm A',
      LLLL: 'dddd, D MMMM YYYY h:mm A'
    },
    calendar: {
      sameDay: '[Today at] LT',
      nextDay: '[Tomorrow at] LT',
      nextWeek: 'dddd [at] LT',
      lastDay: '[Yesterday at] LT',
      lastWeek: '[Last] dddd [at] LT',
      sameElse: 'L'
    },
    relativeTime: {
      future: 'in %s',
      past: '%s ago',
      s: 'a few seconds',
      ss: '%d seconds',
      m: 'a minute',
      mm: '%d minutes',
      h: 'an hour',
      hh: '%d hours',
      d: 'a day',
      dd: '%d days',
      M: 'a month',
      MM: '%d months',
      y: 'a year',
      yy: '%d years'
    },
    dayOfMonthOrdinalParse: /\d{1,2}(st|nd|rd|th)/,
    ordinal: function (number) {
      var b = number % 10,
        output = ~~(number % 100 / 10) === 1 ? 'th' : b === 1 ? 'st' : b === 2 ? 'nd' : b === 3 ? 'rd' : 'th';
      return number + output;
    },
    week: {
      dow: 0,
      // Sunday is the first day of the week.
      doy: 4 // The week that contains Jan 4th is the first week of the year.
    }
  });
  return enAu;
});

/***/ }),
/* 135 */
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : English (Canada) [en-ca]
//! author : Jonathan Abourbih : https://github.com/jonbca

;
(function (global, factory) {
   true ? factory(__webpack_require__(105)) : 0;
})(this, function (moment) {
  'use strict';

  //! moment.js locale configuration
  var enCa = moment.defineLocale('en-ca', {
    months: 'January_February_March_April_May_June_July_August_September_October_November_December'.split('_'),
    monthsShort: 'Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec'.split('_'),
    weekdays: 'Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday'.split('_'),
    weekdaysShort: 'Sun_Mon_Tue_Wed_Thu_Fri_Sat'.split('_'),
    weekdaysMin: 'Su_Mo_Tu_We_Th_Fr_Sa'.split('_'),
    longDateFormat: {
      LT: 'h:mm A',
      LTS: 'h:mm:ss A',
      L: 'YYYY-MM-DD',
      LL: 'MMMM D, YYYY',
      LLL: 'MMMM D, YYYY h:mm A',
      LLLL: 'dddd, MMMM D, YYYY h:mm A'
    },
    calendar: {
      sameDay: '[Today at] LT',
      nextDay: '[Tomorrow at] LT',
      nextWeek: 'dddd [at] LT',
      lastDay: '[Yesterday at] LT',
      lastWeek: '[Last] dddd [at] LT',
      sameElse: 'L'
    },
    relativeTime: {
      future: 'in %s',
      past: '%s ago',
      s: 'a few seconds',
      ss: '%d seconds',
      m: 'a minute',
      mm: '%d minutes',
      h: 'an hour',
      hh: '%d hours',
      d: 'a day',
      dd: '%d days',
      M: 'a month',
      MM: '%d months',
      y: 'a year',
      yy: '%d years'
    },
    dayOfMonthOrdinalParse: /\d{1,2}(st|nd|rd|th)/,
    ordinal: function (number) {
      var b = number % 10,
        output = ~~(number % 100 / 10) === 1 ? 'th' : b === 1 ? 'st' : b === 2 ? 'nd' : b === 3 ? 'rd' : 'th';
      return number + output;
    }
  });
  return enCa;
});

/***/ }),
/* 136 */
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : English (United Kingdom) [en-gb]
//! author : Chris Gedrim : https://github.com/chrisgedrim

;
(function (global, factory) {
   true ? factory(__webpack_require__(105)) : 0;
})(this, function (moment) {
  'use strict';

  //! moment.js locale configuration
  var enGb = moment.defineLocale('en-gb', {
    months: 'January_February_March_April_May_June_July_August_September_October_November_December'.split('_'),
    monthsShort: 'Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec'.split('_'),
    weekdays: 'Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday'.split('_'),
    weekdaysShort: 'Sun_Mon_Tue_Wed_Thu_Fri_Sat'.split('_'),
    weekdaysMin: 'Su_Mo_Tu_We_Th_Fr_Sa'.split('_'),
    longDateFormat: {
      LT: 'HH:mm',
      LTS: 'HH:mm:ss',
      L: 'DD/MM/YYYY',
      LL: 'D MMMM YYYY',
      LLL: 'D MMMM YYYY HH:mm',
      LLLL: 'dddd, D MMMM YYYY HH:mm'
    },
    calendar: {
      sameDay: '[Today at] LT',
      nextDay: '[Tomorrow at] LT',
      nextWeek: 'dddd [at] LT',
      lastDay: '[Yesterday at] LT',
      lastWeek: '[Last] dddd [at] LT',
      sameElse: 'L'
    },
    relativeTime: {
      future: 'in %s',
      past: '%s ago',
      s: 'a few seconds',
      ss: '%d seconds',
      m: 'a minute',
      mm: '%d minutes',
      h: 'an hour',
      hh: '%d hours',
      d: 'a day',
      dd: '%d days',
      M: 'a month',
      MM: '%d months',
      y: 'a year',
      yy: '%d years'
    },
    dayOfMonthOrdinalParse: /\d{1,2}(st|nd|rd|th)/,
    ordinal: function (number) {
      var b = number % 10,
        output = ~~(number % 100 / 10) === 1 ? 'th' : b === 1 ? 'st' : b === 2 ? 'nd' : b === 3 ? 'rd' : 'th';
      return number + output;
    },
    week: {
      dow: 1,
      // Monday is the first day of the week.
      doy: 4 // The week that contains Jan 4th is the first week of the year.
    }
  });
  return enGb;
});

/***/ }),
/* 137 */
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : English (Ireland) [en-ie]
//! author : Chris Cartlidge : https://github.com/chriscartlidge

;
(function (global, factory) {
   true ? factory(__webpack_require__(105)) : 0;
})(this, function (moment) {
  'use strict';

  //! moment.js locale configuration
  var enIe = moment.defineLocale('en-ie', {
    months: 'January_February_March_April_May_June_July_August_September_October_November_December'.split('_'),
    monthsShort: 'Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec'.split('_'),
    weekdays: 'Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday'.split('_'),
    weekdaysShort: 'Sun_Mon_Tue_Wed_Thu_Fri_Sat'.split('_'),
    weekdaysMin: 'Su_Mo_Tu_We_Th_Fr_Sa'.split('_'),
    longDateFormat: {
      LT: 'HH:mm',
      LTS: 'HH:mm:ss',
      L: 'DD/MM/YYYY',
      LL: 'D MMMM YYYY',
      LLL: 'D MMMM YYYY HH:mm',
      LLLL: 'dddd D MMMM YYYY HH:mm'
    },
    calendar: {
      sameDay: '[Today at] LT',
      nextDay: '[Tomorrow at] LT',
      nextWeek: 'dddd [at] LT',
      lastDay: '[Yesterday at] LT',
      lastWeek: '[Last] dddd [at] LT',
      sameElse: 'L'
    },
    relativeTime: {
      future: 'in %s',
      past: '%s ago',
      s: 'a few seconds',
      ss: '%d seconds',
      m: 'a minute',
      mm: '%d minutes',
      h: 'an hour',
      hh: '%d hours',
      d: 'a day',
      dd: '%d days',
      M: 'a month',
      MM: '%d months',
      y: 'a year',
      yy: '%d years'
    },
    dayOfMonthOrdinalParse: /\d{1,2}(st|nd|rd|th)/,
    ordinal: function (number) {
      var b = number % 10,
        output = ~~(number % 100 / 10) === 1 ? 'th' : b === 1 ? 'st' : b === 2 ? 'nd' : b === 3 ? 'rd' : 'th';
      return number + output;
    },
    week: {
      dow: 1,
      // Monday is the first day of the week.
      doy: 4 // The week that contains Jan 4th is the first week of the year.
    }
  });
  return enIe;
});

/***/ }),
/* 138 */
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : English (Israel) [en-il]
//! author : Chris Gedrim : https://github.com/chrisgedrim

;
(function (global, factory) {
   true ? factory(__webpack_require__(105)) : 0;
})(this, function (moment) {
  'use strict';

  //! moment.js locale configuration
  var enIl = moment.defineLocale('en-il', {
    months: 'January_February_March_April_May_June_July_August_September_October_November_December'.split('_'),
    monthsShort: 'Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec'.split('_'),
    weekdays: 'Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday'.split('_'),
    weekdaysShort: 'Sun_Mon_Tue_Wed_Thu_Fri_Sat'.split('_'),
    weekdaysMin: 'Su_Mo_Tu_We_Th_Fr_Sa'.split('_'),
    longDateFormat: {
      LT: 'HH:mm',
      LTS: 'HH:mm:ss',
      L: 'DD/MM/YYYY',
      LL: 'D MMMM YYYY',
      LLL: 'D MMMM YYYY HH:mm',
      LLLL: 'dddd, D MMMM YYYY HH:mm'
    },
    calendar: {
      sameDay: '[Today at] LT',
      nextDay: '[Tomorrow at] LT',
      nextWeek: 'dddd [at] LT',
      lastDay: '[Yesterday at] LT',
      lastWeek: '[Last] dddd [at] LT',
      sameElse: 'L'
    },
    relativeTime: {
      future: 'in %s',
      past: '%s ago',
      s: 'a few seconds',
      ss: '%d seconds',
      m: 'a minute',
      mm: '%d minutes',
      h: 'an hour',
      hh: '%d hours',
      d: 'a day',
      dd: '%d days',
      M: 'a month',
      MM: '%d months',
      y: 'a year',
      yy: '%d years'
    },
    dayOfMonthOrdinalParse: /\d{1,2}(st|nd|rd|th)/,
    ordinal: function (number) {
      var b = number % 10,
        output = ~~(number % 100 / 10) === 1 ? 'th' : b === 1 ? 'st' : b === 2 ? 'nd' : b === 3 ? 'rd' : 'th';
      return number + output;
    }
  });
  return enIl;
});

/***/ }),
/* 139 */
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : English (India) [en-in]
//! author : Jatin Agrawal : https://github.com/jatinag22

;
(function (global, factory) {
   true ? factory(__webpack_require__(105)) : 0;
})(this, function (moment) {
  'use strict';

  //! moment.js locale configuration
  var enIn = moment.defineLocale('en-in', {
    months: 'January_February_March_April_May_June_July_August_September_October_November_December'.split('_'),
    monthsShort: 'Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec'.split('_'),
    weekdays: 'Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday'.split('_'),
    weekdaysShort: 'Sun_Mon_Tue_Wed_Thu_Fri_Sat'.split('_'),
    weekdaysMin: 'Su_Mo_Tu_We_Th_Fr_Sa'.split('_'),
    longDateFormat: {
      LT: 'h:mm A',
      LTS: 'h:mm:ss A',
      L: 'DD/MM/YYYY',
      LL: 'D MMMM YYYY',
      LLL: 'D MMMM YYYY h:mm A',
      LLLL: 'dddd, D MMMM YYYY h:mm A'
    },
    calendar: {
      sameDay: '[Today at] LT',
      nextDay: '[Tomorrow at] LT',
      nextWeek: 'dddd [at] LT',
      lastDay: '[Yesterday at] LT',
      lastWeek: '[Last] dddd [at] LT',
      sameElse: 'L'
    },
    relativeTime: {
      future: 'in %s',
      past: '%s ago',
      s: 'a few seconds',
      ss: '%d seconds',
      m: 'a minute',
      mm: '%d minutes',
      h: 'an hour',
      hh: '%d hours',
      d: 'a day',
      dd: '%d days',
      M: 'a month',
      MM: '%d months',
      y: 'a year',
      yy: '%d years'
    },
    dayOfMonthOrdinalParse: /\d{1,2}(st|nd|rd|th)/,
    ordinal: function (number) {
      var b = number % 10,
        output = ~~(number % 100 / 10) === 1 ? 'th' : b === 1 ? 'st' : b === 2 ? 'nd' : b === 3 ? 'rd' : 'th';
      return number + output;
    },
    week: {
      dow: 0,
      // Sunday is the first day of the week.
      doy: 6 // The week that contains Jan 1st is the first week of the year.
    }
  });
  return enIn;
});

/***/ }),
/* 140 */
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : English (New Zealand) [en-nz]
//! author : Luke McGregor : https://github.com/lukemcgregor

;
(function (global, factory) {
   true ? factory(__webpack_require__(105)) : 0;
})(this, function (moment) {
  'use strict';

  //! moment.js locale configuration
  var enNz = moment.defineLocale('en-nz', {
    months: 'January_February_March_April_May_June_July_August_September_October_November_December'.split('_'),
    monthsShort: 'Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec'.split('_'),
    weekdays: 'Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday'.split('_'),
    weekdaysShort: 'Sun_Mon_Tue_Wed_Thu_Fri_Sat'.split('_'),
    weekdaysMin: 'Su_Mo_Tu_We_Th_Fr_Sa'.split('_'),
    longDateFormat: {
      LT: 'h:mm A',
      LTS: 'h:mm:ss A',
      L: 'DD/MM/YYYY',
      LL: 'D MMMM YYYY',
      LLL: 'D MMMM YYYY h:mm A',
      LLLL: 'dddd, D MMMM YYYY h:mm A'
    },
    calendar: {
      sameDay: '[Today at] LT',
      nextDay: '[Tomorrow at] LT',
      nextWeek: 'dddd [at] LT',
      lastDay: '[Yesterday at] LT',
      lastWeek: '[Last] dddd [at] LT',
      sameElse: 'L'
    },
    relativeTime: {
      future: 'in %s',
      past: '%s ago',
      s: 'a few seconds',
      ss: '%d seconds',
      m: 'a minute',
      mm: '%d minutes',
      h: 'an hour',
      hh: '%d hours',
      d: 'a day',
      dd: '%d days',
      M: 'a month',
      MM: '%d months',
      y: 'a year',
      yy: '%d years'
    },
    dayOfMonthOrdinalParse: /\d{1,2}(st|nd|rd|th)/,
    ordinal: function (number) {
      var b = number % 10,
        output = ~~(number % 100 / 10) === 1 ? 'th' : b === 1 ? 'st' : b === 2 ? 'nd' : b === 3 ? 'rd' : 'th';
      return number + output;
    },
    week: {
      dow: 1,
      // Monday is the first day of the week.
      doy: 4 // The week that contains Jan 4th is the first week of the year.
    }
  });
  return enNz;
});

/***/ }),
/* 141 */
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : English (Singapore) [en-sg]
//! author : Matthew Castrillon-Madrigal : https://github.com/techdimension

;
(function (global, factory) {
   true ? factory(__webpack_require__(105)) : 0;
})(this, function (moment) {
  'use strict';

  //! moment.js locale configuration
  var enSg = moment.defineLocale('en-sg', {
    months: 'January_February_March_April_May_June_July_August_September_October_November_December'.split('_'),
    monthsShort: 'Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec'.split('_'),
    weekdays: 'Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday'.split('_'),
    weekdaysShort: 'Sun_Mon_Tue_Wed_Thu_Fri_Sat'.split('_'),
    weekdaysMin: 'Su_Mo_Tu_We_Th_Fr_Sa'.split('_'),
    longDateFormat: {
      LT: 'HH:mm',
      LTS: 'HH:mm:ss',
      L: 'DD/MM/YYYY',
      LL: 'D MMMM YYYY',
      LLL: 'D MMMM YYYY HH:mm',
      LLLL: 'dddd, D MMMM YYYY HH:mm'
    },
    calendar: {
      sameDay: '[Today at] LT',
      nextDay: '[Tomorrow at] LT',
      nextWeek: 'dddd [at] LT',
      lastDay: '[Yesterday at] LT',
      lastWeek: '[Last] dddd [at] LT',
      sameElse: 'L'
    },
    relativeTime: {
      future: 'in %s',
      past: '%s ago',
      s: 'a few seconds',
      ss: '%d seconds',
      m: 'a minute',
      mm: '%d minutes',
      h: 'an hour',
      hh: '%d hours',
      d: 'a day',
      dd: '%d days',
      M: 'a month',
      MM: '%d months',
      y: 'a year',
      yy: '%d years'
    },
    dayOfMonthOrdinalParse: /\d{1,2}(st|nd|rd|th)/,
    ordinal: function (number) {
      var b = number % 10,
        output = ~~(number % 100 / 10) === 1 ? 'th' : b === 1 ? 'st' : b === 2 ? 'nd' : b === 3 ? 'rd' : 'th';
      return number + output;
    },
    week: {
      dow: 1,
      // Monday is the first day of the week.
      doy: 4 // The week that contains Jan 4th is the first week of the year.
    }
  });
  return enSg;
});

/***/ }),
/* 142 */
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Esperanto [eo]
//! author : Colin Dean : https://github.com/colindean
//! author : Mia Nordentoft Imperatori : https://github.com/miestasmia
//! comment : miestasmia corrected the translation by colindean
//! comment : Vivakvo corrected the translation by colindean and miestasmia

;
(function (global, factory) {
   true ? factory(__webpack_require__(105)) : 0;
})(this, function (moment) {
  'use strict';

  //! moment.js locale configuration
  var eo = moment.defineLocale('eo', {
    months: 'januaro_februaro_marto_aprilo_majo_junio_julio_agusto_septembro_oktobro_novembro_decembro'.split('_'),
    monthsShort: 'jan_feb_mart_apr_maj_jun_jul_ag_sept_okt_nov_dec'.split('_'),
    weekdays: 'dimano_lundo_mardo_merkredo_ado_vendredo_sabato'.split('_'),
    weekdaysShort: 'dim_lun_mard_merk_a_ven_sab'.split('_'),
    weekdaysMin: 'di_lu_ma_me_a_ve_sa'.split('_'),
    longDateFormat: {
      LT: 'HH:mm',
      LTS: 'HH:mm:ss',
      L: 'YYYY-MM-DD',
      LL: '[la] D[-an de] MMMM, YYYY',
      LLL: '[la] D[-an de] MMMM, YYYY HH:mm',
      LLLL: 'dddd[n], [la] D[-an de] MMMM, YYYY HH:mm',
      llll: 'ddd, [la] D[-an de] MMM, YYYY HH:mm'
    },
    meridiemParse: /[ap]\.t\.m/i,
    isPM: function (input) {
      return input.charAt(0).toLowerCase() === 'p';
    },
    meridiem: function (hours, minutes, isLower) {
      if (hours > 11) {
        return isLower ? 'p.t.m.' : 'P.T.M.';
      } else {
        return isLower ? 'a.t.m.' : 'A.T.M.';
      }
    },
    calendar: {
      sameDay: '[Hodia je] LT',
      nextDay: '[Morga je] LT',
      nextWeek: 'dddd[n je] LT',
      lastDay: '[Hiera je] LT',
      lastWeek: '[pasintan] dddd[n je] LT',
      sameElse: 'L'
    },
    relativeTime: {
      future: 'post %s',
      past: 'anta %s',
      s: 'kelkaj sekundoj',
      ss: '%d sekundoj',
      m: 'unu minuto',
      mm: '%d minutoj',
      h: 'unu horo',
      hh: '%d horoj',
      d: 'unu tago',
      //ne 'diurno', ar estas uzita por proksimumo
      dd: '%d tagoj',
      M: 'unu monato',
      MM: '%d monatoj',
      y: 'unu jaro',
      yy: '%d jaroj'
    },
    dayOfMonthOrdinalParse: /\d{1,2}a/,
    ordinal: '%da',
    week: {
      dow: 1,
      // Monday is the first day of the week.
      doy: 7 // The week that contains Jan 7th is the first week of the year.
    }
  });
  return eo;
});

/***/ }),
/* 143 */
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Spanish [es]
//! author : Julio Napur : https://github.com/julionc

;
(function (global, factory) {
   true ? factory(__webpack_require__(105)) : 0;
})(this, function (moment) {
  'use strict';

  //! moment.js locale configuration
  var monthsShortDot = 'ene._feb._mar._abr._may._jun._jul._ago._sep._oct._nov._dic.'.split('_'),
    monthsShort = 'ene_feb_mar_abr_may_jun_jul_ago_sep_oct_nov_dic'.split('_'),
    monthsParse = [/^ene/i, /^feb/i, /^mar/i, /^abr/i, /^may/i, /^jun/i, /^jul/i, /^ago/i, /^sep/i, /^oct/i, /^nov/i, /^dic/i],
    monthsRegex = /^(enero|febrero|marzo|abril|mayo|junio|julio|agosto|septiembre|octubre|noviembre|diciembre|ene\.?|feb\.?|mar\.?|abr\.?|may\.?|jun\.?|jul\.?|ago\.?|sep\.?|oct\.?|nov\.?|dic\.?)/i;
  var es = moment.defineLocale('es', {
    months: 'enero_febrero_marzo_abril_mayo_junio_julio_agosto_septiembre_octubre_noviembre_diciembre'.split('_'),
    monthsShort: function (m, format) {
      if (!m) {
        return monthsShortDot;
      } else if (/-MMM-/.test(format)) {
        return monthsShort[m.month()];
      } else {
        return monthsShortDot[m.month()];
      }
    },
    monthsRegex: monthsRegex,
    monthsShortRegex: monthsRegex,
    monthsStrictRegex: /^(enero|febrero|marzo|abril|mayo|junio|julio|agosto|septiembre|octubre|noviembre|diciembre)/i,
    monthsShortStrictRegex: /^(ene\.?|feb\.?|mar\.?|abr\.?|may\.?|jun\.?|jul\.?|ago\.?|sep\.?|oct\.?|nov\.?|dic\.?)/i,
    monthsParse: monthsParse,
    longMonthsParse: monthsParse,
    shortMonthsParse: monthsParse,
    weekdays: 'domingo_lunes_martes_mircoles_jueves_viernes_sbado'.split('_'),
    weekdaysShort: 'dom._lun._mar._mi._jue._vie._sb.'.split('_'),
    weekdaysMin: 'do_lu_ma_mi_ju_vi_s'.split('_'),
    weekdaysParseExact: true,
    longDateFormat: {
      LT: 'H:mm',
      LTS: 'H:mm:ss',
      L: 'DD/MM/YYYY',
      LL: 'D [de] MMMM [de] YYYY',
      LLL: 'D [de] MMMM [de] YYYY H:mm',
      LLLL: 'dddd, D [de] MMMM [de] YYYY H:mm'
    },
    calendar: {
      sameDay: function () {
        return '[hoy a la' + (this.hours() !== 1 ? 's' : '') + '] LT';
      },
      nextDay: function () {
        return '[maana a la' + (this.hours() !== 1 ? 's' : '') + '] LT';
      },
      nextWeek: function () {
        return 'dddd [a la' + (this.hours() !== 1 ? 's' : '') + '] LT';
      },
      lastDay: function () {
        return '[ayer a la' + (this.hours() !== 1 ? 's' : '') + '] LT';
      },
      lastWeek: function () {
        return '[el] dddd [pasado a la' + (this.hours() !== 1 ? 's' : '') + '] LT';
      },
      sameElse: 'L'
    },
    relativeTime: {
      future: 'en %s',
      past: 'hace %s',
      s: 'unos segundos',
      ss: '%d segundos',
      m: 'un minuto',
      mm: '%d minutos',
      h: 'una hora',
      hh: '%d horas',
      d: 'un da',
      dd: '%d das',
      w: 'una semana',
      ww: '%d semanas',
      M: 'un mes',
      MM: '%d meses',
      y: 'un ao',
      yy: '%d aos'
    },
    dayOfMonthOrdinalParse: /\d{1,2}/,
    ordinal: '%d',
    week: {
      dow: 1,
      // Monday is the first day of the week.
      doy: 4 // The week that contains Jan 4th is the first week of the year.
    },
    invalidDate: 'Fecha invlida'
  });
  return es;
});

/***/ }),
/* 144 */
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Spanish (Dominican Republic) [es-do]

;
(function (global, factory) {
   true ? factory(__webpack_require__(105)) : 0;
})(this, function (moment) {
  'use strict';

  //! moment.js locale configuration
  var monthsShortDot = 'ene._feb._mar._abr._may._jun._jul._ago._sep._oct._nov._dic.'.split('_'),
    monthsShort = 'ene_feb_mar_abr_may_jun_jul_ago_sep_oct_nov_dic'.split('_'),
    monthsParse = [/^ene/i, /^feb/i, /^mar/i, /^abr/i, /^may/i, /^jun/i, /^jul/i, /^ago/i, /^sep/i, /^oct/i, /^nov/i, /^dic/i],
    monthsRegex = /^(enero|febrero|marzo|abril|mayo|junio|julio|agosto|septiembre|octubre|noviembre|diciembre|ene\.?|feb\.?|mar\.?|abr\.?|may\.?|jun\.?|jul\.?|ago\.?|sep\.?|oct\.?|nov\.?|dic\.?)/i;
  var esDo = moment.defineLocale('es-do', {
    months: 'enero_febrero_marzo_abril_mayo_junio_julio_agosto_septiembre_octubre_noviembre_diciembre'.split('_'),
    monthsShort: function (m, format) {
      if (!m) {
        return monthsShortDot;
      } else if (/-MMM-/.test(format)) {
        return monthsShort[m.month()];
      } else {
        return monthsShortDot[m.month()];
      }
    },
    monthsRegex: monthsRegex,
    monthsShortRegex: monthsRegex,
    monthsStrictRegex: /^(enero|febrero|marzo|abril|mayo|junio|julio|agosto|septiembre|octubre|noviembre|diciembre)/i,
    monthsShortStrictRegex: /^(ene\.?|feb\.?|mar\.?|abr\.?|may\.?|jun\.?|jul\.?|ago\.?|sep\.?|oct\.?|nov\.?|dic\.?)/i,
    monthsParse: monthsParse,
    longMonthsParse: monthsParse,
    shortMonthsParse: monthsParse,
    weekdays: 'domingo_lunes_martes_mircoles_jueves_viernes_sbado'.split('_'),
    weekdaysShort: 'dom._lun._mar._mi._jue._vie._sb.'.split('_'),
    weekdaysMin: 'do_lu_ma_mi_ju_vi_s'.split('_'),
    weekdaysParseExact: true,
    longDateFormat: {
      LT: 'h:mm A',
      LTS: 'h:mm:ss A',
      L: 'DD/MM/YYYY',
      LL: 'D [de] MMMM [de] YYYY',
      LLL: 'D [de] MMMM [de] YYYY h:mm A',
      LLLL: 'dddd, D [de] MMMM [de] YYYY h:mm A'
    },
    calendar: {
      sameDay: function () {
        return '[hoy a la' + (this.hours() !== 1 ? 's' : '') + '] LT';
      },
      nextDay: function () {
        return '[maana a la' + (this.hours() !== 1 ? 's' : '') + '] LT';
      },
      nextWeek: function () {
        return 'dddd [a la' + (this.hours() !== 1 ? 's' : '') + '] LT';
      },
      lastDay: function () {
        return '[ayer a la' + (this.hours() !== 1 ? 's' : '') + '] LT';
      },
      lastWeek: function () {
        return '[el] dddd [pasado a la' + (this.hours() !== 1 ? 's' : '') + '] LT';
      },
      sameElse: 'L'
    },
    relativeTime: {
      future: 'en %s',
      past: 'hace %s',
      s: 'unos segundos',
      ss: '%d segundos',
      m: 'un minuto',
      mm: '%d minutos',
      h: 'una hora',
      hh: '%d horas',
      d: 'un da',
      dd: '%d das',
      w: 'una semana',
      ww: '%d semanas',
      M: 'un mes',
      MM: '%d meses',
      y: 'un ao',
      yy: '%d aos'
    },
    dayOfMonthOrdinalParse: /\d{1,2}/,
    ordinal: '%d',
    week: {
      dow: 1,
      // Monday is the first day of the week.
      doy: 4 // The week that contains Jan 4th is the first week of the year.
    }
  });
  return esDo;
});

/***/ }),
/* 145 */
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Spanish (Mexico) [es-mx]
//! author : JC Franco : https://github.com/jcfranco

;
(function (global, factory) {
   true ? factory(__webpack_require__(105)) : 0;
})(this, function (moment) {
  'use strict';

  //! moment.js locale configuration
  var monthsShortDot = 'ene._feb._mar._abr._may._jun._jul._ago._sep._oct._nov._dic.'.split('_'),
    monthsShort = 'ene_feb_mar_abr_may_jun_jul_ago_sep_oct_nov_dic'.split('_'),
    monthsParse = [/^ene/i, /^feb/i, /^mar/i, /^abr/i, /^may/i, /^jun/i, /^jul/i, /^ago/i, /^sep/i, /^oct/i, /^nov/i, /^dic/i],
    monthsRegex = /^(enero|febrero|marzo|abril|mayo|junio|julio|agosto|septiembre|octubre|noviembre|diciembre|ene\.?|feb\.?|mar\.?|abr\.?|may\.?|jun\.?|jul\.?|ago\.?|sep\.?|oct\.?|nov\.?|dic\.?)/i;
  var esMx = moment.defineLocale('es-mx', {
    months: 'enero_febrero_marzo_abril_mayo_junio_julio_agosto_septiembre_octubre_noviembre_diciembre'.split('_'),
    monthsShort: function (m, format) {
      if (!m) {
        return monthsShortDot;
      } else if (/-MMM-/.test(format)) {
        return monthsShort[m.month()];
      } else {
        return monthsShortDot[m.month()];
      }
    },
    monthsRegex: monthsRegex,
    monthsShortRegex: monthsRegex,
    monthsStrictRegex: /^(enero|febrero|marzo|abril|mayo|junio|julio|agosto|septiembre|octubre|noviembre|diciembre)/i,
    monthsShortStrictRegex: /^(ene\.?|feb\.?|mar\.?|abr\.?|may\.?|jun\.?|jul\.?|ago\.?|sep\.?|oct\.?|nov\.?|dic\.?)/i,
    monthsParse: monthsParse,
    longMonthsParse: monthsParse,
    shortMonthsParse: monthsParse,
    weekdays: 'domingo_lunes_martes_mircoles_jueves_viernes_sbado'.split('_'),
    weekdaysShort: 'dom._lun._mar._mi._jue._vie._sb.'.split('_'),
    weekdaysMin: 'do_lu_ma_mi_ju_vi_s'.split('_'),
    weekdaysParseExact: true,
    longDateFormat: {
      LT: 'H:mm',
      LTS: 'H:mm:ss',
      L: 'DD/MM/YYYY',
      LL: 'D [de] MMMM [de] YYYY',
      LLL: 'D [de] MMMM [de] YYYY H:mm',
      LLLL: 'dddd, D [de] MMMM [de] YYYY H:mm'
    },
    calendar: {
      sameDay: function () {
        return '[hoy a la' + (this.hours() !== 1 ? 's' : '') + '] LT';
      },
      nextDay: function () {
        return '[maana a la' + (this.hours() !== 1 ? 's' : '') + '] LT';
      },
      nextWeek: function () {
        return 'dddd [a la' + (this.hours() !== 1 ? 's' : '') + '] LT';
      },
      lastDay: function () {
        return '[ayer a la' + (this.hours() !== 1 ? 's' : '') + '] LT';
      },
      lastWeek: function () {
        return '[el] dddd [pasado a la' + (this.hours() !== 1 ? 's' : '') + '] LT';
      },
      sameElse: 'L'
    },
    relativeTime: {
      future: 'en %s',
      past: 'hace %s',
      s: 'unos segundos',
      ss: '%d segundos',
      m: 'un minuto',
      mm: '%d minutos',
      h: 'una hora',
      hh: '%d horas',
      d: 'un da',
      dd: '%d das',
      w: 'una semana',
      ww: '%d semanas',
      M: 'un mes',
      MM: '%d meses',
      y: 'un ao',
      yy: '%d aos'
    },
    dayOfMonthOrdinalParse: /\d{1,2}/,
    ordinal: '%d',
    week: {
      dow: 0,
      // Sunday is the first day of the week.
      doy: 4 // The week that contains Jan 4th is the first week of the year.
    },
    invalidDate: 'Fecha invlida'
  });
  return esMx;
});

/***/ }),
/* 146 */
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Spanish (United States) [es-us]
//! author : bustta : https://github.com/bustta
//! author : chrisrodz : https://github.com/chrisrodz

;
(function (global, factory) {
   true ? factory(__webpack_require__(105)) : 0;
})(this, function (moment) {
  'use strict';

  //! moment.js locale configuration
  var monthsShortDot = 'ene._feb._mar._abr._may._jun._jul._ago._sep._oct._nov._dic.'.split('_'),
    monthsShort = 'ene_feb_mar_abr_may_jun_jul_ago_sep_oct_nov_dic'.split('_'),
    monthsParse = [/^ene/i, /^feb/i, /^mar/i, /^abr/i, /^may/i, /^jun/i, /^jul/i, /^ago/i, /^sep/i, /^oct/i, /^nov/i, /^dic/i],
    monthsRegex = /^(enero|febrero|marzo|abril|mayo|junio|julio|agosto|septiembre|octubre|noviembre|diciembre|ene\.?|feb\.?|mar\.?|abr\.?|may\.?|jun\.?|jul\.?|ago\.?|sep\.?|oct\.?|nov\.?|dic\.?)/i;
  var esUs = moment.defineLocale('es-us', {
    months: 'enero_febrero_marzo_abril_mayo_junio_julio_agosto_septiembre_octubre_noviembre_diciembre'.split('_'),
    monthsShort: function (m, format) {
      if (!m) {
        return monthsShortDot;
      } else if (/-MMM-/.test(format)) {
        return monthsShort[m.month()];
      } else {
        return monthsShortDot[m.month()];
      }
    },
    monthsRegex: monthsRegex,
    monthsShortRegex: monthsRegex,
    monthsStrictRegex: /^(enero|febrero|marzo|abril|mayo|junio|julio|agosto|septiembre|octubre|noviembre|diciembre)/i,
    monthsShortStrictRegex: /^(ene\.?|feb\.?|mar\.?|abr\.?|may\.?|jun\.?|jul\.?|ago\.?|sep\.?|oct\.?|nov\.?|dic\.?)/i,
    monthsParse: monthsParse,
    longMonthsParse: monthsParse,
    shortMonthsParse: monthsParse,
    weekdays: 'domingo_lunes_martes_mircoles_jueves_viernes_sbado'.split('_'),
    weekdaysShort: 'dom._lun._mar._mi._jue._vie._sb.'.split('_'),
    weekdaysMin: 'do_lu_ma_mi_ju_vi_s'.split('_'),
    weekdaysParseExact: true,
    longDateFormat: {
      LT: 'h:mm A',
      LTS: 'h:mm:ss A',
      L: 'MM/DD/YYYY',
      LL: 'D [de] MMMM [de] YYYY',
      LLL: 'D [de] MMMM [de] YYYY h:mm A',
      LLLL: 'dddd, D [de] MMMM [de] YYYY h:mm A'
    },
    calendar: {
      sameDay: function () {
        return '[hoy a la' + (this.hours() !== 1 ? 's' : '') + '] LT';
      },
      nextDay: function () {
        return '[maana a la' + (this.hours() !== 1 ? 's' : '') + '] LT';
      },
      nextWeek: function () {
        return 'dddd [a la' + (this.hours() !== 1 ? 's' : '') + '] LT';
      },
      lastDay: function () {
        return '[ayer a la' + (this.hours() !== 1 ? 's' : '') + '] LT';
      },
      lastWeek: function () {
        return '[el] dddd [pasado a la' + (this.hours() !== 1 ? 's' : '') + '] LT';
      },
      sameElse: 'L'
    },
    relativeTime: {
      future: 'en %s',
      past: 'hace %s',
      s: 'unos segundos',
      ss: '%d segundos',
      m: 'un minuto',
      mm: '%d minutos',
      h: 'una hora',
      hh: '%d horas',
      d: 'un da',
      dd: '%d das',
      w: 'una semana',
      ww: '%d semanas',
      M: 'un mes',
      MM: '%d meses',
      y: 'un ao',
      yy: '%d aos'
    },
    dayOfMonthOrdinalParse: /\d{1,2}/,
    ordinal: '%d',
    week: {
      dow: 0,
      // Sunday is the first day of the week.
      doy: 6 // The week that contains Jan 6th is the first week of the year.
    }
  });
  return esUs;
});

/***/ }),
/* 147 */
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Estonian [et]
//! author : Henry Kehlmann : https://github.com/madhenry
//! improvements : Illimar Tambek : https://github.com/ragulka

;
(function (global, factory) {
   true ? factory(__webpack_require__(105)) : 0;
})(this, function (moment) {
  'use strict';

  //! moment.js locale configuration
  function processRelativeTime(number, withoutSuffix, key, isFuture) {
    var format = {
      s: ['mne sekundi', 'mni sekund', 'paar sekundit'],
      ss: [number + 'sekundi', number + 'sekundit'],
      m: ['he minuti', 'ks minut'],
      mm: [number + ' minuti', number + ' minutit'],
      h: ['he tunni', 'tund aega', 'ks tund'],
      hh: [number + ' tunni', number + ' tundi'],
      d: ['he peva', 'ks pev'],
      M: ['kuu aja', 'kuu aega', 'ks kuu'],
      MM: [number + ' kuu', number + ' kuud'],
      y: ['he aasta', 'aasta', 'ks aasta'],
      yy: [number + ' aasta', number + ' aastat']
    };
    if (withoutSuffix) {
      return format[key][2] ? format[key][2] : format[key][1];
    }
    return isFuture ? format[key][0] : format[key][1];
  }
  var et = moment.defineLocale('et', {
    months: 'jaanuar_veebruar_mrts_aprill_mai_juuni_juuli_august_september_oktoober_november_detsember'.split('_'),
    monthsShort: 'jaan_veebr_mrts_apr_mai_juuni_juuli_aug_sept_okt_nov_dets'.split('_'),
    weekdays: 'phapev_esmaspev_teisipev_kolmapev_neljapev_reede_laupev'.split('_'),
    weekdaysShort: 'P_E_T_K_N_R_L'.split('_'),
    weekdaysMin: 'P_E_T_K_N_R_L'.split('_'),
    longDateFormat: {
      LT: 'H:mm',
      LTS: 'H:mm:ss',
      L: 'DD.MM.YYYY',
      LL: 'D. MMMM YYYY',
      LLL: 'D. MMMM YYYY H:mm',
      LLLL: 'dddd, D. MMMM YYYY H:mm'
    },
    calendar: {
      sameDay: '[Tna,] LT',
      nextDay: '[Homme,] LT',
      nextWeek: '[Jrgmine] dddd LT',
      lastDay: '[Eile,] LT',
      lastWeek: '[Eelmine] dddd LT',
      sameElse: 'L'
    },
    relativeTime: {
      future: '%s prast',
      past: '%s tagasi',
      s: processRelativeTime,
      ss: processRelativeTime,
      m: processRelativeTime,
      mm: processRelativeTime,
      h: processRelativeTime,
      hh: processRelativeTime,
      d: processRelativeTime,
      dd: '%d peva',
      M: processRelativeTime,
      MM: processRelativeTime,
      y: processRelativeTime,
      yy: processRelativeTime
    },
    dayOfMonthOrdinalParse: /\d{1,2}\./,
    ordinal: '%d.',
    week: {
      dow: 1,
      // Monday is the first day of the week.
      doy: 4 // The week that contains Jan 4th is the first week of the year.
    }
  });
  return et;
});

/***/ }),
/* 148 */
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Basque [eu]
//! author : Eneko Illarramendi : https://github.com/eillarra

;
(function (global, factory) {
   true ? factory(__webpack_require__(105)) : 0;
})(this, function (moment) {
  'use strict';

  //! moment.js locale configuration
  var eu = moment.defineLocale('eu', {
    months: 'urtarrila_otsaila_martxoa_apirila_maiatza_ekaina_uztaila_abuztua_iraila_urria_azaroa_abendua'.split('_'),
    monthsShort: 'urt._ots._mar._api._mai._eka._uzt._abu._ira._urr._aza._abe.'.split('_'),
    monthsParseExact: true,
    weekdays: 'igandea_astelehena_asteartea_asteazkena_osteguna_ostirala_larunbata'.split('_'),
    weekdaysShort: 'ig._al._ar._az._og._ol._lr.'.split('_'),
    weekdaysMin: 'ig_al_ar_az_og_ol_lr'.split('_'),
    weekdaysParseExact: true,
    longDateFormat: {
      LT: 'HH:mm',
      LTS: 'HH:mm:ss',
      L: 'YYYY-MM-DD',
      LL: 'YYYY[ko] MMMM[ren] D[a]',
      LLL: 'YYYY[ko] MMMM[ren] D[a] HH:mm',
      LLLL: 'dddd, YYYY[ko] MMMM[ren] D[a] HH:mm',
      l: 'YYYY-M-D',
      ll: 'YYYY[ko] MMM D[a]',
      lll: 'YYYY[ko] MMM D[a] HH:mm',
      llll: 'ddd, YYYY[ko] MMM D[a] HH:mm'
    },
    calendar: {
      sameDay: '[gaur] LT[etan]',
      nextDay: '[bihar] LT[etan]',
      nextWeek: 'dddd LT[etan]',
      lastDay: '[atzo] LT[etan]',
      lastWeek: '[aurreko] dddd LT[etan]',
      sameElse: 'L'
    },
    relativeTime: {
      future: '%s barru',
      past: 'duela %s',
      s: 'segundo batzuk',
      ss: '%d segundo',
      m: 'minutu bat',
      mm: '%d minutu',
      h: 'ordu bat',
      hh: '%d ordu',
      d: 'egun bat',
      dd: '%d egun',
      M: 'hilabete bat',
      MM: '%d hilabete',
      y: 'urte bat',
      yy: '%d urte'
    },
    dayOfMonthOrdinalParse: /\d{1,2}\./,
    ordinal: '%d.',
    week: {
      dow: 1,
      // Monday is the first day of the week.
      doy: 7 // The week that contains Jan 7th is the first week of the year.
    }
  });
  return eu;
});

/***/ }),
/* 149 */
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Persian [fa]
//! author : Ebrahim Byagowi : https://github.com/ebraminio

;
(function (global, factory) {
   true ? factory(__webpack_require__(105)) : 0;
})(this, function (moment) {
  'use strict';

  //! moment.js locale configuration
  var symbolMap = {
      1: '',
      2: '',
      3: '',
      4: '',
      5: '',
      6: '',
      7: '',
      8: '',
      9: '',
      0: ''
    },
    numberMap = {
      '': '1',
      '': '2',
      '': '3',
      '': '4',
      '': '5',
      '': '6',
      '': '7',
      '': '8',
      '': '9',
      '': '0'
    };
  var fa = moment.defineLocale('fa', {
    months: '___________'.split('_'),
    monthsShort: '___________'.split('_'),
    weekdays: '\u200c__\u200c__\u200c__'.split('_'),
    weekdaysShort: '\u200c__\u200c__\u200c__'.split('_'),
    weekdaysMin: '______'.split('_'),
    weekdaysParseExact: true,
    longDateFormat: {
      LT: 'HH:mm',
      LTS: 'HH:mm:ss',
      L: 'DD/MM/YYYY',
      LL: 'D MMMM YYYY',
      LLL: 'D MMMM YYYY HH:mm',
      LLLL: 'dddd, D MMMM YYYY HH:mm'
    },
    meridiemParse: /  |  /,
    isPM: function (input) {
      return /  /.test(input);
    },
    meridiem: function (hour, minute, isLower) {
      if (hour < 12) {
        return '  ';
      } else {
        return '  ';
      }
    },
    calendar: {
      sameDay: '[ ] LT',
      nextDay: '[ ] LT',
      nextWeek: 'dddd [] LT',
      lastDay: '[ ] LT',
      lastWeek: 'dddd [] [] LT',
      sameElse: 'L'
    },
    relativeTime: {
      future: ' %s',
      past: '%s ',
      s: ' ',
      ss: '%d ',
      m: ' ',
      mm: '%d ',
      h: ' ',
      hh: '%d ',
      d: ' ',
      dd: '%d ',
      M: ' ',
      MM: '%d ',
      y: ' ',
      yy: '%d '
    },
    preparse: function (string) {
      return string.replace(/[-]/g, function (match) {
        return numberMap[match];
      }).replace(//g, ',');
    },
    postformat: function (string) {
      return string.replace(/\d/g, function (match) {
        return symbolMap[match];
      }).replace(/,/g, '');
    },
    dayOfMonthOrdinalParse: /\d{1,2}/,
    ordinal: '%d',
    week: {
      dow: 6,
      // Saturday is the first day of the week.
      doy: 12 // The week that contains Jan 12th is the first week of the year.
    }
  });
  return fa;
});

/***/ }),
/* 150 */
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Finnish [fi]
//! author : Tarmo Aidantausta : https://github.com/bleadof

;
(function (global, factory) {
   true ? factory(__webpack_require__(105)) : 0;
})(this, function (moment) {
  'use strict';

  //! moment.js locale configuration
  var numbersPast = 'nolla yksi kaksi kolme nelj viisi kuusi seitsemn kahdeksan yhdeksn'.split(' '),
    numbersFuture = ['nolla', 'yhden', 'kahden', 'kolmen', 'neljn', 'viiden', 'kuuden', numbersPast[7], numbersPast[8], numbersPast[9]];
  function translate(number, withoutSuffix, key, isFuture) {
    var result = '';
    switch (key) {
      case 's':
        return isFuture ? 'muutaman sekunnin' : 'muutama sekunti';
      case 'ss':
        result = isFuture ? 'sekunnin' : 'sekuntia';
        break;
      case 'm':
        return isFuture ? 'minuutin' : 'minuutti';
      case 'mm':
        result = isFuture ? 'minuutin' : 'minuuttia';
        break;
      case 'h':
        return isFuture ? 'tunnin' : 'tunti';
      case 'hh':
        result = isFuture ? 'tunnin' : 'tuntia';
        break;
      case 'd':
        return isFuture ? 'pivn' : 'piv';
      case 'dd':
        result = isFuture ? 'pivn' : 'piv';
        break;
      case 'M':
        return isFuture ? 'kuukauden' : 'kuukausi';
      case 'MM':
        result = isFuture ? 'kuukauden' : 'kuukautta';
        break;
      case 'y':
        return isFuture ? 'vuoden' : 'vuosi';
      case 'yy':
        result = isFuture ? 'vuoden' : 'vuotta';
        break;
    }
    result = verbalNumber(number, isFuture) + ' ' + result;
    return result;
  }
  function verbalNumber(number, isFuture) {
    return number < 10 ? isFuture ? numbersFuture[number] : numbersPast[number] : number;
  }
  var fi = moment.defineLocale('fi', {
    months: 'tammikuu_helmikuu_maaliskuu_huhtikuu_toukokuu_keskuu_heinkuu_elokuu_syyskuu_lokakuu_marraskuu_joulukuu'.split('_'),
    monthsShort: 'tammi_helmi_maalis_huhti_touko_kes_hein_elo_syys_loka_marras_joulu'.split('_'),
    weekdays: 'sunnuntai_maanantai_tiistai_keskiviikko_torstai_perjantai_lauantai'.split('_'),
    weekdaysShort: 'su_ma_ti_ke_to_pe_la'.split('_'),
    weekdaysMin: 'su_ma_ti_ke_to_pe_la'.split('_'),
    longDateFormat: {
      LT: 'HH.mm',
      LTS: 'HH.mm.ss',
      L: 'DD.MM.YYYY',
      LL: 'Do MMMM[ta] YYYY',
      LLL: 'Do MMMM[ta] YYYY, [klo] HH.mm',
      LLLL: 'dddd, Do MMMM[ta] YYYY, [klo] HH.mm',
      l: 'D.M.YYYY',
      ll: 'Do MMM YYYY',
      lll: 'Do MMM YYYY, [klo] HH.mm',
      llll: 'ddd, Do MMM YYYY, [klo] HH.mm'
    },
    calendar: {
      sameDay: '[tnn] [klo] LT',
      nextDay: '[huomenna] [klo] LT',
      nextWeek: 'dddd [klo] LT',
      lastDay: '[eilen] [klo] LT',
      lastWeek: '[viime] dddd[na] [klo] LT',
      sameElse: 'L'
    },
    relativeTime: {
      future: '%s pst',
      past: '%s sitten',
      s: translate,
      ss: translate,
      m: translate,
      mm: translate,
      h: translate,
      hh: translate,
      d: translate,
      dd: translate,
      M: translate,
      MM: translate,
      y: translate,
      yy: translate
    },
    dayOfMonthOrdinalParse: /\d{1,2}\./,
    ordinal: '%d.',
    week: {
      dow: 1,
      // Monday is the first day of the week.
      doy: 4 // The week that contains Jan 4th is the first week of the year.
    }
  });
  return fi;
});

/***/ }),
/* 151 */
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Filipino [fil]
//! author : Dan Hagman : https://github.com/hagmandan
//! author : Matthew Co : https://github.com/matthewdeeco

;
(function (global, factory) {
   true ? factory(__webpack_require__(105)) : 0;
})(this, function (moment) {
  'use strict';

  //! moment.js locale configuration
  var fil = moment.defineLocale('fil', {
    months: 'Enero_Pebrero_Marso_Abril_Mayo_Hunyo_Hulyo_Agosto_Setyembre_Oktubre_Nobyembre_Disyembre'.split('_'),
    monthsShort: 'Ene_Peb_Mar_Abr_May_Hun_Hul_Ago_Set_Okt_Nob_Dis'.split('_'),
    weekdays: 'Linggo_Lunes_Martes_Miyerkules_Huwebes_Biyernes_Sabado'.split('_'),
    weekdaysShort: 'Lin_Lun_Mar_Miy_Huw_Biy_Sab'.split('_'),
    weekdaysMin: 'Li_Lu_Ma_Mi_Hu_Bi_Sab'.split('_'),
    longDateFormat: {
      LT: 'HH:mm',
      LTS: 'HH:mm:ss',
      L: 'MM/D/YYYY',
      LL: 'MMMM D, YYYY',
      LLL: 'MMMM D, YYYY HH:mm',
      LLLL: 'dddd, MMMM DD, YYYY HH:mm'
    },
    calendar: {
      sameDay: 'LT [ngayong araw]',
      nextDay: '[Bukas ng] LT',
      nextWeek: 'LT [sa susunod na] dddd',
      lastDay: 'LT [kahapon]',
      lastWeek: 'LT [noong nakaraang] dddd',
      sameElse: 'L'
    },
    relativeTime: {
      future: 'sa loob ng %s',
      past: '%s ang nakalipas',
      s: 'ilang segundo',
      ss: '%d segundo',
      m: 'isang minuto',
      mm: '%d minuto',
      h: 'isang oras',
      hh: '%d oras',
      d: 'isang araw',
      dd: '%d araw',
      M: 'isang buwan',
      MM: '%d buwan',
      y: 'isang taon',
      yy: '%d taon'
    },
    dayOfMonthOrdinalParse: /\d{1,2}/,
    ordinal: function (number) {
      return number;
    },
    week: {
      dow: 1,
      // Monday is the first day of the week.
      doy: 4 // The week that contains Jan 4th is the first week of the year.
    }
  });
  return fil;
});

/***/ }),
/* 152 */
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Faroese [fo]
//! author : Ragnar Johannesen : https://github.com/ragnar123
//! author : Kristian Sakarisson : https://github.com/sakarisson

;
(function (global, factory) {
   true ? factory(__webpack_require__(105)) : 0;
})(this, function (moment) {
  'use strict';

  //! moment.js locale configuration
  var fo = moment.defineLocale('fo', {
    months: 'januar_februar_mars_aprl_mai_juni_juli_august_september_oktober_november_desember'.split('_'),
    monthsShort: 'jan_feb_mar_apr_mai_jun_jul_aug_sep_okt_nov_des'.split('_'),
    weekdays: 'sunnudagur_mnadagur_tsdagur_mikudagur_hsdagur_frggjadagur_leygardagur'.split('_'),
    weekdaysShort: 'sun_mn_ts_mik_hs_fr_ley'.split('_'),
    weekdaysMin: 'su_m_t_mi_h_fr_le'.split('_'),
    longDateFormat: {
      LT: 'HH:mm',
      LTS: 'HH:mm:ss',
      L: 'DD/MM/YYYY',
      LL: 'D MMMM YYYY',
      LLL: 'D MMMM YYYY HH:mm',
      LLLL: 'dddd D. MMMM, YYYY HH:mm'
    },
    calendar: {
      sameDay: '[ dag kl.] LT',
      nextDay: '[ morgin kl.] LT',
      nextWeek: 'dddd [kl.] LT',
      lastDay: '[ gjr kl.] LT',
      lastWeek: '[sstu] dddd [kl] LT',
      sameElse: 'L'
    },
    relativeTime: {
      future: 'um %s',
      past: '%s sani',
      s: 'f sekund',
      ss: '%d sekundir',
      m: 'ein minuttur',
      mm: '%d minuttir',
      h: 'ein tmi',
      hh: '%d tmar',
      d: 'ein dagur',
      dd: '%d dagar',
      M: 'ein mnaur',
      MM: '%d mnair',
      y: 'eitt r',
      yy: '%d r'
    },
    dayOfMonthOrdinalParse: /\d{1,2}\./,
    ordinal: '%d.',
    week: {
      dow: 1,
      // Monday is the first day of the week.
      doy: 4 // The week that contains Jan 4th is the first week of the year.
    }
  });
  return fo;
});

/***/ }),
/* 153 */
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : French [fr]
//! author : John Fischer : https://github.com/jfroffice

;
(function (global, factory) {
   true ? factory(__webpack_require__(105)) : 0;
})(this, function (moment) {
  'use strict';

  //! moment.js locale configuration
  var monthsStrictRegex = /^(janvier|fvrier|mars|avril|mai|juin|juillet|aot|septembre|octobre|novembre|dcembre)/i,
    monthsShortStrictRegex = /(janv\.?|fvr\.?|mars|avr\.?|mai|juin|juil\.?|aot|sept\.?|oct\.?|nov\.?|dc\.?)/i,
    monthsRegex = /(janv\.?|fvr\.?|mars|avr\.?|mai|juin|juil\.?|aot|sept\.?|oct\.?|nov\.?|dc\.?|janvier|fvrier|mars|avril|mai|juin|juillet|aot|septembre|octobre|novembre|dcembre)/i,
    monthsParse = [/^janv/i, /^fvr/i, /^mars/i, /^avr/i, /^mai/i, /^juin/i, /^juil/i, /^aot/i, /^sept/i, /^oct/i, /^nov/i, /^dc/i];
  var fr = moment.defineLocale('fr', {
    months: 'janvier_fvrier_mars_avril_mai_juin_juillet_aot_septembre_octobre_novembre_dcembre'.split('_'),
    monthsShort: 'janv._fvr._mars_avr._mai_juin_juil._aot_sept._oct._nov._dc.'.split('_'),
    monthsRegex: monthsRegex,
    monthsShortRegex: monthsRegex,
    monthsStrictRegex: monthsStrictRegex,
    monthsShortStrictRegex: monthsShortStrictRegex,
    monthsParse: monthsParse,
    longMonthsParse: monthsParse,
    shortMonthsParse: monthsParse,
    weekdays: 'dimanche_lundi_mardi_mercredi_jeudi_vendredi_samedi'.split('_'),
    weekdaysShort: 'dim._lun._mar._mer._jeu._ven._sam.'.split('_'),
    weekdaysMin: 'di_lu_ma_me_je_ve_sa'.split('_'),
    weekdaysParseExact: true,
    longDateFormat: {
      LT: 'HH:mm',
      LTS: 'HH:mm:ss',
      L: 'DD/MM/YYYY',
      LL: 'D MMMM YYYY',
      LLL: 'D MMMM YYYY HH:mm',
      LLLL: 'dddd D MMMM YYYY HH:mm'
    },
    calendar: {
      sameDay: '[Aujourdhui ] LT',
      nextDay: '[Demain ] LT',
      nextWeek: 'dddd [] LT',
      lastDay: '[Hier ] LT',
      lastWeek: 'dddd [dernier ] LT',
      sameElse: 'L'
    },
    relativeTime: {
      future: 'dans %s',
      past: 'il y a %s',
      s: 'quelques secondes',
      ss: '%d secondes',
      m: 'une minute',
      mm: '%d minutes',
      h: 'une heure',
      hh: '%d heures',
      d: 'un jour',
      dd: '%d jours',
      w: 'une semaine',
      ww: '%d semaines',
      M: 'un mois',
      MM: '%d mois',
      y: 'un an',
      yy: '%d ans'
    },
    dayOfMonthOrdinalParse: /\d{1,2}(er|)/,
    ordinal: function (number, period) {
      switch (period) {
        // TODO: Return 'e' when day of month > 1. Move this case inside
        // block for masculine words below.
        // See https://github.com/moment/moment/issues/3375
        case 'D':
          return number + (number === 1 ? 'er' : '');

        // Words with masculine grammatical gender: mois, trimestre, jour
        default:
        case 'M':
        case 'Q':
        case 'DDD':
        case 'd':
          return number + (number === 1 ? 'er' : 'e');

        // Words with feminine grammatical gender: semaine
        case 'w':
        case 'W':
          return number + (number === 1 ? 're' : 'e');
      }
    },
    week: {
      dow: 1,
      // Monday is the first day of the week.
      doy: 4 // The week that contains Jan 4th is the first week of the year.
    }
  });
  return fr;
});

/***/ }),
/* 154 */
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : French (Canada) [fr-ca]
//! author : Jonathan Abourbih : https://github.com/jonbca

;
(function (global, factory) {
   true ? factory(__webpack_require__(105)) : 0;
})(this, function (moment) {
  'use strict';

  //! moment.js locale configuration
  var frCa = moment.defineLocale('fr-ca', {
    months: 'janvier_fvrier_mars_avril_mai_juin_juillet_aot_septembre_octobre_novembre_dcembre'.split('_'),
    monthsShort: 'janv._fvr._mars_avr._mai_juin_juil._aot_sept._oct._nov._dc.'.split('_'),
    monthsParseExact: true,
    weekdays: 'dimanche_lundi_mardi_mercredi_jeudi_vendredi_samedi'.split('_'),
    weekdaysShort: 'dim._lun._mar._mer._jeu._ven._sam.'.split('_'),
    weekdaysMin: 'di_lu_ma_me_je_ve_sa'.split('_'),
    weekdaysParseExact: true,
    longDateFormat: {
      LT: 'HH:mm',
      LTS: 'HH:mm:ss',
      L: 'YYYY-MM-DD',
      LL: 'D MMMM YYYY',
      LLL: 'D MMMM YYYY HH:mm',
      LLLL: 'dddd D MMMM YYYY HH:mm'
    },
    calendar: {
      sameDay: '[Aujourdhui ] LT',
      nextDay: '[Demain ] LT',
      nextWeek: 'dddd [] LT',
      lastDay: '[Hier ] LT',
      lastWeek: 'dddd [dernier ] LT',
      sameElse: 'L'
    },
    relativeTime: {
      future: 'dans %s',
      past: 'il y a %s',
      s: 'quelques secondes',
      ss: '%d secondes',
      m: 'une minute',
      mm: '%d minutes',
      h: 'une heure',
      hh: '%d heures',
      d: 'un jour',
      dd: '%d jours',
      M: 'un mois',
      MM: '%d mois',
      y: 'un an',
      yy: '%d ans'
    },
    dayOfMonthOrdinalParse: /\d{1,2}(er|e)/,
    ordinal: function (number, period) {
      switch (period) {
        // Words with masculine grammatical gender: mois, trimestre, jour
        default:
        case 'M':
        case 'Q':
        case 'D':
        case 'DDD':
        case 'd':
          return number + (number === 1 ? 'er' : 'e');

        // Words with feminine grammatical gender: semaine
        case 'w':
        case 'W':
          return number + (number === 1 ? 're' : 'e');
      }
    }
  });
  return frCa;
});

/***/ }),
/* 155 */
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : French (Switzerland) [fr-ch]
//! author : Gaspard Bucher : https://github.com/gaspard

;
(function (global, factory) {
   true ? factory(__webpack_require__(105)) : 0;
})(this, function (moment) {
  'use strict';

  //! moment.js locale configuration
  var frCh = moment.defineLocale('fr-ch', {
    months: 'janvier_fvrier_mars_avril_mai_juin_juillet_aot_septembre_octobre_novembre_dcembre'.split('_'),
    monthsShort: 'janv._fvr._mars_avr._mai_juin_juil._aot_sept._oct._nov._dc.'.split('_'),
    monthsParseExact: true,
    weekdays: 'dimanche_lundi_mardi_mercredi_jeudi_vendredi_samedi'.split('_'),
    weekdaysShort: 'dim._lun._mar._mer._jeu._ven._sam.'.split('_'),
    weekdaysMin: 'di_lu_ma_me_je_ve_sa'.split('_'),
    weekdaysParseExact: true,
    longDateFormat: {
      LT: 'HH:mm',
      LTS: 'HH:mm:ss',
      L: 'DD.MM.YYYY',
      LL: 'D MMMM YYYY',
      LLL: 'D MMMM YYYY HH:mm',
      LLLL: 'dddd D MMMM YYYY HH:mm'
    },
    calendar: {
      sameDay: '[Aujourdhui ] LT',
      nextDay: '[Demain ] LT',
      nextWeek: 'dddd [] LT',
      lastDay: '[Hier ] LT',
      lastWeek: 'dddd [dernier ] LT',
      sameElse: 'L'
    },
    relativeTime: {
      future: 'dans %s',
      past: 'il y a %s',
      s: 'quelques secondes',
      ss: '%d secondes',
      m: 'une minute',
      mm: '%d minutes',
      h: 'une heure',
      hh: '%d heures',
      d: 'un jour',
      dd: '%d jours',
      M: 'un mois',
      MM: '%d mois',
      y: 'un an',
      yy: '%d ans'
    },
    dayOfMonthOrdinalParse: /\d{1,2}(er|e)/,
    ordinal: function (number, period) {
      switch (period) {
        // Words with masculine grammatical gender: mois, trimestre, jour
        default:
        case 'M':
        case 'Q':
        case 'D':
        case 'DDD':
        case 'd':
          return number + (number === 1 ? 'er' : 'e');

        // Words with feminine grammatical gender: semaine
        case 'w':
        case 'W':
          return number + (number === 1 ? 're' : 'e');
      }
    },
    week: {
      dow: 1,
      // Monday is the first day of the week.
      doy: 4 // The week that contains Jan 4th is the first week of the year.
    }
  });
  return frCh;
});

/***/ }),
/* 156 */
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Frisian [fy]
//! author : Robin van der Vliet : https://github.com/robin0van0der0v

;
(function (global, factory) {
   true ? factory(__webpack_require__(105)) : 0;
})(this, function (moment) {
  'use strict';

  //! moment.js locale configuration
  var monthsShortWithDots = 'jan._feb._mrt._apr._mai_jun._jul._aug._sep._okt._nov._des.'.split('_'),
    monthsShortWithoutDots = 'jan_feb_mrt_apr_mai_jun_jul_aug_sep_okt_nov_des'.split('_');
  var fy = moment.defineLocale('fy', {
    months: 'jannewaris_febrewaris_maart_april_maaie_juny_july_augustus_septimber_oktober_novimber_desimber'.split('_'),
    monthsShort: function (m, format) {
      if (!m) {
        return monthsShortWithDots;
      } else if (/-MMM-/.test(format)) {
        return monthsShortWithoutDots[m.month()];
      } else {
        return monthsShortWithDots[m.month()];
      }
    },
    monthsParseExact: true,
    weekdays: 'snein_moandei_tiisdei_woansdei_tongersdei_freed_sneon'.split('_'),
    weekdaysShort: 'si._mo._ti._wo._to._fr._so.'.split('_'),
    weekdaysMin: 'Si_Mo_Ti_Wo_To_Fr_So'.split('_'),
    weekdaysParseExact: true,
    longDateFormat: {
      LT: 'HH:mm',
      LTS: 'HH:mm:ss',
      L: 'DD-MM-YYYY',
      LL: 'D MMMM YYYY',
      LLL: 'D MMMM YYYY HH:mm',
      LLLL: 'dddd D MMMM YYYY HH:mm'
    },
    calendar: {
      sameDay: '[hjoed om] LT',
      nextDay: '[moarn om] LT',
      nextWeek: 'dddd [om] LT',
      lastDay: '[juster om] LT',
      lastWeek: '[frne] dddd [om] LT',
      sameElse: 'L'
    },
    relativeTime: {
      future: 'oer %s',
      past: '%s lyn',
      s: 'in pear sekonden',
      ss: '%d sekonden',
      m: 'ien mint',
      mm: '%d minuten',
      h: 'ien oere',
      hh: '%d oeren',
      d: 'ien dei',
      dd: '%d dagen',
      M: 'ien moanne',
      MM: '%d moannen',
      y: 'ien jier',
      yy: '%d jierren'
    },
    dayOfMonthOrdinalParse: /\d{1,2}(ste|de)/,
    ordinal: function (number) {
      return number + (number === 1 || number === 8 || number >= 20 ? 'ste' : 'de');
    },
    week: {
      dow: 1,
      // Monday is the first day of the week.
      doy: 4 // The week that contains Jan 4th is the first week of the year.
    }
  });
  return fy;
});

/***/ }),
/* 157 */
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Irish or Irish Gaelic [ga]
//! author : Andr Silva : https://github.com/askpt

;
(function (global, factory) {
   true ? factory(__webpack_require__(105)) : 0;
})(this, function (moment) {
  'use strict';

  //! moment.js locale configuration
  var months = ['Eanir', 'Feabhra', 'Mrta', 'Aibren', 'Bealtaine', 'Meitheamh', 'Iil', 'Lnasa', 'Men Fmhair', 'Deireadh Fmhair', 'Samhain', 'Nollaig'],
    monthsShort = ['Ean', 'Feabh', 'Mrt', 'Aib', 'Beal', 'Meith', 'Iil', 'Ln', 'M.F.', 'D.F.', 'Samh', 'Noll'],
    weekdays = ['D Domhnaigh', 'D Luain', 'D Mirt', 'D Cadaoin', 'Dardaoin', 'D hAoine', 'D Sathairn'],
    weekdaysShort = ['Domh', 'Luan', 'Mirt', 'Cad', 'Dar', 'Aoine', 'Sath'],
    weekdaysMin = ['Do', 'Lu', 'M', 'C', 'D', 'A', 'Sa'];
  var ga = moment.defineLocale('ga', {
    months: months,
    monthsShort: monthsShort,
    monthsParseExact: true,
    weekdays: weekdays,
    weekdaysShort: weekdaysShort,
    weekdaysMin: weekdaysMin,
    longDateFormat: {
      LT: 'HH:mm',
      LTS: 'HH:mm:ss',
      L: 'DD/MM/YYYY',
      LL: 'D MMMM YYYY',
      LLL: 'D MMMM YYYY HH:mm',
      LLLL: 'dddd, D MMMM YYYY HH:mm'
    },
    calendar: {
      sameDay: '[Inniu ag] LT',
      nextDay: '[Amrach ag] LT',
      nextWeek: 'dddd [ag] LT',
      lastDay: '[Inn ag] LT',
      lastWeek: 'dddd [seo caite] [ag] LT',
      sameElse: 'L'
    },
    relativeTime: {
      future: 'i %s',
      past: '%s  shin',
      s: 'cpla soicind',
      ss: '%d soicind',
      m: 'nimad',
      mm: '%d nimad',
      h: 'uair an chloig',
      hh: '%d uair an chloig',
      d: 'l',
      dd: '%d l',
      M: 'm',
      MM: '%d monna',
      y: 'bliain',
      yy: '%d bliain'
    },
    dayOfMonthOrdinalParse: /\d{1,2}(d|na|mh)/,
    ordinal: function (number) {
      var output = number === 1 ? 'd' : number % 10 === 2 ? 'na' : 'mh';
      return number + output;
    },
    week: {
      dow: 1,
      // Monday is the first day of the week.
      doy: 4 // The week that contains Jan 4th is the first week of the year.
    }
  });
  return ga;
});

/***/ }),
/* 158 */
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Scottish Gaelic [gd]
//! author : Jon Ashdown : https://github.com/jonashdown

;
(function (global, factory) {
   true ? factory(__webpack_require__(105)) : 0;
})(this, function (moment) {
  'use strict';

  //! moment.js locale configuration
  var months = ['Am Faoilleach', 'An Gearran', 'Am Mrt', 'An Giblean', 'An Citean', 'An t-gmhios', 'An t-Iuchar', 'An Lnastal', 'An t-Sultain', 'An Dmhair', 'An t-Samhain', 'An Dbhlachd'],
    monthsShort = ['Faoi', 'Gear', 'Mrt', 'Gibl', 'Cit', 'gmh', 'Iuch', 'Ln', 'Sult', 'Dmh', 'Samh', 'Dbh'],
    weekdays = ['Didmhnaich', 'Diluain', 'Dimirt', 'Diciadain', 'Diardaoin', 'Dihaoine', 'Disathairne'],
    weekdaysShort = ['Did', 'Dil', 'Dim', 'Dic', 'Dia', 'Dih', 'Dis'],
    weekdaysMin = ['D', 'Lu', 'M', 'Ci', 'Ar', 'Ha', 'Sa'];
  var gd = moment.defineLocale('gd', {
    months: months,
    monthsShort: monthsShort,
    monthsParseExact: true,
    weekdays: weekdays,
    weekdaysShort: weekdaysShort,
    weekdaysMin: weekdaysMin,
    longDateFormat: {
      LT: 'HH:mm',
      LTS: 'HH:mm:ss',
      L: 'DD/MM/YYYY',
      LL: 'D MMMM YYYY',
      LLL: 'D MMMM YYYY HH:mm',
      LLLL: 'dddd, D MMMM YYYY HH:mm'
    },
    calendar: {
      sameDay: '[An-diugh aig] LT',
      nextDay: '[A-mireach aig] LT',
      nextWeek: 'dddd [aig] LT',
      lastDay: '[An-d aig] LT',
      lastWeek: 'dddd [seo chaidh] [aig] LT',
      sameElse: 'L'
    },
    relativeTime: {
      future: 'ann an %s',
      past: 'bho chionn %s',
      s: 'beagan diogan',
      ss: '%d diogan',
      m: 'mionaid',
      mm: '%d mionaidean',
      h: 'uair',
      hh: '%d uairean',
      d: 'latha',
      dd: '%d latha',
      M: 'mos',
      MM: '%d mosan',
      y: 'bliadhna',
      yy: '%d bliadhna'
    },
    dayOfMonthOrdinalParse: /\d{1,2}(d|na|mh)/,
    ordinal: function (number) {
      var output = number === 1 ? 'd' : number % 10 === 2 ? 'na' : 'mh';
      return number + output;
    },
    week: {
      dow: 1,
      // Monday is the first day of the week.
      doy: 4 // The week that contains Jan 4th is the first week of the year.
    }
  });
  return gd;
});

/***/ }),
/* 159 */
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Galician [gl]
//! author : Juan G. Hurtado : https://github.com/juanghurtado

;
(function (global, factory) {
   true ? factory(__webpack_require__(105)) : 0;
})(this, function (moment) {
  'use strict';

  //! moment.js locale configuration
  var gl = moment.defineLocale('gl', {
    months: 'xaneiro_febreiro_marzo_abril_maio_xuo_xullo_agosto_setembro_outubro_novembro_decembro'.split('_'),
    monthsShort: 'xan._feb._mar._abr._mai._xu._xul._ago._set._out._nov._dec.'.split('_'),
    monthsParseExact: true,
    weekdays: 'domingo_luns_martes_mrcores_xoves_venres_sbado'.split('_'),
    weekdaysShort: 'dom._lun._mar._mr._xov._ven._sb.'.split('_'),
    weekdaysMin: 'do_lu_ma_m_xo_ve_s'.split('_'),
    weekdaysParseExact: true,
    longDateFormat: {
      LT: 'H:mm',
      LTS: 'H:mm:ss',
      L: 'DD/MM/YYYY',
      LL: 'D [de] MMMM [de] YYYY',
      LLL: 'D [de] MMMM [de] YYYY H:mm',
      LLLL: 'dddd, D [de] MMMM [de] YYYY H:mm'
    },
    calendar: {
      sameDay: function () {
        return '[hoxe ' + (this.hours() !== 1 ? 's' : '') + '] LT';
      },
      nextDay: function () {
        return '[ma ' + (this.hours() !== 1 ? 's' : '') + '] LT';
      },
      nextWeek: function () {
        return 'dddd [' + (this.hours() !== 1 ? 's' : 'a') + '] LT';
      },
      lastDay: function () {
        return '[onte ' + (this.hours() !== 1 ? '' : 'a') + '] LT';
      },
      lastWeek: function () {
        return '[o] dddd [pasado ' + (this.hours() !== 1 ? 's' : 'a') + '] LT';
      },
      sameElse: 'L'
    },
    relativeTime: {
      future: function (str) {
        if (str.indexOf('un') === 0) {
          return 'n' + str;
        }
        return 'en ' + str;
      },
      past: 'hai %s',
      s: 'uns segundos',
      ss: '%d segundos',
      m: 'un minuto',
      mm: '%d minutos',
      h: 'unha hora',
      hh: '%d horas',
      d: 'un da',
      dd: '%d das',
      M: 'un mes',
      MM: '%d meses',
      y: 'un ano',
      yy: '%d anos'
    },
    dayOfMonthOrdinalParse: /\d{1,2}/,
    ordinal: '%d',
    week: {
      dow: 1,
      // Monday is the first day of the week.
      doy: 4 // The week that contains Jan 4th is the first week of the year.
    }
  });
  return gl;
});

/***/ }),
/* 160 */
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Konkani Devanagari script [gom-deva]
//! author : The Discoverer : https://github.com/WikiDiscoverer

;
(function (global, factory) {
   true ? factory(__webpack_require__(105)) : 0;
})(this, function (moment) {
  'use strict';

  //! moment.js locale configuration
  function processRelativeTime(number, withoutSuffix, key, isFuture) {
    var format = {
      s: [' ', ' '],
      ss: [number + ' ', number + ' '],
      m: [' ', ' '],
      mm: [number + ' ', number + ' '],
      h: [' ', ' '],
      hh: [number + ' ', number + ' '],
      d: [' ', ' '],
      dd: [number + ' ', number + ' '],
      M: [' ', ' '],
      MM: [number + ' ', number + ' '],
      y: [' ', ' '],
      yy: [number + ' ', number + ' ']
    };
    return isFuture ? format[key][0] : format[key][1];
  }
  var gomDeva = moment.defineLocale('gom-deva', {
    months: {
      standalone: '___________'.split('_'),
      format: '___________'.split('_'),
      isFormat: /MMMM(\s)+D[oD]?/
    },
    monthsShort: '._.__.___._._._._._.'.split('_'),
    monthsParseExact: true,
    weekdays: '______'.split('_'),
    weekdaysShort: '._._._._._._.'.split('_'),
    weekdaysMin: '______'.split('_'),
    weekdaysParseExact: true,
    longDateFormat: {
      LT: 'A h:mm []',
      LTS: 'A h:mm:ss []',
      L: 'DD-MM-YYYY',
      LL: 'D MMMM YYYY',
      LLL: 'D MMMM YYYY A h:mm []',
      LLLL: 'dddd, MMMM Do, YYYY, A h:mm []',
      llll: 'ddd, D MMM YYYY, A h:mm []'
    },
    calendar: {
      sameDay: '[] LT',
      nextDay: '[] LT',
      nextWeek: '[] dddd[,] LT',
      lastDay: '[] LT',
      lastWeek: '[] dddd[,] LT',
      sameElse: 'L'
    },
    relativeTime: {
      future: '%s',
      past: '%s ',
      s: processRelativeTime,
      ss: processRelativeTime,
      m: processRelativeTime,
      mm: processRelativeTime,
      h: processRelativeTime,
      hh: processRelativeTime,
      d: processRelativeTime,
      dd: processRelativeTime,
      M: processRelativeTime,
      MM: processRelativeTime,
      y: processRelativeTime,
      yy: processRelativeTime
    },
    dayOfMonthOrdinalParse: /\d{1,2}()/,
    ordinal: function (number, period) {
      switch (period) {
        // the ordinal '' only applies to day of the month
        case 'D':
          return number + '';
        default:
        case 'M':
        case 'Q':
        case 'DDD':
        case 'd':
        case 'w':
        case 'W':
          return number;
      }
    },
    week: {
      dow: 0,
      // Sunday is the first day of the week
      doy: 3 // The week that contains Jan 4th is the first week of the year (7 + 0 - 4)
    },
    meridiemParse: /|||/,
    meridiemHour: function (hour, meridiem) {
      if (hour === 12) {
        hour = 0;
      }
      if (meridiem === '') {
        return hour < 4 ? hour : hour + 12;
      } else if (meridiem === '') {
        return hour;
      } else if (meridiem === '') {
        return hour > 12 ? hour : hour + 12;
      } else if (meridiem === '') {
        return hour + 12;
      }
    },
    meridiem: function (hour, minute, isLower) {
      if (hour < 4) {
        return '';
      } else if (hour < 12) {
        return '';
      } else if (hour < 16) {
        return '';
      } else if (hour < 20) {
        return '';
      } else {
        return '';
      }
    }
  });
  return gomDeva;
});

/***/ }),
/* 161 */
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Konkani Latin script [gom-latn]
//! author : The Discoverer : https://github.com/WikiDiscoverer

;
(function (global, factory) {
   true ? factory(__webpack_require__(105)) : 0;
})(this, function (moment) {
  'use strict';

  //! moment.js locale configuration
  function processRelativeTime(number, withoutSuffix, key, isFuture) {
    var format = {
      s: ['thoddea sekondamni', 'thodde sekond'],
      ss: [number + ' sekondamni', number + ' sekond'],
      m: ['eka mintan', 'ek minut'],
      mm: [number + ' mintamni', number + ' mintam'],
      h: ['eka voran', 'ek vor'],
      hh: [number + ' voramni', number + ' voram'],
      d: ['eka disan', 'ek dis'],
      dd: [number + ' disamni', number + ' dis'],
      M: ['eka mhoinean', 'ek mhoino'],
      MM: [number + ' mhoineamni', number + ' mhoine'],
      y: ['eka vorsan', 'ek voros'],
      yy: [number + ' vorsamni', number + ' vorsam']
    };
    return isFuture ? format[key][0] : format[key][1];
  }
  var gomLatn = moment.defineLocale('gom-latn', {
    months: {
      standalone: 'Janer_Febrer_Mars_Abril_Mai_Jun_Julai_Agost_Setembr_Otubr_Novembr_Dezembr'.split('_'),
      format: 'Janerachea_Febrerachea_Marsachea_Abrilachea_Maiachea_Junachea_Julaiachea_Agostachea_Setembrachea_Otubrachea_Novembrachea_Dezembrachea'.split('_'),
      isFormat: /MMMM(\s)+D[oD]?/
    },
    monthsShort: 'Jan._Feb._Mars_Abr._Mai_Jun_Jul._Ago._Set._Otu._Nov._Dez.'.split('_'),
    monthsParseExact: true,
    weekdays: "Aitar_Somar_Mongllar_Budhvar_Birestar_Sukrar_Son'var".split('_'),
    weekdaysShort: 'Ait._Som._Mon._Bud._Bre._Suk._Son.'.split('_'),
    weekdaysMin: 'Ai_Sm_Mo_Bu_Br_Su_Sn'.split('_'),
    weekdaysParseExact: true,
    longDateFormat: {
      LT: 'A h:mm [vazta]',
      LTS: 'A h:mm:ss [vazta]',
      L: 'DD-MM-YYYY',
      LL: 'D MMMM YYYY',
      LLL: 'D MMMM YYYY A h:mm [vazta]',
      LLLL: 'dddd, MMMM Do, YYYY, A h:mm [vazta]',
      llll: 'ddd, D MMM YYYY, A h:mm [vazta]'
    },
    calendar: {
      sameDay: '[Aiz] LT',
      nextDay: '[Faleam] LT',
      nextWeek: '[Fuddlo] dddd[,] LT',
      lastDay: '[Kal] LT',
      lastWeek: '[Fattlo] dddd[,] LT',
      sameElse: 'L'
    },
    relativeTime: {
      future: '%s',
      past: '%s adim',
      s: processRelativeTime,
      ss: processRelativeTime,
      m: processRelativeTime,
      mm: processRelativeTime,
      h: processRelativeTime,
      hh: processRelativeTime,
      d: processRelativeTime,
      dd: processRelativeTime,
      M: processRelativeTime,
      MM: processRelativeTime,
      y: processRelativeTime,
      yy: processRelativeTime
    },
    dayOfMonthOrdinalParse: /\d{1,2}(er)/,
    ordinal: function (number, period) {
      switch (period) {
        // the ordinal 'er' only applies to day of the month
        case 'D':
          return number + 'er';
        default:
        case 'M':
        case 'Q':
        case 'DDD':
        case 'd':
        case 'w':
        case 'W':
          return number;
      }
    },
    week: {
      dow: 0,
      // Sunday is the first day of the week
      doy: 3 // The week that contains Jan 4th is the first week of the year (7 + 0 - 4)
    },
    meridiemParse: /rati|sokallim|donparam|sanje/,
    meridiemHour: function (hour, meridiem) {
      if (hour === 12) {
        hour = 0;
      }
      if (meridiem === 'rati') {
        return hour < 4 ? hour : hour + 12;
      } else if (meridiem === 'sokallim') {
        return hour;
      } else if (meridiem === 'donparam') {
        return hour > 12 ? hour : hour + 12;
      } else if (meridiem === 'sanje') {
        return hour + 12;
      }
    },
    meridiem: function (hour, minute, isLower) {
      if (hour < 4) {
        return 'rati';
      } else if (hour < 12) {
        return 'sokallim';
      } else if (hour < 16) {
        return 'donparam';
      } else if (hour < 20) {
        return 'sanje';
      } else {
        return 'rati';
      }
    }
  });
  return gomLatn;
});

/***/ }),
/* 162 */
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Gujarati [gu]
//! author : Kaushik Thanki : https://github.com/Kaushik1987

;
(function (global, factory) {
   true ? factory(__webpack_require__(105)) : 0;
})(this, function (moment) {
  'use strict';

  //! moment.js locale configuration
  var symbolMap = {
      1: '',
      2: '',
      3: '',
      4: '',
      5: '',
      6: '',
      7: '',
      8: '',
      9: '',
      0: ''
    },
    numberMap = {
      '': '1',
      '': '2',
      '': '3',
      '': '4',
      '': '5',
      '': '6',
      '': '7',
      '': '8',
      '': '9',
      '': '0'
    };
  var gu = moment.defineLocale('gu', {
    months: '___________'.split('_'),
    monthsShort: '._.__.___._._._._._.'.split('_'),
    monthsParseExact: true,
    weekdays: '______'.split('_'),
    weekdaysShort: '______'.split('_'),
    weekdaysMin: '______'.split('_'),
    longDateFormat: {
      LT: 'A h:mm ',
      LTS: 'A h:mm:ss ',
      L: 'DD/MM/YYYY',
      LL: 'D MMMM YYYY',
      LLL: 'D MMMM YYYY, A h:mm ',
      LLLL: 'dddd, D MMMM YYYY, A h:mm '
    },
    calendar: {
      sameDay: '[] LT',
      nextDay: '[] LT',
      nextWeek: 'dddd, LT',
      lastDay: '[] LT',
      lastWeek: '[] dddd, LT',
      sameElse: 'L'
    },
    relativeTime: {
      future: '%s ',
      past: '%s ',
      s: ' ',
      ss: '%d ',
      m: ' ',
      mm: '%d ',
      h: ' ',
      hh: '%d ',
      d: ' ',
      dd: '%d ',
      M: ' ',
      MM: '%d ',
      y: ' ',
      yy: '%d '
    },
    preparse: function (string) {
      return string.replace(/[]/g, function (match) {
        return numberMap[match];
      });
    },
    postformat: function (string) {
      return string.replace(/\d/g, function (match) {
        return symbolMap[match];
      });
    },
    // Gujarati notation for meridiems are quite fuzzy in practice. While there exists
    // a rigid notion of a 'Pahar' it is not used as rigidly in modern Gujarati.
    meridiemParse: /|||/,
    meridiemHour: function (hour, meridiem) {
      if (hour === 12) {
        hour = 0;
      }
      if (meridiem === '') {
        return hour < 4 ? hour : hour + 12;
      } else if (meridiem === '') {
        return hour;
      } else if (meridiem === '') {
        return hour >= 10 ? hour : hour + 12;
      } else if (meridiem === '') {
        return hour + 12;
      }
    },
    meridiem: function (hour, minute, isLower) {
      if (hour < 4) {
        return '';
      } else if (hour < 10) {
        return '';
      } else if (hour < 17) {
        return '';
      } else if (hour < 20) {
        return '';
      } else {
        return '';
      }
    },
    week: {
      dow: 0,
      // Sunday is the first day of the week.
      doy: 6 // The week that contains Jan 6th is the first week of the year.
    }
  });
  return gu;
});

/***/ }),
/* 163 */
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Hebrew [he]
//! author : Tomer Cohen : https://github.com/tomer
//! author : Moshe Simantov : https://github.com/DevelopmentIL
//! author : Tal Ater : https://github.com/TalAter

;
(function (global, factory) {
   true ? factory(__webpack_require__(105)) : 0;
})(this, function (moment) {
  'use strict';

  //! moment.js locale configuration
  var he = moment.defineLocale('he', {
    months: '___________'.split('_'),
    monthsShort: '___________'.split('_'),
    weekdays: '______'.split('_'),
    weekdaysShort: '______'.split('_'),
    weekdaysMin: '______'.split('_'),
    longDateFormat: {
      LT: 'HH:mm',
      LTS: 'HH:mm:ss',
      L: 'DD/MM/YYYY',
      LL: 'D []MMMM YYYY',
      LLL: 'D []MMMM YYYY HH:mm',
      LLLL: 'dddd, D []MMMM YYYY HH:mm',
      l: 'D/M/YYYY',
      ll: 'D MMM YYYY',
      lll: 'D MMM YYYY HH:mm',
      llll: 'ddd, D MMM YYYY HH:mm'
    },
    calendar: {
      sameDay: '[ ]LT',
      nextDay: '[ ]LT',
      nextWeek: 'dddd [] LT',
      lastDay: '[ ]LT',
      lastWeek: '[] dddd [ ] LT',
      sameElse: 'L'
    },
    relativeTime: {
      future: ' %s',
      past: ' %s',
      s: ' ',
      ss: '%d ',
      m: '',
      mm: '%d ',
      h: '',
      hh: function (number) {
        if (number === 2) {
          return '';
        }
        return number + ' ';
      },
      d: '',
      dd: function (number) {
        if (number === 2) {
          return '';
        }
        return number + ' ';
      },
      M: '',
      MM: function (number) {
        if (number === 2) {
          return '';
        }
        return number + ' ';
      },
      y: '',
      yy: function (number) {
        if (number === 2) {
          return '';
        } else if (number % 10 === 0 && number !== 10) {
          return number + ' ';
        }
        return number + ' ';
      }
    },
    meridiemParse: /"|"| | | ||/i,
    isPM: function (input) {
      return /^("| |)$/.test(input);
    },
    meridiem: function (hour, minute, isLower) {
      if (hour < 5) {
        return ' ';
      } else if (hour < 10) {
        return '';
      } else if (hour < 12) {
        return isLower ? '"' : ' ';
      } else if (hour < 18) {
        return isLower ? '"' : ' ';
      } else {
        return '';
      }
    }
  });
  return he;
});

/***/ }),
/* 164 */
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Hindi [hi]
//! author : Mayank Singhal : https://github.com/mayanksinghal

;
(function (global, factory) {
   true ? factory(__webpack_require__(105)) : 0;
})(this, function (moment) {
  'use strict';

  //! moment.js locale configuration
  var symbolMap = {
      1: '',
      2: '',
      3: '',
      4: '',
      5: '',
      6: '',
      7: '',
      8: '',
      9: '',
      0: ''
    },
    numberMap = {
      '': '1',
      '': '2',
      '': '3',
      '': '4',
      '': '5',
      '': '6',
      '': '7',
      '': '8',
      '': '9',
      '': '0'
    },
    monthsParse = [/^/i, /^|/i, /^/i, /^/i, /^/i, /^/i, /^/i, /^/i, /^|/i, /^/i, /^|/i, /^|/i],
    shortMonthsParse = [/^/i, /^/i, /^/i, /^/i, /^/i, /^/i, /^/i, /^/i, /^/i, /^/i, /^/i, /^/i];
  var hi = moment.defineLocale('hi', {
    months: {
      format: '___________'.split('_'),
      standalone: '___________'.split('_')
    },
    monthsShort: '._.__.___._._._._._.'.split('_'),
    weekdays: '______'.split('_'),
    weekdaysShort: '______'.split('_'),
    weekdaysMin: '______'.split('_'),
    longDateFormat: {
      LT: 'A h:mm ',
      LTS: 'A h:mm:ss ',
      L: 'DD/MM/YYYY',
      LL: 'D MMMM YYYY',
      LLL: 'D MMMM YYYY, A h:mm ',
      LLLL: 'dddd, D MMMM YYYY, A h:mm '
    },
    monthsParse: monthsParse,
    longMonthsParse: monthsParse,
    shortMonthsParse: shortMonthsParse,
    monthsRegex: /^(|\.?|||\.?|?||\.?|?|?||\.?||\.?|||\.?||\.?|||\.?|||\.?)/i,
    monthsShortRegex: /^(|\.?|||\.?|?||\.?|?|?||\.?||\.?|||\.?||\.?|||\.?|||\.?)/i,
    monthsStrictRegex: /^(?||?|?|?|?|?|?|?|||?\.?||\.?||?||?)/i,
    monthsShortStrictRegex: /^(\.?|\.?|?|\.?|?|?|\.?|\.?|\.?|\.?|\.?|\.?)/i,
    calendar: {
      sameDay: '[] LT',
      nextDay: '[] LT',
      nextWeek: 'dddd, LT',
      lastDay: '[] LT',
      lastWeek: '[] dddd, LT',
      sameElse: 'L'
    },
    relativeTime: {
      future: '%s ',
      past: '%s ',
      s: '  ',
      ss: '%d ',
      m: ' ',
      mm: '%d ',
      h: ' ',
      hh: '%d ',
      d: ' ',
      dd: '%d ',
      M: ' ',
      MM: '%d ',
      y: ' ',
      yy: '%d '
    },
    preparse: function (string) {
      return string.replace(/[]/g, function (match) {
        return numberMap[match];
      });
    },
    postformat: function (string) {
      return string.replace(/\d/g, function (match) {
        return symbolMap[match];
      });
    },
    // Hindi notation for meridiems are quite fuzzy in practice. While there exists
    // a rigid notion of a 'Pahar' it is not used as rigidly in modern Hindi.
    meridiemParse: /|||/,
    meridiemHour: function (hour, meridiem) {
      if (hour === 12) {
        hour = 0;
      }
      if (meridiem === '') {
        return hour < 4 ? hour : hour + 12;
      } else if (meridiem === '') {
        return hour;
      } else if (meridiem === '') {
        return hour >= 10 ? hour : hour + 12;
      } else if (meridiem === '') {
        return hour + 12;
      }
    },
    meridiem: function (hour, minute, isLower) {
      if (hour < 4) {
        return '';
      } else if (hour < 10) {
        return '';
      } else if (hour < 17) {
        return '';
      } else if (hour < 20) {
        return '';
      } else {
        return '';
      }
    },
    week: {
      dow: 0,
      // Sunday is the first day of the week.
      doy: 6 // The week that contains Jan 6th is the first week of the year.
    }
  });
  return hi;
});

/***/ }),
/* 165 */
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Croatian [hr]
//! author : Bojan Markovi : https://github.com/bmarkovic

;
(function (global, factory) {
   true ? factory(__webpack_require__(105)) : 0;
})(this, function (moment) {
  'use strict';

  //! moment.js locale configuration
  function translate(number, withoutSuffix, key) {
    var result = number + ' ';
    switch (key) {
      case 'ss':
        if (number === 1) {
          result += 'sekunda';
        } else if (number === 2 || number === 3 || number === 4) {
          result += 'sekunde';
        } else {
          result += 'sekundi';
        }
        return result;
      case 'm':
        return withoutSuffix ? 'jedna minuta' : 'jedne minute';
      case 'mm':
        if (number === 1) {
          result += 'minuta';
        } else if (number === 2 || number === 3 || number === 4) {
          result += 'minute';
        } else {
          result += 'minuta';
        }
        return result;
      case 'h':
        return withoutSuffix ? 'jedan sat' : 'jednog sata';
      case 'hh':
        if (number === 1) {
          result += 'sat';
        } else if (number === 2 || number === 3 || number === 4) {
          result += 'sata';
        } else {
          result += 'sati';
        }
        return result;
      case 'dd':
        if (number === 1) {
          result += 'dan';
        } else {
          result += 'dana';
        }
        return result;
      case 'MM':
        if (number === 1) {
          result += 'mjesec';
        } else if (number === 2 || number === 3 || number === 4) {
          result += 'mjeseca';
        } else {
          result += 'mjeseci';
        }
        return result;
      case 'yy':
        if (number === 1) {
          result += 'godina';
        } else if (number === 2 || number === 3 || number === 4) {
          result += 'godine';
        } else {
          result += 'godina';
        }
        return result;
    }
  }
  var hr = moment.defineLocale('hr', {
    months: {
      format: 'sijenja_veljae_oujka_travnja_svibnja_lipnja_srpnja_kolovoza_rujna_listopada_studenoga_prosinca'.split('_'),
      standalone: 'sijeanj_veljaa_oujak_travanj_svibanj_lipanj_srpanj_kolovoz_rujan_listopad_studeni_prosinac'.split('_')
    },
    monthsShort: 'sij._velj._ou._tra._svi._lip._srp._kol._ruj._lis._stu._pro.'.split('_'),
    monthsParseExact: true,
    weekdays: 'nedjelja_ponedjeljak_utorak_srijeda_etvrtak_petak_subota'.split('_'),
    weekdaysShort: 'ned._pon._uto._sri._et._pet._sub.'.split('_'),
    weekdaysMin: 'ne_po_ut_sr_e_pe_su'.split('_'),
    weekdaysParseExact: true,
    longDateFormat: {
      LT: 'H:mm',
      LTS: 'H:mm:ss',
      L: 'DD.MM.YYYY',
      LL: 'Do MMMM YYYY',
      LLL: 'Do MMMM YYYY H:mm',
      LLLL: 'dddd, Do MMMM YYYY H:mm'
    },
    calendar: {
      sameDay: '[danas u] LT',
      nextDay: '[sutra u] LT',
      nextWeek: function () {
        switch (this.day()) {
          case 0:
            return '[u] [nedjelju] [u] LT';
          case 3:
            return '[u] [srijedu] [u] LT';
          case 6:
            return '[u] [subotu] [u] LT';
          case 1:
          case 2:
          case 4:
          case 5:
            return '[u] dddd [u] LT';
        }
      },
      lastDay: '[juer u] LT',
      lastWeek: function () {
        switch (this.day()) {
          case 0:
            return '[prolu] [nedjelju] [u] LT';
          case 3:
            return '[prolu] [srijedu] [u] LT';
          case 6:
            return '[prole] [subote] [u] LT';
          case 1:
          case 2:
          case 4:
          case 5:
            return '[proli] dddd [u] LT';
        }
      },
      sameElse: 'L'
    },
    relativeTime: {
      future: 'za %s',
      past: 'prije %s',
      s: 'par sekundi',
      ss: translate,
      m: translate,
      mm: translate,
      h: translate,
      hh: translate,
      d: 'dan',
      dd: translate,
      M: 'mjesec',
      MM: translate,
      y: 'godinu',
      yy: translate
    },
    dayOfMonthOrdinalParse: /\d{1,2}\./,
    ordinal: '%d.',
    week: {
      dow: 1,
      // Monday is the first day of the week.
      doy: 7 // The week that contains Jan 7th is the first week of the year.
    }
  });
  return hr;
});

/***/ }),
/* 166 */
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Hungarian [hu]
//! author : Adam Brunner : https://github.com/adambrunner
//! author : Peter Viszt  : https://github.com/passatgt

;
(function (global, factory) {
   true ? factory(__webpack_require__(105)) : 0;
})(this, function (moment) {
  'use strict';

  //! moment.js locale configuration
  var weekEndings = 'vasrnap htfn kedden szerdn cstrtkn pnteken szombaton'.split(' ');
  function translate(number, withoutSuffix, key, isFuture) {
    var num = number;
    switch (key) {
      case 's':
        return isFuture || withoutSuffix ? 'nhny msodperc' : 'nhny msodperce';
      case 'ss':
        return num + (isFuture || withoutSuffix) ? ' msodperc' : ' msodperce';
      case 'm':
        return 'egy' + (isFuture || withoutSuffix ? ' perc' : ' perce');
      case 'mm':
        return num + (isFuture || withoutSuffix ? ' perc' : ' perce');
      case 'h':
        return 'egy' + (isFuture || withoutSuffix ? ' ra' : ' rja');
      case 'hh':
        return num + (isFuture || withoutSuffix ? ' ra' : ' rja');
      case 'd':
        return 'egy' + (isFuture || withoutSuffix ? ' nap' : ' napja');
      case 'dd':
        return num + (isFuture || withoutSuffix ? ' nap' : ' napja');
      case 'M':
        return 'egy' + (isFuture || withoutSuffix ? ' hnap' : ' hnapja');
      case 'MM':
        return num + (isFuture || withoutSuffix ? ' hnap' : ' hnapja');
      case 'y':
        return 'egy' + (isFuture || withoutSuffix ? ' v' : ' ve');
      case 'yy':
        return num + (isFuture || withoutSuffix ? ' v' : ' ve');
    }
    return '';
  }
  function week(isFuture) {
    return (isFuture ? '' : '[mlt] ') + '[' + weekEndings[this.day()] + '] LT[-kor]';
  }
  var hu = moment.defineLocale('hu', {
    months: 'janur_februr_mrcius_prilis_mjus_jnius_jlius_augusztus_szeptember_oktber_november_december'.split('_'),
    monthsShort: 'jan._feb._mrc._pr._mj._jn._jl._aug._szept._okt._nov._dec.'.split('_'),
    monthsParseExact: true,
    weekdays: 'vasrnap_htf_kedd_szerda_cstrtk_pntek_szombat'.split('_'),
    weekdaysShort: 'vas_ht_kedd_sze_cst_pn_szo'.split('_'),
    weekdaysMin: 'v_h_k_sze_cs_p_szo'.split('_'),
    longDateFormat: {
      LT: 'H:mm',
      LTS: 'H:mm:ss',
      L: 'YYYY.MM.DD.',
      LL: 'YYYY. MMMM D.',
      LLL: 'YYYY. MMMM D. H:mm',
      LLLL: 'YYYY. MMMM D., dddd H:mm'
    },
    meridiemParse: /de|du/i,
    isPM: function (input) {
      return input.charAt(1).toLowerCase() === 'u';
    },
    meridiem: function (hours, minutes, isLower) {
      if (hours < 12) {
        return isLower === true ? 'de' : 'DE';
      } else {
        return isLower === true ? 'du' : 'DU';
      }
    },
    calendar: {
      sameDay: '[ma] LT[-kor]',
      nextDay: '[holnap] LT[-kor]',
      nextWeek: function () {
        return week.call(this, true);
      },
      lastDay: '[tegnap] LT[-kor]',
      lastWeek: function () {
        return week.call(this, false);
      },
      sameElse: 'L'
    },
    relativeTime: {
      future: '%s mlva',
      past: '%s',
      s: translate,
      ss: translate,
      m: translate,
      mm: translate,
      h: translate,
      hh: translate,
      d: translate,
      dd: translate,
      M: translate,
      MM: translate,
      y: translate,
      yy: translate
    },
    dayOfMonthOrdinalParse: /\d{1,2}\./,
    ordinal: '%d.',
    week: {
      dow: 1,
      // Monday is the first day of the week.
      doy: 4 // The week that contains Jan 4th is the first week of the year.
    }
  });
  return hu;
});

/***/ }),
/* 167 */
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Armenian [hy-am]
//! author : Armendarabyan : https://github.com/armendarabyan

;
(function (global, factory) {
   true ? factory(__webpack_require__(105)) : 0;
})(this, function (moment) {
  'use strict';

  //! moment.js locale configuration
  var hyAm = moment.defineLocale('hy-am', {
    months: {
      format: '___________'.split('_'),
      standalone: '___________'.split('_')
    },
    monthsShort: '___________'.split('_'),
    weekdays: '______'.split('_'),
    weekdaysShort: '______'.split('_'),
    weekdaysMin: '______'.split('_'),
    longDateFormat: {
      LT: 'HH:mm',
      LTS: 'HH:mm:ss',
      L: 'DD.MM.YYYY',
      LL: 'D MMMM YYYY .',
      LLL: 'D MMMM YYYY ., HH:mm',
      LLLL: 'dddd, D MMMM YYYY ., HH:mm'
    },
    calendar: {
      sameDay: '[] LT',
      nextDay: '[] LT',
      lastDay: '[] LT',
      nextWeek: function () {
        return 'dddd [ ] LT';
      },
      lastWeek: function () {
        return '[] dddd [ ] LT';
      },
      sameElse: 'L'
    },
    relativeTime: {
      future: '%s ',
      past: '%s ',
      s: '  ',
      ss: '%d ',
      m: '',
      mm: '%d ',
      h: '',
      hh: '%d ',
      d: '',
      dd: '%d ',
      M: '',
      MM: '%d ',
      y: '',
      yy: '%d '
    },
    meridiemParse: /|||/,
    isPM: function (input) {
      return /^(|)$/.test(input);
    },
    meridiem: function (hour) {
      if (hour < 4) {
        return '';
      } else if (hour < 12) {
        return '';
      } else if (hour < 17) {
        return '';
      } else {
        return '';
      }
    },
    dayOfMonthOrdinalParse: /\d{1,2}|\d{1,2}-(|)/,
    ordinal: function (number, period) {
      switch (period) {
        case 'DDD':
        case 'w':
        case 'W':
        case 'DDDo':
          if (number === 1) {
            return number + '-';
          }
          return number + '-';
        default:
          return number;
      }
    },
    week: {
      dow: 1,
      // Monday is the first day of the week.
      doy: 7 // The week that contains Jan 7th is the first week of the year.
    }
  });
  return hyAm;
});

/***/ }),
/* 168 */
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Indonesian [id]
//! author : Mohammad Satrio Utomo : https://github.com/tyok
//! reference: http://id.wikisource.org/wiki/Pedoman_Umum_Ejaan_Bahasa_Indonesia_yang_Disempurnakan

;
(function (global, factory) {
   true ? factory(__webpack_require__(105)) : 0;
})(this, function (moment) {
  'use strict';

  //! moment.js locale configuration
  var id = moment.defineLocale('id', {
    months: 'Januari_Februari_Maret_April_Mei_Juni_Juli_Agustus_September_Oktober_November_Desember'.split('_'),
    monthsShort: 'Jan_Feb_Mar_Apr_Mei_Jun_Jul_Agt_Sep_Okt_Nov_Des'.split('_'),
    weekdays: 'Minggu_Senin_Selasa_Rabu_Kamis_Jumat_Sabtu'.split('_'),
    weekdaysShort: 'Min_Sen_Sel_Rab_Kam_Jum_Sab'.split('_'),
    weekdaysMin: 'Mg_Sn_Sl_Rb_Km_Jm_Sb'.split('_'),
    longDateFormat: {
      LT: 'HH.mm',
      LTS: 'HH.mm.ss',
      L: 'DD/MM/YYYY',
      LL: 'D MMMM YYYY',
      LLL: 'D MMMM YYYY [pukul] HH.mm',
      LLLL: 'dddd, D MMMM YYYY [pukul] HH.mm'
    },
    meridiemParse: /pagi|siang|sore|malam/,
    meridiemHour: function (hour, meridiem) {
      if (hour === 12) {
        hour = 0;
      }
      if (meridiem === 'pagi') {
        return hour;
      } else if (meridiem === 'siang') {
        return hour >= 11 ? hour : hour + 12;
      } else if (meridiem === 'sore' || meridiem === 'malam') {
        return hour + 12;
      }
    },
    meridiem: function (hours, minutes, isLower) {
      if (hours < 11) {
        return 'pagi';
      } else if (hours < 15) {
        return 'siang';
      } else if (hours < 19) {
        return 'sore';
      } else {
        return 'malam';
      }
    },
    calendar: {
      sameDay: '[Hari ini pukul] LT',
      nextDay: '[Besok pukul] LT',
      nextWeek: 'dddd [pukul] LT',
      lastDay: '[Kemarin pukul] LT',
      lastWeek: 'dddd [lalu pukul] LT',
      sameElse: 'L'
    },
    relativeTime: {
      future: 'dalam %s',
      past: '%s yang lalu',
      s: 'beberapa detik',
      ss: '%d detik',
      m: 'semenit',
      mm: '%d menit',
      h: 'sejam',
      hh: '%d jam',
      d: 'sehari',
      dd: '%d hari',
      M: 'sebulan',
      MM: '%d bulan',
      y: 'setahun',
      yy: '%d tahun'
    },
    week: {
      dow: 0,
      // Sunday is the first day of the week.
      doy: 6 // The week that contains Jan 6th is the first week of the year.
    }
  });
  return id;
});

/***/ }),
/* 169 */
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Icelandic [is]
//! author : Hinrik rn Sigursson : https://github.com/hinrik

;
(function (global, factory) {
   true ? factory(__webpack_require__(105)) : 0;
})(this, function (moment) {
  'use strict';

  //! moment.js locale configuration
  function plural(n) {
    if (n % 100 === 11) {
      return true;
    } else if (n % 10 === 1) {
      return false;
    }
    return true;
  }
  function translate(number, withoutSuffix, key, isFuture) {
    var result = number + ' ';
    switch (key) {
      case 's':
        return withoutSuffix || isFuture ? 'nokkrar sekndur' : 'nokkrum sekndum';
      case 'ss':
        if (plural(number)) {
          return result + (withoutSuffix || isFuture ? 'sekndur' : 'sekndum');
        }
        return result + 'seknda';
      case 'm':
        return withoutSuffix ? 'mnta' : 'mntu';
      case 'mm':
        if (plural(number)) {
          return result + (withoutSuffix || isFuture ? 'mntur' : 'mntum');
        } else if (withoutSuffix) {
          return result + 'mnta';
        }
        return result + 'mntu';
      case 'hh':
        if (plural(number)) {
          return result + (withoutSuffix || isFuture ? 'klukkustundir' : 'klukkustundum');
        }
        return result + 'klukkustund';
      case 'd':
        if (withoutSuffix) {
          return 'dagur';
        }
        return isFuture ? 'dag' : 'degi';
      case 'dd':
        if (plural(number)) {
          if (withoutSuffix) {
            return result + 'dagar';
          }
          return result + (isFuture ? 'daga' : 'dgum');
        } else if (withoutSuffix) {
          return result + 'dagur';
        }
        return result + (isFuture ? 'dag' : 'degi');
      case 'M':
        if (withoutSuffix) {
          return 'mnuur';
        }
        return isFuture ? 'mnu' : 'mnui';
      case 'MM':
        if (plural(number)) {
          if (withoutSuffix) {
            return result + 'mnuir';
          }
          return result + (isFuture ? 'mnui' : 'mnuum');
        } else if (withoutSuffix) {
          return result + 'mnuur';
        }
        return result + (isFuture ? 'mnu' : 'mnui');
      case 'y':
        return withoutSuffix || isFuture ? 'r' : 'ri';
      case 'yy':
        if (plural(number)) {
          return result + (withoutSuffix || isFuture ? 'r' : 'rum');
        }
        return result + (withoutSuffix || isFuture ? 'r' : 'ri');
    }
  }
  var is = moment.defineLocale('is', {
    months: 'janar_febrar_mars_aprl_ma_jn_jl_gst_september_oktber_nvember_desember'.split('_'),
    monthsShort: 'jan_feb_mar_apr_ma_jn_jl_g_sep_okt_nv_des'.split('_'),
    weekdays: 'sunnudagur_mnudagur_rijudagur_mivikudagur_fimmtudagur_fstudagur_laugardagur'.split('_'),
    weekdaysShort: 'sun_mn_ri_mi_fim_fs_lau'.split('_'),
    weekdaysMin: 'Su_M_r_Mi_Fi_F_La'.split('_'),
    longDateFormat: {
      LT: 'H:mm',
      LTS: 'H:mm:ss',
      L: 'DD.MM.YYYY',
      LL: 'D. MMMM YYYY',
      LLL: 'D. MMMM YYYY [kl.] H:mm',
      LLLL: 'dddd, D. MMMM YYYY [kl.] H:mm'
    },
    calendar: {
      sameDay: '[ dag kl.] LT',
      nextDay: '[ morgun kl.] LT',
      nextWeek: 'dddd [kl.] LT',
      lastDay: '[ gr kl.] LT',
      lastWeek: '[sasta] dddd [kl.] LT',
      sameElse: 'L'
    },
    relativeTime: {
      future: 'eftir %s',
      past: 'fyrir %s san',
      s: translate,
      ss: translate,
      m: translate,
      mm: translate,
      h: 'klukkustund',
      hh: translate,
      d: translate,
      dd: translate,
      M: translate,
      MM: translate,
      y: translate,
      yy: translate
    },
    dayOfMonthOrdinalParse: /\d{1,2}\./,
    ordinal: '%d.',
    week: {
      dow: 1,
      // Monday is the first day of the week.
      doy: 4 // The week that contains Jan 4th is the first week of the year.
    }
  });
  return is;
});

/***/ }),
/* 170 */
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Italian [it]
//! author : Lorenzo : https://github.com/aliem
//! author: Mattia Larentis: https://github.com/nostalgiaz
//! author: Marco : https://github.com/Manfre98

;
(function (global, factory) {
   true ? factory(__webpack_require__(105)) : 0;
})(this, function (moment) {
  'use strict';

  //! moment.js locale configuration
  var it = moment.defineLocale('it', {
    months: 'gennaio_febbraio_marzo_aprile_maggio_giugno_luglio_agosto_settembre_ottobre_novembre_dicembre'.split('_'),
    monthsShort: 'gen_feb_mar_apr_mag_giu_lug_ago_set_ott_nov_dic'.split('_'),
    weekdays: 'domenica_luned_marted_mercoled_gioved_venerd_sabato'.split('_'),
    weekdaysShort: 'dom_lun_mar_mer_gio_ven_sab'.split('_'),
    weekdaysMin: 'do_lu_ma_me_gi_ve_sa'.split('_'),
    longDateFormat: {
      LT: 'HH:mm',
      LTS: 'HH:mm:ss',
      L: 'DD/MM/YYYY',
      LL: 'D MMMM YYYY',
      LLL: 'D MMMM YYYY HH:mm',
      LLLL: 'dddd D MMMM YYYY HH:mm'
    },
    calendar: {
      sameDay: function () {
        return '[Oggi a' + (this.hours() > 1 ? 'lle ' : this.hours() === 0 ? ' ' : "ll'") + ']LT';
      },
      nextDay: function () {
        return '[Domani a' + (this.hours() > 1 ? 'lle ' : this.hours() === 0 ? ' ' : "ll'") + ']LT';
      },
      nextWeek: function () {
        return 'dddd [a' + (this.hours() > 1 ? 'lle ' : this.hours() === 0 ? ' ' : "ll'") + ']LT';
      },
      lastDay: function () {
        return '[Ieri a' + (this.hours() > 1 ? 'lle ' : this.hours() === 0 ? ' ' : "ll'") + ']LT';
      },
      lastWeek: function () {
        switch (this.day()) {
          case 0:
            return '[La scorsa] dddd [a' + (this.hours() > 1 ? 'lle ' : this.hours() === 0 ? ' ' : "ll'") + ']LT';
          default:
            return '[Lo scorso] dddd [a' + (this.hours() > 1 ? 'lle ' : this.hours() === 0 ? ' ' : "ll'") + ']LT';
        }
      },
      sameElse: 'L'
    },
    relativeTime: {
      future: 'tra %s',
      past: '%s fa',
      s: 'alcuni secondi',
      ss: '%d secondi',
      m: 'un minuto',
      mm: '%d minuti',
      h: "un'ora",
      hh: '%d ore',
      d: 'un giorno',
      dd: '%d giorni',
      w: 'una settimana',
      ww: '%d settimane',
      M: 'un mese',
      MM: '%d mesi',
      y: 'un anno',
      yy: '%d anni'
    },
    dayOfMonthOrdinalParse: /\d{1,2}/,
    ordinal: '%d',
    week: {
      dow: 1,
      // Monday is the first day of the week.
      doy: 4 // The week that contains Jan 4th is the first week of the year.
    }
  });
  return it;
});

/***/ }),
/* 171 */
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Italian (Switzerland) [it-ch]
//! author : xfh : https://github.com/xfh

;
(function (global, factory) {
   true ? factory(__webpack_require__(105)) : 0;
})(this, function (moment) {
  'use strict';

  //! moment.js locale configuration
  var itCh = moment.defineLocale('it-ch', {
    months: 'gennaio_febbraio_marzo_aprile_maggio_giugno_luglio_agosto_settembre_ottobre_novembre_dicembre'.split('_'),
    monthsShort: 'gen_feb_mar_apr_mag_giu_lug_ago_set_ott_nov_dic'.split('_'),
    weekdays: 'domenica_luned_marted_mercoled_gioved_venerd_sabato'.split('_'),
    weekdaysShort: 'dom_lun_mar_mer_gio_ven_sab'.split('_'),
    weekdaysMin: 'do_lu_ma_me_gi_ve_sa'.split('_'),
    longDateFormat: {
      LT: 'HH:mm',
      LTS: 'HH:mm:ss',
      L: 'DD.MM.YYYY',
      LL: 'D MMMM YYYY',
      LLL: 'D MMMM YYYY HH:mm',
      LLLL: 'dddd D MMMM YYYY HH:mm'
    },
    calendar: {
      sameDay: '[Oggi alle] LT',
      nextDay: '[Domani alle] LT',
      nextWeek: 'dddd [alle] LT',
      lastDay: '[Ieri alle] LT',
      lastWeek: function () {
        switch (this.day()) {
          case 0:
            return '[la scorsa] dddd [alle] LT';
          default:
            return '[lo scorso] dddd [alle] LT';
        }
      },
      sameElse: 'L'
    },
    relativeTime: {
      future: function (s) {
        return (/^[0-9].+$/.test(s) ? 'tra' : 'in') + ' ' + s;
      },
      past: '%s fa',
      s: 'alcuni secondi',
      ss: '%d secondi',
      m: 'un minuto',
      mm: '%d minuti',
      h: "un'ora",
      hh: '%d ore',
      d: 'un giorno',
      dd: '%d giorni',
      M: 'un mese',
      MM: '%d mesi',
      y: 'un anno',
      yy: '%d anni'
    },
    dayOfMonthOrdinalParse: /\d{1,2}/,
    ordinal: '%d',
    week: {
      dow: 1,
      // Monday is the first day of the week.
      doy: 4 // The week that contains Jan 4th is the first week of the year.
    }
  });
  return itCh;
});

/***/ }),
/* 172 */
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Japanese [ja]
//! author : LI Long : https://github.com/baryon

;
(function (global, factory) {
   true ? factory(__webpack_require__(105)) : 0;
})(this, function (moment) {
  'use strict';

  //! moment.js locale configuration
  var ja = moment.defineLocale('ja', {
    eras: [{
      since: '2019-05-01',
      offset: 1,
      name: '',
      narrow: '',
      abbr: 'R'
    }, {
      since: '1989-01-08',
      until: '2019-04-30',
      offset: 1,
      name: '',
      narrow: '',
      abbr: 'H'
    }, {
      since: '1926-12-25',
      until: '1989-01-07',
      offset: 1,
      name: '',
      narrow: '',
      abbr: 'S'
    }, {
      since: '1912-07-30',
      until: '1926-12-24',
      offset: 1,
      name: '',
      narrow: '',
      abbr: 'T'
    }, {
      since: '1873-01-01',
      until: '1912-07-29',
      offset: 6,
      name: '',
      narrow: '',
      abbr: 'M'
    }, {
      since: '0001-01-01',
      until: '1873-12-31',
      offset: 1,
      name: '',
      narrow: 'AD',
      abbr: 'AD'
    }, {
      since: '0000-12-31',
      until: -Infinity,
      offset: 1,
      name: '',
      narrow: 'BC',
      abbr: 'BC'
    }],
    eraYearOrdinalRegex: /(|\d+)/,
    eraYearOrdinalParse: function (input, match) {
      return match[1] === '' ? 1 : parseInt(match[1] || input, 10);
    },
    months: '1_2_3_4_5_6_7_8_9_10_11_12'.split('_'),
    monthsShort: '1_2_3_4_5_6_7_8_9_10_11_12'.split('_'),
    weekdays: '______'.split('_'),
    weekdaysShort: '______'.split('_'),
    weekdaysMin: '______'.split('_'),
    longDateFormat: {
      LT: 'HH:mm',
      LTS: 'HH:mm:ss',
      L: 'YYYY/MM/DD',
      LL: 'YYYYMD',
      LLL: 'YYYYMD HH:mm',
      LLLL: 'YYYYMD dddd HH:mm',
      l: 'YYYY/MM/DD',
      ll: 'YYYYMD',
      lll: 'YYYYMD HH:mm',
      llll: 'YYYYMD(ddd) HH:mm'
    },
    meridiemParse: /|/i,
    isPM: function (input) {
      return input === '';
    },
    meridiem: function (hour, minute, isLower) {
      if (hour < 12) {
        return '';
      } else {
        return '';
      }
    },
    calendar: {
      sameDay: '[] LT',
      nextDay: '[] LT',
      nextWeek: function (now) {
        if (now.week() !== this.week()) {
          return '[]dddd LT';
        } else {
          return 'dddd LT';
        }
      },
      lastDay: '[] LT',
      lastWeek: function (now) {
        if (this.week() !== now.week()) {
          return '[]dddd LT';
        } else {
          return 'dddd LT';
        }
      },
      sameElse: 'L'
    },
    dayOfMonthOrdinalParse: /\d{1,2}/,
    ordinal: function (number, period) {
      switch (period) {
        case 'y':
          return number === 1 ? '' : number + '';
        case 'd':
        case 'D':
        case 'DDD':
          return number + '';
        default:
          return number;
      }
    },
    relativeTime: {
      future: '%s',
      past: '%s',
      s: '',
      ss: '%d',
      m: '1',
      mm: '%d',
      h: '1',
      hh: '%d',
      d: '1',
      dd: '%d',
      M: '1',
      MM: '%d',
      y: '1',
      yy: '%d'
    }
  });
  return ja;
});

/***/ }),
/* 173 */
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Javanese [jv]
//! author : Rony Lantip : https://github.com/lantip
//! reference: http://jv.wikipedia.org/wiki/Basa_Jawa

;
(function (global, factory) {
   true ? factory(__webpack_require__(105)) : 0;
})(this, function (moment) {
  'use strict';

  //! moment.js locale configuration
  var jv = moment.defineLocale('jv', {
    months: 'Januari_Februari_Maret_April_Mei_Juni_Juli_Agustus_September_Oktober_Nopember_Desember'.split('_'),
    monthsShort: 'Jan_Feb_Mar_Apr_Mei_Jun_Jul_Ags_Sep_Okt_Nop_Des'.split('_'),
    weekdays: 'Minggu_Senen_Seloso_Rebu_Kemis_Jemuwah_Septu'.split('_'),
    weekdaysShort: 'Min_Sen_Sel_Reb_Kem_Jem_Sep'.split('_'),
    weekdaysMin: 'Mg_Sn_Sl_Rb_Km_Jm_Sp'.split('_'),
    longDateFormat: {
      LT: 'HH.mm',
      LTS: 'HH.mm.ss',
      L: 'DD/MM/YYYY',
      LL: 'D MMMM YYYY',
      LLL: 'D MMMM YYYY [pukul] HH.mm',
      LLLL: 'dddd, D MMMM YYYY [pukul] HH.mm'
    },
    meridiemParse: /enjing|siyang|sonten|ndalu/,
    meridiemHour: function (hour, meridiem) {
      if (hour === 12) {
        hour = 0;
      }
      if (meridiem === 'enjing') {
        return hour;
      } else if (meridiem === 'siyang') {
        return hour >= 11 ? hour : hour + 12;
      } else if (meridiem === 'sonten' || meridiem === 'ndalu') {
        return hour + 12;
      }
    },
    meridiem: function (hours, minutes, isLower) {
      if (hours < 11) {
        return 'enjing';
      } else if (hours < 15) {
        return 'siyang';
      } else if (hours < 19) {
        return 'sonten';
      } else {
        return 'ndalu';
      }
    },
    calendar: {
      sameDay: '[Dinten puniko pukul] LT',
      nextDay: '[Mbenjang pukul] LT',
      nextWeek: 'dddd [pukul] LT',
      lastDay: '[Kala wingi pukul] LT',
      lastWeek: 'dddd [kepengker pukul] LT',
      sameElse: 'L'
    },
    relativeTime: {
      future: 'wonten ing %s',
      past: '%s ingkang kepengker',
      s: 'sawetawis detik',
      ss: '%d detik',
      m: 'setunggal menit',
      mm: '%d menit',
      h: 'setunggal jam',
      hh: '%d jam',
      d: 'sedinten',
      dd: '%d dinten',
      M: 'sewulan',
      MM: '%d wulan',
      y: 'setaun',
      yy: '%d taun'
    },
    week: {
      dow: 1,
      // Monday is the first day of the week.
      doy: 7 // The week that contains Jan 7th is the first week of the year.
    }
  });
  return jv;
});

/***/ }),
/* 174 */
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Georgian [ka]
//! author : Irakli Janiashvili : https://github.com/IrakliJani

;
(function (global, factory) {
   true ? factory(__webpack_require__(105)) : 0;
})(this, function (moment) {
  'use strict';

  //! moment.js locale configuration
  var ka = moment.defineLocale('ka', {
    months: '___________'.split('_'),
    monthsShort: '___________'.split('_'),
    weekdays: {
      standalone: '______'.split('_'),
      format: '______'.split('_'),
      isFormat: /(|)/
    },
    weekdaysShort: '______'.split('_'),
    weekdaysMin: '______'.split('_'),
    longDateFormat: {
      LT: 'HH:mm',
      LTS: 'HH:mm:ss',
      L: 'DD/MM/YYYY',
      LL: 'D MMMM YYYY',
      LLL: 'D MMMM YYYY HH:mm',
      LLLL: 'dddd, D MMMM YYYY HH:mm'
    },
    calendar: {
      sameDay: '[] LT[-]',
      nextDay: '[] LT[-]',
      lastDay: '[] LT[-]',
      nextWeek: '[] dddd LT[-]',
      lastWeek: '[] dddd LT-',
      sameElse: 'L'
    },
    relativeTime: {
      future: function (s) {
        return s.replace(/(|||||)(|)/, function ($0, $1, $2) {
          return $2 === '' ? $1 + '' : $1 + $2 + '';
        });
      },
      past: function (s) {
        if (/(||||)/.test(s)) {
          return s.replace(/(|)$/, ' ');
        }
        if (//.test(s)) {
          return s.replace(/$/, ' ');
        }
        return s;
      },
      s: ' ',
      ss: '%d ',
      m: '',
      mm: '%d ',
      h: '',
      hh: '%d ',
      d: '',
      dd: '%d ',
      M: '',
      MM: '%d ',
      y: '',
      yy: '%d '
    },
    dayOfMonthOrdinalParse: /0|1-|-\d{1,2}|\d{1,2}-/,
    ordinal: function (number) {
      if (number === 0) {
        return number;
      }
      if (number === 1) {
        return number + '-';
      }
      if (number < 20 || number <= 100 && number % 20 === 0 || number % 100 === 0) {
        return '-' + number;
      }
      return number + '-';
    },
    week: {
      dow: 1,
      doy: 7
    }
  });
  return ka;
});

/***/ }),
/* 175 */
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Kazakh [kk]
//! authors : Nurlan Rakhimzhanov : https://github.com/nurlan

;
(function (global, factory) {
   true ? factory(__webpack_require__(105)) : 0;
})(this, function (moment) {
  'use strict';

  //! moment.js locale configuration
  var suffixes = {
    0: '-',
    1: '-',
    2: '-',
    3: '-',
    4: '-',
    5: '-',
    6: '-',
    7: '-',
    8: '-',
    9: '-',
    10: '-',
    20: '-',
    30: '-',
    40: '-',
    50: '-',
    60: '-',
    70: '-',
    80: '-',
    90: '-',
    100: '-'
  };
  var kk = moment.defineLocale('kk', {
    months: '___________'.split('_'),
    monthsShort: '___________'.split('_'),
    weekdays: '______'.split('_'),
    weekdaysShort: '______'.split('_'),
    weekdaysMin: '______'.split('_'),
    longDateFormat: {
      LT: 'HH:mm',
      LTS: 'HH:mm:ss',
      L: 'DD.MM.YYYY',
      LL: 'D MMMM YYYY',
      LLL: 'D MMMM YYYY HH:mm',
      LLLL: 'dddd, D MMMM YYYY HH:mm'
    },
    calendar: {
      sameDay: '[ ] LT',
      nextDay: '[ ] LT',
      nextWeek: 'dddd [] LT',
      lastDay: '[ ] LT',
      lastWeek: '[ ] dddd [] LT',
      sameElse: 'L'
    },
    relativeTime: {
      future: '%s ',
      past: '%s ',
      s: ' ',
      ss: '%d ',
      m: ' ',
      mm: '%d ',
      h: ' ',
      hh: '%d ',
      d: ' ',
      dd: '%d ',
      M: ' ',
      MM: '%d ',
      y: ' ',
      yy: '%d '
    },
    dayOfMonthOrdinalParse: /\d{1,2}-(|)/,
    ordinal: function (number) {
      var a = number % 10,
        b = number >= 100 ? 100 : null;
      return number + (suffixes[number] || suffixes[a] || suffixes[b]);
    },
    week: {
      dow: 1,
      // Monday is the first day of the week.
      doy: 7 // The week that contains Jan 7th is the first week of the year.
    }
  });
  return kk;
});

/***/ }),
/* 176 */
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Cambodian [km]
//! author : Kruy Vanna : https://github.com/kruyvanna

;
(function (global, factory) {
   true ? factory(__webpack_require__(105)) : 0;
})(this, function (moment) {
  'use strict';

  //! moment.js locale configuration
  var symbolMap = {
      1: '',
      2: '',
      3: '',
      4: '',
      5: '',
      6: '',
      7: '',
      8: '',
      9: '',
      0: ''
    },
    numberMap = {
      '': '1',
      '': '2',
      '': '3',
      '': '4',
      '': '5',
      '': '6',
      '': '7',
      '': '8',
      '': '9',
      '': '0'
    };
  var km = moment.defineLocale('km', {
    months: '___________'.split('_'),
    monthsShort: '___________'.split('_'),
    weekdays: '______'.split('_'),
    weekdaysShort: '______'.split('_'),
    weekdaysMin: '______'.split('_'),
    weekdaysParseExact: true,
    longDateFormat: {
      LT: 'HH:mm',
      LTS: 'HH:mm:ss',
      L: 'DD/MM/YYYY',
      LL: 'D MMMM YYYY',
      LLL: 'D MMMM YYYY HH:mm',
      LLLL: 'dddd, D MMMM YYYY HH:mm'
    },
    meridiemParse: /|/,
    isPM: function (input) {
      return input === '';
    },
    meridiem: function (hour, minute, isLower) {
      if (hour < 12) {
        return '';
      } else {
        return '';
      }
    },
    calendar: {
      sameDay: '[ ] LT',
      nextDay: '[ ] LT',
      nextWeek: 'dddd [] LT',
      lastDay: '[ ] LT',
      lastWeek: 'dddd [] [] LT',
      sameElse: 'L'
    },
    relativeTime: {
      future: '%s',
      past: '%s',
      s: '',
      ss: '%d ',
      m: '',
      mm: '%d ',
      h: '',
      hh: '%d ',
      d: '',
      dd: '%d ',
      M: '',
      MM: '%d ',
      y: '',
      yy: '%d '
    },
    dayOfMonthOrdinalParse: /\d{1,2}/,
    ordinal: '%d',
    preparse: function (string) {
      return string.replace(/[]/g, function (match) {
        return numberMap[match];
      });
    },
    postformat: function (string) {
      return string.replace(/\d/g, function (match) {
        return symbolMap[match];
      });
    },
    week: {
      dow: 1,
      // Monday is the first day of the week.
      doy: 4 // The week that contains Jan 4th is the first week of the year.
    }
  });
  return km;
});

/***/ }),
/* 177 */
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Kannada [kn]
//! author : Rajeev Naik : https://github.com/rajeevnaikte

;
(function (global, factory) {
   true ? factory(__webpack_require__(105)) : 0;
})(this, function (moment) {
  'use strict';

  //! moment.js locale configuration
  var symbolMap = {
      1: '',
      2: '',
      3: '',
      4: '',
      5: '',
      6: '',
      7: '',
      8: '',
      9: '',
      0: ''
    },
    numberMap = {
      '': '1',
      '': '2',
      '': '3',
      '': '4',
      '': '5',
      '': '6',
      '': '7',
      '': '8',
      '': '9',
      '': '0'
    };
  var kn = moment.defineLocale('kn', {
    months: '___________'.split('_'),
    monthsShort: '___________'.split('_'),
    monthsParseExact: true,
    weekdays: '______'.split('_'),
    weekdaysShort: '______'.split('_'),
    weekdaysMin: '______'.split('_'),
    longDateFormat: {
      LT: 'A h:mm',
      LTS: 'A h:mm:ss',
      L: 'DD/MM/YYYY',
      LL: 'D MMMM YYYY',
      LLL: 'D MMMM YYYY, A h:mm',
      LLLL: 'dddd, D MMMM YYYY, A h:mm'
    },
    calendar: {
      sameDay: '[] LT',
      nextDay: '[] LT',
      nextWeek: 'dddd, LT',
      lastDay: '[] LT',
      lastWeek: '[] dddd, LT',
      sameElse: 'L'
    },
    relativeTime: {
      future: '%s ',
      past: '%s ',
      s: ' ',
      ss: '%d ',
      m: ' ',
      mm: '%d ',
      h: ' ',
      hh: '%d ',
      d: ' ',
      dd: '%d ',
      M: ' ',
      MM: '%d ',
      y: ' ',
      yy: '%d '
    },
    preparse: function (string) {
      return string.replace(/[]/g, function (match) {
        return numberMap[match];
      });
    },
    postformat: function (string) {
      return string.replace(/\d/g, function (match) {
        return symbolMap[match];
      });
    },
    meridiemParse: /|||/,
    meridiemHour: function (hour, meridiem) {
      if (hour === 12) {
        hour = 0;
      }
      if (meridiem === '') {
        return hour < 4 ? hour : hour + 12;
      } else if (meridiem === '') {
        return hour;
      } else if (meridiem === '') {
        return hour >= 10 ? hour : hour + 12;
      } else if (meridiem === '') {
        return hour + 12;
      }
    },
    meridiem: function (hour, minute, isLower) {
      if (hour < 4) {
        return '';
      } else if (hour < 10) {
        return '';
      } else if (hour < 17) {
        return '';
      } else if (hour < 20) {
        return '';
      } else {
        return '';
      }
    },
    dayOfMonthOrdinalParse: /\d{1,2}()/,
    ordinal: function (number) {
      return number + '';
    },
    week: {
      dow: 0,
      // Sunday is the first day of the week.
      doy: 6 // The week that contains Jan 6th is the first week of the year.
    }
  });
  return kn;
});

/***/ }),
/* 178 */
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Korean [ko]
//! author : Kyungwook, Park : https://github.com/kyungw00k
//! author : Jeeeyul Lee <jeeeyul@gmail.com>

;
(function (global, factory) {
   true ? factory(__webpack_require__(105)) : 0;
})(this, function (moment) {
  'use strict';

  //! moment.js locale configuration
  var ko = moment.defineLocale('ko', {
    months: '1_2_3_4_5_6_7_8_9_10_11_12'.split('_'),
    monthsShort: '1_2_3_4_5_6_7_8_9_10_11_12'.split('_'),
    weekdays: '______'.split('_'),
    weekdaysShort: '______'.split('_'),
    weekdaysMin: '______'.split('_'),
    longDateFormat: {
      LT: 'A h:mm',
      LTS: 'A h:mm:ss',
      L: 'YYYY.MM.DD.',
      LL: 'YYYY MMMM D',
      LLL: 'YYYY MMMM D A h:mm',
      LLLL: 'YYYY MMMM D dddd A h:mm',
      l: 'YYYY.MM.DD.',
      ll: 'YYYY MMMM D',
      lll: 'YYYY MMMM D A h:mm',
      llll: 'YYYY MMMM D dddd A h:mm'
    },
    calendar: {
      sameDay: ' LT',
      nextDay: ' LT',
      nextWeek: 'dddd LT',
      lastDay: ' LT',
      lastWeek: ' dddd LT',
      sameElse: 'L'
    },
    relativeTime: {
      future: '%s ',
      past: '%s ',
      s: ' ',
      ss: '%d',
      m: '1',
      mm: '%d',
      h: ' ',
      hh: '%d',
      d: '',
      dd: '%d',
      M: ' ',
      MM: '%d',
      y: ' ',
      yy: '%d'
    },
    dayOfMonthOrdinalParse: /\d{1,2}(||)/,
    ordinal: function (number, period) {
      switch (period) {
        case 'd':
        case 'D':
        case 'DDD':
          return number + '';
        case 'M':
          return number + '';
        case 'w':
        case 'W':
          return number + '';
        default:
          return number;
      }
    },
    meridiemParse: /|/,
    isPM: function (token) {
      return token === '';
    },
    meridiem: function (hour, minute, isUpper) {
      return hour < 12 ? '' : '';
    }
  });
  return ko;
});

/***/ }),
/* 179 */
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Kurdish [ku]
//! author : Shahram Mebashar : https://github.com/ShahramMebashar

;
(function (global, factory) {
   true ? factory(__webpack_require__(105)) : 0;
})(this, function (moment) {
  'use strict';

  //! moment.js locale configuration
  var symbolMap = {
      1: '',
      2: '',
      3: '',
      4: '',
      5: '',
      6: '',
      7: '',
      8: '',
      9: '',
      0: ''
    },
    numberMap = {
      '': '1',
      '': '2',
      '': '3',
      '': '4',
      '': '5',
      '': '6',
      '': '7',
      '': '8',
      '': '9',
      '': '0'
    },
    months = [' ', '', '', '', '', '', '', '', '', ' ', ' ', ' '];
  var ku = moment.defineLocale('ku', {
    months: months,
    monthsShort: months,
    weekdays: '______'.split('_'),
    weekdaysShort: '______'.split('_'),
    weekdaysMin: '______'.split('_'),
    weekdaysParseExact: true,
    longDateFormat: {
      LT: 'HH:mm',
      LTS: 'HH:mm:ss',
      L: 'DD/MM/YYYY',
      LL: 'D MMMM YYYY',
      LLL: 'D MMMM YYYY HH:mm',
      LLLL: 'dddd, D MMMM YYYY HH:mm'
    },
    meridiemParse: /|/,
    isPM: function (input) {
      return //.test(input);
    },
    meridiem: function (hour, minute, isLower) {
      if (hour < 12) {
        return '';
      } else {
        return '';
      }
    },
    calendar: {
      sameDay: '[ ] LT',
      nextDay: '[ ] LT',
      nextWeek: 'dddd [] LT',
      lastDay: '[ ] LT',
      lastWeek: 'dddd [] LT',
      sameElse: 'L'
    },
    relativeTime: {
      future: ' %s',
      past: '%s',
      s: ' ',
      ss: ' %d',
      m: ' ',
      mm: '%d ',
      h: ' ',
      hh: '%d ',
      d: ' ',
      dd: '%d ',
      M: ' ',
      MM: '%d ',
      y: ' ',
      yy: '%d '
    },
    preparse: function (string) {
      return string.replace(/[]/g, function (match) {
        return numberMap[match];
      }).replace(//g, ',');
    },
    postformat: function (string) {
      return string.replace(/\d/g, function (match) {
        return symbolMap[match];
      }).replace(/,/g, '');
    },
    week: {
      dow: 6,
      // Saturday is the first day of the week.
      doy: 12 // The week that contains Jan 12th is the first week of the year.
    }
  });
  return ku;
});

/***/ }),
/* 180 */
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Kyrgyz [ky]
//! author : Chyngyz Arystan uulu : https://github.com/chyngyz

;
(function (global, factory) {
   true ? factory(__webpack_require__(105)) : 0;
})(this, function (moment) {
  'use strict';

  //! moment.js locale configuration
  var suffixes = {
    0: '-',
    1: '-',
    2: '-',
    3: '-',
    4: '-',
    5: '-',
    6: '-',
    7: '-',
    8: '-',
    9: '-',
    10: '-',
    20: '-',
    30: '-',
    40: '-',
    50: '-',
    60: '-',
    70: '-',
    80: '-',
    90: '-',
    100: '-'
  };
  var ky = moment.defineLocale('ky', {
    months: '___________'.split('_'),
    monthsShort: '___________'.split('_'),
    weekdays: '______'.split('_'),
    weekdaysShort: '______'.split('_'),
    weekdaysMin: '______'.split('_'),
    longDateFormat: {
      LT: 'HH:mm',
      LTS: 'HH:mm:ss',
      L: 'DD.MM.YYYY',
      LL: 'D MMMM YYYY',
      LLL: 'D MMMM YYYY HH:mm',
      LLLL: 'dddd, D MMMM YYYY HH:mm'
    },
    calendar: {
      sameDay: '[ ] LT',
      nextDay: '[ ] LT',
      nextWeek: 'dddd [] LT',
      lastDay: '[ ] LT',
      lastWeek: '[ ] dddd [] [] LT',
      sameElse: 'L'
    },
    relativeTime: {
      future: '%s ',
      past: '%s ',
      s: ' ',
      ss: '%d ',
      m: ' ',
      mm: '%d ',
      h: ' ',
      hh: '%d ',
      d: ' ',
      dd: '%d ',
      M: ' ',
      MM: '%d ',
      y: ' ',
      yy: '%d '
    },
    dayOfMonthOrdinalParse: /\d{1,2}-(|||)/,
    ordinal: function (number) {
      var a = number % 10,
        b = number >= 100 ? 100 : null;
      return number + (suffixes[number] || suffixes[a] || suffixes[b]);
    },
    week: {
      dow: 1,
      // Monday is the first day of the week.
      doy: 7 // The week that contains Jan 7th is the first week of the year.
    }
  });
  return ky;
});

/***/ }),
/* 181 */
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Luxembourgish [lb]
//! author : mweimerskirch : https://github.com/mweimerskirch
//! author : David Raison : https://github.com/kwisatz

;
(function (global, factory) {
   true ? factory(__webpack_require__(105)) : 0;
})(this, function (moment) {
  'use strict';

  //! moment.js locale configuration
  function processRelativeTime(number, withoutSuffix, key, isFuture) {
    var format = {
      m: ['eng Minutt', 'enger Minutt'],
      h: ['eng Stonn', 'enger Stonn'],
      d: ['een Dag', 'engem Dag'],
      M: ['ee Mount', 'engem Mount'],
      y: ['ee Joer', 'engem Joer']
    };
    return withoutSuffix ? format[key][0] : format[key][1];
  }
  function processFutureTime(string) {
    var number = string.substr(0, string.indexOf(' '));
    if (eifelerRegelAppliesToNumber(number)) {
      return 'a ' + string;
    }
    return 'an ' + string;
  }
  function processPastTime(string) {
    var number = string.substr(0, string.indexOf(' '));
    if (eifelerRegelAppliesToNumber(number)) {
      return 'viru ' + string;
    }
    return 'virun ' + string;
  }
  /**
   * Returns true if the word before the given number loses the '-n' ending.
   * e.g. 'an 10 Deeg' but 'a 5 Deeg'
   *
   * @param number {integer}
   * @returns {boolean}
   */
  function eifelerRegelAppliesToNumber(number) {
    number = parseInt(number, 10);
    if (isNaN(number)) {
      return false;
    }
    if (number < 0) {
      // Negative Number --> always true
      return true;
    } else if (number < 10) {
      // Only 1 digit
      if (4 <= number && number <= 7) {
        return true;
      }
      return false;
    } else if (number < 100) {
      // 2 digits
      var lastDigit = number % 10,
        firstDigit = number / 10;
      if (lastDigit === 0) {
        return eifelerRegelAppliesToNumber(firstDigit);
      }
      return eifelerRegelAppliesToNumber(lastDigit);
    } else if (number < 10000) {
      // 3 or 4 digits --> recursively check first digit
      while (number >= 10) {
        number = number / 10;
      }
      return eifelerRegelAppliesToNumber(number);
    } else {
      // Anything larger than 4 digits: recursively check first n-3 digits
      number = number / 1000;
      return eifelerRegelAppliesToNumber(number);
    }
  }
  var lb = moment.defineLocale('lb', {
    months: 'Januar_Februar_Merz_Abrll_Mee_Juni_Juli_August_September_Oktober_November_Dezember'.split('_'),
    monthsShort: 'Jan._Febr._Mrz._Abr._Mee_Jun._Jul._Aug._Sept._Okt._Nov._Dez.'.split('_'),
    monthsParseExact: true,
    weekdays: 'Sonndeg_Mindeg_Dnschdeg_Mttwoch_Donneschdeg_Freideg_Samschdeg'.split('_'),
    weekdaysShort: 'So._M._D._M._Do._Fr._Sa.'.split('_'),
    weekdaysMin: 'So_M_D_M_Do_Fr_Sa'.split('_'),
    weekdaysParseExact: true,
    longDateFormat: {
      LT: 'H:mm [Auer]',
      LTS: 'H:mm:ss [Auer]',
      L: 'DD.MM.YYYY',
      LL: 'D. MMMM YYYY',
      LLL: 'D. MMMM YYYY H:mm [Auer]',
      LLLL: 'dddd, D. MMMM YYYY H:mm [Auer]'
    },
    calendar: {
      sameDay: '[Haut um] LT',
      sameElse: 'L',
      nextDay: '[Muer um] LT',
      nextWeek: 'dddd [um] LT',
      lastDay: '[Gschter um] LT',
      lastWeek: function () {
        // Different date string for 'Dnschdeg' (Tuesday) and 'Donneschdeg' (Thursday) due to phonological rule
        switch (this.day()) {
          case 2:
          case 4:
            return '[Leschten] dddd [um] LT';
          default:
            return '[Leschte] dddd [um] LT';
        }
      }
    },
    relativeTime: {
      future: processFutureTime,
      past: processPastTime,
      s: 'e puer Sekonnen',
      ss: '%d Sekonnen',
      m: processRelativeTime,
      mm: '%d Minutten',
      h: processRelativeTime,
      hh: '%d Stonnen',
      d: processRelativeTime,
      dd: '%d Deeg',
      M: processRelativeTime,
      MM: '%d Mint',
      y: processRelativeTime,
      yy: '%d Joer'
    },
    dayOfMonthOrdinalParse: /\d{1,2}\./,
    ordinal: '%d.',
    week: {
      dow: 1,
      // Monday is the first day of the week.
      doy: 4 // The week that contains Jan 4th is the first week of the year.
    }
  });
  return lb;
});

/***/ }),
/* 182 */
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Lao [lo]
//! author : Ryan Hart : https://github.com/ryanhart2

;
(function (global, factory) {
   true ? factory(__webpack_require__(105)) : 0;
})(this, function (moment) {
  'use strict';

  //! moment.js locale configuration
  var lo = moment.defineLocale('lo', {
    months: '___________'.split('_'),
    monthsShort: '___________'.split('_'),
    weekdays: '______'.split('_'),
    weekdaysShort: '______'.split('_'),
    weekdaysMin: '______'.split('_'),
    weekdaysParseExact: true,
    longDateFormat: {
      LT: 'HH:mm',
      LTS: 'HH:mm:ss',
      L: 'DD/MM/YYYY',
      LL: 'D MMMM YYYY',
      LLL: 'D MMMM YYYY HH:mm',
      LLLL: 'dddd D MMMM YYYY HH:mm'
    },
    meridiemParse: /|/,
    isPM: function (input) {
      return input === '';
    },
    meridiem: function (hour, minute, isLower) {
      if (hour < 12) {
        return '';
      } else {
        return '';
      }
    },
    calendar: {
      sameDay: '[] LT',
      nextDay: '[] LT',
      nextWeek: '[]dddd[] LT',
      lastDay: '[] LT',
      lastWeek: '[]dddd[] LT',
      sameElse: 'L'
    },
    relativeTime: {
      future: ' %s',
      past: '%s',
      s: '',
      ss: '%d ',
      m: '1 ',
      mm: '%d ',
      h: '1 ',
      hh: '%d ',
      d: '1 ',
      dd: '%d ',
      M: '1 ',
      MM: '%d ',
      y: '1 ',
      yy: '%d '
    },
    dayOfMonthOrdinalParse: /()\d{1,2}/,
    ordinal: function (number) {
      return '' + number;
    }
  });
  return lo;
});

/***/ }),
/* 183 */
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Lithuanian [lt]
//! author : Mindaugas Mozras : https://github.com/mmozuras

;
(function (global, factory) {
   true ? factory(__webpack_require__(105)) : 0;
})(this, function (moment) {
  'use strict';

  //! moment.js locale configuration
  var units = {
    ss: 'sekund_sekundi_sekundes',
    m: 'minut_minuts_minut',
    mm: 'minuts_minui_minutes',
    h: 'valanda_valandos_valand',
    hh: 'valandos_valand_valandas',
    d: 'diena_dienos_dien',
    dd: 'dienos_dien_dienas',
    M: 'mnuo_mnesio_mnes',
    MM: 'mnesiai_mnesi_mnesius',
    y: 'metai_met_metus',
    yy: 'metai_met_metus'
  };
  function translateSeconds(number, withoutSuffix, key, isFuture) {
    if (withoutSuffix) {
      return 'kelios sekunds';
    } else {
      return isFuture ? 'keli sekundi' : 'kelias sekundes';
    }
  }
  function translateSingular(number, withoutSuffix, key, isFuture) {
    return withoutSuffix ? forms(key)[0] : isFuture ? forms(key)[1] : forms(key)[2];
  }
  function special(number) {
    return number % 10 === 0 || number > 10 && number < 20;
  }
  function forms(key) {
    return units[key].split('_');
  }
  function translate(number, withoutSuffix, key, isFuture) {
    var result = number + ' ';
    if (number === 1) {
      return result + translateSingular(number, withoutSuffix, key[0], isFuture);
    } else if (withoutSuffix) {
      return result + (special(number) ? forms(key)[1] : forms(key)[0]);
    } else {
      if (isFuture) {
        return result + forms(key)[1];
      } else {
        return result + (special(number) ? forms(key)[1] : forms(key)[2]);
      }
    }
  }
  var lt = moment.defineLocale('lt', {
    months: {
      format: 'sausio_vasario_kovo_balandio_gegus_birelio_liepos_rugpjio_rugsjo_spalio_lapkriio_gruodio'.split('_'),
      standalone: 'sausis_vasaris_kovas_balandis_gegu_birelis_liepa_rugpjtis_rugsjis_spalis_lapkritis_gruodis'.split('_'),
      isFormat: /D[oD]?(\[[^\[\]]*\]|\s)+MMMM?|MMMM?(\[[^\[\]]*\]|\s)+D[oD]?/
    },
    monthsShort: 'sau_vas_kov_bal_geg_bir_lie_rgp_rgs_spa_lap_grd'.split('_'),
    weekdays: {
      format: 'sekmadien_pirmadien_antradien_treiadien_ketvirtadien_penktadien_etadien'.split('_'),
      standalone: 'sekmadienis_pirmadienis_antradienis_treiadienis_ketvirtadienis_penktadienis_etadienis'.split('_'),
      isFormat: /dddd HH:mm/
    },
    weekdaysShort: 'Sek_Pir_Ant_Tre_Ket_Pen_e'.split('_'),
    weekdaysMin: 'S_P_A_T_K_Pn_'.split('_'),
    weekdaysParseExact: true,
    longDateFormat: {
      LT: 'HH:mm',
      LTS: 'HH:mm:ss',
      L: 'YYYY-MM-DD',
      LL: 'YYYY [m.] MMMM D [d.]',
      LLL: 'YYYY [m.] MMMM D [d.], HH:mm [val.]',
      LLLL: 'YYYY [m.] MMMM D [d.], dddd, HH:mm [val.]',
      l: 'YYYY-MM-DD',
      ll: 'YYYY [m.] MMMM D [d.]',
      lll: 'YYYY [m.] MMMM D [d.], HH:mm [val.]',
      llll: 'YYYY [m.] MMMM D [d.], ddd, HH:mm [val.]'
    },
    calendar: {
      sameDay: '[iandien] LT',
      nextDay: '[Rytoj] LT',
      nextWeek: 'dddd LT',
      lastDay: '[Vakar] LT',
      lastWeek: '[Prajus] dddd LT',
      sameElse: 'L'
    },
    relativeTime: {
      future: 'po %s',
      past: 'prie %s',
      s: translateSeconds,
      ss: translate,
      m: translateSingular,
      mm: translate,
      h: translateSingular,
      hh: translate,
      d: translateSingular,
      dd: translate,
      M: translateSingular,
      MM: translate,
      y: translateSingular,
      yy: translate
    },
    dayOfMonthOrdinalParse: /\d{1,2}-oji/,
    ordinal: function (number) {
      return number + '-oji';
    },
    week: {
      dow: 1,
      // Monday is the first day of the week.
      doy: 4 // The week that contains Jan 4th is the first week of the year.
    }
  });
  return lt;
});

/***/ }),
/* 184 */
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Latvian [lv]
//! author : Kristaps Karlsons : https://github.com/skakri
//! author : Jnis Elmeris : https://github.com/JanisE

;
(function (global, factory) {
   true ? factory(__webpack_require__(105)) : 0;
})(this, function (moment) {
  'use strict';

  //! moment.js locale configuration
  var units = {
    ss: 'sekundes_sekundm_sekunde_sekundes'.split('_'),
    m: 'mintes_mintm_minte_mintes'.split('_'),
    mm: 'mintes_mintm_minte_mintes'.split('_'),
    h: 'stundas_stundm_stunda_stundas'.split('_'),
    hh: 'stundas_stundm_stunda_stundas'.split('_'),
    d: 'dienas_dienm_diena_dienas'.split('_'),
    dd: 'dienas_dienm_diena_dienas'.split('_'),
    M: 'mnea_mneiem_mnesis_mnei'.split('_'),
    MM: 'mnea_mneiem_mnesis_mnei'.split('_'),
    y: 'gada_gadiem_gads_gadi'.split('_'),
    yy: 'gada_gadiem_gads_gadi'.split('_')
  };
  /**
   * @param withoutSuffix boolean true = a length of time; false = before/after a period of time.
   */
  function format(forms, number, withoutSuffix) {
    if (withoutSuffix) {
      // E.g. "21 minte", "3 mintes".
      return number % 10 === 1 && number % 100 !== 11 ? forms[2] : forms[3];
    } else {
      // E.g. "21 mintes" as in "pc 21 mintes".
      // E.g. "3 mintm" as in "pc 3 mintm".
      return number % 10 === 1 && number % 100 !== 11 ? forms[0] : forms[1];
    }
  }
  function relativeTimeWithPlural(number, withoutSuffix, key) {
    return number + ' ' + format(units[key], number, withoutSuffix);
  }
  function relativeTimeWithSingular(number, withoutSuffix, key) {
    return format(units[key], number, withoutSuffix);
  }
  function relativeSeconds(number, withoutSuffix) {
    return withoutSuffix ? 'daas sekundes' : 'dam sekundm';
  }
  var lv = moment.defineLocale('lv', {
    months: 'janvris_februris_marts_aprlis_maijs_jnijs_jlijs_augusts_septembris_oktobris_novembris_decembris'.split('_'),
    monthsShort: 'jan_feb_mar_apr_mai_jn_jl_aug_sep_okt_nov_dec'.split('_'),
    weekdays: 'svtdiena_pirmdiena_otrdiena_trediena_ceturtdiena_piektdiena_sestdiena'.split('_'),
    weekdaysShort: 'Sv_P_O_T_C_Pk_S'.split('_'),
    weekdaysMin: 'Sv_P_O_T_C_Pk_S'.split('_'),
    weekdaysParseExact: true,
    longDateFormat: {
      LT: 'HH:mm',
      LTS: 'HH:mm:ss',
      L: 'DD.MM.YYYY.',
      LL: 'YYYY. [gada] D. MMMM',
      LLL: 'YYYY. [gada] D. MMMM, HH:mm',
      LLLL: 'YYYY. [gada] D. MMMM, dddd, HH:mm'
    },
    calendar: {
      sameDay: '[odien pulksten] LT',
      nextDay: '[Rt pulksten] LT',
      nextWeek: 'dddd [pulksten] LT',
      lastDay: '[Vakar pulksten] LT',
      lastWeek: '[Pagju] dddd [pulksten] LT',
      sameElse: 'L'
    },
    relativeTime: {
      future: 'pc %s',
      past: 'pirms %s',
      s: relativeSeconds,
      ss: relativeTimeWithPlural,
      m: relativeTimeWithSingular,
      mm: relativeTimeWithPlural,
      h: relativeTimeWithSingular,
      hh: relativeTimeWithPlural,
      d: relativeTimeWithSingular,
      dd: relativeTimeWithPlural,
      M: relativeTimeWithSingular,
      MM: relativeTimeWithPlural,
      y: relativeTimeWithSingular,
      yy: relativeTimeWithPlural
    },
    dayOfMonthOrdinalParse: /\d{1,2}\./,
    ordinal: '%d.',
    week: {
      dow: 1,
      // Monday is the first day of the week.
      doy: 4 // The week that contains Jan 4th is the first week of the year.
    }
  });
  return lv;
});

/***/ }),
/* 185 */
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Montenegrin [me]
//! author : Miodrag Nika <miodrag@restartit.me> : https://github.com/miodragnikac

;
(function (global, factory) {
   true ? factory(__webpack_require__(105)) : 0;
})(this, function (moment) {
  'use strict';

  //! moment.js locale configuration
  var translator = {
    words: {
      //Different grammatical cases
      ss: ['sekund', 'sekunda', 'sekundi'],
      m: ['jedan minut', 'jednog minuta'],
      mm: ['minut', 'minuta', 'minuta'],
      h: ['jedan sat', 'jednog sata'],
      hh: ['sat', 'sata', 'sati'],
      dd: ['dan', 'dana', 'dana'],
      MM: ['mjesec', 'mjeseca', 'mjeseci'],
      yy: ['godina', 'godine', 'godina']
    },
    correctGrammaticalCase: function (number, wordKey) {
      return number === 1 ? wordKey[0] : number >= 2 && number <= 4 ? wordKey[1] : wordKey[2];
    },
    translate: function (number, withoutSuffix, key) {
      var wordKey = translator.words[key];
      if (key.length === 1) {
        return withoutSuffix ? wordKey[0] : wordKey[1];
      } else {
        return number + ' ' + translator.correctGrammaticalCase(number, wordKey);
      }
    }
  };
  var me = moment.defineLocale('me', {
    months: 'januar_februar_mart_april_maj_jun_jul_avgust_septembar_oktobar_novembar_decembar'.split('_'),
    monthsShort: 'jan._feb._mar._apr._maj_jun_jul_avg._sep._okt._nov._dec.'.split('_'),
    monthsParseExact: true,
    weekdays: 'nedjelja_ponedjeljak_utorak_srijeda_etvrtak_petak_subota'.split('_'),
    weekdaysShort: 'ned._pon._uto._sri._et._pet._sub.'.split('_'),
    weekdaysMin: 'ne_po_ut_sr_e_pe_su'.split('_'),
    weekdaysParseExact: true,
    longDateFormat: {
      LT: 'H:mm',
      LTS: 'H:mm:ss',
      L: 'DD.MM.YYYY',
      LL: 'D. MMMM YYYY',
      LLL: 'D. MMMM YYYY H:mm',
      LLLL: 'dddd, D. MMMM YYYY H:mm'
    },
    calendar: {
      sameDay: '[danas u] LT',
      nextDay: '[sjutra u] LT',
      nextWeek: function () {
        switch (this.day()) {
          case 0:
            return '[u] [nedjelju] [u] LT';
          case 3:
            return '[u] [srijedu] [u] LT';
          case 6:
            return '[u] [subotu] [u] LT';
          case 1:
          case 2:
          case 4:
          case 5:
            return '[u] dddd [u] LT';
        }
      },
      lastDay: '[jue u] LT',
      lastWeek: function () {
        var lastWeekDays = ['[prole] [nedjelje] [u] LT', '[prolog] [ponedjeljka] [u] LT', '[prolog] [utorka] [u] LT', '[prole] [srijede] [u] LT', '[prolog] [etvrtka] [u] LT', '[prolog] [petka] [u] LT', '[prole] [subote] [u] LT'];
        return lastWeekDays[this.day()];
      },
      sameElse: 'L'
    },
    relativeTime: {
      future: 'za %s',
      past: 'prije %s',
      s: 'nekoliko sekundi',
      ss: translator.translate,
      m: translator.translate,
      mm: translator.translate,
      h: translator.translate,
      hh: translator.translate,
      d: 'dan',
      dd: translator.translate,
      M: 'mjesec',
      MM: translator.translate,
      y: 'godinu',
      yy: translator.translate
    },
    dayOfMonthOrdinalParse: /\d{1,2}\./,
    ordinal: '%d.',
    week: {
      dow: 1,
      // Monday is the first day of the week.
      doy: 7 // The week that contains Jan 7th is the first week of the year.
    }
  });
  return me;
});

/***/ }),
/* 186 */
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Maori [mi]
//! author : John Corrigan <robbiecloset@gmail.com> : https://github.com/johnideal

;
(function (global, factory) {
   true ? factory(__webpack_require__(105)) : 0;
})(this, function (moment) {
  'use strict';

  //! moment.js locale configuration
  var mi = moment.defineLocale('mi', {
    months: 'Kohi-tte_Hui-tanguru_Pout-te-rangi_Paenga-whwh_Haratua_Pipiri_Hngoingoi_Here-turi-kk_Mahuru_Whiringa--nuku_Whiringa--rangi_Hakihea'.split('_'),
    monthsShort: 'Kohi_Hui_Pou_Pae_Hara_Pipi_Hngoi_Here_Mahu_Whi-nu_Whi-ra_Haki'.split('_'),
    monthsRegex: /(?:['a-z\u0101\u014D\u016B]+\-?){1,3}/i,
    monthsStrictRegex: /(?:['a-z\u0101\u014D\u016B]+\-?){1,3}/i,
    monthsShortRegex: /(?:['a-z\u0101\u014D\u016B]+\-?){1,3}/i,
    monthsShortStrictRegex: /(?:['a-z\u0101\u014D\u016B]+\-?){1,2}/i,
    weekdays: 'Rtapu_Mane_Trei_Wenerei_Tite_Paraire_Htarei'.split('_'),
    weekdaysShort: 'Ta_Ma_T_We_Ti_Pa_H'.split('_'),
    weekdaysMin: 'Ta_Ma_T_We_Ti_Pa_H'.split('_'),
    longDateFormat: {
      LT: 'HH:mm',
      LTS: 'HH:mm:ss',
      L: 'DD/MM/YYYY',
      LL: 'D MMMM YYYY',
      LLL: 'D MMMM YYYY [i] HH:mm',
      LLLL: 'dddd, D MMMM YYYY [i] HH:mm'
    },
    calendar: {
      sameDay: '[i teie mahana, i] LT',
      nextDay: '[apopo i] LT',
      nextWeek: 'dddd [i] LT',
      lastDay: '[inanahi i] LT',
      lastWeek: 'dddd [whakamutunga i] LT',
      sameElse: 'L'
    },
    relativeTime: {
      future: 'i roto i %s',
      past: '%s i mua',
      s: 'te hkona ruarua',
      ss: '%d hkona',
      m: 'he meneti',
      mm: '%d meneti',
      h: 'te haora',
      hh: '%d haora',
      d: 'he ra',
      dd: '%d ra',
      M: 'he marama',
      MM: '%d marama',
      y: 'he tau',
      yy: '%d tau'
    },
    dayOfMonthOrdinalParse: /\d{1,2}/,
    ordinal: '%d',
    week: {
      dow: 1,
      // Monday is the first day of the week.
      doy: 4 // The week that contains Jan 4th is the first week of the year.
    }
  });
  return mi;
});

/***/ }),
/* 187 */
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Macedonian [mk]
//! author : Borislav Mickov : https://github.com/B0k0
//! author : Sashko Todorov : https://github.com/bkyceh

;
(function (global, factory) {
   true ? factory(__webpack_require__(105)) : 0;
})(this, function (moment) {
  'use strict';

  //! moment.js locale configuration
  var mk = moment.defineLocale('mk', {
    months: '___________'.split('_'),
    monthsShort: '___________'.split('_'),
    weekdays: '______'.split('_'),
    weekdaysShort: '______'.split('_'),
    weekdaysMin: 'e_o_____a'.split('_'),
    longDateFormat: {
      LT: 'H:mm',
      LTS: 'H:mm:ss',
      L: 'D.MM.YYYY',
      LL: 'D MMMM YYYY',
      LLL: 'D MMMM YYYY H:mm',
      LLLL: 'dddd, D MMMM YYYY H:mm'
    },
    calendar: {
      sameDay: '[ ] LT',
      nextDay: '[ ] LT',
      nextWeek: '[] dddd [] LT',
      lastDay: '[ ] LT',
      lastWeek: function () {
        switch (this.day()) {
          case 0:
          case 3:
          case 6:
            return '[] dddd [] LT';
          case 1:
          case 2:
          case 4:
          case 5:
            return '[] dddd [] LT';
        }
      },
      sameElse: 'L'
    },
    relativeTime: {
      future: ' %s',
      past: ' %s',
      s: ' ',
      ss: '%d ',
      m: ' ',
      mm: '%d ',
      h: ' ',
      hh: '%d ',
      d: ' ',
      dd: '%d ',
      M: ' ',
      MM: '%d ',
      y: ' ',
      yy: '%d '
    },
    dayOfMonthOrdinalParse: /\d{1,2}-(|||||)/,
    ordinal: function (number) {
      var lastDigit = number % 10,
        last2Digits = number % 100;
      if (number === 0) {
        return number + '-';
      } else if (last2Digits === 0) {
        return number + '-';
      } else if (last2Digits > 10 && last2Digits < 20) {
        return number + '-';
      } else if (lastDigit === 1) {
        return number + '-';
      } else if (lastDigit === 2) {
        return number + '-';
      } else if (lastDigit === 7 || lastDigit === 8) {
        return number + '-';
      } else {
        return number + '-';
      }
    },
    week: {
      dow: 1,
      // Monday is the first day of the week.
      doy: 7 // The week that contains Jan 7th is the first week of the year.
    }
  });
  return mk;
});

/***/ }),
/* 188 */
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Malayalam [ml]
//! author : Floyd Pink : https://github.com/floydpink

;
(function (global, factory) {
   true ? factory(__webpack_require__(105)) : 0;
})(this, function (moment) {
  'use strict';

  //! moment.js locale configuration
  var ml = moment.defineLocale('ml', {
    months: '___________'.split('_'),
    monthsShort: '._._._.___._._._._._.'.split('_'),
    monthsParseExact: true,
    weekdays: '______'.split('_'),
    weekdaysShort: '______'.split('_'),
    weekdaysMin: '______'.split('_'),
    longDateFormat: {
      LT: 'A h:mm -',
      LTS: 'A h:mm:ss -',
      L: 'DD/MM/YYYY',
      LL: 'D MMMM YYYY',
      LLL: 'D MMMM YYYY, A h:mm -',
      LLLL: 'dddd, D MMMM YYYY, A h:mm -'
    },
    calendar: {
      sameDay: '[] LT',
      nextDay: '[] LT',
      nextWeek: 'dddd, LT',
      lastDay: '[] LT',
      lastWeek: '[] dddd, LT',
      sameElse: 'L'
    },
    relativeTime: {
      future: '%s ',
      past: '%s ',
      s: ' ',
      ss: '%d ',
      m: ' ',
      mm: '%d ',
      h: ' ',
      hh: '%d ',
      d: ' ',
      dd: '%d ',
      M: ' ',
      MM: '%d ',
      y: ' ',
      yy: '%d '
    },
    meridiemParse: /|| ||/i,
    meridiemHour: function (hour, meridiem) {
      if (hour === 12) {
        hour = 0;
      }
      if (meridiem === '' && hour >= 4 || meridiem === ' ' || meridiem === '') {
        return hour + 12;
      } else {
        return hour;
      }
    },
    meridiem: function (hour, minute, isLower) {
      if (hour < 4) {
        return '';
      } else if (hour < 12) {
        return '';
      } else if (hour < 17) {
        return ' ';
      } else if (hour < 20) {
        return '';
      } else {
        return '';
      }
    }
  });
  return ml;
});

/***/ }),
/* 189 */
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Mongolian [mn]
//! author : Javkhlantugs Nyamdorj : https://github.com/javkhaanj7

;
(function (global, factory) {
   true ? factory(__webpack_require__(105)) : 0;
})(this, function (moment) {
  'use strict';

  //! moment.js locale configuration
  function translate(number, withoutSuffix, key, isFuture) {
    switch (key) {
      case 's':
        return withoutSuffix ? ' ' : ' ';
      case 'ss':
        return number + (withoutSuffix ? ' ' : ' ');
      case 'm':
      case 'mm':
        return number + (withoutSuffix ? ' ' : ' ');
      case 'h':
      case 'hh':
        return number + (withoutSuffix ? ' ' : ' ');
      case 'd':
      case 'dd':
        return number + (withoutSuffix ? ' ' : ' ');
      case 'M':
      case 'MM':
        return number + (withoutSuffix ? ' ' : ' ');
      case 'y':
      case 'yy':
        return number + (withoutSuffix ? ' ' : ' ');
      default:
        return number;
    }
  }
  var mn = moment.defineLocale('mn', {
    months: ' _ _ _ _ _ _ _ _ _ _  _  '.split('_'),
    monthsShort: '1 _2 _3 _4 _5 _6 _7 _8 _9 _10 _11 _12 '.split('_'),
    monthsParseExact: true,
    weekdays: '______'.split('_'),
    weekdaysShort: '______'.split('_'),
    weekdaysMin: '______'.split('_'),
    weekdaysParseExact: true,
    longDateFormat: {
      LT: 'HH:mm',
      LTS: 'HH:mm:ss',
      L: 'YYYY-MM-DD',
      LL: 'YYYY  MMMM D',
      LLL: 'YYYY  MMMM D HH:mm',
      LLLL: 'dddd, YYYY  MMMM D HH:mm'
    },
    meridiemParse: /|/i,
    isPM: function (input) {
      return input === '';
    },
    meridiem: function (hour, minute, isLower) {
      if (hour < 12) {
        return '';
      } else {
        return '';
      }
    },
    calendar: {
      sameDay: '[] LT',
      nextDay: '[] LT',
      nextWeek: '[] dddd LT',
      lastDay: '[] LT',
      lastWeek: '[] dddd LT',
      sameElse: 'L'
    },
    relativeTime: {
      future: '%s ',
      past: '%s ',
      s: translate,
      ss: translate,
      m: translate,
      mm: translate,
      h: translate,
      hh: translate,
      d: translate,
      dd: translate,
      M: translate,
      MM: translate,
      y: translate,
      yy: translate
    },
    dayOfMonthOrdinalParse: /\d{1,2} /,
    ordinal: function (number, period) {
      switch (period) {
        case 'd':
        case 'D':
        case 'DDD':
          return number + ' ';
        default:
          return number;
      }
    }
  });
  return mn;
});

/***/ }),
/* 190 */
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Marathi [mr]
//! author : Harshad Kale : https://github.com/kalehv
//! author : Vivek Athalye : https://github.com/vnathalye

;
(function (global, factory) {
   true ? factory(__webpack_require__(105)) : 0;
})(this, function (moment) {
  'use strict';

  //! moment.js locale configuration
  var symbolMap = {
      1: '',
      2: '',
      3: '',
      4: '',
      5: '',
      6: '',
      7: '',
      8: '',
      9: '',
      0: ''
    },
    numberMap = {
      '': '1',
      '': '2',
      '': '3',
      '': '4',
      '': '5',
      '': '6',
      '': '7',
      '': '8',
      '': '9',
      '': '0'
    };
  function relativeTimeMr(number, withoutSuffix, string, isFuture) {
    var output = '';
    if (withoutSuffix) {
      switch (string) {
        case 's':
          output = ' ';
          break;
        case 'ss':
          output = '%d ';
          break;
        case 'm':
          output = ' ';
          break;
        case 'mm':
          output = '%d ';
          break;
        case 'h':
          output = ' ';
          break;
        case 'hh':
          output = '%d ';
          break;
        case 'd':
          output = ' ';
          break;
        case 'dd':
          output = '%d ';
          break;
        case 'M':
          output = ' ';
          break;
        case 'MM':
          output = '%d ';
          break;
        case 'y':
          output = ' ';
          break;
        case 'yy':
          output = '%d ';
          break;
      }
    } else {
      switch (string) {
        case 's':
          output = ' ';
          break;
        case 'ss':
          output = '%d ';
          break;
        case 'm':
          output = ' ';
          break;
        case 'mm':
          output = '%d ';
          break;
        case 'h':
          output = ' ';
          break;
        case 'hh':
          output = '%d ';
          break;
        case 'd':
          output = ' ';
          break;
        case 'dd':
          output = '%d ';
          break;
        case 'M':
          output = ' ';
          break;
        case 'MM':
          output = '%d ';
          break;
        case 'y':
          output = ' ';
          break;
        case 'yy':
          output = '%d ';
          break;
      }
    }
    return output.replace(/%d/i, number);
  }
  var mr = moment.defineLocale('mr', {
    months: '___________'.split('_'),
    monthsShort: '._._._._._._._._._._._.'.split('_'),
    monthsParseExact: true,
    weekdays: '______'.split('_'),
    weekdaysShort: '______'.split('_'),
    weekdaysMin: '______'.split('_'),
    longDateFormat: {
      LT: 'A h:mm ',
      LTS: 'A h:mm:ss ',
      L: 'DD/MM/YYYY',
      LL: 'D MMMM YYYY',
      LLL: 'D MMMM YYYY, A h:mm ',
      LLLL: 'dddd, D MMMM YYYY, A h:mm '
    },
    calendar: {
      sameDay: '[] LT',
      nextDay: '[] LT',
      nextWeek: 'dddd, LT',
      lastDay: '[] LT',
      lastWeek: '[] dddd, LT',
      sameElse: 'L'
    },
    relativeTime: {
      future: '%s',
      past: '%s',
      s: relativeTimeMr,
      ss: relativeTimeMr,
      m: relativeTimeMr,
      mm: relativeTimeMr,
      h: relativeTimeMr,
      hh: relativeTimeMr,
      d: relativeTimeMr,
      dd: relativeTimeMr,
      M: relativeTimeMr,
      MM: relativeTimeMr,
      y: relativeTimeMr,
      yy: relativeTimeMr
    },
    preparse: function (string) {
      return string.replace(/[]/g, function (match) {
        return numberMap[match];
      });
    },
    postformat: function (string) {
      return string.replace(/\d/g, function (match) {
        return symbolMap[match];
      });
    },
    meridiemParse: /||||/,
    meridiemHour: function (hour, meridiem) {
      if (hour === 12) {
        hour = 0;
      }
      if (meridiem === '' || meridiem === '') {
        return hour;
      } else if (meridiem === '' || meridiem === '' || meridiem === '') {
        return hour >= 12 ? hour : hour + 12;
      }
    },
    meridiem: function (hour, minute, isLower) {
      if (hour >= 0 && hour < 6) {
        return '';
      } else if (hour < 12) {
        return '';
      } else if (hour < 17) {
        return '';
      } else if (hour < 20) {
        return '';
      } else {
        return '';
      }
    },
    week: {
      dow: 0,
      // Sunday is the first day of the week.
      doy: 6 // The week that contains Jan 6th is the first week of the year.
    }
  });
  return mr;
});

/***/ }),
/* 191 */
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Malay [ms]
//! author : Weldan Jamili : https://github.com/weldan

;
(function (global, factory) {
   true ? factory(__webpack_require__(105)) : 0;
})(this, function (moment) {
  'use strict';

  //! moment.js locale configuration
  var ms = moment.defineLocale('ms', {
    months: 'Januari_Februari_Mac_April_Mei_Jun_Julai_Ogos_September_Oktober_November_Disember'.split('_'),
    monthsShort: 'Jan_Feb_Mac_Apr_Mei_Jun_Jul_Ogs_Sep_Okt_Nov_Dis'.split('_'),
    weekdays: 'Ahad_Isnin_Selasa_Rabu_Khamis_Jumaat_Sabtu'.split('_'),
    weekdaysShort: 'Ahd_Isn_Sel_Rab_Kha_Jum_Sab'.split('_'),
    weekdaysMin: 'Ah_Is_Sl_Rb_Km_Jm_Sb'.split('_'),
    longDateFormat: {
      LT: 'HH.mm',
      LTS: 'HH.mm.ss',
      L: 'DD/MM/YYYY',
      LL: 'D MMMM YYYY',
      LLL: 'D MMMM YYYY [pukul] HH.mm',
      LLLL: 'dddd, D MMMM YYYY [pukul] HH.mm'
    },
    meridiemParse: /pagi|tengahari|petang|malam/,
    meridiemHour: function (hour, meridiem) {
      if (hour === 12) {
        hour = 0;
      }
      if (meridiem === 'pagi') {
        return hour;
      } else if (meridiem === 'tengahari') {
        return hour >= 11 ? hour : hour + 12;
      } else if (meridiem === 'petang' || meridiem === 'malam') {
        return hour + 12;
      }
    },
    meridiem: function (hours, minutes, isLower) {
      if (hours < 11) {
        return 'pagi';
      } else if (hours < 15) {
        return 'tengahari';
      } else if (hours < 19) {
        return 'petang';
      } else {
        return 'malam';
      }
    },
    calendar: {
      sameDay: '[Hari ini pukul] LT',
      nextDay: '[Esok pukul] LT',
      nextWeek: 'dddd [pukul] LT',
      lastDay: '[Kelmarin pukul] LT',
      lastWeek: 'dddd [lepas pukul] LT',
      sameElse: 'L'
    },
    relativeTime: {
      future: 'dalam %s',
      past: '%s yang lepas',
      s: 'beberapa saat',
      ss: '%d saat',
      m: 'seminit',
      mm: '%d minit',
      h: 'sejam',
      hh: '%d jam',
      d: 'sehari',
      dd: '%d hari',
      M: 'sebulan',
      MM: '%d bulan',
      y: 'setahun',
      yy: '%d tahun'
    },
    week: {
      dow: 1,
      // Monday is the first day of the week.
      doy: 7 // The week that contains Jan 7th is the first week of the year.
    }
  });
  return ms;
});

/***/ }),
/* 192 */
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Malay [ms-my]
//! note : DEPRECATED, the correct one is [ms]
//! author : Weldan Jamili : https://github.com/weldan

;
(function (global, factory) {
   true ? factory(__webpack_require__(105)) : 0;
})(this, function (moment) {
  'use strict';

  //! moment.js locale configuration
  var msMy = moment.defineLocale('ms-my', {
    months: 'Januari_Februari_Mac_April_Mei_Jun_Julai_Ogos_September_Oktober_November_Disember'.split('_'),
    monthsShort: 'Jan_Feb_Mac_Apr_Mei_Jun_Jul_Ogs_Sep_Okt_Nov_Dis'.split('_'),
    weekdays: 'Ahad_Isnin_Selasa_Rabu_Khamis_Jumaat_Sabtu'.split('_'),
    weekdaysShort: 'Ahd_Isn_Sel_Rab_Kha_Jum_Sab'.split('_'),
    weekdaysMin: 'Ah_Is_Sl_Rb_Km_Jm_Sb'.split('_'),
    longDateFormat: {
      LT: 'HH.mm',
      LTS: 'HH.mm.ss',
      L: 'DD/MM/YYYY',
      LL: 'D MMMM YYYY',
      LLL: 'D MMMM YYYY [pukul] HH.mm',
      LLLL: 'dddd, D MMMM YYYY [pukul] HH.mm'
    },
    meridiemParse: /pagi|tengahari|petang|malam/,
    meridiemHour: function (hour, meridiem) {
      if (hour === 12) {
        hour = 0;
      }
      if (meridiem === 'pagi') {
        return hour;
      } else if (meridiem === 'tengahari') {
        return hour >= 11 ? hour : hour + 12;
      } else if (meridiem === 'petang' || meridiem === 'malam') {
        return hour + 12;
      }
    },
    meridiem: function (hours, minutes, isLower) {
      if (hours < 11) {
        return 'pagi';
      } else if (hours < 15) {
        return 'tengahari';
      } else if (hours < 19) {
        return 'petang';
      } else {
        return 'malam';
      }
    },
    calendar: {
      sameDay: '[Hari ini pukul] LT',
      nextDay: '[Esok pukul] LT',
      nextWeek: 'dddd [pukul] LT',
      lastDay: '[Kelmarin pukul] LT',
      lastWeek: 'dddd [lepas pukul] LT',
      sameElse: 'L'
    },
    relativeTime: {
      future: 'dalam %s',
      past: '%s yang lepas',
      s: 'beberapa saat',
      ss: '%d saat',
      m: 'seminit',
      mm: '%d minit',
      h: 'sejam',
      hh: '%d jam',
      d: 'sehari',
      dd: '%d hari',
      M: 'sebulan',
      MM: '%d bulan',
      y: 'setahun',
      yy: '%d tahun'
    },
    week: {
      dow: 1,
      // Monday is the first day of the week.
      doy: 7 // The week that contains Jan 7th is the first week of the year.
    }
  });
  return msMy;
});

/***/ }),
/* 193 */
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Maltese (Malta) [mt]
//! author : Alessandro Maruccia : https://github.com/alesma

;
(function (global, factory) {
   true ? factory(__webpack_require__(105)) : 0;
})(this, function (moment) {
  'use strict';

  //! moment.js locale configuration
  var mt = moment.defineLocale('mt', {
    months: 'Jannar_Frar_Marzu_April_Mejju_unju_Lulju_Awwissu_Settembru_Ottubru_Novembru_Diembru'.split('_'),
    monthsShort: 'Jan_Fra_Mar_Apr_Mej_un_Lul_Aww_Set_Ott_Nov_Di'.split('_'),
    weekdays: 'Il-add_It-Tnejn_It-Tlieta_L-Erbga_Il-amis_Il-imga_Is-Sibt'.split('_'),
    weekdaysShort: 'ad_Tne_Tli_Erb_am_im_Sib'.split('_'),
    weekdaysMin: 'a_Tn_Tl_Er_a_i_Si'.split('_'),
    longDateFormat: {
      LT: 'HH:mm',
      LTS: 'HH:mm:ss',
      L: 'DD/MM/YYYY',
      LL: 'D MMMM YYYY',
      LLL: 'D MMMM YYYY HH:mm',
      LLLL: 'dddd, D MMMM YYYY HH:mm'
    },
    calendar: {
      sameDay: '[Illum fil-]LT',
      nextDay: '[Gada fil-]LT',
      nextWeek: 'dddd [fil-]LT',
      lastDay: '[Il-biera fil-]LT',
      lastWeek: 'dddd [li gadda] [fil-]LT',
      sameElse: 'L'
    },
    relativeTime: {
      future: 'f %s',
      past: '%s ilu',
      s: 'ftit sekondi',
      ss: '%d sekondi',
      m: 'minuta',
      mm: '%d minuti',
      h: 'siega',
      hh: '%d siegat',
      d: 'urnata',
      dd: '%d ranet',
      M: 'xahar',
      MM: '%d xhur',
      y: 'sena',
      yy: '%d sni'
    },
    dayOfMonthOrdinalParse: /\d{1,2}/,
    ordinal: '%d',
    week: {
      dow: 1,
      // Monday is the first day of the week.
      doy: 4 // The week that contains Jan 4th is the first week of the year.
    }
  });
  return mt;
});

/***/ }),
/* 194 */
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Burmese [my]
//! author : Squar team, mysquar.com
//! author : David Rossellat : https://github.com/gholadr
//! author : Tin Aung Lin : https://github.com/thanyawzinmin

;
(function (global, factory) {
   true ? factory(__webpack_require__(105)) : 0;
})(this, function (moment) {
  'use strict';

  //! moment.js locale configuration
  var symbolMap = {
      1: '',
      2: '',
      3: '',
      4: '',
      5: '',
      6: '',
      7: '',
      8: '',
      9: '',
      0: ''
    },
    numberMap = {
      '': '1',
      '': '2',
      '': '3',
      '': '4',
      '': '5',
      '': '6',
      '': '7',
      '': '8',
      '': '9',
      '': '0'
    };
  var my = moment.defineLocale('my', {
    months: '___________'.split('_'),
    monthsShort: '___________'.split('_'),
    weekdays: '______'.split('_'),
    weekdaysShort: '______'.split('_'),
    weekdaysMin: '______'.split('_'),
    longDateFormat: {
      LT: 'HH:mm',
      LTS: 'HH:mm:ss',
      L: 'DD/MM/YYYY',
      LL: 'D MMMM YYYY',
      LLL: 'D MMMM YYYY HH:mm',
      LLLL: 'dddd D MMMM YYYY HH:mm'
    },
    calendar: {
      sameDay: '[.] LT []',
      nextDay: '[] LT []',
      nextWeek: 'dddd LT []',
      lastDay: '[.] LT []',
      lastWeek: '[] dddd LT []',
      sameElse: 'L'
    },
    relativeTime: {
      future: ' %s ',
      past: ' %s ',
      s: '.',
      ss: '%d ',
      m: '',
      mm: '%d ',
      h: '',
      hh: '%d ',
      d: '',
      dd: '%d ',
      M: '',
      MM: '%d ',
      y: '',
      yy: '%d '
    },
    preparse: function (string) {
      return string.replace(/[]/g, function (match) {
        return numberMap[match];
      });
    },
    postformat: function (string) {
      return string.replace(/\d/g, function (match) {
        return symbolMap[match];
      });
    },
    week: {
      dow: 1,
      // Monday is the first day of the week.
      doy: 4 // The week that contains Jan 4th is the first week of the year.
    }
  });
  return my;
});

/***/ }),
/* 195 */
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Norwegian Bokml [nb]
//! authors : Espen Hovlandsdal : https://github.com/rexxars
//!           Sigurd Gartmann : https://github.com/sigurdga
//!           Stephen Ramthun : https://github.com/stephenramthun

;
(function (global, factory) {
   true ? factory(__webpack_require__(105)) : 0;
})(this, function (moment) {
  'use strict';

  //! moment.js locale configuration
  var nb = moment.defineLocale('nb', {
    months: 'januar_februar_mars_april_mai_juni_juli_august_september_oktober_november_desember'.split('_'),
    monthsShort: 'jan._feb._mars_apr._mai_juni_juli_aug._sep._okt._nov._des.'.split('_'),
    monthsParseExact: true,
    weekdays: 'sndag_mandag_tirsdag_onsdag_torsdag_fredag_lrdag'.split('_'),
    weekdaysShort: 's._ma._ti._on._to._fr._l.'.split('_'),
    weekdaysMin: 's_ma_ti_on_to_fr_l'.split('_'),
    weekdaysParseExact: true,
    longDateFormat: {
      LT: 'HH:mm',
      LTS: 'HH:mm:ss',
      L: 'DD.MM.YYYY',
      LL: 'D. MMMM YYYY',
      LLL: 'D. MMMM YYYY [kl.] HH:mm',
      LLLL: 'dddd D. MMMM YYYY [kl.] HH:mm'
    },
    calendar: {
      sameDay: '[i dag kl.] LT',
      nextDay: '[i morgen kl.] LT',
      nextWeek: 'dddd [kl.] LT',
      lastDay: '[i gr kl.] LT',
      lastWeek: '[forrige] dddd [kl.] LT',
      sameElse: 'L'
    },
    relativeTime: {
      future: 'om %s',
      past: '%s siden',
      s: 'noen sekunder',
      ss: '%d sekunder',
      m: 'ett minutt',
      mm: '%d minutter',
      h: 'en time',
      hh: '%d timer',
      d: 'en dag',
      dd: '%d dager',
      w: 'en uke',
      ww: '%d uker',
      M: 'en mned',
      MM: '%d mneder',
      y: 'ett r',
      yy: '%d r'
    },
    dayOfMonthOrdinalParse: /\d{1,2}\./,
    ordinal: '%d.',
    week: {
      dow: 1,
      // Monday is the first day of the week.
      doy: 4 // The week that contains Jan 4th is the first week of the year.
    }
  });
  return nb;
});

/***/ }),
/* 196 */
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Nepalese [ne]
//! author : suvash : https://github.com/suvash

;
(function (global, factory) {
   true ? factory(__webpack_require__(105)) : 0;
})(this, function (moment) {
  'use strict';

  //! moment.js locale configuration
  var symbolMap = {
      1: '',
      2: '',
      3: '',
      4: '',
      5: '',
      6: '',
      7: '',
      8: '',
      9: '',
      0: ''
    },
    numberMap = {
      '': '1',
      '': '2',
      '': '3',
      '': '4',
      '': '5',
      '': '6',
      '': '7',
      '': '8',
      '': '9',
      '': '0'
    };
  var ne = moment.defineLocale('ne', {
    months: '___________'.split('_'),
    monthsShort: '._.__.___._._._._._.'.split('_'),
    monthsParseExact: true,
    weekdays: '______'.split('_'),
    weekdaysShort: '._._._._._._.'.split('_'),
    weekdaysMin: '._._._._._._.'.split('_'),
    weekdaysParseExact: true,
    longDateFormat: {
      LT: 'A h:mm ',
      LTS: 'A h:mm:ss ',
      L: 'DD/MM/YYYY',
      LL: 'D MMMM YYYY',
      LLL: 'D MMMM YYYY, A h:mm ',
      LLLL: 'dddd, D MMMM YYYY, A h:mm '
    },
    preparse: function (string) {
      return string.replace(/[]/g, function (match) {
        return numberMap[match];
      });
    },
    postformat: function (string) {
      return string.replace(/\d/g, function (match) {
        return symbolMap[match];
      });
    },
    meridiemParse: /|||/,
    meridiemHour: function (hour, meridiem) {
      if (hour === 12) {
        hour = 0;
      }
      if (meridiem === '') {
        return hour < 4 ? hour : hour + 12;
      } else if (meridiem === '') {
        return hour;
      } else if (meridiem === '') {
        return hour >= 10 ? hour : hour + 12;
      } else if (meridiem === '') {
        return hour + 12;
      }
    },
    meridiem: function (hour, minute, isLower) {
      if (hour < 3) {
        return '';
      } else if (hour < 12) {
        return '';
      } else if (hour < 16) {
        return '';
      } else if (hour < 20) {
        return '';
      } else {
        return '';
      }
    },
    calendar: {
      sameDay: '[] LT',
      nextDay: '[] LT',
      nextWeek: '[] dddd[,] LT',
      lastDay: '[] LT',
      lastWeek: '[] dddd[,] LT',
      sameElse: 'L'
    },
    relativeTime: {
      future: '%s',
      past: '%s ',
      s: ' ',
      ss: '%d ',
      m: ' ',
      mm: '%d ',
      h: ' ',
      hh: '%d ',
      d: ' ',
      dd: '%d ',
      M: ' ',
      MM: '%d ',
      y: ' ',
      yy: '%d '
    },
    week: {
      dow: 0,
      // Sunday is the first day of the week.
      doy: 6 // The week that contains Jan 6th is the first week of the year.
    }
  });
  return ne;
});

/***/ }),
/* 197 */
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Dutch [nl]
//! author : Joris Rling : https://github.com/jorisroling
//! author : Jacob Middag : https://github.com/middagj

;
(function (global, factory) {
   true ? factory(__webpack_require__(105)) : 0;
})(this, function (moment) {
  'use strict';

  //! moment.js locale configuration
  var monthsShortWithDots = 'jan._feb._mrt._apr._mei_jun._jul._aug._sep._okt._nov._dec.'.split('_'),
    monthsShortWithoutDots = 'jan_feb_mrt_apr_mei_jun_jul_aug_sep_okt_nov_dec'.split('_'),
    monthsParse = [/^jan/i, /^feb/i, /^maart|mrt.?$/i, /^apr/i, /^mei$/i, /^jun[i.]?$/i, /^jul[i.]?$/i, /^aug/i, /^sep/i, /^okt/i, /^nov/i, /^dec/i],
    monthsRegex = /^(januari|februari|maart|april|mei|ju[nl]i|augustus|september|oktober|november|december|jan\.?|feb\.?|mrt\.?|apr\.?|ju[nl]\.?|aug\.?|sep\.?|okt\.?|nov\.?|dec\.?)/i;
  var nl = moment.defineLocale('nl', {
    months: 'januari_februari_maart_april_mei_juni_juli_augustus_september_oktober_november_december'.split('_'),
    monthsShort: function (m, format) {
      if (!m) {
        return monthsShortWithDots;
      } else if (/-MMM-/.test(format)) {
        return monthsShortWithoutDots[m.month()];
      } else {
        return monthsShortWithDots[m.month()];
      }
    },
    monthsRegex: monthsRegex,
    monthsShortRegex: monthsRegex,
    monthsStrictRegex: /^(januari|februari|maart|april|mei|ju[nl]i|augustus|september|oktober|november|december)/i,
    monthsShortStrictRegex: /^(jan\.?|feb\.?|mrt\.?|apr\.?|mei|ju[nl]\.?|aug\.?|sep\.?|okt\.?|nov\.?|dec\.?)/i,
    monthsParse: monthsParse,
    longMonthsParse: monthsParse,
    shortMonthsParse: monthsParse,
    weekdays: 'zondag_maandag_dinsdag_woensdag_donderdag_vrijdag_zaterdag'.split('_'),
    weekdaysShort: 'zo._ma._di._wo._do._vr._za.'.split('_'),
    weekdaysMin: 'zo_ma_di_wo_do_vr_za'.split('_'),
    weekdaysParseExact: true,
    longDateFormat: {
      LT: 'HH:mm',
      LTS: 'HH:mm:ss',
      L: 'DD-MM-YYYY',
      LL: 'D MMMM YYYY',
      LLL: 'D MMMM YYYY HH:mm',
      LLLL: 'dddd D MMMM YYYY HH:mm'
    },
    calendar: {
      sameDay: '[vandaag om] LT',
      nextDay: '[morgen om] LT',
      nextWeek: 'dddd [om] LT',
      lastDay: '[gisteren om] LT',
      lastWeek: '[afgelopen] dddd [om] LT',
      sameElse: 'L'
    },
    relativeTime: {
      future: 'over %s',
      past: '%s geleden',
      s: 'een paar seconden',
      ss: '%d seconden',
      m: 'n minuut',
      mm: '%d minuten',
      h: 'n uur',
      hh: '%d uur',
      d: 'n dag',
      dd: '%d dagen',
      w: 'n week',
      ww: '%d weken',
      M: 'n maand',
      MM: '%d maanden',
      y: 'n jaar',
      yy: '%d jaar'
    },
    dayOfMonthOrdinalParse: /\d{1,2}(ste|de)/,
    ordinal: function (number) {
      return number + (number === 1 || number === 8 || number >= 20 ? 'ste' : 'de');
    },
    week: {
      dow: 1,
      // Monday is the first day of the week.
      doy: 4 // The week that contains Jan 4th is the first week of the year.
    }
  });
  return nl;
});

/***/ }),
/* 198 */
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Dutch (Belgium) [nl-be]
//! author : Joris Rling : https://github.com/jorisroling
//! author : Jacob Middag : https://github.com/middagj

;
(function (global, factory) {
   true ? factory(__webpack_require__(105)) : 0;
})(this, function (moment) {
  'use strict';

  //! moment.js locale configuration
  var monthsShortWithDots = 'jan._feb._mrt._apr._mei_jun._jul._aug._sep._okt._nov._dec.'.split('_'),
    monthsShortWithoutDots = 'jan_feb_mrt_apr_mei_jun_jul_aug_sep_okt_nov_dec'.split('_'),
    monthsParse = [/^jan/i, /^feb/i, /^maart|mrt.?$/i, /^apr/i, /^mei$/i, /^jun[i.]?$/i, /^jul[i.]?$/i, /^aug/i, /^sep/i, /^okt/i, /^nov/i, /^dec/i],
    monthsRegex = /^(januari|februari|maart|april|mei|ju[nl]i|augustus|september|oktober|november|december|jan\.?|feb\.?|mrt\.?|apr\.?|ju[nl]\.?|aug\.?|sep\.?|okt\.?|nov\.?|dec\.?)/i;
  var nlBe = moment.defineLocale('nl-be', {
    months: 'januari_februari_maart_april_mei_juni_juli_augustus_september_oktober_november_december'.split('_'),
    monthsShort: function (m, format) {
      if (!m) {
        return monthsShortWithDots;
      } else if (/-MMM-/.test(format)) {
        return monthsShortWithoutDots[m.month()];
      } else {
        return monthsShortWithDots[m.month()];
      }
    },
    monthsRegex: monthsRegex,
    monthsShortRegex: monthsRegex,
    monthsStrictRegex: /^(januari|februari|maart|april|mei|ju[nl]i|augustus|september|oktober|november|december)/i,
    monthsShortStrictRegex: /^(jan\.?|feb\.?|mrt\.?|apr\.?|mei|ju[nl]\.?|aug\.?|sep\.?|okt\.?|nov\.?|dec\.?)/i,
    monthsParse: monthsParse,
    longMonthsParse: monthsParse,
    shortMonthsParse: monthsParse,
    weekdays: 'zondag_maandag_dinsdag_woensdag_donderdag_vrijdag_zaterdag'.split('_'),
    weekdaysShort: 'zo._ma._di._wo._do._vr._za.'.split('_'),
    weekdaysMin: 'zo_ma_di_wo_do_vr_za'.split('_'),
    weekdaysParseExact: true,
    longDateFormat: {
      LT: 'HH:mm',
      LTS: 'HH:mm:ss',
      L: 'DD/MM/YYYY',
      LL: 'D MMMM YYYY',
      LLL: 'D MMMM YYYY HH:mm',
      LLLL: 'dddd D MMMM YYYY HH:mm'
    },
    calendar: {
      sameDay: '[vandaag om] LT',
      nextDay: '[morgen om] LT',
      nextWeek: 'dddd [om] LT',
      lastDay: '[gisteren om] LT',
      lastWeek: '[afgelopen] dddd [om] LT',
      sameElse: 'L'
    },
    relativeTime: {
      future: 'over %s',
      past: '%s geleden',
      s: 'een paar seconden',
      ss: '%d seconden',
      m: 'n minuut',
      mm: '%d minuten',
      h: 'n uur',
      hh: '%d uur',
      d: 'n dag',
      dd: '%d dagen',
      M: 'n maand',
      MM: '%d maanden',
      y: 'n jaar',
      yy: '%d jaar'
    },
    dayOfMonthOrdinalParse: /\d{1,2}(ste|de)/,
    ordinal: function (number) {
      return number + (number === 1 || number === 8 || number >= 20 ? 'ste' : 'de');
    },
    week: {
      dow: 1,
      // Monday is the first day of the week.
      doy: 4 // The week that contains Jan 4th is the first week of the year.
    }
  });
  return nlBe;
});

/***/ }),
/* 199 */
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Nynorsk [nn]
//! authors : https://github.com/mechuwind
//!           Stephen Ramthun : https://github.com/stephenramthun

;
(function (global, factory) {
   true ? factory(__webpack_require__(105)) : 0;
})(this, function (moment) {
  'use strict';

  //! moment.js locale configuration
  var nn = moment.defineLocale('nn', {
    months: 'januar_februar_mars_april_mai_juni_juli_august_september_oktober_november_desember'.split('_'),
    monthsShort: 'jan._feb._mars_apr._mai_juni_juli_aug._sep._okt._nov._des.'.split('_'),
    monthsParseExact: true,
    weekdays: 'sundag_mndag_tysdag_onsdag_torsdag_fredag_laurdag'.split('_'),
    weekdaysShort: 'su._m._ty._on._to._fr._lau.'.split('_'),
    weekdaysMin: 'su_m_ty_on_to_fr_la'.split('_'),
    weekdaysParseExact: true,
    longDateFormat: {
      LT: 'HH:mm',
      LTS: 'HH:mm:ss',
      L: 'DD.MM.YYYY',
      LL: 'D. MMMM YYYY',
      LLL: 'D. MMMM YYYY [kl.] H:mm',
      LLLL: 'dddd D. MMMM YYYY [kl.] HH:mm'
    },
    calendar: {
      sameDay: '[I dag klokka] LT',
      nextDay: '[I morgon klokka] LT',
      nextWeek: 'dddd [klokka] LT',
      lastDay: '[I gr klokka] LT',
      lastWeek: '[Fregande] dddd [klokka] LT',
      sameElse: 'L'
    },
    relativeTime: {
      future: 'om %s',
      past: '%s sidan',
      s: 'nokre sekund',
      ss: '%d sekund',
      m: 'eit minutt',
      mm: '%d minutt',
      h: 'ein time',
      hh: '%d timar',
      d: 'ein dag',
      dd: '%d dagar',
      w: 'ei veke',
      ww: '%d veker',
      M: 'ein mnad',
      MM: '%d mnader',
      y: 'eit r',
      yy: '%d r'
    },
    dayOfMonthOrdinalParse: /\d{1,2}\./,
    ordinal: '%d.',
    week: {
      dow: 1,
      // Monday is the first day of the week.
      doy: 4 // The week that contains Jan 4th is the first week of the year.
    }
  });
  return nn;
});

/***/ }),
/* 200 */
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Occitan, lengadocian dialecte [oc-lnc]
//! author : Quentin PAGS : https://github.com/Quenty31

;
(function (global, factory) {
   true ? factory(__webpack_require__(105)) : 0;
})(this, function (moment) {
  'use strict';

  //! moment.js locale configuration
  var ocLnc = moment.defineLocale('oc-lnc', {
    months: {
      standalone: 'genir_febrir_mar_abril_mai_junh_julhet_agost_setembre_octbre_novembre_decembre'.split('_'),
      format: "de genir_de febrir_de mar_d'abril_de mai_de junh_de julhet_d'agost_de setembre_d'octbre_de novembre_de decembre".split('_'),
      isFormat: /D[oD]?(\s)+MMMM/
    },
    monthsShort: 'gen._febr._mar_abr._mai_junh_julh._ago._set._oct._nov._dec.'.split('_'),
    monthsParseExact: true,
    weekdays: 'dimenge_diluns_dimars_dimcres_dijus_divendres_dissabte'.split('_'),
    weekdaysShort: 'dg._dl._dm._dc._dj._dv._ds.'.split('_'),
    weekdaysMin: 'dg_dl_dm_dc_dj_dv_ds'.split('_'),
    weekdaysParseExact: true,
    longDateFormat: {
      LT: 'H:mm',
      LTS: 'H:mm:ss',
      L: 'DD/MM/YYYY',
      LL: 'D MMMM [de] YYYY',
      ll: 'D MMM YYYY',
      LLL: 'D MMMM [de] YYYY [a] H:mm',
      lll: 'D MMM YYYY, H:mm',
      LLLL: 'dddd D MMMM [de] YYYY [a] H:mm',
      llll: 'ddd D MMM YYYY, H:mm'
    },
    calendar: {
      sameDay: '[ui a] LT',
      nextDay: '[deman a] LT',
      nextWeek: 'dddd [a] LT',
      lastDay: '[ir a] LT',
      lastWeek: 'dddd [passat a] LT',
      sameElse: 'L'
    },
    relativeTime: {
      future: "d'aqu %s",
      past: 'fa %s',
      s: 'unas segondas',
      ss: '%d segondas',
      m: 'una minuta',
      mm: '%d minutas',
      h: 'una ora',
      hh: '%d oras',
      d: 'un jorn',
      dd: '%d jorns',
      M: 'un mes',
      MM: '%d meses',
      y: 'un an',
      yy: '%d ans'
    },
    dayOfMonthOrdinalParse: /\d{1,2}(r|n|t||a)/,
    ordinal: function (number, period) {
      var output = number === 1 ? 'r' : number === 2 ? 'n' : number === 3 ? 'r' : number === 4 ? 't' : '';
      if (period === 'w' || period === 'W') {
        output = 'a';
      }
      return number + output;
    },
    week: {
      dow: 1,
      // Monday is the first day of the week.
      doy: 4
    }
  });
  return ocLnc;
});

/***/ }),
/* 201 */
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Punjabi (India) [pa-in]
//! author : Harpreet Singh : https://github.com/harpreetkhalsagtbit

;
(function (global, factory) {
   true ? factory(__webpack_require__(105)) : 0;
})(this, function (moment) {
  'use strict';

  //! moment.js locale configuration
  var symbolMap = {
      1: '',
      2: '',
      3: '',
      4: '',
      5: '',
      6: '',
      7: '',
      8: '',
      9: '',
      0: ''
    },
    numberMap = {
      '': '1',
      '': '2',
      '': '3',
      '': '4',
      '': '5',
      '': '6',
      '': '7',
      '': '8',
      '': '9',
      '': '0'
    };
  var paIn = moment.defineLocale('pa-in', {
    // There are months name as per Nanakshahi Calendar but they are not used as rigidly in modern Punjabi.
    months: '___________'.split('_'),
    monthsShort: '___________'.split('_'),
    weekdays: '______'.split('_'),
    weekdaysShort: '______'.split('_'),
    weekdaysMin: '______'.split('_'),
    longDateFormat: {
      LT: 'A h:mm ',
      LTS: 'A h:mm:ss ',
      L: 'DD/MM/YYYY',
      LL: 'D MMMM YYYY',
      LLL: 'D MMMM YYYY, A h:mm ',
      LLLL: 'dddd, D MMMM YYYY, A h:mm '
    },
    calendar: {
      sameDay: '[] LT',
      nextDay: '[] LT',
      nextWeek: '[] dddd, LT',
      lastDay: '[] LT',
      lastWeek: '[] dddd, LT',
      sameElse: 'L'
    },
    relativeTime: {
      future: '%s ',
      past: '%s ',
      s: ' ',
      ss: '%d ',
      m: ' ',
      mm: '%d ',
      h: ' ',
      hh: '%d ',
      d: ' ',
      dd: '%d ',
      M: ' ',
      MM: '%d ',
      y: ' ',
      yy: '%d '
    },
    preparse: function (string) {
      return string.replace(/[]/g, function (match) {
        return numberMap[match];
      });
    },
    postformat: function (string) {
      return string.replace(/\d/g, function (match) {
        return symbolMap[match];
      });
    },
    // Punjabi notation for meridiems are quite fuzzy in practice. While there exists
    // a rigid notion of a 'Pahar' it is not used as rigidly in modern Punjabi.
    meridiemParse: /|||/,
    meridiemHour: function (hour, meridiem) {
      if (hour === 12) {
        hour = 0;
      }
      if (meridiem === '') {
        return hour < 4 ? hour : hour + 12;
      } else if (meridiem === '') {
        return hour;
      } else if (meridiem === '') {
        return hour >= 10 ? hour : hour + 12;
      } else if (meridiem === '') {
        return hour + 12;
      }
    },
    meridiem: function (hour, minute, isLower) {
      if (hour < 4) {
        return '';
      } else if (hour < 10) {
        return '';
      } else if (hour < 17) {
        return '';
      } else if (hour < 20) {
        return '';
      } else {
        return '';
      }
    },
    week: {
      dow: 0,
      // Sunday is the first day of the week.
      doy: 6 // The week that contains Jan 6th is the first week of the year.
    }
  });
  return paIn;
});

/***/ }),
/* 202 */
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Polish [pl]
//! author : Rafal Hirsz : https://github.com/evoL

;
(function (global, factory) {
   true ? factory(__webpack_require__(105)) : 0;
})(this, function (moment) {
  'use strict';

  //! moment.js locale configuration
  var monthsNominative = 'stycze_luty_marzec_kwiecie_maj_czerwiec_lipiec_sierpie_wrzesie_padziernik_listopad_grudzie'.split('_'),
    monthsSubjective = 'stycznia_lutego_marca_kwietnia_maja_czerwca_lipca_sierpnia_wrzenia_padziernika_listopada_grudnia'.split('_'),
    monthsParse = [/^sty/i, /^lut/i, /^mar/i, /^kwi/i, /^maj/i, /^cze/i, /^lip/i, /^sie/i, /^wrz/i, /^pa/i, /^lis/i, /^gru/i];
  function plural(n) {
    return n % 10 < 5 && n % 10 > 1 && ~~(n / 10) % 10 !== 1;
  }
  function translate(number, withoutSuffix, key) {
    var result = number + ' ';
    switch (key) {
      case 'ss':
        return result + (plural(number) ? 'sekundy' : 'sekund');
      case 'm':
        return withoutSuffix ? 'minuta' : 'minut';
      case 'mm':
        return result + (plural(number) ? 'minuty' : 'minut');
      case 'h':
        return withoutSuffix ? 'godzina' : 'godzin';
      case 'hh':
        return result + (plural(number) ? 'godziny' : 'godzin');
      case 'ww':
        return result + (plural(number) ? 'tygodnie' : 'tygodni');
      case 'MM':
        return result + (plural(number) ? 'miesice' : 'miesicy');
      case 'yy':
        return result + (plural(number) ? 'lata' : 'lat');
    }
  }
  var pl = moment.defineLocale('pl', {
    months: function (momentToFormat, format) {
      if (!momentToFormat) {
        return monthsNominative;
      } else if (/D MMMM/.test(format)) {
        return monthsSubjective[momentToFormat.month()];
      } else {
        return monthsNominative[momentToFormat.month()];
      }
    },
    monthsShort: 'sty_lut_mar_kwi_maj_cze_lip_sie_wrz_pa_lis_gru'.split('_'),
    monthsParse: monthsParse,
    longMonthsParse: monthsParse,
    shortMonthsParse: monthsParse,
    weekdays: 'niedziela_poniedziaek_wtorek_roda_czwartek_pitek_sobota'.split('_'),
    weekdaysShort: 'ndz_pon_wt_r_czw_pt_sob'.split('_'),
    weekdaysMin: 'Nd_Pn_Wt_r_Cz_Pt_So'.split('_'),
    longDateFormat: {
      LT: 'HH:mm',
      LTS: 'HH:mm:ss',
      L: 'DD.MM.YYYY',
      LL: 'D MMMM YYYY',
      LLL: 'D MMMM YYYY HH:mm',
      LLLL: 'dddd, D MMMM YYYY HH:mm'
    },
    calendar: {
      sameDay: '[Dzi o] LT',
      nextDay: '[Jutro o] LT',
      nextWeek: function () {
        switch (this.day()) {
          case 0:
            return '[W niedziel o] LT';
          case 2:
            return '[We wtorek o] LT';
          case 3:
            return '[W rod o] LT';
          case 6:
            return '[W sobot o] LT';
          default:
            return '[W] dddd [o] LT';
        }
      },
      lastDay: '[Wczoraj o] LT',
      lastWeek: function () {
        switch (this.day()) {
          case 0:
            return '[W zesz niedziel o] LT';
          case 3:
            return '[W zesz rod o] LT';
          case 6:
            return '[W zesz sobot o] LT';
          default:
            return '[W zeszy] dddd [o] LT';
        }
      },
      sameElse: 'L'
    },
    relativeTime: {
      future: 'za %s',
      past: '%s temu',
      s: 'kilka sekund',
      ss: translate,
      m: translate,
      mm: translate,
      h: translate,
      hh: translate,
      d: '1 dzie',
      dd: '%d dni',
      w: 'tydzie',
      ww: translate,
      M: 'miesic',
      MM: translate,
      y: 'rok',
      yy: translate
    },
    dayOfMonthOrdinalParse: /\d{1,2}\./,
    ordinal: '%d.',
    week: {
      dow: 1,
      // Monday is the first day of the week.
      doy: 4 // The week that contains Jan 4th is the first week of the year.
    }
  });
  return pl;
});

/***/ }),
/* 203 */
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Portuguese [pt]
//! author : Jefferson : https://github.com/jalex79

;
(function (global, factory) {
   true ? factory(__webpack_require__(105)) : 0;
})(this, function (moment) {
  'use strict';

  //! moment.js locale configuration
  var pt = moment.defineLocale('pt', {
    months: 'janeiro_fevereiro_maro_abril_maio_junho_julho_agosto_setembro_outubro_novembro_dezembro'.split('_'),
    monthsShort: 'jan_fev_mar_abr_mai_jun_jul_ago_set_out_nov_dez'.split('_'),
    weekdays: 'Domingo_Segunda-feira_Tera-feira_Quarta-feira_Quinta-feira_Sexta-feira_Sbado'.split('_'),
    weekdaysShort: 'Dom_Seg_Ter_Qua_Qui_Sex_Sb'.split('_'),
    weekdaysMin: 'Do_2_3_4_5_6_S'.split('_'),
    weekdaysParseExact: true,
    longDateFormat: {
      LT: 'HH:mm',
      LTS: 'HH:mm:ss',
      L: 'DD/MM/YYYY',
      LL: 'D [de] MMMM [de] YYYY',
      LLL: 'D [de] MMMM [de] YYYY HH:mm',
      LLLL: 'dddd, D [de] MMMM [de] YYYY HH:mm'
    },
    calendar: {
      sameDay: '[Hoje s] LT',
      nextDay: '[Amanh s] LT',
      nextWeek: 'dddd [s] LT',
      lastDay: '[Ontem s] LT',
      lastWeek: function () {
        return this.day() === 0 || this.day() === 6 ? '[ltimo] dddd [s] LT' // Saturday + Sunday
        : '[ltima] dddd [s] LT'; // Monday - Friday
      },
      sameElse: 'L'
    },
    relativeTime: {
      future: 'em %s',
      past: 'h %s',
      s: 'segundos',
      ss: '%d segundos',
      m: 'um minuto',
      mm: '%d minutos',
      h: 'uma hora',
      hh: '%d horas',
      d: 'um dia',
      dd: '%d dias',
      w: 'uma semana',
      ww: '%d semanas',
      M: 'um ms',
      MM: '%d meses',
      y: 'um ano',
      yy: '%d anos'
    },
    dayOfMonthOrdinalParse: /\d{1,2}/,
    ordinal: '%d',
    week: {
      dow: 1,
      // Monday is the first day of the week.
      doy: 4 // The week that contains Jan 4th is the first week of the year.
    }
  });
  return pt;
});

/***/ }),
/* 204 */
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Portuguese (Brazil) [pt-br]
//! author : Caio Ribeiro Pereira : https://github.com/caio-ribeiro-pereira

;
(function (global, factory) {
   true ? factory(__webpack_require__(105)) : 0;
})(this, function (moment) {
  'use strict';

  //! moment.js locale configuration
  var ptBr = moment.defineLocale('pt-br', {
    months: 'janeiro_fevereiro_maro_abril_maio_junho_julho_agosto_setembro_outubro_novembro_dezembro'.split('_'),
    monthsShort: 'jan_fev_mar_abr_mai_jun_jul_ago_set_out_nov_dez'.split('_'),
    weekdays: 'domingo_segunda-feira_tera-feira_quarta-feira_quinta-feira_sexta-feira_sbado'.split('_'),
    weekdaysShort: 'dom_seg_ter_qua_qui_sex_sb'.split('_'),
    weekdaysMin: 'do_2_3_4_5_6_s'.split('_'),
    weekdaysParseExact: true,
    longDateFormat: {
      LT: 'HH:mm',
      LTS: 'HH:mm:ss',
      L: 'DD/MM/YYYY',
      LL: 'D [de] MMMM [de] YYYY',
      LLL: 'D [de] MMMM [de] YYYY [s] HH:mm',
      LLLL: 'dddd, D [de] MMMM [de] YYYY [s] HH:mm'
    },
    calendar: {
      sameDay: '[Hoje s] LT',
      nextDay: '[Amanh s] LT',
      nextWeek: 'dddd [s] LT',
      lastDay: '[Ontem s] LT',
      lastWeek: function () {
        return this.day() === 0 || this.day() === 6 ? '[ltimo] dddd [s] LT' // Saturday + Sunday
        : '[ltima] dddd [s] LT'; // Monday - Friday
      },
      sameElse: 'L'
    },
    relativeTime: {
      future: 'em %s',
      past: 'h %s',
      s: 'poucos segundos',
      ss: '%d segundos',
      m: 'um minuto',
      mm: '%d minutos',
      h: 'uma hora',
      hh: '%d horas',
      d: 'um dia',
      dd: '%d dias',
      M: 'um ms',
      MM: '%d meses',
      y: 'um ano',
      yy: '%d anos'
    },
    dayOfMonthOrdinalParse: /\d{1,2}/,
    ordinal: '%d',
    invalidDate: 'Data invlida'
  });
  return ptBr;
});

/***/ }),
/* 205 */
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Romanian [ro]
//! author : Vlad Gurdiga : https://github.com/gurdiga
//! author : Valentin Agachi : https://github.com/avaly
//! author : Emanuel Cepoi : https://github.com/cepem

;
(function (global, factory) {
   true ? factory(__webpack_require__(105)) : 0;
})(this, function (moment) {
  'use strict';

  //! moment.js locale configuration
  function relativeTimeWithPlural(number, withoutSuffix, key) {
    var format = {
        ss: 'secunde',
        mm: 'minute',
        hh: 'ore',
        dd: 'zile',
        ww: 'sptmni',
        MM: 'luni',
        yy: 'ani'
      },
      separator = ' ';
    if (number % 100 >= 20 || number >= 100 && number % 100 === 0) {
      separator = ' de ';
    }
    return number + separator + format[key];
  }
  var ro = moment.defineLocale('ro', {
    months: 'ianuarie_februarie_martie_aprilie_mai_iunie_iulie_august_septembrie_octombrie_noiembrie_decembrie'.split('_'),
    monthsShort: 'ian._feb._mart._apr._mai_iun._iul._aug._sept._oct._nov._dec.'.split('_'),
    monthsParseExact: true,
    weekdays: 'duminic_luni_mari_miercuri_joi_vineri_smbt'.split('_'),
    weekdaysShort: 'Dum_Lun_Mar_Mie_Joi_Vin_Sm'.split('_'),
    weekdaysMin: 'Du_Lu_Ma_Mi_Jo_Vi_S'.split('_'),
    longDateFormat: {
      LT: 'H:mm',
      LTS: 'H:mm:ss',
      L: 'DD.MM.YYYY',
      LL: 'D MMMM YYYY',
      LLL: 'D MMMM YYYY H:mm',
      LLLL: 'dddd, D MMMM YYYY H:mm'
    },
    calendar: {
      sameDay: '[azi la] LT',
      nextDay: '[mine la] LT',
      nextWeek: 'dddd [la] LT',
      lastDay: '[ieri la] LT',
      lastWeek: '[fosta] dddd [la] LT',
      sameElse: 'L'
    },
    relativeTime: {
      future: 'peste %s',
      past: '%s n urm',
      s: 'cteva secunde',
      ss: relativeTimeWithPlural,
      m: 'un minut',
      mm: relativeTimeWithPlural,
      h: 'o or',
      hh: relativeTimeWithPlural,
      d: 'o zi',
      dd: relativeTimeWithPlural,
      w: 'o sptmn',
      ww: relativeTimeWithPlural,
      M: 'o lun',
      MM: relativeTimeWithPlural,
      y: 'un an',
      yy: relativeTimeWithPlural
    },
    week: {
      dow: 1,
      // Monday is the first day of the week.
      doy: 7 // The week that contains Jan 7th is the first week of the year.
    }
  });
  return ro;
});

/***/ }),
/* 206 */
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Russian [ru]
//! author : Viktorminator : https://github.com/Viktorminator
//! author : Menelion Elensle : https://github.com/Oire
//! author :   : https://github.com/socketpair

;
(function (global, factory) {
   true ? factory(__webpack_require__(105)) : 0;
})(this, function (moment) {
  'use strict';

  //! moment.js locale configuration
  function plural(word, num) {
    var forms = word.split('_');
    return num % 10 === 1 && num % 100 !== 11 ? forms[0] : num % 10 >= 2 && num % 10 <= 4 && (num % 100 < 10 || num % 100 >= 20) ? forms[1] : forms[2];
  }
  function relativeTimeWithPlural(number, withoutSuffix, key) {
    var format = {
      ss: withoutSuffix ? '__' : '__',
      mm: withoutSuffix ? '__' : '__',
      hh: '__',
      dd: '__',
      ww: '__',
      MM: '__',
      yy: '__'
    };
    if (key === 'm') {
      return withoutSuffix ? '' : '';
    } else {
      return number + ' ' + plural(format[key], +number);
    }
  }
  var monthsParse = [/^/i, /^/i, /^/i, /^/i, /^[]/i, /^/i, /^/i, /^/i, /^/i, /^/i, /^/i, /^/i];

  // http://new.gramota.ru/spravka/rules/139-prop :  103
  //  : http://new.gramota.ru/spravka/buro/search-answer?s=242637
  // CLDR data:          http://www.unicode.org/cldr/charts/28/summary/ru.html#1753
  var ru = moment.defineLocale('ru', {
    months: {
      format: '___________'.split('_'),
      standalone: '___________'.split('_')
    },
    monthsShort: {
      //  CLDR  "."  ".",       ?
      format: '._._._.____._._._._.'.split('_'),
      standalone: '._.__.____._._._._.'.split('_')
    },
    weekdays: {
      standalone: '______'.split('_'),
      format: '______'.split('_'),
      isFormat: /\[ ?[] ?(?:||)? ?] ?dddd/
    },
    weekdaysShort: '______'.split('_'),
    weekdaysMin: '______'.split('_'),
    monthsParse: monthsParse,
    longMonthsParse: monthsParse,
    shortMonthsParse: monthsParse,
    //    ,   ,  ,  4 ,      
    monthsRegex: /^([]|\.?|[]|?\.?|?|\.?|[]|\.?|[]|[]|\.?|[]|\.?|?|\.?|[]|?\.?|[]|\.?|[]|?\.?|[]|\.?)/i,
    //  
    monthsShortRegex: /^([]|\.?|[]|?\.?|?|\.?|[]|\.?|[]|[]|\.?|[]|\.?|?|\.?|[]|?\.?|[]|\.?|[]|?\.?|[]|\.?)/i,
    //    
    monthsStrictRegex: /^([]|[]|?|[]|[]|[]|[]|?|[]|[]|[]|[])/i,
    // ,     
    monthsShortStrictRegex: /^(\.|?\.|[.]|\.|[]|[.]|[.]|\.|?\.|\.|?\.|\.)/i,
    longDateFormat: {
      LT: 'H:mm',
      LTS: 'H:mm:ss',
      L: 'DD.MM.YYYY',
      LL: 'D MMMM YYYY .',
      LLL: 'D MMMM YYYY ., H:mm',
      LLLL: 'dddd, D MMMM YYYY ., H:mm'
    },
    calendar: {
      sameDay: '[, ] LT',
      nextDay: '[, ] LT',
      lastDay: '[, ] LT',
      nextWeek: function (now) {
        if (now.week() !== this.week()) {
          switch (this.day()) {
            case 0:
              return '[ ] dddd, [] LT';
            case 1:
            case 2:
            case 4:
              return '[ ] dddd, [] LT';
            case 3:
            case 5:
            case 6:
              return '[ ] dddd, [] LT';
          }
        } else {
          if (this.day() === 2) {
            return '[] dddd, [] LT';
          } else {
            return '[] dddd, [] LT';
          }
        }
      },
      lastWeek: function (now) {
        if (now.week() !== this.week()) {
          switch (this.day()) {
            case 0:
              return '[ ] dddd, [] LT';
            case 1:
            case 2:
            case 4:
              return '[ ] dddd, [] LT';
            case 3:
            case 5:
            case 6:
              return '[ ] dddd, [] LT';
          }
        } else {
          if (this.day() === 2) {
            return '[] dddd, [] LT';
          } else {
            return '[] dddd, [] LT';
          }
        }
      },
      sameElse: 'L'
    },
    relativeTime: {
      future: ' %s',
      past: '%s ',
      s: ' ',
      ss: relativeTimeWithPlural,
      m: relativeTimeWithPlural,
      mm: relativeTimeWithPlural,
      h: '',
      hh: relativeTimeWithPlural,
      d: '',
      dd: relativeTimeWithPlural,
      w: '',
      ww: relativeTimeWithPlural,
      M: '',
      MM: relativeTimeWithPlural,
      y: '',
      yy: relativeTimeWithPlural
    },
    meridiemParse: /|||/i,
    isPM: function (input) {
      return /^(|)$/.test(input);
    },
    meridiem: function (hour, minute, isLower) {
      if (hour < 4) {
        return '';
      } else if (hour < 12) {
        return '';
      } else if (hour < 17) {
        return '';
      } else {
        return '';
      }
    },
    dayOfMonthOrdinalParse: /\d{1,2}-(||)/,
    ordinal: function (number, period) {
      switch (period) {
        case 'M':
        case 'd':
        case 'DDD':
          return number + '-';
        case 'D':
          return number + '-';
        case 'w':
        case 'W':
          return number + '-';
        default:
          return number;
      }
    },
    week: {
      dow: 1,
      // Monday is the first day of the week.
      doy: 4 // The week that contains Jan 4th is the first week of the year.
    }
  });
  return ru;
});

/***/ }),
/* 207 */
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Sindhi [sd]
//! author : Narain Sagar : https://github.com/narainsagar

;
(function (global, factory) {
   true ? factory(__webpack_require__(105)) : 0;
})(this, function (moment) {
  'use strict';

  //! moment.js locale configuration
  var months = ['', '', '', '', '', '', '', '', '', '', '', ''],
    days = ['', '', '', '', '', '', ''];
  var sd = moment.defineLocale('sd', {
    months: months,
    monthsShort: months,
    weekdays: days,
    weekdaysShort: days,
    weekdaysMin: days,
    longDateFormat: {
      LT: 'HH:mm',
      LTS: 'HH:mm:ss',
      L: 'DD/MM/YYYY',
      LL: 'D MMMM YYYY',
      LLL: 'D MMMM YYYY HH:mm',
      LLLL: 'dddd D MMMM YYYY HH:mm'
    },
    meridiemParse: /|/,
    isPM: function (input) {
      return '' === input;
    },
    meridiem: function (hour, minute, isLower) {
      if (hour < 12) {
        return '';
      }
      return '';
    },
    calendar: {
      sameDay: '[] LT',
      nextDay: '[] LT',
      nextWeek: 'dddd [  ] LT',
      lastDay: '[] LT',
      lastWeek: '[ ] dddd [] LT',
      sameElse: 'L'
    },
    relativeTime: {
      future: '%s ',
      past: '%s ',
      s: ' ',
      ss: '%d ',
      m: ' ',
      mm: '%d ',
      h: ' ',
      hh: '%d ',
      d: ' ',
      dd: '%d ',
      M: ' ',
      MM: '%d ',
      y: ' ',
      yy: '%d '
    },
    preparse: function (string) {
      return string.replace(//g, ',');
    },
    postformat: function (string) {
      return string.replace(/,/g, '');
    },
    week: {
      dow: 1,
      // Monday is the first day of the week.
      doy: 4 // The week that contains Jan 4th is the first week of the year.
    }
  });
  return sd;
});

/***/ }),
/* 208 */
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Northern Sami [se]
//! authors : Brd Rolstad Henriksen : https://github.com/karamell

;
(function (global, factory) {
   true ? factory(__webpack_require__(105)) : 0;
})(this, function (moment) {
  'use strict';

  //! moment.js locale configuration
  var se = moment.defineLocale('se', {
    months: 'oajagemnnu_guovvamnnu_njukamnnu_cuoomnnu_miessemnnu_geassemnnu_suoidnemnnu_borgemnnu_akamnnu_golggotmnnu_skbmamnnu_juovlamnnu'.split('_'),
    monthsShort: 'oj_guov_njuk_cuo_mies_geas_suoi_borg_ak_golg_skb_juov'.split('_'),
    weekdays: 'sotnabeaivi_vuossrga_maebrga_gaskavahkku_duorastat_bearjadat_lvvardat'.split('_'),
    weekdaysShort: 'sotn_vuos_ma_gask_duor_bear_lv'.split('_'),
    weekdaysMin: 's_v_m_g_d_b_L'.split('_'),
    longDateFormat: {
      LT: 'HH:mm',
      LTS: 'HH:mm:ss',
      L: 'DD.MM.YYYY',
      LL: 'MMMM D. [b.] YYYY',
      LLL: 'MMMM D. [b.] YYYY [ti.] HH:mm',
      LLLL: 'dddd, MMMM D. [b.] YYYY [ti.] HH:mm'
    },
    calendar: {
      sameDay: '[otne ti] LT',
      nextDay: '[ihttin ti] LT',
      nextWeek: 'dddd [ti] LT',
      lastDay: '[ikte ti] LT',
      lastWeek: '[ovddit] dddd [ti] LT',
      sameElse: 'L'
    },
    relativeTime: {
      future: '%s geaes',
      past: 'mait %s',
      s: 'moadde sekunddat',
      ss: '%d sekunddat',
      m: 'okta minuhta',
      mm: '%d minuhtat',
      h: 'okta diimmu',
      hh: '%d diimmut',
      d: 'okta beaivi',
      dd: '%d beaivvit',
      M: 'okta mnnu',
      MM: '%d mnut',
      y: 'okta jahki',
      yy: '%d jagit'
    },
    dayOfMonthOrdinalParse: /\d{1,2}\./,
    ordinal: '%d.',
    week: {
      dow: 1,
      // Monday is the first day of the week.
      doy: 4 // The week that contains Jan 4th is the first week of the year.
    }
  });
  return se;
});

/***/ }),
/* 209 */
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Sinhalese [si]
//! author : Sampath Sitinamaluwa : https://github.com/sampathsris

;
(function (global, factory) {
   true ? factory(__webpack_require__(105)) : 0;
})(this, function (moment) {
  'use strict';

  //! moment.js locale configuration

  /*jshint -W100*/
  var si = moment.defineLocale('si', {
    months: '___________'.split('_'),
    monthsShort: '___________'.split('_'),
    weekdays: '______'.split('_'),
    weekdaysShort: '______'.split('_'),
    weekdaysMin: '______'.split('_'),
    weekdaysParseExact: true,
    longDateFormat: {
      LT: 'a h:mm',
      LTS: 'a h:mm:ss',
      L: 'YYYY/MM/DD',
      LL: 'YYYY MMMM D',
      LLL: 'YYYY MMMM D, a h:mm',
      LLLL: 'YYYY MMMM D [] dddd, a h:mm:ss'
    },
    calendar: {
      sameDay: '[] LT[]',
      nextDay: '[] LT[]',
      nextWeek: 'dddd LT[]',
      lastDay: '[] LT[]',
      lastWeek: '[] dddd LT[]',
      sameElse: 'L'
    },
    relativeTime: {
      future: '%s',
      past: '%s ',
      s: ' ',
      ss: ' %d',
      m: '',
      mm: ' %d',
      h: '',
      hh: ' %d',
      d: '',
      dd: ' %d',
      M: '',
      MM: ' %d',
      y: '',
      yy: ' %d'
    },
    dayOfMonthOrdinalParse: /\d{1,2} /,
    ordinal: function (number) {
      return number + ' ';
    },
    meridiemParse: / | |.|../,
    isPM: function (input) {
      return input === '..' || input === ' ';
    },
    meridiem: function (hours, minutes, isLower) {
      if (hours > 11) {
        return isLower ? '..' : ' ';
      } else {
        return isLower ? '..' : ' ';
      }
    }
  });
  return si;
});

/***/ }),
/* 210 */
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Slovak [sk]
//! author : Martin Minka : https://github.com/k2s
//! based on work of petrbela : https://github.com/petrbela

;
(function (global, factory) {
   true ? factory(__webpack_require__(105)) : 0;
})(this, function (moment) {
  'use strict';

  //! moment.js locale configuration
  var months = 'janur_februr_marec_aprl_mj_jn_jl_august_september_oktber_november_december'.split('_'),
    monthsShort = 'jan_feb_mar_apr_mj_jn_jl_aug_sep_okt_nov_dec'.split('_');
  function plural(n) {
    return n > 1 && n < 5;
  }
  function translate(number, withoutSuffix, key, isFuture) {
    var result = number + ' ';
    switch (key) {
      case 's':
        // a few seconds / in a few seconds / a few seconds ago
        return withoutSuffix || isFuture ? 'pr seknd' : 'pr sekundami';
      case 'ss':
        // 9 seconds / in 9 seconds / 9 seconds ago
        if (withoutSuffix || isFuture) {
          return result + (plural(number) ? 'sekundy' : 'seknd');
        } else {
          return result + 'sekundami';
        }
      case 'm':
        // a minute / in a minute / a minute ago
        return withoutSuffix ? 'minta' : isFuture ? 'mintu' : 'mintou';
      case 'mm':
        // 9 minutes / in 9 minutes / 9 minutes ago
        if (withoutSuffix || isFuture) {
          return result + (plural(number) ? 'minty' : 'mint');
        } else {
          return result + 'mintami';
        }
      case 'h':
        // an hour / in an hour / an hour ago
        return withoutSuffix ? 'hodina' : isFuture ? 'hodinu' : 'hodinou';
      case 'hh':
        // 9 hours / in 9 hours / 9 hours ago
        if (withoutSuffix || isFuture) {
          return result + (plural(number) ? 'hodiny' : 'hodn');
        } else {
          return result + 'hodinami';
        }
      case 'd':
        // a day / in a day / a day ago
        return withoutSuffix || isFuture ? 'de' : 'dom';
      case 'dd':
        // 9 days / in 9 days / 9 days ago
        if (withoutSuffix || isFuture) {
          return result + (plural(number) ? 'dni' : 'dn');
        } else {
          return result + 'dami';
        }
      case 'M':
        // a month / in a month / a month ago
        return withoutSuffix || isFuture ? 'mesiac' : 'mesiacom';
      case 'MM':
        // 9 months / in 9 months / 9 months ago
        if (withoutSuffix || isFuture) {
          return result + (plural(number) ? 'mesiace' : 'mesiacov');
        } else {
          return result + 'mesiacmi';
        }
      case 'y':
        // a year / in a year / a year ago
        return withoutSuffix || isFuture ? 'rok' : 'rokom';
      case 'yy':
        // 9 years / in 9 years / 9 years ago
        if (withoutSuffix || isFuture) {
          return result + (plural(number) ? 'roky' : 'rokov');
        } else {
          return result + 'rokmi';
        }
    }
  }
  var sk = moment.defineLocale('sk', {
    months: months,
    monthsShort: monthsShort,
    weekdays: 'nedea_pondelok_utorok_streda_tvrtok_piatok_sobota'.split('_'),
    weekdaysShort: 'ne_po_ut_st_t_pi_so'.split('_'),
    weekdaysMin: 'ne_po_ut_st_t_pi_so'.split('_'),
    longDateFormat: {
      LT: 'H:mm',
      LTS: 'H:mm:ss',
      L: 'DD.MM.YYYY',
      LL: 'D. MMMM YYYY',
      LLL: 'D. MMMM YYYY H:mm',
      LLLL: 'dddd D. MMMM YYYY H:mm'
    },
    calendar: {
      sameDay: '[dnes o] LT',
      nextDay: '[zajtra o] LT',
      nextWeek: function () {
        switch (this.day()) {
          case 0:
            return '[v nedeu o] LT';
          case 1:
          case 2:
            return '[v] dddd [o] LT';
          case 3:
            return '[v stredu o] LT';
          case 4:
            return '[vo tvrtok o] LT';
          case 5:
            return '[v piatok o] LT';
          case 6:
            return '[v sobotu o] LT';
        }
      },
      lastDay: '[vera o] LT',
      lastWeek: function () {
        switch (this.day()) {
          case 0:
            return '[minul nedeu o] LT';
          case 1:
          case 2:
            return '[minul] dddd [o] LT';
          case 3:
            return '[minul stredu o] LT';
          case 4:
          case 5:
            return '[minul] dddd [o] LT';
          case 6:
            return '[minul sobotu o] LT';
        }
      },
      sameElse: 'L'
    },
    relativeTime: {
      future: 'za %s',
      past: 'pred %s',
      s: translate,
      ss: translate,
      m: translate,
      mm: translate,
      h: translate,
      hh: translate,
      d: translate,
      dd: translate,
      M: translate,
      MM: translate,
      y: translate,
      yy: translate
    },
    dayOfMonthOrdinalParse: /\d{1,2}\./,
    ordinal: '%d.',
    week: {
      dow: 1,
      // Monday is the first day of the week.
      doy: 4 // The week that contains Jan 4th is the first week of the year.
    }
  });
  return sk;
});

/***/ }),
/* 211 */
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Slovenian [sl]
//! author : Robert Sedovek : https://github.com/sedovsek

;
(function (global, factory) {
   true ? factory(__webpack_require__(105)) : 0;
})(this, function (moment) {
  'use strict';

  //! moment.js locale configuration
  function processRelativeTime(number, withoutSuffix, key, isFuture) {
    var result = number + ' ';
    switch (key) {
      case 's':
        return withoutSuffix || isFuture ? 'nekaj sekund' : 'nekaj sekundami';
      case 'ss':
        if (number === 1) {
          result += withoutSuffix ? 'sekundo' : 'sekundi';
        } else if (number === 2) {
          result += withoutSuffix || isFuture ? 'sekundi' : 'sekundah';
        } else if (number < 5) {
          result += withoutSuffix || isFuture ? 'sekunde' : 'sekundah';
        } else {
          result += 'sekund';
        }
        return result;
      case 'm':
        return withoutSuffix ? 'ena minuta' : 'eno minuto';
      case 'mm':
        if (number === 1) {
          result += withoutSuffix ? 'minuta' : 'minuto';
        } else if (number === 2) {
          result += withoutSuffix || isFuture ? 'minuti' : 'minutama';
        } else if (number < 5) {
          result += withoutSuffix || isFuture ? 'minute' : 'minutami';
        } else {
          result += withoutSuffix || isFuture ? 'minut' : 'minutami';
        }
        return result;
      case 'h':
        return withoutSuffix ? 'ena ura' : 'eno uro';
      case 'hh':
        if (number === 1) {
          result += withoutSuffix ? 'ura' : 'uro';
        } else if (number === 2) {
          result += withoutSuffix || isFuture ? 'uri' : 'urama';
        } else if (number < 5) {
          result += withoutSuffix || isFuture ? 'ure' : 'urami';
        } else {
          result += withoutSuffix || isFuture ? 'ur' : 'urami';
        }
        return result;
      case 'd':
        return withoutSuffix || isFuture ? 'en dan' : 'enim dnem';
      case 'dd':
        if (number === 1) {
          result += withoutSuffix || isFuture ? 'dan' : 'dnem';
        } else if (number === 2) {
          result += withoutSuffix || isFuture ? 'dni' : 'dnevoma';
        } else {
          result += withoutSuffix || isFuture ? 'dni' : 'dnevi';
        }
        return result;
      case 'M':
        return withoutSuffix || isFuture ? 'en mesec' : 'enim mesecem';
      case 'MM':
        if (number === 1) {
          result += withoutSuffix || isFuture ? 'mesec' : 'mesecem';
        } else if (number === 2) {
          result += withoutSuffix || isFuture ? 'meseca' : 'mesecema';
        } else if (number < 5) {
          result += withoutSuffix || isFuture ? 'mesece' : 'meseci';
        } else {
          result += withoutSuffix || isFuture ? 'mesecev' : 'meseci';
        }
        return result;
      case 'y':
        return withoutSuffix || isFuture ? 'eno leto' : 'enim letom';
      case 'yy':
        if (number === 1) {
          result += withoutSuffix || isFuture ? 'leto' : 'letom';
        } else if (number === 2) {
          result += withoutSuffix || isFuture ? 'leti' : 'letoma';
        } else if (number < 5) {
          result += withoutSuffix || isFuture ? 'leta' : 'leti';
        } else {
          result += withoutSuffix || isFuture ? 'let' : 'leti';
        }
        return result;
    }
  }
  var sl = moment.defineLocale('sl', {
    months: 'januar_februar_marec_april_maj_junij_julij_avgust_september_oktober_november_december'.split('_'),
    monthsShort: 'jan._feb._mar._apr._maj._jun._jul._avg._sep._okt._nov._dec.'.split('_'),
    monthsParseExact: true,
    weekdays: 'nedelja_ponedeljek_torek_sreda_etrtek_petek_sobota'.split('_'),
    weekdaysShort: 'ned._pon._tor._sre._et._pet._sob.'.split('_'),
    weekdaysMin: 'ne_po_to_sr_e_pe_so'.split('_'),
    weekdaysParseExact: true,
    longDateFormat: {
      LT: 'H:mm',
      LTS: 'H:mm:ss',
      L: 'DD. MM. YYYY',
      LL: 'D. MMMM YYYY',
      LLL: 'D. MMMM YYYY H:mm',
      LLLL: 'dddd, D. MMMM YYYY H:mm'
    },
    calendar: {
      sameDay: '[danes ob] LT',
      nextDay: '[jutri ob] LT',
      nextWeek: function () {
        switch (this.day()) {
          case 0:
            return '[v] [nedeljo] [ob] LT';
          case 3:
            return '[v] [sredo] [ob] LT';
          case 6:
            return '[v] [soboto] [ob] LT';
          case 1:
          case 2:
          case 4:
          case 5:
            return '[v] dddd [ob] LT';
        }
      },
      lastDay: '[veraj ob] LT',
      lastWeek: function () {
        switch (this.day()) {
          case 0:
            return '[prejnjo] [nedeljo] [ob] LT';
          case 3:
            return '[prejnjo] [sredo] [ob] LT';
          case 6:
            return '[prejnjo] [soboto] [ob] LT';
          case 1:
          case 2:
          case 4:
          case 5:
            return '[prejnji] dddd [ob] LT';
        }
      },
      sameElse: 'L'
    },
    relativeTime: {
      future: 'ez %s',
      past: 'pred %s',
      s: processRelativeTime,
      ss: processRelativeTime,
      m: processRelativeTime,
      mm: processRelativeTime,
      h: processRelativeTime,
      hh: processRelativeTime,
      d: processRelativeTime,
      dd: processRelativeTime,
      M: processRelativeTime,
      MM: processRelativeTime,
      y: processRelativeTime,
      yy: processRelativeTime
    },
    dayOfMonthOrdinalParse: /\d{1,2}\./,
    ordinal: '%d.',
    week: {
      dow: 1,
      // Monday is the first day of the week.
      doy: 7 // The week that contains Jan 7th is the first week of the year.
    }
  });
  return sl;
});

/***/ }),
/* 212 */
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Albanian [sq]
//! author : Flakrim Ismani : https://github.com/flakerimi
//! author : Menelion Elensle : https://github.com/Oire
//! author : Oerd Cukalla : https://github.com/oerd

;
(function (global, factory) {
   true ? factory(__webpack_require__(105)) : 0;
})(this, function (moment) {
  'use strict';

  //! moment.js locale configuration
  var sq = moment.defineLocale('sq', {
    months: 'Janar_Shkurt_Mars_Prill_Maj_Qershor_Korrik_Gusht_Shtator_Tetor_Nntor_Dhjetor'.split('_'),
    monthsShort: 'Jan_Shk_Mar_Pri_Maj_Qer_Kor_Gus_Sht_Tet_Nn_Dhj'.split('_'),
    weekdays: 'E Diel_E Hn_E Mart_E Mrkur_E Enjte_E Premte_E Shtun'.split('_'),
    weekdaysShort: 'Die_Hn_Mar_Mr_Enj_Pre_Sht'.split('_'),
    weekdaysMin: 'D_H_Ma_M_E_P_Sh'.split('_'),
    weekdaysParseExact: true,
    meridiemParse: /PD|MD/,
    isPM: function (input) {
      return input.charAt(0) === 'M';
    },
    meridiem: function (hours, minutes, isLower) {
      return hours < 12 ? 'PD' : 'MD';
    },
    longDateFormat: {
      LT: 'HH:mm',
      LTS: 'HH:mm:ss',
      L: 'DD/MM/YYYY',
      LL: 'D MMMM YYYY',
      LLL: 'D MMMM YYYY HH:mm',
      LLLL: 'dddd, D MMMM YYYY HH:mm'
    },
    calendar: {
      sameDay: '[Sot n] LT',
      nextDay: '[Nesr n] LT',
      nextWeek: 'dddd [n] LT',
      lastDay: '[Dje n] LT',
      lastWeek: 'dddd [e kaluar n] LT',
      sameElse: 'L'
    },
    relativeTime: {
      future: 'n %s',
      past: '%s m par',
      s: 'disa sekonda',
      ss: '%d sekonda',
      m: 'nj minut',
      mm: '%d minuta',
      h: 'nj or',
      hh: '%d or',
      d: 'nj dit',
      dd: '%d dit',
      M: 'nj muaj',
      MM: '%d muaj',
      y: 'nj vit',
      yy: '%d vite'
    },
    dayOfMonthOrdinalParse: /\d{1,2}\./,
    ordinal: '%d.',
    week: {
      dow: 1,
      // Monday is the first day of the week.
      doy: 4 // The week that contains Jan 4th is the first week of the year.
    }
  });
  return sq;
});

/***/ }),
/* 213 */
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Serbian [sr]
//! author : Milan Janakovi<milanjanackovic@gmail.com> : https://github.com/milan-j
//! author : Stefan Crnjakovi <stefan@hotmail.rs> : https://github.com/crnjakovic

;
(function (global, factory) {
   true ? factory(__webpack_require__(105)) : 0;
})(this, function (moment) {
  'use strict';

  //! moment.js locale configuration
  var translator = {
    words: {
      //Different grammatical cases
      ss: ['sekunda', 'sekunde', 'sekundi'],
      m: ['jedan minut', 'jednog minuta'],
      mm: ['minut', 'minuta', 'minuta'],
      h: ['jedan sat', 'jednog sata'],
      hh: ['sat', 'sata', 'sati'],
      d: ['jedan dan', 'jednog dana'],
      dd: ['dan', 'dana', 'dana'],
      M: ['jedan mesec', 'jednog meseca'],
      MM: ['mesec', 'meseca', 'meseci'],
      y: ['jednu godinu', 'jedne godine'],
      yy: ['godinu', 'godine', 'godina']
    },
    correctGrammaticalCase: function (number, wordKey) {
      if (number % 10 >= 1 && number % 10 <= 4 && (number % 100 < 10 || number % 100 >= 20)) {
        return number % 10 === 1 ? wordKey[0] : wordKey[1];
      }
      return wordKey[2];
    },
    translate: function (number, withoutSuffix, key, isFuture) {
      var wordKey = translator.words[key],
        word;
      if (key.length === 1) {
        // Nominativ
        if (key === 'y' && withoutSuffix) return 'jedna godina';
        return isFuture || withoutSuffix ? wordKey[0] : wordKey[1];
      }
      word = translator.correctGrammaticalCase(number, wordKey);
      // Nominativ
      if (key === 'yy' && withoutSuffix && word === 'godinu') {
        return number + ' godina';
      }
      return number + ' ' + word;
    }
  };
  var sr = moment.defineLocale('sr', {
    months: 'januar_februar_mart_april_maj_jun_jul_avgust_septembar_oktobar_novembar_decembar'.split('_'),
    monthsShort: 'jan._feb._mar._apr._maj_jun_jul_avg._sep._okt._nov._dec.'.split('_'),
    monthsParseExact: true,
    weekdays: 'nedelja_ponedeljak_utorak_sreda_etvrtak_petak_subota'.split('_'),
    weekdaysShort: 'ned._pon._uto._sre._et._pet._sub.'.split('_'),
    weekdaysMin: 'ne_po_ut_sr_e_pe_su'.split('_'),
    weekdaysParseExact: true,
    longDateFormat: {
      LT: 'H:mm',
      LTS: 'H:mm:ss',
      L: 'D. M. YYYY.',
      LL: 'D. MMMM YYYY.',
      LLL: 'D. MMMM YYYY. H:mm',
      LLLL: 'dddd, D. MMMM YYYY. H:mm'
    },
    calendar: {
      sameDay: '[danas u] LT',
      nextDay: '[sutra u] LT',
      nextWeek: function () {
        switch (this.day()) {
          case 0:
            return '[u] [nedelju] [u] LT';
          case 3:
            return '[u] [sredu] [u] LT';
          case 6:
            return '[u] [subotu] [u] LT';
          case 1:
          case 2:
          case 4:
          case 5:
            return '[u] dddd [u] LT';
        }
      },
      lastDay: '[jue u] LT',
      lastWeek: function () {
        var lastWeekDays = ['[prole] [nedelje] [u] LT', '[prolog] [ponedeljka] [u] LT', '[prolog] [utorka] [u] LT', '[prole] [srede] [u] LT', '[prolog] [etvrtka] [u] LT', '[prolog] [petka] [u] LT', '[prole] [subote] [u] LT'];
        return lastWeekDays[this.day()];
      },
      sameElse: 'L'
    },
    relativeTime: {
      future: 'za %s',
      past: 'pre %s',
      s: 'nekoliko sekundi',
      ss: translator.translate,
      m: translator.translate,
      mm: translator.translate,
      h: translator.translate,
      hh: translator.translate,
      d: translator.translate,
      dd: translator.translate,
      M: translator.translate,
      MM: translator.translate,
      y: translator.translate,
      yy: translator.translate
    },
    dayOfMonthOrdinalParse: /\d{1,2}\./,
    ordinal: '%d.',
    week: {
      dow: 1,
      // Monday is the first day of the week.
      doy: 7 // The week that contains Jan 7th is the first week of the year.
    }
  });
  return sr;
});

/***/ }),
/* 214 */
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Serbian Cyrillic [sr-cyrl]
//! author : Milan Janakovi<milanjanackovic@gmail.com> : https://github.com/milan-j
//! author : Stefan Crnjakovi <stefan@hotmail.rs> : https://github.com/crnjakovic

;
(function (global, factory) {
   true ? factory(__webpack_require__(105)) : 0;
})(this, function (moment) {
  'use strict';

  //! moment.js locale configuration
  var translator = {
    words: {
      //Different grammatical cases
      ss: ['', '', ''],
      m: [' ', ' '],
      mm: ['', '', ''],
      h: [' ', ' '],
      hh: ['', '', ''],
      d: [' ', ' '],
      dd: ['', '', ''],
      M: [' ', ' '],
      MM: ['', '', ''],
      y: [' ', ' '],
      yy: ['', '', '']
    },
    correctGrammaticalCase: function (number, wordKey) {
      if (number % 10 >= 1 && number % 10 <= 4 && (number % 100 < 10 || number % 100 >= 20)) {
        return number % 10 === 1 ? wordKey[0] : wordKey[1];
      }
      return wordKey[2];
    },
    translate: function (number, withoutSuffix, key, isFuture) {
      var wordKey = translator.words[key],
        word;
      if (key.length === 1) {
        // Nominativ
        if (key === 'y' && withoutSuffix) return ' ';
        return isFuture || withoutSuffix ? wordKey[0] : wordKey[1];
      }
      word = translator.correctGrammaticalCase(number, wordKey);
      // Nominativ
      if (key === 'yy' && withoutSuffix && word === '') {
        return number + ' ';
      }
      return number + ' ' + word;
    }
  };
  var srCyrl = moment.defineLocale('sr-cyrl', {
    months: '___________'.split('_'),
    monthsShort: '._._._.____._._._._.'.split('_'),
    monthsParseExact: true,
    weekdays: '______'.split('_'),
    weekdaysShort: '._._._._._._.'.split('_'),
    weekdaysMin: '______'.split('_'),
    weekdaysParseExact: true,
    longDateFormat: {
      LT: 'H:mm',
      LTS: 'H:mm:ss',
      L: 'D. M. YYYY.',
      LL: 'D. MMMM YYYY.',
      LLL: 'D. MMMM YYYY. H:mm',
      LLLL: 'dddd, D. MMMM YYYY. H:mm'
    },
    calendar: {
      sameDay: '[ ] LT',
      nextDay: '[ ] LT',
      nextWeek: function () {
        switch (this.day()) {
          case 0:
            return '[] [] [] LT';
          case 3:
            return '[] [] [] LT';
          case 6:
            return '[] [] [] LT';
          case 1:
          case 2:
          case 4:
          case 5:
            return '[] dddd [] LT';
        }
      },
      lastDay: '[ ] LT',
      lastWeek: function () {
        var lastWeekDays = ['[] [] [] LT', '[] [] [] LT', '[] [] [] LT', '[] [] [] LT', '[] [] [] LT', '[] [] [] LT', '[] [] [] LT'];
        return lastWeekDays[this.day()];
      },
      sameElse: 'L'
    },
    relativeTime: {
      future: ' %s',
      past: ' %s',
      s: ' ',
      ss: translator.translate,
      m: translator.translate,
      mm: translator.translate,
      h: translator.translate,
      hh: translator.translate,
      d: translator.translate,
      dd: translator.translate,
      M: translator.translate,
      MM: translator.translate,
      y: translator.translate,
      yy: translator.translate
    },
    dayOfMonthOrdinalParse: /\d{1,2}\./,
    ordinal: '%d.',
    week: {
      dow: 1,
      // Monday is the first day of the week.
      doy: 7 // The week that contains Jan 1st is the first week of the year.
    }
  });
  return srCyrl;
});

/***/ }),
/* 215 */
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : siSwati [ss]
//! author : Nicolai Davies<mail@nicolai.io> : https://github.com/nicolaidavies

;
(function (global, factory) {
   true ? factory(__webpack_require__(105)) : 0;
})(this, function (moment) {
  'use strict';

  //! moment.js locale configuration
  var ss = moment.defineLocale('ss', {
    months: "Bhimbidvwane_Indlovana_Indlov'lenkhulu_Mabasa_Inkhwekhweti_Inhlaba_Kholwane_Ingci_Inyoni_Imphala_Lweti_Ingongoni".split('_'),
    monthsShort: 'Bhi_Ina_Inu_Mab_Ink_Inh_Kho_Igc_Iny_Imp_Lwe_Igo'.split('_'),
    weekdays: 'Lisontfo_Umsombuluko_Lesibili_Lesitsatfu_Lesine_Lesihlanu_Umgcibelo'.split('_'),
    weekdaysShort: 'Lis_Umb_Lsb_Les_Lsi_Lsh_Umg'.split('_'),
    weekdaysMin: 'Li_Us_Lb_Lt_Ls_Lh_Ug'.split('_'),
    weekdaysParseExact: true,
    longDateFormat: {
      LT: 'h:mm A',
      LTS: 'h:mm:ss A',
      L: 'DD/MM/YYYY',
      LL: 'D MMMM YYYY',
      LLL: 'D MMMM YYYY h:mm A',
      LLLL: 'dddd, D MMMM YYYY h:mm A'
    },
    calendar: {
      sameDay: '[Namuhla nga] LT',
      nextDay: '[Kusasa nga] LT',
      nextWeek: 'dddd [nga] LT',
      lastDay: '[Itolo nga] LT',
      lastWeek: 'dddd [leliphelile] [nga] LT',
      sameElse: 'L'
    },
    relativeTime: {
      future: 'nga %s',
      past: 'wenteka nga %s',
      s: 'emizuzwana lomcane',
      ss: '%d mzuzwana',
      m: 'umzuzu',
      mm: '%d emizuzu',
      h: 'lihora',
      hh: '%d emahora',
      d: 'lilanga',
      dd: '%d emalanga',
      M: 'inyanga',
      MM: '%d tinyanga',
      y: 'umnyaka',
      yy: '%d iminyaka'
    },
    meridiemParse: /ekuseni|emini|entsambama|ebusuku/,
    meridiem: function (hours, minutes, isLower) {
      if (hours < 11) {
        return 'ekuseni';
      } else if (hours < 15) {
        return 'emini';
      } else if (hours < 19) {
        return 'entsambama';
      } else {
        return 'ebusuku';
      }
    },
    meridiemHour: function (hour, meridiem) {
      if (hour === 12) {
        hour = 0;
      }
      if (meridiem === 'ekuseni') {
        return hour;
      } else if (meridiem === 'emini') {
        return hour >= 11 ? hour : hour + 12;
      } else if (meridiem === 'entsambama' || meridiem === 'ebusuku') {
        if (hour === 0) {
          return 0;
        }
        return hour + 12;
      }
    },
    dayOfMonthOrdinalParse: /\d{1,2}/,
    ordinal: '%d',
    week: {
      dow: 1,
      // Monday is the first day of the week.
      doy: 4 // The week that contains Jan 4th is the first week of the year.
    }
  });
  return ss;
});

/***/ }),
/* 216 */
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Swedish [sv]
//! author : Jens Alm : https://github.com/ulmus

;
(function (global, factory) {
   true ? factory(__webpack_require__(105)) : 0;
})(this, function (moment) {
  'use strict';

  //! moment.js locale configuration
  var sv = moment.defineLocale('sv', {
    months: 'januari_februari_mars_april_maj_juni_juli_augusti_september_oktober_november_december'.split('_'),
    monthsShort: 'jan_feb_mar_apr_maj_jun_jul_aug_sep_okt_nov_dec'.split('_'),
    weekdays: 'sndag_mndag_tisdag_onsdag_torsdag_fredag_lrdag'.split('_'),
    weekdaysShort: 'sn_mn_tis_ons_tor_fre_lr'.split('_'),
    weekdaysMin: 's_m_ti_on_to_fr_l'.split('_'),
    longDateFormat: {
      LT: 'HH:mm',
      LTS: 'HH:mm:ss',
      L: 'YYYY-MM-DD',
      LL: 'D MMMM YYYY',
      LLL: 'D MMMM YYYY [kl.] HH:mm',
      LLLL: 'dddd D MMMM YYYY [kl.] HH:mm',
      lll: 'D MMM YYYY HH:mm',
      llll: 'ddd D MMM YYYY HH:mm'
    },
    calendar: {
      sameDay: '[Idag] LT',
      nextDay: '[Imorgon] LT',
      lastDay: '[Igr] LT',
      nextWeek: '[P] dddd LT',
      lastWeek: '[I] dddd[s] LT',
      sameElse: 'L'
    },
    relativeTime: {
      future: 'om %s',
      past: 'fr %s sedan',
      s: 'ngra sekunder',
      ss: '%d sekunder',
      m: 'en minut',
      mm: '%d minuter',
      h: 'en timme',
      hh: '%d timmar',
      d: 'en dag',
      dd: '%d dagar',
      M: 'en mnad',
      MM: '%d mnader',
      y: 'ett r',
      yy: '%d r'
    },
    dayOfMonthOrdinalParse: /\d{1,2}(\:e|\:a)/,
    ordinal: function (number) {
      var b = number % 10,
        output = ~~(number % 100 / 10) === 1 ? ':e' : b === 1 ? ':a' : b === 2 ? ':a' : b === 3 ? ':e' : ':e';
      return number + output;
    },
    week: {
      dow: 1,
      // Monday is the first day of the week.
      doy: 4 // The week that contains Jan 4th is the first week of the year.
    }
  });
  return sv;
});

/***/ }),
/* 217 */
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Swahili [sw]
//! author : Fahad Kassim : https://github.com/fadsel

;
(function (global, factory) {
   true ? factory(__webpack_require__(105)) : 0;
})(this, function (moment) {
  'use strict';

  //! moment.js locale configuration
  var sw = moment.defineLocale('sw', {
    months: 'Januari_Februari_Machi_Aprili_Mei_Juni_Julai_Agosti_Septemba_Oktoba_Novemba_Desemba'.split('_'),
    monthsShort: 'Jan_Feb_Mac_Apr_Mei_Jun_Jul_Ago_Sep_Okt_Nov_Des'.split('_'),
    weekdays: 'Jumapili_Jumatatu_Jumanne_Jumatano_Alhamisi_Ijumaa_Jumamosi'.split('_'),
    weekdaysShort: 'Jpl_Jtat_Jnne_Jtan_Alh_Ijm_Jmos'.split('_'),
    weekdaysMin: 'J2_J3_J4_J5_Al_Ij_J1'.split('_'),
    weekdaysParseExact: true,
    longDateFormat: {
      LT: 'hh:mm A',
      LTS: 'HH:mm:ss',
      L: 'DD.MM.YYYY',
      LL: 'D MMMM YYYY',
      LLL: 'D MMMM YYYY HH:mm',
      LLLL: 'dddd, D MMMM YYYY HH:mm'
    },
    calendar: {
      sameDay: '[leo saa] LT',
      nextDay: '[kesho saa] LT',
      nextWeek: '[wiki ijayo] dddd [saat] LT',
      lastDay: '[jana] LT',
      lastWeek: '[wiki iliyopita] dddd [saat] LT',
      sameElse: 'L'
    },
    relativeTime: {
      future: '%s baadaye',
      past: 'tokea %s',
      s: 'hivi punde',
      ss: 'sekunde %d',
      m: 'dakika moja',
      mm: 'dakika %d',
      h: 'saa limoja',
      hh: 'masaa %d',
      d: 'siku moja',
      dd: 'siku %d',
      M: 'mwezi mmoja',
      MM: 'miezi %d',
      y: 'mwaka mmoja',
      yy: 'miaka %d'
    },
    week: {
      dow: 1,
      // Monday is the first day of the week.
      doy: 7 // The week that contains Jan 7th is the first week of the year.
    }
  });
  return sw;
});

/***/ }),
/* 218 */
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Tamil [ta]
//! author : Arjunkumar Krishnamoorthy : https://github.com/tk120404

;
(function (global, factory) {
   true ? factory(__webpack_require__(105)) : 0;
})(this, function (moment) {
  'use strict';

  //! moment.js locale configuration
  var symbolMap = {
      1: '',
      2: '',
      3: '',
      4: '',
      5: '',
      6: '',
      7: '',
      8: '',
      9: '',
      0: ''
    },
    numberMap = {
      '': '1',
      '': '2',
      '': '3',
      '': '4',
      '': '5',
      '': '6',
      '': '7',
      '': '8',
      '': '9',
      '': '0'
    };
  var ta = moment.defineLocale('ta', {
    months: '___________'.split('_'),
    monthsShort: '___________'.split('_'),
    weekdays: '______'.split('_'),
    weekdaysShort: '______'.split('_'),
    weekdaysMin: '______'.split('_'),
    longDateFormat: {
      LT: 'HH:mm',
      LTS: 'HH:mm:ss',
      L: 'DD/MM/YYYY',
      LL: 'D MMMM YYYY',
      LLL: 'D MMMM YYYY, HH:mm',
      LLLL: 'dddd, D MMMM YYYY, HH:mm'
    },
    calendar: {
      sameDay: '[] LT',
      nextDay: '[] LT',
      nextWeek: 'dddd, LT',
      lastDay: '[] LT',
      lastWeek: '[ ] dddd, LT',
      sameElse: 'L'
    },
    relativeTime: {
      future: '%s ',
      past: '%s ',
      s: '  ',
      ss: '%d ',
      m: ' ',
      mm: '%d ',
      h: '  ',
      hh: '%d  ',
      d: ' ',
      dd: '%d ',
      M: ' ',
      MM: '%d ',
      y: ' ',
      yy: '%d '
    },
    dayOfMonthOrdinalParse: /\d{1,2}/,
    ordinal: function (number) {
      return number + '';
    },
    preparse: function (string) {
      return string.replace(/[]/g, function (match) {
        return numberMap[match];
      });
    },
    postformat: function (string) {
      return string.replace(/\d/g, function (match) {
        return symbolMap[match];
      });
    },
    // refer http://ta.wikipedia.org/s/1er1
    meridiemParse: /|||||/,
    meridiem: function (hour, minute, isLower) {
      if (hour < 2) {
        return ' ';
      } else if (hour < 6) {
        return ' '; // 
      } else if (hour < 10) {
        return ' '; // 
      } else if (hour < 14) {
        return ' '; // 
      } else if (hour < 18) {
        return ' '; // 
      } else if (hour < 22) {
        return ' '; // 
      } else {
        return ' ';
      }
    },
    meridiemHour: function (hour, meridiem) {
      if (hour === 12) {
        hour = 0;
      }
      if (meridiem === '') {
        return hour < 2 ? hour : hour + 12;
      } else if (meridiem === '' || meridiem === '') {
        return hour;
      } else if (meridiem === '') {
        return hour >= 10 ? hour : hour + 12;
      } else {
        return hour + 12;
      }
    },
    week: {
      dow: 0,
      // Sunday is the first day of the week.
      doy: 6 // The week that contains Jan 6th is the first week of the year.
    }
  });
  return ta;
});

/***/ }),
/* 219 */
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Telugu [te]
//! author : Krishna Chaitanya Thota : https://github.com/kcthota

;
(function (global, factory) {
   true ? factory(__webpack_require__(105)) : 0;
})(this, function (moment) {
  'use strict';

  //! moment.js locale configuration
  var te = moment.defineLocale('te', {
    months: '___________'.split('_'),
    monthsShort: '._.__.____._._._._.'.split('_'),
    monthsParseExact: true,
    weekdays: '______'.split('_'),
    weekdaysShort: '______'.split('_'),
    weekdaysMin: '______'.split('_'),
    longDateFormat: {
      LT: 'A h:mm',
      LTS: 'A h:mm:ss',
      L: 'DD/MM/YYYY',
      LL: 'D MMMM YYYY',
      LLL: 'D MMMM YYYY, A h:mm',
      LLLL: 'dddd, D MMMM YYYY, A h:mm'
    },
    calendar: {
      sameDay: '[] LT',
      nextDay: '[] LT',
      nextWeek: 'dddd, LT',
      lastDay: '[] LT',
      lastWeek: '[] dddd, LT',
      sameElse: 'L'
    },
    relativeTime: {
      future: '%s ',
      past: '%s ',
      s: ' ',
      ss: '%d ',
      m: ' ',
      mm: '%d ',
      h: ' ',
      hh: '%d ',
      d: ' ',
      dd: '%d ',
      M: ' ',
      MM: '%d ',
      y: ' ',
      yy: '%d '
    },
    dayOfMonthOrdinalParse: /\d{1,2}/,
    ordinal: '%d',
    meridiemParse: /|||/,
    meridiemHour: function (hour, meridiem) {
      if (hour === 12) {
        hour = 0;
      }
      if (meridiem === '') {
        return hour < 4 ? hour : hour + 12;
      } else if (meridiem === '') {
        return hour;
      } else if (meridiem === '') {
        return hour >= 10 ? hour : hour + 12;
      } else if (meridiem === '') {
        return hour + 12;
      }
    },
    meridiem: function (hour, minute, isLower) {
      if (hour < 4) {
        return '';
      } else if (hour < 10) {
        return '';
      } else if (hour < 17) {
        return '';
      } else if (hour < 20) {
        return '';
      } else {
        return '';
      }
    },
    week: {
      dow: 0,
      // Sunday is the first day of the week.
      doy: 6 // The week that contains Jan 6th is the first week of the year.
    }
  });
  return te;
});

/***/ }),
/* 220 */
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Tetun Dili (East Timor) [tet]
//! author : Joshua Brooks : https://github.com/joshbrooks
//! author : Onorio De J. Afonso : https://github.com/marobo
//! author : Sonia Simoes : https://github.com/soniasimoes

;
(function (global, factory) {
   true ? factory(__webpack_require__(105)) : 0;
})(this, function (moment) {
  'use strict';

  //! moment.js locale configuration
  var tet = moment.defineLocale('tet', {
    months: 'Janeiru_Fevereiru_Marsu_Abril_Maiu_Juu_Jullu_Agustu_Setembru_Outubru_Novembru_Dezembru'.split('_'),
    monthsShort: 'Jan_Fev_Mar_Abr_Mai_Jun_Jul_Ago_Set_Out_Nov_Dez'.split('_'),
    weekdays: 'Domingu_Segunda_Tersa_Kuarta_Kinta_Sesta_Sabadu'.split('_'),
    weekdaysShort: 'Dom_Seg_Ters_Kua_Kint_Sest_Sab'.split('_'),
    weekdaysMin: 'Do_Seg_Te_Ku_Ki_Ses_Sa'.split('_'),
    longDateFormat: {
      LT: 'HH:mm',
      LTS: 'HH:mm:ss',
      L: 'DD/MM/YYYY',
      LL: 'D MMMM YYYY',
      LLL: 'D MMMM YYYY HH:mm',
      LLLL: 'dddd, D MMMM YYYY HH:mm'
    },
    calendar: {
      sameDay: '[Ohin iha] LT',
      nextDay: '[Aban iha] LT',
      nextWeek: 'dddd [iha] LT',
      lastDay: '[Horiseik iha] LT',
      lastWeek: 'dddd [semana kotuk] [iha] LT',
      sameElse: 'L'
    },
    relativeTime: {
      future: 'iha %s',
      past: '%s liuba',
      s: 'segundu balun',
      ss: 'segundu %d',
      m: 'minutu ida',
      mm: 'minutu %d',
      h: 'oras ida',
      hh: 'oras %d',
      d: 'loron ida',
      dd: 'loron %d',
      M: 'fulan ida',
      MM: 'fulan %d',
      y: 'tinan ida',
      yy: 'tinan %d'
    },
    dayOfMonthOrdinalParse: /\d{1,2}(st|nd|rd|th)/,
    ordinal: function (number) {
      var b = number % 10,
        output = ~~(number % 100 / 10) === 1 ? 'th' : b === 1 ? 'st' : b === 2 ? 'nd' : b === 3 ? 'rd' : 'th';
      return number + output;
    },
    week: {
      dow: 1,
      // Monday is the first day of the week.
      doy: 4 // The week that contains Jan 4th is the first week of the year.
    }
  });
  return tet;
});

/***/ }),
/* 221 */
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Tajik [tg]
//! author : Orif N. Jr. : https://github.com/orif-jr

;
(function (global, factory) {
   true ? factory(__webpack_require__(105)) : 0;
})(this, function (moment) {
  'use strict';

  //! moment.js locale configuration
  var suffixes = {
    0: '-',
    1: '-',
    2: '-',
    3: '-',
    4: '-',
    5: '-',
    6: '-',
    7: '-',
    8: '-',
    9: '-',
    10: '-',
    12: '-',
    13: '-',
    20: '-',
    30: '-',
    40: '-',
    50: '-',
    60: '-',
    70: '-',
    80: '-',
    90: '-',
    100: '-'
  };
  var tg = moment.defineLocale('tg', {
    months: {
      format: '___________'.split('_'),
      standalone: '___________'.split('_')
    },
    monthsShort: '___________'.split('_'),
    weekdays: '______'.split('_'),
    weekdaysShort: '______'.split('_'),
    weekdaysMin: '______'.split('_'),
    longDateFormat: {
      LT: 'HH:mm',
      LTS: 'HH:mm:ss',
      L: 'DD.MM.YYYY',
      LL: 'D MMMM YYYY',
      LLL: 'D MMMM YYYY HH:mm',
      LLLL: 'dddd, D MMMM YYYY HH:mm'
    },
    calendar: {
      sameDay: '[ ] LT',
      nextDay: '[ ] LT',
      lastDay: '[ ] LT',
      nextWeek: 'dddd[] [  ] LT',
      lastWeek: 'dddd[] [  ] LT',
      sameElse: 'L'
    },
    relativeTime: {
      future: ' %s',
      past: '%s ',
      s: ' ',
      m: ' ',
      mm: '%d ',
      h: ' ',
      hh: '%d ',
      d: ' ',
      dd: '%d ',
      M: ' ',
      MM: '%d ',
      y: ' ',
      yy: '%d '
    },
    meridiemParse: /|||/,
    meridiemHour: function (hour, meridiem) {
      if (hour === 12) {
        hour = 0;
      }
      if (meridiem === '') {
        return hour < 4 ? hour : hour + 12;
      } else if (meridiem === '') {
        return hour;
      } else if (meridiem === '') {
        return hour >= 11 ? hour : hour + 12;
      } else if (meridiem === '') {
        return hour + 12;
      }
    },
    meridiem: function (hour, minute, isLower) {
      if (hour < 4) {
        return '';
      } else if (hour < 11) {
        return '';
      } else if (hour < 16) {
        return '';
      } else if (hour < 19) {
        return '';
      } else {
        return '';
      }
    },
    dayOfMonthOrdinalParse: /\d{1,2}-(|)/,
    ordinal: function (number) {
      var a = number % 10,
        b = number >= 100 ? 100 : null;
      return number + (suffixes[number] || suffixes[a] || suffixes[b]);
    },
    week: {
      dow: 1,
      // Monday is the first day of the week.
      doy: 7 // The week that contains Jan 1th is the first week of the year.
    }
  });
  return tg;
});

/***/ }),
/* 222 */
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Thai [th]
//! author : Kridsada Thanabulpong : https://github.com/sirn

;
(function (global, factory) {
   true ? factory(__webpack_require__(105)) : 0;
})(this, function (moment) {
  'use strict';

  //! moment.js locale configuration
  var th = moment.defineLocale('th', {
    months: '___________'.split('_'),
    monthsShort: '.._.._.._.._.._.._.._.._.._.._.._..'.split('_'),
    monthsParseExact: true,
    weekdays: '______'.split('_'),
    weekdaysShort: '______'.split('_'),
    // yes, three characters difference
    weekdaysMin: '._._._._._._.'.split('_'),
    weekdaysParseExact: true,
    longDateFormat: {
      LT: 'H:mm',
      LTS: 'H:mm:ss',
      L: 'DD/MM/YYYY',
      LL: 'D MMMM YYYY',
      LLL: 'D MMMM YYYY  H:mm',
      LLLL: 'dddd D MMMM YYYY  H:mm'
    },
    meridiemParse: /|/,
    isPM: function (input) {
      return input === '';
    },
    meridiem: function (hour, minute, isLower) {
      if (hour < 12) {
        return '';
      } else {
        return '';
      }
    },
    calendar: {
      sameDay: '[ ] LT',
      nextDay: '[ ] LT',
      nextWeek: 'dddd[ ] LT',
      lastDay: '[ ] LT',
      lastWeek: '[]dddd[ ] LT',
      sameElse: 'L'
    },
    relativeTime: {
      future: ' %s',
      past: '%s',
      s: '',
      ss: '%d ',
      m: '1 ',
      mm: '%d ',
      h: '1 ',
      hh: '%d ',
      d: '1 ',
      dd: '%d ',
      w: '1 ',
      ww: '%d ',
      M: '1 ',
      MM: '%d ',
      y: '1 ',
      yy: '%d '
    }
  });
  return th;
});

/***/ }),
/* 223 */
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Turkmen [tk]
//! author : Atamyrat Abdyrahmanov : https://github.com/atamyratabdy

;
(function (global, factory) {
   true ? factory(__webpack_require__(105)) : 0;
})(this, function (moment) {
  'use strict';

  //! moment.js locale configuration
  var suffixes = {
    1: "'inji",
    5: "'inji",
    8: "'inji",
    70: "'inji",
    80: "'inji",
    2: "'nji",
    7: "'nji",
    20: "'nji",
    50: "'nji",
    3: "'nji",
    4: "'nji",
    100: "'nji",
    6: "'njy",
    9: "'unjy",
    10: "'unjy",
    30: "'unjy",
    60: "'ynjy",
    90: "'ynjy"
  };
  var tk = moment.defineLocale('tk', {
    months: 'anwar_Fewral_Mart_Aprel_Ma_Iun_Iul_Awgust_Sentabr_Oktabr_Noabr_Dekabr'.split('_'),
    monthsShort: 'an_Few_Mar_Apr_Ma_In_Il_Awg_Sen_Okt_No_Dek'.split('_'),
    weekdays: 'ekenbe_Duenbe_Sienbe_arenbe_Penenbe_Anna_enbe'.split('_'),
    weekdaysShort: 'ek_Du_Si_ar_Pen_Ann_en'.split('_'),
    weekdaysMin: 'k_D_S_r_Pn_An_n'.split('_'),
    longDateFormat: {
      LT: 'HH:mm',
      LTS: 'HH:mm:ss',
      L: 'DD.MM.YYYY',
      LL: 'D MMMM YYYY',
      LLL: 'D MMMM YYYY HH:mm',
      LLLL: 'dddd, D MMMM YYYY HH:mm'
    },
    calendar: {
      sameDay: '[bugn sagat] LT',
      nextDay: '[ertir sagat] LT',
      nextWeek: '[indiki] dddd [sagat] LT',
      lastDay: '[dn] LT',
      lastWeek: '[geen] dddd [sagat] LT',
      sameElse: 'L'
    },
    relativeTime: {
      future: '%s so',
      past: '%s ',
      s: 'birne sekunt',
      m: 'bir minut',
      mm: '%d minut',
      h: 'bir sagat',
      hh: '%d sagat',
      d: 'bir gn',
      dd: '%d gn',
      M: 'bir a',
      MM: '%d a',
      y: 'bir yl',
      yy: '%d yl'
    },
    ordinal: function (number, period) {
      switch (period) {
        case 'd':
        case 'D':
        case 'Do':
        case 'DD':
          return number;
        default:
          if (number === 0) {
            // special case for zero
            return number + "'unjy";
          }
          var a = number % 10,
            b = number % 100 - a,
            c = number >= 100 ? 100 : null;
          return number + (suffixes[a] || suffixes[b] || suffixes[c]);
      }
    },
    week: {
      dow: 1,
      // Monday is the first day of the week.
      doy: 7 // The week that contains Jan 7th is the first week of the year.
    }
  });
  return tk;
});

/***/ }),
/* 224 */
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Tagalog (Philippines) [tl-ph]
//! author : Dan Hagman : https://github.com/hagmandan

;
(function (global, factory) {
   true ? factory(__webpack_require__(105)) : 0;
})(this, function (moment) {
  'use strict';

  //! moment.js locale configuration
  var tlPh = moment.defineLocale('tl-ph', {
    months: 'Enero_Pebrero_Marso_Abril_Mayo_Hunyo_Hulyo_Agosto_Setyembre_Oktubre_Nobyembre_Disyembre'.split('_'),
    monthsShort: 'Ene_Peb_Mar_Abr_May_Hun_Hul_Ago_Set_Okt_Nob_Dis'.split('_'),
    weekdays: 'Linggo_Lunes_Martes_Miyerkules_Huwebes_Biyernes_Sabado'.split('_'),
    weekdaysShort: 'Lin_Lun_Mar_Miy_Huw_Biy_Sab'.split('_'),
    weekdaysMin: 'Li_Lu_Ma_Mi_Hu_Bi_Sab'.split('_'),
    longDateFormat: {
      LT: 'HH:mm',
      LTS: 'HH:mm:ss',
      L: 'MM/D/YYYY',
      LL: 'MMMM D, YYYY',
      LLL: 'MMMM D, YYYY HH:mm',
      LLLL: 'dddd, MMMM DD, YYYY HH:mm'
    },
    calendar: {
      sameDay: 'LT [ngayong araw]',
      nextDay: '[Bukas ng] LT',
      nextWeek: 'LT [sa susunod na] dddd',
      lastDay: 'LT [kahapon]',
      lastWeek: 'LT [noong nakaraang] dddd',
      sameElse: 'L'
    },
    relativeTime: {
      future: 'sa loob ng %s',
      past: '%s ang nakalipas',
      s: 'ilang segundo',
      ss: '%d segundo',
      m: 'isang minuto',
      mm: '%d minuto',
      h: 'isang oras',
      hh: '%d oras',
      d: 'isang araw',
      dd: '%d araw',
      M: 'isang buwan',
      MM: '%d buwan',
      y: 'isang taon',
      yy: '%d taon'
    },
    dayOfMonthOrdinalParse: /\d{1,2}/,
    ordinal: function (number) {
      return number;
    },
    week: {
      dow: 1,
      // Monday is the first day of the week.
      doy: 4 // The week that contains Jan 4th is the first week of the year.
    }
  });
  return tlPh;
});

/***/ }),
/* 225 */
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Klingon [tlh]
//! author : Dominika Kruk : https://github.com/amaranthrose

;
(function (global, factory) {
   true ? factory(__webpack_require__(105)) : 0;
})(this, function (moment) {
  'use strict';

  //! moment.js locale configuration
  var numbersNouns = 'pagh_wa_cha_wej_loS_vagh_jav_Soch_chorgh_Hut'.split('_');
  function translateFuture(output) {
    var time = output;
    time = output.indexOf('jaj') !== -1 ? time.slice(0, -3) + 'leS' : output.indexOf('jar') !== -1 ? time.slice(0, -3) + 'waQ' : output.indexOf('DIS') !== -1 ? time.slice(0, -3) + 'nem' : time + ' pIq';
    return time;
  }
  function translatePast(output) {
    var time = output;
    time = output.indexOf('jaj') !== -1 ? time.slice(0, -3) + 'Hu' : output.indexOf('jar') !== -1 ? time.slice(0, -3) + 'wen' : output.indexOf('DIS') !== -1 ? time.slice(0, -3) + 'ben' : time + ' ret';
    return time;
  }
  function translate(number, withoutSuffix, string, isFuture) {
    var numberNoun = numberAsNoun(number);
    switch (string) {
      case 'ss':
        return numberNoun + ' lup';
      case 'mm':
        return numberNoun + ' tup';
      case 'hh':
        return numberNoun + ' rep';
      case 'dd':
        return numberNoun + ' jaj';
      case 'MM':
        return numberNoun + ' jar';
      case 'yy':
        return numberNoun + ' DIS';
    }
  }
  function numberAsNoun(number) {
    var hundred = Math.floor(number % 1000 / 100),
      ten = Math.floor(number % 100 / 10),
      one = number % 10,
      word = '';
    if (hundred > 0) {
      word += numbersNouns[hundred] + 'vatlh';
    }
    if (ten > 0) {
      word += (word !== '' ? ' ' : '') + numbersNouns[ten] + 'maH';
    }
    if (one > 0) {
      word += (word !== '' ? ' ' : '') + numbersNouns[one];
    }
    return word === '' ? 'pagh' : word;
  }
  var tlh = moment.defineLocale('tlh', {
    months: 'tera jar wa_tera jar cha_tera jar wej_tera jar loS_tera jar vagh_tera jar jav_tera jar Soch_tera jar chorgh_tera jar Hut_tera jar wamaH_tera jar wamaH wa_tera jar wamaH cha'.split('_'),
    monthsShort: 'jar wa_jar cha_jar wej_jar loS_jar vagh_jar jav_jar Soch_jar chorgh_jar Hut_jar wamaH_jar wamaH wa_jar wamaH cha'.split('_'),
    monthsParseExact: true,
    weekdays: 'lojmItjaj_DaSjaj_povjaj_ghItlhjaj_loghjaj_buqjaj_ghInjaj'.split('_'),
    weekdaysShort: 'lojmItjaj_DaSjaj_povjaj_ghItlhjaj_loghjaj_buqjaj_ghInjaj'.split('_'),
    weekdaysMin: 'lojmItjaj_DaSjaj_povjaj_ghItlhjaj_loghjaj_buqjaj_ghInjaj'.split('_'),
    longDateFormat: {
      LT: 'HH:mm',
      LTS: 'HH:mm:ss',
      L: 'DD.MM.YYYY',
      LL: 'D MMMM YYYY',
      LLL: 'D MMMM YYYY HH:mm',
      LLLL: 'dddd, D MMMM YYYY HH:mm'
    },
    calendar: {
      sameDay: '[DaHjaj] LT',
      nextDay: '[waleS] LT',
      nextWeek: 'LLL',
      lastDay: '[waHu] LT',
      lastWeek: 'LLL',
      sameElse: 'L'
    },
    relativeTime: {
      future: translateFuture,
      past: translatePast,
      s: 'puS lup',
      ss: translate,
      m: 'wa tup',
      mm: translate,
      h: 'wa rep',
      hh: translate,
      d: 'wa jaj',
      dd: translate,
      M: 'wa jar',
      MM: translate,
      y: 'wa DIS',
      yy: translate
    },
    dayOfMonthOrdinalParse: /\d{1,2}\./,
    ordinal: '%d.',
    week: {
      dow: 1,
      // Monday is the first day of the week.
      doy: 4 // The week that contains Jan 4th is the first week of the year.
    }
  });
  return tlh;
});

/***/ }),
/* 226 */
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Turkish [tr]
//! authors : Erhan Gundogan : https://github.com/erhangundogan,
//!           Burak Yiit Kaya: https://github.com/BYK

;
(function (global, factory) {
   true ? factory(__webpack_require__(105)) : 0;
})(this, function (moment) {
  'use strict';

  //! moment.js locale configuration
  var suffixes = {
    1: "'inci",
    5: "'inci",
    8: "'inci",
    70: "'inci",
    80: "'inci",
    2: "'nci",
    7: "'nci",
    20: "'nci",
    50: "'nci",
    3: "'nc",
    4: "'nc",
    100: "'nc",
    6: "'nc",
    9: "'uncu",
    10: "'uncu",
    30: "'uncu",
    60: "'nc",
    90: "'nc"
  };
  var tr = moment.defineLocale('tr', {
    months: 'Ocak_ubat_Mart_Nisan_Mays_Haziran_Temmuz_Austos_Eyll_Ekim_Kasm_Aralk'.split('_'),
    monthsShort: 'Oca_ub_Mar_Nis_May_Haz_Tem_Au_Eyl_Eki_Kas_Ara'.split('_'),
    weekdays: 'Pazar_Pazartesi_Sal_aramba_Perembe_Cuma_Cumartesi'.split('_'),
    weekdaysShort: 'Paz_Pzt_Sal_ar_Per_Cum_Cmt'.split('_'),
    weekdaysMin: 'Pz_Pt_Sa_a_Pe_Cu_Ct'.split('_'),
    meridiem: function (hours, minutes, isLower) {
      if (hours < 12) {
        return isLower ? '' : '';
      } else {
        return isLower ? 's' : 'S';
      }
    },
    meridiemParse: /||s|S/,
    isPM: function (input) {
      return input === 's' || input === 'S';
    },
    longDateFormat: {
      LT: 'HH:mm',
      LTS: 'HH:mm:ss',
      L: 'DD.MM.YYYY',
      LL: 'D MMMM YYYY',
      LLL: 'D MMMM YYYY HH:mm',
      LLLL: 'dddd, D MMMM YYYY HH:mm'
    },
    calendar: {
      sameDay: '[bugn saat] LT',
      nextDay: '[yarn saat] LT',
      nextWeek: '[gelecek] dddd [saat] LT',
      lastDay: '[dn] LT',
      lastWeek: '[geen] dddd [saat] LT',
      sameElse: 'L'
    },
    relativeTime: {
      future: '%s sonra',
      past: '%s nce',
      s: 'birka saniye',
      ss: '%d saniye',
      m: 'bir dakika',
      mm: '%d dakika',
      h: 'bir saat',
      hh: '%d saat',
      d: 'bir gn',
      dd: '%d gn',
      w: 'bir hafta',
      ww: '%d hafta',
      M: 'bir ay',
      MM: '%d ay',
      y: 'bir yl',
      yy: '%d yl'
    },
    ordinal: function (number, period) {
      switch (period) {
        case 'd':
        case 'D':
        case 'Do':
        case 'DD':
          return number;
        default:
          if (number === 0) {
            // special case for zero
            return number + "'nc";
          }
          var a = number % 10,
            b = number % 100 - a,
            c = number >= 100 ? 100 : null;
          return number + (suffixes[a] || suffixes[b] || suffixes[c]);
      }
    },
    week: {
      dow: 1,
      // Monday is the first day of the week.
      doy: 7 // The week that contains Jan 7th is the first week of the year.
    }
  });
  return tr;
});

/***/ }),
/* 227 */
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Talossan [tzl]
//! author : Robin van der Vliet : https://github.com/robin0van0der0v
//! author : Iust Canun

;
(function (global, factory) {
   true ? factory(__webpack_require__(105)) : 0;
})(this, function (moment) {
  'use strict';

  //! moment.js locale configuration

  // After the year there should be a slash and the amount of years since December 26, 1979 in Roman numerals.
  // This is currently too difficult (maybe even impossible) to add.
  var tzl = moment.defineLocale('tzl', {
    months: 'Januar_Fevraglh_Mar_Avru_Mai_Gn_Julia_Guscht_Setemvar_Listopts_Noemvar_Zecemvar'.split('_'),
    monthsShort: 'Jan_Fev_Mar_Avr_Mai_Gn_Jul_Gus_Set_Lis_Noe_Zec'.split('_'),
    weekdays: 'Sladi_Lnei_Maitzi_Mrcuri_Xhadi_Vineri_Sturi'.split('_'),
    weekdaysShort: 'Sl_Ln_Mai_Mr_Xh_Vi_St'.split('_'),
    weekdaysMin: 'S_L_Ma_M_Xh_Vi_S'.split('_'),
    longDateFormat: {
      LT: 'HH.mm',
      LTS: 'HH.mm.ss',
      L: 'DD.MM.YYYY',
      LL: 'D. MMMM [dallas] YYYY',
      LLL: 'D. MMMM [dallas] YYYY HH.mm',
      LLLL: 'dddd, [li] D. MMMM [dallas] YYYY HH.mm'
    },
    meridiemParse: /d\'o|d\'a/i,
    isPM: function (input) {
      return "d'o" === input.toLowerCase();
    },
    meridiem: function (hours, minutes, isLower) {
      if (hours > 11) {
        return isLower ? "d'o" : "D'O";
      } else {
        return isLower ? "d'a" : "D'A";
      }
    },
    calendar: {
      sameDay: '[oxhi ] LT',
      nextDay: '[dem ] LT',
      nextWeek: 'dddd [] LT',
      lastDay: '[ieiri ] LT',
      lastWeek: '[sr el] dddd [lasteu ] LT',
      sameElse: 'L'
    },
    relativeTime: {
      future: 'osprei %s',
      past: 'ja%s',
      s: processRelativeTime,
      ss: processRelativeTime,
      m: processRelativeTime,
      mm: processRelativeTime,
      h: processRelativeTime,
      hh: processRelativeTime,
      d: processRelativeTime,
      dd: processRelativeTime,
      M: processRelativeTime,
      MM: processRelativeTime,
      y: processRelativeTime,
      yy: processRelativeTime
    },
    dayOfMonthOrdinalParse: /\d{1,2}\./,
    ordinal: '%d.',
    week: {
      dow: 1,
      // Monday is the first day of the week.
      doy: 4 // The week that contains Jan 4th is the first week of the year.
    }
  });
  function processRelativeTime(number, withoutSuffix, key, isFuture) {
    var format = {
      s: ['viensas secunds', "'iensas secunds"],
      ss: [number + ' secunds', '' + number + ' secunds'],
      m: ["'n mut", "'iens mut"],
      mm: [number + ' muts', '' + number + ' muts'],
      h: ["'n ora", "'iensa ora"],
      hh: [number + ' oras', '' + number + ' oras'],
      d: ["'n ziua", "'iensa ziua"],
      dd: [number + ' ziuas', '' + number + ' ziuas'],
      M: ["'n mes", "'iens mes"],
      MM: [number + ' mesen', '' + number + ' mesen'],
      y: ["'n ar", "'iens ar"],
      yy: [number + ' ars', '' + number + ' ars']
    };
    return isFuture ? format[key][0] : withoutSuffix ? format[key][0] : format[key][1];
  }
  return tzl;
});

/***/ }),
/* 228 */
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Central Atlas Tamazight [tzm]
//! author : Abdel Said : https://github.com/abdelsaid

;
(function (global, factory) {
   true ? factory(__webpack_require__(105)) : 0;
})(this, function (moment) {
  'use strict';

  //! moment.js locale configuration
  var tzm = moment.defineLocale('tzm', {
    months: '___________'.split('_'),
    monthsShort: '___________'.split('_'),
    weekdays: '______'.split('_'),
    weekdaysShort: '______'.split('_'),
    weekdaysMin: '______'.split('_'),
    longDateFormat: {
      LT: 'HH:mm',
      LTS: 'HH:mm:ss',
      L: 'DD/MM/YYYY',
      LL: 'D MMMM YYYY',
      LLL: 'D MMMM YYYY HH:mm',
      LLLL: 'dddd D MMMM YYYY HH:mm'
    },
    calendar: {
      sameDay: '[ ] LT',
      nextDay: '[ ] LT',
      nextWeek: 'dddd [] LT',
      lastDay: '[ ] LT',
      lastWeek: 'dddd [] LT',
      sameElse: 'L'
    },
    relativeTime: {
      future: '   %s',
      past: ' %s',
      s: '',
      ss: '%d ',
      m: '',
      mm: '%d ',
      h: '',
      hh: '%d ',
      d: '',
      dd: '%d o',
      M: 'o',
      MM: '%d ',
      y: '',
      yy: '%d '
    },
    week: {
      dow: 6,
      // Saturday is the first day of the week.
      doy: 12 // The week that contains Jan 12th is the first week of the year.
    }
  });
  return tzm;
});

/***/ }),
/* 229 */
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Central Atlas Tamazight Latin [tzm-latn]
//! author : Abdel Said : https://github.com/abdelsaid

;
(function (global, factory) {
   true ? factory(__webpack_require__(105)) : 0;
})(this, function (moment) {
  'use strict';

  //! moment.js locale configuration
  var tzmLatn = moment.defineLocale('tzm-latn', {
    months: 'innayr_brayr_mars_ibrir_mayyw_ywnyw_ywlywz_wt_wtanbir_ktwbr_nwwanbir_dwjnbir'.split('_'),
    monthsShort: 'innayr_brayr_mars_ibrir_mayyw_ywnyw_ywlywz_wt_wtanbir_ktwbr_nwwanbir_dwjnbir'.split('_'),
    weekdays: 'asamas_aynas_asinas_akras_akwas_asimwas_asiyas'.split('_'),
    weekdaysShort: 'asamas_aynas_asinas_akras_akwas_asimwas_asiyas'.split('_'),
    weekdaysMin: 'asamas_aynas_asinas_akras_akwas_asimwas_asiyas'.split('_'),
    longDateFormat: {
      LT: 'HH:mm',
      LTS: 'HH:mm:ss',
      L: 'DD/MM/YYYY',
      LL: 'D MMMM YYYY',
      LLL: 'D MMMM YYYY HH:mm',
      LLLL: 'dddd D MMMM YYYY HH:mm'
    },
    calendar: {
      sameDay: '[asdkh g] LT',
      nextDay: '[aska g] LT',
      nextWeek: 'dddd [g] LT',
      lastDay: '[assant g] LT',
      lastWeek: 'dddd [g] LT',
      sameElse: 'L'
    },
    relativeTime: {
      future: 'dadkh s yan %s',
      past: 'yan %s',
      s: 'imik',
      ss: '%d imik',
      m: 'minu',
      mm: '%d minu',
      h: 'saa',
      hh: '%d tassain',
      d: 'ass',
      dd: '%d ossan',
      M: 'ayowr',
      MM: '%d iyyirn',
      y: 'asgas',
      yy: '%d isgasn'
    },
    week: {
      dow: 6,
      // Saturday is the first day of the week.
      doy: 12 // The week that contains Jan 12th is the first week of the year.
    }
  });
  return tzmLatn;
});

/***/ }),
/* 230 */
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Uyghur (China) [ug-cn]
//! author: boyaq : https://github.com/boyaq

;
(function (global, factory) {
   true ? factory(__webpack_require__(105)) : 0;
})(this, function (moment) {
  'use strict';

  //! moment.js locale configuration
  var ugCn = moment.defineLocale('ug-cn', {
    months: '___________'.split('_'),
    monthsShort: '___________'.split('_'),
    weekdays: '______'.split('_'),
    weekdaysShort: '______'.split('_'),
    weekdaysMin: '______'.split('_'),
    longDateFormat: {
      LT: 'HH:mm',
      LTS: 'HH:mm:ss',
      L: 'YYYY-MM-DD',
      LL: 'YYYY-M-D-',
      LLL: 'YYYY-M-D- HH:mm',
      LLLL: 'dddd YYYY-M-D- HH:mm'
    },
    meridiemParse: / || || |/,
    meridiemHour: function (hour, meridiem) {
      if (hour === 12) {
        hour = 0;
      }
      if (meridiem === ' ' || meridiem === '' || meridiem === ' ') {
        return hour;
      } else if (meridiem === ' ' || meridiem === '') {
        return hour + 12;
      } else {
        return hour >= 11 ? hour : hour + 12;
      }
    },
    meridiem: function (hour, minute, isLower) {
      var hm = hour * 100 + minute;
      if (hm < 600) {
        return ' ';
      } else if (hm < 900) {
        return '';
      } else if (hm < 1130) {
        return ' ';
      } else if (hm < 1230) {
        return '';
      } else if (hm < 1800) {
        return ' ';
      } else {
        return '';
      }
    },
    calendar: {
      sameDay: '[ ] LT',
      nextDay: '[ ] LT',
      nextWeek: '[] dddd [] LT',
      lastDay: '[] LT',
      lastWeek: '[] dddd [] LT',
      sameElse: 'L'
    },
    relativeTime: {
      future: '%s ',
      past: '%s ',
      s: ' ',
      ss: '%d ',
      m: ' ',
      mm: '%d ',
      h: ' ',
      hh: '%d ',
      d: ' ',
      dd: '%d ',
      M: ' ',
      MM: '%d ',
      y: ' ',
      yy: '%d '
    },
    dayOfMonthOrdinalParse: /\d{1,2}(-|-|-)/,
    ordinal: function (number, period) {
      switch (period) {
        case 'd':
        case 'D':
        case 'DDD':
          return number + '-';
        case 'w':
        case 'W':
          return number + '-';
        default:
          return number;
      }
    },
    preparse: function (string) {
      return string.replace(//g, ',');
    },
    postformat: function (string) {
      return string.replace(/,/g, '');
    },
    week: {
      // GB/T 7408-1994ISO 8601:1988
      dow: 1,
      // Monday is the first day of the week.
      doy: 7 // The week that contains Jan 1st is the first week of the year.
    }
  });
  return ugCn;
});

/***/ }),
/* 231 */
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Ukrainian [uk]
//! author : zemlanin : https://github.com/zemlanin
//! Author : Menelion Elensle : https://github.com/Oire

;
(function (global, factory) {
   true ? factory(__webpack_require__(105)) : 0;
})(this, function (moment) {
  'use strict';

  //! moment.js locale configuration
  function plural(word, num) {
    var forms = word.split('_');
    return num % 10 === 1 && num % 100 !== 11 ? forms[0] : num % 10 >= 2 && num % 10 <= 4 && (num % 100 < 10 || num % 100 >= 20) ? forms[1] : forms[2];
  }
  function relativeTimeWithPlural(number, withoutSuffix, key) {
    var format = {
      ss: withoutSuffix ? '__' : '__',
      mm: withoutSuffix ? '__' : '__',
      hh: withoutSuffix ? '__' : '__',
      dd: '__',
      MM: '__',
      yy: '__'
    };
    if (key === 'm') {
      return withoutSuffix ? '' : '';
    } else if (key === 'h') {
      return withoutSuffix ? '' : '';
    } else {
      return number + ' ' + plural(format[key], +number);
    }
  }
  function weekdaysCaseReplace(m, format) {
    var weekdays = {
        nominative: '______'.split('_'),
        accusative: '______'.split('_'),
        genitive: '______'.split('_')
      },
      nounCase;
    if (m === true) {
      return weekdays['nominative'].slice(1, 7).concat(weekdays['nominative'].slice(0, 1));
    }
    if (!m) {
      return weekdays['nominative'];
    }
    nounCase = /(\[[]\]) ?dddd/.test(format) ? 'accusative' : /\[?(?:|)? ?\] ?dddd/.test(format) ? 'genitive' : 'nominative';
    return weekdays[nounCase][m.day()];
  }
  function processHoursFunction(str) {
    return function () {
      return str + '' + (this.hours() === 11 ? '' : '') + '] LT';
    };
  }
  var uk = moment.defineLocale('uk', {
    months: {
      format: '___________'.split('_'),
      standalone: '___________'.split('_')
    },
    monthsShort: '___________'.split('_'),
    weekdays: weekdaysCaseReplace,
    weekdaysShort: '______'.split('_'),
    weekdaysMin: '______'.split('_'),
    longDateFormat: {
      LT: 'HH:mm',
      LTS: 'HH:mm:ss',
      L: 'DD.MM.YYYY',
      LL: 'D MMMM YYYY .',
      LLL: 'D MMMM YYYY ., HH:mm',
      LLLL: 'dddd, D MMMM YYYY ., HH:mm'
    },
    calendar: {
      sameDay: processHoursFunction('[ '),
      nextDay: processHoursFunction('[ '),
      lastDay: processHoursFunction('[ '),
      nextWeek: processHoursFunction('[] dddd ['),
      lastWeek: function () {
        switch (this.day()) {
          case 0:
          case 3:
          case 5:
          case 6:
            return processHoursFunction('[] dddd [').call(this);
          case 1:
          case 2:
          case 4:
            return processHoursFunction('[] dddd [').call(this);
        }
      },
      sameElse: 'L'
    },
    relativeTime: {
      future: ' %s',
      past: '%s ',
      s: ' ',
      ss: relativeTimeWithPlural,
      m: relativeTimeWithPlural,
      mm: relativeTimeWithPlural,
      h: '',
      hh: relativeTimeWithPlural,
      d: '',
      dd: relativeTimeWithPlural,
      M: '',
      MM: relativeTimeWithPlural,
      y: '',
      yy: relativeTimeWithPlural
    },
    // M. E.: those two are virtually unused but a user might want to implement them for his/her website for some reason
    meridiemParse: /|||/,
    isPM: function (input) {
      return /^(|)$/.test(input);
    },
    meridiem: function (hour, minute, isLower) {
      if (hour < 4) {
        return '';
      } else if (hour < 12) {
        return '';
      } else if (hour < 17) {
        return '';
      } else {
        return '';
      }
    },
    dayOfMonthOrdinalParse: /\d{1,2}-(|)/,
    ordinal: function (number, period) {
      switch (period) {
        case 'M':
        case 'd':
        case 'DDD':
        case 'w':
        case 'W':
          return number + '-';
        case 'D':
          return number + '-';
        default:
          return number;
      }
    },
    week: {
      dow: 1,
      // Monday is the first day of the week.
      doy: 7 // The week that contains Jan 7th is the first week of the year.
    }
  });
  return uk;
});

/***/ }),
/* 232 */
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Urdu [ur]
//! author : Sawood Alam : https://github.com/ibnesayeed
//! author : Zack : https://github.com/ZackVision

;
(function (global, factory) {
   true ? factory(__webpack_require__(105)) : 0;
})(this, function (moment) {
  'use strict';

  //! moment.js locale configuration
  var months = ['', '', '', '', '', '', '', '', '', '', '', ''],
    days = ['', '', '', '', '', '', ''];
  var ur = moment.defineLocale('ur', {
    months: months,
    monthsShort: months,
    weekdays: days,
    weekdaysShort: days,
    weekdaysMin: days,
    longDateFormat: {
      LT: 'HH:mm',
      LTS: 'HH:mm:ss',
      L: 'DD/MM/YYYY',
      LL: 'D MMMM YYYY',
      LLL: 'D MMMM YYYY HH:mm',
      LLLL: 'dddd D MMMM YYYY HH:mm'
    },
    meridiemParse: /|/,
    isPM: function (input) {
      return '' === input;
    },
    meridiem: function (hour, minute, isLower) {
      if (hour < 12) {
        return '';
      }
      return '';
    },
    calendar: {
      sameDay: '[ ] LT',
      nextDay: '[ ] LT',
      nextWeek: 'dddd [] LT',
      lastDay: '[  ] LT',
      lastWeek: '[] dddd [] LT',
      sameElse: 'L'
    },
    relativeTime: {
      future: '%s ',
      past: '%s ',
      s: ' ',
      ss: '%d ',
      m: ' ',
      mm: '%d ',
      h: ' ',
      hh: '%d ',
      d: ' ',
      dd: '%d ',
      M: ' ',
      MM: '%d ',
      y: ' ',
      yy: '%d '
    },
    preparse: function (string) {
      return string.replace(//g, ',');
    },
    postformat: function (string) {
      return string.replace(/,/g, '');
    },
    week: {
      dow: 1,
      // Monday is the first day of the week.
      doy: 4 // The week that contains Jan 4th is the first week of the year.
    }
  });
  return ur;
});

/***/ }),
/* 233 */
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Uzbek [uz]
//! author : Sardor Muminov : https://github.com/muminoff

;
(function (global, factory) {
   true ? factory(__webpack_require__(105)) : 0;
})(this, function (moment) {
  'use strict';

  //! moment.js locale configuration
  var uz = moment.defineLocale('uz', {
    months: '___________'.split('_'),
    monthsShort: '___________'.split('_'),
    weekdays: '______'.split('_'),
    weekdaysShort: '______'.split('_'),
    weekdaysMin: '______'.split('_'),
    longDateFormat: {
      LT: 'HH:mm',
      LTS: 'HH:mm:ss',
      L: 'DD/MM/YYYY',
      LL: 'D MMMM YYYY',
      LLL: 'D MMMM YYYY HH:mm',
      LLLL: 'D MMMM YYYY, dddd HH:mm'
    },
    calendar: {
      sameDay: '[ ] LT []',
      nextDay: '[] LT []',
      nextWeek: 'dddd [ ] LT []',
      lastDay: '[ ] LT []',
      lastWeek: '[] dddd [ ] LT []',
      sameElse: 'L'
    },
    relativeTime: {
      future: ' %s ',
      past: '  %s ',
      s: '',
      ss: '%d ',
      m: ' ',
      mm: '%d ',
      h: ' ',
      hh: '%d ',
      d: ' ',
      dd: '%d ',
      M: ' ',
      MM: '%d ',
      y: ' ',
      yy: '%d '
    },
    week: {
      dow: 1,
      // Monday is the first day of the week.
      doy: 7 // The week that contains Jan 4th is the first week of the year.
    }
  });
  return uz;
});

/***/ }),
/* 234 */
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Uzbek Latin [uz-latn]
//! author : Rasulbek Mirzayev : github.com/Rasulbeeek

;
(function (global, factory) {
   true ? factory(__webpack_require__(105)) : 0;
})(this, function (moment) {
  'use strict';

  //! moment.js locale configuration
  var uzLatn = moment.defineLocale('uz-latn', {
    months: 'Yanvar_Fevral_Mart_Aprel_May_Iyun_Iyul_Avgust_Sentabr_Oktabr_Noyabr_Dekabr'.split('_'),
    monthsShort: 'Yan_Fev_Mar_Apr_May_Iyun_Iyul_Avg_Sen_Okt_Noy_Dek'.split('_'),
    weekdays: 'Yakshanba_Dushanba_Seshanba_Chorshanba_Payshanba_Juma_Shanba'.split('_'),
    weekdaysShort: 'Yak_Dush_Sesh_Chor_Pay_Jum_Shan'.split('_'),
    weekdaysMin: 'Ya_Du_Se_Cho_Pa_Ju_Sha'.split('_'),
    longDateFormat: {
      LT: 'HH:mm',
      LTS: 'HH:mm:ss',
      L: 'DD/MM/YYYY',
      LL: 'D MMMM YYYY',
      LLL: 'D MMMM YYYY HH:mm',
      LLLL: 'D MMMM YYYY, dddd HH:mm'
    },
    calendar: {
      sameDay: '[Bugun soat] LT [da]',
      nextDay: '[Ertaga] LT [da]',
      nextWeek: 'dddd [kuni soat] LT [da]',
      lastDay: '[Kecha soat] LT [da]',
      lastWeek: "[O'tgan] dddd [kuni soat] LT [da]",
      sameElse: 'L'
    },
    relativeTime: {
      future: 'Yaqin %s ichida',
      past: 'Bir necha %s oldin',
      s: 'soniya',
      ss: '%d soniya',
      m: 'bir daqiqa',
      mm: '%d daqiqa',
      h: 'bir soat',
      hh: '%d soat',
      d: 'bir kun',
      dd: '%d kun',
      M: 'bir oy',
      MM: '%d oy',
      y: 'bir yil',
      yy: '%d yil'
    },
    week: {
      dow: 1,
      // Monday is the first day of the week.
      doy: 7 // The week that contains Jan 7th is the first week of the year.
    }
  });
  return uzLatn;
});

/***/ }),
/* 235 */
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Vietnamese [vi]
//! author : Bang Nguyen : https://github.com/bangnk
//! author : Chien Kira : https://github.com/chienkira

;
(function (global, factory) {
   true ? factory(__webpack_require__(105)) : 0;
})(this, function (moment) {
  'use strict';

  //! moment.js locale configuration
  var vi = moment.defineLocale('vi', {
    months: 'thng 1_thng 2_thng 3_thng 4_thng 5_thng 6_thng 7_thng 8_thng 9_thng 10_thng 11_thng 12'.split('_'),
    monthsShort: 'Thg 01_Thg 02_Thg 03_Thg 04_Thg 05_Thg 06_Thg 07_Thg 08_Thg 09_Thg 10_Thg 11_Thg 12'.split('_'),
    monthsParseExact: true,
    weekdays: 'ch nht_th hai_th ba_th t_th nm_th su_th by'.split('_'),
    weekdaysShort: 'CN_T2_T3_T4_T5_T6_T7'.split('_'),
    weekdaysMin: 'CN_T2_T3_T4_T5_T6_T7'.split('_'),
    weekdaysParseExact: true,
    meridiemParse: /sa|ch/i,
    isPM: function (input) {
      return /^ch$/i.test(input);
    },
    meridiem: function (hours, minutes, isLower) {
      if (hours < 12) {
        return isLower ? 'sa' : 'SA';
      } else {
        return isLower ? 'ch' : 'CH';
      }
    },
    longDateFormat: {
      LT: 'HH:mm',
      LTS: 'HH:mm:ss',
      L: 'DD/MM/YYYY',
      LL: 'D MMMM [nm] YYYY',
      LLL: 'D MMMM [nm] YYYY HH:mm',
      LLLL: 'dddd, D MMMM [nm] YYYY HH:mm',
      l: 'DD/M/YYYY',
      ll: 'D MMM YYYY',
      lll: 'D MMM YYYY HH:mm',
      llll: 'ddd, D MMM YYYY HH:mm'
    },
    calendar: {
      sameDay: '[Hm nay lc] LT',
      nextDay: '[Ngy mai lc] LT',
      nextWeek: 'dddd [tun ti lc] LT',
      lastDay: '[Hm qua lc] LT',
      lastWeek: 'dddd [tun trc lc] LT',
      sameElse: 'L'
    },
    relativeTime: {
      future: '%s ti',
      past: '%s trc',
      s: 'vi giy',
      ss: '%d giy',
      m: 'mt pht',
      mm: '%d pht',
      h: 'mt gi',
      hh: '%d gi',
      d: 'mt ngy',
      dd: '%d ngy',
      w: 'mt tun',
      ww: '%d tun',
      M: 'mt thng',
      MM: '%d thng',
      y: 'mt nm',
      yy: '%d nm'
    },
    dayOfMonthOrdinalParse: /\d{1,2}/,
    ordinal: function (number) {
      return number;
    },
    week: {
      dow: 1,
      // Monday is the first day of the week.
      doy: 4 // The week that contains Jan 4th is the first week of the year.
    }
  });
  return vi;
});

/***/ }),
/* 236 */
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Pseudo [x-pseudo]
//! author : Andrew Hood : https://github.com/andrewhood125

;
(function (global, factory) {
   true ? factory(__webpack_require__(105)) : 0;
})(this, function (moment) {
  'use strict';

  //! moment.js locale configuration
  var xPseudo = moment.defineLocale('x-pseudo', {
    months: 'J~~r_F~br~r_~Mrc~h_p~rl_~M_~J~_Jl~_~gst~_Sp~tmb~r_~ctb~r_~vm~br_~Dc~mbr'.split('_'),
    monthsShort: 'J~_~Fb_~Mr_~pr_~M_~J_~Jl_~g_~Sp_~ct_~v_~Dc'.split('_'),
    monthsParseExact: true,
    weekdays: 'S~d~_M~d~_T~sd~_Wd~sd~_T~hrs~d_~Frd~_S~tr~d'.split('_'),
    weekdaysShort: 'S~_~M_~T_~Wd_~Th_~Fr_~St'.split('_'),
    weekdaysMin: 'S~_M~_T_~W_T~h_Fr~_S'.split('_'),
    weekdaysParseExact: true,
    longDateFormat: {
      LT: 'HH:mm',
      L: 'DD/MM/YYYY',
      LL: 'D MMMM YYYY',
      LLL: 'D MMMM YYYY HH:mm',
      LLLL: 'dddd, D MMMM YYYY HH:mm'
    },
    calendar: {
      sameDay: '[T~d~ t] LT',
      nextDay: '[T~m~rr~w t] LT',
      nextWeek: 'dddd [t] LT',
      lastDay: '[~st~rd~ t] LT',
      lastWeek: '[L~st] dddd [t] LT',
      sameElse: 'L'
    },
    relativeTime: {
      future: '~ %s',
      past: '%s ~g',
      s: ' ~fw ~sc~ds',
      ss: '%d s~c~ds',
      m: ' ~m~t',
      mm: '%d m~~ts',
      h: '~ h~r',
      hh: '%d h~rs',
      d: ' ~d',
      dd: '%d d~s',
      M: ' ~m~th',
      MM: '%d m~t~hs',
      y: ' ~r',
      yy: '%d ~rs'
    },
    dayOfMonthOrdinalParse: /\d{1,2}(th|st|nd|rd)/,
    ordinal: function (number) {
      var b = number % 10,
        output = ~~(number % 100 / 10) === 1 ? 'th' : b === 1 ? 'st' : b === 2 ? 'nd' : b === 3 ? 'rd' : 'th';
      return number + output;
    },
    week: {
      dow: 1,
      // Monday is the first day of the week.
      doy: 4 // The week that contains Jan 4th is the first week of the year.
    }
  });
  return xPseudo;
});

/***/ }),
/* 237 */
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Yoruba Nigeria [yo]
//! author : Atolagbe Abisoye : https://github.com/andela-batolagbe

;
(function (global, factory) {
   true ? factory(__webpack_require__(105)) : 0;
})(this, function (moment) {
  'use strict';

  //! moment.js locale configuration
  var yo = moment.defineLocale('yo', {
    months: 'Sr_Erele_rna_Igbe_Ebibi_Okudu_Agmo_Ogun_Owewe_wara_Belu_p'.split('_'),
    monthsShort: 'Sr_Erl_rn_Igb_Ebi_Oku_Ag_Ogu_Owe_wa_Bel_p'.split('_'),
    weekdays: 'Aiku_Aje_Isgun_jru_jb_ti_Abamta'.split('_'),
    weekdaysShort: 'Aik_Aje_Is_jr_jb_ti_Aba'.split('_'),
    weekdaysMin: 'Ai_Aj_Is_r_b_t_Ab'.split('_'),
    longDateFormat: {
      LT: 'h:mm A',
      LTS: 'h:mm:ss A',
      L: 'DD/MM/YYYY',
      LL: 'D MMMM YYYY',
      LLL: 'D MMMM YYYY h:mm A',
      LLLL: 'dddd, D MMMM YYYY h:mm A'
    },
    calendar: {
      sameDay: '[Oni ni] LT',
      nextDay: '[la ni] LT',
      nextWeek: "dddd [s ton'b] [ni] LT",
      lastDay: '[Ana ni] LT',
      lastWeek: 'dddd [s tol] [ni] LT',
      sameElse: 'L'
    },
    relativeTime: {
      future: 'ni %s',
      past: '%s kja',
      s: 'isju aaya die',
      ss: 'aaya %d',
      m: 'isju kan',
      mm: 'isju %d',
      h: 'wakati kan',
      hh: 'wakati %d',
      d: 'j kan',
      dd: 'j %d',
      M: 'osu kan',
      MM: 'osu %d',
      y: 'dun kan',
      yy: 'dun %d'
    },
    dayOfMonthOrdinalParse: /j\s\d{1,2}/,
    ordinal: 'j %d',
    week: {
      dow: 1,
      // Monday is the first day of the week.
      doy: 4 // The week that contains Jan 4th is the first week of the year.
    }
  });
  return yo;
});

/***/ }),
/* 238 */
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Chinese (China) [zh-cn]
//! author : suupic : https://github.com/suupic
//! author : Zeno Zeng : https://github.com/zenozeng
//! author : uu109 : https://github.com/uu109

;
(function (global, factory) {
   true ? factory(__webpack_require__(105)) : 0;
})(this, function (moment) {
  'use strict';

  //! moment.js locale configuration
  var zhCn = moment.defineLocale('zh-cn', {
    months: '___________'.split('_'),
    monthsShort: '1_2_3_4_5_6_7_8_9_10_11_12'.split('_'),
    weekdays: '______'.split('_'),
    weekdaysShort: '______'.split('_'),
    weekdaysMin: '______'.split('_'),
    longDateFormat: {
      LT: 'HH:mm',
      LTS: 'HH:mm:ss',
      L: 'YYYY/MM/DD',
      LL: 'YYYYMD',
      LLL: 'YYYYMDAhmm',
      LLLL: 'YYYYMDddddAhmm',
      l: 'YYYY/M/D',
      ll: 'YYYYMD',
      lll: 'YYYYMD HH:mm',
      llll: 'YYYYMDdddd HH:mm'
    },
    meridiemParse: /|||||/,
    meridiemHour: function (hour, meridiem) {
      if (hour === 12) {
        hour = 0;
      }
      if (meridiem === '' || meridiem === '' || meridiem === '') {
        return hour;
      } else if (meridiem === '' || meridiem === '') {
        return hour + 12;
      } else {
        // ''
        return hour >= 11 ? hour : hour + 12;
      }
    },
    meridiem: function (hour, minute, isLower) {
      var hm = hour * 100 + minute;
      if (hm < 600) {
        return '';
      } else if (hm < 900) {
        return '';
      } else if (hm < 1130) {
        return '';
      } else if (hm < 1230) {
        return '';
      } else if (hm < 1800) {
        return '';
      } else {
        return '';
      }
    },
    calendar: {
      sameDay: '[]LT',
      nextDay: '[]LT',
      nextWeek: function (now) {
        if (now.week() !== this.week()) {
          return '[]dddLT';
        } else {
          return '[]dddLT';
        }
      },
      lastDay: '[]LT',
      lastWeek: function (now) {
        if (this.week() !== now.week()) {
          return '[]dddLT';
        } else {
          return '[]dddLT';
        }
      },
      sameElse: 'L'
    },
    dayOfMonthOrdinalParse: /\d{1,2}(||)/,
    ordinal: function (number, period) {
      switch (period) {
        case 'd':
        case 'D':
        case 'DDD':
          return number + '';
        case 'M':
          return number + '';
        case 'w':
        case 'W':
          return number + '';
        default:
          return number;
      }
    },
    relativeTime: {
      future: '%s',
      past: '%s',
      s: '',
      ss: '%d ',
      m: '1 ',
      mm: '%d ',
      h: '1 ',
      hh: '%d ',
      d: '1 ',
      dd: '%d ',
      w: '1 ',
      ww: '%d ',
      M: '1 ',
      MM: '%d ',
      y: '1 ',
      yy: '%d '
    },
    week: {
      // GB/T 7408-1994ISO 8601:1988
      dow: 1,
      // Monday is the first day of the week.
      doy: 4 // The week that contains Jan 4th is the first week of the year.
    }
  });
  return zhCn;
});

/***/ }),
/* 239 */
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Chinese (Hong Kong) [zh-hk]
//! author : Ben : https://github.com/ben-lin
//! author : Chris Lam : https://github.com/hehachris
//! author : Konstantin : https://github.com/skfd
//! author : Anthony : https://github.com/anthonylau

;
(function (global, factory) {
   true ? factory(__webpack_require__(105)) : 0;
})(this, function (moment) {
  'use strict';

  //! moment.js locale configuration
  var zhHk = moment.defineLocale('zh-hk', {
    months: '___________'.split('_'),
    monthsShort: '1_2_3_4_5_6_7_8_9_10_11_12'.split('_'),
    weekdays: '______'.split('_'),
    weekdaysShort: '______'.split('_'),
    weekdaysMin: '______'.split('_'),
    longDateFormat: {
      LT: 'HH:mm',
      LTS: 'HH:mm:ss',
      L: 'YYYY/MM/DD',
      LL: 'YYYYMD',
      LLL: 'YYYYMD HH:mm',
      LLLL: 'YYYYMDdddd HH:mm',
      l: 'YYYY/M/D',
      ll: 'YYYYMD',
      lll: 'YYYYMD HH:mm',
      llll: 'YYYYMDdddd HH:mm'
    },
    meridiemParse: /|||||/,
    meridiemHour: function (hour, meridiem) {
      if (hour === 12) {
        hour = 0;
      }
      if (meridiem === '' || meridiem === '' || meridiem === '') {
        return hour;
      } else if (meridiem === '') {
        return hour >= 11 ? hour : hour + 12;
      } else if (meridiem === '' || meridiem === '') {
        return hour + 12;
      }
    },
    meridiem: function (hour, minute, isLower) {
      var hm = hour * 100 + minute;
      if (hm < 600) {
        return '';
      } else if (hm < 900) {
        return '';
      } else if (hm < 1200) {
        return '';
      } else if (hm === 1200) {
        return '';
      } else if (hm < 1800) {
        return '';
      } else {
        return '';
      }
    },
    calendar: {
      sameDay: '[]LT',
      nextDay: '[]LT',
      nextWeek: '[]ddddLT',
      lastDay: '[]LT',
      lastWeek: '[]ddddLT',
      sameElse: 'L'
    },
    dayOfMonthOrdinalParse: /\d{1,2}(||)/,
    ordinal: function (number, period) {
      switch (period) {
        case 'd':
        case 'D':
        case 'DDD':
          return number + '';
        case 'M':
          return number + '';
        case 'w':
        case 'W':
          return number + '';
        default:
          return number;
      }
    },
    relativeTime: {
      future: '%s',
      past: '%s',
      s: '',
      ss: '%d ',
      m: '1 ',
      mm: '%d ',
      h: '1 ',
      hh: '%d ',
      d: '1 ',
      dd: '%d ',
      M: '1 ',
      MM: '%d ',
      y: '1 ',
      yy: '%d '
    }
  });
  return zhHk;
});

/***/ }),
/* 240 */
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Chinese (Macau) [zh-mo]
//! author : Ben : https://github.com/ben-lin
//! author : Chris Lam : https://github.com/hehachris
//! author : Tan Yuanhong : https://github.com/le0tan

;
(function (global, factory) {
   true ? factory(__webpack_require__(105)) : 0;
})(this, function (moment) {
  'use strict';

  //! moment.js locale configuration
  var zhMo = moment.defineLocale('zh-mo', {
    months: '___________'.split('_'),
    monthsShort: '1_2_3_4_5_6_7_8_9_10_11_12'.split('_'),
    weekdays: '______'.split('_'),
    weekdaysShort: '______'.split('_'),
    weekdaysMin: '______'.split('_'),
    longDateFormat: {
      LT: 'HH:mm',
      LTS: 'HH:mm:ss',
      L: 'DD/MM/YYYY',
      LL: 'YYYYMD',
      LLL: 'YYYYMD HH:mm',
      LLLL: 'YYYYMDdddd HH:mm',
      l: 'D/M/YYYY',
      ll: 'YYYYMD',
      lll: 'YYYYMD HH:mm',
      llll: 'YYYYMDdddd HH:mm'
    },
    meridiemParse: /|||||/,
    meridiemHour: function (hour, meridiem) {
      if (hour === 12) {
        hour = 0;
      }
      if (meridiem === '' || meridiem === '' || meridiem === '') {
        return hour;
      } else if (meridiem === '') {
        return hour >= 11 ? hour : hour + 12;
      } else if (meridiem === '' || meridiem === '') {
        return hour + 12;
      }
    },
    meridiem: function (hour, minute, isLower) {
      var hm = hour * 100 + minute;
      if (hm < 600) {
        return '';
      } else if (hm < 900) {
        return '';
      } else if (hm < 1130) {
        return '';
      } else if (hm < 1230) {
        return '';
      } else if (hm < 1800) {
        return '';
      } else {
        return '';
      }
    },
    calendar: {
      sameDay: '[] LT',
      nextDay: '[] LT',
      nextWeek: '[]dddd LT',
      lastDay: '[] LT',
      lastWeek: '[]dddd LT',
      sameElse: 'L'
    },
    dayOfMonthOrdinalParse: /\d{1,2}(||)/,
    ordinal: function (number, period) {
      switch (period) {
        case 'd':
        case 'D':
        case 'DDD':
          return number + '';
        case 'M':
          return number + '';
        case 'w':
        case 'W':
          return number + '';
        default:
          return number;
      }
    },
    relativeTime: {
      future: '%s',
      past: '%s',
      s: '',
      ss: '%d ',
      m: '1 ',
      mm: '%d ',
      h: '1 ',
      hh: '%d ',
      d: '1 ',
      dd: '%d ',
      M: '1 ',
      MM: '%d ',
      y: '1 ',
      yy: '%d '
    }
  });
  return zhMo;
});

/***/ }),
/* 241 */
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Chinese (Taiwan) [zh-tw]
//! author : Ben : https://github.com/ben-lin
//! author : Chris Lam : https://github.com/hehachris

;
(function (global, factory) {
   true ? factory(__webpack_require__(105)) : 0;
})(this, function (moment) {
  'use strict';

  //! moment.js locale configuration
  var zhTw = moment.defineLocale('zh-tw', {
    months: '___________'.split('_'),
    monthsShort: '1_2_3_4_5_6_7_8_9_10_11_12'.split('_'),
    weekdays: '______'.split('_'),
    weekdaysShort: '______'.split('_'),
    weekdaysMin: '______'.split('_'),
    longDateFormat: {
      LT: 'HH:mm',
      LTS: 'HH:mm:ss',
      L: 'YYYY/MM/DD',
      LL: 'YYYYMD',
      LLL: 'YYYYMD HH:mm',
      LLLL: 'YYYYMDdddd HH:mm',
      l: 'YYYY/M/D',
      ll: 'YYYYMD',
      lll: 'YYYYMD HH:mm',
      llll: 'YYYYMDdddd HH:mm'
    },
    meridiemParse: /|||||/,
    meridiemHour: function (hour, meridiem) {
      if (hour === 12) {
        hour = 0;
      }
      if (meridiem === '' || meridiem === '' || meridiem === '') {
        return hour;
      } else if (meridiem === '') {
        return hour >= 11 ? hour : hour + 12;
      } else if (meridiem === '' || meridiem === '') {
        return hour + 12;
      }
    },
    meridiem: function (hour, minute, isLower) {
      var hm = hour * 100 + minute;
      if (hm < 600) {
        return '';
      } else if (hm < 900) {
        return '';
      } else if (hm < 1130) {
        return '';
      } else if (hm < 1230) {
        return '';
      } else if (hm < 1800) {
        return '';
      } else {
        return '';
      }
    },
    calendar: {
      sameDay: '[] LT',
      nextDay: '[] LT',
      nextWeek: '[]dddd LT',
      lastDay: '[] LT',
      lastWeek: '[]dddd LT',
      sameElse: 'L'
    },
    dayOfMonthOrdinalParse: /\d{1,2}(||)/,
    ordinal: function (number, period) {
      switch (period) {
        case 'd':
        case 'D':
        case 'DDD':
          return number + '';
        case 'M':
          return number + '';
        case 'w':
        case 'W':
          return number + '';
        default:
          return number;
      }
    },
    relativeTime: {
      future: '%s',
      past: '%s',
      s: '',
      ss: '%d ',
      m: '1 ',
      mm: '%d ',
      h: '1 ',
      hh: '%d ',
      d: '1 ',
      dd: '%d ',
      M: '1 ',
      MM: '%d ',
      y: '1 ',
      yy: '%d '
    }
  });
  return zhTw;
});

/***/ }),
/* 242 */
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   copyStrict: function() { return /* binding */ copyStrict; },
/* harmony export */   createCopier: function() { return /* binding */ createCopier; },
/* harmony export */   createStrictCopier: function() { return /* binding */ createStrictCopier; },
/* harmony export */   "default": function() { return /* binding */ index; }
/* harmony export */ });
var toStringFunction = Function.prototype.toString;
var create = Object.create;
var toStringObject = Object.prototype.toString;
/**
 * @classdesc Fallback cache for when WeakMap is not natively supported
 */
var LegacyCache = /** @class */function () {
  function LegacyCache() {
    this._keys = [];
    this._values = [];
  }
  LegacyCache.prototype.has = function (key) {
    return !!~this._keys.indexOf(key);
  };
  LegacyCache.prototype.get = function (key) {
    return this._values[this._keys.indexOf(key)];
  };
  LegacyCache.prototype.set = function (key, value) {
    this._keys.push(key);
    this._values.push(value);
  };
  return LegacyCache;
}();
function createCacheLegacy() {
  return new LegacyCache();
}
function createCacheModern() {
  return new WeakMap();
}
/**
 * Get a new cache object to prevent circular references.
 */
var createCache = typeof WeakMap !== 'undefined' ? createCacheModern : createCacheLegacy;
/**
 * Get an empty version of the object with the same prototype it has.
 */
function getCleanClone(prototype) {
  if (!prototype) {
    return create(null);
  }
  var Constructor = prototype.constructor;
  if (Constructor === Object) {
    return prototype === Object.prototype ? {} : create(prototype);
  }
  if (Constructor && ~toStringFunction.call(Constructor).indexOf('[native code]')) {
    try {
      return new Constructor();
    } catch (_a) {}
  }
  return create(prototype);
}
function getRegExpFlagsLegacy(regExp) {
  var flags = '';
  if (regExp.global) {
    flags += 'g';
  }
  if (regExp.ignoreCase) {
    flags += 'i';
  }
  if (regExp.multiline) {
    flags += 'm';
  }
  if (regExp.unicode) {
    flags += 'u';
  }
  if (regExp.sticky) {
    flags += 'y';
  }
  return flags;
}
function getRegExpFlagsModern(regExp) {
  return regExp.flags;
}
/**
 * Get the flags to apply to the copied regexp.
 */
var getRegExpFlags = /test/g.flags === 'g' ? getRegExpFlagsModern : getRegExpFlagsLegacy;
function getTagLegacy(value) {
  var type = toStringObject.call(value);
  return type.substring(8, type.length - 1);
}
function getTagModern(value) {
  return value[Symbol.toStringTag] || getTagLegacy(value);
}
/**
 * Get the tag of the value passed, so that the correct copier can be used.
 */
var getTag = typeof Symbol !== 'undefined' ? getTagModern : getTagLegacy;
var defineProperty = Object.defineProperty,
  getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor,
  getOwnPropertyNames = Object.getOwnPropertyNames,
  getOwnPropertySymbols = Object.getOwnPropertySymbols;
var _a = Object.prototype,
  hasOwnProperty = _a.hasOwnProperty,
  propertyIsEnumerable = _a.propertyIsEnumerable;
var SUPPORTS_SYMBOL = typeof getOwnPropertySymbols === 'function';
function getStrictPropertiesModern(object) {
  return getOwnPropertyNames(object).concat(getOwnPropertySymbols(object));
}
/**
 * Get the properites used when copying objects strictly. This includes both keys and symbols.
 */
var getStrictProperties = SUPPORTS_SYMBOL ? getStrictPropertiesModern : getOwnPropertyNames;
/**
 * Striclty copy all properties contained on the object.
 */
function copyOwnPropertiesStrict(value, clone, state) {
  var properties = getStrictProperties(value);
  for (var index = 0, length_1 = properties.length, property = void 0, descriptor = void 0; index < length_1; ++index) {
    property = properties[index];
    if (property === 'callee' || property === 'caller') {
      continue;
    }
    descriptor = getOwnPropertyDescriptor(value, property);
    if (!descriptor) {
      // In extra edge cases where the property descriptor cannot be retrived, fall back to
      // the loose assignment.
      clone[property] = state.copier(value[property], state);
      continue;
    }
    // Only clone the value if actually a value, not a getter / setter.
    if (!descriptor.get && !descriptor.set) {
      descriptor.value = state.copier(descriptor.value, state);
    }
    try {
      defineProperty(clone, property, descriptor);
    } catch (error) {
      // Tee above can fail on node in edge cases, so fall back to the loose assignment.
      clone[property] = descriptor.value;
    }
  }
  return clone;
}
/**
 * Deeply copy the indexed values in the array.
 */
function copyArrayLoose(array, state) {
  var clone = new state.Constructor();
  // set in the cache immediately to be able to reuse the object recursively
  state.cache.set(array, clone);
  for (var index = 0, length_2 = array.length; index < length_2; ++index) {
    clone[index] = state.copier(array[index], state);
  }
  return clone;
}
/**
 * Deeply copy the indexed values in the array, as well as any custom properties.
 */
function copyArrayStrict(array, state) {
  var clone = new state.Constructor();
  // set in the cache immediately to be able to reuse the object recursively
  state.cache.set(array, clone);
  return copyOwnPropertiesStrict(array, clone, state);
}
/**
 * Copy the contents of the ArrayBuffer.
 */
function copyArrayBuffer(arrayBuffer, _state) {
  return arrayBuffer.slice(0);
}
/**
 * Create a new Blob with the contents of the original.
 */
function copyBlob(blob, _state) {
  return blob.slice(0, blob.size, blob.type);
}
/**
 * Create a new DataView with the contents of the original.
 */
function copyDataView(dataView, state) {
  return new state.Constructor(copyArrayBuffer(dataView.buffer));
}
/**
 * Create a new Date based on the time of the original.
 */
function copyDate(date, state) {
  return new state.Constructor(date.getTime());
}
/**
 * Deeply copy the keys and values of the original.
 */
function copyMapLoose(map, state) {
  var clone = new state.Constructor();
  // set in the cache immediately to be able to reuse the object recursively
  state.cache.set(map, clone);
  map.forEach(function (value, key) {
    clone.set(key, state.copier(value, state));
  });
  return clone;
}
/**
 * Deeply copy the keys and values of the original, as well as any custom properties.
 */
function copyMapStrict(map, state) {
  return copyOwnPropertiesStrict(map, copyMapLoose(map, state), state);
}
function copyObjectLooseLegacy(object, state) {
  var clone = getCleanClone(state.prototype);
  // set in the cache immediately to be able to reuse the object recursively
  state.cache.set(object, clone);
  for (var key in object) {
    if (hasOwnProperty.call(object, key)) {
      clone[key] = state.copier(object[key], state);
    }
  }
  return clone;
}
function copyObjectLooseModern(object, state) {
  var clone = getCleanClone(state.prototype);
  // set in the cache immediately to be able to reuse the object recursively
  state.cache.set(object, clone);
  for (var key in object) {
    if (hasOwnProperty.call(object, key)) {
      clone[key] = state.copier(object[key], state);
    }
  }
  var symbols = getOwnPropertySymbols(object);
  for (var index = 0, length_3 = symbols.length, symbol = void 0; index < length_3; ++index) {
    symbol = symbols[index];
    if (propertyIsEnumerable.call(object, symbol)) {
      clone[symbol] = state.copier(object[symbol], state);
    }
  }
  return clone;
}
/**
 * Deeply copy the properties (keys and symbols) and values of the original.
 */
var copyObjectLoose = SUPPORTS_SYMBOL ? copyObjectLooseModern : copyObjectLooseLegacy;
/**
 * Deeply copy the properties (keys and symbols) and values of the original, as well
 * as any hidden or non-enumerable properties.
 */
function copyObjectStrict(object, state) {
  var clone = getCleanClone(state.prototype);
  // set in the cache immediately to be able to reuse the object recursively
  state.cache.set(object, clone);
  return copyOwnPropertiesStrict(object, clone, state);
}
/**
 * Create a new primitive wrapper from the value of the original.
 */
function copyPrimitiveWrapper(primitiveObject, state) {
  return new state.Constructor(primitiveObject.valueOf());
}
/**
 * Create a new RegExp based on the value and flags of the original.
 */
function copyRegExp(regExp, state) {
  var clone = new state.Constructor(regExp.source, getRegExpFlags(regExp));
  clone.lastIndex = regExp.lastIndex;
  return clone;
}
/**
 * Return the original value (an identity function).
 *
 * @note
 * THis is used for objects that cannot be copied, such as WeakMap.
 */
function copySelf(value, _state) {
  return value;
}
/**
 * Deeply copy the values of the original.
 */
function copySetLoose(set, state) {
  var clone = new state.Constructor();
  // set in the cache immediately to be able to reuse the object recursively
  state.cache.set(set, clone);
  set.forEach(function (value) {
    clone.add(state.copier(value, state));
  });
  return clone;
}
/**
 * Deeply copy the values of the original, as well as any custom properties.
 */
function copySetStrict(set, state) {
  return copyOwnPropertiesStrict(set, copySetLoose(set, state), state);
}
var isArray = Array.isArray;
var assign = Object.assign;
var getPrototypeOf = Object.getPrototypeOf || function (obj) {
  return obj.__proto__;
};
var DEFAULT_LOOSE_OPTIONS = {
  array: copyArrayLoose,
  arrayBuffer: copyArrayBuffer,
  blob: copyBlob,
  dataView: copyDataView,
  date: copyDate,
  error: copySelf,
  map: copyMapLoose,
  object: copyObjectLoose,
  regExp: copyRegExp,
  set: copySetLoose
};
var DEFAULT_STRICT_OPTIONS = assign({}, DEFAULT_LOOSE_OPTIONS, {
  array: copyArrayStrict,
  map: copyMapStrict,
  object: copyObjectStrict,
  set: copySetStrict
});
/**
 * Get the copiers used for each specific object tag.
 */
function getTagSpecificCopiers(options) {
  return {
    Arguments: options.object,
    Array: options.array,
    ArrayBuffer: options.arrayBuffer,
    Blob: options.blob,
    Boolean: copyPrimitiveWrapper,
    DataView: options.dataView,
    Date: options.date,
    Error: options.error,
    Float32Array: options.arrayBuffer,
    Float64Array: options.arrayBuffer,
    Int8Array: options.arrayBuffer,
    Int16Array: options.arrayBuffer,
    Int32Array: options.arrayBuffer,
    Map: options.map,
    Number: copyPrimitiveWrapper,
    Object: options.object,
    Promise: copySelf,
    RegExp: options.regExp,
    Set: options.set,
    String: copyPrimitiveWrapper,
    WeakMap: copySelf,
    WeakSet: copySelf,
    Uint8Array: options.arrayBuffer,
    Uint8ClampedArray: options.arrayBuffer,
    Uint16Array: options.arrayBuffer,
    Uint32Array: options.arrayBuffer,
    Uint64Array: options.arrayBuffer
  };
}
/**
 * Create a custom copier based on the object-specific copy methods passed.
 */
function createCopier(options) {
  var normalizedOptions = assign({}, DEFAULT_LOOSE_OPTIONS, options);
  var tagSpecificCopiers = getTagSpecificCopiers(normalizedOptions);
  var array = tagSpecificCopiers.Array,
    object = tagSpecificCopiers.Object;
  function copier(value, state) {
    state.prototype = state.Constructor = undefined;
    if (!value || typeof value !== 'object') {
      return value;
    }
    if (state.cache.has(value)) {
      return state.cache.get(value);
    }
    state.prototype = getPrototypeOf(value);
    state.Constructor = state.prototype && state.prototype.constructor;
    // plain objects
    if (!state.Constructor || state.Constructor === Object) {
      return object(value, state);
    }
    // arrays
    if (isArray(value)) {
      return array(value, state);
    }
    var tagSpecificCopier = tagSpecificCopiers[getTag(value)];
    if (tagSpecificCopier) {
      return tagSpecificCopier(value, state);
    }
    return typeof value.then === 'function' ? value : object(value, state);
  }
  return function copy(value) {
    return copier(value, {
      Constructor: undefined,
      cache: createCache(),
      copier: copier,
      prototype: undefined
    });
  };
}
/**
 * Create a custom copier based on the object-specific copy methods passed, defaulting to the
 * same internals as `copyStrict`.
 */
function createStrictCopier(options) {
  return createCopier(assign({}, DEFAULT_STRICT_OPTIONS, options));
}
/**
 * Copy an value deeply as much as possible, where strict recreation of object properties
 * are maintained. All properties (including non-enumerable ones) are copied with their
 * original property descriptors on both objects and arrays.
 */
var copyStrict = createStrictCopier({});
/**
 * Copy an value deeply as much as possible.
 */
var index = createCopier({});


/***/ }),
/* 243 */
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var assign = __webpack_require__(244);
var callBound = __webpack_require__(288);
var flags = __webpack_require__(291);
var GetIntrinsic = __webpack_require__(259);
var getIterator = __webpack_require__(297);
var getSideChannel = __webpack_require__(302);
var is = __webpack_require__(313);
var isArguments = __webpack_require__(298);
var isArray = __webpack_require__(309);
var isArrayBuffer = __webpack_require__(317);
var isDate = __webpack_require__(318);
var isRegex = __webpack_require__(319);
var isSharedArrayBuffer = __webpack_require__(320);
var objectKeys = __webpack_require__(246);
var whichBoxedPrimitive = __webpack_require__(321);
var whichCollection = __webpack_require__(327);
var whichTypedArray = __webpack_require__(330);
var byteLength = __webpack_require__(335);
var sabByteLength = callBound('SharedArrayBuffer.prototype.byteLength', true);
var $getTime = callBound('Date.prototype.getTime');
var gPO = Object.getPrototypeOf;
var $objToString = callBound('Object.prototype.toString');
var $Set = GetIntrinsic('%Set%', true);
var $mapHas = callBound('Map.prototype.has', true);
var $mapGet = callBound('Map.prototype.get', true);
var $mapSize = callBound('Map.prototype.size', true);
var $setAdd = callBound('Set.prototype.add', true);
var $setDelete = callBound('Set.prototype.delete', true);
var $setHas = callBound('Set.prototype.has', true);
var $setSize = callBound('Set.prototype.size', true);

// taken from https://github.com/browserify/commonjs-assert/blob/bba838e9ba9e28edf3127ce6974624208502f6bc/internal/util/comparisons.js#L401-L414
function setHasEqualElement(set, val1, opts, channel) {
  var i = getIterator(set);
  var result;
  while ((result = i.next()) && !result.done) {
    if (internalDeepEqual(val1, result.value, opts, channel)) {
      // eslint-disable-line no-use-before-define
      // Remove the matching element to make sure we do not check that again.
      $setDelete(set, result.value);
      return true;
    }
  }
  return false;
}

// taken from https://github.com/browserify/commonjs-assert/blob/bba838e9ba9e28edf3127ce6974624208502f6bc/internal/util/comparisons.js#L416-L439
function findLooseMatchingPrimitives(prim) {
  if (typeof prim === 'undefined') {
    return null;
  }
  if (typeof prim === 'object') {
    // Only pass in null as object!
    return void 0;
  }
  if (typeof prim === 'symbol') {
    return false;
  }
  if (typeof prim === 'string' || typeof prim === 'number') {
    // Loose equal entries exist only if the string is possible to convert to a regular number and not NaN.
    return +prim === +prim; // eslint-disable-line no-implicit-coercion
  }
  return true;
}

// taken from https://github.com/browserify/commonjs-assert/blob/bba838e9ba9e28edf3127ce6974624208502f6bc/internal/util/comparisons.js#L449-L460
function mapMightHaveLoosePrim(a, b, prim, item, opts, channel) {
  var altValue = findLooseMatchingPrimitives(prim);
  if (altValue != null) {
    return altValue;
  }
  var curB = $mapGet(b, altValue);
  var looseOpts = assign({}, opts, {
    strict: false
  });
  if (typeof curB === 'undefined' && !$mapHas(b, altValue)
  // eslint-disable-next-line no-use-before-define
  || !internalDeepEqual(item, curB, looseOpts, channel)) {
    return false;
  }
  // eslint-disable-next-line no-use-before-define
  return !$mapHas(a, altValue) && internalDeepEqual(item, curB, looseOpts, channel);
}

// taken from https://github.com/browserify/commonjs-assert/blob/bba838e9ba9e28edf3127ce6974624208502f6bc/internal/util/comparisons.js#L441-L447
function setMightHaveLoosePrim(a, b, prim) {
  var altValue = findLooseMatchingPrimitives(prim);
  if (altValue != null) {
    return altValue;
  }
  return $setHas(b, altValue) && !$setHas(a, altValue);
}

// taken from https://github.com/browserify/commonjs-assert/blob/bba838e9ba9e28edf3127ce6974624208502f6bc/internal/util/comparisons.js#L518-L533
function mapHasEqualEntry(set, map, key1, item1, opts, channel) {
  var i = getIterator(set);
  var result;
  var key2;
  while ((result = i.next()) && !result.done) {
    key2 = result.value;
    if (
    // eslint-disable-next-line no-use-before-define
    internalDeepEqual(key1, key2, opts, channel)
    // eslint-disable-next-line no-use-before-define
    && internalDeepEqual(item1, $mapGet(map, key2), opts, channel)) {
      $setDelete(set, key2);
      return true;
    }
  }
  return false;
}
function internalDeepEqual(actual, expected, options, channel) {
  var opts = options || {};

  // 7.1. All identical values are equivalent, as determined by ===.
  if (opts.strict ? is(actual, expected) : actual === expected) {
    return true;
  }
  var actualBoxed = whichBoxedPrimitive(actual);
  var expectedBoxed = whichBoxedPrimitive(expected);
  if (actualBoxed !== expectedBoxed) {
    return false;
  }

  // 7.3. Other pairs that do not both pass typeof value == 'object', equivalence is determined by ==.
  if (!actual || !expected || typeof actual !== 'object' && typeof expected !== 'object') {
    return opts.strict ? is(actual, expected) : actual == expected; // eslint-disable-line eqeqeq
  }

  /*
   * 7.4. For all other Object pairs, including Array objects, equivalence is
   * determined by having the same number of owned properties (as verified
   * with Object.prototype.hasOwnProperty.call), the same set of keys
   * (although not necessarily the same order), equivalent values for every
   * corresponding key, and an identical 'prototype' property. Note: this
   * accounts for both named and indexed properties on Arrays.
   */
  // see https://github.com/nodejs/node/commit/d3aafd02efd3a403d646a3044adcf14e63a88d32 for memos/channel inspiration

  var hasActual = channel.has(actual);
  var hasExpected = channel.has(expected);
  var sentinel;
  if (hasActual && hasExpected) {
    if (channel.get(actual) === channel.get(expected)) {
      return true;
    }
  } else {
    sentinel = {};
  }
  if (!hasActual) {
    channel.set(actual, sentinel);
  }
  if (!hasExpected) {
    channel.set(expected, sentinel);
  }

  // eslint-disable-next-line no-use-before-define
  return objEquiv(actual, expected, opts, channel);
}
function isBuffer(x) {
  if (!x || typeof x !== 'object' || typeof x.length !== 'number') {
    return false;
  }
  if (typeof x.copy !== 'function' || typeof x.slice !== 'function') {
    return false;
  }
  if (x.length > 0 && typeof x[0] !== 'number') {
    return false;
  }
  return !!(x.constructor && x.constructor.isBuffer && x.constructor.isBuffer(x));
}
function setEquiv(a, b, opts, channel) {
  if ($setSize(a) !== $setSize(b)) {
    return false;
  }
  var iA = getIterator(a);
  var iB = getIterator(b);
  var resultA;
  var resultB;
  var set;
  while ((resultA = iA.next()) && !resultA.done) {
    if (resultA.value && typeof resultA.value === 'object') {
      if (!set) {
        set = new $Set();
      }
      $setAdd(set, resultA.value);
    } else if (!$setHas(b, resultA.value)) {
      if (opts.strict) {
        return false;
      }
      if (!setMightHaveLoosePrim(a, b, resultA.value)) {
        return false;
      }
      if (!set) {
        set = new $Set();
      }
      $setAdd(set, resultA.value);
    }
  }
  if (set) {
    while ((resultB = iB.next()) && !resultB.done) {
      // We have to check if a primitive value is already matching and only if it's not, go hunting for it.
      if (resultB.value && typeof resultB.value === 'object') {
        if (!setHasEqualElement(set, resultB.value, opts.strict, channel)) {
          return false;
        }
      } else if (!opts.strict && !$setHas(a, resultB.value) && !setHasEqualElement(set, resultB.value, opts.strict, channel)) {
        return false;
      }
    }
    return $setSize(set) === 0;
  }
  return true;
}
function mapEquiv(a, b, opts, channel) {
  if ($mapSize(a) !== $mapSize(b)) {
    return false;
  }
  var iA = getIterator(a);
  var iB = getIterator(b);
  var resultA;
  var resultB;
  var set;
  var key;
  var item1;
  var item2;
  while ((resultA = iA.next()) && !resultA.done) {
    key = resultA.value[0];
    item1 = resultA.value[1];
    if (key && typeof key === 'object') {
      if (!set) {
        set = new $Set();
      }
      $setAdd(set, key);
    } else {
      item2 = $mapGet(b, key);
      if (typeof item2 === 'undefined' && !$mapHas(b, key) || !internalDeepEqual(item1, item2, opts, channel)) {
        if (opts.strict) {
          return false;
        }
        if (!mapMightHaveLoosePrim(a, b, key, item1, opts, channel)) {
          return false;
        }
        if (!set) {
          set = new $Set();
        }
        $setAdd(set, key);
      }
    }
  }
  if (set) {
    while ((resultB = iB.next()) && !resultB.done) {
      key = resultB.value[0];
      item2 = resultB.value[1];
      if (key && typeof key === 'object') {
        if (!mapHasEqualEntry(set, a, key, item2, opts, channel)) {
          return false;
        }
      } else if (!opts.strict && (!a.has(key) || !internalDeepEqual($mapGet(a, key), item2, opts, channel)) && !mapHasEqualEntry(set, a, key, item2, assign({}, opts, {
        strict: false
      }), channel)) {
        return false;
      }
    }
    return $setSize(set) === 0;
  }
  return true;
}
function objEquiv(a, b, opts, channel) {
  /* eslint max-statements: [2, 100], max-lines-per-function: [2, 120], max-depth: [2, 5], max-lines: [2, 400] */
  var i, key;
  if (typeof a !== typeof b) {
    return false;
  }
  if (a == null || b == null) {
    return false;
  }
  if ($objToString(a) !== $objToString(b)) {
    return false;
  }
  if (isArguments(a) !== isArguments(b)) {
    return false;
  }
  var aIsArray = isArray(a);
  var bIsArray = isArray(b);
  if (aIsArray !== bIsArray) {
    return false;
  }

  // TODO: replace when a cross-realm brand check is available
  var aIsError = a instanceof Error;
  var bIsError = b instanceof Error;
  if (aIsError !== bIsError) {
    return false;
  }
  if (aIsError || bIsError) {
    if (a.name !== b.name || a.message !== b.message) {
      return false;
    }
  }
  var aIsRegex = isRegex(a);
  var bIsRegex = isRegex(b);
  if (aIsRegex !== bIsRegex) {
    return false;
  }
  if ((aIsRegex || bIsRegex) && (a.source !== b.source || flags(a) !== flags(b))) {
    return false;
  }
  var aIsDate = isDate(a);
  var bIsDate = isDate(b);
  if (aIsDate !== bIsDate) {
    return false;
  }
  if (aIsDate || bIsDate) {
    // && would work too, because both are true or both false here
    if ($getTime(a) !== $getTime(b)) {
      return false;
    }
  }
  if (opts.strict && gPO && gPO(a) !== gPO(b)) {
    return false;
  }
  var aWhich = whichTypedArray(a);
  var bWhich = whichTypedArray(b);
  if (aWhich !== bWhich) {
    return false;
  }
  if (aWhich || bWhich) {
    // && would work too, because both are true or both false here
    if (a.length !== b.length) {
      return false;
    }
    for (i = 0; i < a.length; i++) {
      if (a[i] !== b[i]) {
        return false;
      }
    }
    return true;
  }
  var aIsBuffer = isBuffer(a);
  var bIsBuffer = isBuffer(b);
  if (aIsBuffer !== bIsBuffer) {
    return false;
  }
  if (aIsBuffer || bIsBuffer) {
    // && would work too, because both are true or both false here
    if (a.length !== b.length) {
      return false;
    }
    for (i = 0; i < a.length; i++) {
      if (a[i] !== b[i]) {
        return false;
      }
    }
    return true;
  }
  var aIsArrayBuffer = isArrayBuffer(a);
  var bIsArrayBuffer = isArrayBuffer(b);
  if (aIsArrayBuffer !== bIsArrayBuffer) {
    return false;
  }
  if (aIsArrayBuffer || bIsArrayBuffer) {
    // && would work too, because both are true or both false here
    if (byteLength(a) !== byteLength(b)) {
      return false;
    }
    return typeof Uint8Array === 'function' && internalDeepEqual(new Uint8Array(a), new Uint8Array(b), opts, channel);
  }
  var aIsSAB = isSharedArrayBuffer(a);
  var bIsSAB = isSharedArrayBuffer(b);
  if (aIsSAB !== bIsSAB) {
    return false;
  }
  if (aIsSAB || bIsSAB) {
    // && would work too, because both are true or both false here
    if (sabByteLength(a) !== sabByteLength(b)) {
      return false;
    }
    return typeof Uint8Array === 'function' && internalDeepEqual(new Uint8Array(a), new Uint8Array(b), opts, channel);
  }
  if (typeof a !== typeof b) {
    return false;
  }
  var ka = objectKeys(a);
  var kb = objectKeys(b);
  // having the same number of owned properties (keys incorporates hasOwnProperty)
  if (ka.length !== kb.length) {
    return false;
  }

  // the same set of keys (although not necessarily the same order),
  ka.sort();
  kb.sort();
  // ~~~cheap key test
  for (i = ka.length - 1; i >= 0; i--) {
    if (ka[i] != kb[i]) {
      return false;
    } // eslint-disable-line eqeqeq
  }

  // equivalent values for every corresponding key, and ~~~possibly expensive deep test
  for (i = ka.length - 1; i >= 0; i--) {
    key = ka[i];
    if (!internalDeepEqual(a[key], b[key], opts, channel)) {
      return false;
    }
  }
  var aCollection = whichCollection(a);
  var bCollection = whichCollection(b);
  if (aCollection !== bCollection) {
    return false;
  }
  if (aCollection === 'Set' || bCollection === 'Set') {
    // aCollection === bCollection
    return setEquiv(a, b, opts, channel);
  }
  if (aCollection === 'Map') {
    // aCollection === bCollection
    return mapEquiv(a, b, opts, channel);
  }
  return true;
}
module.exports = function deepEqual(a, b, opts) {
  return internalDeepEqual(a, b, opts, getSideChannel());
};

/***/ }),
/* 244 */
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var defineProperties = __webpack_require__(245);
var callBind = __webpack_require__(256);
var implementation = __webpack_require__(287);
var getPolyfill = __webpack_require__(289);
var shim = __webpack_require__(290);
var polyfill = callBind.apply(getPolyfill());
// eslint-disable-next-line no-unused-vars
var bound = function assign(target, source1) {
  return polyfill(Object, arguments);
};
defineProperties(bound, {
  getPolyfill: getPolyfill,
  implementation: implementation,
  shim: shim
});
module.exports = bound;

/***/ }),
/* 245 */
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var keys = __webpack_require__(246);
var hasSymbols = typeof Symbol === 'function' && typeof Symbol('foo') === 'symbol';
var toStr = Object.prototype.toString;
var concat = Array.prototype.concat;
var defineDataProperty = __webpack_require__(249);
var isFunction = function (fn) {
  return typeof fn === 'function' && toStr.call(fn) === '[object Function]';
};
var supportsDescriptors = __webpack_require__(255)();
var defineProperty = function (object, name, value, predicate) {
  if (name in object) {
    if (predicate === true) {
      if (object[name] === value) {
        return;
      }
    } else if (!isFunction(predicate) || !predicate()) {
      return;
    }
  }
  if (supportsDescriptors) {
    defineDataProperty(object, name, value, true);
  } else {
    defineDataProperty(object, name, value);
  }
};
var defineProperties = function (object, map) {
  var predicates = arguments.length > 2 ? arguments[2] : {};
  var props = keys(map);
  if (hasSymbols) {
    props = concat.call(props, Object.getOwnPropertySymbols(map));
  }
  for (var i = 0; i < props.length; i += 1) {
    defineProperty(object, props[i], map[props[i]], predicates[props[i]]);
  }
};
defineProperties.supportsDescriptors = !!supportsDescriptors;
module.exports = defineProperties;

/***/ }),
/* 246 */
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var slice = Array.prototype.slice;
var isArgs = __webpack_require__(247);
var origKeys = Object.keys;
var keysShim = origKeys ? function keys(o) {
  return origKeys(o);
} : __webpack_require__(248);
var originalKeys = Object.keys;
keysShim.shim = function shimObjectKeys() {
  if (Object.keys) {
    var keysWorksWithArguments = function () {
      // Safari 5.0 bug
      var args = Object.keys(arguments);
      return args && args.length === arguments.length;
    }(1, 2);
    if (!keysWorksWithArguments) {
      Object.keys = function keys(object) {
        // eslint-disable-line func-name-matching
        if (isArgs(object)) {
          return originalKeys(slice.call(object));
        }
        return originalKeys(object);
      };
    }
  } else {
    Object.keys = keysShim;
  }
  return Object.keys || keysShim;
};
module.exports = keysShim;

/***/ }),
/* 247 */
/***/ (function(module) {

"use strict";


var toStr = Object.prototype.toString;
module.exports = function isArguments(value) {
  var str = toStr.call(value);
  var isArgs = str === '[object Arguments]';
  if (!isArgs) {
    isArgs = str !== '[object Array]' && value !== null && typeof value === 'object' && typeof value.length === 'number' && value.length >= 0 && toStr.call(value.callee) === '[object Function]';
  }
  return isArgs;
};

/***/ }),
/* 248 */
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var keysShim;
if (!Object.keys) {
  // modified from https://github.com/es-shims/es5-shim
  var has = Object.prototype.hasOwnProperty;
  var toStr = Object.prototype.toString;
  var isArgs = __webpack_require__(247); // eslint-disable-line global-require
  var isEnumerable = Object.prototype.propertyIsEnumerable;
  var hasDontEnumBug = !isEnumerable.call({
    toString: null
  }, 'toString');
  var hasProtoEnumBug = isEnumerable.call(function () {}, 'prototype');
  var dontEnums = ['toString', 'toLocaleString', 'valueOf', 'hasOwnProperty', 'isPrototypeOf', 'propertyIsEnumerable', 'constructor'];
  var equalsConstructorPrototype = function (o) {
    var ctor = o.constructor;
    return ctor && ctor.prototype === o;
  };
  var excludedKeys = {
    $applicationCache: true,
    $console: true,
    $external: true,
    $frame: true,
    $frameElement: true,
    $frames: true,
    $innerHeight: true,
    $innerWidth: true,
    $onmozfullscreenchange: true,
    $onmozfullscreenerror: true,
    $outerHeight: true,
    $outerWidth: true,
    $pageXOffset: true,
    $pageYOffset: true,
    $parent: true,
    $scrollLeft: true,
    $scrollTop: true,
    $scrollX: true,
    $scrollY: true,
    $self: true,
    $webkitIndexedDB: true,
    $webkitStorageInfo: true,
    $window: true
  };
  var hasAutomationEqualityBug = function () {
    /* global window */
    if (typeof window === 'undefined') {
      return false;
    }
    for (var k in window) {
      try {
        if (!excludedKeys['$' + k] && has.call(window, k) && window[k] !== null && typeof window[k] === 'object') {
          try {
            equalsConstructorPrototype(window[k]);
          } catch (e) {
            return true;
          }
        }
      } catch (e) {
        return true;
      }
    }
    return false;
  }();
  var equalsConstructorPrototypeIfNotBuggy = function (o) {
    /* global window */
    if (typeof window === 'undefined' || !hasAutomationEqualityBug) {
      return equalsConstructorPrototype(o);
    }
    try {
      return equalsConstructorPrototype(o);
    } catch (e) {
      return false;
    }
  };
  keysShim = function keys(object) {
    var isObject = object !== null && typeof object === 'object';
    var isFunction = toStr.call(object) === '[object Function]';
    var isArguments = isArgs(object);
    var isString = isObject && toStr.call(object) === '[object String]';
    var theKeys = [];
    if (!isObject && !isFunction && !isArguments) {
      throw new TypeError('Object.keys called on a non-object');
    }
    var skipProto = hasProtoEnumBug && isFunction;
    if (isString && object.length > 0 && !has.call(object, 0)) {
      for (var i = 0; i < object.length; ++i) {
        theKeys.push(String(i));
      }
    }
    if (isArguments && object.length > 0) {
      for (var j = 0; j < object.length; ++j) {
        theKeys.push(String(j));
      }
    } else {
      for (var name in object) {
        if (!(skipProto && name === 'prototype') && has.call(object, name)) {
          theKeys.push(String(name));
        }
      }
    }
    if (hasDontEnumBug) {
      var skipConstructor = equalsConstructorPrototypeIfNotBuggy(object);
      for (var k = 0; k < dontEnums.length; ++k) {
        if (!(skipConstructor && dontEnums[k] === 'constructor') && has.call(object, dontEnums[k])) {
          theKeys.push(dontEnums[k]);
        }
      }
    }
    return theKeys;
  };
}
module.exports = keysShim;

/***/ }),
/* 249 */
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var $defineProperty = __webpack_require__(250);
var $SyntaxError = __webpack_require__(251);
var $TypeError = __webpack_require__(252);
var gopd = __webpack_require__(253);

/** @type {import('.')} */
module.exports = function defineDataProperty(obj, property, value) {
  if (!obj || typeof obj !== 'object' && typeof obj !== 'function') {
    throw new $TypeError('`obj` must be an object or a function`');
  }
  if (typeof property !== 'string' && typeof property !== 'symbol') {
    throw new $TypeError('`property` must be a string or a symbol`');
  }
  if (arguments.length > 3 && typeof arguments[3] !== 'boolean' && arguments[3] !== null) {
    throw new $TypeError('`nonEnumerable`, if provided, must be a boolean or null');
  }
  if (arguments.length > 4 && typeof arguments[4] !== 'boolean' && arguments[4] !== null) {
    throw new $TypeError('`nonWritable`, if provided, must be a boolean or null');
  }
  if (arguments.length > 5 && typeof arguments[5] !== 'boolean' && arguments[5] !== null) {
    throw new $TypeError('`nonConfigurable`, if provided, must be a boolean or null');
  }
  if (arguments.length > 6 && typeof arguments[6] !== 'boolean') {
    throw new $TypeError('`loose`, if provided, must be a boolean');
  }
  var nonEnumerable = arguments.length > 3 ? arguments[3] : null;
  var nonWritable = arguments.length > 4 ? arguments[4] : null;
  var nonConfigurable = arguments.length > 5 ? arguments[5] : null;
  var loose = arguments.length > 6 ? arguments[6] : false;

  /* @type {false | TypedPropertyDescriptor<unknown>} */
  var desc = !!gopd && gopd(obj, property);
  if ($defineProperty) {
    $defineProperty(obj, property, {
      configurable: nonConfigurable === null && desc ? desc.configurable : !nonConfigurable,
      enumerable: nonEnumerable === null && desc ? desc.enumerable : !nonEnumerable,
      value: value,
      writable: nonWritable === null && desc ? desc.writable : !nonWritable
    });
  } else if (loose || !nonEnumerable && !nonWritable && !nonConfigurable) {
    // must fall back to [[Set]], and was not explicitly asked to make non-enumerable, non-writable, or non-configurable
    obj[property] = value; // eslint-disable-line no-param-reassign
  } else {
    throw new $SyntaxError('This environment does not support defining a property as non-configurable, non-writable, or non-enumerable.');
  }
};

/***/ }),
/* 250 */
/***/ (function(module) {

"use strict";


/** @type {import('.')} */
var $defineProperty = Object.defineProperty || false;
if ($defineProperty) {
  try {
    $defineProperty({}, 'a', {
      value: 1
    });
  } catch (e) {
    // IE 8 has a broken defineProperty
    $defineProperty = false;
  }
}
module.exports = $defineProperty;

/***/ }),
/* 251 */
/***/ (function(module) {

"use strict";


/** @type {import('./syntax')} */
module.exports = SyntaxError;

/***/ }),
/* 252 */
/***/ (function(module) {

"use strict";


/** @type {import('./type')} */
module.exports = TypeError;

/***/ }),
/* 253 */
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


/** @type {import('.')} */
var $gOPD = __webpack_require__(254);
if ($gOPD) {
  try {
    $gOPD([], 'length');
  } catch (e) {
    // IE 8 has a broken gOPD
    $gOPD = null;
  }
}
module.exports = $gOPD;

/***/ }),
/* 254 */
/***/ (function(module) {

"use strict";


/** @type {import('./gOPD')} */
module.exports = Object.getOwnPropertyDescriptor;

/***/ }),
/* 255 */
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var $defineProperty = __webpack_require__(250);
var hasPropertyDescriptors = function hasPropertyDescriptors() {
  return !!$defineProperty;
};
hasPropertyDescriptors.hasArrayLengthDefineBug = function hasArrayLengthDefineBug() {
  // node v0.6 has a bug where array lengths can be Set but not Defined
  if (!$defineProperty) {
    return null;
  }
  try {
    return $defineProperty([], 'length', {
      value: 1
    }).length !== 1;
  } catch (e) {
    // In Firefox 4-22, defining length on an array throws an exception.
    return true;
  }
};
module.exports = hasPropertyDescriptors;

/***/ }),
/* 256 */
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var bind = __webpack_require__(257);
var GetIntrinsic = __webpack_require__(259);
var setFunctionLength = __webpack_require__(286);
var $TypeError = __webpack_require__(252);
var $apply = GetIntrinsic('%Function.prototype.apply%');
var $call = GetIntrinsic('%Function.prototype.call%');
var $reflectApply = GetIntrinsic('%Reflect.apply%', true) || bind.call($call, $apply);
var $defineProperty = __webpack_require__(250);
var $max = GetIntrinsic('%Math.max%');
module.exports = function callBind(originalFunction) {
  if (typeof originalFunction !== 'function') {
    throw new $TypeError('a function is required');
  }
  var func = $reflectApply(bind, $call, arguments);
  return setFunctionLength(func, 1 + $max(0, originalFunction.length - (arguments.length - 1)), true);
};
var applyBind = function applyBind() {
  return $reflectApply(bind, $apply, arguments);
};
if ($defineProperty) {
  $defineProperty(module.exports, 'apply', {
    value: applyBind
  });
} else {
  module.exports.apply = applyBind;
}

/***/ }),
/* 257 */
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var implementation = __webpack_require__(258);
module.exports = Function.prototype.bind || implementation;

/***/ }),
/* 258 */
/***/ (function(module) {

"use strict";


/* eslint no-invalid-this: 1 */
var ERROR_MESSAGE = 'Function.prototype.bind called on incompatible ';
var toStr = Object.prototype.toString;
var max = Math.max;
var funcType = '[object Function]';
var concatty = function concatty(a, b) {
  var arr = [];
  for (var i = 0; i < a.length; i += 1) {
    arr[i] = a[i];
  }
  for (var j = 0; j < b.length; j += 1) {
    arr[j + a.length] = b[j];
  }
  return arr;
};
var slicy = function slicy(arrLike, offset) {
  var arr = [];
  for (var i = offset || 0, j = 0; i < arrLike.length; i += 1, j += 1) {
    arr[j] = arrLike[i];
  }
  return arr;
};
var joiny = function (arr, joiner) {
  var str = '';
  for (var i = 0; i < arr.length; i += 1) {
    str += arr[i];
    if (i + 1 < arr.length) {
      str += joiner;
    }
  }
  return str;
};
module.exports = function bind(that) {
  var target = this;
  if (typeof target !== 'function' || toStr.apply(target) !== funcType) {
    throw new TypeError(ERROR_MESSAGE + target);
  }
  var args = slicy(arguments, 1);
  var bound;
  var binder = function () {
    if (this instanceof bound) {
      var result = target.apply(this, concatty(args, arguments));
      if (Object(result) === result) {
        return result;
      }
      return this;
    }
    return target.apply(that, concatty(args, arguments));
  };
  var boundLength = max(0, target.length - args.length);
  var boundArgs = [];
  for (var i = 0; i < boundLength; i++) {
    boundArgs[i] = '$' + i;
  }
  bound = Function('binder', 'return function (' + joiny(boundArgs, ',') + '){ return binder.apply(this,arguments); }')(binder);
  if (target.prototype) {
    var Empty = function Empty() {};
    Empty.prototype = target.prototype;
    bound.prototype = new Empty();
    Empty.prototype = null;
  }
  return bound;
};

/***/ }),
/* 259 */
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var undefined;
var $Object = __webpack_require__(260);
var $Error = __webpack_require__(261);
var $EvalError = __webpack_require__(262);
var $RangeError = __webpack_require__(263);
var $ReferenceError = __webpack_require__(264);
var $SyntaxError = __webpack_require__(251);
var $TypeError = __webpack_require__(252);
var $URIError = __webpack_require__(265);
var abs = __webpack_require__(266);
var floor = __webpack_require__(267);
var max = __webpack_require__(268);
var min = __webpack_require__(269);
var pow = __webpack_require__(270);
var round = __webpack_require__(271);
var sign = __webpack_require__(272);
var $Function = Function;

// eslint-disable-next-line consistent-return
var getEvalledConstructor = function (expressionSyntax) {
  try {
    return $Function('"use strict"; return (' + expressionSyntax + ').constructor;')();
  } catch (e) {}
};
var $gOPD = __webpack_require__(253);
var $defineProperty = __webpack_require__(250);
var throwTypeError = function () {
  throw new $TypeError();
};
var ThrowTypeError = $gOPD ? function () {
  try {
    // eslint-disable-next-line no-unused-expressions, no-caller, no-restricted-properties
    arguments.callee; // IE 8 does not throw here
    return throwTypeError;
  } catch (calleeThrows) {
    try {
      // IE 8 throws on Object.getOwnPropertyDescriptor(arguments, '')
      return $gOPD(arguments, 'callee').get;
    } catch (gOPDthrows) {
      return throwTypeError;
    }
  }
}() : throwTypeError;
var hasSymbols = __webpack_require__(274)();
var getProto = __webpack_require__(276);
var $ObjectGPO = __webpack_require__(278);
var $ReflectGPO = __webpack_require__(277);
var $apply = __webpack_require__(283);
var $call = __webpack_require__(281);
var needsEval = {};
var TypedArray = typeof Uint8Array === 'undefined' || !getProto ? undefined : getProto(Uint8Array);
var INTRINSICS = {
  __proto__: null,
  '%AggregateError%': typeof AggregateError === 'undefined' ? undefined : AggregateError,
  '%Array%': Array,
  '%ArrayBuffer%': typeof ArrayBuffer === 'undefined' ? undefined : ArrayBuffer,
  '%ArrayIteratorPrototype%': hasSymbols && getProto ? getProto([][Symbol.iterator]()) : undefined,
  '%AsyncFromSyncIteratorPrototype%': undefined,
  '%AsyncFunction%': needsEval,
  '%AsyncGenerator%': needsEval,
  '%AsyncGeneratorFunction%': needsEval,
  '%AsyncIteratorPrototype%': needsEval,
  '%Atomics%': typeof Atomics === 'undefined' ? undefined : Atomics,
  '%BigInt%': typeof BigInt === 'undefined' ? undefined : BigInt,
  '%BigInt64Array%': typeof BigInt64Array === 'undefined' ? undefined : BigInt64Array,
  '%BigUint64Array%': typeof BigUint64Array === 'undefined' ? undefined : BigUint64Array,
  '%Boolean%': Boolean,
  '%DataView%': typeof DataView === 'undefined' ? undefined : DataView,
  '%Date%': Date,
  '%decodeURI%': decodeURI,
  '%decodeURIComponent%': decodeURIComponent,
  '%encodeURI%': encodeURI,
  '%encodeURIComponent%': encodeURIComponent,
  '%Error%': $Error,
  '%eval%': eval,
  // eslint-disable-line no-eval
  '%EvalError%': $EvalError,
  '%Float16Array%': typeof Float16Array === 'undefined' ? undefined : Float16Array,
  '%Float32Array%': typeof Float32Array === 'undefined' ? undefined : Float32Array,
  '%Float64Array%': typeof Float64Array === 'undefined' ? undefined : Float64Array,
  '%FinalizationRegistry%': typeof FinalizationRegistry === 'undefined' ? undefined : FinalizationRegistry,
  '%Function%': $Function,
  '%GeneratorFunction%': needsEval,
  '%Int8Array%': typeof Int8Array === 'undefined' ? undefined : Int8Array,
  '%Int16Array%': typeof Int16Array === 'undefined' ? undefined : Int16Array,
  '%Int32Array%': typeof Int32Array === 'undefined' ? undefined : Int32Array,
  '%isFinite%': isFinite,
  '%isNaN%': isNaN,
  '%IteratorPrototype%': hasSymbols && getProto ? getProto(getProto([][Symbol.iterator]())) : undefined,
  '%JSON%': typeof JSON === 'object' ? JSON : undefined,
  '%Map%': typeof Map === 'undefined' ? undefined : Map,
  '%MapIteratorPrototype%': typeof Map === 'undefined' || !hasSymbols || !getProto ? undefined : getProto(new Map()[Symbol.iterator]()),
  '%Math%': Math,
  '%Number%': Number,
  '%Object%': $Object,
  '%Object.getOwnPropertyDescriptor%': $gOPD,
  '%parseFloat%': parseFloat,
  '%parseInt%': parseInt,
  '%Promise%': typeof Promise === 'undefined' ? undefined : Promise,
  '%Proxy%': typeof Proxy === 'undefined' ? undefined : Proxy,
  '%RangeError%': $RangeError,
  '%ReferenceError%': $ReferenceError,
  '%Reflect%': typeof Reflect === 'undefined' ? undefined : Reflect,
  '%RegExp%': RegExp,
  '%Set%': typeof Set === 'undefined' ? undefined : Set,
  '%SetIteratorPrototype%': typeof Set === 'undefined' || !hasSymbols || !getProto ? undefined : getProto(new Set()[Symbol.iterator]()),
  '%SharedArrayBuffer%': typeof SharedArrayBuffer === 'undefined' ? undefined : SharedArrayBuffer,
  '%String%': String,
  '%StringIteratorPrototype%': hasSymbols && getProto ? getProto(''[Symbol.iterator]()) : undefined,
  '%Symbol%': hasSymbols ? Symbol : undefined,
  '%SyntaxError%': $SyntaxError,
  '%ThrowTypeError%': ThrowTypeError,
  '%TypedArray%': TypedArray,
  '%TypeError%': $TypeError,
  '%Uint8Array%': typeof Uint8Array === 'undefined' ? undefined : Uint8Array,
  '%Uint8ClampedArray%': typeof Uint8ClampedArray === 'undefined' ? undefined : Uint8ClampedArray,
  '%Uint16Array%': typeof Uint16Array === 'undefined' ? undefined : Uint16Array,
  '%Uint32Array%': typeof Uint32Array === 'undefined' ? undefined : Uint32Array,
  '%URIError%': $URIError,
  '%WeakMap%': typeof WeakMap === 'undefined' ? undefined : WeakMap,
  '%WeakRef%': typeof WeakRef === 'undefined' ? undefined : WeakRef,
  '%WeakSet%': typeof WeakSet === 'undefined' ? undefined : WeakSet,
  '%Function.prototype.call%': $call,
  '%Function.prototype.apply%': $apply,
  '%Object.defineProperty%': $defineProperty,
  '%Object.getPrototypeOf%': $ObjectGPO,
  '%Math.abs%': abs,
  '%Math.floor%': floor,
  '%Math.max%': max,
  '%Math.min%': min,
  '%Math.pow%': pow,
  '%Math.round%': round,
  '%Math.sign%': sign,
  '%Reflect.getPrototypeOf%': $ReflectGPO
};
if (getProto) {
  try {
    null.error; // eslint-disable-line no-unused-expressions
  } catch (e) {
    // https://github.com/tc39/proposal-shadowrealm/pull/384#issuecomment-1364264229
    var errorProto = getProto(getProto(e));
    INTRINSICS['%Error.prototype%'] = errorProto;
  }
}
var doEval = function doEval(name) {
  var value;
  if (name === '%AsyncFunction%') {
    value = getEvalledConstructor('async function () {}');
  } else if (name === '%GeneratorFunction%') {
    value = getEvalledConstructor('function* () {}');
  } else if (name === '%AsyncGeneratorFunction%') {
    value = getEvalledConstructor('async function* () {}');
  } else if (name === '%AsyncGenerator%') {
    var fn = doEval('%AsyncGeneratorFunction%');
    if (fn) {
      value = fn.prototype;
    }
  } else if (name === '%AsyncIteratorPrototype%') {
    var gen = doEval('%AsyncGenerator%');
    if (gen && getProto) {
      value = getProto(gen.prototype);
    }
  }
  INTRINSICS[name] = value;
  return value;
};
var LEGACY_ALIASES = {
  __proto__: null,
  '%ArrayBufferPrototype%': ['ArrayBuffer', 'prototype'],
  '%ArrayPrototype%': ['Array', 'prototype'],
  '%ArrayProto_entries%': ['Array', 'prototype', 'entries'],
  '%ArrayProto_forEach%': ['Array', 'prototype', 'forEach'],
  '%ArrayProto_keys%': ['Array', 'prototype', 'keys'],
  '%ArrayProto_values%': ['Array', 'prototype', 'values'],
  '%AsyncFunctionPrototype%': ['AsyncFunction', 'prototype'],
  '%AsyncGenerator%': ['AsyncGeneratorFunction', 'prototype'],
  '%AsyncGeneratorPrototype%': ['AsyncGeneratorFunction', 'prototype', 'prototype'],
  '%BooleanPrototype%': ['Boolean', 'prototype'],
  '%DataViewPrototype%': ['DataView', 'prototype'],
  '%DatePrototype%': ['Date', 'prototype'],
  '%ErrorPrototype%': ['Error', 'prototype'],
  '%EvalErrorPrototype%': ['EvalError', 'prototype'],
  '%Float32ArrayPrototype%': ['Float32Array', 'prototype'],
  '%Float64ArrayPrototype%': ['Float64Array', 'prototype'],
  '%FunctionPrototype%': ['Function', 'prototype'],
  '%Generator%': ['GeneratorFunction', 'prototype'],
  '%GeneratorPrototype%': ['GeneratorFunction', 'prototype', 'prototype'],
  '%Int8ArrayPrototype%': ['Int8Array', 'prototype'],
  '%Int16ArrayPrototype%': ['Int16Array', 'prototype'],
  '%Int32ArrayPrototype%': ['Int32Array', 'prototype'],
  '%JSONParse%': ['JSON', 'parse'],
  '%JSONStringify%': ['JSON', 'stringify'],
  '%MapPrototype%': ['Map', 'prototype'],
  '%NumberPrototype%': ['Number', 'prototype'],
  '%ObjectPrototype%': ['Object', 'prototype'],
  '%ObjProto_toString%': ['Object', 'prototype', 'toString'],
  '%ObjProto_valueOf%': ['Object', 'prototype', 'valueOf'],
  '%PromisePrototype%': ['Promise', 'prototype'],
  '%PromiseProto_then%': ['Promise', 'prototype', 'then'],
  '%Promise_all%': ['Promise', 'all'],
  '%Promise_reject%': ['Promise', 'reject'],
  '%Promise_resolve%': ['Promise', 'resolve'],
  '%RangeErrorPrototype%': ['RangeError', 'prototype'],
  '%ReferenceErrorPrototype%': ['ReferenceError', 'prototype'],
  '%RegExpPrototype%': ['RegExp', 'prototype'],
  '%SetPrototype%': ['Set', 'prototype'],
  '%SharedArrayBufferPrototype%': ['SharedArrayBuffer', 'prototype'],
  '%StringPrototype%': ['String', 'prototype'],
  '%SymbolPrototype%': ['Symbol', 'prototype'],
  '%SyntaxErrorPrototype%': ['SyntaxError', 'prototype'],
  '%TypedArrayPrototype%': ['TypedArray', 'prototype'],
  '%TypeErrorPrototype%': ['TypeError', 'prototype'],
  '%Uint8ArrayPrototype%': ['Uint8Array', 'prototype'],
  '%Uint8ClampedArrayPrototype%': ['Uint8ClampedArray', 'prototype'],
  '%Uint16ArrayPrototype%': ['Uint16Array', 'prototype'],
  '%Uint32ArrayPrototype%': ['Uint32Array', 'prototype'],
  '%URIErrorPrototype%': ['URIError', 'prototype'],
  '%WeakMapPrototype%': ['WeakMap', 'prototype'],
  '%WeakSetPrototype%': ['WeakSet', 'prototype']
};
var bind = __webpack_require__(257);
var hasOwn = __webpack_require__(285);
var $concat = bind.call($call, Array.prototype.concat);
var $spliceApply = bind.call($apply, Array.prototype.splice);
var $replace = bind.call($call, String.prototype.replace);
var $strSlice = bind.call($call, String.prototype.slice);
var $exec = bind.call($call, RegExp.prototype.exec);

/* adapted from https://github.com/lodash/lodash/blob/4.17.15/dist/lodash.js#L6735-L6744 */
var rePropName = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g;
var reEscapeChar = /\\(\\)?/g; /** Used to match backslashes in property paths. */
var stringToPath = function stringToPath(string) {
  var first = $strSlice(string, 0, 1);
  var last = $strSlice(string, -1);
  if (first === '%' && last !== '%') {
    throw new $SyntaxError('invalid intrinsic syntax, expected closing `%`');
  } else if (last === '%' && first !== '%') {
    throw new $SyntaxError('invalid intrinsic syntax, expected opening `%`');
  }
  var result = [];
  $replace(string, rePropName, function (match, number, quote, subString) {
    result[result.length] = quote ? $replace(subString, reEscapeChar, '$1') : number || match;
  });
  return result;
};
/* end adaptation */

var getBaseIntrinsic = function getBaseIntrinsic(name, allowMissing) {
  var intrinsicName = name;
  var alias;
  if (hasOwn(LEGACY_ALIASES, intrinsicName)) {
    alias = LEGACY_ALIASES[intrinsicName];
    intrinsicName = '%' + alias[0] + '%';
  }
  if (hasOwn(INTRINSICS, intrinsicName)) {
    var value = INTRINSICS[intrinsicName];
    if (value === needsEval) {
      value = doEval(intrinsicName);
    }
    if (typeof value === 'undefined' && !allowMissing) {
      throw new $TypeError('intrinsic ' + name + ' exists, but is not available. Please file an issue!');
    }
    return {
      alias: alias,
      name: intrinsicName,
      value: value
    };
  }
  throw new $SyntaxError('intrinsic ' + name + ' does not exist!');
};
module.exports = function GetIntrinsic(name, allowMissing) {
  if (typeof name !== 'string' || name.length === 0) {
    throw new $TypeError('intrinsic name must be a non-empty string');
  }
  if (arguments.length > 1 && typeof allowMissing !== 'boolean') {
    throw new $TypeError('"allowMissing" argument must be a boolean');
  }
  if ($exec(/^%?[^%]*%?$/, name) === null) {
    throw new $SyntaxError('`%` may not be present anywhere but at the beginning and end of the intrinsic name');
  }
  var parts = stringToPath(name);
  var intrinsicBaseName = parts.length > 0 ? parts[0] : '';
  var intrinsic = getBaseIntrinsic('%' + intrinsicBaseName + '%', allowMissing);
  var intrinsicRealName = intrinsic.name;
  var value = intrinsic.value;
  var skipFurtherCaching = false;
  var alias = intrinsic.alias;
  if (alias) {
    intrinsicBaseName = alias[0];
    $spliceApply(parts, $concat([0, 1], alias));
  }
  for (var i = 1, isOwn = true; i < parts.length; i += 1) {
    var part = parts[i];
    var first = $strSlice(part, 0, 1);
    var last = $strSlice(part, -1);
    if ((first === '"' || first === "'" || first === '`' || last === '"' || last === "'" || last === '`') && first !== last) {
      throw new $SyntaxError('property names with quotes must have matching quotes');
    }
    if (part === 'constructor' || !isOwn) {
      skipFurtherCaching = true;
    }
    intrinsicBaseName += '.' + part;
    intrinsicRealName = '%' + intrinsicBaseName + '%';
    if (hasOwn(INTRINSICS, intrinsicRealName)) {
      value = INTRINSICS[intrinsicRealName];
    } else if (value != null) {
      if (!(part in value)) {
        if (!allowMissing) {
          throw new $TypeError('base intrinsic for ' + name + ' exists, but the property is not available.');
        }
        return void undefined;
      }
      if ($gOPD && i + 1 >= parts.length) {
        var desc = $gOPD(value, part);
        isOwn = !!desc;

        // By convention, when a data property is converted to an accessor
        // property to emulate a data property that does not suffer from
        // the override mistake, that accessor's getter is marked with
        // an `originalValue` property. Here, when we detect this, we
        // uphold the illusion by pretending to see that original data
        // property, i.e., returning the value rather than the getter
        // itself.
        if (isOwn && 'get' in desc && !('originalValue' in desc.get)) {
          value = desc.get;
        } else {
          value = value[part];
        }
      } else {
        isOwn = hasOwn(value, part);
        value = value[part];
      }
      if (isOwn && !skipFurtherCaching) {
        INTRINSICS[intrinsicRealName] = value;
      }
    }
  }
  return value;
};

/***/ }),
/* 260 */
/***/ (function(module) {

"use strict";


/** @type {import('.')} */
module.exports = Object;

/***/ }),
/* 261 */
/***/ (function(module) {

"use strict";


/** @type {import('.')} */
module.exports = Error;

/***/ }),
/* 262 */
/***/ (function(module) {

"use strict";


/** @type {import('./eval')} */
module.exports = EvalError;

/***/ }),
/* 263 */
/***/ (function(module) {

"use strict";


/** @type {import('./range')} */
module.exports = RangeError;

/***/ }),
/* 264 */
/***/ (function(module) {

"use strict";


/** @type {import('./ref')} */
module.exports = ReferenceError;

/***/ }),
/* 265 */
/***/ (function(module) {

"use strict";


/** @type {import('./uri')} */
module.exports = URIError;

/***/ }),
/* 266 */
/***/ (function(module) {

"use strict";


/** @type {import('./abs')} */
module.exports = Math.abs;

/***/ }),
/* 267 */
/***/ (function(module) {

"use strict";


/** @type {import('./floor')} */
module.exports = Math.floor;

/***/ }),
/* 268 */
/***/ (function(module) {

"use strict";


/** @type {import('./max')} */
module.exports = Math.max;

/***/ }),
/* 269 */
/***/ (function(module) {

"use strict";


/** @type {import('./min')} */
module.exports = Math.min;

/***/ }),
/* 270 */
/***/ (function(module) {

"use strict";


/** @type {import('./pow')} */
module.exports = Math.pow;

/***/ }),
/* 271 */
/***/ (function(module) {

"use strict";


/** @type {import('./round')} */
module.exports = Math.round;

/***/ }),
/* 272 */
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var $isNaN = __webpack_require__(273);

/** @type {import('./sign')} */
module.exports = function sign(number) {
  if ($isNaN(number) || number === 0) {
    return number;
  }
  return number < 0 ? -1 : +1;
};

/***/ }),
/* 273 */
/***/ (function(module) {

"use strict";


/** @type {import('./isNaN')} */
module.exports = Number.isNaN || function isNaN(a) {
  return a !== a;
};

/***/ }),
/* 274 */
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var origSymbol = typeof Symbol !== 'undefined' && Symbol;
var hasSymbolSham = __webpack_require__(275);

/** @type {import('.')} */
module.exports = function hasNativeSymbols() {
  if (typeof origSymbol !== 'function') {
    return false;
  }
  if (typeof Symbol !== 'function') {
    return false;
  }
  if (typeof origSymbol('foo') !== 'symbol') {
    return false;
  }
  if (typeof Symbol('bar') !== 'symbol') {
    return false;
  }
  return hasSymbolSham();
};

/***/ }),
/* 275 */
/***/ (function(module) {

"use strict";


/** @type {import('./shams')} */
/* eslint complexity: [2, 18], max-statements: [2, 33] */
module.exports = function hasSymbols() {
  if (typeof Symbol !== 'function' || typeof Object.getOwnPropertySymbols !== 'function') {
    return false;
  }
  if (typeof Symbol.iterator === 'symbol') {
    return true;
  }

  /** @type {{ [k in symbol]?: unknown }} */
  var obj = {};
  var sym = Symbol('test');
  var symObj = Object(sym);
  if (typeof sym === 'string') {
    return false;
  }
  if (Object.prototype.toString.call(sym) !== '[object Symbol]') {
    return false;
  }
  if (Object.prototype.toString.call(symObj) !== '[object Symbol]') {
    return false;
  }

  // temp disabled per https://github.com/ljharb/object.assign/issues/17
  // if (sym instanceof Symbol) { return false; }
  // temp disabled per https://github.com/WebReflection/get-own-property-symbols/issues/4
  // if (!(symObj instanceof Symbol)) { return false; }

  // if (typeof Symbol.prototype.toString !== 'function') { return false; }
  // if (String(sym) !== Symbol.prototype.toString.call(sym)) { return false; }

  var symVal = 42;
  obj[sym] = symVal;
  for (var _ in obj) {
    return false;
  } // eslint-disable-line no-restricted-syntax, no-unreachable-loop
  if (typeof Object.keys === 'function' && Object.keys(obj).length !== 0) {
    return false;
  }
  if (typeof Object.getOwnPropertyNames === 'function' && Object.getOwnPropertyNames(obj).length !== 0) {
    return false;
  }
  var syms = Object.getOwnPropertySymbols(obj);
  if (syms.length !== 1 || syms[0] !== sym) {
    return false;
  }
  if (!Object.prototype.propertyIsEnumerable.call(obj, sym)) {
    return false;
  }
  if (typeof Object.getOwnPropertyDescriptor === 'function') {
    // eslint-disable-next-line no-extra-parens
    var descriptor = /** @type {PropertyDescriptor} */Object.getOwnPropertyDescriptor(obj, sym);
    if (descriptor.value !== symVal || descriptor.enumerable !== true) {
      return false;
    }
  }
  return true;
};

/***/ }),
/* 276 */
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var reflectGetProto = __webpack_require__(277);
var originalGetProto = __webpack_require__(278);
var getDunderProto = __webpack_require__(279);

/** @type {import('.')} */
module.exports = reflectGetProto ? function getProto(O) {
  // @ts-expect-error TS can't narrow inside a closure, for some reason
  return reflectGetProto(O);
} : originalGetProto ? function getProto(O) {
  if (!O || typeof O !== 'object' && typeof O !== 'function') {
    throw new TypeError('getProto: not an object');
  }
  // @ts-expect-error TS can't narrow inside a closure, for some reason
  return originalGetProto(O);
} : getDunderProto ? function getProto(O) {
  // @ts-expect-error TS can't narrow inside a closure, for some reason
  return getDunderProto(O);
} : null;

/***/ }),
/* 277 */
/***/ (function(module) {

"use strict";


/** @type {import('./Reflect.getPrototypeOf')} */
module.exports = typeof Reflect !== 'undefined' && Reflect.getPrototypeOf || null;

/***/ }),
/* 278 */
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var $Object = __webpack_require__(260);

/** @type {import('./Object.getPrototypeOf')} */
module.exports = $Object.getPrototypeOf || null;

/***/ }),
/* 279 */
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var callBind = __webpack_require__(280);
var gOPD = __webpack_require__(253);
var hasProtoAccessor;
try {
  // eslint-disable-next-line no-extra-parens, no-proto
  hasProtoAccessor = /** @type {{ __proto__?: typeof Array.prototype }} */[].__proto__ === Array.prototype;
} catch (e) {
  if (!e || typeof e !== 'object' || !('code' in e) || e.code !== 'ERR_PROTO_ACCESS') {
    throw e;
  }
}

// eslint-disable-next-line no-extra-parens
var desc = !!hasProtoAccessor && gOPD && gOPD(Object.prototype, /** @type {keyof typeof Object.prototype} */'__proto__');
var $Object = Object;
var $getPrototypeOf = $Object.getPrototypeOf;

/** @type {import('./get')} */
module.exports = desc && typeof desc.get === 'function' ? callBind([desc.get]) : typeof $getPrototypeOf === 'function' ? /** @type {import('./get')} */function getDunder(value) {
  // eslint-disable-next-line eqeqeq
  return $getPrototypeOf(value == null ? value : $Object(value));
} : false;

/***/ }),
/* 280 */
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var bind = __webpack_require__(257);
var $TypeError = __webpack_require__(252);
var $call = __webpack_require__(281);
var $actualApply = __webpack_require__(282);

/** @type {(args: [Function, thisArg?: unknown, ...args: unknown[]]) => Function} TODO FIXME, find a way to use import('.') */
module.exports = function callBindBasic(args) {
  if (args.length < 1 || typeof args[0] !== 'function') {
    throw new $TypeError('a function is required');
  }
  return $actualApply(bind, $call, args);
};

/***/ }),
/* 281 */
/***/ (function(module) {

"use strict";


/** @type {import('./functionCall')} */
module.exports = Function.prototype.call;

/***/ }),
/* 282 */
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var bind = __webpack_require__(257);
var $apply = __webpack_require__(283);
var $call = __webpack_require__(281);
var $reflectApply = __webpack_require__(284);

/** @type {import('./actualApply')} */
module.exports = $reflectApply || bind.call($call, $apply);

/***/ }),
/* 283 */
/***/ (function(module) {

"use strict";


/** @type {import('./functionApply')} */
module.exports = Function.prototype.apply;

/***/ }),
/* 284 */
/***/ (function(module) {

"use strict";


/** @type {import('./reflectApply')} */
module.exports = typeof Reflect !== 'undefined' && Reflect && Reflect.apply;

/***/ }),
/* 285 */
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var call = Function.prototype.call;
var $hasOwn = Object.prototype.hasOwnProperty;
var bind = __webpack_require__(257);

/** @type {import('.')} */
module.exports = bind.call(call, $hasOwn);

/***/ }),
/* 286 */
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var GetIntrinsic = __webpack_require__(259);
var define = __webpack_require__(249);
var hasDescriptors = __webpack_require__(255)();
var gOPD = __webpack_require__(253);
var $TypeError = __webpack_require__(252);
var $floor = GetIntrinsic('%Math.floor%');

/** @type {import('.')} */
module.exports = function setFunctionLength(fn, length) {
  if (typeof fn !== 'function') {
    throw new $TypeError('`fn` is not a function');
  }
  if (typeof length !== 'number' || length < 0 || length > 0xFFFFFFFF || $floor(length) !== length) {
    throw new $TypeError('`length` must be a positive 32-bit integer');
  }
  var loose = arguments.length > 2 && !!arguments[2];
  var functionLengthIsConfigurable = true;
  var functionLengthIsWritable = true;
  if ('length' in fn && gOPD) {
    var desc = gOPD(fn, 'length');
    if (desc && !desc.configurable) {
      functionLengthIsConfigurable = false;
    }
    if (desc && !desc.writable) {
      functionLengthIsWritable = false;
    }
  }
  if (functionLengthIsConfigurable || functionLengthIsWritable || !loose) {
    if (hasDescriptors) {
      define(/** @type {Parameters<define>[0]} */fn, 'length', length, true, true);
    } else {
      define(/** @type {Parameters<define>[0]} */fn, 'length', length);
    }
  }
  return fn;
};

/***/ }),
/* 287 */
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


// modified from https://github.com/es-shims/es6-shim
var objectKeys = __webpack_require__(246);
var hasSymbols = __webpack_require__(275)();
var callBound = __webpack_require__(288);
var toObject = Object;
var $push = callBound('Array.prototype.push');
var $propIsEnumerable = callBound('Object.prototype.propertyIsEnumerable');
var originalGetSymbols = hasSymbols ? Object.getOwnPropertySymbols : null;

// eslint-disable-next-line no-unused-vars
module.exports = function assign(target, source1) {
  if (target == null) {
    throw new TypeError('target must be an object');
  }
  var to = toObject(target); // step 1
  if (arguments.length === 1) {
    return to; // step 2
  }
  for (var s = 1; s < arguments.length; ++s) {
    var from = toObject(arguments[s]); // step 3.a.i

    // step 3.a.ii:
    var keys = objectKeys(from);
    var getSymbols = hasSymbols && (Object.getOwnPropertySymbols || originalGetSymbols);
    if (getSymbols) {
      var syms = getSymbols(from);
      for (var j = 0; j < syms.length; ++j) {
        var key = syms[j];
        if ($propIsEnumerable(from, key)) {
          $push(keys, key);
        }
      }
    }

    // step 3.a.iii:
    for (var i = 0; i < keys.length; ++i) {
      var nextKey = keys[i];
      if ($propIsEnumerable(from, nextKey)) {
        // step 3.a.iii.2
        var propValue = from[nextKey]; // step 3.a.iii.2.a
        to[nextKey] = propValue; // step 3.a.iii.2.b
      }
    }
  }
  return to; // step 4
};

/***/ }),
/* 288 */
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var GetIntrinsic = __webpack_require__(259);
var callBind = __webpack_require__(256);
var $indexOf = callBind(GetIntrinsic('String.prototype.indexOf'));
module.exports = function callBoundIntrinsic(name, allowMissing) {
  var intrinsic = GetIntrinsic(name, !!allowMissing);
  if (typeof intrinsic === 'function' && $indexOf(name, '.prototype.') > -1) {
    return callBind(intrinsic);
  }
  return intrinsic;
};

/***/ }),
/* 289 */
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var implementation = __webpack_require__(287);
var lacksProperEnumerationOrder = function () {
  if (!Object.assign) {
    return false;
  }
  /*
   * v8, specifically in node 4.x, has a bug with incorrect property enumeration order
   * note: this does not detect the bug unless there's 20 characters
   */
  var str = 'abcdefghijklmnopqrst';
  var letters = str.split('');
  var map = {};
  for (var i = 0; i < letters.length; ++i) {
    map[letters[i]] = letters[i];
  }
  var obj = Object.assign({}, map);
  var actual = '';
  for (var k in obj) {
    actual += k;
  }
  return str !== actual;
};
var assignHasPendingExceptions = function () {
  if (!Object.assign || !Object.preventExtensions) {
    return false;
  }
  /*
   * Firefox 37 still has "pending exception" logic in its Object.assign implementation,
   * which is 72% slower than our shim, and Firefox 40's native implementation.
   */
  var thrower = Object.preventExtensions({
    1: 2
  });
  try {
    Object.assign(thrower, 'xy');
  } catch (e) {
    return thrower[1] === 'y';
  }
  return false;
};
module.exports = function getPolyfill() {
  if (!Object.assign) {
    return implementation;
  }
  if (lacksProperEnumerationOrder()) {
    return implementation;
  }
  if (assignHasPendingExceptions()) {
    return implementation;
  }
  return Object.assign;
};

/***/ }),
/* 290 */
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var define = __webpack_require__(245);
var getPolyfill = __webpack_require__(289);
module.exports = function shimAssign() {
  var polyfill = getPolyfill();
  define(Object, {
    assign: polyfill
  }, {
    assign: function () {
      return Object.assign !== polyfill;
    }
  });
  return polyfill;
};

/***/ }),
/* 291 */
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var define = __webpack_require__(245);
var callBind = __webpack_require__(256);
var implementation = __webpack_require__(292);
var getPolyfill = __webpack_require__(295);
var shim = __webpack_require__(296);
var flagsBound = callBind(getPolyfill());
define(flagsBound, {
  getPolyfill: getPolyfill,
  implementation: implementation,
  shim: shim
});
module.exports = flagsBound;

/***/ }),
/* 292 */
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var setFunctionName = __webpack_require__(293);
var $TypeError = __webpack_require__(252);
var $Object = Object;
module.exports = setFunctionName(function flags() {
  if (this == null || this !== $Object(this)) {
    throw new $TypeError('RegExp.prototype.flags getter called on non-object');
  }
  var result = '';
  if (this.hasIndices) {
    result += 'd';
  }
  if (this.global) {
    result += 'g';
  }
  if (this.ignoreCase) {
    result += 'i';
  }
  if (this.multiline) {
    result += 'm';
  }
  if (this.dotAll) {
    result += 's';
  }
  if (this.unicode) {
    result += 'u';
  }
  if (this.unicodeSets) {
    result += 'v';
  }
  if (this.sticky) {
    result += 'y';
  }
  return result;
}, 'get flags', true);

/***/ }),
/* 293 */
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var define = __webpack_require__(249);
var hasDescriptors = __webpack_require__(255)();
var functionsHaveConfigurableNames = (__webpack_require__(294).functionsHaveConfigurableNames)();
var $TypeError = __webpack_require__(252);

/** @type {import('.')} */
module.exports = function setFunctionName(fn, name) {
  if (typeof fn !== 'function') {
    throw new $TypeError('`fn` is not a function');
  }
  var loose = arguments.length > 2 && !!arguments[2];
  if (!loose || functionsHaveConfigurableNames) {
    if (hasDescriptors) {
      define(/** @type {Parameters<define>[0]} */fn, 'name', name, true, true);
    } else {
      define(/** @type {Parameters<define>[0]} */fn, 'name', name);
    }
  }
  return fn;
};

/***/ }),
/* 294 */
/***/ (function(module) {

"use strict";


var functionsHaveNames = function functionsHaveNames() {
  return typeof function f() {}.name === 'string';
};
var gOPD = Object.getOwnPropertyDescriptor;
if (gOPD) {
  try {
    gOPD([], 'length');
  } catch (e) {
    // IE 8 has a broken gOPD
    gOPD = null;
  }
}
functionsHaveNames.functionsHaveConfigurableNames = function functionsHaveConfigurableNames() {
  if (!functionsHaveNames() || !gOPD) {
    return false;
  }
  var desc = gOPD(function () {}, 'name');
  return !!desc && !!desc.configurable;
};
var $bind = Function.prototype.bind;
functionsHaveNames.boundFunctionsHaveNames = function boundFunctionsHaveNames() {
  return functionsHaveNames() && typeof $bind === 'function' && function f() {}.bind().name !== '';
};
module.exports = functionsHaveNames;

/***/ }),
/* 295 */
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var implementation = __webpack_require__(292);
var supportsDescriptors = (__webpack_require__(245).supportsDescriptors);
var $gOPD = Object.getOwnPropertyDescriptor;
module.exports = function getPolyfill() {
  if (supportsDescriptors && /a/mig.flags === 'gim') {
    var descriptor = $gOPD(RegExp.prototype, 'flags');
    if (descriptor && typeof descriptor.get === 'function' && typeof RegExp.prototype.dotAll === 'boolean' && typeof RegExp.prototype.hasIndices === 'boolean') {
      /* eslint getter-return: 0 */
      var calls = '';
      var o = {};
      Object.defineProperty(o, 'hasIndices', {
        get: function () {
          calls += 'd';
        }
      });
      Object.defineProperty(o, 'sticky', {
        get: function () {
          calls += 'y';
        }
      });
      if (calls === 'dy') {
        return descriptor.get;
      }
    }
  }
  return implementation;
};

/***/ }),
/* 296 */
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var supportsDescriptors = (__webpack_require__(245).supportsDescriptors);
var getPolyfill = __webpack_require__(295);
var gOPD = Object.getOwnPropertyDescriptor;
var defineProperty = Object.defineProperty;
var TypeErr = TypeError;
var getProto = Object.getPrototypeOf;
var regex = /a/;
module.exports = function shimFlags() {
  if (!supportsDescriptors || !getProto) {
    throw new TypeErr('RegExp.prototype.flags requires a true ES5 environment that supports property descriptors');
  }
  var polyfill = getPolyfill();
  var proto = getProto(regex);
  var descriptor = gOPD(proto, 'flags');
  if (!descriptor || descriptor.get !== polyfill) {
    defineProperty(proto, 'flags', {
      configurable: true,
      enumerable: false,
      get: polyfill
    });
  }
  return polyfill;
};

/***/ }),
/* 297 */
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


/* eslint global-require: 0 */
// the code is structured this way so that bundlers can
// alias out `has-symbols` to `() => true` or `() => false` if your target
// environments' Symbol capabilities are known, and then use
// dead code elimination on the rest of this module.
//
// Similarly, `isarray` can be aliased to `Array.isArray` if
// available in all target environments.
var isArguments = __webpack_require__(298);
var getStopIterationIterator = __webpack_require__(300);
if (__webpack_require__(274)() || __webpack_require__(275)()) {
  var $iterator = Symbol.iterator;
  // Symbol is available natively or shammed
  // natively:
  //  - Chrome >= 38
  //  - Edge 12-14?, Edge >= 15 for sure
  //  - FF >= 36
  //  - Safari >= 9
  //  - node >= 0.12
  module.exports = function getIterator(iterable) {
    // alternatively, `iterable[$iterator]?.()`
    if (iterable != null && typeof iterable[$iterator] !== 'undefined') {
      return iterable[$iterator]();
    }
    if (isArguments(iterable)) {
      // arguments objects lack Symbol.iterator
      // - node 0.12
      return Array.prototype[$iterator].call(iterable);
    }
  };
} else {
  // Symbol is not available, native or shammed
  var isArray = __webpack_require__(309);
  var isString = __webpack_require__(310);
  var GetIntrinsic = __webpack_require__(259);
  var $Map = GetIntrinsic('%Map%', true);
  var $Set = GetIntrinsic('%Set%', true);
  var callBound = __webpack_require__(288);
  var $arrayPush = callBound('Array.prototype.push');
  var $charCodeAt = callBound('String.prototype.charCodeAt');
  var $stringSlice = callBound('String.prototype.slice');
  var advanceStringIndex = function advanceStringIndex(S, index) {
    var length = S.length;
    if (index + 1 >= length) {
      return index + 1;
    }
    var first = $charCodeAt(S, index);
    if (first < 0xD800 || first > 0xDBFF) {
      return index + 1;
    }
    var second = $charCodeAt(S, index + 1);
    if (second < 0xDC00 || second > 0xDFFF) {
      return index + 1;
    }
    return index + 2;
  };
  var getArrayIterator = function getArrayIterator(arraylike) {
    var i = 0;
    return {
      next: function next() {
        var done = i >= arraylike.length;
        var value;
        if (!done) {
          value = arraylike[i];
          i += 1;
        }
        return {
          done: done,
          value: value
        };
      }
    };
  };
  var getNonCollectionIterator = function getNonCollectionIterator(iterable, noPrimordialCollections) {
    if (isArray(iterable) || isArguments(iterable)) {
      return getArrayIterator(iterable);
    }
    if (isString(iterable)) {
      var i = 0;
      return {
        next: function next() {
          var nextIndex = advanceStringIndex(iterable, i);
          var value = $stringSlice(iterable, i, nextIndex);
          i = nextIndex;
          return {
            done: nextIndex > iterable.length,
            value: value
          };
        }
      };
    }

    // es6-shim and es-shims' es-map use a string "_es6-shim iterator_" property on different iterables, such as MapIterator.
    if (noPrimordialCollections && typeof iterable['_es6-shim iterator_'] !== 'undefined') {
      return iterable['_es6-shim iterator_']();
    }
  };
  if (!$Map && !$Set) {
    // the only language iterables are Array, String, arguments
    // - Safari <= 6.0
    // - Chrome < 38
    // - node < 0.12
    // - FF < 13
    // - IE < 11
    // - Edge < 11

    module.exports = function getIterator(iterable) {
      if (iterable != null) {
        return getNonCollectionIterator(iterable, true);
      }
    };
  } else {
    // either Map or Set are available, but Symbol is not
    // - es6-shim on an ES5 browser
    // - Safari 6.2 (maybe 6.1?)
    // - FF v[13, 36)
    // - IE 11
    // - Edge 11
    // - Safari v[6, 9)

    var isMap = __webpack_require__(311);
    var isSet = __webpack_require__(312);

    // Firefox >= 27, IE 11, Safari 6.2 - 9, Edge 11, es6-shim in older envs, all have forEach
    var $mapForEach = callBound('Map.prototype.forEach', true);
    var $setForEach = callBound('Set.prototype.forEach', true);
    if (typeof process === 'undefined' || !process.versions || !process.versions.node) {
      // "if is not node"

      // Firefox 17 - 26 has `.iterator()`, whose iterator `.next()` either
      // returns a value, or throws a StopIteration object. These browsers
      // do not have any other mechanism for iteration.
      var $mapIterator = callBound('Map.prototype.iterator', true);
      var $setIterator = callBound('Set.prototype.iterator', true);
    }
    // Firefox 27-35, and some older es6-shim versions, use a string "@@iterator" property
    // this returns a proper iterator object, so we should use it instead of forEach.
    // newer es6-shim versions use a string "_es6-shim iterator_" property.
    var $mapAtAtIterator = callBound('Map.prototype.@@iterator', true) || callBound('Map.prototype._es6-shim iterator_', true);
    var $setAtAtIterator = callBound('Set.prototype.@@iterator', true) || callBound('Set.prototype._es6-shim iterator_', true);
    var getCollectionIterator = function getCollectionIterator(iterable) {
      if (isMap(iterable)) {
        if ($mapIterator) {
          return getStopIterationIterator($mapIterator(iterable));
        }
        if ($mapAtAtIterator) {
          return $mapAtAtIterator(iterable);
        }
        if ($mapForEach) {
          var entries = [];
          $mapForEach(iterable, function (v, k) {
            $arrayPush(entries, [k, v]);
          });
          return getArrayIterator(entries);
        }
      }
      if (isSet(iterable)) {
        if ($setIterator) {
          return getStopIterationIterator($setIterator(iterable));
        }
        if ($setAtAtIterator) {
          return $setAtAtIterator(iterable);
        }
        if ($setForEach) {
          var values = [];
          $setForEach(iterable, function (v) {
            $arrayPush(values, v);
          });
          return getArrayIterator(values);
        }
      }
    };
    module.exports = function getIterator(iterable) {
      return getCollectionIterator(iterable) || getNonCollectionIterator(iterable);
    };
  }
}

/***/ }),
/* 298 */
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var hasToStringTag = __webpack_require__(299)();
var callBound = __webpack_require__(288);
var $toString = callBound('Object.prototype.toString');
var isStandardArguments = function isArguments(value) {
  if (hasToStringTag && value && typeof value === 'object' && Symbol.toStringTag in value) {
    return false;
  }
  return $toString(value) === '[object Arguments]';
};
var isLegacyArguments = function isArguments(value) {
  if (isStandardArguments(value)) {
    return true;
  }
  return value !== null && typeof value === 'object' && typeof value.length === 'number' && value.length >= 0 && $toString(value) !== '[object Array]' && $toString(value.callee) === '[object Function]';
};
var supportsStandardArguments = function () {
  return isStandardArguments(arguments);
}();
isStandardArguments.isLegacyArguments = isLegacyArguments; // for tests

module.exports = supportsStandardArguments ? isStandardArguments : isLegacyArguments;

/***/ }),
/* 299 */
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var hasSymbols = __webpack_require__(275);

/** @type {import('.')} */
module.exports = function hasToStringTagShams() {
  return hasSymbols() && !!Symbol.toStringTag;
};

/***/ }),
/* 300 */
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var SLOT = __webpack_require__(301);
var $SyntaxError = SyntaxError;
var $StopIteration = typeof StopIteration === 'object' ? StopIteration : null;
module.exports = function getStopIterationIterator(origIterator) {
  if (!$StopIteration) {
    throw new $SyntaxError('this environment lacks StopIteration');
  }
  SLOT.set(origIterator, '[[Done]]', false);
  var siIterator = {
    next: function next() {
      var iterator = SLOT.get(this, '[[Iterator]]');
      var done = SLOT.get(iterator, '[[Done]]');
      try {
        return {
          done: done,
          value: done ? void undefined : iterator.next()
        };
      } catch (e) {
        SLOT.set(iterator, '[[Done]]', true);
        if (e !== $StopIteration) {
          throw e;
        }
        return {
          done: true,
          value: void undefined
        };
      }
    }
  };
  SLOT.set(siIterator, '[[Iterator]]', origIterator);
  return siIterator;
};

/***/ }),
/* 301 */
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var hasOwn = __webpack_require__(285);
var channel = __webpack_require__(302)();
var $TypeError = __webpack_require__(252);
var SLOT = {
  assert: function (O, slot) {
    if (!O || typeof O !== 'object' && typeof O !== 'function') {
      throw new $TypeError('`O` is not an object');
    }
    if (typeof slot !== 'string') {
      throw new $TypeError('`slot` must be a string');
    }
    channel.assert(O);
    if (!SLOT.has(O, slot)) {
      throw new $TypeError('`' + slot + '` is not present on `O`');
    }
  },
  get: function (O, slot) {
    if (!O || typeof O !== 'object' && typeof O !== 'function') {
      throw new $TypeError('`O` is not an object');
    }
    if (typeof slot !== 'string') {
      throw new $TypeError('`slot` must be a string');
    }
    var slots = channel.get(O);
    return slots && slots['$' + slot];
  },
  has: function (O, slot) {
    if (!O || typeof O !== 'object' && typeof O !== 'function') {
      throw new $TypeError('`O` is not an object');
    }
    if (typeof slot !== 'string') {
      throw new $TypeError('`slot` must be a string');
    }
    var slots = channel.get(O);
    return !!slots && hasOwn(slots, '$' + slot);
  },
  set: function (O, slot, V) {
    if (!O || typeof O !== 'object' && typeof O !== 'function') {
      throw new $TypeError('`O` is not an object');
    }
    if (typeof slot !== 'string') {
      throw new $TypeError('`slot` must be a string');
    }
    var slots = channel.get(O);
    if (!slots) {
      slots = {};
      channel.set(O, slots);
    }
    slots['$' + slot] = V;
  }
};
if (Object.freeze) {
  Object.freeze(SLOT);
}
module.exports = SLOT;

/***/ }),
/* 302 */
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var $TypeError = __webpack_require__(252);
var inspect = __webpack_require__(303);
var getSideChannelList = __webpack_require__(305);
var getSideChannelMap = __webpack_require__(306);
var getSideChannelWeakMap = __webpack_require__(308);
var makeChannel = getSideChannelWeakMap || getSideChannelMap || getSideChannelList;

/** @type {import('.')} */
module.exports = function getSideChannel() {
  /** @typedef {ReturnType<typeof getSideChannel>} Channel */

  /** @type {Channel | undefined} */var $channelData;

  /** @type {Channel} */
  var channel = {
    assert: function (key) {
      if (!channel.has(key)) {
        throw new $TypeError('Side channel does not contain ' + inspect(key));
      }
    },
    'delete': function (key) {
      return !!$channelData && $channelData['delete'](key);
    },
    get: function (key) {
      return $channelData && $channelData.get(key);
    },
    has: function (key) {
      return !!$channelData && $channelData.has(key);
    },
    set: function (key, value) {
      if (!$channelData) {
        $channelData = makeChannel();
      }
      $channelData.set(key, value);
    }
  };
  // @ts-expect-error TODO: figure out why this is erroring
  return channel;
};

/***/ }),
/* 303 */
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var hasMap = typeof Map === 'function' && Map.prototype;
var mapSizeDescriptor = Object.getOwnPropertyDescriptor && hasMap ? Object.getOwnPropertyDescriptor(Map.prototype, 'size') : null;
var mapSize = hasMap && mapSizeDescriptor && typeof mapSizeDescriptor.get === 'function' ? mapSizeDescriptor.get : null;
var mapForEach = hasMap && Map.prototype.forEach;
var hasSet = typeof Set === 'function' && Set.prototype;
var setSizeDescriptor = Object.getOwnPropertyDescriptor && hasSet ? Object.getOwnPropertyDescriptor(Set.prototype, 'size') : null;
var setSize = hasSet && setSizeDescriptor && typeof setSizeDescriptor.get === 'function' ? setSizeDescriptor.get : null;
var setForEach = hasSet && Set.prototype.forEach;
var hasWeakMap = typeof WeakMap === 'function' && WeakMap.prototype;
var weakMapHas = hasWeakMap ? WeakMap.prototype.has : null;
var hasWeakSet = typeof WeakSet === 'function' && WeakSet.prototype;
var weakSetHas = hasWeakSet ? WeakSet.prototype.has : null;
var hasWeakRef = typeof WeakRef === 'function' && WeakRef.prototype;
var weakRefDeref = hasWeakRef ? WeakRef.prototype.deref : null;
var booleanValueOf = Boolean.prototype.valueOf;
var objectToString = Object.prototype.toString;
var functionToString = Function.prototype.toString;
var $match = String.prototype.match;
var $slice = String.prototype.slice;
var $replace = String.prototype.replace;
var $toUpperCase = String.prototype.toUpperCase;
var $toLowerCase = String.prototype.toLowerCase;
var $test = RegExp.prototype.test;
var $concat = Array.prototype.concat;
var $join = Array.prototype.join;
var $arrSlice = Array.prototype.slice;
var $floor = Math.floor;
var bigIntValueOf = typeof BigInt === 'function' ? BigInt.prototype.valueOf : null;
var gOPS = Object.getOwnPropertySymbols;
var symToString = typeof Symbol === 'function' && typeof Symbol.iterator === 'symbol' ? Symbol.prototype.toString : null;
var hasShammedSymbols = typeof Symbol === 'function' && typeof Symbol.iterator === 'object';
// ie, `has-tostringtag/shams
var toStringTag = typeof Symbol === 'function' && Symbol.toStringTag && (typeof Symbol.toStringTag === hasShammedSymbols ? 'object' : 'symbol') ? Symbol.toStringTag : null;
var isEnumerable = Object.prototype.propertyIsEnumerable;
var gPO = (typeof Reflect === 'function' ? Reflect.getPrototypeOf : Object.getPrototypeOf) || ([].__proto__ === Array.prototype // eslint-disable-line no-proto
? function (O) {
  return O.__proto__; // eslint-disable-line no-proto
} : null);
function addNumericSeparator(num, str) {
  if (num === Infinity || num === -Infinity || num !== num || num && num > -1000 && num < 1000 || $test.call(/e/, str)) {
    return str;
  }
  var sepRegex = /[0-9](?=(?:[0-9]{3})+(?![0-9]))/g;
  if (typeof num === 'number') {
    var int = num < 0 ? -$floor(-num) : $floor(num); // trunc(num)
    if (int !== num) {
      var intStr = String(int);
      var dec = $slice.call(str, intStr.length + 1);
      return $replace.call(intStr, sepRegex, '$&_') + '.' + $replace.call($replace.call(dec, /([0-9]{3})/g, '$&_'), /_$/, '');
    }
  }
  return $replace.call(str, sepRegex, '$&_');
}
var utilInspect = __webpack_require__(304);
var inspectCustom = utilInspect.custom;
var inspectSymbol = isSymbol(inspectCustom) ? inspectCustom : null;
var quotes = {
  __proto__: null,
  'double': '"',
  single: "'"
};
var quoteREs = {
  __proto__: null,
  'double': /(["\\])/g,
  single: /(['\\])/g
};
module.exports = function inspect_(obj, options, depth, seen) {
  var opts = options || {};
  if (has(opts, 'quoteStyle') && !has(quotes, opts.quoteStyle)) {
    throw new TypeError('option "quoteStyle" must be "single" or "double"');
  }
  if (has(opts, 'maxStringLength') && (typeof opts.maxStringLength === 'number' ? opts.maxStringLength < 0 && opts.maxStringLength !== Infinity : opts.maxStringLength !== null)) {
    throw new TypeError('option "maxStringLength", if provided, must be a positive integer, Infinity, or `null`');
  }
  var customInspect = has(opts, 'customInspect') ? opts.customInspect : true;
  if (typeof customInspect !== 'boolean' && customInspect !== 'symbol') {
    throw new TypeError('option "customInspect", if provided, must be `true`, `false`, or `\'symbol\'`');
  }
  if (has(opts, 'indent') && opts.indent !== null && opts.indent !== '\t' && !(parseInt(opts.indent, 10) === opts.indent && opts.indent > 0)) {
    throw new TypeError('option "indent" must be "\\t", an integer > 0, or `null`');
  }
  if (has(opts, 'numericSeparator') && typeof opts.numericSeparator !== 'boolean') {
    throw new TypeError('option "numericSeparator", if provided, must be `true` or `false`');
  }
  var numericSeparator = opts.numericSeparator;
  if (typeof obj === 'undefined') {
    return 'undefined';
  }
  if (obj === null) {
    return 'null';
  }
  if (typeof obj === 'boolean') {
    return obj ? 'true' : 'false';
  }
  if (typeof obj === 'string') {
    return inspectString(obj, opts);
  }
  if (typeof obj === 'number') {
    if (obj === 0) {
      return Infinity / obj > 0 ? '0' : '-0';
    }
    var str = String(obj);
    return numericSeparator ? addNumericSeparator(obj, str) : str;
  }
  if (typeof obj === 'bigint') {
    var bigIntStr = String(obj) + 'n';
    return numericSeparator ? addNumericSeparator(obj, bigIntStr) : bigIntStr;
  }
  var maxDepth = typeof opts.depth === 'undefined' ? 5 : opts.depth;
  if (typeof depth === 'undefined') {
    depth = 0;
  }
  if (depth >= maxDepth && maxDepth > 0 && typeof obj === 'object') {
    return isArray(obj) ? '[Array]' : '[Object]';
  }
  var indent = getIndent(opts, depth);
  if (typeof seen === 'undefined') {
    seen = [];
  } else if (indexOf(seen, obj) >= 0) {
    return '[Circular]';
  }
  function inspect(value, from, noIndent) {
    if (from) {
      seen = $arrSlice.call(seen);
      seen.push(from);
    }
    if (noIndent) {
      var newOpts = {
        depth: opts.depth
      };
      if (has(opts, 'quoteStyle')) {
        newOpts.quoteStyle = opts.quoteStyle;
      }
      return inspect_(value, newOpts, depth + 1, seen);
    }
    return inspect_(value, opts, depth + 1, seen);
  }
  if (typeof obj === 'function' && !isRegExp(obj)) {
    // in older engines, regexes are callable
    var name = nameOf(obj);
    var keys = arrObjKeys(obj, inspect);
    return '[Function' + (name ? ': ' + name : ' (anonymous)') + ']' + (keys.length > 0 ? ' { ' + $join.call(keys, ', ') + ' }' : '');
  }
  if (isSymbol(obj)) {
    var symString = hasShammedSymbols ? $replace.call(String(obj), /^(Symbol\(.*\))_[^)]*$/, '$1') : symToString.call(obj);
    return typeof obj === 'object' && !hasShammedSymbols ? markBoxed(symString) : symString;
  }
  if (isElement(obj)) {
    var s = '<' + $toLowerCase.call(String(obj.nodeName));
    var attrs = obj.attributes || [];
    for (var i = 0; i < attrs.length; i++) {
      s += ' ' + attrs[i].name + '=' + wrapQuotes(quote(attrs[i].value), 'double', opts);
    }
    s += '>';
    if (obj.childNodes && obj.childNodes.length) {
      s += '...';
    }
    s += '</' + $toLowerCase.call(String(obj.nodeName)) + '>';
    return s;
  }
  if (isArray(obj)) {
    if (obj.length === 0) {
      return '[]';
    }
    var xs = arrObjKeys(obj, inspect);
    if (indent && !singleLineValues(xs)) {
      return '[' + indentedJoin(xs, indent) + ']';
    }
    return '[ ' + $join.call(xs, ', ') + ' ]';
  }
  if (isError(obj)) {
    var parts = arrObjKeys(obj, inspect);
    if (!('cause' in Error.prototype) && 'cause' in obj && !isEnumerable.call(obj, 'cause')) {
      return '{ [' + String(obj) + '] ' + $join.call($concat.call('[cause]: ' + inspect(obj.cause), parts), ', ') + ' }';
    }
    if (parts.length === 0) {
      return '[' + String(obj) + ']';
    }
    return '{ [' + String(obj) + '] ' + $join.call(parts, ', ') + ' }';
  }
  if (typeof obj === 'object' && customInspect) {
    if (inspectSymbol && typeof obj[inspectSymbol] === 'function' && utilInspect) {
      return utilInspect(obj, {
        depth: maxDepth - depth
      });
    } else if (customInspect !== 'symbol' && typeof obj.inspect === 'function') {
      return obj.inspect();
    }
  }
  if (isMap(obj)) {
    var mapParts = [];
    if (mapForEach) {
      mapForEach.call(obj, function (value, key) {
        mapParts.push(inspect(key, obj, true) + ' => ' + inspect(value, obj));
      });
    }
    return collectionOf('Map', mapSize.call(obj), mapParts, indent);
  }
  if (isSet(obj)) {
    var setParts = [];
    if (setForEach) {
      setForEach.call(obj, function (value) {
        setParts.push(inspect(value, obj));
      });
    }
    return collectionOf('Set', setSize.call(obj), setParts, indent);
  }
  if (isWeakMap(obj)) {
    return weakCollectionOf('WeakMap');
  }
  if (isWeakSet(obj)) {
    return weakCollectionOf('WeakSet');
  }
  if (isWeakRef(obj)) {
    return weakCollectionOf('WeakRef');
  }
  if (isNumber(obj)) {
    return markBoxed(inspect(Number(obj)));
  }
  if (isBigInt(obj)) {
    return markBoxed(inspect(bigIntValueOf.call(obj)));
  }
  if (isBoolean(obj)) {
    return markBoxed(booleanValueOf.call(obj));
  }
  if (isString(obj)) {
    return markBoxed(inspect(String(obj)));
  }
  // note: in IE 8, sometimes `global !== window` but both are the prototypes of each other
  /* eslint-env browser */
  if (typeof window !== 'undefined' && obj === window) {
    return '{ [object Window] }';
  }
  if (typeof globalThis !== 'undefined' && obj === globalThis || typeof __webpack_require__.g !== 'undefined' && obj === __webpack_require__.g) {
    return '{ [object globalThis] }';
  }
  if (!isDate(obj) && !isRegExp(obj)) {
    var ys = arrObjKeys(obj, inspect);
    var isPlainObject = gPO ? gPO(obj) === Object.prototype : obj instanceof Object || obj.constructor === Object;
    var protoTag = obj instanceof Object ? '' : 'null prototype';
    var stringTag = !isPlainObject && toStringTag && Object(obj) === obj && toStringTag in obj ? $slice.call(toStr(obj), 8, -1) : protoTag ? 'Object' : '';
    var constructorTag = isPlainObject || typeof obj.constructor !== 'function' ? '' : obj.constructor.name ? obj.constructor.name + ' ' : '';
    var tag = constructorTag + (stringTag || protoTag ? '[' + $join.call($concat.call([], stringTag || [], protoTag || []), ': ') + '] ' : '');
    if (ys.length === 0) {
      return tag + '{}';
    }
    if (indent) {
      return tag + '{' + indentedJoin(ys, indent) + '}';
    }
    return tag + '{ ' + $join.call(ys, ', ') + ' }';
  }
  return String(obj);
};
function wrapQuotes(s, defaultStyle, opts) {
  var style = opts.quoteStyle || defaultStyle;
  var quoteChar = quotes[style];
  return quoteChar + s + quoteChar;
}
function quote(s) {
  return $replace.call(String(s), /"/g, '&quot;');
}
function canTrustToString(obj) {
  return !toStringTag || !(typeof obj === 'object' && (toStringTag in obj || typeof obj[toStringTag] !== 'undefined'));
}
function isArray(obj) {
  return toStr(obj) === '[object Array]' && canTrustToString(obj);
}
function isDate(obj) {
  return toStr(obj) === '[object Date]' && canTrustToString(obj);
}
function isRegExp(obj) {
  return toStr(obj) === '[object RegExp]' && canTrustToString(obj);
}
function isError(obj) {
  return toStr(obj) === '[object Error]' && canTrustToString(obj);
}
function isString(obj) {
  return toStr(obj) === '[object String]' && canTrustToString(obj);
}
function isNumber(obj) {
  return toStr(obj) === '[object Number]' && canTrustToString(obj);
}
function isBoolean(obj) {
  return toStr(obj) === '[object Boolean]' && canTrustToString(obj);
}

// Symbol and BigInt do have Symbol.toStringTag by spec, so that can't be used to eliminate false positives
function isSymbol(obj) {
  if (hasShammedSymbols) {
    return obj && typeof obj === 'object' && obj instanceof Symbol;
  }
  if (typeof obj === 'symbol') {
    return true;
  }
  if (!obj || typeof obj !== 'object' || !symToString) {
    return false;
  }
  try {
    symToString.call(obj);
    return true;
  } catch (e) {}
  return false;
}
function isBigInt(obj) {
  if (!obj || typeof obj !== 'object' || !bigIntValueOf) {
    return false;
  }
  try {
    bigIntValueOf.call(obj);
    return true;
  } catch (e) {}
  return false;
}
var hasOwn = Object.prototype.hasOwnProperty || function (key) {
  return key in this;
};
function has(obj, key) {
  return hasOwn.call(obj, key);
}
function toStr(obj) {
  return objectToString.call(obj);
}
function nameOf(f) {
  if (f.name) {
    return f.name;
  }
  var m = $match.call(functionToString.call(f), /^function\s*([\w$]+)/);
  if (m) {
    return m[1];
  }
  return null;
}
function indexOf(xs, x) {
  if (xs.indexOf) {
    return xs.indexOf(x);
  }
  for (var i = 0, l = xs.length; i < l; i++) {
    if (xs[i] === x) {
      return i;
    }
  }
  return -1;
}
function isMap(x) {
  if (!mapSize || !x || typeof x !== 'object') {
    return false;
  }
  try {
    mapSize.call(x);
    try {
      setSize.call(x);
    } catch (s) {
      return true;
    }
    return x instanceof Map; // core-js workaround, pre-v2.5.0
  } catch (e) {}
  return false;
}
function isWeakMap(x) {
  if (!weakMapHas || !x || typeof x !== 'object') {
    return false;
  }
  try {
    weakMapHas.call(x, weakMapHas);
    try {
      weakSetHas.call(x, weakSetHas);
    } catch (s) {
      return true;
    }
    return x instanceof WeakMap; // core-js workaround, pre-v2.5.0
  } catch (e) {}
  return false;
}
function isWeakRef(x) {
  if (!weakRefDeref || !x || typeof x !== 'object') {
    return false;
  }
  try {
    weakRefDeref.call(x);
    return true;
  } catch (e) {}
  return false;
}
function isSet(x) {
  if (!setSize || !x || typeof x !== 'object') {
    return false;
  }
  try {
    setSize.call(x);
    try {
      mapSize.call(x);
    } catch (m) {
      return true;
    }
    return x instanceof Set; // core-js workaround, pre-v2.5.0
  } catch (e) {}
  return false;
}
function isWeakSet(x) {
  if (!weakSetHas || !x || typeof x !== 'object') {
    return false;
  }
  try {
    weakSetHas.call(x, weakSetHas);
    try {
      weakMapHas.call(x, weakMapHas);
    } catch (s) {
      return true;
    }
    return x instanceof WeakSet; // core-js workaround, pre-v2.5.0
  } catch (e) {}
  return false;
}
function isElement(x) {
  if (!x || typeof x !== 'object') {
    return false;
  }
  if (typeof HTMLElement !== 'undefined' && x instanceof HTMLElement) {
    return true;
  }
  return typeof x.nodeName === 'string' && typeof x.getAttribute === 'function';
}
function inspectString(str, opts) {
  if (str.length > opts.maxStringLength) {
    var remaining = str.length - opts.maxStringLength;
    var trailer = '... ' + remaining + ' more character' + (remaining > 1 ? 's' : '');
    return inspectString($slice.call(str, 0, opts.maxStringLength), opts) + trailer;
  }
  var quoteRE = quoteREs[opts.quoteStyle || 'single'];
  quoteRE.lastIndex = 0;
  // eslint-disable-next-line no-control-regex
  var s = $replace.call($replace.call(str, quoteRE, '\\$1'), /[\x00-\x1f]/g, lowbyte);
  return wrapQuotes(s, 'single', opts);
}
function lowbyte(c) {
  var n = c.charCodeAt(0);
  var x = {
    8: 'b',
    9: 't',
    10: 'n',
    12: 'f',
    13: 'r'
  }[n];
  if (x) {
    return '\\' + x;
  }
  return '\\x' + (n < 0x10 ? '0' : '') + $toUpperCase.call(n.toString(16));
}
function markBoxed(str) {
  return 'Object(' + str + ')';
}
function weakCollectionOf(type) {
  return type + ' { ? }';
}
function collectionOf(type, size, entries, indent) {
  var joinedEntries = indent ? indentedJoin(entries, indent) : $join.call(entries, ', ');
  return type + ' (' + size + ') {' + joinedEntries + '}';
}
function singleLineValues(xs) {
  for (var i = 0; i < xs.length; i++) {
    if (indexOf(xs[i], '\n') >= 0) {
      return false;
    }
  }
  return true;
}
function getIndent(opts, depth) {
  var baseIndent;
  if (opts.indent === '\t') {
    baseIndent = '\t';
  } else if (typeof opts.indent === 'number' && opts.indent > 0) {
    baseIndent = $join.call(Array(opts.indent + 1), ' ');
  } else {
    return null;
  }
  return {
    base: baseIndent,
    prev: $join.call(Array(depth + 1), baseIndent)
  };
}
function indentedJoin(xs, indent) {
  if (xs.length === 0) {
    return '';
  }
  var lineJoiner = '\n' + indent.prev + indent.base;
  return lineJoiner + $join.call(xs, ',' + lineJoiner) + '\n' + indent.prev;
}
function arrObjKeys(obj, inspect) {
  var isArr = isArray(obj);
  var xs = [];
  if (isArr) {
    xs.length = obj.length;
    for (var i = 0; i < obj.length; i++) {
      xs[i] = has(obj, i) ? inspect(obj[i], obj) : '';
    }
  }
  var syms = typeof gOPS === 'function' ? gOPS(obj) : [];
  var symMap;
  if (hasShammedSymbols) {
    symMap = {};
    for (var k = 0; k < syms.length; k++) {
      symMap['$' + syms[k]] = syms[k];
    }
  }
  for (var key in obj) {
    // eslint-disable-line no-restricted-syntax
    if (!has(obj, key)) {
      continue;
    } // eslint-disable-line no-restricted-syntax, no-continue
    if (isArr && String(Number(key)) === key && key < obj.length) {
      continue;
    } // eslint-disable-line no-restricted-syntax, no-continue
    if (hasShammedSymbols && symMap['$' + key] instanceof Symbol) {
      // this is to prevent shammed Symbols, which are stored as strings, from being included in the string key section
      continue; // eslint-disable-line no-restricted-syntax, no-continue
    } else if ($test.call(/[^\w$]/, key)) {
      xs.push(inspect(key, obj) + ': ' + inspect(obj[key], obj));
    } else {
      xs.push(key + ': ' + inspect(obj[key], obj));
    }
  }
  if (typeof gOPS === 'function') {
    for (var j = 0; j < syms.length; j++) {
      if (isEnumerable.call(obj, syms[j])) {
        xs.push('[' + inspect(syms[j]) + ']: ' + inspect(obj[syms[j]], obj));
      }
    }
  }
  return xs;
}

/***/ }),
/* 304 */
/***/ (function() {

/* (ignored) */

/***/ }),
/* 305 */
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var inspect = __webpack_require__(303);
var $TypeError = __webpack_require__(252);

/*
* This function traverses the list returning the node corresponding to the given key.
*
* That node is also moved to the head of the list, so that if it's accessed again we don't need to traverse the whole list.
* By doing so, all the recently used nodes can be accessed relatively quickly.
*/
/** @type {import('./list.d.ts').listGetNode} */
// eslint-disable-next-line consistent-return
var listGetNode = function (list, key, isDelete) {
  /** @type {typeof list | NonNullable<(typeof list)['next']>} */
  var prev = list;
  /** @type {(typeof list)['next']} */
  var curr;
  // eslint-disable-next-line eqeqeq
  for (; (curr = prev.next) != null; prev = curr) {
    if (curr.key === key) {
      prev.next = curr.next;
      if (!isDelete) {
        // eslint-disable-next-line no-extra-parens
        curr.next = /** @type {NonNullable<typeof list.next>} */list.next;
        list.next = curr; // eslint-disable-line no-param-reassign
      }
      return curr;
    }
  }
};

/** @type {import('./list.d.ts').listGet} */
var listGet = function (objects, key) {
  if (!objects) {
    return void undefined;
  }
  var node = listGetNode(objects, key);
  return node && node.value;
};
/** @type {import('./list.d.ts').listSet} */
var listSet = function (objects, key, value) {
  var node = listGetNode(objects, key);
  if (node) {
    node.value = value;
  } else {
    // Prepend the new node to the beginning of the list
    objects.next = /** @type {import('./list.d.ts').ListNode<typeof value, typeof key>} */{
      // eslint-disable-line no-param-reassign, no-extra-parens
      key: key,
      next: objects.next,
      value: value
    };
  }
};
/** @type {import('./list.d.ts').listHas} */
var listHas = function (objects, key) {
  if (!objects) {
    return false;
  }
  return !!listGetNode(objects, key);
};
/** @type {import('./list.d.ts').listDelete} */
// eslint-disable-next-line consistent-return
var listDelete = function (objects, key) {
  if (objects) {
    return listGetNode(objects, key, true);
  }
};

/** @type {import('.')} */
module.exports = function getSideChannelList() {
  /** @typedef {ReturnType<typeof getSideChannelList>} Channel */
  /** @typedef {Parameters<Channel['get']>[0]} K */
  /** @typedef {Parameters<Channel['set']>[1]} V */

  /** @type {import('./list.d.ts').RootNode<V, K> | undefined} */var $o;

  /** @type {Channel} */
  var channel = {
    assert: function (key) {
      if (!channel.has(key)) {
        throw new $TypeError('Side channel does not contain ' + inspect(key));
      }
    },
    'delete': function (key) {
      var root = $o && $o.next;
      var deletedNode = listDelete($o, key);
      if (deletedNode && root && root === deletedNode) {
        $o = void undefined;
      }
      return !!deletedNode;
    },
    get: function (key) {
      return listGet($o, key);
    },
    has: function (key) {
      return listHas($o, key);
    },
    set: function (key, value) {
      if (!$o) {
        // Initialize the linked list as an empty node, so that we don't have to special-case handling of the first node: we can always refer to it as (previous node).next, instead of something like (list).head
        $o = {
          next: void undefined
        };
      }
      // eslint-disable-next-line no-extra-parens
      listSet(/** @type {NonNullable<typeof $o>} */$o, key, value);
    }
  };
  // @ts-expect-error TODO: figure out why this is erroring
  return channel;
};

/***/ }),
/* 306 */
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var GetIntrinsic = __webpack_require__(259);
var callBound = __webpack_require__(307);
var inspect = __webpack_require__(303);
var $TypeError = __webpack_require__(252);
var $Map = GetIntrinsic('%Map%', true);

/** @type {<K, V>(thisArg: Map<K, V>, key: K) => V} */
var $mapGet = callBound('Map.prototype.get', true);
/** @type {<K, V>(thisArg: Map<K, V>, key: K, value: V) => void} */
var $mapSet = callBound('Map.prototype.set', true);
/** @type {<K, V>(thisArg: Map<K, V>, key: K) => boolean} */
var $mapHas = callBound('Map.prototype.has', true);
/** @type {<K, V>(thisArg: Map<K, V>, key: K) => boolean} */
var $mapDelete = callBound('Map.prototype.delete', true);
/** @type {<K, V>(thisArg: Map<K, V>) => number} */
var $mapSize = callBound('Map.prototype.size', true);

/** @type {import('.')} */
module.exports = !!$Map && /** @type {Exclude<import('.'), false>} */function getSideChannelMap() {
  /** @typedef {ReturnType<typeof getSideChannelMap>} Channel */
  /** @typedef {Parameters<Channel['get']>[0]} K */
  /** @typedef {Parameters<Channel['set']>[1]} V */

  /** @type {Map<K, V> | undefined} */var $m;

  /** @type {Channel} */
  var channel = {
    assert: function (key) {
      if (!channel.has(key)) {
        throw new $TypeError('Side channel does not contain ' + inspect(key));
      }
    },
    'delete': function (key) {
      if ($m) {
        var result = $mapDelete($m, key);
        if ($mapSize($m) === 0) {
          $m = void undefined;
        }
        return result;
      }
      return false;
    },
    get: function (key) {
      // eslint-disable-line consistent-return
      if ($m) {
        return $mapGet($m, key);
      }
    },
    has: function (key) {
      if ($m) {
        return $mapHas($m, key);
      }
      return false;
    },
    set: function (key, value) {
      if (!$m) {
        // @ts-expect-error TS can't handle narrowing a variable inside a closure
        $m = new $Map();
      }
      $mapSet($m, key, value);
    }
  };

  // @ts-expect-error TODO: figure out why TS is erroring here
  return channel;
};

/***/ }),
/* 307 */
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var GetIntrinsic = __webpack_require__(259);
var callBindBasic = __webpack_require__(280);

/** @type {(thisArg: string, searchString: string, position?: number) => number} */
var $indexOf = callBindBasic([GetIntrinsic('%String.prototype.indexOf%')]);

/** @type {import('.')} */
module.exports = function callBoundIntrinsic(name, allowMissing) {
  /* eslint no-extra-parens: 0 */

  var intrinsic = /** @type {(this: unknown, ...args: unknown[]) => unknown} */GetIntrinsic(name, !!allowMissing);
  if (typeof intrinsic === 'function' && $indexOf(name, '.prototype.') > -1) {
    return callBindBasic(/** @type {const} */[intrinsic]);
  }
  return intrinsic;
};

/***/ }),
/* 308 */
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var GetIntrinsic = __webpack_require__(259);
var callBound = __webpack_require__(307);
var inspect = __webpack_require__(303);
var getSideChannelMap = __webpack_require__(306);
var $TypeError = __webpack_require__(252);
var $WeakMap = GetIntrinsic('%WeakMap%', true);

/** @type {<K extends object, V>(thisArg: WeakMap<K, V>, key: K) => V} */
var $weakMapGet = callBound('WeakMap.prototype.get', true);
/** @type {<K extends object, V>(thisArg: WeakMap<K, V>, key: K, value: V) => void} */
var $weakMapSet = callBound('WeakMap.prototype.set', true);
/** @type {<K extends object, V>(thisArg: WeakMap<K, V>, key: K) => boolean} */
var $weakMapHas = callBound('WeakMap.prototype.has', true);
/** @type {<K extends object, V>(thisArg: WeakMap<K, V>, key: K) => boolean} */
var $weakMapDelete = callBound('WeakMap.prototype.delete', true);

/** @type {import('.')} */
module.exports = $WeakMap ? /** @type {Exclude<import('.'), false>} */function getSideChannelWeakMap() {
  /** @typedef {ReturnType<typeof getSideChannelWeakMap>} Channel */
  /** @typedef {Parameters<Channel['get']>[0]} K */
  /** @typedef {Parameters<Channel['set']>[1]} V */

  /** @type {WeakMap<K & object, V> | undefined} */var $wm;
  /** @type {Channel | undefined} */
  var $m;

  /** @type {Channel} */
  var channel = {
    assert: function (key) {
      if (!channel.has(key)) {
        throw new $TypeError('Side channel does not contain ' + inspect(key));
      }
    },
    'delete': function (key) {
      if ($WeakMap && key && (typeof key === 'object' || typeof key === 'function')) {
        if ($wm) {
          return $weakMapDelete($wm, key);
        }
      } else if (getSideChannelMap) {
        if ($m) {
          return $m['delete'](key);
        }
      }
      return false;
    },
    get: function (key) {
      if ($WeakMap && key && (typeof key === 'object' || typeof key === 'function')) {
        if ($wm) {
          return $weakMapGet($wm, key);
        }
      }
      return $m && $m.get(key);
    },
    has: function (key) {
      if ($WeakMap && key && (typeof key === 'object' || typeof key === 'function')) {
        if ($wm) {
          return $weakMapHas($wm, key);
        }
      }
      return !!$m && $m.has(key);
    },
    set: function (key, value) {
      if ($WeakMap && key && (typeof key === 'object' || typeof key === 'function')) {
        if (!$wm) {
          $wm = new $WeakMap();
        }
        $weakMapSet($wm, key, value);
      } else if (getSideChannelMap) {
        if (!$m) {
          $m = getSideChannelMap();
        }
        // eslint-disable-next-line no-extra-parens
        /** @type {NonNullable<typeof $m>} */
        $m.set(key, value);
      }
    }
  };

  // @ts-expect-error TODO: figure out why this is erroring
  return channel;
} : getSideChannelMap;

/***/ }),
/* 309 */
/***/ (function(module) {

var toString = {}.toString;
module.exports = Array.isArray || function (arr) {
  return toString.call(arr) == '[object Array]';
};

/***/ }),
/* 310 */
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var strValue = String.prototype.valueOf;
var tryStringObject = function tryStringObject(value) {
  try {
    strValue.call(value);
    return true;
  } catch (e) {
    return false;
  }
};
var toStr = Object.prototype.toString;
var strClass = '[object String]';
var hasToStringTag = __webpack_require__(299)();
module.exports = function isString(value) {
  if (typeof value === 'string') {
    return true;
  }
  if (typeof value !== 'object') {
    return false;
  }
  return hasToStringTag ? tryStringObject(value) : toStr.call(value) === strClass;
};

/***/ }),
/* 311 */
/***/ (function(module) {

"use strict";


/** @const */
var $Map = typeof Map === 'function' && Map.prototype ? Map : null;
var $Set = typeof Set === 'function' && Set.prototype ? Set : null;
var exported;
if (!$Map) {
  /** @type {import('.')} */
  // eslint-disable-next-line no-unused-vars
  exported = function isMap(x) {
    // `Map` is not present in this environment.
    return false;
  };
}
var $mapHas = $Map ? Map.prototype.has : null;
var $setHas = $Set ? Set.prototype.has : null;
if (!exported && !$mapHas) {
  /** @type {import('.')} */
  // eslint-disable-next-line no-unused-vars
  exported = function isMap(x) {
    // `Map` does not have a `has` method
    return false;
  };
}

/** @type {import('.')} */
module.exports = exported || function isMap(x) {
  if (!x || typeof x !== 'object') {
    return false;
  }
  try {
    $mapHas.call(x);
    if ($setHas) {
      try {
        $setHas.call(x);
      } catch (e) {
        return true;
      }
    }
    // @ts-expect-error TS can't figure out that $Map is always truthy here
    return x instanceof $Map; // core-js workaround, pre-v2.5.0
  } catch (e) {}
  return false;
};

/***/ }),
/* 312 */
/***/ (function(module) {

"use strict";


var $Map = typeof Map === 'function' && Map.prototype ? Map : null;
var $Set = typeof Set === 'function' && Set.prototype ? Set : null;
var exported;
if (!$Set) {
  /** @type {import('.')} */
  // eslint-disable-next-line no-unused-vars
  exported = function isSet(x) {
    // `Set` is not present in this environment.
    return false;
  };
}
var $mapHas = $Map ? Map.prototype.has : null;
var $setHas = $Set ? Set.prototype.has : null;
if (!exported && !$setHas) {
  /** @type {import('.')} */
  // eslint-disable-next-line no-unused-vars
  exported = function isSet(x) {
    // `Set` does not have a `has` method
    return false;
  };
}

/** @type {import('.')} */
module.exports = exported || function isSet(x) {
  if (!x || typeof x !== 'object') {
    return false;
  }
  try {
    $setHas.call(x);
    if ($mapHas) {
      try {
        $mapHas.call(x);
      } catch (e) {
        return true;
      }
    }
    // @ts-expect-error TS can't figure out that $Set is always truthy here
    return x instanceof $Set; // core-js workaround, pre-v2.5.0
  } catch (e) {}
  return false;
};

/***/ }),
/* 313 */
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var define = __webpack_require__(245);
var callBind = __webpack_require__(256);
var implementation = __webpack_require__(314);
var getPolyfill = __webpack_require__(315);
var shim = __webpack_require__(316);
var polyfill = callBind(getPolyfill(), Object);
define(polyfill, {
  getPolyfill: getPolyfill,
  implementation: implementation,
  shim: shim
});
module.exports = polyfill;

/***/ }),
/* 314 */
/***/ (function(module) {

"use strict";


var numberIsNaN = function (value) {
  return value !== value;
};
module.exports = function is(a, b) {
  if (a === 0 && b === 0) {
    return 1 / a === 1 / b;
  }
  if (a === b) {
    return true;
  }
  if (numberIsNaN(a) && numberIsNaN(b)) {
    return true;
  }
  return false;
};

/***/ }),
/* 315 */
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var implementation = __webpack_require__(314);
module.exports = function getPolyfill() {
  return typeof Object.is === 'function' ? Object.is : implementation;
};

/***/ }),
/* 316 */
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var getPolyfill = __webpack_require__(315);
var define = __webpack_require__(245);
module.exports = function shimObjectIs() {
  var polyfill = getPolyfill();
  define(Object, {
    is: polyfill
  }, {
    is: function testObjectIs() {
      return Object.is !== polyfill;
    }
  });
  return polyfill;
};

/***/ }),
/* 317 */
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var callBind = __webpack_require__(256);
var callBound = __webpack_require__(288);
var GetIntrinsic = __webpack_require__(259);
var $ArrayBuffer = GetIntrinsic('%ArrayBuffer%', true);
/** @type {undefined | ((receiver: ArrayBuffer) => number) | ((receiver: unknown) => never)} */
var $byteLength = callBound('ArrayBuffer.prototype.byteLength', true);
var $toString = callBound('Object.prototype.toString');

// in node 0.10, ArrayBuffers have no prototype methods, but have an own slot-checking `slice` method
var abSlice = !!$ArrayBuffer && !$byteLength && new $ArrayBuffer(0).slice;
var $abSlice = !!abSlice && callBind(abSlice);

/** @type {import('.')} */
module.exports = $byteLength || $abSlice ? function isArrayBuffer(obj) {
  if (!obj || typeof obj !== 'object') {
    return false;
  }
  try {
    if ($byteLength) {
      // @ts-expect-error no idea why TS can't handle the overload
      $byteLength(obj);
    } else {
      // @ts-expect-error TS chooses not to type-narrow inside a closure
      $abSlice(obj, 0);
    }
    return true;
  } catch (e) {
    return false;
  }
} : $ArrayBuffer
// in node 0.8, ArrayBuffers have no prototype or own methods, but also no Symbol.toStringTag
? function isArrayBuffer(obj) {
  return $toString(obj) === '[object ArrayBuffer]';
} : function isArrayBuffer(obj) {
  // eslint-disable-line no-unused-vars
  return false;
};

/***/ }),
/* 318 */
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var getDay = Date.prototype.getDay;
var tryDateObject = function tryDateGetDayCall(value) {
  try {
    getDay.call(value);
    return true;
  } catch (e) {
    return false;
  }
};
var toStr = Object.prototype.toString;
var dateClass = '[object Date]';
var hasToStringTag = __webpack_require__(299)();
module.exports = function isDateObject(value) {
  if (typeof value !== 'object' || value === null) {
    return false;
  }
  return hasToStringTag ? tryDateObject(value) : toStr.call(value) === dateClass;
};

/***/ }),
/* 319 */
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var callBound = __webpack_require__(288);
var hasToStringTag = __webpack_require__(299)();
var has;
var $exec;
var isRegexMarker;
var badStringifier;
if (hasToStringTag) {
  has = callBound('Object.prototype.hasOwnProperty');
  $exec = callBound('RegExp.prototype.exec');
  isRegexMarker = {};
  var throwRegexMarker = function () {
    throw isRegexMarker;
  };
  badStringifier = {
    toString: throwRegexMarker,
    valueOf: throwRegexMarker
  };
  if (typeof Symbol.toPrimitive === 'symbol') {
    badStringifier[Symbol.toPrimitive] = throwRegexMarker;
  }
}
var $toString = callBound('Object.prototype.toString');
var gOPD = Object.getOwnPropertyDescriptor;
var regexClass = '[object RegExp]';
module.exports = hasToStringTag
// eslint-disable-next-line consistent-return
? function isRegex(value) {
  if (!value || typeof value !== 'object') {
    return false;
  }
  var descriptor = gOPD(value, 'lastIndex');
  var hasLastIndexDataProperty = descriptor && has(descriptor, 'value');
  if (!hasLastIndexDataProperty) {
    return false;
  }
  try {
    $exec(value, badStringifier);
  } catch (e) {
    return e === isRegexMarker;
  }
} : function isRegex(value) {
  // In older browsers, typeof regex incorrectly returns 'function'
  if (!value || typeof value !== 'object' && typeof value !== 'function') {
    return false;
  }
  return $toString(value) === regexClass;
};

/***/ }),
/* 320 */
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var callBound = __webpack_require__(288);
var $byteLength = callBound('SharedArrayBuffer.prototype.byteLength', true);

/** @type {import('.')} */
module.exports = $byteLength ? function isSharedArrayBuffer(obj) {
  if (!obj || typeof obj !== 'object') {
    return false;
  }
  try {
    $byteLength(obj);
    return true;
  } catch (e) {
    return false;
  }
} : function isSharedArrayBuffer(obj) {
  // eslint-disable-line no-unused-vars
  return false;
};

/***/ }),
/* 321 */
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var isString = __webpack_require__(310);
var isNumber = __webpack_require__(322);
var isBoolean = __webpack_require__(323);
var isSymbol = __webpack_require__(324);
var isBigInt = __webpack_require__(325);

// eslint-disable-next-line consistent-return
module.exports = function whichBoxedPrimitive(value) {
  // eslint-disable-next-line eqeqeq
  if (value == null || typeof value !== 'object' && typeof value !== 'function') {
    return null;
  }
  if (isString(value)) {
    return 'String';
  }
  if (isNumber(value)) {
    return 'Number';
  }
  if (isBoolean(value)) {
    return 'Boolean';
  }
  if (isSymbol(value)) {
    return 'Symbol';
  }
  if (isBigInt(value)) {
    return 'BigInt';
  }
};

/***/ }),
/* 322 */
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var numToStr = Number.prototype.toString;
var tryNumberObject = function tryNumberObject(value) {
  try {
    numToStr.call(value);
    return true;
  } catch (e) {
    return false;
  }
};
var toStr = Object.prototype.toString;
var numClass = '[object Number]';
var hasToStringTag = __webpack_require__(299)();
module.exports = function isNumberObject(value) {
  if (typeof value === 'number') {
    return true;
  }
  if (typeof value !== 'object') {
    return false;
  }
  return hasToStringTag ? tryNumberObject(value) : toStr.call(value) === numClass;
};

/***/ }),
/* 323 */
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var callBound = __webpack_require__(288);
var $boolToStr = callBound('Boolean.prototype.toString');
var $toString = callBound('Object.prototype.toString');
var tryBooleanObject = function booleanBrandCheck(value) {
  try {
    $boolToStr(value);
    return true;
  } catch (e) {
    return false;
  }
};
var boolClass = '[object Boolean]';
var hasToStringTag = __webpack_require__(299)();
module.exports = function isBoolean(value) {
  if (typeof value === 'boolean') {
    return true;
  }
  if (value === null || typeof value !== 'object') {
    return false;
  }
  return hasToStringTag && Symbol.toStringTag in value ? tryBooleanObject(value) : $toString(value) === boolClass;
};

/***/ }),
/* 324 */
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var toStr = Object.prototype.toString;
var hasSymbols = __webpack_require__(274)();
if (hasSymbols) {
  var symToStr = Symbol.prototype.toString;
  var symStringRegex = /^Symbol\(.*\)$/;
  var isSymbolObject = function isRealSymbolObject(value) {
    if (typeof value.valueOf() !== 'symbol') {
      return false;
    }
    return symStringRegex.test(symToStr.call(value));
  };
  module.exports = function isSymbol(value) {
    if (typeof value === 'symbol') {
      return true;
    }
    if (toStr.call(value) !== '[object Symbol]') {
      return false;
    }
    try {
      return isSymbolObject(value);
    } catch (e) {
      return false;
    }
  };
} else {
  module.exports = function isSymbol(value) {
    // this environment does not support Symbols.
    return  false && 0;
  };
}

/***/ }),
/* 325 */
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var hasBigInts = __webpack_require__(326)();
if (hasBigInts) {
  var bigIntValueOf = BigInt.prototype.valueOf;
  var tryBigInt = function tryBigIntObject(value) {
    try {
      bigIntValueOf.call(value);
      return true;
    } catch (e) {}
    return false;
  };
  module.exports = function isBigInt(value) {
    if (value === null || typeof value === 'undefined' || typeof value === 'boolean' || typeof value === 'string' || typeof value === 'number' || typeof value === 'symbol' || typeof value === 'function') {
      return false;
    }
    if (typeof value === 'bigint') {
      return true;
    }
    return tryBigInt(value);
  };
} else {
  module.exports = function isBigInt(value) {
    return  false && 0;
  };
}

/***/ }),
/* 326 */
/***/ (function(module) {

"use strict";


var $BigInt = typeof BigInt !== 'undefined' && BigInt;
module.exports = function hasNativeBigInts() {
  return typeof $BigInt === 'function' && typeof BigInt === 'function' && typeof $BigInt(42) === 'bigint' // eslint-disable-line no-magic-numbers
  && typeof BigInt(42) === 'bigint'; // eslint-disable-line no-magic-numbers
};

/***/ }),
/* 327 */
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var isMap = __webpack_require__(311);
var isSet = __webpack_require__(312);
var isWeakMap = __webpack_require__(328);
var isWeakSet = __webpack_require__(329);

/** @type {import('.')} */
module.exports = function whichCollection(/** @type {unknown} */value) {
  if (value && typeof value === 'object') {
    if (isMap(value)) {
      return 'Map';
    }
    if (isSet(value)) {
      return 'Set';
    }
    if (isWeakMap(value)) {
      return 'WeakMap';
    }
    if (isWeakSet(value)) {
      return 'WeakSet';
    }
  }
  return false;
};

/***/ }),
/* 328 */
/***/ (function(module) {

"use strict";


var $WeakMap = typeof WeakMap === 'function' && WeakMap.prototype ? WeakMap : null;
var $WeakSet = typeof WeakSet === 'function' && WeakSet.prototype ? WeakSet : null;
var exported;
if (!$WeakMap) {
  /** @type {import('.')} */
  // eslint-disable-next-line no-unused-vars
  exported = function isWeakMap(x) {
    // `WeakMap` is not present in this environment.
    return false;
  };
}
var $mapHas = $WeakMap ? $WeakMap.prototype.has : null;
var $setHas = $WeakSet ? $WeakSet.prototype.has : null;
if (!exported && !$mapHas) {
  /** @type {import('.')} */
  // eslint-disable-next-line no-unused-vars
  exported = function isWeakMap(x) {
    // `WeakMap` does not have a `has` method
    return false;
  };
}

/** @type {import('.')} */
module.exports = exported || function isWeakMap(x) {
  if (!x || typeof x !== 'object') {
    return false;
  }
  try {
    $mapHas.call(x, $mapHas);
    if ($setHas) {
      try {
        $setHas.call(x, $setHas);
      } catch (e) {
        return true;
      }
    }
    // @ts-expect-error TS can't figure out that $WeakMap is always truthy here
    return x instanceof $WeakMap; // core-js workaround, pre-v3
  } catch (e) {}
  return false;
};

/***/ }),
/* 329 */
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var GetIntrinsic = __webpack_require__(259);
var callBound = __webpack_require__(288);
var $WeakSet = GetIntrinsic('%WeakSet%', true);
var $setHas = callBound('WeakSet.prototype.has', true);
if ($setHas) {
  var $mapHas = callBound('WeakMap.prototype.has', true);

  /** @type {import('.')} */
  module.exports = function isWeakSet(x) {
    if (!x || typeof x !== 'object') {
      return false;
    }
    try {
      $setHas(x, $setHas);
      if ($mapHas) {
        try {
          $mapHas(x, $mapHas);
        } catch (e) {
          return true;
        }
      }
      // @ts-expect-error TS can't figure out that $WeakSet is always truthy here
      return x instanceof $WeakSet; // core-js workaround, pre-v3
    } catch (e) {}
    return false;
  };
} else {
  /** @type {import('.')} */
  // eslint-disable-next-line no-unused-vars
  module.exports = function isWeakSet(x) {
    // `WeakSet` does not exist, or does not have a `has` method
    return false;
  };
}

/***/ }),
/* 330 */
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var forEach = __webpack_require__(331);
var availableTypedArrays = __webpack_require__(333);
var callBind = __webpack_require__(256);
var callBound = __webpack_require__(288);
var gOPD = __webpack_require__(253);

/** @type {(O: object) => string} */
var $toString = callBound('Object.prototype.toString');
var hasToStringTag = __webpack_require__(299)();
var g = typeof globalThis === 'undefined' ? __webpack_require__.g : globalThis;
var typedArrays = availableTypedArrays();
var $slice = callBound('String.prototype.slice');
var getPrototypeOf = Object.getPrototypeOf; // require('getprototypeof');

/** @type {<T = unknown>(array: readonly T[], value: unknown) => number} */
var $indexOf = callBound('Array.prototype.indexOf', true) || function indexOf(array, value) {
  for (var i = 0; i < array.length; i += 1) {
    if (array[i] === value) {
      return i;
    }
  }
  return -1;
};

/** @typedef {(receiver: import('.').TypedArray) => string | typeof Uint8Array.prototype.slice.call | typeof Uint8Array.prototype.set.call} Getter */
/** @type {{ [k in `\$${import('.').TypedArrayName}`]?: Getter } & { __proto__: null }} */
var cache = {
  __proto__: null
};
if (hasToStringTag && gOPD && getPrototypeOf) {
  forEach(typedArrays, function (typedArray) {
    var arr = new g[typedArray]();
    if (Symbol.toStringTag in arr) {
      var proto = getPrototypeOf(arr);
      // @ts-expect-error TS won't narrow inside a closure
      var descriptor = gOPD(proto, Symbol.toStringTag);
      if (!descriptor) {
        var superProto = getPrototypeOf(proto);
        // @ts-expect-error TS won't narrow inside a closure
        descriptor = gOPD(superProto, Symbol.toStringTag);
      }
      // @ts-expect-error TODO: fix
      cache['$' + typedArray] = callBind(descriptor.get);
    }
  });
} else {
  forEach(typedArrays, function (typedArray) {
    var arr = new g[typedArray]();
    var fn = arr.slice || arr.set;
    if (fn) {
      // @ts-expect-error TODO: fix
      cache['$' + typedArray] = callBind(fn);
    }
  });
}

/** @type {(value: object) => false | import('.').TypedArrayName} */
var tryTypedArrays = function tryAllTypedArrays(value) {
  /** @type {ReturnType<typeof tryAllTypedArrays>} */var found = false;
  forEach(
  // eslint-disable-next-line no-extra-parens
  /** @type {Record<`\$${TypedArrayName}`, Getter>} */ /** @type {any} */
  cache, /** @type {(getter: Getter, name: `\$${import('.').TypedArrayName}`) => void} */
  function (getter, typedArray) {
    if (!found) {
      try {
        // @ts-expect-error TODO: fix
        if ('$' + getter(value) === typedArray) {
          found = $slice(typedArray, 1);
        }
      } catch (e) {/**/}
    }
  });
  return found;
};

/** @type {(value: object) => false | import('.').TypedArrayName} */
var trySlices = function tryAllSlices(value) {
  /** @type {ReturnType<typeof tryAllSlices>} */var found = false;
  forEach(
  // eslint-disable-next-line no-extra-parens
  /** @type {Record<`\$${TypedArrayName}`, Getter>} */ /** @type {any} */
  cache, /** @type {(getter: typeof cache, name: `\$${import('.').TypedArrayName}`) => void} */function (getter, name) {
    if (!found) {
      try {
        // @ts-expect-error TODO: fix
        getter(value);
        found = $slice(name, 1);
      } catch (e) {/**/}
    }
  });
  return found;
};

/** @type {import('.')} */
module.exports = function whichTypedArray(value) {
  if (!value || typeof value !== 'object') {
    return false;
  }
  if (!hasToStringTag) {
    /** @type {string} */
    var tag = $slice($toString(value), 8, -1);
    if ($indexOf(typedArrays, tag) > -1) {
      return tag;
    }
    if (tag !== 'Object') {
      return false;
    }
    // node < 0.6 hits here on real Typed Arrays
    return trySlices(value);
  }
  if (!gOPD) {
    return null;
  } // unknown engine
  return tryTypedArrays(value);
};

/***/ }),
/* 331 */
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var isCallable = __webpack_require__(332);
var toStr = Object.prototype.toString;
var hasOwnProperty = Object.prototype.hasOwnProperty;
var forEachArray = function forEachArray(array, iterator, receiver) {
  for (var i = 0, len = array.length; i < len; i++) {
    if (hasOwnProperty.call(array, i)) {
      if (receiver == null) {
        iterator(array[i], i, array);
      } else {
        iterator.call(receiver, array[i], i, array);
      }
    }
  }
};
var forEachString = function forEachString(string, iterator, receiver) {
  for (var i = 0, len = string.length; i < len; i++) {
    // no such thing as a sparse string.
    if (receiver == null) {
      iterator(string.charAt(i), i, string);
    } else {
      iterator.call(receiver, string.charAt(i), i, string);
    }
  }
};
var forEachObject = function forEachObject(object, iterator, receiver) {
  for (var k in object) {
    if (hasOwnProperty.call(object, k)) {
      if (receiver == null) {
        iterator(object[k], k, object);
      } else {
        iterator.call(receiver, object[k], k, object);
      }
    }
  }
};
var forEach = function forEach(list, iterator, thisArg) {
  if (!isCallable(iterator)) {
    throw new TypeError('iterator must be a function');
  }
  var receiver;
  if (arguments.length >= 3) {
    receiver = thisArg;
  }
  if (toStr.call(list) === '[object Array]') {
    forEachArray(list, iterator, receiver);
  } else if (typeof list === 'string') {
    forEachString(list, iterator, receiver);
  } else {
    forEachObject(list, iterator, receiver);
  }
};
module.exports = forEach;

/***/ }),
/* 332 */
/***/ (function(module) {

"use strict";


var fnToStr = Function.prototype.toString;
var reflectApply = typeof Reflect === 'object' && Reflect !== null && Reflect.apply;
var badArrayLike;
var isCallableMarker;
if (typeof reflectApply === 'function' && typeof Object.defineProperty === 'function') {
  try {
    badArrayLike = Object.defineProperty({}, 'length', {
      get: function () {
        throw isCallableMarker;
      }
    });
    isCallableMarker = {};
    // eslint-disable-next-line no-throw-literal
    reflectApply(function () {
      throw 42;
    }, null, badArrayLike);
  } catch (_) {
    if (_ !== isCallableMarker) {
      reflectApply = null;
    }
  }
} else {
  reflectApply = null;
}
var constructorRegex = /^\s*class\b/;
var isES6ClassFn = function isES6ClassFunction(value) {
  try {
    var fnStr = fnToStr.call(value);
    return constructorRegex.test(fnStr);
  } catch (e) {
    return false; // not a function
  }
};
var tryFunctionObject = function tryFunctionToStr(value) {
  try {
    if (isES6ClassFn(value)) {
      return false;
    }
    fnToStr.call(value);
    return true;
  } catch (e) {
    return false;
  }
};
var toStr = Object.prototype.toString;
var objectClass = '[object Object]';
var fnClass = '[object Function]';
var genClass = '[object GeneratorFunction]';
var ddaClass = '[object HTMLAllCollection]'; // IE 11
var ddaClass2 = '[object HTML document.all class]';
var ddaClass3 = '[object HTMLCollection]'; // IE 9-10
var hasToStringTag = typeof Symbol === 'function' && !!Symbol.toStringTag; // better: use `has-tostringtag`

var isIE68 = !(0 in [,]); // eslint-disable-line no-sparse-arrays, comma-spacing

var isDDA = function isDocumentDotAll() {
  return false;
};
if (typeof document === 'object') {
  // Firefox 3 canonicalizes DDA to undefined when it's not accessed directly
  var all = document.all;
  if (toStr.call(all) === toStr.call(document.all)) {
    isDDA = function isDocumentDotAll(value) {
      /* globals document: false */
      // in IE 6-8, typeof document.all is "object" and it's truthy
      if ((isIE68 || !value) && (typeof value === 'undefined' || typeof value === 'object')) {
        try {
          var str = toStr.call(value);
          return (str === ddaClass || str === ddaClass2 || str === ddaClass3 // opera 12.16
          || str === objectClass // IE 6-8
          ) && value('') == null; // eslint-disable-line eqeqeq
        } catch (e) {/**/}
      }
      return false;
    };
  }
}
module.exports = reflectApply ? function isCallable(value) {
  if (isDDA(value)) {
    return true;
  }
  if (!value) {
    return false;
  }
  if (typeof value !== 'function' && typeof value !== 'object') {
    return false;
  }
  try {
    reflectApply(value, null, badArrayLike);
  } catch (e) {
    if (e !== isCallableMarker) {
      return false;
    }
  }
  return !isES6ClassFn(value) && tryFunctionObject(value);
} : function isCallable(value) {
  if (isDDA(value)) {
    return true;
  }
  if (!value) {
    return false;
  }
  if (typeof value !== 'function' && typeof value !== 'object') {
    return false;
  }
  if (hasToStringTag) {
    return tryFunctionObject(value);
  }
  if (isES6ClassFn(value)) {
    return false;
  }
  var strClass = toStr.call(value);
  if (strClass !== fnClass && strClass !== genClass && !/^\[object HTML/.test(strClass)) {
    return false;
  }
  return tryFunctionObject(value);
};

/***/ }),
/* 333 */
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var possibleNames = __webpack_require__(334);
var g = typeof globalThis === 'undefined' ? __webpack_require__.g : globalThis;

/** @type {import('.')} */
module.exports = function availableTypedArrays() {
  var /** @type {ReturnType<typeof availableTypedArrays>} */out = [];
  for (var i = 0; i < possibleNames.length; i++) {
    if (typeof g[possibleNames[i]] === 'function') {
      // @ts-expect-error
      out[out.length] = possibleNames[i];
    }
  }
  return out;
};

/***/ }),
/* 334 */
/***/ (function(module) {

"use strict";


/** @type {import('.')} */
module.exports = ['Float32Array', 'Float64Array', 'Int8Array', 'Int16Array', 'Int32Array', 'Uint8Array', 'Uint8ClampedArray', 'Uint16Array', 'Uint32Array', 'BigInt64Array', 'BigUint64Array'];

/***/ }),
/* 335 */
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var callBound = __webpack_require__(288);
var $byteLength = callBound('ArrayBuffer.prototype.byteLength', true);
var isArrayBuffer = __webpack_require__(317);

/** @type {import('.')} */
module.exports = function byteLength(ab) {
  if (!isArrayBuffer(ab)) {
    return NaN;
  }
  return $byteLength ? $byteLength(ab) : ab.byteLength;
}; // in node < 0.11, byteLength is an own nonconfigurable property

/***/ }),
/* 336 */
/***/ (function(module) {

"use strict";
module.exports = /*#__PURE__*/JSON.parse('{"helpTitle":"Instruction","legalTitle":"legal","dateFormat":"MM/dd/yyyy","dateTimeFormat":"MM/dd/yyyy HH:mm:ss","timeFormat":"HH:mm:ss","decimalCharacter":".","decimalRegex":"^\\\\s*[\\\\+-]?([\\\\+-]?\\\\d+\\\\.?\\\\d*([eE]?[\\\\+|-]?\\\\d+)?|[\\\\+-]?\\\\d*\\\\.?\\\\d+[eE]?([\\\\+|-]?\\\\d+)?)\\\\s*$","placeholderSearchMultiOptionsOrString":"Search for or type values","placeholderSearchSingleOptionsOrString":"Search for or type a value","placeholderSelectMultiOptionsOrString":"Select one or more or type a value","placeholderSelectSingleOptionsOrString":"Select one or type a value","placeholderSearchMulti":"Search for values","placeholderSearchSingle":"Search for a value","placeholderSelectMulti":"Select one or more","placeholderSelectSingle":"Select one","placeholderDate":"MM/DD/YYYY","placeholderDateTime":"MM/DD/YYYY HH:MM:SS","placeholderTime":"HH:MM:SS","placeholderTypeANumber":"Type a number","placeholderTypeAValue":"Type a value","added":"Added ","removed":"Removed ","errorMessages":{"BL":"must be a boolean (true/false).","INT":"must be an integer number.","REAL":"must be a decimal number.","ST":"must be a string value.","TX":"must be a text value.","BIN":"must be a binary value.","DT":"must be a date value.","DTM":"must be a date and time value.","TM":"must be a time value.","RTO":"must be a ratio value.","QTY":"must be a decimal number.","NR":"must be two numeric values separated by a ^. One value can be omitted, but not the ^.","YEAR":"must be a numeric value of year.","MONTH":"must be a numeric value of month.","DAY":"must be a numeric value of day.","URL":"must be a valid URL.","EMAIL":"must be a valid email address.","PHONE":"must be a valid phone number."},"requiresAValue":"requires a value","mustBeGreater":"must be a value greater than {lformsParam}.","mustBeGreaterOrEqual":"must be a value greater than or equal to {lformsParam}.","mustBeLess":"must be a value less than {lformsParam}.","mustBeLessOrEqual":"must be a value less than or equal to {lformsParam}.","mustHaveTotalLength":"must have a total length of {lformsParam}.","mustHaveTotalLengthLessOrEqual":"must have a total length less than or equal to {lformsParam}.","mustHaveTotalLengthGreaterOrEqual":"must have a total length greater than or equal to {lformsParam}.","mustMatchRegex":"must match a RegExp pattern of {lformsParam}.","mustNotHaveMoreDecimalPlaces":"must not have more than {lformsParam} decimal places.","booleanYes":"Yes","booleanNo":"No","booleanNotAnswered":"Not Answered","pleaseEnterInfoForTheBlank":"Please enter info in the blank \\"{lformsParam}\\".","other":"Other","parsedDateFormats":["M/D/YYYY","M/D/YY","M/D","M-D-YYYY","M-D-YY","M-D","YYYY","YYYY-M-D","YYYY/M/D","M/D/YYYY HH:mm","M/D/YY HH:mm","M/D HH:mm","M-D-YYYY HH:mm","M-D-YY HH:mm","M-D HH:mm"]}');

/***/ }),
/* 337 */
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
// constants
const CONSTANTS = {
  DATA_CONTROL: {
    CONSTRUCTION_ARRAY: "ARRAY",
    CONSTRUCTION_OBJECT: "OBJECT",
    CONSTRUCTION_SIMPLE: "SIMPLE",
    SOURCE_INTERNAL: "INTERNAL",
    EXTERNAL: "EXTERNAL" // not supported yet
  },
  SKIP_LOGIC: {
    ACTION_ENABLE: "show",
    ACTION_DISABLE: "hide",
    // not supported yet
    STATUS_ENABLED: "target-enabled",
    STATUS_DISABLED: "target-disabled"
  },
  CALCULATION_METHOD: {
    TOTALSCORE: "TOTALSCORE",
    BMI: "BMI",
    BSA: "BSA"
  },
  DATA_TYPE: {
    INT: "INT",
    REAL: "REAL",
    ST: "ST",
    TX: "TX",
    DT: "DT",
    DTM: "DTM",
    TM: "TM",
    CNE: "CNE",
    // deprecated, replaced with CODING and item.answerConstraint: 'optionsOnly'
    CWE: "CWE",
    // deprecated, replaced with CODING and item.answerConstraint: 'optionsOrType' and/or 'optionsOrString'
    NR: "NR",
    YEAR: "YEAR",
    MONTH: "MONTH",
    DAY: "DAY",
    URL: "URL",
    EMAIL: "EMAIL",
    PHONE: "PHONE",
    SECTION: "SECTION",
    TITLE: "TITLE",
    QTY: "QTY",
    BL: "BL",
    CODING: "CODING" // R5 'coding'
    // BIN:    "BIN",   // not supported yet
    // RTO:    "RTO",   // not supported yet
  },
  DISPLAY_MODE: ['lg', 'md', 'sm', 'auto']
};
/* harmony default export */ __webpack_exports__["default"] = (CONSTANTS);

/***/ }),
/* 338 */
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   DefaultHandler: function() { return /* reexport safe */ domhandler__WEBPACK_IMPORTED_MODULE_1__.DomHandler; },
/* harmony export */   DomHandler: function() { return /* reexport safe */ domhandler__WEBPACK_IMPORTED_MODULE_1__.DomHandler; },
/* harmony export */   DomUtils: function() { return /* reexport module object */ domutils__WEBPACK_IMPORTED_MODULE_4__; },
/* harmony export */   ElementType: function() { return /* reexport module object */ domelementtype__WEBPACK_IMPORTED_MODULE_3__; },
/* harmony export */   Parser: function() { return /* reexport safe */ _Parser_js__WEBPACK_IMPORTED_MODULE_0__.Parser; },
/* harmony export */   QuoteType: function() { return /* reexport safe */ _Tokenizer_js__WEBPACK_IMPORTED_MODULE_2__.QuoteType; },
/* harmony export */   Tokenizer: function() { return /* reexport safe */ _Tokenizer_js__WEBPACK_IMPORTED_MODULE_2__["default"]; },
/* harmony export */   createDocumentStream: function() { return /* binding */ createDocumentStream; },
/* harmony export */   createDomStream: function() { return /* binding */ createDomStream; },
/* harmony export */   getFeed: function() { return /* reexport safe */ domutils__WEBPACK_IMPORTED_MODULE_4__.getFeed; },
/* harmony export */   parseDOM: function() { return /* binding */ parseDOM; },
/* harmony export */   parseDocument: function() { return /* binding */ parseDocument; },
/* harmony export */   parseFeed: function() { return /* binding */ parseFeed; }
/* harmony export */ });
/* harmony import */ var _Parser_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(339);
/* harmony import */ var domhandler__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(345);
/* harmony import */ var _Tokenizer_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(340);
/* harmony import */ var domelementtype__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(346);
/* harmony import */ var domutils__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(348);




// Helper methods
/**
 * Parses the data, returns the resulting document.
 *
 * @param data The data that should be parsed.
 * @param options Optional options for the parser and DOM handler.
 */
function parseDocument(data, options) {
  const handler = new domhandler__WEBPACK_IMPORTED_MODULE_1__.DomHandler(undefined, options);
  new _Parser_js__WEBPACK_IMPORTED_MODULE_0__.Parser(handler, options).end(data);
  return handler.root;
}
/**
 * Parses data, returns an array of the root nodes.
 *
 * Note that the root nodes still have a `Document` node as their parent.
 * Use `parseDocument` to get the `Document` node instead.
 *
 * @param data The data that should be parsed.
 * @param options Optional options for the parser and DOM handler.
 * @deprecated Use `parseDocument` instead.
 */
function parseDOM(data, options) {
  return parseDocument(data, options).children;
}
/**
 * Creates a parser instance, with an attached DOM handler.
 *
 * @param callback A callback that will be called once parsing has been completed, with the resulting document.
 * @param options Optional options for the parser and DOM handler.
 * @param elementCallback An optional callback that will be called every time a tag has been completed inside of the DOM.
 */
function createDocumentStream(callback, options, elementCallback) {
  const handler = new domhandler__WEBPACK_IMPORTED_MODULE_1__.DomHandler(error => callback(error, handler.root), options, elementCallback);
  return new _Parser_js__WEBPACK_IMPORTED_MODULE_0__.Parser(handler, options);
}
/**
 * Creates a parser instance, with an attached DOM handler.
 *
 * @param callback A callback that will be called once parsing has been completed, with an array of root nodes.
 * @param options Optional options for the parser and DOM handler.
 * @param elementCallback An optional callback that will be called every time a tag has been completed inside of the DOM.
 * @deprecated Use `createDocumentStream` instead.
 */
function createDomStream(callback, options, elementCallback) {
  const handler = new domhandler__WEBPACK_IMPORTED_MODULE_1__.DomHandler(callback, options, elementCallback);
  return new _Parser_js__WEBPACK_IMPORTED_MODULE_0__.Parser(handler, options);
}

/*
 * All of the following exports exist for backwards-compatibility.
 * They should probably be removed eventually.
 */



const parseFeedDefaultOptions = {
  xmlMode: true
};
/**
 * Parse a feed.
 *
 * @param feed The feed that should be parsed, as a string.
 * @param options Optionally, options for parsing. When using this, you should set `xmlMode` to `true`.
 */
function parseFeed(feed, options = parseFeedDefaultOptions) {
  return (0,domutils__WEBPACK_IMPORTED_MODULE_4__.getFeed)(parseDOM(feed, options));
}


/***/ }),
/* 339 */
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Parser: function() { return /* binding */ Parser; }
/* harmony export */ });
/* harmony import */ var _Tokenizer_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(340);
/* harmony import */ var entities_lib_decode_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(341);


const formTags = new Set(["input", "option", "optgroup", "select", "button", "datalist", "textarea"]);
const pTag = new Set(["p"]);
const tableSectionTags = new Set(["thead", "tbody"]);
const ddtTags = new Set(["dd", "dt"]);
const rtpTags = new Set(["rt", "rp"]);
const openImpliesClose = new Map([["tr", new Set(["tr", "th", "td"])], ["th", new Set(["th"])], ["td", new Set(["thead", "th", "td"])], ["body", new Set(["head", "link", "script"])], ["li", new Set(["li"])], ["p", pTag], ["h1", pTag], ["h2", pTag], ["h3", pTag], ["h4", pTag], ["h5", pTag], ["h6", pTag], ["select", formTags], ["input", formTags], ["output", formTags], ["button", formTags], ["datalist", formTags], ["textarea", formTags], ["option", new Set(["option"])], ["optgroup", new Set(["optgroup", "option"])], ["dd", ddtTags], ["dt", ddtTags], ["address", pTag], ["article", pTag], ["aside", pTag], ["blockquote", pTag], ["details", pTag], ["div", pTag], ["dl", pTag], ["fieldset", pTag], ["figcaption", pTag], ["figure", pTag], ["footer", pTag], ["form", pTag], ["header", pTag], ["hr", pTag], ["main", pTag], ["nav", pTag], ["ol", pTag], ["pre", pTag], ["section", pTag], ["table", pTag], ["ul", pTag], ["rt", rtpTags], ["rp", rtpTags], ["tbody", tableSectionTags], ["tfoot", tableSectionTags]]);
const voidElements = new Set(["area", "base", "basefont", "br", "col", "command", "embed", "frame", "hr", "img", "input", "isindex", "keygen", "link", "meta", "param", "source", "track", "wbr"]);
const foreignContextElements = new Set(["math", "svg"]);
const htmlIntegrationElements = new Set(["mi", "mo", "mn", "ms", "mtext", "annotation-xml", "foreignobject", "desc", "title"]);
const reNameEnd = /\s|\//;
class Parser {
  constructor(cbs, options = {}) {
    var _a, _b, _c, _d, _e, _f;
    this.options = options;
    /** The start index of the last event. */
    this.startIndex = 0;
    /** The end index of the last event. */
    this.endIndex = 0;
    /**
     * Store the start index of the current open tag,
     * so we can update the start index for attributes.
     */
    this.openTagStart = 0;
    this.tagname = "";
    this.attribname = "";
    this.attribvalue = "";
    this.attribs = null;
    this.stack = [];
    this.buffers = [];
    this.bufferOffset = 0;
    /** The index of the last written buffer. Used when resuming after a `pause()`. */
    this.writeIndex = 0;
    /** Indicates whether the parser has finished running / `.end` has been called. */
    this.ended = false;
    this.cbs = cbs !== null && cbs !== void 0 ? cbs : {};
    this.htmlMode = !this.options.xmlMode;
    this.lowerCaseTagNames = (_a = options.lowerCaseTags) !== null && _a !== void 0 ? _a : this.htmlMode;
    this.lowerCaseAttributeNames = (_b = options.lowerCaseAttributeNames) !== null && _b !== void 0 ? _b : this.htmlMode;
    this.recognizeSelfClosing = (_c = options.recognizeSelfClosing) !== null && _c !== void 0 ? _c : !this.htmlMode;
    this.tokenizer = new ((_d = options.Tokenizer) !== null && _d !== void 0 ? _d : _Tokenizer_js__WEBPACK_IMPORTED_MODULE_0__["default"])(this.options, this);
    this.foreignContext = [!this.htmlMode];
    (_f = (_e = this.cbs).onparserinit) === null || _f === void 0 ? void 0 : _f.call(_e, this);
  }
  // Tokenizer event handlers
  /** @internal */
  ontext(start, endIndex) {
    var _a, _b;
    const data = this.getSlice(start, endIndex);
    this.endIndex = endIndex - 1;
    (_b = (_a = this.cbs).ontext) === null || _b === void 0 ? void 0 : _b.call(_a, data);
    this.startIndex = endIndex;
  }
  /** @internal */
  ontextentity(cp, endIndex) {
    var _a, _b;
    this.endIndex = endIndex - 1;
    (_b = (_a = this.cbs).ontext) === null || _b === void 0 ? void 0 : _b.call(_a, (0,entities_lib_decode_js__WEBPACK_IMPORTED_MODULE_1__.fromCodePoint)(cp));
    this.startIndex = endIndex;
  }
  /**
   * Checks if the current tag is a void element. Override this if you want
   * to specify your own additional void elements.
   */
  isVoidElement(name) {
    return this.htmlMode && voidElements.has(name);
  }
  /** @internal */
  onopentagname(start, endIndex) {
    this.endIndex = endIndex;
    let name = this.getSlice(start, endIndex);
    if (this.lowerCaseTagNames) {
      name = name.toLowerCase();
    }
    this.emitOpenTag(name);
  }
  emitOpenTag(name) {
    var _a, _b, _c, _d;
    this.openTagStart = this.startIndex;
    this.tagname = name;
    const impliesClose = this.htmlMode && openImpliesClose.get(name);
    if (impliesClose) {
      while (this.stack.length > 0 && impliesClose.has(this.stack[0])) {
        const element = this.stack.shift();
        (_b = (_a = this.cbs).onclosetag) === null || _b === void 0 ? void 0 : _b.call(_a, element, true);
      }
    }
    if (!this.isVoidElement(name)) {
      this.stack.unshift(name);
      if (this.htmlMode) {
        if (foreignContextElements.has(name)) {
          this.foreignContext.unshift(true);
        } else if (htmlIntegrationElements.has(name)) {
          this.foreignContext.unshift(false);
        }
      }
    }
    (_d = (_c = this.cbs).onopentagname) === null || _d === void 0 ? void 0 : _d.call(_c, name);
    if (this.cbs.onopentag) this.attribs = {};
  }
  endOpenTag(isImplied) {
    var _a, _b;
    this.startIndex = this.openTagStart;
    if (this.attribs) {
      (_b = (_a = this.cbs).onopentag) === null || _b === void 0 ? void 0 : _b.call(_a, this.tagname, this.attribs, isImplied);
      this.attribs = null;
    }
    if (this.cbs.onclosetag && this.isVoidElement(this.tagname)) {
      this.cbs.onclosetag(this.tagname, true);
    }
    this.tagname = "";
  }
  /** @internal */
  onopentagend(endIndex) {
    this.endIndex = endIndex;
    this.endOpenTag(false);
    // Set `startIndex` for next node
    this.startIndex = endIndex + 1;
  }
  /** @internal */
  onclosetag(start, endIndex) {
    var _a, _b, _c, _d, _e, _f, _g, _h;
    this.endIndex = endIndex;
    let name = this.getSlice(start, endIndex);
    if (this.lowerCaseTagNames) {
      name = name.toLowerCase();
    }
    if (this.htmlMode && (foreignContextElements.has(name) || htmlIntegrationElements.has(name))) {
      this.foreignContext.shift();
    }
    if (!this.isVoidElement(name)) {
      const pos = this.stack.indexOf(name);
      if (pos !== -1) {
        for (let index = 0; index <= pos; index++) {
          const element = this.stack.shift();
          // We know the stack has sufficient elements.
          (_b = (_a = this.cbs).onclosetag) === null || _b === void 0 ? void 0 : _b.call(_a, element, index !== pos);
        }
      } else if (this.htmlMode && name === "p") {
        // Implicit open before close
        this.emitOpenTag("p");
        this.closeCurrentTag(true);
      }
    } else if (this.htmlMode && name === "br") {
      // We can't use `emitOpenTag` for implicit open, as `br` would be implicitly closed.
      (_d = (_c = this.cbs).onopentagname) === null || _d === void 0 ? void 0 : _d.call(_c, "br");
      (_f = (_e = this.cbs).onopentag) === null || _f === void 0 ? void 0 : _f.call(_e, "br", {}, true);
      (_h = (_g = this.cbs).onclosetag) === null || _h === void 0 ? void 0 : _h.call(_g, "br", false);
    }
    // Set `startIndex` for next node
    this.startIndex = endIndex + 1;
  }
  /** @internal */
  onselfclosingtag(endIndex) {
    this.endIndex = endIndex;
    if (this.recognizeSelfClosing || this.foreignContext[0]) {
      this.closeCurrentTag(false);
      // Set `startIndex` for next node
      this.startIndex = endIndex + 1;
    } else {
      // Ignore the fact that the tag is self-closing.
      this.onopentagend(endIndex);
    }
  }
  closeCurrentTag(isOpenImplied) {
    var _a, _b;
    const name = this.tagname;
    this.endOpenTag(isOpenImplied);
    // Self-closing tags will be on the top of the stack
    if (this.stack[0] === name) {
      // If the opening tag isn't implied, the closing tag has to be implied.
      (_b = (_a = this.cbs).onclosetag) === null || _b === void 0 ? void 0 : _b.call(_a, name, !isOpenImplied);
      this.stack.shift();
    }
  }
  /** @internal */
  onattribname(start, endIndex) {
    this.startIndex = start;
    const name = this.getSlice(start, endIndex);
    this.attribname = this.lowerCaseAttributeNames ? name.toLowerCase() : name;
  }
  /** @internal */
  onattribdata(start, endIndex) {
    this.attribvalue += this.getSlice(start, endIndex);
  }
  /** @internal */
  onattribentity(cp) {
    this.attribvalue += (0,entities_lib_decode_js__WEBPACK_IMPORTED_MODULE_1__.fromCodePoint)(cp);
  }
  /** @internal */
  onattribend(quote, endIndex) {
    var _a, _b;
    this.endIndex = endIndex;
    (_b = (_a = this.cbs).onattribute) === null || _b === void 0 ? void 0 : _b.call(_a, this.attribname, this.attribvalue, quote === _Tokenizer_js__WEBPACK_IMPORTED_MODULE_0__.QuoteType.Double ? '"' : quote === _Tokenizer_js__WEBPACK_IMPORTED_MODULE_0__.QuoteType.Single ? "'" : quote === _Tokenizer_js__WEBPACK_IMPORTED_MODULE_0__.QuoteType.NoValue ? undefined : null);
    if (this.attribs && !Object.prototype.hasOwnProperty.call(this.attribs, this.attribname)) {
      this.attribs[this.attribname] = this.attribvalue;
    }
    this.attribvalue = "";
  }
  getInstructionName(value) {
    const index = value.search(reNameEnd);
    let name = index < 0 ? value : value.substr(0, index);
    if (this.lowerCaseTagNames) {
      name = name.toLowerCase();
    }
    return name;
  }
  /** @internal */
  ondeclaration(start, endIndex) {
    this.endIndex = endIndex;
    const value = this.getSlice(start, endIndex);
    if (this.cbs.onprocessinginstruction) {
      const name = this.getInstructionName(value);
      this.cbs.onprocessinginstruction(`!${name}`, `!${value}`);
    }
    // Set `startIndex` for next node
    this.startIndex = endIndex + 1;
  }
  /** @internal */
  onprocessinginstruction(start, endIndex) {
    this.endIndex = endIndex;
    const value = this.getSlice(start, endIndex);
    if (this.cbs.onprocessinginstruction) {
      const name = this.getInstructionName(value);
      this.cbs.onprocessinginstruction(`?${name}`, `?${value}`);
    }
    // Set `startIndex` for next node
    this.startIndex = endIndex + 1;
  }
  /** @internal */
  oncomment(start, endIndex, offset) {
    var _a, _b, _c, _d;
    this.endIndex = endIndex;
    (_b = (_a = this.cbs).oncomment) === null || _b === void 0 ? void 0 : _b.call(_a, this.getSlice(start, endIndex - offset));
    (_d = (_c = this.cbs).oncommentend) === null || _d === void 0 ? void 0 : _d.call(_c);
    // Set `startIndex` for next node
    this.startIndex = endIndex + 1;
  }
  /** @internal */
  oncdata(start, endIndex, offset) {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
    this.endIndex = endIndex;
    const value = this.getSlice(start, endIndex - offset);
    if (!this.htmlMode || this.options.recognizeCDATA) {
      (_b = (_a = this.cbs).oncdatastart) === null || _b === void 0 ? void 0 : _b.call(_a);
      (_d = (_c = this.cbs).ontext) === null || _d === void 0 ? void 0 : _d.call(_c, value);
      (_f = (_e = this.cbs).oncdataend) === null || _f === void 0 ? void 0 : _f.call(_e);
    } else {
      (_h = (_g = this.cbs).oncomment) === null || _h === void 0 ? void 0 : _h.call(_g, `[CDATA[${value}]]`);
      (_k = (_j = this.cbs).oncommentend) === null || _k === void 0 ? void 0 : _k.call(_j);
    }
    // Set `startIndex` for next node
    this.startIndex = endIndex + 1;
  }
  /** @internal */
  onend() {
    var _a, _b;
    if (this.cbs.onclosetag) {
      // Set the end index for all remaining tags
      this.endIndex = this.startIndex;
      for (let index = 0; index < this.stack.length; index++) {
        this.cbs.onclosetag(this.stack[index], true);
      }
    }
    (_b = (_a = this.cbs).onend) === null || _b === void 0 ? void 0 : _b.call(_a);
  }
  /**
   * Resets the parser to a blank state, ready to parse a new HTML document
   */
  reset() {
    var _a, _b, _c, _d;
    (_b = (_a = this.cbs).onreset) === null || _b === void 0 ? void 0 : _b.call(_a);
    this.tokenizer.reset();
    this.tagname = "";
    this.attribname = "";
    this.attribs = null;
    this.stack.length = 0;
    this.startIndex = 0;
    this.endIndex = 0;
    (_d = (_c = this.cbs).onparserinit) === null || _d === void 0 ? void 0 : _d.call(_c, this);
    this.buffers.length = 0;
    this.foreignContext.length = 0;
    this.foreignContext.unshift(!this.htmlMode);
    this.bufferOffset = 0;
    this.writeIndex = 0;
    this.ended = false;
  }
  /**
   * Resets the parser, then parses a complete document and
   * pushes it to the handler.
   *
   * @param data Document to parse.
   */
  parseComplete(data) {
    this.reset();
    this.end(data);
  }
  getSlice(start, end) {
    while (start - this.bufferOffset >= this.buffers[0].length) {
      this.shiftBuffer();
    }
    let slice = this.buffers[0].slice(start - this.bufferOffset, end - this.bufferOffset);
    while (end - this.bufferOffset > this.buffers[0].length) {
      this.shiftBuffer();
      slice += this.buffers[0].slice(0, end - this.bufferOffset);
    }
    return slice;
  }
  shiftBuffer() {
    this.bufferOffset += this.buffers[0].length;
    this.writeIndex--;
    this.buffers.shift();
  }
  /**
   * Parses a chunk of data and calls the corresponding callbacks.
   *
   * @param chunk Chunk to parse.
   */
  write(chunk) {
    var _a, _b;
    if (this.ended) {
      (_b = (_a = this.cbs).onerror) === null || _b === void 0 ? void 0 : _b.call(_a, new Error(".write() after done!"));
      return;
    }
    this.buffers.push(chunk);
    if (this.tokenizer.running) {
      this.tokenizer.write(chunk);
      this.writeIndex++;
    }
  }
  /**
   * Parses the end of the buffer and clears the stack, calls onend.
   *
   * @param chunk Optional final chunk to parse.
   */
  end(chunk) {
    var _a, _b;
    if (this.ended) {
      (_b = (_a = this.cbs).onerror) === null || _b === void 0 ? void 0 : _b.call(_a, new Error(".end() after done!"));
      return;
    }
    if (chunk) this.write(chunk);
    this.ended = true;
    this.tokenizer.end();
  }
  /**
   * Pauses parsing. The parser won't emit events until `resume` is called.
   */
  pause() {
    this.tokenizer.pause();
  }
  /**
   * Resumes parsing after `pause` was called.
   */
  resume() {
    this.tokenizer.resume();
    while (this.tokenizer.running && this.writeIndex < this.buffers.length) {
      this.tokenizer.write(this.buffers[this.writeIndex++]);
    }
    if (this.ended) this.tokenizer.end();
  }
  /**
   * Alias of `write`, for backwards compatibility.
   *
   * @param chunk Chunk to parse.
   * @deprecated
   */
  parseChunk(chunk) {
    this.write(chunk);
  }
  /**
   * Alias of `end`, for backwards compatibility.
   *
   * @param chunk Optional final chunk to parse.
   * @deprecated
   */
  done(chunk) {
    this.end(chunk);
  }
}

/***/ }),
/* 340 */
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   QuoteType: function() { return /* binding */ QuoteType; },
/* harmony export */   "default": function() { return /* binding */ Tokenizer; }
/* harmony export */ });
/* harmony import */ var entities_lib_decode_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(341);

var CharCodes;
(function (CharCodes) {
  CharCodes[CharCodes["Tab"] = 9] = "Tab";
  CharCodes[CharCodes["NewLine"] = 10] = "NewLine";
  CharCodes[CharCodes["FormFeed"] = 12] = "FormFeed";
  CharCodes[CharCodes["CarriageReturn"] = 13] = "CarriageReturn";
  CharCodes[CharCodes["Space"] = 32] = "Space";
  CharCodes[CharCodes["ExclamationMark"] = 33] = "ExclamationMark";
  CharCodes[CharCodes["Number"] = 35] = "Number";
  CharCodes[CharCodes["Amp"] = 38] = "Amp";
  CharCodes[CharCodes["SingleQuote"] = 39] = "SingleQuote";
  CharCodes[CharCodes["DoubleQuote"] = 34] = "DoubleQuote";
  CharCodes[CharCodes["Dash"] = 45] = "Dash";
  CharCodes[CharCodes["Slash"] = 47] = "Slash";
  CharCodes[CharCodes["Zero"] = 48] = "Zero";
  CharCodes[CharCodes["Nine"] = 57] = "Nine";
  CharCodes[CharCodes["Semi"] = 59] = "Semi";
  CharCodes[CharCodes["Lt"] = 60] = "Lt";
  CharCodes[CharCodes["Eq"] = 61] = "Eq";
  CharCodes[CharCodes["Gt"] = 62] = "Gt";
  CharCodes[CharCodes["Questionmark"] = 63] = "Questionmark";
  CharCodes[CharCodes["UpperA"] = 65] = "UpperA";
  CharCodes[CharCodes["LowerA"] = 97] = "LowerA";
  CharCodes[CharCodes["UpperF"] = 70] = "UpperF";
  CharCodes[CharCodes["LowerF"] = 102] = "LowerF";
  CharCodes[CharCodes["UpperZ"] = 90] = "UpperZ";
  CharCodes[CharCodes["LowerZ"] = 122] = "LowerZ";
  CharCodes[CharCodes["LowerX"] = 120] = "LowerX";
  CharCodes[CharCodes["OpeningSquareBracket"] = 91] = "OpeningSquareBracket";
})(CharCodes || (CharCodes = {}));
/** All the states the tokenizer can be in. */
var State;
(function (State) {
  State[State["Text"] = 1] = "Text";
  State[State["BeforeTagName"] = 2] = "BeforeTagName";
  State[State["InTagName"] = 3] = "InTagName";
  State[State["InSelfClosingTag"] = 4] = "InSelfClosingTag";
  State[State["BeforeClosingTagName"] = 5] = "BeforeClosingTagName";
  State[State["InClosingTagName"] = 6] = "InClosingTagName";
  State[State["AfterClosingTagName"] = 7] = "AfterClosingTagName";
  // Attributes
  State[State["BeforeAttributeName"] = 8] = "BeforeAttributeName";
  State[State["InAttributeName"] = 9] = "InAttributeName";
  State[State["AfterAttributeName"] = 10] = "AfterAttributeName";
  State[State["BeforeAttributeValue"] = 11] = "BeforeAttributeValue";
  State[State["InAttributeValueDq"] = 12] = "InAttributeValueDq";
  State[State["InAttributeValueSq"] = 13] = "InAttributeValueSq";
  State[State["InAttributeValueNq"] = 14] = "InAttributeValueNq";
  // Declarations
  State[State["BeforeDeclaration"] = 15] = "BeforeDeclaration";
  State[State["InDeclaration"] = 16] = "InDeclaration";
  // Processing instructions
  State[State["InProcessingInstruction"] = 17] = "InProcessingInstruction";
  // Comments & CDATA
  State[State["BeforeComment"] = 18] = "BeforeComment";
  State[State["CDATASequence"] = 19] = "CDATASequence";
  State[State["InSpecialComment"] = 20] = "InSpecialComment";
  State[State["InCommentLike"] = 21] = "InCommentLike";
  // Special tags
  State[State["BeforeSpecialS"] = 22] = "BeforeSpecialS";
  State[State["BeforeSpecialT"] = 23] = "BeforeSpecialT";
  State[State["SpecialStartSequence"] = 24] = "SpecialStartSequence";
  State[State["InSpecialTag"] = 25] = "InSpecialTag";
  State[State["InEntity"] = 26] = "InEntity";
})(State || (State = {}));
function isWhitespace(c) {
  return c === CharCodes.Space || c === CharCodes.NewLine || c === CharCodes.Tab || c === CharCodes.FormFeed || c === CharCodes.CarriageReturn;
}
function isEndOfTagSection(c) {
  return c === CharCodes.Slash || c === CharCodes.Gt || isWhitespace(c);
}
function isASCIIAlpha(c) {
  return c >= CharCodes.LowerA && c <= CharCodes.LowerZ || c >= CharCodes.UpperA && c <= CharCodes.UpperZ;
}
var QuoteType;
(function (QuoteType) {
  QuoteType[QuoteType["NoValue"] = 0] = "NoValue";
  QuoteType[QuoteType["Unquoted"] = 1] = "Unquoted";
  QuoteType[QuoteType["Single"] = 2] = "Single";
  QuoteType[QuoteType["Double"] = 3] = "Double";
})(QuoteType || (QuoteType = {}));
/**
 * Sequences used to match longer strings.
 *
 * We don't have `Script`, `Style`, or `Title` here. Instead, we re-use the *End
 * sequences with an increased offset.
 */
const Sequences = {
  Cdata: new Uint8Array([0x43, 0x44, 0x41, 0x54, 0x41, 0x5b]),
  // CDATA[
  CdataEnd: new Uint8Array([0x5d, 0x5d, 0x3e]),
  // ]]>
  CommentEnd: new Uint8Array([0x2d, 0x2d, 0x3e]),
  // `-->`
  ScriptEnd: new Uint8Array([0x3c, 0x2f, 0x73, 0x63, 0x72, 0x69, 0x70, 0x74]),
  // `</script`
  StyleEnd: new Uint8Array([0x3c, 0x2f, 0x73, 0x74, 0x79, 0x6c, 0x65]),
  // `</style`
  TitleEnd: new Uint8Array([0x3c, 0x2f, 0x74, 0x69, 0x74, 0x6c, 0x65]),
  // `</title`
  TextareaEnd: new Uint8Array([0x3c, 0x2f, 0x74, 0x65, 0x78, 0x74, 0x61, 0x72, 0x65, 0x61]) // `</textarea`
};
class Tokenizer {
  constructor({
    xmlMode = false,
    decodeEntities = true
  }, cbs) {
    this.cbs = cbs;
    /** The current state the tokenizer is in. */
    this.state = State.Text;
    /** The read buffer. */
    this.buffer = "";
    /** The beginning of the section that is currently being read. */
    this.sectionStart = 0;
    /** The index within the buffer that we are currently looking at. */
    this.index = 0;
    /** The start of the last entity. */
    this.entityStart = 0;
    /** Some behavior, eg. when decoding entities, is done while we are in another state. This keeps track of the other state type. */
    this.baseState = State.Text;
    /** For special parsing behavior inside of script and style tags. */
    this.isSpecial = false;
    /** Indicates whether the tokenizer has been paused. */
    this.running = true;
    /** The offset of the current buffer. */
    this.offset = 0;
    this.currentSequence = undefined;
    this.sequenceIndex = 0;
    this.xmlMode = xmlMode;
    this.decodeEntities = decodeEntities;
    this.entityDecoder = new entities_lib_decode_js__WEBPACK_IMPORTED_MODULE_0__.EntityDecoder(xmlMode ? entities_lib_decode_js__WEBPACK_IMPORTED_MODULE_0__.xmlDecodeTree : entities_lib_decode_js__WEBPACK_IMPORTED_MODULE_0__.htmlDecodeTree, (cp, consumed) => this.emitCodePoint(cp, consumed));
  }
  reset() {
    this.state = State.Text;
    this.buffer = "";
    this.sectionStart = 0;
    this.index = 0;
    this.baseState = State.Text;
    this.currentSequence = undefined;
    this.running = true;
    this.offset = 0;
  }
  write(chunk) {
    this.offset += this.buffer.length;
    this.buffer = chunk;
    this.parse();
  }
  end() {
    if (this.running) this.finish();
  }
  pause() {
    this.running = false;
  }
  resume() {
    this.running = true;
    if (this.index < this.buffer.length + this.offset) {
      this.parse();
    }
  }
  stateText(c) {
    if (c === CharCodes.Lt || !this.decodeEntities && this.fastForwardTo(CharCodes.Lt)) {
      if (this.index > this.sectionStart) {
        this.cbs.ontext(this.sectionStart, this.index);
      }
      this.state = State.BeforeTagName;
      this.sectionStart = this.index;
    } else if (this.decodeEntities && c === CharCodes.Amp) {
      this.startEntity();
    }
  }
  stateSpecialStartSequence(c) {
    const isEnd = this.sequenceIndex === this.currentSequence.length;
    const isMatch = isEnd ?
    // If we are at the end of the sequence, make sure the tag name has ended
    isEndOfTagSection(c) :
    // Otherwise, do a case-insensitive comparison
    (c | 0x20) === this.currentSequence[this.sequenceIndex];
    if (!isMatch) {
      this.isSpecial = false;
    } else if (!isEnd) {
      this.sequenceIndex++;
      return;
    }
    this.sequenceIndex = 0;
    this.state = State.InTagName;
    this.stateInTagName(c);
  }
  /** Look for an end tag. For <title> tags, also decode entities. */
  stateInSpecialTag(c) {
    if (this.sequenceIndex === this.currentSequence.length) {
      if (c === CharCodes.Gt || isWhitespace(c)) {
        const endOfText = this.index - this.currentSequence.length;
        if (this.sectionStart < endOfText) {
          // Spoof the index so that reported locations match up.
          const actualIndex = this.index;
          this.index = endOfText;
          this.cbs.ontext(this.sectionStart, endOfText);
          this.index = actualIndex;
        }
        this.isSpecial = false;
        this.sectionStart = endOfText + 2; // Skip over the `</`
        this.stateInClosingTagName(c);
        return; // We are done; skip the rest of the function.
      }
      this.sequenceIndex = 0;
    }
    if ((c | 0x20) === this.currentSequence[this.sequenceIndex]) {
      this.sequenceIndex += 1;
    } else if (this.sequenceIndex === 0) {
      if (this.currentSequence === Sequences.TitleEnd) {
        // We have to parse entities in <title> tags.
        if (this.decodeEntities && c === CharCodes.Amp) {
          this.startEntity();
        }
      } else if (this.fastForwardTo(CharCodes.Lt)) {
        // Outside of <title> tags, we can fast-forward.
        this.sequenceIndex = 1;
      }
    } else {
      // If we see a `<`, set the sequence index to 1; useful for eg. `<</script>`.
      this.sequenceIndex = Number(c === CharCodes.Lt);
    }
  }
  stateCDATASequence(c) {
    if (c === Sequences.Cdata[this.sequenceIndex]) {
      if (++this.sequenceIndex === Sequences.Cdata.length) {
        this.state = State.InCommentLike;
        this.currentSequence = Sequences.CdataEnd;
        this.sequenceIndex = 0;
        this.sectionStart = this.index + 1;
      }
    } else {
      this.sequenceIndex = 0;
      this.state = State.InDeclaration;
      this.stateInDeclaration(c); // Reconsume the character
    }
  }
  /**
   * When we wait for one specific character, we can speed things up
   * by skipping through the buffer until we find it.
   *
   * @returns Whether the character was found.
   */
  fastForwardTo(c) {
    while (++this.index < this.buffer.length + this.offset) {
      if (this.buffer.charCodeAt(this.index - this.offset) === c) {
        return true;
      }
    }
    /*
     * We increment the index at the end of the `parse` loop,
     * so set it to `buffer.length - 1` here.
     *
     * TODO: Refactor `parse` to increment index before calling states.
     */
    this.index = this.buffer.length + this.offset - 1;
    return false;
  }
  /**
   * Comments and CDATA end with `-->` and `]]>`.
   *
   * Their common qualities are:
   * - Their end sequences have a distinct character they start with.
   * - That character is then repeated, so we have to check multiple repeats.
   * - All characters but the start character of the sequence can be skipped.
   */
  stateInCommentLike(c) {
    if (c === this.currentSequence[this.sequenceIndex]) {
      if (++this.sequenceIndex === this.currentSequence.length) {
        if (this.currentSequence === Sequences.CdataEnd) {
          this.cbs.oncdata(this.sectionStart, this.index, 2);
        } else {
          this.cbs.oncomment(this.sectionStart, this.index, 2);
        }
        this.sequenceIndex = 0;
        this.sectionStart = this.index + 1;
        this.state = State.Text;
      }
    } else if (this.sequenceIndex === 0) {
      // Fast-forward to the first character of the sequence
      if (this.fastForwardTo(this.currentSequence[0])) {
        this.sequenceIndex = 1;
      }
    } else if (c !== this.currentSequence[this.sequenceIndex - 1]) {
      // Allow long sequences, eg. --->, ]]]>
      this.sequenceIndex = 0;
    }
  }
  /**
   * HTML only allows ASCII alpha characters (a-z and A-Z) at the beginning of a tag name.
   *
   * XML allows a lot more characters here (@see https://www.w3.org/TR/REC-xml/#NT-NameStartChar).
   * We allow anything that wouldn't end the tag.
   */
  isTagStartChar(c) {
    return this.xmlMode ? !isEndOfTagSection(c) : isASCIIAlpha(c);
  }
  startSpecial(sequence, offset) {
    this.isSpecial = true;
    this.currentSequence = sequence;
    this.sequenceIndex = offset;
    this.state = State.SpecialStartSequence;
  }
  stateBeforeTagName(c) {
    if (c === CharCodes.ExclamationMark) {
      this.state = State.BeforeDeclaration;
      this.sectionStart = this.index + 1;
    } else if (c === CharCodes.Questionmark) {
      this.state = State.InProcessingInstruction;
      this.sectionStart = this.index + 1;
    } else if (this.isTagStartChar(c)) {
      const lower = c | 0x20;
      this.sectionStart = this.index;
      if (this.xmlMode) {
        this.state = State.InTagName;
      } else if (lower === Sequences.ScriptEnd[2]) {
        this.state = State.BeforeSpecialS;
      } else if (lower === Sequences.TitleEnd[2]) {
        this.state = State.BeforeSpecialT;
      } else {
        this.state = State.InTagName;
      }
    } else if (c === CharCodes.Slash) {
      this.state = State.BeforeClosingTagName;
    } else {
      this.state = State.Text;
      this.stateText(c);
    }
  }
  stateInTagName(c) {
    if (isEndOfTagSection(c)) {
      this.cbs.onopentagname(this.sectionStart, this.index);
      this.sectionStart = -1;
      this.state = State.BeforeAttributeName;
      this.stateBeforeAttributeName(c);
    }
  }
  stateBeforeClosingTagName(c) {
    if (isWhitespace(c)) {
      // Ignore
    } else if (c === CharCodes.Gt) {
      this.state = State.Text;
    } else {
      this.state = this.isTagStartChar(c) ? State.InClosingTagName : State.InSpecialComment;
      this.sectionStart = this.index;
    }
  }
  stateInClosingTagName(c) {
    if (c === CharCodes.Gt || isWhitespace(c)) {
      this.cbs.onclosetag(this.sectionStart, this.index);
      this.sectionStart = -1;
      this.state = State.AfterClosingTagName;
      this.stateAfterClosingTagName(c);
    }
  }
  stateAfterClosingTagName(c) {
    // Skip everything until ">"
    if (c === CharCodes.Gt || this.fastForwardTo(CharCodes.Gt)) {
      this.state = State.Text;
      this.sectionStart = this.index + 1;
    }
  }
  stateBeforeAttributeName(c) {
    if (c === CharCodes.Gt) {
      this.cbs.onopentagend(this.index);
      if (this.isSpecial) {
        this.state = State.InSpecialTag;
        this.sequenceIndex = 0;
      } else {
        this.state = State.Text;
      }
      this.sectionStart = this.index + 1;
    } else if (c === CharCodes.Slash) {
      this.state = State.InSelfClosingTag;
    } else if (!isWhitespace(c)) {
      this.state = State.InAttributeName;
      this.sectionStart = this.index;
    }
  }
  stateInSelfClosingTag(c) {
    if (c === CharCodes.Gt) {
      this.cbs.onselfclosingtag(this.index);
      this.state = State.Text;
      this.sectionStart = this.index + 1;
      this.isSpecial = false; // Reset special state, in case of self-closing special tags
    } else if (!isWhitespace(c)) {
      this.state = State.BeforeAttributeName;
      this.stateBeforeAttributeName(c);
    }
  }
  stateInAttributeName(c) {
    if (c === CharCodes.Eq || isEndOfTagSection(c)) {
      this.cbs.onattribname(this.sectionStart, this.index);
      this.sectionStart = this.index;
      this.state = State.AfterAttributeName;
      this.stateAfterAttributeName(c);
    }
  }
  stateAfterAttributeName(c) {
    if (c === CharCodes.Eq) {
      this.state = State.BeforeAttributeValue;
    } else if (c === CharCodes.Slash || c === CharCodes.Gt) {
      this.cbs.onattribend(QuoteType.NoValue, this.sectionStart);
      this.sectionStart = -1;
      this.state = State.BeforeAttributeName;
      this.stateBeforeAttributeName(c);
    } else if (!isWhitespace(c)) {
      this.cbs.onattribend(QuoteType.NoValue, this.sectionStart);
      this.state = State.InAttributeName;
      this.sectionStart = this.index;
    }
  }
  stateBeforeAttributeValue(c) {
    if (c === CharCodes.DoubleQuote) {
      this.state = State.InAttributeValueDq;
      this.sectionStart = this.index + 1;
    } else if (c === CharCodes.SingleQuote) {
      this.state = State.InAttributeValueSq;
      this.sectionStart = this.index + 1;
    } else if (!isWhitespace(c)) {
      this.sectionStart = this.index;
      this.state = State.InAttributeValueNq;
      this.stateInAttributeValueNoQuotes(c); // Reconsume token
    }
  }
  handleInAttributeValue(c, quote) {
    if (c === quote || !this.decodeEntities && this.fastForwardTo(quote)) {
      this.cbs.onattribdata(this.sectionStart, this.index);
      this.sectionStart = -1;
      this.cbs.onattribend(quote === CharCodes.DoubleQuote ? QuoteType.Double : QuoteType.Single, this.index + 1);
      this.state = State.BeforeAttributeName;
    } else if (this.decodeEntities && c === CharCodes.Amp) {
      this.startEntity();
    }
  }
  stateInAttributeValueDoubleQuotes(c) {
    this.handleInAttributeValue(c, CharCodes.DoubleQuote);
  }
  stateInAttributeValueSingleQuotes(c) {
    this.handleInAttributeValue(c, CharCodes.SingleQuote);
  }
  stateInAttributeValueNoQuotes(c) {
    if (isWhitespace(c) || c === CharCodes.Gt) {
      this.cbs.onattribdata(this.sectionStart, this.index);
      this.sectionStart = -1;
      this.cbs.onattribend(QuoteType.Unquoted, this.index);
      this.state = State.BeforeAttributeName;
      this.stateBeforeAttributeName(c);
    } else if (this.decodeEntities && c === CharCodes.Amp) {
      this.startEntity();
    }
  }
  stateBeforeDeclaration(c) {
    if (c === CharCodes.OpeningSquareBracket) {
      this.state = State.CDATASequence;
      this.sequenceIndex = 0;
    } else {
      this.state = c === CharCodes.Dash ? State.BeforeComment : State.InDeclaration;
    }
  }
  stateInDeclaration(c) {
    if (c === CharCodes.Gt || this.fastForwardTo(CharCodes.Gt)) {
      this.cbs.ondeclaration(this.sectionStart, this.index);
      this.state = State.Text;
      this.sectionStart = this.index + 1;
    }
  }
  stateInProcessingInstruction(c) {
    if (c === CharCodes.Gt || this.fastForwardTo(CharCodes.Gt)) {
      this.cbs.onprocessinginstruction(this.sectionStart, this.index);
      this.state = State.Text;
      this.sectionStart = this.index + 1;
    }
  }
  stateBeforeComment(c) {
    if (c === CharCodes.Dash) {
      this.state = State.InCommentLike;
      this.currentSequence = Sequences.CommentEnd;
      // Allow short comments (eg. <!-->)
      this.sequenceIndex = 2;
      this.sectionStart = this.index + 1;
    } else {
      this.state = State.InDeclaration;
    }
  }
  stateInSpecialComment(c) {
    if (c === CharCodes.Gt || this.fastForwardTo(CharCodes.Gt)) {
      this.cbs.oncomment(this.sectionStart, this.index, 0);
      this.state = State.Text;
      this.sectionStart = this.index + 1;
    }
  }
  stateBeforeSpecialS(c) {
    const lower = c | 0x20;
    if (lower === Sequences.ScriptEnd[3]) {
      this.startSpecial(Sequences.ScriptEnd, 4);
    } else if (lower === Sequences.StyleEnd[3]) {
      this.startSpecial(Sequences.StyleEnd, 4);
    } else {
      this.state = State.InTagName;
      this.stateInTagName(c); // Consume the token again
    }
  }
  stateBeforeSpecialT(c) {
    const lower = c | 0x20;
    if (lower === Sequences.TitleEnd[3]) {
      this.startSpecial(Sequences.TitleEnd, 4);
    } else if (lower === Sequences.TextareaEnd[3]) {
      this.startSpecial(Sequences.TextareaEnd, 4);
    } else {
      this.state = State.InTagName;
      this.stateInTagName(c); // Consume the token again
    }
  }
  startEntity() {
    this.baseState = this.state;
    this.state = State.InEntity;
    this.entityStart = this.index;
    this.entityDecoder.startEntity(this.xmlMode ? entities_lib_decode_js__WEBPACK_IMPORTED_MODULE_0__.DecodingMode.Strict : this.baseState === State.Text || this.baseState === State.InSpecialTag ? entities_lib_decode_js__WEBPACK_IMPORTED_MODULE_0__.DecodingMode.Legacy : entities_lib_decode_js__WEBPACK_IMPORTED_MODULE_0__.DecodingMode.Attribute);
  }
  stateInEntity() {
    const length = this.entityDecoder.write(this.buffer, this.index - this.offset);
    // If `length` is positive, we are done with the entity.
    if (length >= 0) {
      this.state = this.baseState;
      if (length === 0) {
        this.index = this.entityStart;
      }
    } else {
      // Mark buffer as consumed.
      this.index = this.offset + this.buffer.length - 1;
    }
  }
  /**
   * Remove data that has already been consumed from the buffer.
   */
  cleanup() {
    // If we are inside of text or attributes, emit what we already have.
    if (this.running && this.sectionStart !== this.index) {
      if (this.state === State.Text || this.state === State.InSpecialTag && this.sequenceIndex === 0) {
        this.cbs.ontext(this.sectionStart, this.index);
        this.sectionStart = this.index;
      } else if (this.state === State.InAttributeValueDq || this.state === State.InAttributeValueSq || this.state === State.InAttributeValueNq) {
        this.cbs.onattribdata(this.sectionStart, this.index);
        this.sectionStart = this.index;
      }
    }
  }
  shouldContinue() {
    return this.index < this.buffer.length + this.offset && this.running;
  }
  /**
   * Iterates through the buffer, calling the function corresponding to the current state.
   *
   * States that are more likely to be hit are higher up, as a performance improvement.
   */
  parse() {
    while (this.shouldContinue()) {
      const c = this.buffer.charCodeAt(this.index - this.offset);
      switch (this.state) {
        case State.Text:
          {
            this.stateText(c);
            break;
          }
        case State.SpecialStartSequence:
          {
            this.stateSpecialStartSequence(c);
            break;
          }
        case State.InSpecialTag:
          {
            this.stateInSpecialTag(c);
            break;
          }
        case State.CDATASequence:
          {
            this.stateCDATASequence(c);
            break;
          }
        case State.InAttributeValueDq:
          {
            this.stateInAttributeValueDoubleQuotes(c);
            break;
          }
        case State.InAttributeName:
          {
            this.stateInAttributeName(c);
            break;
          }
        case State.InCommentLike:
          {
            this.stateInCommentLike(c);
            break;
          }
        case State.InSpecialComment:
          {
            this.stateInSpecialComment(c);
            break;
          }
        case State.BeforeAttributeName:
          {
            this.stateBeforeAttributeName(c);
            break;
          }
        case State.InTagName:
          {
            this.stateInTagName(c);
            break;
          }
        case State.InClosingTagName:
          {
            this.stateInClosingTagName(c);
            break;
          }
        case State.BeforeTagName:
          {
            this.stateBeforeTagName(c);
            break;
          }
        case State.AfterAttributeName:
          {
            this.stateAfterAttributeName(c);
            break;
          }
        case State.InAttributeValueSq:
          {
            this.stateInAttributeValueSingleQuotes(c);
            break;
          }
        case State.BeforeAttributeValue:
          {
            this.stateBeforeAttributeValue(c);
            break;
          }
        case State.BeforeClosingTagName:
          {
            this.stateBeforeClosingTagName(c);
            break;
          }
        case State.AfterClosingTagName:
          {
            this.stateAfterClosingTagName(c);
            break;
          }
        case State.BeforeSpecialS:
          {
            this.stateBeforeSpecialS(c);
            break;
          }
        case State.BeforeSpecialT:
          {
            this.stateBeforeSpecialT(c);
            break;
          }
        case State.InAttributeValueNq:
          {
            this.stateInAttributeValueNoQuotes(c);
            break;
          }
        case State.InSelfClosingTag:
          {
            this.stateInSelfClosingTag(c);
            break;
          }
        case State.InDeclaration:
          {
            this.stateInDeclaration(c);
            break;
          }
        case State.BeforeDeclaration:
          {
            this.stateBeforeDeclaration(c);
            break;
          }
        case State.BeforeComment:
          {
            this.stateBeforeComment(c);
            break;
          }
        case State.InProcessingInstruction:
          {
            this.stateInProcessingInstruction(c);
            break;
          }
        case State.InEntity:
          {
            this.stateInEntity();
            break;
          }
      }
      this.index++;
    }
    this.cleanup();
  }
  finish() {
    if (this.state === State.InEntity) {
      this.entityDecoder.end();
      this.state = this.baseState;
    }
    this.handleTrailingData();
    this.cbs.onend();
  }
  /** Handle any trailing data. */
  handleTrailingData() {
    const endIndex = this.buffer.length + this.offset;
    // If there is no remaining data, we are done.
    if (this.sectionStart >= endIndex) {
      return;
    }
    if (this.state === State.InCommentLike) {
      if (this.currentSequence === Sequences.CdataEnd) {
        this.cbs.oncdata(this.sectionStart, endIndex, 0);
      } else {
        this.cbs.oncomment(this.sectionStart, endIndex, 0);
      }
    } else if (this.state === State.InTagName || this.state === State.BeforeAttributeName || this.state === State.BeforeAttributeValue || this.state === State.AfterAttributeName || this.state === State.InAttributeName || this.state === State.InAttributeValueSq || this.state === State.InAttributeValueDq || this.state === State.InAttributeValueNq || this.state === State.InClosingTagName) {
      /*
       * If we are currently in an opening or closing tag, us not calling the
       * respective callback signals that the tag should be ignored.
       */
    } else {
      this.cbs.ontext(this.sectionStart, endIndex);
    }
  }
  emitCodePoint(cp, consumed) {
    if (this.baseState !== State.Text && this.baseState !== State.InSpecialTag) {
      if (this.sectionStart < this.entityStart) {
        this.cbs.onattribdata(this.sectionStart, this.entityStart);
      }
      this.sectionStart = this.entityStart + consumed;
      this.index = this.sectionStart - 1;
      this.cbs.onattribentity(cp);
    } else {
      if (this.sectionStart < this.entityStart) {
        this.cbs.ontext(this.sectionStart, this.entityStart);
      }
      this.sectionStart = this.entityStart + consumed;
      this.index = this.sectionStart - 1;
      this.cbs.ontextentity(cp, this.sectionStart);
    }
  }
}

/***/ }),
/* 341 */
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   BinTrieFlags: function() { return /* binding */ BinTrieFlags; },
/* harmony export */   DecodingMode: function() { return /* binding */ DecodingMode; },
/* harmony export */   EntityDecoder: function() { return /* binding */ EntityDecoder; },
/* harmony export */   decodeCodePoint: function() { return /* reexport safe */ _decode_codepoint_js__WEBPACK_IMPORTED_MODULE_2__["default"]; },
/* harmony export */   decodeHTML: function() { return /* binding */ decodeHTML; },
/* harmony export */   decodeHTMLAttribute: function() { return /* binding */ decodeHTMLAttribute; },
/* harmony export */   decodeHTMLStrict: function() { return /* binding */ decodeHTMLStrict; },
/* harmony export */   decodeXML: function() { return /* binding */ decodeXML; },
/* harmony export */   determineBranch: function() { return /* binding */ determineBranch; },
/* harmony export */   fromCodePoint: function() { return /* reexport safe */ _decode_codepoint_js__WEBPACK_IMPORTED_MODULE_2__.fromCodePoint; },
/* harmony export */   htmlDecodeTree: function() { return /* reexport safe */ _generated_decode_data_html_js__WEBPACK_IMPORTED_MODULE_0__["default"]; },
/* harmony export */   replaceCodePoint: function() { return /* reexport safe */ _decode_codepoint_js__WEBPACK_IMPORTED_MODULE_2__.replaceCodePoint; },
/* harmony export */   xmlDecodeTree: function() { return /* reexport safe */ _generated_decode_data_xml_js__WEBPACK_IMPORTED_MODULE_1__["default"]; }
/* harmony export */ });
/* harmony import */ var _generated_decode_data_html_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(342);
/* harmony import */ var _generated_decode_data_xml_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(343);
/* harmony import */ var _decode_codepoint_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(344);



// Re-export for use by eg. htmlparser2


var CharCodes;
(function (CharCodes) {
  CharCodes[CharCodes["NUM"] = 35] = "NUM";
  CharCodes[CharCodes["SEMI"] = 59] = "SEMI";
  CharCodes[CharCodes["EQUALS"] = 61] = "EQUALS";
  CharCodes[CharCodes["ZERO"] = 48] = "ZERO";
  CharCodes[CharCodes["NINE"] = 57] = "NINE";
  CharCodes[CharCodes["LOWER_A"] = 97] = "LOWER_A";
  CharCodes[CharCodes["LOWER_F"] = 102] = "LOWER_F";
  CharCodes[CharCodes["LOWER_X"] = 120] = "LOWER_X";
  CharCodes[CharCodes["LOWER_Z"] = 122] = "LOWER_Z";
  CharCodes[CharCodes["UPPER_A"] = 65] = "UPPER_A";
  CharCodes[CharCodes["UPPER_F"] = 70] = "UPPER_F";
  CharCodes[CharCodes["UPPER_Z"] = 90] = "UPPER_Z";
})(CharCodes || (CharCodes = {}));
/** Bit that needs to be set to convert an upper case ASCII character to lower case */
const TO_LOWER_BIT = 0b100000;
var BinTrieFlags;
(function (BinTrieFlags) {
  BinTrieFlags[BinTrieFlags["VALUE_LENGTH"] = 49152] = "VALUE_LENGTH";
  BinTrieFlags[BinTrieFlags["BRANCH_LENGTH"] = 16256] = "BRANCH_LENGTH";
  BinTrieFlags[BinTrieFlags["JUMP_TABLE"] = 127] = "JUMP_TABLE";
})(BinTrieFlags || (BinTrieFlags = {}));
function isNumber(code) {
  return code >= CharCodes.ZERO && code <= CharCodes.NINE;
}
function isHexadecimalCharacter(code) {
  return code >= CharCodes.UPPER_A && code <= CharCodes.UPPER_F || code >= CharCodes.LOWER_A && code <= CharCodes.LOWER_F;
}
function isAsciiAlphaNumeric(code) {
  return code >= CharCodes.UPPER_A && code <= CharCodes.UPPER_Z || code >= CharCodes.LOWER_A && code <= CharCodes.LOWER_Z || isNumber(code);
}
/**
 * Checks if the given character is a valid end character for an entity in an attribute.
 *
 * Attribute values that aren't terminated properly aren't parsed, and shouldn't lead to a parser error.
 * See the example in https://html.spec.whatwg.org/multipage/parsing.html#named-character-reference-state
 */
function isEntityInAttributeInvalidEnd(code) {
  return code === CharCodes.EQUALS || isAsciiAlphaNumeric(code);
}
var EntityDecoderState;
(function (EntityDecoderState) {
  EntityDecoderState[EntityDecoderState["EntityStart"] = 0] = "EntityStart";
  EntityDecoderState[EntityDecoderState["NumericStart"] = 1] = "NumericStart";
  EntityDecoderState[EntityDecoderState["NumericDecimal"] = 2] = "NumericDecimal";
  EntityDecoderState[EntityDecoderState["NumericHex"] = 3] = "NumericHex";
  EntityDecoderState[EntityDecoderState["NamedEntity"] = 4] = "NamedEntity";
})(EntityDecoderState || (EntityDecoderState = {}));
var DecodingMode;
(function (DecodingMode) {
  /** Entities in text nodes that can end with any character. */
  DecodingMode[DecodingMode["Legacy"] = 0] = "Legacy";
  /** Only allow entities terminated with a semicolon. */
  DecodingMode[DecodingMode["Strict"] = 1] = "Strict";
  /** Entities in attributes have limitations on ending characters. */
  DecodingMode[DecodingMode["Attribute"] = 2] = "Attribute";
})(DecodingMode || (DecodingMode = {}));
/**
 * Token decoder with support of writing partial entities.
 */
class EntityDecoder {
  constructor(/** The tree used to decode entities. */
  decodeTree,
  /**
   * The function that is called when a codepoint is decoded.
   *
   * For multi-byte named entities, this will be called multiple times,
   * with the second codepoint, and the same `consumed` value.
   *
   * @param codepoint The decoded codepoint.
   * @param consumed The number of bytes consumed by the decoder.
   */
  emitCodePoint, /** An object that is used to produce errors. */
  errors) {
    this.decodeTree = decodeTree;
    this.emitCodePoint = emitCodePoint;
    this.errors = errors;
    /** The current state of the decoder. */
    this.state = EntityDecoderState.EntityStart;
    /** Characters that were consumed while parsing an entity. */
    this.consumed = 1;
    /**
     * The result of the entity.
     *
     * Either the result index of a numeric entity, or the codepoint of a
     * numeric entity.
     */
    this.result = 0;
    /** The current index in the decode tree. */
    this.treeIndex = 0;
    /** The number of characters that were consumed in excess. */
    this.excess = 1;
    /** The mode in which the decoder is operating. */
    this.decodeMode = DecodingMode.Strict;
  }
  /** Resets the instance to make it reusable. */
  startEntity(decodeMode) {
    this.decodeMode = decodeMode;
    this.state = EntityDecoderState.EntityStart;
    this.result = 0;
    this.treeIndex = 0;
    this.excess = 1;
    this.consumed = 1;
  }
  /**
   * Write an entity to the decoder. This can be called multiple times with partial entities.
   * If the entity is incomplete, the decoder will return -1.
   *
   * Mirrors the implementation of `getDecoder`, but with the ability to stop decoding if the
   * entity is incomplete, and resume when the next string is written.
   *
   * @param string The string containing the entity (or a continuation of the entity).
   * @param offset The offset at which the entity begins. Should be 0 if this is not the first call.
   * @returns The number of characters that were consumed, or -1 if the entity is incomplete.
   */
  write(str, offset) {
    switch (this.state) {
      case EntityDecoderState.EntityStart:
        {
          if (str.charCodeAt(offset) === CharCodes.NUM) {
            this.state = EntityDecoderState.NumericStart;
            this.consumed += 1;
            return this.stateNumericStart(str, offset + 1);
          }
          this.state = EntityDecoderState.NamedEntity;
          return this.stateNamedEntity(str, offset);
        }
      case EntityDecoderState.NumericStart:
        {
          return this.stateNumericStart(str, offset);
        }
      case EntityDecoderState.NumericDecimal:
        {
          return this.stateNumericDecimal(str, offset);
        }
      case EntityDecoderState.NumericHex:
        {
          return this.stateNumericHex(str, offset);
        }
      case EntityDecoderState.NamedEntity:
        {
          return this.stateNamedEntity(str, offset);
        }
    }
  }
  /**
   * Switches between the numeric decimal and hexadecimal states.
   *
   * Equivalent to the `Numeric character reference state` in the HTML spec.
   *
   * @param str The string containing the entity (or a continuation of the entity).
   * @param offset The current offset.
   * @returns The number of characters that were consumed, or -1 if the entity is incomplete.
   */
  stateNumericStart(str, offset) {
    if (offset >= str.length) {
      return -1;
    }
    if ((str.charCodeAt(offset) | TO_LOWER_BIT) === CharCodes.LOWER_X) {
      this.state = EntityDecoderState.NumericHex;
      this.consumed += 1;
      return this.stateNumericHex(str, offset + 1);
    }
    this.state = EntityDecoderState.NumericDecimal;
    return this.stateNumericDecimal(str, offset);
  }
  addToNumericResult(str, start, end, base) {
    if (start !== end) {
      const digitCount = end - start;
      this.result = this.result * Math.pow(base, digitCount) + parseInt(str.substr(start, digitCount), base);
      this.consumed += digitCount;
    }
  }
  /**
   * Parses a hexadecimal numeric entity.
   *
   * Equivalent to the `Hexademical character reference state` in the HTML spec.
   *
   * @param str The string containing the entity (or a continuation of the entity).
   * @param offset The current offset.
   * @returns The number of characters that were consumed, or -1 if the entity is incomplete.
   */
  stateNumericHex(str, offset) {
    const startIdx = offset;
    while (offset < str.length) {
      const char = str.charCodeAt(offset);
      if (isNumber(char) || isHexadecimalCharacter(char)) {
        offset += 1;
      } else {
        this.addToNumericResult(str, startIdx, offset, 16);
        return this.emitNumericEntity(char, 3);
      }
    }
    this.addToNumericResult(str, startIdx, offset, 16);
    return -1;
  }
  /**
   * Parses a decimal numeric entity.
   *
   * Equivalent to the `Decimal character reference state` in the HTML spec.
   *
   * @param str The string containing the entity (or a continuation of the entity).
   * @param offset The current offset.
   * @returns The number of characters that were consumed, or -1 if the entity is incomplete.
   */
  stateNumericDecimal(str, offset) {
    const startIdx = offset;
    while (offset < str.length) {
      const char = str.charCodeAt(offset);
      if (isNumber(char)) {
        offset += 1;
      } else {
        this.addToNumericResult(str, startIdx, offset, 10);
        return this.emitNumericEntity(char, 2);
      }
    }
    this.addToNumericResult(str, startIdx, offset, 10);
    return -1;
  }
  /**
   * Validate and emit a numeric entity.
   *
   * Implements the logic from the `Hexademical character reference start
   * state` and `Numeric character reference end state` in the HTML spec.
   *
   * @param lastCp The last code point of the entity. Used to see if the
   *               entity was terminated with a semicolon.
   * @param expectedLength The minimum number of characters that should be
   *                       consumed. Used to validate that at least one digit
   *                       was consumed.
   * @returns The number of characters that were consumed.
   */
  emitNumericEntity(lastCp, expectedLength) {
    var _a;
    // Ensure we consumed at least one digit.
    if (this.consumed <= expectedLength) {
      (_a = this.errors) === null || _a === void 0 ? void 0 : _a.absenceOfDigitsInNumericCharacterReference(this.consumed);
      return 0;
    }
    // Figure out if this is a legit end of the entity
    if (lastCp === CharCodes.SEMI) {
      this.consumed += 1;
    } else if (this.decodeMode === DecodingMode.Strict) {
      return 0;
    }
    this.emitCodePoint((0,_decode_codepoint_js__WEBPACK_IMPORTED_MODULE_2__.replaceCodePoint)(this.result), this.consumed);
    if (this.errors) {
      if (lastCp !== CharCodes.SEMI) {
        this.errors.missingSemicolonAfterCharacterReference();
      }
      this.errors.validateNumericCharacterReference(this.result);
    }
    return this.consumed;
  }
  /**
   * Parses a named entity.
   *
   * Equivalent to the `Named character reference state` in the HTML spec.
   *
   * @param str The string containing the entity (or a continuation of the entity).
   * @param offset The current offset.
   * @returns The number of characters that were consumed, or -1 if the entity is incomplete.
   */
  stateNamedEntity(str, offset) {
    const {
      decodeTree
    } = this;
    let current = decodeTree[this.treeIndex];
    // The mask is the number of bytes of the value, including the current byte.
    let valueLength = (current & BinTrieFlags.VALUE_LENGTH) >> 14;
    for (; offset < str.length; offset++, this.excess++) {
      const char = str.charCodeAt(offset);
      this.treeIndex = determineBranch(decodeTree, current, this.treeIndex + Math.max(1, valueLength), char);
      if (this.treeIndex < 0) {
        return this.result === 0 ||
        // If we are parsing an attribute
        this.decodeMode === DecodingMode.Attribute && (
        // We shouldn't have consumed any characters after the entity,
        valueLength === 0 ||
        // And there should be no invalid characters.
        isEntityInAttributeInvalidEnd(char)) ? 0 : this.emitNotTerminatedNamedEntity();
      }
      current = decodeTree[this.treeIndex];
      valueLength = (current & BinTrieFlags.VALUE_LENGTH) >> 14;
      // If the branch is a value, store it and continue
      if (valueLength !== 0) {
        // If the entity is terminated by a semicolon, we are done.
        if (char === CharCodes.SEMI) {
          return this.emitNamedEntityData(this.treeIndex, valueLength, this.consumed + this.excess);
        }
        // If we encounter a non-terminated (legacy) entity while parsing strictly, then ignore it.
        if (this.decodeMode !== DecodingMode.Strict) {
          this.result = this.treeIndex;
          this.consumed += this.excess;
          this.excess = 0;
        }
      }
    }
    return -1;
  }
  /**
   * Emit a named entity that was not terminated with a semicolon.
   *
   * @returns The number of characters consumed.
   */
  emitNotTerminatedNamedEntity() {
    var _a;
    const {
      result,
      decodeTree
    } = this;
    const valueLength = (decodeTree[result] & BinTrieFlags.VALUE_LENGTH) >> 14;
    this.emitNamedEntityData(result, valueLength, this.consumed);
    (_a = this.errors) === null || _a === void 0 ? void 0 : _a.missingSemicolonAfterCharacterReference();
    return this.consumed;
  }
  /**
   * Emit a named entity.
   *
   * @param result The index of the entity in the decode tree.
   * @param valueLength The number of bytes in the entity.
   * @param consumed The number of characters consumed.
   *
   * @returns The number of characters consumed.
   */
  emitNamedEntityData(result, valueLength, consumed) {
    const {
      decodeTree
    } = this;
    this.emitCodePoint(valueLength === 1 ? decodeTree[result] & ~BinTrieFlags.VALUE_LENGTH : decodeTree[result + 1], consumed);
    if (valueLength === 3) {
      // For multi-byte values, we need to emit the second byte.
      this.emitCodePoint(decodeTree[result + 2], consumed);
    }
    return consumed;
  }
  /**
   * Signal to the parser that the end of the input was reached.
   *
   * Remaining data will be emitted and relevant errors will be produced.
   *
   * @returns The number of characters consumed.
   */
  end() {
    var _a;
    switch (this.state) {
      case EntityDecoderState.NamedEntity:
        {
          // Emit a named entity if we have one.
          return this.result !== 0 && (this.decodeMode !== DecodingMode.Attribute || this.result === this.treeIndex) ? this.emitNotTerminatedNamedEntity() : 0;
        }
      // Otherwise, emit a numeric entity if we have one.
      case EntityDecoderState.NumericDecimal:
        {
          return this.emitNumericEntity(0, 2);
        }
      case EntityDecoderState.NumericHex:
        {
          return this.emitNumericEntity(0, 3);
        }
      case EntityDecoderState.NumericStart:
        {
          (_a = this.errors) === null || _a === void 0 ? void 0 : _a.absenceOfDigitsInNumericCharacterReference(this.consumed);
          return 0;
        }
      case EntityDecoderState.EntityStart:
        {
          // Return 0 if we have no entity.
          return 0;
        }
    }
  }
}
/**
 * Creates a function that decodes entities in a string.
 *
 * @param decodeTree The decode tree.
 * @returns A function that decodes entities in a string.
 */
function getDecoder(decodeTree) {
  let ret = "";
  const decoder = new EntityDecoder(decodeTree, str => ret += (0,_decode_codepoint_js__WEBPACK_IMPORTED_MODULE_2__.fromCodePoint)(str));
  return function decodeWithTrie(str, decodeMode) {
    let lastIndex = 0;
    let offset = 0;
    while ((offset = str.indexOf("&", offset)) >= 0) {
      ret += str.slice(lastIndex, offset);
      decoder.startEntity(decodeMode);
      const len = decoder.write(str,
      // Skip the "&"
      offset + 1);
      if (len < 0) {
        lastIndex = offset + decoder.end();
        break;
      }
      lastIndex = offset + len;
      // If `len` is 0, skip the current `&` and continue.
      offset = len === 0 ? lastIndex + 1 : lastIndex;
    }
    const result = ret + str.slice(lastIndex);
    // Make sure we don't keep a reference to the final string.
    ret = "";
    return result;
  };
}
/**
 * Determines the branch of the current node that is taken given the current
 * character. This function is used to traverse the trie.
 *
 * @param decodeTree The trie.
 * @param current The current node.
 * @param nodeIdx The index right after the current node and its value.
 * @param char The current character.
 * @returns The index of the next node, or -1 if no branch is taken.
 */
function determineBranch(decodeTree, current, nodeIdx, char) {
  const branchCount = (current & BinTrieFlags.BRANCH_LENGTH) >> 7;
  const jumpOffset = current & BinTrieFlags.JUMP_TABLE;
  // Case 1: Single branch encoded in jump offset
  if (branchCount === 0) {
    return jumpOffset !== 0 && char === jumpOffset ? nodeIdx : -1;
  }
  // Case 2: Multiple branches encoded in jump table
  if (jumpOffset) {
    const value = char - jumpOffset;
    return value < 0 || value >= branchCount ? -1 : decodeTree[nodeIdx + value] - 1;
  }
  // Case 3: Multiple branches encoded in dictionary
  // Binary search for the character.
  let lo = nodeIdx;
  let hi = lo + branchCount - 1;
  while (lo <= hi) {
    const mid = lo + hi >>> 1;
    const midVal = decodeTree[mid];
    if (midVal < char) {
      lo = mid + 1;
    } else if (midVal > char) {
      hi = mid - 1;
    } else {
      return decodeTree[mid + branchCount];
    }
  }
  return -1;
}
const htmlDecoder = getDecoder(_generated_decode_data_html_js__WEBPACK_IMPORTED_MODULE_0__["default"]);
const xmlDecoder = getDecoder(_generated_decode_data_xml_js__WEBPACK_IMPORTED_MODULE_1__["default"]);
/**
 * Decodes an HTML string.
 *
 * @param str The string to decode.
 * @param mode The decoding mode.
 * @returns The decoded string.
 */
function decodeHTML(str, mode = DecodingMode.Legacy) {
  return htmlDecoder(str, mode);
}
/**
 * Decodes an HTML string in an attribute.
 *
 * @param str The string to decode.
 * @returns The decoded string.
 */
function decodeHTMLAttribute(str) {
  return htmlDecoder(str, DecodingMode.Attribute);
}
/**
 * Decodes an HTML string, requiring all entities to be terminated by a semicolon.
 *
 * @param str The string to decode.
 * @returns The decoded string.
 */
function decodeHTMLStrict(str) {
  return htmlDecoder(str, DecodingMode.Strict);
}
/**
 * Decodes an XML string, requiring all entities to be terminated by a semicolon.
 *
 * @param str The string to decode.
 * @returns The decoded string.
 */
function decodeXML(str) {
  return xmlDecoder(str, DecodingMode.Strict);
}

/***/ }),
/* 342 */
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
// Generated using scripts/write-decode-map.ts
/* harmony default export */ __webpack_exports__["default"] = (new Uint16Array(
// prettier-ignore
"\u1d41<\xd5\u0131\u028a\u049d\u057b\u05d0\u0675\u06de\u07a2\u07d6\u080f\u0a4a\u0a91\u0da1\u0e6d\u0f09\u0f26\u10ca\u1228\u12e1\u1415\u149d\u14c3\u14df\u1525\0\0\0\0\0\0\u156b\u16cd\u198d\u1c12\u1ddd\u1f7e\u2060\u21b0\u228d\u23c0\u23fb\u2442\u2824\u2912\u2d08\u2e48\u2fce\u3016\u32ba\u3639\u37ac\u38fe\u3a28\u3a71\u3ae0\u3b2e\u0800EMabcfglmnoprstu\\bfms\x7f\x84\x8b\x90\x95\x98\xa6\xb3\xb9\xc8\xcflig\u803b\xc6\u40c6P\u803b&\u4026cute\u803b\xc1\u40c1reve;\u4102\u0100iyx}rc\u803b\xc2\u40c2;\u4410r;\uc000\ud835\udd04rave\u803b\xc0\u40c0pha;\u4391acr;\u4100d;\u6a53\u0100gp\x9d\xa1on;\u4104f;\uc000\ud835\udd38plyFunction;\u6061ing\u803b\xc5\u40c5\u0100cs\xbe\xc3r;\uc000\ud835\udc9cign;\u6254ilde\u803b\xc3\u40c3ml\u803b\xc4\u40c4\u0400aceforsu\xe5\xfb\xfe\u0117\u011c\u0122\u0127\u012a\u0100cr\xea\xf2kslash;\u6216\u0176\xf6\xf8;\u6ae7ed;\u6306y;\u4411\u0180crt\u0105\u010b\u0114ause;\u6235noullis;\u612ca;\u4392r;\uc000\ud835\udd05pf;\uc000\ud835\udd39eve;\u42d8c\xf2\u0113mpeq;\u624e\u0700HOacdefhilorsu\u014d\u0151\u0156\u0180\u019e\u01a2\u01b5\u01b7\u01ba\u01dc\u0215\u0273\u0278\u027ecy;\u4427PY\u803b\xa9\u40a9\u0180cpy\u015d\u0162\u017aute;\u4106\u0100;i\u0167\u0168\u62d2talDifferentialD;\u6145leys;\u612d\u0200aeio\u0189\u018e\u0194\u0198ron;\u410cdil\u803b\xc7\u40c7rc;\u4108nint;\u6230ot;\u410a\u0100dn\u01a7\u01adilla;\u40b8terDot;\u40b7\xf2\u017fi;\u43a7rcle\u0200DMPT\u01c7\u01cb\u01d1\u01d6ot;\u6299inus;\u6296lus;\u6295imes;\u6297o\u0100cs\u01e2\u01f8kwiseContourIntegral;\u6232eCurly\u0100DQ\u0203\u020foubleQuote;\u601duote;\u6019\u0200lnpu\u021e\u0228\u0247\u0255on\u0100;e\u0225\u0226\u6237;\u6a74\u0180git\u022f\u0236\u023aruent;\u6261nt;\u622fourIntegral;\u622e\u0100fr\u024c\u024e;\u6102oduct;\u6210nterClockwiseContourIntegral;\u6233oss;\u6a2fcr;\uc000\ud835\udc9ep\u0100;C\u0284\u0285\u62d3ap;\u624d\u0580DJSZacefios\u02a0\u02ac\u02b0\u02b4\u02b8\u02cb\u02d7\u02e1\u02e6\u0333\u048d\u0100;o\u0179\u02a5trahd;\u6911cy;\u4402cy;\u4405cy;\u440f\u0180grs\u02bf\u02c4\u02c7ger;\u6021r;\u61a1hv;\u6ae4\u0100ay\u02d0\u02d5ron;\u410e;\u4414l\u0100;t\u02dd\u02de\u6207a;\u4394r;\uc000\ud835\udd07\u0100af\u02eb\u0327\u0100cm\u02f0\u0322ritical\u0200ADGT\u0300\u0306\u0316\u031ccute;\u40b4o\u0174\u030b\u030d;\u42d9bleAcute;\u42ddrave;\u4060ilde;\u42dcond;\u62c4ferentialD;\u6146\u0470\u033d\0\0\0\u0342\u0354\0\u0405f;\uc000\ud835\udd3b\u0180;DE\u0348\u0349\u034d\u40a8ot;\u60dcqual;\u6250ble\u0300CDLRUV\u0363\u0372\u0382\u03cf\u03e2\u03f8ontourIntegra\xec\u0239o\u0274\u0379\0\0\u037b\xbb\u0349nArrow;\u61d3\u0100eo\u0387\u03a4ft\u0180ART\u0390\u0396\u03a1rrow;\u61d0ightArrow;\u61d4e\xe5\u02cang\u0100LR\u03ab\u03c4eft\u0100AR\u03b3\u03b9rrow;\u67f8ightArrow;\u67faightArrow;\u67f9ight\u0100AT\u03d8\u03derrow;\u61d2ee;\u62a8p\u0241\u03e9\0\0\u03efrrow;\u61d1ownArrow;\u61d5erticalBar;\u6225n\u0300ABLRTa\u0412\u042a\u0430\u045e\u047f\u037crrow\u0180;BU\u041d\u041e\u0422\u6193ar;\u6913pArrow;\u61f5reve;\u4311eft\u02d2\u043a\0\u0446\0\u0450ightVector;\u6950eeVector;\u695eector\u0100;B\u0459\u045a\u61bdar;\u6956ight\u01d4\u0467\0\u0471eeVector;\u695fector\u0100;B\u047a\u047b\u61c1ar;\u6957ee\u0100;A\u0486\u0487\u62a4rrow;\u61a7\u0100ct\u0492\u0497r;\uc000\ud835\udc9frok;\u4110\u0800NTacdfglmopqstux\u04bd\u04c0\u04c4\u04cb\u04de\u04e2\u04e7\u04ee\u04f5\u0521\u052f\u0536\u0552\u055d\u0560\u0565G;\u414aH\u803b\xd0\u40d0cute\u803b\xc9\u40c9\u0180aiy\u04d2\u04d7\u04dcron;\u411arc\u803b\xca\u40ca;\u442dot;\u4116r;\uc000\ud835\udd08rave\u803b\xc8\u40c8ement;\u6208\u0100ap\u04fa\u04fecr;\u4112ty\u0253\u0506\0\0\u0512mallSquare;\u65fberySmallSquare;\u65ab\u0100gp\u0526\u052aon;\u4118f;\uc000\ud835\udd3csilon;\u4395u\u0100ai\u053c\u0549l\u0100;T\u0542\u0543\u6a75ilde;\u6242librium;\u61cc\u0100ci\u0557\u055ar;\u6130m;\u6a73a;\u4397ml\u803b\xcb\u40cb\u0100ip\u056a\u056fsts;\u6203onentialE;\u6147\u0280cfios\u0585\u0588\u058d\u05b2\u05ccy;\u4424r;\uc000\ud835\udd09lled\u0253\u0597\0\0\u05a3mallSquare;\u65fcerySmallSquare;\u65aa\u0370\u05ba\0\u05bf\0\0\u05c4f;\uc000\ud835\udd3dAll;\u6200riertrf;\u6131c\xf2\u05cb\u0600JTabcdfgorst\u05e8\u05ec\u05ef\u05fa\u0600\u0612\u0616\u061b\u061d\u0623\u066c\u0672cy;\u4403\u803b>\u403emma\u0100;d\u05f7\u05f8\u4393;\u43dcreve;\u411e\u0180eiy\u0607\u060c\u0610dil;\u4122rc;\u411c;\u4413ot;\u4120r;\uc000\ud835\udd0a;\u62d9pf;\uc000\ud835\udd3eeater\u0300EFGLST\u0635\u0644\u064e\u0656\u065b\u0666qual\u0100;L\u063e\u063f\u6265ess;\u62dbullEqual;\u6267reater;\u6aa2ess;\u6277lantEqual;\u6a7eilde;\u6273cr;\uc000\ud835\udca2;\u626b\u0400Aacfiosu\u0685\u068b\u0696\u069b\u069e\u06aa\u06be\u06caRDcy;\u442a\u0100ct\u0690\u0694ek;\u42c7;\u405eirc;\u4124r;\u610clbertSpace;\u610b\u01f0\u06af\0\u06b2f;\u610dizontalLine;\u6500\u0100ct\u06c3\u06c5\xf2\u06a9rok;\u4126mp\u0144\u06d0\u06d8ownHum\xf0\u012fqual;\u624f\u0700EJOacdfgmnostu\u06fa\u06fe\u0703\u0707\u070e\u071a\u071e\u0721\u0728\u0744\u0778\u078b\u078f\u0795cy;\u4415lig;\u4132cy;\u4401cute\u803b\xcd\u40cd\u0100iy\u0713\u0718rc\u803b\xce\u40ce;\u4418ot;\u4130r;\u6111rave\u803b\xcc\u40cc\u0180;ap\u0720\u072f\u073f\u0100cg\u0734\u0737r;\u412ainaryI;\u6148lie\xf3\u03dd\u01f4\u0749\0\u0762\u0100;e\u074d\u074e\u622c\u0100gr\u0753\u0758ral;\u622bsection;\u62c2isible\u0100CT\u076c\u0772omma;\u6063imes;\u6062\u0180gpt\u077f\u0783\u0788on;\u412ef;\uc000\ud835\udd40a;\u4399cr;\u6110ilde;\u4128\u01eb\u079a\0\u079ecy;\u4406l\u803b\xcf\u40cf\u0280cfosu\u07ac\u07b7\u07bc\u07c2\u07d0\u0100iy\u07b1\u07b5rc;\u4134;\u4419r;\uc000\ud835\udd0dpf;\uc000\ud835\udd41\u01e3\u07c7\0\u07ccr;\uc000\ud835\udca5rcy;\u4408kcy;\u4404\u0380HJacfos\u07e4\u07e8\u07ec\u07f1\u07fd\u0802\u0808cy;\u4425cy;\u440cppa;\u439a\u0100ey\u07f6\u07fbdil;\u4136;\u441ar;\uc000\ud835\udd0epf;\uc000\ud835\udd42cr;\uc000\ud835\udca6\u0580JTaceflmost\u0825\u0829\u082c\u0850\u0863\u09b3\u09b8\u09c7\u09cd\u0a37\u0a47cy;\u4409\u803b<\u403c\u0280cmnpr\u0837\u083c\u0841\u0844\u084dute;\u4139bda;\u439bg;\u67ealacetrf;\u6112r;\u619e\u0180aey\u0857\u085c\u0861ron;\u413ddil;\u413b;\u441b\u0100fs\u0868\u0970t\u0500ACDFRTUVar\u087e\u08a9\u08b1\u08e0\u08e6\u08fc\u092f\u095b\u0390\u096a\u0100nr\u0883\u088fgleBracket;\u67e8row\u0180;BR\u0899\u089a\u089e\u6190ar;\u61e4ightArrow;\u61c6eiling;\u6308o\u01f5\u08b7\0\u08c3bleBracket;\u67e6n\u01d4\u08c8\0\u08d2eeVector;\u6961ector\u0100;B\u08db\u08dc\u61c3ar;\u6959loor;\u630aight\u0100AV\u08ef\u08f5rrow;\u6194ector;\u694e\u0100er\u0901\u0917e\u0180;AV\u0909\u090a\u0910\u62a3rrow;\u61a4ector;\u695aiangle\u0180;BE\u0924\u0925\u0929\u62b2ar;\u69cfqual;\u62b4p\u0180DTV\u0937\u0942\u094cownVector;\u6951eeVector;\u6960ector\u0100;B\u0956\u0957\u61bfar;\u6958ector\u0100;B\u0965\u0966\u61bcar;\u6952ight\xe1\u039cs\u0300EFGLST\u097e\u098b\u0995\u099d\u09a2\u09adqualGreater;\u62daullEqual;\u6266reater;\u6276ess;\u6aa1lantEqual;\u6a7dilde;\u6272r;\uc000\ud835\udd0f\u0100;e\u09bd\u09be\u62d8ftarrow;\u61daidot;\u413f\u0180npw\u09d4\u0a16\u0a1bg\u0200LRlr\u09de\u09f7\u0a02\u0a10eft\u0100AR\u09e6\u09ecrrow;\u67f5ightArrow;\u67f7ightArrow;\u67f6eft\u0100ar\u03b3\u0a0aight\xe1\u03bfight\xe1\u03caf;\uc000\ud835\udd43er\u0100LR\u0a22\u0a2ceftArrow;\u6199ightArrow;\u6198\u0180cht\u0a3e\u0a40\u0a42\xf2\u084c;\u61b0rok;\u4141;\u626a\u0400acefiosu\u0a5a\u0a5d\u0a60\u0a77\u0a7c\u0a85\u0a8b\u0a8ep;\u6905y;\u441c\u0100dl\u0a65\u0a6fiumSpace;\u605flintrf;\u6133r;\uc000\ud835\udd10nusPlus;\u6213pf;\uc000\ud835\udd44c\xf2\u0a76;\u439c\u0480Jacefostu\u0aa3\u0aa7\u0aad\u0ac0\u0b14\u0b19\u0d91\u0d97\u0d9ecy;\u440acute;\u4143\u0180aey\u0ab4\u0ab9\u0aberon;\u4147dil;\u4145;\u441d\u0180gsw\u0ac7\u0af0\u0b0eative\u0180MTV\u0ad3\u0adf\u0ae8ediumSpace;\u600bhi\u0100cn\u0ae6\u0ad8\xeb\u0ad9eryThi\xee\u0ad9ted\u0100GL\u0af8\u0b06reaterGreate\xf2\u0673essLes\xf3\u0a48Line;\u400ar;\uc000\ud835\udd11\u0200Bnpt\u0b22\u0b28\u0b37\u0b3areak;\u6060BreakingSpace;\u40a0f;\u6115\u0680;CDEGHLNPRSTV\u0b55\u0b56\u0b6a\u0b7c\u0ba1\u0beb\u0c04\u0c5e\u0c84\u0ca6\u0cd8\u0d61\u0d85\u6aec\u0100ou\u0b5b\u0b64ngruent;\u6262pCap;\u626doubleVerticalBar;\u6226\u0180lqx\u0b83\u0b8a\u0b9bement;\u6209ual\u0100;T\u0b92\u0b93\u6260ilde;\uc000\u2242\u0338ists;\u6204reater\u0380;EFGLST\u0bb6\u0bb7\u0bbd\u0bc9\u0bd3\u0bd8\u0be5\u626fqual;\u6271ullEqual;\uc000\u2267\u0338reater;\uc000\u226b\u0338ess;\u6279lantEqual;\uc000\u2a7e\u0338ilde;\u6275ump\u0144\u0bf2\u0bfdownHump;\uc000\u224e\u0338qual;\uc000\u224f\u0338e\u0100fs\u0c0a\u0c27tTriangle\u0180;BE\u0c1a\u0c1b\u0c21\u62eaar;\uc000\u29cf\u0338qual;\u62ecs\u0300;EGLST\u0c35\u0c36\u0c3c\u0c44\u0c4b\u0c58\u626equal;\u6270reater;\u6278ess;\uc000\u226a\u0338lantEqual;\uc000\u2a7d\u0338ilde;\u6274ested\u0100GL\u0c68\u0c79reaterGreater;\uc000\u2aa2\u0338essLess;\uc000\u2aa1\u0338recedes\u0180;ES\u0c92\u0c93\u0c9b\u6280qual;\uc000\u2aaf\u0338lantEqual;\u62e0\u0100ei\u0cab\u0cb9verseElement;\u620cghtTriangle\u0180;BE\u0ccb\u0ccc\u0cd2\u62ebar;\uc000\u29d0\u0338qual;\u62ed\u0100qu\u0cdd\u0d0cuareSu\u0100bp\u0ce8\u0cf9set\u0100;E\u0cf0\u0cf3\uc000\u228f\u0338qual;\u62e2erset\u0100;E\u0d03\u0d06\uc000\u2290\u0338qual;\u62e3\u0180bcp\u0d13\u0d24\u0d4eset\u0100;E\u0d1b\u0d1e\uc000\u2282\u20d2qual;\u6288ceeds\u0200;EST\u0d32\u0d33\u0d3b\u0d46\u6281qual;\uc000\u2ab0\u0338lantEqual;\u62e1ilde;\uc000\u227f\u0338erset\u0100;E\u0d58\u0d5b\uc000\u2283\u20d2qual;\u6289ilde\u0200;EFT\u0d6e\u0d6f\u0d75\u0d7f\u6241qual;\u6244ullEqual;\u6247ilde;\u6249erticalBar;\u6224cr;\uc000\ud835\udca9ilde\u803b\xd1\u40d1;\u439d\u0700Eacdfgmoprstuv\u0dbd\u0dc2\u0dc9\u0dd5\u0ddb\u0de0\u0de7\u0dfc\u0e02\u0e20\u0e22\u0e32\u0e3f\u0e44lig;\u4152cute\u803b\xd3\u40d3\u0100iy\u0dce\u0dd3rc\u803b\xd4\u40d4;\u441eblac;\u4150r;\uc000\ud835\udd12rave\u803b\xd2\u40d2\u0180aei\u0dee\u0df2\u0df6cr;\u414cga;\u43a9cron;\u439fpf;\uc000\ud835\udd46enCurly\u0100DQ\u0e0e\u0e1aoubleQuote;\u601cuote;\u6018;\u6a54\u0100cl\u0e27\u0e2cr;\uc000\ud835\udcaaash\u803b\xd8\u40d8i\u016c\u0e37\u0e3cde\u803b\xd5\u40d5es;\u6a37ml\u803b\xd6\u40d6er\u0100BP\u0e4b\u0e60\u0100ar\u0e50\u0e53r;\u603eac\u0100ek\u0e5a\u0e5c;\u63deet;\u63b4arenthesis;\u63dc\u0480acfhilors\u0e7f\u0e87\u0e8a\u0e8f\u0e92\u0e94\u0e9d\u0eb0\u0efcrtialD;\u6202y;\u441fr;\uc000\ud835\udd13i;\u43a6;\u43a0usMinus;\u40b1\u0100ip\u0ea2\u0eadncareplan\xe5\u069df;\u6119\u0200;eio\u0eb9\u0eba\u0ee0\u0ee4\u6abbcedes\u0200;EST\u0ec8\u0ec9\u0ecf\u0eda\u627aqual;\u6aaflantEqual;\u627cilde;\u627eme;\u6033\u0100dp\u0ee9\u0eeeuct;\u620fortion\u0100;a\u0225\u0ef9l;\u621d\u0100ci\u0f01\u0f06r;\uc000\ud835\udcab;\u43a8\u0200Ufos\u0f11\u0f16\u0f1b\u0f1fOT\u803b\"\u4022r;\uc000\ud835\udd14pf;\u611acr;\uc000\ud835\udcac\u0600BEacefhiorsu\u0f3e\u0f43\u0f47\u0f60\u0f73\u0fa7\u0faa\u0fad\u1096\u10a9\u10b4\u10bearr;\u6910G\u803b\xae\u40ae\u0180cnr\u0f4e\u0f53\u0f56ute;\u4154g;\u67ebr\u0100;t\u0f5c\u0f5d\u61a0l;\u6916\u0180aey\u0f67\u0f6c\u0f71ron;\u4158dil;\u4156;\u4420\u0100;v\u0f78\u0f79\u611cerse\u0100EU\u0f82\u0f99\u0100lq\u0f87\u0f8eement;\u620builibrium;\u61cbpEquilibrium;\u696fr\xbb\u0f79o;\u43a1ght\u0400ACDFTUVa\u0fc1\u0feb\u0ff3\u1022\u1028\u105b\u1087\u03d8\u0100nr\u0fc6\u0fd2gleBracket;\u67e9row\u0180;BL\u0fdc\u0fdd\u0fe1\u6192ar;\u61e5eftArrow;\u61c4eiling;\u6309o\u01f5\u0ff9\0\u1005bleBracket;\u67e7n\u01d4\u100a\0\u1014eeVector;\u695dector\u0100;B\u101d\u101e\u61c2ar;\u6955loor;\u630b\u0100er\u102d\u1043e\u0180;AV\u1035\u1036\u103c\u62a2rrow;\u61a6ector;\u695biangle\u0180;BE\u1050\u1051\u1055\u62b3ar;\u69d0qual;\u62b5p\u0180DTV\u1063\u106e\u1078ownVector;\u694feeVector;\u695cector\u0100;B\u1082\u1083\u61bear;\u6954ector\u0100;B\u1091\u1092\u61c0ar;\u6953\u0100pu\u109b\u109ef;\u611dndImplies;\u6970ightarrow;\u61db\u0100ch\u10b9\u10bcr;\u611b;\u61b1leDelayed;\u69f4\u0680HOacfhimoqstu\u10e4\u10f1\u10f7\u10fd\u1119\u111e\u1151\u1156\u1161\u1167\u11b5\u11bb\u11bf\u0100Cc\u10e9\u10eeHcy;\u4429y;\u4428FTcy;\u442ccute;\u415a\u0280;aeiy\u1108\u1109\u110e\u1113\u1117\u6abcron;\u4160dil;\u415erc;\u415c;\u4421r;\uc000\ud835\udd16ort\u0200DLRU\u112a\u1134\u113e\u1149ownArrow\xbb\u041eeftArrow\xbb\u089aightArrow\xbb\u0fddpArrow;\u6191gma;\u43a3allCircle;\u6218pf;\uc000\ud835\udd4a\u0272\u116d\0\0\u1170t;\u621aare\u0200;ISU\u117b\u117c\u1189\u11af\u65a1ntersection;\u6293u\u0100bp\u118f\u119eset\u0100;E\u1197\u1198\u628fqual;\u6291erset\u0100;E\u11a8\u11a9\u6290qual;\u6292nion;\u6294cr;\uc000\ud835\udcaear;\u62c6\u0200bcmp\u11c8\u11db\u1209\u120b\u0100;s\u11cd\u11ce\u62d0et\u0100;E\u11cd\u11d5qual;\u6286\u0100ch\u11e0\u1205eeds\u0200;EST\u11ed\u11ee\u11f4\u11ff\u627bqual;\u6ab0lantEqual;\u627dilde;\u627fTh\xe1\u0f8c;\u6211\u0180;es\u1212\u1213\u1223\u62d1rset\u0100;E\u121c\u121d\u6283qual;\u6287et\xbb\u1213\u0580HRSacfhiors\u123e\u1244\u1249\u1255\u125e\u1271\u1276\u129f\u12c2\u12c8\u12d1ORN\u803b\xde\u40deADE;\u6122\u0100Hc\u124e\u1252cy;\u440by;\u4426\u0100bu\u125a\u125c;\u4009;\u43a4\u0180aey\u1265\u126a\u126fron;\u4164dil;\u4162;\u4422r;\uc000\ud835\udd17\u0100ei\u127b\u1289\u01f2\u1280\0\u1287efore;\u6234a;\u4398\u0100cn\u128e\u1298kSpace;\uc000\u205f\u200aSpace;\u6009lde\u0200;EFT\u12ab\u12ac\u12b2\u12bc\u623cqual;\u6243ullEqual;\u6245ilde;\u6248pf;\uc000\ud835\udd4bipleDot;\u60db\u0100ct\u12d6\u12dbr;\uc000\ud835\udcafrok;\u4166\u0ae1\u12f7\u130e\u131a\u1326\0\u132c\u1331\0\0\0\0\0\u1338\u133d\u1377\u1385\0\u13ff\u1404\u140a\u1410\u0100cr\u12fb\u1301ute\u803b\xda\u40dar\u0100;o\u1307\u1308\u619fcir;\u6949r\u01e3\u1313\0\u1316y;\u440eve;\u416c\u0100iy\u131e\u1323rc\u803b\xdb\u40db;\u4423blac;\u4170r;\uc000\ud835\udd18rave\u803b\xd9\u40d9acr;\u416a\u0100di\u1341\u1369er\u0100BP\u1348\u135d\u0100ar\u134d\u1350r;\u405fac\u0100ek\u1357\u1359;\u63dfet;\u63b5arenthesis;\u63ddon\u0100;P\u1370\u1371\u62c3lus;\u628e\u0100gp\u137b\u137fon;\u4172f;\uc000\ud835\udd4c\u0400ADETadps\u1395\u13ae\u13b8\u13c4\u03e8\u13d2\u13d7\u13f3rrow\u0180;BD\u1150\u13a0\u13a4ar;\u6912ownArrow;\u61c5ownArrow;\u6195quilibrium;\u696eee\u0100;A\u13cb\u13cc\u62a5rrow;\u61a5own\xe1\u03f3er\u0100LR\u13de\u13e8eftArrow;\u6196ightArrow;\u6197i\u0100;l\u13f9\u13fa\u43d2on;\u43a5ing;\u416ecr;\uc000\ud835\udcb0ilde;\u4168ml\u803b\xdc\u40dc\u0480Dbcdefosv\u1427\u142c\u1430\u1433\u143e\u1485\u148a\u1490\u1496ash;\u62abar;\u6aeby;\u4412ash\u0100;l\u143b\u143c\u62a9;\u6ae6\u0100er\u1443\u1445;\u62c1\u0180bty\u144c\u1450\u147aar;\u6016\u0100;i\u144f\u1455cal\u0200BLST\u1461\u1465\u146a\u1474ar;\u6223ine;\u407ceparator;\u6758ilde;\u6240ThinSpace;\u600ar;\uc000\ud835\udd19pf;\uc000\ud835\udd4dcr;\uc000\ud835\udcb1dash;\u62aa\u0280cefos\u14a7\u14ac\u14b1\u14b6\u14bcirc;\u4174dge;\u62c0r;\uc000\ud835\udd1apf;\uc000\ud835\udd4ecr;\uc000\ud835\udcb2\u0200fios\u14cb\u14d0\u14d2\u14d8r;\uc000\ud835\udd1b;\u439epf;\uc000\ud835\udd4fcr;\uc000\ud835\udcb3\u0480AIUacfosu\u14f1\u14f5\u14f9\u14fd\u1504\u150f\u1514\u151a\u1520cy;\u442fcy;\u4407cy;\u442ecute\u803b\xdd\u40dd\u0100iy\u1509\u150drc;\u4176;\u442br;\uc000\ud835\udd1cpf;\uc000\ud835\udd50cr;\uc000\ud835\udcb4ml;\u4178\u0400Hacdefos\u1535\u1539\u153f\u154b\u154f\u155d\u1560\u1564cy;\u4416cute;\u4179\u0100ay\u1544\u1549ron;\u417d;\u4417ot;\u417b\u01f2\u1554\0\u155boWidt\xe8\u0ad9a;\u4396r;\u6128pf;\u6124cr;\uc000\ud835\udcb5\u0be1\u1583\u158a\u1590\0\u15b0\u15b6\u15bf\0\0\0\0\u15c6\u15db\u15eb\u165f\u166d\0\u1695\u169b\u16b2\u16b9\0\u16becute\u803b\xe1\u40e1reve;\u4103\u0300;Ediuy\u159c\u159d\u15a1\u15a3\u15a8\u15ad\u623e;\uc000\u223e\u0333;\u623frc\u803b\xe2\u40e2te\u80bb\xb4\u0306;\u4430lig\u803b\xe6\u40e6\u0100;r\xb2\u15ba;\uc000\ud835\udd1erave\u803b\xe0\u40e0\u0100ep\u15ca\u15d6\u0100fp\u15cf\u15d4sym;\u6135\xe8\u15d3ha;\u43b1\u0100ap\u15dfc\u0100cl\u15e4\u15e7r;\u4101g;\u6a3f\u0264\u15f0\0\0\u160a\u0280;adsv\u15fa\u15fb\u15ff\u1601\u1607\u6227nd;\u6a55;\u6a5clope;\u6a58;\u6a5a\u0380;elmrsz\u1618\u1619\u161b\u161e\u163f\u164f\u1659\u6220;\u69a4e\xbb\u1619sd\u0100;a\u1625\u1626\u6221\u0461\u1630\u1632\u1634\u1636\u1638\u163a\u163c\u163e;\u69a8;\u69a9;\u69aa;\u69ab;\u69ac;\u69ad;\u69ae;\u69aft\u0100;v\u1645\u1646\u621fb\u0100;d\u164c\u164d\u62be;\u699d\u0100pt\u1654\u1657h;\u6222\xbb\xb9arr;\u637c\u0100gp\u1663\u1667on;\u4105f;\uc000\ud835\udd52\u0380;Eaeiop\u12c1\u167b\u167d\u1682\u1684\u1687\u168a;\u6a70cir;\u6a6f;\u624ad;\u624bs;\u4027rox\u0100;e\u12c1\u1692\xf1\u1683ing\u803b\xe5\u40e5\u0180cty\u16a1\u16a6\u16a8r;\uc000\ud835\udcb6;\u402amp\u0100;e\u12c1\u16af\xf1\u0288ilde\u803b\xe3\u40e3ml\u803b\xe4\u40e4\u0100ci\u16c2\u16c8onin\xf4\u0272nt;\u6a11\u0800Nabcdefiklnoprsu\u16ed\u16f1\u1730\u173c\u1743\u1748\u1778\u177d\u17e0\u17e6\u1839\u1850\u170d\u193d\u1948\u1970ot;\u6aed\u0100cr\u16f6\u171ek\u0200ceps\u1700\u1705\u170d\u1713ong;\u624cpsilon;\u43f6rime;\u6035im\u0100;e\u171a\u171b\u623dq;\u62cd\u0176\u1722\u1726ee;\u62bded\u0100;g\u172c\u172d\u6305e\xbb\u172drk\u0100;t\u135c\u1737brk;\u63b6\u0100oy\u1701\u1741;\u4431quo;\u601e\u0280cmprt\u1753\u175b\u1761\u1764\u1768aus\u0100;e\u010a\u0109ptyv;\u69b0s\xe9\u170cno\xf5\u0113\u0180ahw\u176f\u1771\u1773;\u43b2;\u6136een;\u626cr;\uc000\ud835\udd1fg\u0380costuvw\u178d\u179d\u17b3\u17c1\u17d5\u17db\u17de\u0180aiu\u1794\u1796\u179a\xf0\u0760rc;\u65efp\xbb\u1371\u0180dpt\u17a4\u17a8\u17adot;\u6a00lus;\u6a01imes;\u6a02\u0271\u17b9\0\0\u17becup;\u6a06ar;\u6605riangle\u0100du\u17cd\u17d2own;\u65bdp;\u65b3plus;\u6a04e\xe5\u1444\xe5\u14adarow;\u690d\u0180ako\u17ed\u1826\u1835\u0100cn\u17f2\u1823k\u0180lst\u17fa\u05ab\u1802ozenge;\u69ebriangle\u0200;dlr\u1812\u1813\u1818\u181d\u65b4own;\u65beeft;\u65c2ight;\u65b8k;\u6423\u01b1\u182b\0\u1833\u01b2\u182f\0\u1831;\u6592;\u65914;\u6593ck;\u6588\u0100eo\u183e\u184d\u0100;q\u1843\u1846\uc000=\u20e5uiv;\uc000\u2261\u20e5t;\u6310\u0200ptwx\u1859\u185e\u1867\u186cf;\uc000\ud835\udd53\u0100;t\u13cb\u1863om\xbb\u13cctie;\u62c8\u0600DHUVbdhmptuv\u1885\u1896\u18aa\u18bb\u18d7\u18db\u18ec\u18ff\u1905\u190a\u1910\u1921\u0200LRlr\u188e\u1890\u1892\u1894;\u6557;\u6554;\u6556;\u6553\u0280;DUdu\u18a1\u18a2\u18a4\u18a6\u18a8\u6550;\u6566;\u6569;\u6564;\u6567\u0200LRlr\u18b3\u18b5\u18b7\u18b9;\u655d;\u655a;\u655c;\u6559\u0380;HLRhlr\u18ca\u18cb\u18cd\u18cf\u18d1\u18d3\u18d5\u6551;\u656c;\u6563;\u6560;\u656b;\u6562;\u655fox;\u69c9\u0200LRlr\u18e4\u18e6\u18e8\u18ea;\u6555;\u6552;\u6510;\u650c\u0280;DUdu\u06bd\u18f7\u18f9\u18fb\u18fd;\u6565;\u6568;\u652c;\u6534inus;\u629flus;\u629eimes;\u62a0\u0200LRlr\u1919\u191b\u191d\u191f;\u655b;\u6558;\u6518;\u6514\u0380;HLRhlr\u1930\u1931\u1933\u1935\u1937\u1939\u193b\u6502;\u656a;\u6561;\u655e;\u653c;\u6524;\u651c\u0100ev\u0123\u1942bar\u803b\xa6\u40a6\u0200ceio\u1951\u1956\u195a\u1960r;\uc000\ud835\udcb7mi;\u604fm\u0100;e\u171a\u171cl\u0180;bh\u1968\u1969\u196b\u405c;\u69c5sub;\u67c8\u016c\u1974\u197el\u0100;e\u1979\u197a\u6022t\xbb\u197ap\u0180;Ee\u012f\u1985\u1987;\u6aae\u0100;q\u06dc\u06db\u0ce1\u19a7\0\u19e8\u1a11\u1a15\u1a32\0\u1a37\u1a50\0\0\u1ab4\0\0\u1ac1\0\0\u1b21\u1b2e\u1b4d\u1b52\0\u1bfd\0\u1c0c\u0180cpr\u19ad\u19b2\u19ddute;\u4107\u0300;abcds\u19bf\u19c0\u19c4\u19ca\u19d5\u19d9\u6229nd;\u6a44rcup;\u6a49\u0100au\u19cf\u19d2p;\u6a4bp;\u6a47ot;\u6a40;\uc000\u2229\ufe00\u0100eo\u19e2\u19e5t;\u6041\xee\u0693\u0200aeiu\u19f0\u19fb\u1a01\u1a05\u01f0\u19f5\0\u19f8s;\u6a4don;\u410ddil\u803b\xe7\u40e7rc;\u4109ps\u0100;s\u1a0c\u1a0d\u6a4cm;\u6a50ot;\u410b\u0180dmn\u1a1b\u1a20\u1a26il\u80bb\xb8\u01adptyv;\u69b2t\u8100\xa2;e\u1a2d\u1a2e\u40a2r\xe4\u01b2r;\uc000\ud835\udd20\u0180cei\u1a3d\u1a40\u1a4dy;\u4447ck\u0100;m\u1a47\u1a48\u6713ark\xbb\u1a48;\u43c7r\u0380;Ecefms\u1a5f\u1a60\u1a62\u1a6b\u1aa4\u1aaa\u1aae\u65cb;\u69c3\u0180;el\u1a69\u1a6a\u1a6d\u42c6q;\u6257e\u0261\u1a74\0\0\u1a88rrow\u0100lr\u1a7c\u1a81eft;\u61baight;\u61bb\u0280RSacd\u1a92\u1a94\u1a96\u1a9a\u1a9f\xbb\u0f47;\u64c8st;\u629birc;\u629aash;\u629dnint;\u6a10id;\u6aefcir;\u69c2ubs\u0100;u\u1abb\u1abc\u6663it\xbb\u1abc\u02ec\u1ac7\u1ad4\u1afa\0\u1b0aon\u0100;e\u1acd\u1ace\u403a\u0100;q\xc7\xc6\u026d\u1ad9\0\0\u1ae2a\u0100;t\u1ade\u1adf\u402c;\u4040\u0180;fl\u1ae8\u1ae9\u1aeb\u6201\xee\u1160e\u0100mx\u1af1\u1af6ent\xbb\u1ae9e\xf3\u024d\u01e7\u1afe\0\u1b07\u0100;d\u12bb\u1b02ot;\u6a6dn\xf4\u0246\u0180fry\u1b10\u1b14\u1b17;\uc000\ud835\udd54o\xe4\u0254\u8100\xa9;s\u0155\u1b1dr;\u6117\u0100ao\u1b25\u1b29rr;\u61b5ss;\u6717\u0100cu\u1b32\u1b37r;\uc000\ud835\udcb8\u0100bp\u1b3c\u1b44\u0100;e\u1b41\u1b42\u6acf;\u6ad1\u0100;e\u1b49\u1b4a\u6ad0;\u6ad2dot;\u62ef\u0380delprvw\u1b60\u1b6c\u1b77\u1b82\u1bac\u1bd4\u1bf9arr\u0100lr\u1b68\u1b6a;\u6938;\u6935\u0270\u1b72\0\0\u1b75r;\u62dec;\u62dfarr\u0100;p\u1b7f\u1b80\u61b6;\u693d\u0300;bcdos\u1b8f\u1b90\u1b96\u1ba1\u1ba5\u1ba8\u622arcap;\u6a48\u0100au\u1b9b\u1b9ep;\u6a46p;\u6a4aot;\u628dr;\u6a45;\uc000\u222a\ufe00\u0200alrv\u1bb5\u1bbf\u1bde\u1be3rr\u0100;m\u1bbc\u1bbd\u61b7;\u693cy\u0180evw\u1bc7\u1bd4\u1bd8q\u0270\u1bce\0\0\u1bd2re\xe3\u1b73u\xe3\u1b75ee;\u62ceedge;\u62cfen\u803b\xa4\u40a4earrow\u0100lr\u1bee\u1bf3eft\xbb\u1b80ight\xbb\u1bbde\xe4\u1bdd\u0100ci\u1c01\u1c07onin\xf4\u01f7nt;\u6231lcty;\u632d\u0980AHabcdefhijlorstuwz\u1c38\u1c3b\u1c3f\u1c5d\u1c69\u1c75\u1c8a\u1c9e\u1cac\u1cb7\u1cfb\u1cff\u1d0d\u1d7b\u1d91\u1dab\u1dbb\u1dc6\u1dcdr\xf2\u0381ar;\u6965\u0200glrs\u1c48\u1c4d\u1c52\u1c54ger;\u6020eth;\u6138\xf2\u1133h\u0100;v\u1c5a\u1c5b\u6010\xbb\u090a\u016b\u1c61\u1c67arow;\u690fa\xe3\u0315\u0100ay\u1c6e\u1c73ron;\u410f;\u4434\u0180;ao\u0332\u1c7c\u1c84\u0100gr\u02bf\u1c81r;\u61catseq;\u6a77\u0180glm\u1c91\u1c94\u1c98\u803b\xb0\u40b0ta;\u43b4ptyv;\u69b1\u0100ir\u1ca3\u1ca8sht;\u697f;\uc000\ud835\udd21ar\u0100lr\u1cb3\u1cb5\xbb\u08dc\xbb\u101e\u0280aegsv\u1cc2\u0378\u1cd6\u1cdc\u1ce0m\u0180;os\u0326\u1cca\u1cd4nd\u0100;s\u0326\u1cd1uit;\u6666amma;\u43ddin;\u62f2\u0180;io\u1ce7\u1ce8\u1cf8\u40f7de\u8100\xf7;o\u1ce7\u1cf0ntimes;\u62c7n\xf8\u1cf7cy;\u4452c\u026f\u1d06\0\0\u1d0arn;\u631eop;\u630d\u0280lptuw\u1d18\u1d1d\u1d22\u1d49\u1d55lar;\u4024f;\uc000\ud835\udd55\u0280;emps\u030b\u1d2d\u1d37\u1d3d\u1d42q\u0100;d\u0352\u1d33ot;\u6251inus;\u6238lus;\u6214quare;\u62a1blebarwedg\xe5\xfan\u0180adh\u112e\u1d5d\u1d67ownarrow\xf3\u1c83arpoon\u0100lr\u1d72\u1d76ef\xf4\u1cb4igh\xf4\u1cb6\u0162\u1d7f\u1d85karo\xf7\u0f42\u026f\u1d8a\0\0\u1d8ern;\u631fop;\u630c\u0180cot\u1d98\u1da3\u1da6\u0100ry\u1d9d\u1da1;\uc000\ud835\udcb9;\u4455l;\u69f6rok;\u4111\u0100dr\u1db0\u1db4ot;\u62f1i\u0100;f\u1dba\u1816\u65bf\u0100ah\u1dc0\u1dc3r\xf2\u0429a\xf2\u0fa6angle;\u69a6\u0100ci\u1dd2\u1dd5y;\u445fgrarr;\u67ff\u0900Dacdefglmnopqrstux\u1e01\u1e09\u1e19\u1e38\u0578\u1e3c\u1e49\u1e61\u1e7e\u1ea5\u1eaf\u1ebd\u1ee1\u1f2a\u1f37\u1f44\u1f4e\u1f5a\u0100Do\u1e06\u1d34o\xf4\u1c89\u0100cs\u1e0e\u1e14ute\u803b\xe9\u40e9ter;\u6a6e\u0200aioy\u1e22\u1e27\u1e31\u1e36ron;\u411br\u0100;c\u1e2d\u1e2e\u6256\u803b\xea\u40ealon;\u6255;\u444dot;\u4117\u0100Dr\u1e41\u1e45ot;\u6252;\uc000\ud835\udd22\u0180;rs\u1e50\u1e51\u1e57\u6a9aave\u803b\xe8\u40e8\u0100;d\u1e5c\u1e5d\u6a96ot;\u6a98\u0200;ils\u1e6a\u1e6b\u1e72\u1e74\u6a99nters;\u63e7;\u6113\u0100;d\u1e79\u1e7a\u6a95ot;\u6a97\u0180aps\u1e85\u1e89\u1e97cr;\u4113ty\u0180;sv\u1e92\u1e93\u1e95\u6205et\xbb\u1e93p\u01001;\u1e9d\u1ea4\u0133\u1ea1\u1ea3;\u6004;\u6005\u6003\u0100gs\u1eaa\u1eac;\u414bp;\u6002\u0100gp\u1eb4\u1eb8on;\u4119f;\uc000\ud835\udd56\u0180als\u1ec4\u1ece\u1ed2r\u0100;s\u1eca\u1ecb\u62d5l;\u69e3us;\u6a71i\u0180;lv\u1eda\u1edb\u1edf\u43b5on\xbb\u1edb;\u43f5\u0200csuv\u1eea\u1ef3\u1f0b\u1f23\u0100io\u1eef\u1e31rc\xbb\u1e2e\u0269\u1ef9\0\0\u1efb\xed\u0548ant\u0100gl\u1f02\u1f06tr\xbb\u1e5dess\xbb\u1e7a\u0180aei\u1f12\u1f16\u1f1als;\u403dst;\u625fv\u0100;D\u0235\u1f20D;\u6a78parsl;\u69e5\u0100Da\u1f2f\u1f33ot;\u6253rr;\u6971\u0180cdi\u1f3e\u1f41\u1ef8r;\u612fo\xf4\u0352\u0100ah\u1f49\u1f4b;\u43b7\u803b\xf0\u40f0\u0100mr\u1f53\u1f57l\u803b\xeb\u40ebo;\u60ac\u0180cip\u1f61\u1f64\u1f67l;\u4021s\xf4\u056e\u0100eo\u1f6c\u1f74ctatio\xee\u0559nential\xe5\u0579\u09e1\u1f92\0\u1f9e\0\u1fa1\u1fa7\0\0\u1fc6\u1fcc\0\u1fd3\0\u1fe6\u1fea\u2000\0\u2008\u205allingdotse\xf1\u1e44y;\u4444male;\u6640\u0180ilr\u1fad\u1fb3\u1fc1lig;\u8000\ufb03\u0269\u1fb9\0\0\u1fbdg;\u8000\ufb00ig;\u8000\ufb04;\uc000\ud835\udd23lig;\u8000\ufb01lig;\uc000fj\u0180alt\u1fd9\u1fdc\u1fe1t;\u666dig;\u8000\ufb02ns;\u65b1of;\u4192\u01f0\u1fee\0\u1ff3f;\uc000\ud835\udd57\u0100ak\u05bf\u1ff7\u0100;v\u1ffc\u1ffd\u62d4;\u6ad9artint;\u6a0d\u0100ao\u200c\u2055\u0100cs\u2011\u2052\u03b1\u201a\u2030\u2038\u2045\u2048\0\u2050\u03b2\u2022\u2025\u2027\u202a\u202c\0\u202e\u803b\xbd\u40bd;\u6153\u803b\xbc\u40bc;\u6155;\u6159;\u615b\u01b3\u2034\0\u2036;\u6154;\u6156\u02b4\u203e\u2041\0\0\u2043\u803b\xbe\u40be;\u6157;\u615c5;\u6158\u01b6\u204c\0\u204e;\u615a;\u615d8;\u615el;\u6044wn;\u6322cr;\uc000\ud835\udcbb\u0880Eabcdefgijlnorstv\u2082\u2089\u209f\u20a5\u20b0\u20b4\u20f0\u20f5\u20fa\u20ff\u2103\u2112\u2138\u0317\u213e\u2152\u219e\u0100;l\u064d\u2087;\u6a8c\u0180cmp\u2090\u2095\u209dute;\u41f5ma\u0100;d\u209c\u1cda\u43b3;\u6a86reve;\u411f\u0100iy\u20aa\u20aerc;\u411d;\u4433ot;\u4121\u0200;lqs\u063e\u0642\u20bd\u20c9\u0180;qs\u063e\u064c\u20c4lan\xf4\u0665\u0200;cdl\u0665\u20d2\u20d5\u20e5c;\u6aa9ot\u0100;o\u20dc\u20dd\u6a80\u0100;l\u20e2\u20e3\u6a82;\u6a84\u0100;e\u20ea\u20ed\uc000\u22db\ufe00s;\u6a94r;\uc000\ud835\udd24\u0100;g\u0673\u061bmel;\u6137cy;\u4453\u0200;Eaj\u065a\u210c\u210e\u2110;\u6a92;\u6aa5;\u6aa4\u0200Eaes\u211b\u211d\u2129\u2134;\u6269p\u0100;p\u2123\u2124\u6a8arox\xbb\u2124\u0100;q\u212e\u212f\u6a88\u0100;q\u212e\u211bim;\u62e7pf;\uc000\ud835\udd58\u0100ci\u2143\u2146r;\u610am\u0180;el\u066b\u214e\u2150;\u6a8e;\u6a90\u8300>;cdlqr\u05ee\u2160\u216a\u216e\u2173\u2179\u0100ci\u2165\u2167;\u6aa7r;\u6a7aot;\u62d7Par;\u6995uest;\u6a7c\u0280adels\u2184\u216a\u2190\u0656\u219b\u01f0\u2189\0\u218epro\xf8\u209er;\u6978q\u0100lq\u063f\u2196les\xf3\u2088i\xed\u066b\u0100en\u21a3\u21adrtneqq;\uc000\u2269\ufe00\xc5\u21aa\u0500Aabcefkosy\u21c4\u21c7\u21f1\u21f5\u21fa\u2218\u221d\u222f\u2268\u227dr\xf2\u03a0\u0200ilmr\u21d0\u21d4\u21d7\u21dbrs\xf0\u1484f\xbb\u2024il\xf4\u06a9\u0100dr\u21e0\u21e4cy;\u444a\u0180;cw\u08f4\u21eb\u21efir;\u6948;\u61adar;\u610firc;\u4125\u0180alr\u2201\u220e\u2213rts\u0100;u\u2209\u220a\u6665it\xbb\u220alip;\u6026con;\u62b9r;\uc000\ud835\udd25s\u0100ew\u2223\u2229arow;\u6925arow;\u6926\u0280amopr\u223a\u223e\u2243\u225e\u2263rr;\u61fftht;\u623bk\u0100lr\u2249\u2253eftarrow;\u61a9ightarrow;\u61aaf;\uc000\ud835\udd59bar;\u6015\u0180clt\u226f\u2274\u2278r;\uc000\ud835\udcbdas\xe8\u21f4rok;\u4127\u0100bp\u2282\u2287ull;\u6043hen\xbb\u1c5b\u0ae1\u22a3\0\u22aa\0\u22b8\u22c5\u22ce\0\u22d5\u22f3\0\0\u22f8\u2322\u2367\u2362\u237f\0\u2386\u23aa\u23b4cute\u803b\xed\u40ed\u0180;iy\u0771\u22b0\u22b5rc\u803b\xee\u40ee;\u4438\u0100cx\u22bc\u22bfy;\u4435cl\u803b\xa1\u40a1\u0100fr\u039f\u22c9;\uc000\ud835\udd26rave\u803b\xec\u40ec\u0200;ino\u073e\u22dd\u22e9\u22ee\u0100in\u22e2\u22e6nt;\u6a0ct;\u622dfin;\u69dcta;\u6129lig;\u4133\u0180aop\u22fe\u231a\u231d\u0180cgt\u2305\u2308\u2317r;\u412b\u0180elp\u071f\u230f\u2313in\xe5\u078ear\xf4\u0720h;\u4131f;\u62b7ed;\u41b5\u0280;cfot\u04f4\u232c\u2331\u233d\u2341are;\u6105in\u0100;t\u2338\u2339\u621eie;\u69dddo\xf4\u2319\u0280;celp\u0757\u234c\u2350\u235b\u2361al;\u62ba\u0100gr\u2355\u2359er\xf3\u1563\xe3\u234darhk;\u6a17rod;\u6a3c\u0200cgpt\u236f\u2372\u2376\u237by;\u4451on;\u412ff;\uc000\ud835\udd5aa;\u43b9uest\u803b\xbf\u40bf\u0100ci\u238a\u238fr;\uc000\ud835\udcben\u0280;Edsv\u04f4\u239b\u239d\u23a1\u04f3;\u62f9ot;\u62f5\u0100;v\u23a6\u23a7\u62f4;\u62f3\u0100;i\u0777\u23aelde;\u4129\u01eb\u23b8\0\u23bccy;\u4456l\u803b\xef\u40ef\u0300cfmosu\u23cc\u23d7\u23dc\u23e1\u23e7\u23f5\u0100iy\u23d1\u23d5rc;\u4135;\u4439r;\uc000\ud835\udd27ath;\u4237pf;\uc000\ud835\udd5b\u01e3\u23ec\0\u23f1r;\uc000\ud835\udcbfrcy;\u4458kcy;\u4454\u0400acfghjos\u240b\u2416\u2422\u2427\u242d\u2431\u2435\u243bppa\u0100;v\u2413\u2414\u43ba;\u43f0\u0100ey\u241b\u2420dil;\u4137;\u443ar;\uc000\ud835\udd28reen;\u4138cy;\u4445cy;\u445cpf;\uc000\ud835\udd5ccr;\uc000\ud835\udcc0\u0b80ABEHabcdefghjlmnoprstuv\u2470\u2481\u2486\u248d\u2491\u250e\u253d\u255a\u2580\u264e\u265e\u2665\u2679\u267d\u269a\u26b2\u26d8\u275d\u2768\u278b\u27c0\u2801\u2812\u0180art\u2477\u247a\u247cr\xf2\u09c6\xf2\u0395ail;\u691barr;\u690e\u0100;g\u0994\u248b;\u6a8bar;\u6962\u0963\u24a5\0\u24aa\0\u24b1\0\0\0\0\0\u24b5\u24ba\0\u24c6\u24c8\u24cd\0\u24f9ute;\u413amptyv;\u69b4ra\xee\u084cbda;\u43bbg\u0180;dl\u088e\u24c1\u24c3;\u6991\xe5\u088e;\u6a85uo\u803b\xab\u40abr\u0400;bfhlpst\u0899\u24de\u24e6\u24e9\u24eb\u24ee\u24f1\u24f5\u0100;f\u089d\u24e3s;\u691fs;\u691d\xeb\u2252p;\u61abl;\u6939im;\u6973l;\u61a2\u0180;ae\u24ff\u2500\u2504\u6aabil;\u6919\u0100;s\u2509\u250a\u6aad;\uc000\u2aad\ufe00\u0180abr\u2515\u2519\u251drr;\u690crk;\u6772\u0100ak\u2522\u252cc\u0100ek\u2528\u252a;\u407b;\u405b\u0100es\u2531\u2533;\u698bl\u0100du\u2539\u253b;\u698f;\u698d\u0200aeuy\u2546\u254b\u2556\u2558ron;\u413e\u0100di\u2550\u2554il;\u413c\xec\u08b0\xe2\u2529;\u443b\u0200cqrs\u2563\u2566\u256d\u257da;\u6936uo\u0100;r\u0e19\u1746\u0100du\u2572\u2577har;\u6967shar;\u694bh;\u61b2\u0280;fgqs\u258b\u258c\u0989\u25f3\u25ff\u6264t\u0280ahlrt\u2598\u25a4\u25b7\u25c2\u25e8rrow\u0100;t\u0899\u25a1a\xe9\u24f6arpoon\u0100du\u25af\u25b4own\xbb\u045ap\xbb\u0966eftarrows;\u61c7ight\u0180ahs\u25cd\u25d6\u25derrow\u0100;s\u08f4\u08a7arpoon\xf3\u0f98quigarro\xf7\u21f0hreetimes;\u62cb\u0180;qs\u258b\u0993\u25falan\xf4\u09ac\u0280;cdgs\u09ac\u260a\u260d\u261d\u2628c;\u6aa8ot\u0100;o\u2614\u2615\u6a7f\u0100;r\u261a\u261b\u6a81;\u6a83\u0100;e\u2622\u2625\uc000\u22da\ufe00s;\u6a93\u0280adegs\u2633\u2639\u263d\u2649\u264bppro\xf8\u24c6ot;\u62d6q\u0100gq\u2643\u2645\xf4\u0989gt\xf2\u248c\xf4\u099bi\xed\u09b2\u0180ilr\u2655\u08e1\u265asht;\u697c;\uc000\ud835\udd29\u0100;E\u099c\u2663;\u6a91\u0161\u2669\u2676r\u0100du\u25b2\u266e\u0100;l\u0965\u2673;\u696alk;\u6584cy;\u4459\u0280;acht\u0a48\u2688\u268b\u2691\u2696r\xf2\u25c1orne\xf2\u1d08ard;\u696bri;\u65fa\u0100io\u269f\u26a4dot;\u4140ust\u0100;a\u26ac\u26ad\u63b0che\xbb\u26ad\u0200Eaes\u26bb\u26bd\u26c9\u26d4;\u6268p\u0100;p\u26c3\u26c4\u6a89rox\xbb\u26c4\u0100;q\u26ce\u26cf\u6a87\u0100;q\u26ce\u26bbim;\u62e6\u0400abnoptwz\u26e9\u26f4\u26f7\u271a\u272f\u2741\u2747\u2750\u0100nr\u26ee\u26f1g;\u67ecr;\u61fdr\xeb\u08c1g\u0180lmr\u26ff\u270d\u2714eft\u0100ar\u09e6\u2707ight\xe1\u09f2apsto;\u67fcight\xe1\u09fdparrow\u0100lr\u2725\u2729ef\xf4\u24edight;\u61ac\u0180afl\u2736\u2739\u273dr;\u6985;\uc000\ud835\udd5dus;\u6a2dimes;\u6a34\u0161\u274b\u274fst;\u6217\xe1\u134e\u0180;ef\u2757\u2758\u1800\u65cange\xbb\u2758ar\u0100;l\u2764\u2765\u4028t;\u6993\u0280achmt\u2773\u2776\u277c\u2785\u2787r\xf2\u08a8orne\xf2\u1d8car\u0100;d\u0f98\u2783;\u696d;\u600eri;\u62bf\u0300achiqt\u2798\u279d\u0a40\u27a2\u27ae\u27bbquo;\u6039r;\uc000\ud835\udcc1m\u0180;eg\u09b2\u27aa\u27ac;\u6a8d;\u6a8f\u0100bu\u252a\u27b3o\u0100;r\u0e1f\u27b9;\u601arok;\u4142\u8400<;cdhilqr\u082b\u27d2\u2639\u27dc\u27e0\u27e5\u27ea\u27f0\u0100ci\u27d7\u27d9;\u6aa6r;\u6a79re\xe5\u25f2mes;\u62c9arr;\u6976uest;\u6a7b\u0100Pi\u27f5\u27f9ar;\u6996\u0180;ef\u2800\u092d\u181b\u65c3r\u0100du\u2807\u280dshar;\u694ahar;\u6966\u0100en\u2817\u2821rtneqq;\uc000\u2268\ufe00\xc5\u281e\u0700Dacdefhilnopsu\u2840\u2845\u2882\u288e\u2893\u28a0\u28a5\u28a8\u28da\u28e2\u28e4\u0a83\u28f3\u2902Dot;\u623a\u0200clpr\u284e\u2852\u2863\u287dr\u803b\xaf\u40af\u0100et\u2857\u2859;\u6642\u0100;e\u285e\u285f\u6720se\xbb\u285f\u0100;s\u103b\u2868to\u0200;dlu\u103b\u2873\u2877\u287bow\xee\u048cef\xf4\u090f\xf0\u13d1ker;\u65ae\u0100oy\u2887\u288cmma;\u6a29;\u443cash;\u6014asuredangle\xbb\u1626r;\uc000\ud835\udd2ao;\u6127\u0180cdn\u28af\u28b4\u28c9ro\u803b\xb5\u40b5\u0200;acd\u1464\u28bd\u28c0\u28c4s\xf4\u16a7ir;\u6af0ot\u80bb\xb7\u01b5us\u0180;bd\u28d2\u1903\u28d3\u6212\u0100;u\u1d3c\u28d8;\u6a2a\u0163\u28de\u28e1p;\u6adb\xf2\u2212\xf0\u0a81\u0100dp\u28e9\u28eeels;\u62a7f;\uc000\ud835\udd5e\u0100ct\u28f8\u28fdr;\uc000\ud835\udcc2pos\xbb\u159d\u0180;lm\u2909\u290a\u290d\u43bctimap;\u62b8\u0c00GLRVabcdefghijlmoprstuvw\u2942\u2953\u297e\u2989\u2998\u29da\u29e9\u2a15\u2a1a\u2a58\u2a5d\u2a83\u2a95\u2aa4\u2aa8\u2b04\u2b07\u2b44\u2b7f\u2bae\u2c34\u2c67\u2c7c\u2ce9\u0100gt\u2947\u294b;\uc000\u22d9\u0338\u0100;v\u2950\u0bcf\uc000\u226b\u20d2\u0180elt\u295a\u2972\u2976ft\u0100ar\u2961\u2967rrow;\u61cdightarrow;\u61ce;\uc000\u22d8\u0338\u0100;v\u297b\u0c47\uc000\u226a\u20d2ightarrow;\u61cf\u0100Dd\u298e\u2993ash;\u62afash;\u62ae\u0280bcnpt\u29a3\u29a7\u29ac\u29b1\u29ccla\xbb\u02deute;\u4144g;\uc000\u2220\u20d2\u0280;Eiop\u0d84\u29bc\u29c0\u29c5\u29c8;\uc000\u2a70\u0338d;\uc000\u224b\u0338s;\u4149ro\xf8\u0d84ur\u0100;a\u29d3\u29d4\u666el\u0100;s\u29d3\u0b38\u01f3\u29df\0\u29e3p\u80bb\xa0\u0b37mp\u0100;e\u0bf9\u0c00\u0280aeouy\u29f4\u29fe\u2a03\u2a10\u2a13\u01f0\u29f9\0\u29fb;\u6a43on;\u4148dil;\u4146ng\u0100;d\u0d7e\u2a0aot;\uc000\u2a6d\u0338p;\u6a42;\u443dash;\u6013\u0380;Aadqsx\u0b92\u2a29\u2a2d\u2a3b\u2a41\u2a45\u2a50rr;\u61d7r\u0100hr\u2a33\u2a36k;\u6924\u0100;o\u13f2\u13f0ot;\uc000\u2250\u0338ui\xf6\u0b63\u0100ei\u2a4a\u2a4ear;\u6928\xed\u0b98ist\u0100;s\u0ba0\u0b9fr;\uc000\ud835\udd2b\u0200Eest\u0bc5\u2a66\u2a79\u2a7c\u0180;qs\u0bbc\u2a6d\u0be1\u0180;qs\u0bbc\u0bc5\u2a74lan\xf4\u0be2i\xed\u0bea\u0100;r\u0bb6\u2a81\xbb\u0bb7\u0180Aap\u2a8a\u2a8d\u2a91r\xf2\u2971rr;\u61aear;\u6af2\u0180;sv\u0f8d\u2a9c\u0f8c\u0100;d\u2aa1\u2aa2\u62fc;\u62facy;\u445a\u0380AEadest\u2ab7\u2aba\u2abe\u2ac2\u2ac5\u2af6\u2af9r\xf2\u2966;\uc000\u2266\u0338rr;\u619ar;\u6025\u0200;fqs\u0c3b\u2ace\u2ae3\u2aeft\u0100ar\u2ad4\u2ad9rro\xf7\u2ac1ightarro\xf7\u2a90\u0180;qs\u0c3b\u2aba\u2aealan\xf4\u0c55\u0100;s\u0c55\u2af4\xbb\u0c36i\xed\u0c5d\u0100;r\u0c35\u2afei\u0100;e\u0c1a\u0c25i\xe4\u0d90\u0100pt\u2b0c\u2b11f;\uc000\ud835\udd5f\u8180\xac;in\u2b19\u2b1a\u2b36\u40acn\u0200;Edv\u0b89\u2b24\u2b28\u2b2e;\uc000\u22f9\u0338ot;\uc000\u22f5\u0338\u01e1\u0b89\u2b33\u2b35;\u62f7;\u62f6i\u0100;v\u0cb8\u2b3c\u01e1\u0cb8\u2b41\u2b43;\u62fe;\u62fd\u0180aor\u2b4b\u2b63\u2b69r\u0200;ast\u0b7b\u2b55\u2b5a\u2b5flle\xec\u0b7bl;\uc000\u2afd\u20e5;\uc000\u2202\u0338lint;\u6a14\u0180;ce\u0c92\u2b70\u2b73u\xe5\u0ca5\u0100;c\u0c98\u2b78\u0100;e\u0c92\u2b7d\xf1\u0c98\u0200Aait\u2b88\u2b8b\u2b9d\u2ba7r\xf2\u2988rr\u0180;cw\u2b94\u2b95\u2b99\u619b;\uc000\u2933\u0338;\uc000\u219d\u0338ghtarrow\xbb\u2b95ri\u0100;e\u0ccb\u0cd6\u0380chimpqu\u2bbd\u2bcd\u2bd9\u2b04\u0b78\u2be4\u2bef\u0200;cer\u0d32\u2bc6\u0d37\u2bc9u\xe5\u0d45;\uc000\ud835\udcc3ort\u026d\u2b05\0\0\u2bd6ar\xe1\u2b56m\u0100;e\u0d6e\u2bdf\u0100;q\u0d74\u0d73su\u0100bp\u2beb\u2bed\xe5\u0cf8\xe5\u0d0b\u0180bcp\u2bf6\u2c11\u2c19\u0200;Ees\u2bff\u2c00\u0d22\u2c04\u6284;\uc000\u2ac5\u0338et\u0100;e\u0d1b\u2c0bq\u0100;q\u0d23\u2c00c\u0100;e\u0d32\u2c17\xf1\u0d38\u0200;Ees\u2c22\u2c23\u0d5f\u2c27\u6285;\uc000\u2ac6\u0338et\u0100;e\u0d58\u2c2eq\u0100;q\u0d60\u2c23\u0200gilr\u2c3d\u2c3f\u2c45\u2c47\xec\u0bd7lde\u803b\xf1\u40f1\xe7\u0c43iangle\u0100lr\u2c52\u2c5ceft\u0100;e\u0c1a\u2c5a\xf1\u0c26ight\u0100;e\u0ccb\u2c65\xf1\u0cd7\u0100;m\u2c6c\u2c6d\u43bd\u0180;es\u2c74\u2c75\u2c79\u4023ro;\u6116p;\u6007\u0480DHadgilrs\u2c8f\u2c94\u2c99\u2c9e\u2ca3\u2cb0\u2cb6\u2cd3\u2ce3ash;\u62adarr;\u6904p;\uc000\u224d\u20d2ash;\u62ac\u0100et\u2ca8\u2cac;\uc000\u2265\u20d2;\uc000>\u20d2nfin;\u69de\u0180Aet\u2cbd\u2cc1\u2cc5rr;\u6902;\uc000\u2264\u20d2\u0100;r\u2cca\u2ccd\uc000<\u20d2ie;\uc000\u22b4\u20d2\u0100At\u2cd8\u2cdcrr;\u6903rie;\uc000\u22b5\u20d2im;\uc000\u223c\u20d2\u0180Aan\u2cf0\u2cf4\u2d02rr;\u61d6r\u0100hr\u2cfa\u2cfdk;\u6923\u0100;o\u13e7\u13e5ear;\u6927\u1253\u1a95\0\0\0\0\0\0\0\0\0\0\0\0\0\u2d2d\0\u2d38\u2d48\u2d60\u2d65\u2d72\u2d84\u1b07\0\0\u2d8d\u2dab\0\u2dc8\u2dce\0\u2ddc\u2e19\u2e2b\u2e3e\u2e43\u0100cs\u2d31\u1a97ute\u803b\xf3\u40f3\u0100iy\u2d3c\u2d45r\u0100;c\u1a9e\u2d42\u803b\xf4\u40f4;\u443e\u0280abios\u1aa0\u2d52\u2d57\u01c8\u2d5alac;\u4151v;\u6a38old;\u69bclig;\u4153\u0100cr\u2d69\u2d6dir;\u69bf;\uc000\ud835\udd2c\u036f\u2d79\0\0\u2d7c\0\u2d82n;\u42dbave\u803b\xf2\u40f2;\u69c1\u0100bm\u2d88\u0df4ar;\u69b5\u0200acit\u2d95\u2d98\u2da5\u2da8r\xf2\u1a80\u0100ir\u2d9d\u2da0r;\u69beoss;\u69bbn\xe5\u0e52;\u69c0\u0180aei\u2db1\u2db5\u2db9cr;\u414dga;\u43c9\u0180cdn\u2dc0\u2dc5\u01cdron;\u43bf;\u69b6pf;\uc000\ud835\udd60\u0180ael\u2dd4\u2dd7\u01d2r;\u69b7rp;\u69b9\u0380;adiosv\u2dea\u2deb\u2dee\u2e08\u2e0d\u2e10\u2e16\u6228r\xf2\u1a86\u0200;efm\u2df7\u2df8\u2e02\u2e05\u6a5dr\u0100;o\u2dfe\u2dff\u6134f\xbb\u2dff\u803b\xaa\u40aa\u803b\xba\u40bagof;\u62b6r;\u6a56lope;\u6a57;\u6a5b\u0180clo\u2e1f\u2e21\u2e27\xf2\u2e01ash\u803b\xf8\u40f8l;\u6298i\u016c\u2e2f\u2e34de\u803b\xf5\u40f5es\u0100;a\u01db\u2e3as;\u6a36ml\u803b\xf6\u40f6bar;\u633d\u0ae1\u2e5e\0\u2e7d\0\u2e80\u2e9d\0\u2ea2\u2eb9\0\0\u2ecb\u0e9c\0\u2f13\0\0\u2f2b\u2fbc\0\u2fc8r\u0200;ast\u0403\u2e67\u2e72\u0e85\u8100\xb6;l\u2e6d\u2e6e\u40b6le\xec\u0403\u0269\u2e78\0\0\u2e7bm;\u6af3;\u6afdy;\u443fr\u0280cimpt\u2e8b\u2e8f\u2e93\u1865\u2e97nt;\u4025od;\u402eil;\u6030enk;\u6031r;\uc000\ud835\udd2d\u0180imo\u2ea8\u2eb0\u2eb4\u0100;v\u2ead\u2eae\u43c6;\u43d5ma\xf4\u0a76ne;\u660e\u0180;tv\u2ebf\u2ec0\u2ec8\u43c0chfork\xbb\u1ffd;\u43d6\u0100au\u2ecf\u2edfn\u0100ck\u2ed5\u2eddk\u0100;h\u21f4\u2edb;\u610e\xf6\u21f4s\u0480;abcdemst\u2ef3\u2ef4\u1908\u2ef9\u2efd\u2f04\u2f06\u2f0a\u2f0e\u402bcir;\u6a23ir;\u6a22\u0100ou\u1d40\u2f02;\u6a25;\u6a72n\u80bb\xb1\u0e9dim;\u6a26wo;\u6a27\u0180ipu\u2f19\u2f20\u2f25ntint;\u6a15f;\uc000\ud835\udd61nd\u803b\xa3\u40a3\u0500;Eaceinosu\u0ec8\u2f3f\u2f41\u2f44\u2f47\u2f81\u2f89\u2f92\u2f7e\u2fb6;\u6ab3p;\u6ab7u\xe5\u0ed9\u0100;c\u0ece\u2f4c\u0300;acens\u0ec8\u2f59\u2f5f\u2f66\u2f68\u2f7eppro\xf8\u2f43urlye\xf1\u0ed9\xf1\u0ece\u0180aes\u2f6f\u2f76\u2f7approx;\u6ab9qq;\u6ab5im;\u62e8i\xed\u0edfme\u0100;s\u2f88\u0eae\u6032\u0180Eas\u2f78\u2f90\u2f7a\xf0\u2f75\u0180dfp\u0eec\u2f99\u2faf\u0180als\u2fa0\u2fa5\u2faalar;\u632eine;\u6312urf;\u6313\u0100;t\u0efb\u2fb4\xef\u0efbrel;\u62b0\u0100ci\u2fc0\u2fc5r;\uc000\ud835\udcc5;\u43c8ncsp;\u6008\u0300fiopsu\u2fda\u22e2\u2fdf\u2fe5\u2feb\u2ff1r;\uc000\ud835\udd2epf;\uc000\ud835\udd62rime;\u6057cr;\uc000\ud835\udcc6\u0180aeo\u2ff8\u3009\u3013t\u0100ei\u2ffe\u3005rnion\xf3\u06b0nt;\u6a16st\u0100;e\u3010\u3011\u403f\xf1\u1f19\xf4\u0f14\u0a80ABHabcdefhilmnoprstux\u3040\u3051\u3055\u3059\u30e0\u310e\u312b\u3147\u3162\u3172\u318e\u3206\u3215\u3224\u3229\u3258\u326e\u3272\u3290\u32b0\u32b7\u0180art\u3047\u304a\u304cr\xf2\u10b3\xf2\u03ddail;\u691car\xf2\u1c65ar;\u6964\u0380cdenqrt\u3068\u3075\u3078\u307f\u308f\u3094\u30cc\u0100eu\u306d\u3071;\uc000\u223d\u0331te;\u4155i\xe3\u116emptyv;\u69b3g\u0200;del\u0fd1\u3089\u308b\u308d;\u6992;\u69a5\xe5\u0fd1uo\u803b\xbb\u40bbr\u0580;abcfhlpstw\u0fdc\u30ac\u30af\u30b7\u30b9\u30bc\u30be\u30c0\u30c3\u30c7\u30cap;\u6975\u0100;f\u0fe0\u30b4s;\u6920;\u6933s;\u691e\xeb\u225d\xf0\u272el;\u6945im;\u6974l;\u61a3;\u619d\u0100ai\u30d1\u30d5il;\u691ao\u0100;n\u30db\u30dc\u6236al\xf3\u0f1e\u0180abr\u30e7\u30ea\u30eer\xf2\u17e5rk;\u6773\u0100ak\u30f3\u30fdc\u0100ek\u30f9\u30fb;\u407d;\u405d\u0100es\u3102\u3104;\u698cl\u0100du\u310a\u310c;\u698e;\u6990\u0200aeuy\u3117\u311c\u3127\u3129ron;\u4159\u0100di\u3121\u3125il;\u4157\xec\u0ff2\xe2\u30fa;\u4440\u0200clqs\u3134\u3137\u313d\u3144a;\u6937dhar;\u6969uo\u0100;r\u020e\u020dh;\u61b3\u0180acg\u314e\u315f\u0f44l\u0200;ips\u0f78\u3158\u315b\u109cn\xe5\u10bbar\xf4\u0fa9t;\u65ad\u0180ilr\u3169\u1023\u316esht;\u697d;\uc000\ud835\udd2f\u0100ao\u3177\u3186r\u0100du\u317d\u317f\xbb\u047b\u0100;l\u1091\u3184;\u696c\u0100;v\u318b\u318c\u43c1;\u43f1\u0180gns\u3195\u31f9\u31fcht\u0300ahlrst\u31a4\u31b0\u31c2\u31d8\u31e4\u31eerrow\u0100;t\u0fdc\u31ada\xe9\u30c8arpoon\u0100du\u31bb\u31bfow\xee\u317ep\xbb\u1092eft\u0100ah\u31ca\u31d0rrow\xf3\u0feaarpoon\xf3\u0551ightarrows;\u61c9quigarro\xf7\u30cbhreetimes;\u62ccg;\u42daingdotse\xf1\u1f32\u0180ahm\u320d\u3210\u3213r\xf2\u0feaa\xf2\u0551;\u600foust\u0100;a\u321e\u321f\u63b1che\xbb\u321fmid;\u6aee\u0200abpt\u3232\u323d\u3240\u3252\u0100nr\u3237\u323ag;\u67edr;\u61fer\xeb\u1003\u0180afl\u3247\u324a\u324er;\u6986;\uc000\ud835\udd63us;\u6a2eimes;\u6a35\u0100ap\u325d\u3267r\u0100;g\u3263\u3264\u4029t;\u6994olint;\u6a12ar\xf2\u31e3\u0200achq\u327b\u3280\u10bc\u3285quo;\u603ar;\uc000\ud835\udcc7\u0100bu\u30fb\u328ao\u0100;r\u0214\u0213\u0180hir\u3297\u329b\u32a0re\xe5\u31f8mes;\u62cai\u0200;efl\u32aa\u1059\u1821\u32ab\u65b9tri;\u69celuhar;\u6968;\u611e\u0d61\u32d5\u32db\u32df\u332c\u3338\u3371\0\u337a\u33a4\0\0\u33ec\u33f0\0\u3428\u3448\u345a\u34ad\u34b1\u34ca\u34f1\0\u3616\0\0\u3633cute;\u415bqu\xef\u27ba\u0500;Eaceinpsy\u11ed\u32f3\u32f5\u32ff\u3302\u330b\u330f\u331f\u3326\u3329;\u6ab4\u01f0\u32fa\0\u32fc;\u6ab8on;\u4161u\xe5\u11fe\u0100;d\u11f3\u3307il;\u415frc;\u415d\u0180Eas\u3316\u3318\u331b;\u6ab6p;\u6abaim;\u62e9olint;\u6a13i\xed\u1204;\u4441ot\u0180;be\u3334\u1d47\u3335\u62c5;\u6a66\u0380Aacmstx\u3346\u334a\u3357\u335b\u335e\u3363\u336drr;\u61d8r\u0100hr\u3350\u3352\xeb\u2228\u0100;o\u0a36\u0a34t\u803b\xa7\u40a7i;\u403bwar;\u6929m\u0100in\u3369\xf0nu\xf3\xf1t;\u6736r\u0100;o\u3376\u2055\uc000\ud835\udd30\u0200acoy\u3382\u3386\u3391\u33a0rp;\u666f\u0100hy\u338b\u338fcy;\u4449;\u4448rt\u026d\u3399\0\0\u339ci\xe4\u1464ara\xec\u2e6f\u803b\xad\u40ad\u0100gm\u33a8\u33b4ma\u0180;fv\u33b1\u33b2\u33b2\u43c3;\u43c2\u0400;deglnpr\u12ab\u33c5\u33c9\u33ce\u33d6\u33de\u33e1\u33e6ot;\u6a6a\u0100;q\u12b1\u12b0\u0100;E\u33d3\u33d4\u6a9e;\u6aa0\u0100;E\u33db\u33dc\u6a9d;\u6a9fe;\u6246lus;\u6a24arr;\u6972ar\xf2\u113d\u0200aeit\u33f8\u3408\u340f\u3417\u0100ls\u33fd\u3404lsetm\xe9\u336ahp;\u6a33parsl;\u69e4\u0100dl\u1463\u3414e;\u6323\u0100;e\u341c\u341d\u6aaa\u0100;s\u3422\u3423\u6aac;\uc000\u2aac\ufe00\u0180flp\u342e\u3433\u3442tcy;\u444c\u0100;b\u3438\u3439\u402f\u0100;a\u343e\u343f\u69c4r;\u633ff;\uc000\ud835\udd64a\u0100dr\u344d\u0402es\u0100;u\u3454\u3455\u6660it\xbb\u3455\u0180csu\u3460\u3479\u349f\u0100au\u3465\u346fp\u0100;s\u1188\u346b;\uc000\u2293\ufe00p\u0100;s\u11b4\u3475;\uc000\u2294\ufe00u\u0100bp\u347f\u348f\u0180;es\u1197\u119c\u3486et\u0100;e\u1197\u348d\xf1\u119d\u0180;es\u11a8\u11ad\u3496et\u0100;e\u11a8\u349d\xf1\u11ae\u0180;af\u117b\u34a6\u05b0r\u0165\u34ab\u05b1\xbb\u117car\xf2\u1148\u0200cemt\u34b9\u34be\u34c2\u34c5r;\uc000\ud835\udcc8tm\xee\xf1i\xec\u3415ar\xe6\u11be\u0100ar\u34ce\u34d5r\u0100;f\u34d4\u17bf\u6606\u0100an\u34da\u34edight\u0100ep\u34e3\u34eapsilo\xee\u1ee0h\xe9\u2eafs\xbb\u2852\u0280bcmnp\u34fb\u355e\u1209\u358b\u358e\u0480;Edemnprs\u350e\u350f\u3511\u3515\u351e\u3523\u352c\u3531\u3536\u6282;\u6ac5ot;\u6abd\u0100;d\u11da\u351aot;\u6ac3ult;\u6ac1\u0100Ee\u3528\u352a;\u6acb;\u628alus;\u6abfarr;\u6979\u0180eiu\u353d\u3552\u3555t\u0180;en\u350e\u3545\u354bq\u0100;q\u11da\u350feq\u0100;q\u352b\u3528m;\u6ac7\u0100bp\u355a\u355c;\u6ad5;\u6ad3c\u0300;acens\u11ed\u356c\u3572\u3579\u357b\u3326ppro\xf8\u32faurlye\xf1\u11fe\xf1\u11f3\u0180aes\u3582\u3588\u331bppro\xf8\u331aq\xf1\u3317g;\u666a\u0680123;Edehlmnps\u35a9\u35ac\u35af\u121c\u35b2\u35b4\u35c0\u35c9\u35d5\u35da\u35df\u35e8\u35ed\u803b\xb9\u40b9\u803b\xb2\u40b2\u803b\xb3\u40b3;\u6ac6\u0100os\u35b9\u35bct;\u6abeub;\u6ad8\u0100;d\u1222\u35c5ot;\u6ac4s\u0100ou\u35cf\u35d2l;\u67c9b;\u6ad7arr;\u697bult;\u6ac2\u0100Ee\u35e4\u35e6;\u6acc;\u628blus;\u6ac0\u0180eiu\u35f4\u3609\u360ct\u0180;en\u121c\u35fc\u3602q\u0100;q\u1222\u35b2eq\u0100;q\u35e7\u35e4m;\u6ac8\u0100bp\u3611\u3613;\u6ad4;\u6ad6\u0180Aan\u361c\u3620\u362drr;\u61d9r\u0100hr\u3626\u3628\xeb\u222e\u0100;o\u0a2b\u0a29war;\u692alig\u803b\xdf\u40df\u0be1\u3651\u365d\u3660\u12ce\u3673\u3679\0\u367e\u36c2\0\0\0\0\0\u36db\u3703\0\u3709\u376c\0\0\0\u3787\u0272\u3656\0\0\u365bget;\u6316;\u43c4r\xeb\u0e5f\u0180aey\u3666\u366b\u3670ron;\u4165dil;\u4163;\u4442lrec;\u6315r;\uc000\ud835\udd31\u0200eiko\u3686\u369d\u36b5\u36bc\u01f2\u368b\0\u3691e\u01004f\u1284\u1281a\u0180;sv\u3698\u3699\u369b\u43b8ym;\u43d1\u0100cn\u36a2\u36b2k\u0100as\u36a8\u36aeppro\xf8\u12c1im\xbb\u12acs\xf0\u129e\u0100as\u36ba\u36ae\xf0\u12c1rn\u803b\xfe\u40fe\u01ec\u031f\u36c6\u22e7es\u8180\xd7;bd\u36cf\u36d0\u36d8\u40d7\u0100;a\u190f\u36d5r;\u6a31;\u6a30\u0180eps\u36e1\u36e3\u3700\xe1\u2a4d\u0200;bcf\u0486\u36ec\u36f0\u36f4ot;\u6336ir;\u6af1\u0100;o\u36f9\u36fc\uc000\ud835\udd65rk;\u6ada\xe1\u3362rime;\u6034\u0180aip\u370f\u3712\u3764d\xe5\u1248\u0380adempst\u3721\u374d\u3740\u3751\u3757\u375c\u375fngle\u0280;dlqr\u3730\u3731\u3736\u3740\u3742\u65b5own\xbb\u1dbbeft\u0100;e\u2800\u373e\xf1\u092e;\u625cight\u0100;e\u32aa\u374b\xf1\u105aot;\u65ecinus;\u6a3alus;\u6a39b;\u69cdime;\u6a3bezium;\u63e2\u0180cht\u3772\u377d\u3781\u0100ry\u3777\u377b;\uc000\ud835\udcc9;\u4446cy;\u445brok;\u4167\u0100io\u378b\u378ex\xf4\u1777head\u0100lr\u3797\u37a0eftarro\xf7\u084fightarrow\xbb\u0f5d\u0900AHabcdfghlmoprstuw\u37d0\u37d3\u37d7\u37e4\u37f0\u37fc\u380e\u381c\u3823\u3834\u3851\u385d\u386b\u38a9\u38cc\u38d2\u38ea\u38f6r\xf2\u03edar;\u6963\u0100cr\u37dc\u37e2ute\u803b\xfa\u40fa\xf2\u1150r\u01e3\u37ea\0\u37edy;\u445eve;\u416d\u0100iy\u37f5\u37farc\u803b\xfb\u40fb;\u4443\u0180abh\u3803\u3806\u380br\xf2\u13adlac;\u4171a\xf2\u13c3\u0100ir\u3813\u3818sht;\u697e;\uc000\ud835\udd32rave\u803b\xf9\u40f9\u0161\u3827\u3831r\u0100lr\u382c\u382e\xbb\u0957\xbb\u1083lk;\u6580\u0100ct\u3839\u384d\u026f\u383f\0\0\u384arn\u0100;e\u3845\u3846\u631cr\xbb\u3846op;\u630fri;\u65f8\u0100al\u3856\u385acr;\u416b\u80bb\xa8\u0349\u0100gp\u3862\u3866on;\u4173f;\uc000\ud835\udd66\u0300adhlsu\u114b\u3878\u387d\u1372\u3891\u38a0own\xe1\u13b3arpoon\u0100lr\u3888\u388cef\xf4\u382digh\xf4\u382fi\u0180;hl\u3899\u389a\u389c\u43c5\xbb\u13faon\xbb\u389aparrows;\u61c8\u0180cit\u38b0\u38c4\u38c8\u026f\u38b6\0\0\u38c1rn\u0100;e\u38bc\u38bd\u631dr\xbb\u38bdop;\u630eng;\u416fri;\u65f9cr;\uc000\ud835\udcca\u0180dir\u38d9\u38dd\u38e2ot;\u62f0lde;\u4169i\u0100;f\u3730\u38e8\xbb\u1813\u0100am\u38ef\u38f2r\xf2\u38a8l\u803b\xfc\u40fcangle;\u69a7\u0780ABDacdeflnoprsz\u391c\u391f\u3929\u392d\u39b5\u39b8\u39bd\u39df\u39e4\u39e8\u39f3\u39f9\u39fd\u3a01\u3a20r\xf2\u03f7ar\u0100;v\u3926\u3927\u6ae8;\u6ae9as\xe8\u03e1\u0100nr\u3932\u3937grt;\u699c\u0380eknprst\u34e3\u3946\u394b\u3952\u395d\u3964\u3996app\xe1\u2415othin\xe7\u1e96\u0180hir\u34eb\u2ec8\u3959op\xf4\u2fb5\u0100;h\u13b7\u3962\xef\u318d\u0100iu\u3969\u396dgm\xe1\u33b3\u0100bp\u3972\u3984setneq\u0100;q\u397d\u3980\uc000\u228a\ufe00;\uc000\u2acb\ufe00setneq\u0100;q\u398f\u3992\uc000\u228b\ufe00;\uc000\u2acc\ufe00\u0100hr\u399b\u399fet\xe1\u369ciangle\u0100lr\u39aa\u39afeft\xbb\u0925ight\xbb\u1051y;\u4432ash\xbb\u1036\u0180elr\u39c4\u39d2\u39d7\u0180;be\u2dea\u39cb\u39cfar;\u62bbq;\u625alip;\u62ee\u0100bt\u39dc\u1468a\xf2\u1469r;\uc000\ud835\udd33tr\xe9\u39aesu\u0100bp\u39ef\u39f1\xbb\u0d1c\xbb\u0d59pf;\uc000\ud835\udd67ro\xf0\u0efbtr\xe9\u39b4\u0100cu\u3a06\u3a0br;\uc000\ud835\udccb\u0100bp\u3a10\u3a18n\u0100Ee\u3980\u3a16\xbb\u397en\u0100Ee\u3992\u3a1e\xbb\u3990igzag;\u699a\u0380cefoprs\u3a36\u3a3b\u3a56\u3a5b\u3a54\u3a61\u3a6airc;\u4175\u0100di\u3a40\u3a51\u0100bg\u3a45\u3a49ar;\u6a5fe\u0100;q\u15fa\u3a4f;\u6259erp;\u6118r;\uc000\ud835\udd34pf;\uc000\ud835\udd68\u0100;e\u1479\u3a66at\xe8\u1479cr;\uc000\ud835\udccc\u0ae3\u178e\u3a87\0\u3a8b\0\u3a90\u3a9b\0\0\u3a9d\u3aa8\u3aab\u3aaf\0\0\u3ac3\u3ace\0\u3ad8\u17dc\u17dftr\xe9\u17d1r;\uc000\ud835\udd35\u0100Aa\u3a94\u3a97r\xf2\u03c3r\xf2\u09f6;\u43be\u0100Aa\u3aa1\u3aa4r\xf2\u03b8r\xf2\u09eba\xf0\u2713is;\u62fb\u0180dpt\u17a4\u3ab5\u3abe\u0100fl\u3aba\u17a9;\uc000\ud835\udd69im\xe5\u17b2\u0100Aa\u3ac7\u3acar\xf2\u03cer\xf2\u0a01\u0100cq\u3ad2\u17b8r;\uc000\ud835\udccd\u0100pt\u17d6\u3adcr\xe9\u17d4\u0400acefiosu\u3af0\u3afd\u3b08\u3b0c\u3b11\u3b15\u3b1b\u3b21c\u0100uy\u3af6\u3afbte\u803b\xfd\u40fd;\u444f\u0100iy\u3b02\u3b06rc;\u4177;\u444bn\u803b\xa5\u40a5r;\uc000\ud835\udd36cy;\u4457pf;\uc000\ud835\udd6acr;\uc000\ud835\udcce\u0100cm\u3b26\u3b29y;\u444el\u803b\xff\u40ff\u0500acdefhiosw\u3b42\u3b48\u3b54\u3b58\u3b64\u3b69\u3b6d\u3b74\u3b7a\u3b80cute;\u417a\u0100ay\u3b4d\u3b52ron;\u417e;\u4437ot;\u417c\u0100et\u3b5d\u3b61tr\xe6\u155fa;\u43b6r;\uc000\ud835\udd37cy;\u4436grarr;\u61ddpf;\uc000\ud835\udd6bcr;\uc000\ud835\udccf\u0100jn\u3b85\u3b87;\u600dj;\u600c".split("").map(c => c.charCodeAt(0))));

/***/ }),
/* 343 */
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
// Generated using scripts/write-decode-map.ts
/* harmony default export */ __webpack_exports__["default"] = (new Uint16Array(
// prettier-ignore
"\u0200aglq\t\x15\x18\x1b\u026d\x0f\0\0\x12p;\u4026os;\u4027t;\u403et;\u403cuot;\u4022".split("").map(c => c.charCodeAt(0))));

/***/ }),
/* 344 */
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ decodeCodePoint; },
/* harmony export */   fromCodePoint: function() { return /* binding */ fromCodePoint; },
/* harmony export */   replaceCodePoint: function() { return /* binding */ replaceCodePoint; }
/* harmony export */ });
// Adapted from https://github.com/mathiasbynens/he/blob/36afe179392226cf1b6ccdb16ebbb7a5a844d93a/src/he.js#L106-L134
var _a;
const decodeMap = new Map([[0, 65533],
// C1 Unicode control character reference replacements
[128, 8364], [130, 8218], [131, 402], [132, 8222], [133, 8230], [134, 8224], [135, 8225], [136, 710], [137, 8240], [138, 352], [139, 8249], [140, 338], [142, 381], [145, 8216], [146, 8217], [147, 8220], [148, 8221], [149, 8226], [150, 8211], [151, 8212], [152, 732], [153, 8482], [154, 353], [155, 8250], [156, 339], [158, 382], [159, 376]]);
/**
 * Polyfill for `String.fromCodePoint`. It is used to create a string from a Unicode code point.
 */
const fromCodePoint =
// eslint-disable-next-line @typescript-eslint/no-unnecessary-condition, node/no-unsupported-features/es-builtins
(_a = String.fromCodePoint) !== null && _a !== void 0 ? _a : function (codePoint) {
  let output = "";
  if (codePoint > 0xffff) {
    codePoint -= 0x10000;
    output += String.fromCharCode(codePoint >>> 10 & 0x3ff | 0xd800);
    codePoint = 0xdc00 | codePoint & 0x3ff;
  }
  output += String.fromCharCode(codePoint);
  return output;
};
/**
 * Replace the given code point with a replacement character if it is a
 * surrogate or is outside the valid range. Otherwise return the code
 * point unchanged.
 */
function replaceCodePoint(codePoint) {
  var _a;
  if (codePoint >= 0xd800 && codePoint <= 0xdfff || codePoint > 0x10ffff) {
    return 0xfffd;
  }
  return (_a = decodeMap.get(codePoint)) !== null && _a !== void 0 ? _a : codePoint;
}
/**
 * Replace the code point if relevant, then convert it to a string.
 *
 * @deprecated Use `fromCodePoint(replaceCodePoint(codePoint))` instead.
 * @param codePoint The code point to decode.
 * @returns The decoded code point.
 */
function decodeCodePoint(codePoint) {
  return fromCodePoint(replaceCodePoint(codePoint));
}

/***/ }),
/* 345 */
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   CDATA: function() { return /* reexport safe */ _node_js__WEBPACK_IMPORTED_MODULE_1__.CDATA; },
/* harmony export */   Comment: function() { return /* reexport safe */ _node_js__WEBPACK_IMPORTED_MODULE_1__.Comment; },
/* harmony export */   DataNode: function() { return /* reexport safe */ _node_js__WEBPACK_IMPORTED_MODULE_1__.DataNode; },
/* harmony export */   Document: function() { return /* reexport safe */ _node_js__WEBPACK_IMPORTED_MODULE_1__.Document; },
/* harmony export */   DomHandler: function() { return /* binding */ DomHandler; },
/* harmony export */   Element: function() { return /* reexport safe */ _node_js__WEBPACK_IMPORTED_MODULE_1__.Element; },
/* harmony export */   Node: function() { return /* reexport safe */ _node_js__WEBPACK_IMPORTED_MODULE_1__.Node; },
/* harmony export */   NodeWithChildren: function() { return /* reexport safe */ _node_js__WEBPACK_IMPORTED_MODULE_1__.NodeWithChildren; },
/* harmony export */   ProcessingInstruction: function() { return /* reexport safe */ _node_js__WEBPACK_IMPORTED_MODULE_1__.ProcessingInstruction; },
/* harmony export */   Text: function() { return /* reexport safe */ _node_js__WEBPACK_IMPORTED_MODULE_1__.Text; },
/* harmony export */   cloneNode: function() { return /* reexport safe */ _node_js__WEBPACK_IMPORTED_MODULE_1__.cloneNode; },
/* harmony export */   hasChildren: function() { return /* reexport safe */ _node_js__WEBPACK_IMPORTED_MODULE_1__.hasChildren; },
/* harmony export */   isCDATA: function() { return /* reexport safe */ _node_js__WEBPACK_IMPORTED_MODULE_1__.isCDATA; },
/* harmony export */   isComment: function() { return /* reexport safe */ _node_js__WEBPACK_IMPORTED_MODULE_1__.isComment; },
/* harmony export */   isDirective: function() { return /* reexport safe */ _node_js__WEBPACK_IMPORTED_MODULE_1__.isDirective; },
/* harmony export */   isDocument: function() { return /* reexport safe */ _node_js__WEBPACK_IMPORTED_MODULE_1__.isDocument; },
/* harmony export */   isTag: function() { return /* reexport safe */ _node_js__WEBPACK_IMPORTED_MODULE_1__.isTag; },
/* harmony export */   isText: function() { return /* reexport safe */ _node_js__WEBPACK_IMPORTED_MODULE_1__.isText; }
/* harmony export */ });
/* harmony import */ var domelementtype__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(346);
/* harmony import */ var _node_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(347);



// Default options
const defaultOpts = {
  withStartIndices: false,
  withEndIndices: false,
  xmlMode: false
};
class DomHandler {
  /**
   * @param callback Called once parsing has completed.
   * @param options Settings for the handler.
   * @param elementCB Callback whenever a tag is closed.
   */
  constructor(callback, options, elementCB) {
    /** The elements of the DOM */
    this.dom = [];
    /** The root element for the DOM */
    this.root = new _node_js__WEBPACK_IMPORTED_MODULE_1__.Document(this.dom);
    /** Indicated whether parsing has been completed. */
    this.done = false;
    /** Stack of open tags. */
    this.tagStack = [this.root];
    /** A data node that is still being written to. */
    this.lastNode = null;
    /** Reference to the parser instance. Used for location information. */
    this.parser = null;
    // Make it possible to skip arguments, for backwards-compatibility
    if (typeof options === "function") {
      elementCB = options;
      options = defaultOpts;
    }
    if (typeof callback === "object") {
      options = callback;
      callback = undefined;
    }
    this.callback = callback !== null && callback !== void 0 ? callback : null;
    this.options = options !== null && options !== void 0 ? options : defaultOpts;
    this.elementCB = elementCB !== null && elementCB !== void 0 ? elementCB : null;
  }
  onparserinit(parser) {
    this.parser = parser;
  }
  // Resets the handler back to starting state
  onreset() {
    this.dom = [];
    this.root = new _node_js__WEBPACK_IMPORTED_MODULE_1__.Document(this.dom);
    this.done = false;
    this.tagStack = [this.root];
    this.lastNode = null;
    this.parser = null;
  }
  // Signals the handler that parsing is done
  onend() {
    if (this.done) return;
    this.done = true;
    this.parser = null;
    this.handleCallback(null);
  }
  onerror(error) {
    this.handleCallback(error);
  }
  onclosetag() {
    this.lastNode = null;
    const elem = this.tagStack.pop();
    if (this.options.withEndIndices) {
      elem.endIndex = this.parser.endIndex;
    }
    if (this.elementCB) this.elementCB(elem);
  }
  onopentag(name, attribs) {
    const type = this.options.xmlMode ? domelementtype__WEBPACK_IMPORTED_MODULE_0__.ElementType.Tag : undefined;
    const element = new _node_js__WEBPACK_IMPORTED_MODULE_1__.Element(name, attribs, undefined, type);
    this.addNode(element);
    this.tagStack.push(element);
  }
  ontext(data) {
    const {
      lastNode
    } = this;
    if (lastNode && lastNode.type === domelementtype__WEBPACK_IMPORTED_MODULE_0__.ElementType.Text) {
      lastNode.data += data;
      if (this.options.withEndIndices) {
        lastNode.endIndex = this.parser.endIndex;
      }
    } else {
      const node = new _node_js__WEBPACK_IMPORTED_MODULE_1__.Text(data);
      this.addNode(node);
      this.lastNode = node;
    }
  }
  oncomment(data) {
    if (this.lastNode && this.lastNode.type === domelementtype__WEBPACK_IMPORTED_MODULE_0__.ElementType.Comment) {
      this.lastNode.data += data;
      return;
    }
    const node = new _node_js__WEBPACK_IMPORTED_MODULE_1__.Comment(data);
    this.addNode(node);
    this.lastNode = node;
  }
  oncommentend() {
    this.lastNode = null;
  }
  oncdatastart() {
    const text = new _node_js__WEBPACK_IMPORTED_MODULE_1__.Text("");
    const node = new _node_js__WEBPACK_IMPORTED_MODULE_1__.CDATA([text]);
    this.addNode(node);
    text.parent = node;
    this.lastNode = text;
  }
  oncdataend() {
    this.lastNode = null;
  }
  onprocessinginstruction(name, data) {
    const node = new _node_js__WEBPACK_IMPORTED_MODULE_1__.ProcessingInstruction(name, data);
    this.addNode(node);
  }
  handleCallback(error) {
    if (typeof this.callback === "function") {
      this.callback(error, this.dom);
    } else if (error) {
      throw error;
    }
  }
  addNode(node) {
    const parent = this.tagStack[this.tagStack.length - 1];
    const previousSibling = parent.children[parent.children.length - 1];
    if (this.options.withStartIndices) {
      node.startIndex = this.parser.startIndex;
    }
    if (this.options.withEndIndices) {
      node.endIndex = this.parser.endIndex;
    }
    parent.children.push(node);
    if (previousSibling) {
      node.prev = previousSibling;
      previousSibling.next = node;
    }
    node.parent = parent;
    this.lastNode = null;
  }
}
/* harmony default export */ __webpack_exports__["default"] = (DomHandler);

/***/ }),
/* 346 */
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   CDATA: function() { return /* binding */ CDATA; },
/* harmony export */   Comment: function() { return /* binding */ Comment; },
/* harmony export */   Directive: function() { return /* binding */ Directive; },
/* harmony export */   Doctype: function() { return /* binding */ Doctype; },
/* harmony export */   ElementType: function() { return /* binding */ ElementType; },
/* harmony export */   Root: function() { return /* binding */ Root; },
/* harmony export */   Script: function() { return /* binding */ Script; },
/* harmony export */   Style: function() { return /* binding */ Style; },
/* harmony export */   Tag: function() { return /* binding */ Tag; },
/* harmony export */   Text: function() { return /* binding */ Text; },
/* harmony export */   isTag: function() { return /* binding */ isTag; }
/* harmony export */ });
/** Types of elements found in htmlparser2's DOM */
var ElementType;
(function (ElementType) {
  /** Type for the root element of a document */
  ElementType["Root"] = "root";
  /** Type for Text */
  ElementType["Text"] = "text";
  /** Type for <? ... ?> */
  ElementType["Directive"] = "directive";
  /** Type for <!-- ... --> */
  ElementType["Comment"] = "comment";
  /** Type for <script> tags */
  ElementType["Script"] = "script";
  /** Type for <style> tags */
  ElementType["Style"] = "style";
  /** Type for Any tag */
  ElementType["Tag"] = "tag";
  /** Type for <![CDATA[ ... ]]> */
  ElementType["CDATA"] = "cdata";
  /** Type for <!doctype ...> */
  ElementType["Doctype"] = "doctype";
})(ElementType || (ElementType = {}));
/**
 * Tests whether an element is a tag or not.
 *
 * @param elem Element to test
 */
function isTag(elem) {
  return elem.type === ElementType.Tag || elem.type === ElementType.Script || elem.type === ElementType.Style;
}
// Exports for backwards compatibility
/** Type for the root element of a document */
const Root = ElementType.Root;
/** Type for Text */
const Text = ElementType.Text;
/** Type for <? ... ?> */
const Directive = ElementType.Directive;
/** Type for <!-- ... --> */
const Comment = ElementType.Comment;
/** Type for <script> tags */
const Script = ElementType.Script;
/** Type for <style> tags */
const Style = ElementType.Style;
/** Type for Any tag */
const Tag = ElementType.Tag;
/** Type for <![CDATA[ ... ]]> */
const CDATA = ElementType.CDATA;
/** Type for <!doctype ...> */
const Doctype = ElementType.Doctype;

/***/ }),
/* 347 */
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   CDATA: function() { return /* binding */ CDATA; },
/* harmony export */   Comment: function() { return /* binding */ Comment; },
/* harmony export */   DataNode: function() { return /* binding */ DataNode; },
/* harmony export */   Document: function() { return /* binding */ Document; },
/* harmony export */   Element: function() { return /* binding */ Element; },
/* harmony export */   Node: function() { return /* binding */ Node; },
/* harmony export */   NodeWithChildren: function() { return /* binding */ NodeWithChildren; },
/* harmony export */   ProcessingInstruction: function() { return /* binding */ ProcessingInstruction; },
/* harmony export */   Text: function() { return /* binding */ Text; },
/* harmony export */   cloneNode: function() { return /* binding */ cloneNode; },
/* harmony export */   hasChildren: function() { return /* binding */ hasChildren; },
/* harmony export */   isCDATA: function() { return /* binding */ isCDATA; },
/* harmony export */   isComment: function() { return /* binding */ isComment; },
/* harmony export */   isDirective: function() { return /* binding */ isDirective; },
/* harmony export */   isDocument: function() { return /* binding */ isDocument; },
/* harmony export */   isTag: function() { return /* binding */ isTag; },
/* harmony export */   isText: function() { return /* binding */ isText; }
/* harmony export */ });
/* harmony import */ var domelementtype__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(346);

/**
 * This object will be used as the prototype for Nodes when creating a
 * DOM-Level-1-compliant structure.
 */
class Node {
  constructor() {
    /** Parent of the node */
    this.parent = null;
    /** Previous sibling */
    this.prev = null;
    /** Next sibling */
    this.next = null;
    /** The start index of the node. Requires `withStartIndices` on the handler to be `true. */
    this.startIndex = null;
    /** The end index of the node. Requires `withEndIndices` on the handler to be `true. */
    this.endIndex = null;
  }
  // Read-write aliases for properties
  /**
   * Same as {@link parent}.
   * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
   */
  get parentNode() {
    return this.parent;
  }
  set parentNode(parent) {
    this.parent = parent;
  }
  /**
   * Same as {@link prev}.
   * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
   */
  get previousSibling() {
    return this.prev;
  }
  set previousSibling(prev) {
    this.prev = prev;
  }
  /**
   * Same as {@link next}.
   * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
   */
  get nextSibling() {
    return this.next;
  }
  set nextSibling(next) {
    this.next = next;
  }
  /**
   * Clone this node, and optionally its children.
   *
   * @param recursive Clone child nodes as well.
   * @returns A clone of the node.
   */
  cloneNode(recursive = false) {
    return cloneNode(this, recursive);
  }
}
/**
 * A node that contains some data.
 */
class DataNode extends Node {
  /**
   * @param data The content of the data node
   */
  constructor(data) {
    super();
    this.data = data;
  }
  /**
   * Same as {@link data}.
   * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
   */
  get nodeValue() {
    return this.data;
  }
  set nodeValue(data) {
    this.data = data;
  }
}
/**
 * Text within the document.
 */
class Text extends DataNode {
  constructor() {
    super(...arguments);
    this.type = domelementtype__WEBPACK_IMPORTED_MODULE_0__.ElementType.Text;
  }
  get nodeType() {
    return 3;
  }
}
/**
 * Comments within the document.
 */
class Comment extends DataNode {
  constructor() {
    super(...arguments);
    this.type = domelementtype__WEBPACK_IMPORTED_MODULE_0__.ElementType.Comment;
  }
  get nodeType() {
    return 8;
  }
}
/**
 * Processing instructions, including doc types.
 */
class ProcessingInstruction extends DataNode {
  constructor(name, data) {
    super(data);
    this.name = name;
    this.type = domelementtype__WEBPACK_IMPORTED_MODULE_0__.ElementType.Directive;
  }
  get nodeType() {
    return 1;
  }
}
/**
 * A `Node` that can have children.
 */
class NodeWithChildren extends Node {
  /**
   * @param children Children of the node. Only certain node types can have children.
   */
  constructor(children) {
    super();
    this.children = children;
  }
  // Aliases
  /** First child of the node. */
  get firstChild() {
    var _a;
    return (_a = this.children[0]) !== null && _a !== void 0 ? _a : null;
  }
  /** Last child of the node. */
  get lastChild() {
    return this.children.length > 0 ? this.children[this.children.length - 1] : null;
  }
  /**
   * Same as {@link children}.
   * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
   */
  get childNodes() {
    return this.children;
  }
  set childNodes(children) {
    this.children = children;
  }
}
class CDATA extends NodeWithChildren {
  constructor() {
    super(...arguments);
    this.type = domelementtype__WEBPACK_IMPORTED_MODULE_0__.ElementType.CDATA;
  }
  get nodeType() {
    return 4;
  }
}
/**
 * The root node of the document.
 */
class Document extends NodeWithChildren {
  constructor() {
    super(...arguments);
    this.type = domelementtype__WEBPACK_IMPORTED_MODULE_0__.ElementType.Root;
  }
  get nodeType() {
    return 9;
  }
}
/**
 * An element within the DOM.
 */
class Element extends NodeWithChildren {
  /**
   * @param name Name of the tag, eg. `div`, `span`.
   * @param attribs Object mapping attribute names to attribute values.
   * @param children Children of the node.
   */
  constructor(name, attribs, children = [], type = name === "script" ? domelementtype__WEBPACK_IMPORTED_MODULE_0__.ElementType.Script : name === "style" ? domelementtype__WEBPACK_IMPORTED_MODULE_0__.ElementType.Style : domelementtype__WEBPACK_IMPORTED_MODULE_0__.ElementType.Tag) {
    super(children);
    this.name = name;
    this.attribs = attribs;
    this.type = type;
  }
  get nodeType() {
    return 1;
  }
  // DOM Level 1 aliases
  /**
   * Same as {@link name}.
   * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
   */
  get tagName() {
    return this.name;
  }
  set tagName(name) {
    this.name = name;
  }
  get attributes() {
    return Object.keys(this.attribs).map(name => {
      var _a, _b;
      return {
        name,
        value: this.attribs[name],
        namespace: (_a = this["x-attribsNamespace"]) === null || _a === void 0 ? void 0 : _a[name],
        prefix: (_b = this["x-attribsPrefix"]) === null || _b === void 0 ? void 0 : _b[name]
      };
    });
  }
}
/**
 * @param node Node to check.
 * @returns `true` if the node is a `Element`, `false` otherwise.
 */
function isTag(node) {
  return (0,domelementtype__WEBPACK_IMPORTED_MODULE_0__.isTag)(node);
}
/**
 * @param node Node to check.
 * @returns `true` if the node has the type `CDATA`, `false` otherwise.
 */
function isCDATA(node) {
  return node.type === domelementtype__WEBPACK_IMPORTED_MODULE_0__.ElementType.CDATA;
}
/**
 * @param node Node to check.
 * @returns `true` if the node has the type `Text`, `false` otherwise.
 */
function isText(node) {
  return node.type === domelementtype__WEBPACK_IMPORTED_MODULE_0__.ElementType.Text;
}
/**
 * @param node Node to check.
 * @returns `true` if the node has the type `Comment`, `false` otherwise.
 */
function isComment(node) {
  return node.type === domelementtype__WEBPACK_IMPORTED_MODULE_0__.ElementType.Comment;
}
/**
 * @param node Node to check.
 * @returns `true` if the node has the type `ProcessingInstruction`, `false` otherwise.
 */
function isDirective(node) {
  return node.type === domelementtype__WEBPACK_IMPORTED_MODULE_0__.ElementType.Directive;
}
/**
 * @param node Node to check.
 * @returns `true` if the node has the type `ProcessingInstruction`, `false` otherwise.
 */
function isDocument(node) {
  return node.type === domelementtype__WEBPACK_IMPORTED_MODULE_0__.ElementType.Root;
}
/**
 * @param node Node to check.
 * @returns `true` if the node has children, `false` otherwise.
 */
function hasChildren(node) {
  return Object.prototype.hasOwnProperty.call(node, "children");
}
/**
 * Clone a node, and optionally its children.
 *
 * @param recursive Clone child nodes as well.
 * @returns A clone of the node.
 */
function cloneNode(node, recursive = false) {
  let result;
  if (isText(node)) {
    result = new Text(node.data);
  } else if (isComment(node)) {
    result = new Comment(node.data);
  } else if (isTag(node)) {
    const children = recursive ? cloneChildren(node.children) : [];
    const clone = new Element(node.name, {
      ...node.attribs
    }, children);
    children.forEach(child => child.parent = clone);
    if (node.namespace != null) {
      clone.namespace = node.namespace;
    }
    if (node["x-attribsNamespace"]) {
      clone["x-attribsNamespace"] = {
        ...node["x-attribsNamespace"]
      };
    }
    if (node["x-attribsPrefix"]) {
      clone["x-attribsPrefix"] = {
        ...node["x-attribsPrefix"]
      };
    }
    result = clone;
  } else if (isCDATA(node)) {
    const children = recursive ? cloneChildren(node.children) : [];
    const clone = new CDATA(children);
    children.forEach(child => child.parent = clone);
    result = clone;
  } else if (isDocument(node)) {
    const children = recursive ? cloneChildren(node.children) : [];
    const clone = new Document(children);
    children.forEach(child => child.parent = clone);
    if (node["x-mode"]) {
      clone["x-mode"] = node["x-mode"];
    }
    result = clone;
  } else if (isDirective(node)) {
    const instruction = new ProcessingInstruction(node.name, node.data);
    if (node["x-name"] != null) {
      instruction["x-name"] = node["x-name"];
      instruction["x-publicId"] = node["x-publicId"];
      instruction["x-systemId"] = node["x-systemId"];
    }
    result = instruction;
  } else {
    throw new Error(`Not implemented yet: ${node.type}`);
  }
  result.startIndex = node.startIndex;
  result.endIndex = node.endIndex;
  if (node.sourceCodeLocation != null) {
    result.sourceCodeLocation = node.sourceCodeLocation;
  }
  return result;
}
function cloneChildren(childs) {
  const children = childs.map(child => cloneNode(child, true));
  for (let i = 1; i < children.length; i++) {
    children[i].prev = children[i - 1];
    children[i - 1].next = children[i];
  }
  return children;
}

/***/ }),
/* 348 */
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   DocumentPosition: function() { return /* reexport safe */ _helpers_js__WEBPACK_IMPORTED_MODULE_5__.DocumentPosition; },
/* harmony export */   append: function() { return /* reexport safe */ _manipulation_js__WEBPACK_IMPORTED_MODULE_2__.append; },
/* harmony export */   appendChild: function() { return /* reexport safe */ _manipulation_js__WEBPACK_IMPORTED_MODULE_2__.appendChild; },
/* harmony export */   compareDocumentPosition: function() { return /* reexport safe */ _helpers_js__WEBPACK_IMPORTED_MODULE_5__.compareDocumentPosition; },
/* harmony export */   existsOne: function() { return /* reexport safe */ _querying_js__WEBPACK_IMPORTED_MODULE_3__.existsOne; },
/* harmony export */   filter: function() { return /* reexport safe */ _querying_js__WEBPACK_IMPORTED_MODULE_3__.filter; },
/* harmony export */   find: function() { return /* reexport safe */ _querying_js__WEBPACK_IMPORTED_MODULE_3__.find; },
/* harmony export */   findAll: function() { return /* reexport safe */ _querying_js__WEBPACK_IMPORTED_MODULE_3__.findAll; },
/* harmony export */   findOne: function() { return /* reexport safe */ _querying_js__WEBPACK_IMPORTED_MODULE_3__.findOne; },
/* harmony export */   findOneChild: function() { return /* reexport safe */ _querying_js__WEBPACK_IMPORTED_MODULE_3__.findOneChild; },
/* harmony export */   getAttributeValue: function() { return /* reexport safe */ _traversal_js__WEBPACK_IMPORTED_MODULE_1__.getAttributeValue; },
/* harmony export */   getChildren: function() { return /* reexport safe */ _traversal_js__WEBPACK_IMPORTED_MODULE_1__.getChildren; },
/* harmony export */   getElementById: function() { return /* reexport safe */ _legacy_js__WEBPACK_IMPORTED_MODULE_4__.getElementById; },
/* harmony export */   getElements: function() { return /* reexport safe */ _legacy_js__WEBPACK_IMPORTED_MODULE_4__.getElements; },
/* harmony export */   getElementsByTagName: function() { return /* reexport safe */ _legacy_js__WEBPACK_IMPORTED_MODULE_4__.getElementsByTagName; },
/* harmony export */   getElementsByTagType: function() { return /* reexport safe */ _legacy_js__WEBPACK_IMPORTED_MODULE_4__.getElementsByTagType; },
/* harmony export */   getFeed: function() { return /* reexport safe */ _feeds_js__WEBPACK_IMPORTED_MODULE_6__.getFeed; },
/* harmony export */   getInnerHTML: function() { return /* reexport safe */ _stringify_js__WEBPACK_IMPORTED_MODULE_0__.getInnerHTML; },
/* harmony export */   getName: function() { return /* reexport safe */ _traversal_js__WEBPACK_IMPORTED_MODULE_1__.getName; },
/* harmony export */   getOuterHTML: function() { return /* reexport safe */ _stringify_js__WEBPACK_IMPORTED_MODULE_0__.getOuterHTML; },
/* harmony export */   getParent: function() { return /* reexport safe */ _traversal_js__WEBPACK_IMPORTED_MODULE_1__.getParent; },
/* harmony export */   getSiblings: function() { return /* reexport safe */ _traversal_js__WEBPACK_IMPORTED_MODULE_1__.getSiblings; },
/* harmony export */   getText: function() { return /* reexport safe */ _stringify_js__WEBPACK_IMPORTED_MODULE_0__.getText; },
/* harmony export */   hasAttrib: function() { return /* reexport safe */ _traversal_js__WEBPACK_IMPORTED_MODULE_1__.hasAttrib; },
/* harmony export */   hasChildren: function() { return /* reexport safe */ domhandler__WEBPACK_IMPORTED_MODULE_7__.hasChildren; },
/* harmony export */   innerText: function() { return /* reexport safe */ _stringify_js__WEBPACK_IMPORTED_MODULE_0__.innerText; },
/* harmony export */   isCDATA: function() { return /* reexport safe */ domhandler__WEBPACK_IMPORTED_MODULE_7__.isCDATA; },
/* harmony export */   isComment: function() { return /* reexport safe */ domhandler__WEBPACK_IMPORTED_MODULE_7__.isComment; },
/* harmony export */   isDocument: function() { return /* reexport safe */ domhandler__WEBPACK_IMPORTED_MODULE_7__.isDocument; },
/* harmony export */   isTag: function() { return /* reexport safe */ domhandler__WEBPACK_IMPORTED_MODULE_7__.isTag; },
/* harmony export */   isText: function() { return /* reexport safe */ domhandler__WEBPACK_IMPORTED_MODULE_7__.isText; },
/* harmony export */   nextElementSibling: function() { return /* reexport safe */ _traversal_js__WEBPACK_IMPORTED_MODULE_1__.nextElementSibling; },
/* harmony export */   prepend: function() { return /* reexport safe */ _manipulation_js__WEBPACK_IMPORTED_MODULE_2__.prepend; },
/* harmony export */   prependChild: function() { return /* reexport safe */ _manipulation_js__WEBPACK_IMPORTED_MODULE_2__.prependChild; },
/* harmony export */   prevElementSibling: function() { return /* reexport safe */ _traversal_js__WEBPACK_IMPORTED_MODULE_1__.prevElementSibling; },
/* harmony export */   removeElement: function() { return /* reexport safe */ _manipulation_js__WEBPACK_IMPORTED_MODULE_2__.removeElement; },
/* harmony export */   removeSubsets: function() { return /* reexport safe */ _helpers_js__WEBPACK_IMPORTED_MODULE_5__.removeSubsets; },
/* harmony export */   replaceElement: function() { return /* reexport safe */ _manipulation_js__WEBPACK_IMPORTED_MODULE_2__.replaceElement; },
/* harmony export */   testElement: function() { return /* reexport safe */ _legacy_js__WEBPACK_IMPORTED_MODULE_4__.testElement; },
/* harmony export */   textContent: function() { return /* reexport safe */ _stringify_js__WEBPACK_IMPORTED_MODULE_0__.textContent; },
/* harmony export */   uniqueSort: function() { return /* reexport safe */ _helpers_js__WEBPACK_IMPORTED_MODULE_5__.uniqueSort; }
/* harmony export */ });
/* harmony import */ var _stringify_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(349);
/* harmony import */ var _traversal_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(356);
/* harmony import */ var _manipulation_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(357);
/* harmony import */ var _querying_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(358);
/* harmony import */ var _legacy_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(359);
/* harmony import */ var _helpers_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(360);
/* harmony import */ var _feeds_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(361);
/* harmony import */ var domhandler__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(345);







/** @deprecated Use these methods from `domhandler` directly. */


/***/ }),
/* 349 */
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   getInnerHTML: function() { return /* binding */ getInnerHTML; },
/* harmony export */   getOuterHTML: function() { return /* binding */ getOuterHTML; },
/* harmony export */   getText: function() { return /* binding */ getText; },
/* harmony export */   innerText: function() { return /* binding */ innerText; },
/* harmony export */   textContent: function() { return /* binding */ textContent; }
/* harmony export */ });
/* harmony import */ var domhandler__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(345);
/* harmony import */ var dom_serializer__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(350);
/* harmony import */ var domelementtype__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(346);



/**
 * @category Stringify
 * @deprecated Use the `dom-serializer` module directly.
 * @param node Node to get the outer HTML of.
 * @param options Options for serialization.
 * @returns `node`'s outer HTML.
 */
function getOuterHTML(node, options) {
  return (0,dom_serializer__WEBPACK_IMPORTED_MODULE_1__["default"])(node, options);
}
/**
 * @category Stringify
 * @deprecated Use the `dom-serializer` module directly.
 * @param node Node to get the inner HTML of.
 * @param options Options for serialization.
 * @returns `node`'s inner HTML.
 */
function getInnerHTML(node, options) {
  return (0,domhandler__WEBPACK_IMPORTED_MODULE_0__.hasChildren)(node) ? node.children.map(node => getOuterHTML(node, options)).join("") : "";
}
/**
 * Get a node's inner text. Same as `textContent`, but inserts newlines for `<br>` tags. Ignores comments.
 *
 * @category Stringify
 * @deprecated Use `textContent` instead.
 * @param node Node to get the inner text of.
 * @returns `node`'s inner text.
 */
function getText(node) {
  if (Array.isArray(node)) return node.map(getText).join("");
  if ((0,domhandler__WEBPACK_IMPORTED_MODULE_0__.isTag)(node)) return node.name === "br" ? "\n" : getText(node.children);
  if ((0,domhandler__WEBPACK_IMPORTED_MODULE_0__.isCDATA)(node)) return getText(node.children);
  if ((0,domhandler__WEBPACK_IMPORTED_MODULE_0__.isText)(node)) return node.data;
  return "";
}
/**
 * Get a node's text content. Ignores comments.
 *
 * @category Stringify
 * @param node Node to get the text content of.
 * @returns `node`'s text content.
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/Node/textContent}
 */
function textContent(node) {
  if (Array.isArray(node)) return node.map(textContent).join("");
  if ((0,domhandler__WEBPACK_IMPORTED_MODULE_0__.hasChildren)(node) && !(0,domhandler__WEBPACK_IMPORTED_MODULE_0__.isComment)(node)) {
    return textContent(node.children);
  }
  if ((0,domhandler__WEBPACK_IMPORTED_MODULE_0__.isText)(node)) return node.data;
  return "";
}
/**
 * Get a node's inner text, ignoring `<script>` and `<style>` tags. Ignores comments.
 *
 * @category Stringify
 * @param node Node to get the inner text of.
 * @returns `node`'s inner text.
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/Node/innerText}
 */
function innerText(node) {
  if (Array.isArray(node)) return node.map(innerText).join("");
  if ((0,domhandler__WEBPACK_IMPORTED_MODULE_0__.hasChildren)(node) && (node.type === domelementtype__WEBPACK_IMPORTED_MODULE_2__.ElementType.Tag || (0,domhandler__WEBPACK_IMPORTED_MODULE_0__.isCDATA)(node))) {
    return innerText(node.children);
  }
  if ((0,domhandler__WEBPACK_IMPORTED_MODULE_0__.isText)(node)) return node.data;
  return "";
}

/***/ }),
/* 350 */
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   render: function() { return /* binding */ render; }
/* harmony export */ });
/* harmony import */ var domelementtype__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(346);
/* harmony import */ var entities__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(351);
/* harmony import */ var _foreignNames_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(355);
/*
 * Module dependencies
 */


/**
 * Mixed-case SVG and MathML tags & attributes
 * recognized by the HTML parser.
 *
 * @see https://html.spec.whatwg.org/multipage/parsing.html#parsing-main-inforeign
 */

const unencodedElements = new Set(["style", "script", "xmp", "iframe", "noembed", "noframes", "plaintext", "noscript"]);
function replaceQuotes(value) {
  return value.replace(/"/g, "&quot;");
}
/**
 * Format attributes
 */
function formatAttributes(attributes, opts) {
  var _a;
  if (!attributes) return;
  const encode = ((_a = opts.encodeEntities) !== null && _a !== void 0 ? _a : opts.decodeEntities) === false ? replaceQuotes : opts.xmlMode || opts.encodeEntities !== "utf8" ? entities__WEBPACK_IMPORTED_MODULE_1__.encodeXML : entities__WEBPACK_IMPORTED_MODULE_1__.escapeAttribute;
  return Object.keys(attributes).map(key => {
    var _a, _b;
    const value = (_a = attributes[key]) !== null && _a !== void 0 ? _a : "";
    if (opts.xmlMode === "foreign") {
      /* Fix up mixed-case attribute names */
      key = (_b = _foreignNames_js__WEBPACK_IMPORTED_MODULE_2__.attributeNames.get(key)) !== null && _b !== void 0 ? _b : key;
    }
    if (!opts.emptyAttrs && !opts.xmlMode && value === "") {
      return key;
    }
    return `${key}="${encode(value)}"`;
  }).join(" ");
}
/**
 * Self-enclosing tags
 */
const singleTag = new Set(["area", "base", "basefont", "br", "col", "command", "embed", "frame", "hr", "img", "input", "isindex", "keygen", "link", "meta", "param", "source", "track", "wbr"]);
/**
 * Renders a DOM node or an array of DOM nodes to a string.
 *
 * Can be thought of as the equivalent of the `outerHTML` of the passed node(s).
 *
 * @param node Node to be rendered.
 * @param options Changes serialization behavior
 */
function render(node, options = {}) {
  const nodes = "length" in node ? node : [node];
  let output = "";
  for (let i = 0; i < nodes.length; i++) {
    output += renderNode(nodes[i], options);
  }
  return output;
}
/* harmony default export */ __webpack_exports__["default"] = (render);
function renderNode(node, options) {
  switch (node.type) {
    case domelementtype__WEBPACK_IMPORTED_MODULE_0__.Root:
      return render(node.children, options);
    // @ts-expect-error We don't use `Doctype` yet
    case domelementtype__WEBPACK_IMPORTED_MODULE_0__.Doctype:
    case domelementtype__WEBPACK_IMPORTED_MODULE_0__.Directive:
      return renderDirective(node);
    case domelementtype__WEBPACK_IMPORTED_MODULE_0__.Comment:
      return renderComment(node);
    case domelementtype__WEBPACK_IMPORTED_MODULE_0__.CDATA:
      return renderCdata(node);
    case domelementtype__WEBPACK_IMPORTED_MODULE_0__.Script:
    case domelementtype__WEBPACK_IMPORTED_MODULE_0__.Style:
    case domelementtype__WEBPACK_IMPORTED_MODULE_0__.Tag:
      return renderTag(node, options);
    case domelementtype__WEBPACK_IMPORTED_MODULE_0__.Text:
      return renderText(node, options);
  }
}
const foreignModeIntegrationPoints = new Set(["mi", "mo", "mn", "ms", "mtext", "annotation-xml", "foreignObject", "desc", "title"]);
const foreignElements = new Set(["svg", "math"]);
function renderTag(elem, opts) {
  var _a;
  // Handle SVG / MathML in HTML
  if (opts.xmlMode === "foreign") {
    /* Fix up mixed-case element names */
    elem.name = (_a = _foreignNames_js__WEBPACK_IMPORTED_MODULE_2__.elementNames.get(elem.name)) !== null && _a !== void 0 ? _a : elem.name;
    /* Exit foreign mode at integration points */
    if (elem.parent && foreignModeIntegrationPoints.has(elem.parent.name)) {
      opts = {
        ...opts,
        xmlMode: false
      };
    }
  }
  if (!opts.xmlMode && foreignElements.has(elem.name)) {
    opts = {
      ...opts,
      xmlMode: "foreign"
    };
  }
  let tag = `<${elem.name}`;
  const attribs = formatAttributes(elem.attribs, opts);
  if (attribs) {
    tag += ` ${attribs}`;
  }
  if (elem.children.length === 0 && (opts.xmlMode ?
  // In XML mode or foreign mode, and user hasn't explicitly turned off self-closing tags
  opts.selfClosingTags !== false :
  // User explicitly asked for self-closing tags, even in HTML mode
  opts.selfClosingTags && singleTag.has(elem.name))) {
    if (!opts.xmlMode) tag += " ";
    tag += "/>";
  } else {
    tag += ">";
    if (elem.children.length > 0) {
      tag += render(elem.children, opts);
    }
    if (opts.xmlMode || !singleTag.has(elem.name)) {
      tag += `</${elem.name}>`;
    }
  }
  return tag;
}
function renderDirective(elem) {
  return `<${elem.data}>`;
}
function renderText(elem, opts) {
  var _a;
  let data = elem.data || "";
  // If entities weren't decoded, no need to encode them back
  if (((_a = opts.encodeEntities) !== null && _a !== void 0 ? _a : opts.decodeEntities) !== false && !(!opts.xmlMode && elem.parent && unencodedElements.has(elem.parent.name))) {
    data = opts.xmlMode || opts.encodeEntities !== "utf8" ? (0,entities__WEBPACK_IMPORTED_MODULE_1__.encodeXML)(data) : (0,entities__WEBPACK_IMPORTED_MODULE_1__.escapeText)(data);
  }
  return data;
}
function renderCdata(elem) {
  return `<![CDATA[${elem.children[0].data}]]>`;
}
function renderComment(elem) {
  return `<!--${elem.data}-->`;
}

/***/ }),
/* 351 */
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   DecodingMode: function() { return /* reexport safe */ _decode_js__WEBPACK_IMPORTED_MODULE_0__.DecodingMode; },
/* harmony export */   EncodingMode: function() { return /* binding */ EncodingMode; },
/* harmony export */   EntityDecoder: function() { return /* reexport safe */ _decode_js__WEBPACK_IMPORTED_MODULE_0__.EntityDecoder; },
/* harmony export */   EntityLevel: function() { return /* binding */ EntityLevel; },
/* harmony export */   decode: function() { return /* binding */ decode; },
/* harmony export */   decodeHTML: function() { return /* reexport safe */ _decode_js__WEBPACK_IMPORTED_MODULE_0__.decodeHTML; },
/* harmony export */   decodeHTML4: function() { return /* reexport safe */ _decode_js__WEBPACK_IMPORTED_MODULE_0__.decodeHTML; },
/* harmony export */   decodeHTML4Strict: function() { return /* reexport safe */ _decode_js__WEBPACK_IMPORTED_MODULE_0__.decodeHTMLStrict; },
/* harmony export */   decodeHTML5: function() { return /* reexport safe */ _decode_js__WEBPACK_IMPORTED_MODULE_0__.decodeHTML; },
/* harmony export */   decodeHTML5Strict: function() { return /* reexport safe */ _decode_js__WEBPACK_IMPORTED_MODULE_0__.decodeHTMLStrict; },
/* harmony export */   decodeHTMLAttribute: function() { return /* reexport safe */ _decode_js__WEBPACK_IMPORTED_MODULE_0__.decodeHTMLAttribute; },
/* harmony export */   decodeHTMLStrict: function() { return /* reexport safe */ _decode_js__WEBPACK_IMPORTED_MODULE_0__.decodeHTMLStrict; },
/* harmony export */   decodeStrict: function() { return /* binding */ decodeStrict; },
/* harmony export */   decodeXML: function() { return /* reexport safe */ _decode_js__WEBPACK_IMPORTED_MODULE_0__.decodeXML; },
/* harmony export */   decodeXMLStrict: function() { return /* reexport safe */ _decode_js__WEBPACK_IMPORTED_MODULE_0__.decodeXML; },
/* harmony export */   encode: function() { return /* binding */ encode; },
/* harmony export */   encodeHTML: function() { return /* reexport safe */ _encode_js__WEBPACK_IMPORTED_MODULE_1__.encodeHTML; },
/* harmony export */   encodeHTML4: function() { return /* reexport safe */ _encode_js__WEBPACK_IMPORTED_MODULE_1__.encodeHTML; },
/* harmony export */   encodeHTML5: function() { return /* reexport safe */ _encode_js__WEBPACK_IMPORTED_MODULE_1__.encodeHTML; },
/* harmony export */   encodeNonAsciiHTML: function() { return /* reexport safe */ _encode_js__WEBPACK_IMPORTED_MODULE_1__.encodeNonAsciiHTML; },
/* harmony export */   encodeXML: function() { return /* reexport safe */ _escape_js__WEBPACK_IMPORTED_MODULE_2__.encodeXML; },
/* harmony export */   escape: function() { return /* reexport safe */ _escape_js__WEBPACK_IMPORTED_MODULE_2__.escape; },
/* harmony export */   escapeAttribute: function() { return /* reexport safe */ _escape_js__WEBPACK_IMPORTED_MODULE_2__.escapeAttribute; },
/* harmony export */   escapeText: function() { return /* reexport safe */ _escape_js__WEBPACK_IMPORTED_MODULE_2__.escapeText; },
/* harmony export */   escapeUTF8: function() { return /* reexport safe */ _escape_js__WEBPACK_IMPORTED_MODULE_2__.escapeUTF8; }
/* harmony export */ });
/* harmony import */ var _decode_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(341);
/* harmony import */ var _encode_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(352);
/* harmony import */ var _escape_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(354);



/** The level of entities to support. */
var EntityLevel;
(function (EntityLevel) {
  /** Support only XML entities. */
  EntityLevel[EntityLevel["XML"] = 0] = "XML";
  /** Support HTML entities, which are a superset of XML entities. */
  EntityLevel[EntityLevel["HTML"] = 1] = "HTML";
})(EntityLevel || (EntityLevel = {}));
var EncodingMode;
(function (EncodingMode) {
  /**
   * The output is UTF-8 encoded. Only characters that need escaping within
   * XML will be escaped.
   */
  EncodingMode[EncodingMode["UTF8"] = 0] = "UTF8";
  /**
   * The output consists only of ASCII characters. Characters that need
   * escaping within HTML, and characters that aren't ASCII characters will
   * be escaped.
   */
  EncodingMode[EncodingMode["ASCII"] = 1] = "ASCII";
  /**
   * Encode all characters that have an equivalent entity, as well as all
   * characters that are not ASCII characters.
   */
  EncodingMode[EncodingMode["Extensive"] = 2] = "Extensive";
  /**
   * Encode all characters that have to be escaped in HTML attributes,
   * following {@link https://html.spec.whatwg.org/multipage/parsing.html#escapingString}.
   */
  EncodingMode[EncodingMode["Attribute"] = 3] = "Attribute";
  /**
   * Encode all characters that have to be escaped in HTML text,
   * following {@link https://html.spec.whatwg.org/multipage/parsing.html#escapingString}.
   */
  EncodingMode[EncodingMode["Text"] = 4] = "Text";
})(EncodingMode || (EncodingMode = {}));
/**
 * Decodes a string with entities.
 *
 * @param data String to decode.
 * @param options Decoding options.
 */
function decode(data, options = EntityLevel.XML) {
  const level = typeof options === "number" ? options : options.level;
  if (level === EntityLevel.HTML) {
    const mode = typeof options === "object" ? options.mode : undefined;
    return (0,_decode_js__WEBPACK_IMPORTED_MODULE_0__.decodeHTML)(data, mode);
  }
  return (0,_decode_js__WEBPACK_IMPORTED_MODULE_0__.decodeXML)(data);
}
/**
 * Decodes a string with entities. Does not allow missing trailing semicolons for entities.
 *
 * @param data String to decode.
 * @param options Decoding options.
 * @deprecated Use `decode` with the `mode` set to `Strict`.
 */
function decodeStrict(data, options = EntityLevel.XML) {
  var _a;
  const opts = typeof options === "number" ? {
    level: options
  } : options;
  (_a = opts.mode) !== null && _a !== void 0 ? _a : opts.mode = _decode_js__WEBPACK_IMPORTED_MODULE_0__.DecodingMode.Strict;
  return decode(data, opts);
}
/**
 * Encodes a string with entities.
 *
 * @param data String to encode.
 * @param options Encoding options.
 */
function encode(data, options = EntityLevel.XML) {
  const opts = typeof options === "number" ? {
    level: options
  } : options;
  // Mode `UTF8` just escapes XML entities
  if (opts.mode === EncodingMode.UTF8) return (0,_escape_js__WEBPACK_IMPORTED_MODULE_2__.escapeUTF8)(data);
  if (opts.mode === EncodingMode.Attribute) return (0,_escape_js__WEBPACK_IMPORTED_MODULE_2__.escapeAttribute)(data);
  if (opts.mode === EncodingMode.Text) return (0,_escape_js__WEBPACK_IMPORTED_MODULE_2__.escapeText)(data);
  if (opts.level === EntityLevel.HTML) {
    if (opts.mode === EncodingMode.ASCII) {
      return (0,_encode_js__WEBPACK_IMPORTED_MODULE_1__.encodeNonAsciiHTML)(data);
    }
    return (0,_encode_js__WEBPACK_IMPORTED_MODULE_1__.encodeHTML)(data);
  }
  // ASCII and Extensive are equivalent
  return (0,_escape_js__WEBPACK_IMPORTED_MODULE_2__.encodeXML)(data);
}




/***/ }),
/* 352 */
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   encodeHTML: function() { return /* binding */ encodeHTML; },
/* harmony export */   encodeNonAsciiHTML: function() { return /* binding */ encodeNonAsciiHTML; }
/* harmony export */ });
/* harmony import */ var _generated_encode_html_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(353);
/* harmony import */ var _escape_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(354);


const htmlReplacer = /[\t\n!-,./:-@[-`\f{-}$\x80-\uFFFF]/g;
/**
 * Encodes all characters in the input using HTML entities. This includes
 * characters that are valid ASCII characters in HTML documents, such as `#`.
 *
 * To get a more compact output, consider using the `encodeNonAsciiHTML`
 * function, which will only encode characters that are not valid in HTML
 * documents, as well as non-ASCII characters.
 *
 * If a character has no equivalent entity, a numeric hexadecimal reference
 * (eg. `&#xfc;`) will be used.
 */
function encodeHTML(data) {
  return encodeHTMLTrieRe(htmlReplacer, data);
}
/**
 * Encodes all non-ASCII characters, as well as characters not valid in HTML
 * documents using HTML entities. This function will not encode characters that
 * are valid in HTML documents, such as `#`.
 *
 * If a character has no equivalent entity, a numeric hexadecimal reference
 * (eg. `&#xfc;`) will be used.
 */
function encodeNonAsciiHTML(data) {
  return encodeHTMLTrieRe(_escape_js__WEBPACK_IMPORTED_MODULE_1__.xmlReplacer, data);
}
function encodeHTMLTrieRe(regExp, str) {
  let ret = "";
  let lastIdx = 0;
  let match;
  while ((match = regExp.exec(str)) !== null) {
    const i = match.index;
    ret += str.substring(lastIdx, i);
    const char = str.charCodeAt(i);
    let next = _generated_encode_html_js__WEBPACK_IMPORTED_MODULE_0__["default"].get(char);
    if (typeof next === "object") {
      // We are in a branch. Try to match the next char.
      if (i + 1 < str.length) {
        const nextChar = str.charCodeAt(i + 1);
        const value = typeof next.n === "number" ? next.n === nextChar ? next.o : undefined : next.n.get(nextChar);
        if (value !== undefined) {
          ret += value;
          lastIdx = regExp.lastIndex += 1;
          continue;
        }
      }
      next = next.v;
    }
    // We might have a tree node without a value; skip and use a numeric entity.
    if (next !== undefined) {
      ret += next;
      lastIdx = i + 1;
    } else {
      const cp = (0,_escape_js__WEBPACK_IMPORTED_MODULE_1__.getCodePoint)(str, i);
      ret += `&#x${cp.toString(16)};`;
      // Increase by 1 if we have a surrogate pair
      lastIdx = regExp.lastIndex += Number(cp !== char);
    }
  }
  return ret + str.substr(lastIdx);
}

/***/ }),
/* 353 */
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
// Generated using scripts/write-encode-map.ts
function restoreDiff(arr) {
  for (let i = 1; i < arr.length; i++) {
    arr[i][0] += arr[i - 1][0] + 1;
  }
  return arr;
}
// prettier-ignore
/* harmony default export */ __webpack_exports__["default"] = (new Map(/* #__PURE__ */restoreDiff([[9, "&Tab;"], [0, "&NewLine;"], [22, "&excl;"], [0, "&quot;"], [0, "&num;"], [0, "&dollar;"], [0, "&percnt;"], [0, "&amp;"], [0, "&apos;"], [0, "&lpar;"], [0, "&rpar;"], [0, "&ast;"], [0, "&plus;"], [0, "&comma;"], [1, "&period;"], [0, "&sol;"], [10, "&colon;"], [0, "&semi;"], [0, {
  v: "&lt;",
  n: 8402,
  o: "&nvlt;"
}], [0, {
  v: "&equals;",
  n: 8421,
  o: "&bne;"
}], [0, {
  v: "&gt;",
  n: 8402,
  o: "&nvgt;"
}], [0, "&quest;"], [0, "&commat;"], [26, "&lbrack;"], [0, "&bsol;"], [0, "&rbrack;"], [0, "&Hat;"], [0, "&lowbar;"], [0, "&DiacriticalGrave;"], [5, {
  n: 106,
  o: "&fjlig;"
}], [20, "&lbrace;"], [0, "&verbar;"], [0, "&rbrace;"], [34, "&nbsp;"], [0, "&iexcl;"], [0, "&cent;"], [0, "&pound;"], [0, "&curren;"], [0, "&yen;"], [0, "&brvbar;"], [0, "&sect;"], [0, "&die;"], [0, "&copy;"], [0, "&ordf;"], [0, "&laquo;"], [0, "&not;"], [0, "&shy;"], [0, "&circledR;"], [0, "&macr;"], [0, "&deg;"], [0, "&PlusMinus;"], [0, "&sup2;"], [0, "&sup3;"], [0, "&acute;"], [0, "&micro;"], [0, "&para;"], [0, "&centerdot;"], [0, "&cedil;"], [0, "&sup1;"], [0, "&ordm;"], [0, "&raquo;"], [0, "&frac14;"], [0, "&frac12;"], [0, "&frac34;"], [0, "&iquest;"], [0, "&Agrave;"], [0, "&Aacute;"], [0, "&Acirc;"], [0, "&Atilde;"], [0, "&Auml;"], [0, "&angst;"], [0, "&AElig;"], [0, "&Ccedil;"], [0, "&Egrave;"], [0, "&Eacute;"], [0, "&Ecirc;"], [0, "&Euml;"], [0, "&Igrave;"], [0, "&Iacute;"], [0, "&Icirc;"], [0, "&Iuml;"], [0, "&ETH;"], [0, "&Ntilde;"], [0, "&Ograve;"], [0, "&Oacute;"], [0, "&Ocirc;"], [0, "&Otilde;"], [0, "&Ouml;"], [0, "&times;"], [0, "&Oslash;"], [0, "&Ugrave;"], [0, "&Uacute;"], [0, "&Ucirc;"], [0, "&Uuml;"], [0, "&Yacute;"], [0, "&THORN;"], [0, "&szlig;"], [0, "&agrave;"], [0, "&aacute;"], [0, "&acirc;"], [0, "&atilde;"], [0, "&auml;"], [0, "&aring;"], [0, "&aelig;"], [0, "&ccedil;"], [0, "&egrave;"], [0, "&eacute;"], [0, "&ecirc;"], [0, "&euml;"], [0, "&igrave;"], [0, "&iacute;"], [0, "&icirc;"], [0, "&iuml;"], [0, "&eth;"], [0, "&ntilde;"], [0, "&ograve;"], [0, "&oacute;"], [0, "&ocirc;"], [0, "&otilde;"], [0, "&ouml;"], [0, "&div;"], [0, "&oslash;"], [0, "&ugrave;"], [0, "&uacute;"], [0, "&ucirc;"], [0, "&uuml;"], [0, "&yacute;"], [0, "&thorn;"], [0, "&yuml;"], [0, "&Amacr;"], [0, "&amacr;"], [0, "&Abreve;"], [0, "&abreve;"], [0, "&Aogon;"], [0, "&aogon;"], [0, "&Cacute;"], [0, "&cacute;"], [0, "&Ccirc;"], [0, "&ccirc;"], [0, "&Cdot;"], [0, "&cdot;"], [0, "&Ccaron;"], [0, "&ccaron;"], [0, "&Dcaron;"], [0, "&dcaron;"], [0, "&Dstrok;"], [0, "&dstrok;"], [0, "&Emacr;"], [0, "&emacr;"], [2, "&Edot;"], [0, "&edot;"], [0, "&Eogon;"], [0, "&eogon;"], [0, "&Ecaron;"], [0, "&ecaron;"], [0, "&Gcirc;"], [0, "&gcirc;"], [0, "&Gbreve;"], [0, "&gbreve;"], [0, "&Gdot;"], [0, "&gdot;"], [0, "&Gcedil;"], [1, "&Hcirc;"], [0, "&hcirc;"], [0, "&Hstrok;"], [0, "&hstrok;"], [0, "&Itilde;"], [0, "&itilde;"], [0, "&Imacr;"], [0, "&imacr;"], [2, "&Iogon;"], [0, "&iogon;"], [0, "&Idot;"], [0, "&imath;"], [0, "&IJlig;"], [0, "&ijlig;"], [0, "&Jcirc;"], [0, "&jcirc;"], [0, "&Kcedil;"], [0, "&kcedil;"], [0, "&kgreen;"], [0, "&Lacute;"], [0, "&lacute;"], [0, "&Lcedil;"], [0, "&lcedil;"], [0, "&Lcaron;"], [0, "&lcaron;"], [0, "&Lmidot;"], [0, "&lmidot;"], [0, "&Lstrok;"], [0, "&lstrok;"], [0, "&Nacute;"], [0, "&nacute;"], [0, "&Ncedil;"], [0, "&ncedil;"], [0, "&Ncaron;"], [0, "&ncaron;"], [0, "&napos;"], [0, "&ENG;"], [0, "&eng;"], [0, "&Omacr;"], [0, "&omacr;"], [2, "&Odblac;"], [0, "&odblac;"], [0, "&OElig;"], [0, "&oelig;"], [0, "&Racute;"], [0, "&racute;"], [0, "&Rcedil;"], [0, "&rcedil;"], [0, "&Rcaron;"], [0, "&rcaron;"], [0, "&Sacute;"], [0, "&sacute;"], [0, "&Scirc;"], [0, "&scirc;"], [0, "&Scedil;"], [0, "&scedil;"], [0, "&Scaron;"], [0, "&scaron;"], [0, "&Tcedil;"], [0, "&tcedil;"], [0, "&Tcaron;"], [0, "&tcaron;"], [0, "&Tstrok;"], [0, "&tstrok;"], [0, "&Utilde;"], [0, "&utilde;"], [0, "&Umacr;"], [0, "&umacr;"], [0, "&Ubreve;"], [0, "&ubreve;"], [0, "&Uring;"], [0, "&uring;"], [0, "&Udblac;"], [0, "&udblac;"], [0, "&Uogon;"], [0, "&uogon;"], [0, "&Wcirc;"], [0, "&wcirc;"], [0, "&Ycirc;"], [0, "&ycirc;"], [0, "&Yuml;"], [0, "&Zacute;"], [0, "&zacute;"], [0, "&Zdot;"], [0, "&zdot;"], [0, "&Zcaron;"], [0, "&zcaron;"], [19, "&fnof;"], [34, "&imped;"], [63, "&gacute;"], [65, "&jmath;"], [142, "&circ;"], [0, "&caron;"], [16, "&breve;"], [0, "&DiacriticalDot;"], [0, "&ring;"], [0, "&ogon;"], [0, "&DiacriticalTilde;"], [0, "&dblac;"], [51, "&DownBreve;"], [127, "&Alpha;"], [0, "&Beta;"], [0, "&Gamma;"], [0, "&Delta;"], [0, "&Epsilon;"], [0, "&Zeta;"], [0, "&Eta;"], [0, "&Theta;"], [0, "&Iota;"], [0, "&Kappa;"], [0, "&Lambda;"], [0, "&Mu;"], [0, "&Nu;"], [0, "&Xi;"], [0, "&Omicron;"], [0, "&Pi;"], [0, "&Rho;"], [1, "&Sigma;"], [0, "&Tau;"], [0, "&Upsilon;"], [0, "&Phi;"], [0, "&Chi;"], [0, "&Psi;"], [0, "&ohm;"], [7, "&alpha;"], [0, "&beta;"], [0, "&gamma;"], [0, "&delta;"], [0, "&epsi;"], [0, "&zeta;"], [0, "&eta;"], [0, "&theta;"], [0, "&iota;"], [0, "&kappa;"], [0, "&lambda;"], [0, "&mu;"], [0, "&nu;"], [0, "&xi;"], [0, "&omicron;"], [0, "&pi;"], [0, "&rho;"], [0, "&sigmaf;"], [0, "&sigma;"], [0, "&tau;"], [0, "&upsi;"], [0, "&phi;"], [0, "&chi;"], [0, "&psi;"], [0, "&omega;"], [7, "&thetasym;"], [0, "&Upsi;"], [2, "&phiv;"], [0, "&piv;"], [5, "&Gammad;"], [0, "&digamma;"], [18, "&kappav;"], [0, "&rhov;"], [3, "&epsiv;"], [0, "&backepsilon;"], [10, "&IOcy;"], [0, "&DJcy;"], [0, "&GJcy;"], [0, "&Jukcy;"], [0, "&DScy;"], [0, "&Iukcy;"], [0, "&YIcy;"], [0, "&Jsercy;"], [0, "&LJcy;"], [0, "&NJcy;"], [0, "&TSHcy;"], [0, "&KJcy;"], [1, "&Ubrcy;"], [0, "&DZcy;"], [0, "&Acy;"], [0, "&Bcy;"], [0, "&Vcy;"], [0, "&Gcy;"], [0, "&Dcy;"], [0, "&IEcy;"], [0, "&ZHcy;"], [0, "&Zcy;"], [0, "&Icy;"], [0, "&Jcy;"], [0, "&Kcy;"], [0, "&Lcy;"], [0, "&Mcy;"], [0, "&Ncy;"], [0, "&Ocy;"], [0, "&Pcy;"], [0, "&Rcy;"], [0, "&Scy;"], [0, "&Tcy;"], [0, "&Ucy;"], [0, "&Fcy;"], [0, "&KHcy;"], [0, "&TScy;"], [0, "&CHcy;"], [0, "&SHcy;"], [0, "&SHCHcy;"], [0, "&HARDcy;"], [0, "&Ycy;"], [0, "&SOFTcy;"], [0, "&Ecy;"], [0, "&YUcy;"], [0, "&YAcy;"], [0, "&acy;"], [0, "&bcy;"], [0, "&vcy;"], [0, "&gcy;"], [0, "&dcy;"], [0, "&iecy;"], [0, "&zhcy;"], [0, "&zcy;"], [0, "&icy;"], [0, "&jcy;"], [0, "&kcy;"], [0, "&lcy;"], [0, "&mcy;"], [0, "&ncy;"], [0, "&ocy;"], [0, "&pcy;"], [0, "&rcy;"], [0, "&scy;"], [0, "&tcy;"], [0, "&ucy;"], [0, "&fcy;"], [0, "&khcy;"], [0, "&tscy;"], [0, "&chcy;"], [0, "&shcy;"], [0, "&shchcy;"], [0, "&hardcy;"], [0, "&ycy;"], [0, "&softcy;"], [0, "&ecy;"], [0, "&yucy;"], [0, "&yacy;"], [1, "&iocy;"], [0, "&djcy;"], [0, "&gjcy;"], [0, "&jukcy;"], [0, "&dscy;"], [0, "&iukcy;"], [0, "&yicy;"], [0, "&jsercy;"], [0, "&ljcy;"], [0, "&njcy;"], [0, "&tshcy;"], [0, "&kjcy;"], [1, "&ubrcy;"], [0, "&dzcy;"], [7074, "&ensp;"], [0, "&emsp;"], [0, "&emsp13;"], [0, "&emsp14;"], [1, "&numsp;"], [0, "&puncsp;"], [0, "&ThinSpace;"], [0, "&hairsp;"], [0, "&NegativeMediumSpace;"], [0, "&zwnj;"], [0, "&zwj;"], [0, "&lrm;"], [0, "&rlm;"], [0, "&dash;"], [2, "&ndash;"], [0, "&mdash;"], [0, "&horbar;"], [0, "&Verbar;"], [1, "&lsquo;"], [0, "&CloseCurlyQuote;"], [0, "&lsquor;"], [1, "&ldquo;"], [0, "&CloseCurlyDoubleQuote;"], [0, "&bdquo;"], [1, "&dagger;"], [0, "&Dagger;"], [0, "&bull;"], [2, "&nldr;"], [0, "&hellip;"], [9, "&permil;"], [0, "&pertenk;"], [0, "&prime;"], [0, "&Prime;"], [0, "&tprime;"], [0, "&backprime;"], [3, "&lsaquo;"], [0, "&rsaquo;"], [3, "&oline;"], [2, "&caret;"], [1, "&hybull;"], [0, "&frasl;"], [10, "&bsemi;"], [7, "&qprime;"], [7, {
  v: "&MediumSpace;",
  n: 8202,
  o: "&ThickSpace;"
}], [0, "&NoBreak;"], [0, "&af;"], [0, "&InvisibleTimes;"], [0, "&ic;"], [72, "&euro;"], [46, "&tdot;"], [0, "&DotDot;"], [37, "&complexes;"], [2, "&incare;"], [4, "&gscr;"], [0, "&hamilt;"], [0, "&Hfr;"], [0, "&Hopf;"], [0, "&planckh;"], [0, "&hbar;"], [0, "&imagline;"], [0, "&Ifr;"], [0, "&lagran;"], [0, "&ell;"], [1, "&naturals;"], [0, "&numero;"], [0, "&copysr;"], [0, "&weierp;"], [0, "&Popf;"], [0, "&Qopf;"], [0, "&realine;"], [0, "&real;"], [0, "&reals;"], [0, "&rx;"], [3, "&trade;"], [1, "&integers;"], [2, "&mho;"], [0, "&zeetrf;"], [0, "&iiota;"], [2, "&bernou;"], [0, "&Cayleys;"], [1, "&escr;"], [0, "&Escr;"], [0, "&Fouriertrf;"], [1, "&Mellintrf;"], [0, "&order;"], [0, "&alefsym;"], [0, "&beth;"], [0, "&gimel;"], [0, "&daleth;"], [12, "&CapitalDifferentialD;"], [0, "&dd;"], [0, "&ee;"], [0, "&ii;"], [10, "&frac13;"], [0, "&frac23;"], [0, "&frac15;"], [0, "&frac25;"], [0, "&frac35;"], [0, "&frac45;"], [0, "&frac16;"], [0, "&frac56;"], [0, "&frac18;"], [0, "&frac38;"], [0, "&frac58;"], [0, "&frac78;"], [49, "&larr;"], [0, "&ShortUpArrow;"], [0, "&rarr;"], [0, "&darr;"], [0, "&harr;"], [0, "&updownarrow;"], [0, "&nwarr;"], [0, "&nearr;"], [0, "&LowerRightArrow;"], [0, "&LowerLeftArrow;"], [0, "&nlarr;"], [0, "&nrarr;"], [1, {
  v: "&rarrw;",
  n: 824,
  o: "&nrarrw;"
}], [0, "&Larr;"], [0, "&Uarr;"], [0, "&Rarr;"], [0, "&Darr;"], [0, "&larrtl;"], [0, "&rarrtl;"], [0, "&LeftTeeArrow;"], [0, "&mapstoup;"], [0, "&map;"], [0, "&DownTeeArrow;"], [1, "&hookleftarrow;"], [0, "&hookrightarrow;"], [0, "&larrlp;"], [0, "&looparrowright;"], [0, "&harrw;"], [0, "&nharr;"], [1, "&lsh;"], [0, "&rsh;"], [0, "&ldsh;"], [0, "&rdsh;"], [1, "&crarr;"], [0, "&cularr;"], [0, "&curarr;"], [2, "&circlearrowleft;"], [0, "&circlearrowright;"], [0, "&leftharpoonup;"], [0, "&DownLeftVector;"], [0, "&RightUpVector;"], [0, "&LeftUpVector;"], [0, "&rharu;"], [0, "&DownRightVector;"], [0, "&dharr;"], [0, "&dharl;"], [0, "&RightArrowLeftArrow;"], [0, "&udarr;"], [0, "&LeftArrowRightArrow;"], [0, "&leftleftarrows;"], [0, "&upuparrows;"], [0, "&rightrightarrows;"], [0, "&ddarr;"], [0, "&leftrightharpoons;"], [0, "&Equilibrium;"], [0, "&nlArr;"], [0, "&nhArr;"], [0, "&nrArr;"], [0, "&DoubleLeftArrow;"], [0, "&DoubleUpArrow;"], [0, "&DoubleRightArrow;"], [0, "&dArr;"], [0, "&DoubleLeftRightArrow;"], [0, "&DoubleUpDownArrow;"], [0, "&nwArr;"], [0, "&neArr;"], [0, "&seArr;"], [0, "&swArr;"], [0, "&lAarr;"], [0, "&rAarr;"], [1, "&zigrarr;"], [6, "&larrb;"], [0, "&rarrb;"], [15, "&DownArrowUpArrow;"], [7, "&loarr;"], [0, "&roarr;"], [0, "&hoarr;"], [0, "&forall;"], [0, "&comp;"], [0, {
  v: "&part;",
  n: 824,
  o: "&npart;"
}], [0, "&exist;"], [0, "&nexist;"], [0, "&empty;"], [1, "&Del;"], [0, "&Element;"], [0, "&NotElement;"], [1, "&ni;"], [0, "&notni;"], [2, "&prod;"], [0, "&coprod;"], [0, "&sum;"], [0, "&minus;"], [0, "&MinusPlus;"], [0, "&dotplus;"], [1, "&Backslash;"], [0, "&lowast;"], [0, "&compfn;"], [1, "&radic;"], [2, "&prop;"], [0, "&infin;"], [0, "&angrt;"], [0, {
  v: "&ang;",
  n: 8402,
  o: "&nang;"
}], [0, "&angmsd;"], [0, "&angsph;"], [0, "&mid;"], [0, "&nmid;"], [0, "&DoubleVerticalBar;"], [0, "&NotDoubleVerticalBar;"], [0, "&and;"], [0, "&or;"], [0, {
  v: "&cap;",
  n: 65024,
  o: "&caps;"
}], [0, {
  v: "&cup;",
  n: 65024,
  o: "&cups;"
}], [0, "&int;"], [0, "&Int;"], [0, "&iiint;"], [0, "&conint;"], [0, "&Conint;"], [0, "&Cconint;"], [0, "&cwint;"], [0, "&ClockwiseContourIntegral;"], [0, "&awconint;"], [0, "&there4;"], [0, "&becaus;"], [0, "&ratio;"], [0, "&Colon;"], [0, "&dotminus;"], [1, "&mDDot;"], [0, "&homtht;"], [0, {
  v: "&sim;",
  n: 8402,
  o: "&nvsim;"
}], [0, {
  v: "&backsim;",
  n: 817,
  o: "&race;"
}], [0, {
  v: "&ac;",
  n: 819,
  o: "&acE;"
}], [0, "&acd;"], [0, "&VerticalTilde;"], [0, "&NotTilde;"], [0, {
  v: "&eqsim;",
  n: 824,
  o: "&nesim;"
}], [0, "&sime;"], [0, "&NotTildeEqual;"], [0, "&cong;"], [0, "&simne;"], [0, "&ncong;"], [0, "&ap;"], [0, "&nap;"], [0, "&ape;"], [0, {
  v: "&apid;",
  n: 824,
  o: "&napid;"
}], [0, "&backcong;"], [0, {
  v: "&asympeq;",
  n: 8402,
  o: "&nvap;"
}], [0, {
  v: "&bump;",
  n: 824,
  o: "&nbump;"
}], [0, {
  v: "&bumpe;",
  n: 824,
  o: "&nbumpe;"
}], [0, {
  v: "&doteq;",
  n: 824,
  o: "&nedot;"
}], [0, "&doteqdot;"], [0, "&efDot;"], [0, "&erDot;"], [0, "&Assign;"], [0, "&ecolon;"], [0, "&ecir;"], [0, "&circeq;"], [1, "&wedgeq;"], [0, "&veeeq;"], [1, "&triangleq;"], [2, "&equest;"], [0, "&ne;"], [0, {
  v: "&Congruent;",
  n: 8421,
  o: "&bnequiv;"
}], [0, "&nequiv;"], [1, {
  v: "&le;",
  n: 8402,
  o: "&nvle;"
}], [0, {
  v: "&ge;",
  n: 8402,
  o: "&nvge;"
}], [0, {
  v: "&lE;",
  n: 824,
  o: "&nlE;"
}], [0, {
  v: "&gE;",
  n: 824,
  o: "&ngE;"
}], [0, {
  v: "&lnE;",
  n: 65024,
  o: "&lvertneqq;"
}], [0, {
  v: "&gnE;",
  n: 65024,
  o: "&gvertneqq;"
}], [0, {
  v: "&ll;",
  n: new Map(/* #__PURE__ */restoreDiff([[824, "&nLtv;"], [7577, "&nLt;"]]))
}], [0, {
  v: "&gg;",
  n: new Map(/* #__PURE__ */restoreDiff([[824, "&nGtv;"], [7577, "&nGt;"]]))
}], [0, "&between;"], [0, "&NotCupCap;"], [0, "&nless;"], [0, "&ngt;"], [0, "&nle;"], [0, "&nge;"], [0, "&lesssim;"], [0, "&GreaterTilde;"], [0, "&nlsim;"], [0, "&ngsim;"], [0, "&LessGreater;"], [0, "&gl;"], [0, "&NotLessGreater;"], [0, "&NotGreaterLess;"], [0, "&pr;"], [0, "&sc;"], [0, "&prcue;"], [0, "&sccue;"], [0, "&PrecedesTilde;"], [0, {
  v: "&scsim;",
  n: 824,
  o: "&NotSucceedsTilde;"
}], [0, "&NotPrecedes;"], [0, "&NotSucceeds;"], [0, {
  v: "&sub;",
  n: 8402,
  o: "&NotSubset;"
}], [0, {
  v: "&sup;",
  n: 8402,
  o: "&NotSuperset;"
}], [0, "&nsub;"], [0, "&nsup;"], [0, "&sube;"], [0, "&supe;"], [0, "&NotSubsetEqual;"], [0, "&NotSupersetEqual;"], [0, {
  v: "&subne;",
  n: 65024,
  o: "&varsubsetneq;"
}], [0, {
  v: "&supne;",
  n: 65024,
  o: "&varsupsetneq;"
}], [1, "&cupdot;"], [0, "&UnionPlus;"], [0, {
  v: "&sqsub;",
  n: 824,
  o: "&NotSquareSubset;"
}], [0, {
  v: "&sqsup;",
  n: 824,
  o: "&NotSquareSuperset;"
}], [0, "&sqsube;"], [0, "&sqsupe;"], [0, {
  v: "&sqcap;",
  n: 65024,
  o: "&sqcaps;"
}], [0, {
  v: "&sqcup;",
  n: 65024,
  o: "&sqcups;"
}], [0, "&CirclePlus;"], [0, "&CircleMinus;"], [0, "&CircleTimes;"], [0, "&osol;"], [0, "&CircleDot;"], [0, "&circledcirc;"], [0, "&circledast;"], [1, "&circleddash;"], [0, "&boxplus;"], [0, "&boxminus;"], [0, "&boxtimes;"], [0, "&dotsquare;"], [0, "&RightTee;"], [0, "&dashv;"], [0, "&DownTee;"], [0, "&bot;"], [1, "&models;"], [0, "&DoubleRightTee;"], [0, "&Vdash;"], [0, "&Vvdash;"], [0, "&VDash;"], [0, "&nvdash;"], [0, "&nvDash;"], [0, "&nVdash;"], [0, "&nVDash;"], [0, "&prurel;"], [1, "&LeftTriangle;"], [0, "&RightTriangle;"], [0, {
  v: "&LeftTriangleEqual;",
  n: 8402,
  o: "&nvltrie;"
}], [0, {
  v: "&RightTriangleEqual;",
  n: 8402,
  o: "&nvrtrie;"
}], [0, "&origof;"], [0, "&imof;"], [0, "&multimap;"], [0, "&hercon;"], [0, "&intcal;"], [0, "&veebar;"], [1, "&barvee;"], [0, "&angrtvb;"], [0, "&lrtri;"], [0, "&bigwedge;"], [0, "&bigvee;"], [0, "&bigcap;"], [0, "&bigcup;"], [0, "&diam;"], [0, "&sdot;"], [0, "&sstarf;"], [0, "&divideontimes;"], [0, "&bowtie;"], [0, "&ltimes;"], [0, "&rtimes;"], [0, "&leftthreetimes;"], [0, "&rightthreetimes;"], [0, "&backsimeq;"], [0, "&curlyvee;"], [0, "&curlywedge;"], [0, "&Sub;"], [0, "&Sup;"], [0, "&Cap;"], [0, "&Cup;"], [0, "&fork;"], [0, "&epar;"], [0, "&lessdot;"], [0, "&gtdot;"], [0, {
  v: "&Ll;",
  n: 824,
  o: "&nLl;"
}], [0, {
  v: "&Gg;",
  n: 824,
  o: "&nGg;"
}], [0, {
  v: "&leg;",
  n: 65024,
  o: "&lesg;"
}], [0, {
  v: "&gel;",
  n: 65024,
  o: "&gesl;"
}], [2, "&cuepr;"], [0, "&cuesc;"], [0, "&NotPrecedesSlantEqual;"], [0, "&NotSucceedsSlantEqual;"], [0, "&NotSquareSubsetEqual;"], [0, "&NotSquareSupersetEqual;"], [2, "&lnsim;"], [0, "&gnsim;"], [0, "&precnsim;"], [0, "&scnsim;"], [0, "&nltri;"], [0, "&NotRightTriangle;"], [0, "&nltrie;"], [0, "&NotRightTriangleEqual;"], [0, "&vellip;"], [0, "&ctdot;"], [0, "&utdot;"], [0, "&dtdot;"], [0, "&disin;"], [0, "&isinsv;"], [0, "&isins;"], [0, {
  v: "&isindot;",
  n: 824,
  o: "&notindot;"
}], [0, "&notinvc;"], [0, "&notinvb;"], [1, {
  v: "&isinE;",
  n: 824,
  o: "&notinE;"
}], [0, "&nisd;"], [0, "&xnis;"], [0, "&nis;"], [0, "&notnivc;"], [0, "&notnivb;"], [6, "&barwed;"], [0, "&Barwed;"], [1, "&lceil;"], [0, "&rceil;"], [0, "&LeftFloor;"], [0, "&rfloor;"], [0, "&drcrop;"], [0, "&dlcrop;"], [0, "&urcrop;"], [0, "&ulcrop;"], [0, "&bnot;"], [1, "&profline;"], [0, "&profsurf;"], [1, "&telrec;"], [0, "&target;"], [5, "&ulcorn;"], [0, "&urcorn;"], [0, "&dlcorn;"], [0, "&drcorn;"], [2, "&frown;"], [0, "&smile;"], [9, "&cylcty;"], [0, "&profalar;"], [7, "&topbot;"], [6, "&ovbar;"], [1, "&solbar;"], [60, "&angzarr;"], [51, "&lmoustache;"], [0, "&rmoustache;"], [2, "&OverBracket;"], [0, "&bbrk;"], [0, "&bbrktbrk;"], [37, "&OverParenthesis;"], [0, "&UnderParenthesis;"], [0, "&OverBrace;"], [0, "&UnderBrace;"], [2, "&trpezium;"], [4, "&elinters;"], [59, "&blank;"], [164, "&circledS;"], [55, "&boxh;"], [1, "&boxv;"], [9, "&boxdr;"], [3, "&boxdl;"], [3, "&boxur;"], [3, "&boxul;"], [3, "&boxvr;"], [7, "&boxvl;"], [7, "&boxhd;"], [7, "&boxhu;"], [7, "&boxvh;"], [19, "&boxH;"], [0, "&boxV;"], [0, "&boxdR;"], [0, "&boxDr;"], [0, "&boxDR;"], [0, "&boxdL;"], [0, "&boxDl;"], [0, "&boxDL;"], [0, "&boxuR;"], [0, "&boxUr;"], [0, "&boxUR;"], [0, "&boxuL;"], [0, "&boxUl;"], [0, "&boxUL;"], [0, "&boxvR;"], [0, "&boxVr;"], [0, "&boxVR;"], [0, "&boxvL;"], [0, "&boxVl;"], [0, "&boxVL;"], [0, "&boxHd;"], [0, "&boxhD;"], [0, "&boxHD;"], [0, "&boxHu;"], [0, "&boxhU;"], [0, "&boxHU;"], [0, "&boxvH;"], [0, "&boxVh;"], [0, "&boxVH;"], [19, "&uhblk;"], [3, "&lhblk;"], [3, "&block;"], [8, "&blk14;"], [0, "&blk12;"], [0, "&blk34;"], [13, "&square;"], [8, "&blacksquare;"], [0, "&EmptyVerySmallSquare;"], [1, "&rect;"], [0, "&marker;"], [2, "&fltns;"], [1, "&bigtriangleup;"], [0, "&blacktriangle;"], [0, "&triangle;"], [2, "&blacktriangleright;"], [0, "&rtri;"], [3, "&bigtriangledown;"], [0, "&blacktriangledown;"], [0, "&dtri;"], [2, "&blacktriangleleft;"], [0, "&ltri;"], [6, "&loz;"], [0, "&cir;"], [32, "&tridot;"], [2, "&bigcirc;"], [8, "&ultri;"], [0, "&urtri;"], [0, "&lltri;"], [0, "&EmptySmallSquare;"], [0, "&FilledSmallSquare;"], [8, "&bigstar;"], [0, "&star;"], [7, "&phone;"], [49, "&female;"], [1, "&male;"], [29, "&spades;"], [2, "&clubs;"], [1, "&hearts;"], [0, "&diamondsuit;"], [3, "&sung;"], [2, "&flat;"], [0, "&natural;"], [0, "&sharp;"], [163, "&check;"], [3, "&cross;"], [8, "&malt;"], [21, "&sext;"], [33, "&VerticalSeparator;"], [25, "&lbbrk;"], [0, "&rbbrk;"], [84, "&bsolhsub;"], [0, "&suphsol;"], [28, "&LeftDoubleBracket;"], [0, "&RightDoubleBracket;"], [0, "&lang;"], [0, "&rang;"], [0, "&Lang;"], [0, "&Rang;"], [0, "&loang;"], [0, "&roang;"], [7, "&longleftarrow;"], [0, "&longrightarrow;"], [0, "&longleftrightarrow;"], [0, "&DoubleLongLeftArrow;"], [0, "&DoubleLongRightArrow;"], [0, "&DoubleLongLeftRightArrow;"], [1, "&longmapsto;"], [2, "&dzigrarr;"], [258, "&nvlArr;"], [0, "&nvrArr;"], [0, "&nvHarr;"], [0, "&Map;"], [6, "&lbarr;"], [0, "&bkarow;"], [0, "&lBarr;"], [0, "&dbkarow;"], [0, "&drbkarow;"], [0, "&DDotrahd;"], [0, "&UpArrowBar;"], [0, "&DownArrowBar;"], [2, "&Rarrtl;"], [2, "&latail;"], [0, "&ratail;"], [0, "&lAtail;"], [0, "&rAtail;"], [0, "&larrfs;"], [0, "&rarrfs;"], [0, "&larrbfs;"], [0, "&rarrbfs;"], [2, "&nwarhk;"], [0, "&nearhk;"], [0, "&hksearow;"], [0, "&hkswarow;"], [0, "&nwnear;"], [0, "&nesear;"], [0, "&seswar;"], [0, "&swnwar;"], [8, {
  v: "&rarrc;",
  n: 824,
  o: "&nrarrc;"
}], [1, "&cudarrr;"], [0, "&ldca;"], [0, "&rdca;"], [0, "&cudarrl;"], [0, "&larrpl;"], [2, "&curarrm;"], [0, "&cularrp;"], [7, "&rarrpl;"], [2, "&harrcir;"], [0, "&Uarrocir;"], [0, "&lurdshar;"], [0, "&ldrushar;"], [2, "&LeftRightVector;"], [0, "&RightUpDownVector;"], [0, "&DownLeftRightVector;"], [0, "&LeftUpDownVector;"], [0, "&LeftVectorBar;"], [0, "&RightVectorBar;"], [0, "&RightUpVectorBar;"], [0, "&RightDownVectorBar;"], [0, "&DownLeftVectorBar;"], [0, "&DownRightVectorBar;"], [0, "&LeftUpVectorBar;"], [0, "&LeftDownVectorBar;"], [0, "&LeftTeeVector;"], [0, "&RightTeeVector;"], [0, "&RightUpTeeVector;"], [0, "&RightDownTeeVector;"], [0, "&DownLeftTeeVector;"], [0, "&DownRightTeeVector;"], [0, "&LeftUpTeeVector;"], [0, "&LeftDownTeeVector;"], [0, "&lHar;"], [0, "&uHar;"], [0, "&rHar;"], [0, "&dHar;"], [0, "&luruhar;"], [0, "&ldrdhar;"], [0, "&ruluhar;"], [0, "&rdldhar;"], [0, "&lharul;"], [0, "&llhard;"], [0, "&rharul;"], [0, "&lrhard;"], [0, "&udhar;"], [0, "&duhar;"], [0, "&RoundImplies;"], [0, "&erarr;"], [0, "&simrarr;"], [0, "&larrsim;"], [0, "&rarrsim;"], [0, "&rarrap;"], [0, "&ltlarr;"], [1, "&gtrarr;"], [0, "&subrarr;"], [1, "&suplarr;"], [0, "&lfisht;"], [0, "&rfisht;"], [0, "&ufisht;"], [0, "&dfisht;"], [5, "&lopar;"], [0, "&ropar;"], [4, "&lbrke;"], [0, "&rbrke;"], [0, "&lbrkslu;"], [0, "&rbrksld;"], [0, "&lbrksld;"], [0, "&rbrkslu;"], [0, "&langd;"], [0, "&rangd;"], [0, "&lparlt;"], [0, "&rpargt;"], [0, "&gtlPar;"], [0, "&ltrPar;"], [3, "&vzigzag;"], [1, "&vangrt;"], [0, "&angrtvbd;"], [6, "&ange;"], [0, "&range;"], [0, "&dwangle;"], [0, "&uwangle;"], [0, "&angmsdaa;"], [0, "&angmsdab;"], [0, "&angmsdac;"], [0, "&angmsdad;"], [0, "&angmsdae;"], [0, "&angmsdaf;"], [0, "&angmsdag;"], [0, "&angmsdah;"], [0, "&bemptyv;"], [0, "&demptyv;"], [0, "&cemptyv;"], [0, "&raemptyv;"], [0, "&laemptyv;"], [0, "&ohbar;"], [0, "&omid;"], [0, "&opar;"], [1, "&operp;"], [1, "&olcross;"], [0, "&odsold;"], [1, "&olcir;"], [0, "&ofcir;"], [0, "&olt;"], [0, "&ogt;"], [0, "&cirscir;"], [0, "&cirE;"], [0, "&solb;"], [0, "&bsolb;"], [3, "&boxbox;"], [3, "&trisb;"], [0, "&rtriltri;"], [0, {
  v: "&LeftTriangleBar;",
  n: 824,
  o: "&NotLeftTriangleBar;"
}], [0, {
  v: "&RightTriangleBar;",
  n: 824,
  o: "&NotRightTriangleBar;"
}], [11, "&iinfin;"], [0, "&infintie;"], [0, "&nvinfin;"], [4, "&eparsl;"], [0, "&smeparsl;"], [0, "&eqvparsl;"], [5, "&blacklozenge;"], [8, "&RuleDelayed;"], [1, "&dsol;"], [9, "&bigodot;"], [0, "&bigoplus;"], [0, "&bigotimes;"], [1, "&biguplus;"], [1, "&bigsqcup;"], [5, "&iiiint;"], [0, "&fpartint;"], [2, "&cirfnint;"], [0, "&awint;"], [0, "&rppolint;"], [0, "&scpolint;"], [0, "&npolint;"], [0, "&pointint;"], [0, "&quatint;"], [0, "&intlarhk;"], [10, "&pluscir;"], [0, "&plusacir;"], [0, "&simplus;"], [0, "&plusdu;"], [0, "&plussim;"], [0, "&plustwo;"], [1, "&mcomma;"], [0, "&minusdu;"], [2, "&loplus;"], [0, "&roplus;"], [0, "&Cross;"], [0, "&timesd;"], [0, "&timesbar;"], [1, "&smashp;"], [0, "&lotimes;"], [0, "&rotimes;"], [0, "&otimesas;"], [0, "&Otimes;"], [0, "&odiv;"], [0, "&triplus;"], [0, "&triminus;"], [0, "&tritime;"], [0, "&intprod;"], [2, "&amalg;"], [0, "&capdot;"], [1, "&ncup;"], [0, "&ncap;"], [0, "&capand;"], [0, "&cupor;"], [0, "&cupcap;"], [0, "&capcup;"], [0, "&cupbrcap;"], [0, "&capbrcup;"], [0, "&cupcup;"], [0, "&capcap;"], [0, "&ccups;"], [0, "&ccaps;"], [2, "&ccupssm;"], [2, "&And;"], [0, "&Or;"], [0, "&andand;"], [0, "&oror;"], [0, "&orslope;"], [0, "&andslope;"], [1, "&andv;"], [0, "&orv;"], [0, "&andd;"], [0, "&ord;"], [1, "&wedbar;"], [6, "&sdote;"], [3, "&simdot;"], [2, {
  v: "&congdot;",
  n: 824,
  o: "&ncongdot;"
}], [0, "&easter;"], [0, "&apacir;"], [0, {
  v: "&apE;",
  n: 824,
  o: "&napE;"
}], [0, "&eplus;"], [0, "&pluse;"], [0, "&Esim;"], [0, "&Colone;"], [0, "&Equal;"], [1, "&ddotseq;"], [0, "&equivDD;"], [0, "&ltcir;"], [0, "&gtcir;"], [0, "&ltquest;"], [0, "&gtquest;"], [0, {
  v: "&leqslant;",
  n: 824,
  o: "&nleqslant;"
}], [0, {
  v: "&geqslant;",
  n: 824,
  o: "&ngeqslant;"
}], [0, "&lesdot;"], [0, "&gesdot;"], [0, "&lesdoto;"], [0, "&gesdoto;"], [0, "&lesdotor;"], [0, "&gesdotol;"], [0, "&lap;"], [0, "&gap;"], [0, "&lne;"], [0, "&gne;"], [0, "&lnap;"], [0, "&gnap;"], [0, "&lEg;"], [0, "&gEl;"], [0, "&lsime;"], [0, "&gsime;"], [0, "&lsimg;"], [0, "&gsiml;"], [0, "&lgE;"], [0, "&glE;"], [0, "&lesges;"], [0, "&gesles;"], [0, "&els;"], [0, "&egs;"], [0, "&elsdot;"], [0, "&egsdot;"], [0, "&el;"], [0, "&eg;"], [2, "&siml;"], [0, "&simg;"], [0, "&simlE;"], [0, "&simgE;"], [0, {
  v: "&LessLess;",
  n: 824,
  o: "&NotNestedLessLess;"
}], [0, {
  v: "&GreaterGreater;",
  n: 824,
  o: "&NotNestedGreaterGreater;"
}], [1, "&glj;"], [0, "&gla;"], [0, "&ltcc;"], [0, "&gtcc;"], [0, "&lescc;"], [0, "&gescc;"], [0, "&smt;"], [0, "&lat;"], [0, {
  v: "&smte;",
  n: 65024,
  o: "&smtes;"
}], [0, {
  v: "&late;",
  n: 65024,
  o: "&lates;"
}], [0, "&bumpE;"], [0, {
  v: "&PrecedesEqual;",
  n: 824,
  o: "&NotPrecedesEqual;"
}], [0, {
  v: "&sce;",
  n: 824,
  o: "&NotSucceedsEqual;"
}], [2, "&prE;"], [0, "&scE;"], [0, "&precneqq;"], [0, "&scnE;"], [0, "&prap;"], [0, "&scap;"], [0, "&precnapprox;"], [0, "&scnap;"], [0, "&Pr;"], [0, "&Sc;"], [0, "&subdot;"], [0, "&supdot;"], [0, "&subplus;"], [0, "&supplus;"], [0, "&submult;"], [0, "&supmult;"], [0, "&subedot;"], [0, "&supedot;"], [0, {
  v: "&subE;",
  n: 824,
  o: "&nsubE;"
}], [0, {
  v: "&supE;",
  n: 824,
  o: "&nsupE;"
}], [0, "&subsim;"], [0, "&supsim;"], [2, {
  v: "&subnE;",
  n: 65024,
  o: "&varsubsetneqq;"
}], [0, {
  v: "&supnE;",
  n: 65024,
  o: "&varsupsetneqq;"
}], [2, "&csub;"], [0, "&csup;"], [0, "&csube;"], [0, "&csupe;"], [0, "&subsup;"], [0, "&supsub;"], [0, "&subsub;"], [0, "&supsup;"], [0, "&suphsub;"], [0, "&supdsub;"], [0, "&forkv;"], [0, "&topfork;"], [0, "&mlcp;"], [8, "&Dashv;"], [1, "&Vdashl;"], [0, "&Barv;"], [0, "&vBar;"], [0, "&vBarv;"], [1, "&Vbar;"], [0, "&Not;"], [0, "&bNot;"], [0, "&rnmid;"], [0, "&cirmid;"], [0, "&midcir;"], [0, "&topcir;"], [0, "&nhpar;"], [0, "&parsim;"], [9, {
  v: "&parsl;",
  n: 8421,
  o: "&nparsl;"
}], [44343, {
  n: new Map(/* #__PURE__ */restoreDiff([[56476, "&Ascr;"], [1, "&Cscr;"], [0, "&Dscr;"], [2, "&Gscr;"], [2, "&Jscr;"], [0, "&Kscr;"], [2, "&Nscr;"], [0, "&Oscr;"], [0, "&Pscr;"], [0, "&Qscr;"], [1, "&Sscr;"], [0, "&Tscr;"], [0, "&Uscr;"], [0, "&Vscr;"], [0, "&Wscr;"], [0, "&Xscr;"], [0, "&Yscr;"], [0, "&Zscr;"], [0, "&ascr;"], [0, "&bscr;"], [0, "&cscr;"], [0, "&dscr;"], [1, "&fscr;"], [1, "&hscr;"], [0, "&iscr;"], [0, "&jscr;"], [0, "&kscr;"], [0, "&lscr;"], [0, "&mscr;"], [0, "&nscr;"], [1, "&pscr;"], [0, "&qscr;"], [0, "&rscr;"], [0, "&sscr;"], [0, "&tscr;"], [0, "&uscr;"], [0, "&vscr;"], [0, "&wscr;"], [0, "&xscr;"], [0, "&yscr;"], [0, "&zscr;"], [52, "&Afr;"], [0, "&Bfr;"], [1, "&Dfr;"], [0, "&Efr;"], [0, "&Ffr;"], [0, "&Gfr;"], [2, "&Jfr;"], [0, "&Kfr;"], [0, "&Lfr;"], [0, "&Mfr;"], [0, "&Nfr;"], [0, "&Ofr;"], [0, "&Pfr;"], [0, "&Qfr;"], [1, "&Sfr;"], [0, "&Tfr;"], [0, "&Ufr;"], [0, "&Vfr;"], [0, "&Wfr;"], [0, "&Xfr;"], [0, "&Yfr;"], [1, "&afr;"], [0, "&bfr;"], [0, "&cfr;"], [0, "&dfr;"], [0, "&efr;"], [0, "&ffr;"], [0, "&gfr;"], [0, "&hfr;"], [0, "&ifr;"], [0, "&jfr;"], [0, "&kfr;"], [0, "&lfr;"], [0, "&mfr;"], [0, "&nfr;"], [0, "&ofr;"], [0, "&pfr;"], [0, "&qfr;"], [0, "&rfr;"], [0, "&sfr;"], [0, "&tfr;"], [0, "&ufr;"], [0, "&vfr;"], [0, "&wfr;"], [0, "&xfr;"], [0, "&yfr;"], [0, "&zfr;"], [0, "&Aopf;"], [0, "&Bopf;"], [1, "&Dopf;"], [0, "&Eopf;"], [0, "&Fopf;"], [0, "&Gopf;"], [1, "&Iopf;"], [0, "&Jopf;"], [0, "&Kopf;"], [0, "&Lopf;"], [0, "&Mopf;"], [1, "&Oopf;"], [3, "&Sopf;"], [0, "&Topf;"], [0, "&Uopf;"], [0, "&Vopf;"], [0, "&Wopf;"], [0, "&Xopf;"], [0, "&Yopf;"], [1, "&aopf;"], [0, "&bopf;"], [0, "&copf;"], [0, "&dopf;"], [0, "&eopf;"], [0, "&fopf;"], [0, "&gopf;"], [0, "&hopf;"], [0, "&iopf;"], [0, "&jopf;"], [0, "&kopf;"], [0, "&lopf;"], [0, "&mopf;"], [0, "&nopf;"], [0, "&oopf;"], [0, "&popf;"], [0, "&qopf;"], [0, "&ropf;"], [0, "&sopf;"], [0, "&topf;"], [0, "&uopf;"], [0, "&vopf;"], [0, "&wopf;"], [0, "&xopf;"], [0, "&yopf;"], [0, "&zopf;"]]))
}], [8906, "&fflig;"], [0, "&filig;"], [0, "&fllig;"], [0, "&ffilig;"], [0, "&ffllig;"]])));

/***/ }),
/* 354 */
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   encodeXML: function() { return /* binding */ encodeXML; },
/* harmony export */   escape: function() { return /* binding */ escape; },
/* harmony export */   escapeAttribute: function() { return /* binding */ escapeAttribute; },
/* harmony export */   escapeText: function() { return /* binding */ escapeText; },
/* harmony export */   escapeUTF8: function() { return /* binding */ escapeUTF8; },
/* harmony export */   getCodePoint: function() { return /* binding */ getCodePoint; },
/* harmony export */   xmlReplacer: function() { return /* binding */ xmlReplacer; }
/* harmony export */ });
const xmlReplacer = /["&'<>$\x80-\uFFFF]/g;
const xmlCodeMap = new Map([[34, "&quot;"], [38, "&amp;"], [39, "&apos;"], [60, "&lt;"], [62, "&gt;"]]);
// For compatibility with node < 4, we wrap `codePointAt`
const getCodePoint =
// eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
String.prototype.codePointAt != null ? (str, index) => str.codePointAt(index) :
// http://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae
(c, index) => (c.charCodeAt(index) & 0xfc00) === 0xd800 ? (c.charCodeAt(index) - 0xd800) * 0x400 + c.charCodeAt(index + 1) - 0xdc00 + 0x10000 : c.charCodeAt(index);
/**
 * Encodes all non-ASCII characters, as well as characters not valid in XML
 * documents using XML entities.
 *
 * If a character has no equivalent entity, a
 * numeric hexadecimal reference (eg. `&#xfc;`) will be used.
 */
function encodeXML(str) {
  let ret = "";
  let lastIdx = 0;
  let match;
  while ((match = xmlReplacer.exec(str)) !== null) {
    const i = match.index;
    const char = str.charCodeAt(i);
    const next = xmlCodeMap.get(char);
    if (next !== undefined) {
      ret += str.substring(lastIdx, i) + next;
      lastIdx = i + 1;
    } else {
      ret += `${str.substring(lastIdx, i)}&#x${getCodePoint(str, i).toString(16)};`;
      // Increase by 1 if we have a surrogate pair
      lastIdx = xmlReplacer.lastIndex += Number((char & 0xfc00) === 0xd800);
    }
  }
  return ret + str.substr(lastIdx);
}
/**
 * Encodes all non-ASCII characters, as well as characters not valid in XML
 * documents using numeric hexadecimal reference (eg. `&#xfc;`).
 *
 * Have a look at `escapeUTF8` if you want a more concise output at the expense
 * of reduced transportability.
 *
 * @param data String to escape.
 */
const escape = encodeXML;
/**
 * Creates a function that escapes all characters matched by the given regular
 * expression using the given map of characters to escape to their entities.
 *
 * @param regex Regular expression to match characters to escape.
 * @param map Map of characters to escape to their entities.
 *
 * @returns Function that escapes all characters matched by the given regular
 * expression using the given map of characters to escape to their entities.
 */
function getEscaper(regex, map) {
  return function escape(data) {
    let match;
    let lastIdx = 0;
    let result = "";
    while (match = regex.exec(data)) {
      if (lastIdx !== match.index) {
        result += data.substring(lastIdx, match.index);
      }
      // We know that this character will be in the map.
      result += map.get(match[0].charCodeAt(0));
      // Every match will be of length 1
      lastIdx = match.index + 1;
    }
    return result + data.substring(lastIdx);
  };
}
/**
 * Encodes all characters not valid in XML documents using XML entities.
 *
 * Note that the output will be character-set dependent.
 *
 * @param data String to escape.
 */
const escapeUTF8 = getEscaper(/[&<>'"]/g, xmlCodeMap);
/**
 * Encodes all characters that have to be escaped in HTML attributes,
 * following {@link https://html.spec.whatwg.org/multipage/parsing.html#escapingString}.
 *
 * @param data String to escape.
 */
const escapeAttribute = getEscaper(/["&\u00A0]/g, new Map([[34, "&quot;"], [38, "&amp;"], [160, "&nbsp;"]]));
/**
 * Encodes all characters that have to be escaped in HTML text,
 * following {@link https://html.spec.whatwg.org/multipage/parsing.html#escapingString}.
 *
 * @param data String to escape.
 */
const escapeText = getEscaper(/[&<>\u00A0]/g, new Map([[38, "&amp;"], [60, "&lt;"], [62, "&gt;"], [160, "&nbsp;"]]));

/***/ }),
/* 355 */
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   attributeNames: function() { return /* binding */ attributeNames; },
/* harmony export */   elementNames: function() { return /* binding */ elementNames; }
/* harmony export */ });
const elementNames = new Map(["altGlyph", "altGlyphDef", "altGlyphItem", "animateColor", "animateMotion", "animateTransform", "clipPath", "feBlend", "feColorMatrix", "feComponentTransfer", "feComposite", "feConvolveMatrix", "feDiffuseLighting", "feDisplacementMap", "feDistantLight", "feDropShadow", "feFlood", "feFuncA", "feFuncB", "feFuncG", "feFuncR", "feGaussianBlur", "feImage", "feMerge", "feMergeNode", "feMorphology", "feOffset", "fePointLight", "feSpecularLighting", "feSpotLight", "feTile", "feTurbulence", "foreignObject", "glyphRef", "linearGradient", "radialGradient", "textPath"].map(val => [val.toLowerCase(), val]));
const attributeNames = new Map(["definitionURL", "attributeName", "attributeType", "baseFrequency", "baseProfile", "calcMode", "clipPathUnits", "diffuseConstant", "edgeMode", "filterUnits", "glyphRef", "gradientTransform", "gradientUnits", "kernelMatrix", "kernelUnitLength", "keyPoints", "keySplines", "keyTimes", "lengthAdjust", "limitingConeAngle", "markerHeight", "markerUnits", "markerWidth", "maskContentUnits", "maskUnits", "numOctaves", "pathLength", "patternContentUnits", "patternTransform", "patternUnits", "pointsAtX", "pointsAtY", "pointsAtZ", "preserveAlpha", "preserveAspectRatio", "primitiveUnits", "refX", "refY", "repeatCount", "repeatDur", "requiredExtensions", "requiredFeatures", "specularConstant", "specularExponent", "spreadMethod", "startOffset", "stdDeviation", "stitchTiles", "surfaceScale", "systemLanguage", "tableValues", "targetX", "targetY", "textLength", "viewBox", "viewTarget", "xChannelSelector", "yChannelSelector", "zoomAndPan"].map(val => [val.toLowerCase(), val]));

/***/ }),
/* 356 */
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   getAttributeValue: function() { return /* binding */ getAttributeValue; },
/* harmony export */   getChildren: function() { return /* binding */ getChildren; },
/* harmony export */   getName: function() { return /* binding */ getName; },
/* harmony export */   getParent: function() { return /* binding */ getParent; },
/* harmony export */   getSiblings: function() { return /* binding */ getSiblings; },
/* harmony export */   hasAttrib: function() { return /* binding */ hasAttrib; },
/* harmony export */   nextElementSibling: function() { return /* binding */ nextElementSibling; },
/* harmony export */   prevElementSibling: function() { return /* binding */ prevElementSibling; }
/* harmony export */ });
/* harmony import */ var domhandler__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(345);

/**
 * Get a node's children.
 *
 * @category Traversal
 * @param elem Node to get the children of.
 * @returns `elem`'s children, or an empty array.
 */
function getChildren(elem) {
  return (0,domhandler__WEBPACK_IMPORTED_MODULE_0__.hasChildren)(elem) ? elem.children : [];
}
/**
 * Get a node's parent.
 *
 * @category Traversal
 * @param elem Node to get the parent of.
 * @returns `elem`'s parent node, or `null` if `elem` is a root node.
 */
function getParent(elem) {
  return elem.parent || null;
}
/**
 * Gets an elements siblings, including the element itself.
 *
 * Attempts to get the children through the element's parent first. If we don't
 * have a parent (the element is a root node), we walk the element's `prev` &
 * `next` to get all remaining nodes.
 *
 * @category Traversal
 * @param elem Element to get the siblings of.
 * @returns `elem`'s siblings, including `elem`.
 */
function getSiblings(elem) {
  const parent = getParent(elem);
  if (parent != null) return getChildren(parent);
  const siblings = [elem];
  let {
    prev,
    next
  } = elem;
  while (prev != null) {
    siblings.unshift(prev);
    ({
      prev
    } = prev);
  }
  while (next != null) {
    siblings.push(next);
    ({
      next
    } = next);
  }
  return siblings;
}
/**
 * Gets an attribute from an element.
 *
 * @category Traversal
 * @param elem Element to check.
 * @param name Attribute name to retrieve.
 * @returns The element's attribute value, or `undefined`.
 */
function getAttributeValue(elem, name) {
  var _a;
  return (_a = elem.attribs) === null || _a === void 0 ? void 0 : _a[name];
}
/**
 * Checks whether an element has an attribute.
 *
 * @category Traversal
 * @param elem Element to check.
 * @param name Attribute name to look for.
 * @returns Returns whether `elem` has the attribute `name`.
 */
function hasAttrib(elem, name) {
  return elem.attribs != null && Object.prototype.hasOwnProperty.call(elem.attribs, name) && elem.attribs[name] != null;
}
/**
 * Get the tag name of an element.
 *
 * @category Traversal
 * @param elem The element to get the name for.
 * @returns The tag name of `elem`.
 */
function getName(elem) {
  return elem.name;
}
/**
 * Returns the next element sibling of a node.
 *
 * @category Traversal
 * @param elem The element to get the next sibling of.
 * @returns `elem`'s next sibling that is a tag, or `null` if there is no next
 * sibling.
 */
function nextElementSibling(elem) {
  let {
    next
  } = elem;
  while (next !== null && !(0,domhandler__WEBPACK_IMPORTED_MODULE_0__.isTag)(next)) ({
    next
  } = next);
  return next;
}
/**
 * Returns the previous element sibling of a node.
 *
 * @category Traversal
 * @param elem The element to get the previous sibling of.
 * @returns `elem`'s previous sibling that is a tag, or `null` if there is no
 * previous sibling.
 */
function prevElementSibling(elem) {
  let {
    prev
  } = elem;
  while (prev !== null && !(0,domhandler__WEBPACK_IMPORTED_MODULE_0__.isTag)(prev)) ({
    prev
  } = prev);
  return prev;
}

/***/ }),
/* 357 */
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   append: function() { return /* binding */ append; },
/* harmony export */   appendChild: function() { return /* binding */ appendChild; },
/* harmony export */   prepend: function() { return /* binding */ prepend; },
/* harmony export */   prependChild: function() { return /* binding */ prependChild; },
/* harmony export */   removeElement: function() { return /* binding */ removeElement; },
/* harmony export */   replaceElement: function() { return /* binding */ replaceElement; }
/* harmony export */ });
/**
 * Remove an element from the dom
 *
 * @category Manipulation
 * @param elem The element to be removed
 */
function removeElement(elem) {
  if (elem.prev) elem.prev.next = elem.next;
  if (elem.next) elem.next.prev = elem.prev;
  if (elem.parent) {
    const childs = elem.parent.children;
    const childsIndex = childs.lastIndexOf(elem);
    if (childsIndex >= 0) {
      childs.splice(childsIndex, 1);
    }
  }
  elem.next = null;
  elem.prev = null;
  elem.parent = null;
}
/**
 * Replace an element in the dom
 *
 * @category Manipulation
 * @param elem The element to be replaced
 * @param replacement The element to be added
 */
function replaceElement(elem, replacement) {
  const prev = replacement.prev = elem.prev;
  if (prev) {
    prev.next = replacement;
  }
  const next = replacement.next = elem.next;
  if (next) {
    next.prev = replacement;
  }
  const parent = replacement.parent = elem.parent;
  if (parent) {
    const childs = parent.children;
    childs[childs.lastIndexOf(elem)] = replacement;
    elem.parent = null;
  }
}
/**
 * Append a child to an element.
 *
 * @category Manipulation
 * @param parent The element to append to.
 * @param child The element to be added as a child.
 */
function appendChild(parent, child) {
  removeElement(child);
  child.next = null;
  child.parent = parent;
  if (parent.children.push(child) > 1) {
    const sibling = parent.children[parent.children.length - 2];
    sibling.next = child;
    child.prev = sibling;
  } else {
    child.prev = null;
  }
}
/**
 * Append an element after another.
 *
 * @category Manipulation
 * @param elem The element to append after.
 * @param next The element be added.
 */
function append(elem, next) {
  removeElement(next);
  const {
    parent
  } = elem;
  const currNext = elem.next;
  next.next = currNext;
  next.prev = elem;
  elem.next = next;
  next.parent = parent;
  if (currNext) {
    currNext.prev = next;
    if (parent) {
      const childs = parent.children;
      childs.splice(childs.lastIndexOf(currNext), 0, next);
    }
  } else if (parent) {
    parent.children.push(next);
  }
}
/**
 * Prepend a child to an element.
 *
 * @category Manipulation
 * @param parent The element to prepend before.
 * @param child The element to be added as a child.
 */
function prependChild(parent, child) {
  removeElement(child);
  child.parent = parent;
  child.prev = null;
  if (parent.children.unshift(child) !== 1) {
    const sibling = parent.children[1];
    sibling.prev = child;
    child.next = sibling;
  } else {
    child.next = null;
  }
}
/**
 * Prepend an element before another.
 *
 * @category Manipulation
 * @param elem The element to prepend before.
 * @param prev The element be added.
 */
function prepend(elem, prev) {
  removeElement(prev);
  const {
    parent
  } = elem;
  if (parent) {
    const childs = parent.children;
    childs.splice(childs.indexOf(elem), 0, prev);
  }
  if (elem.prev) {
    elem.prev.next = prev;
  }
  prev.parent = parent;
  prev.prev = elem.prev;
  prev.next = elem;
  elem.prev = prev;
}

/***/ }),
/* 358 */
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   existsOne: function() { return /* binding */ existsOne; },
/* harmony export */   filter: function() { return /* binding */ filter; },
/* harmony export */   find: function() { return /* binding */ find; },
/* harmony export */   findAll: function() { return /* binding */ findAll; },
/* harmony export */   findOne: function() { return /* binding */ findOne; },
/* harmony export */   findOneChild: function() { return /* binding */ findOneChild; }
/* harmony export */ });
/* harmony import */ var domhandler__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(345);

/**
 * Search a node and its children for nodes passing a test function. If `node` is not an array, it will be wrapped in one.
 *
 * @category Querying
 * @param test Function to test nodes on.
 * @param node Node to search. Will be included in the result set if it matches.
 * @param recurse Also consider child nodes.
 * @param limit Maximum number of nodes to return.
 * @returns All nodes passing `test`.
 */
function filter(test, node, recurse = true, limit = Infinity) {
  return find(test, Array.isArray(node) ? node : [node], recurse, limit);
}
/**
 * Search an array of nodes and their children for nodes passing a test function.
 *
 * @category Querying
 * @param test Function to test nodes on.
 * @param nodes Array of nodes to search.
 * @param recurse Also consider child nodes.
 * @param limit Maximum number of nodes to return.
 * @returns All nodes passing `test`.
 */
function find(test, nodes, recurse, limit) {
  const result = [];
  /** Stack of the arrays we are looking at. */
  const nodeStack = [nodes];
  /** Stack of the indices within the arrays. */
  const indexStack = [0];
  for (;;) {
    // First, check if the current array has any more elements to look at.
    if (indexStack[0] >= nodeStack[0].length) {
      // If we have no more arrays to look at, we are done.
      if (indexStack.length === 1) {
        return result;
      }
      // Otherwise, remove the current array from the stack.
      nodeStack.shift();
      indexStack.shift();
      // Loop back to the start to continue with the next array.
      continue;
    }
    const elem = nodeStack[0][indexStack[0]++];
    if (test(elem)) {
      result.push(elem);
      if (--limit <= 0) return result;
    }
    if (recurse && (0,domhandler__WEBPACK_IMPORTED_MODULE_0__.hasChildren)(elem) && elem.children.length > 0) {
      /*
       * Add the children to the stack. We are depth-first, so this is
       * the next array we look at.
       */
      indexStack.unshift(0);
      nodeStack.unshift(elem.children);
    }
  }
}
/**
 * Finds the first element inside of an array that matches a test function. This is an alias for `Array.prototype.find`.
 *
 * @category Querying
 * @param test Function to test nodes on.
 * @param nodes Array of nodes to search.
 * @returns The first node in the array that passes `test`.
 * @deprecated Use `Array.prototype.find` directly.
 */
function findOneChild(test, nodes) {
  return nodes.find(test);
}
/**
 * Finds one element in a tree that passes a test.
 *
 * @category Querying
 * @param test Function to test nodes on.
 * @param nodes Node or array of nodes to search.
 * @param recurse Also consider child nodes.
 * @returns The first node that passes `test`.
 */
function findOne(test, nodes, recurse = true) {
  let elem = null;
  for (let i = 0; i < nodes.length && !elem; i++) {
    const node = nodes[i];
    if (!(0,domhandler__WEBPACK_IMPORTED_MODULE_0__.isTag)(node)) {
      continue;
    } else if (test(node)) {
      elem = node;
    } else if (recurse && node.children.length > 0) {
      elem = findOne(test, node.children, true);
    }
  }
  return elem;
}
/**
 * Checks if a tree of nodes contains at least one node passing a test.
 *
 * @category Querying
 * @param test Function to test nodes on.
 * @param nodes Array of nodes to search.
 * @returns Whether a tree of nodes contains at least one node passing the test.
 */
function existsOne(test, nodes) {
  return nodes.some(checked => (0,domhandler__WEBPACK_IMPORTED_MODULE_0__.isTag)(checked) && (test(checked) || existsOne(test, checked.children)));
}
/**
 * Search an array of nodes and their children for elements passing a test function.
 *
 * Same as `find`, but limited to elements and with less options, leading to reduced complexity.
 *
 * @category Querying
 * @param test Function to test nodes on.
 * @param nodes Array of nodes to search.
 * @returns All nodes passing `test`.
 */
function findAll(test, nodes) {
  const result = [];
  const nodeStack = [nodes];
  const indexStack = [0];
  for (;;) {
    if (indexStack[0] >= nodeStack[0].length) {
      if (nodeStack.length === 1) {
        return result;
      }
      // Otherwise, remove the current array from the stack.
      nodeStack.shift();
      indexStack.shift();
      // Loop back to the start to continue with the next array.
      continue;
    }
    const elem = nodeStack[0][indexStack[0]++];
    if (!(0,domhandler__WEBPACK_IMPORTED_MODULE_0__.isTag)(elem)) continue;
    if (test(elem)) result.push(elem);
    if (elem.children.length > 0) {
      indexStack.unshift(0);
      nodeStack.unshift(elem.children);
    }
  }
}

/***/ }),
/* 359 */
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   getElementById: function() { return /* binding */ getElementById; },
/* harmony export */   getElements: function() { return /* binding */ getElements; },
/* harmony export */   getElementsByTagName: function() { return /* binding */ getElementsByTagName; },
/* harmony export */   getElementsByTagType: function() { return /* binding */ getElementsByTagType; },
/* harmony export */   testElement: function() { return /* binding */ testElement; }
/* harmony export */ });
/* harmony import */ var domhandler__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(345);
/* harmony import */ var _querying_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(358);


/**
 * A map of functions to check nodes against.
 */
const Checks = {
  tag_name(name) {
    if (typeof name === "function") {
      return elem => (0,domhandler__WEBPACK_IMPORTED_MODULE_0__.isTag)(elem) && name(elem.name);
    } else if (name === "*") {
      return domhandler__WEBPACK_IMPORTED_MODULE_0__.isTag;
    }
    return elem => (0,domhandler__WEBPACK_IMPORTED_MODULE_0__.isTag)(elem) && elem.name === name;
  },
  tag_type(type) {
    if (typeof type === "function") {
      return elem => type(elem.type);
    }
    return elem => elem.type === type;
  },
  tag_contains(data) {
    if (typeof data === "function") {
      return elem => (0,domhandler__WEBPACK_IMPORTED_MODULE_0__.isText)(elem) && data(elem.data);
    }
    return elem => (0,domhandler__WEBPACK_IMPORTED_MODULE_0__.isText)(elem) && elem.data === data;
  }
};
/**
 * Returns a function to check whether a node has an attribute with a particular
 * value.
 *
 * @param attrib Attribute to check.
 * @param value Attribute value to look for.
 * @returns A function to check whether the a node has an attribute with a
 *   particular value.
 */
function getAttribCheck(attrib, value) {
  if (typeof value === "function") {
    return elem => (0,domhandler__WEBPACK_IMPORTED_MODULE_0__.isTag)(elem) && value(elem.attribs[attrib]);
  }
  return elem => (0,domhandler__WEBPACK_IMPORTED_MODULE_0__.isTag)(elem) && elem.attribs[attrib] === value;
}
/**
 * Returns a function that returns `true` if either of the input functions
 * returns `true` for a node.
 *
 * @param a First function to combine.
 * @param b Second function to combine.
 * @returns A function taking a node and returning `true` if either of the input
 *   functions returns `true` for the node.
 */
function combineFuncs(a, b) {
  return elem => a(elem) || b(elem);
}
/**
 * Returns a function that executes all checks in `options` and returns `true`
 * if any of them match a node.
 *
 * @param options An object describing nodes to look for.
 * @returns A function that executes all checks in `options` and returns `true`
 *   if any of them match a node.
 */
function compileTest(options) {
  const funcs = Object.keys(options).map(key => {
    const value = options[key];
    return Object.prototype.hasOwnProperty.call(Checks, key) ? Checks[key](value) : getAttribCheck(key, value);
  });
  return funcs.length === 0 ? null : funcs.reduce(combineFuncs);
}
/**
 * Checks whether a node matches the description in `options`.
 *
 * @category Legacy Query Functions
 * @param options An object describing nodes to look for.
 * @param node The element to test.
 * @returns Whether the element matches the description in `options`.
 */
function testElement(options, node) {
  const test = compileTest(options);
  return test ? test(node) : true;
}
/**
 * Returns all nodes that match `options`.
 *
 * @category Legacy Query Functions
 * @param options An object describing nodes to look for.
 * @param nodes Nodes to search through.
 * @param recurse Also consider child nodes.
 * @param limit Maximum number of nodes to return.
 * @returns All nodes that match `options`.
 */
function getElements(options, nodes, recurse, limit = Infinity) {
  const test = compileTest(options);
  return test ? (0,_querying_js__WEBPACK_IMPORTED_MODULE_1__.filter)(test, nodes, recurse, limit) : [];
}
/**
 * Returns the node with the supplied ID.
 *
 * @category Legacy Query Functions
 * @param id The unique ID attribute value to look for.
 * @param nodes Nodes to search through.
 * @param recurse Also consider child nodes.
 * @returns The node with the supplied ID.
 */
function getElementById(id, nodes, recurse = true) {
  if (!Array.isArray(nodes)) nodes = [nodes];
  return (0,_querying_js__WEBPACK_IMPORTED_MODULE_1__.findOne)(getAttribCheck("id", id), nodes, recurse);
}
/**
 * Returns all nodes with the supplied `tagName`.
 *
 * @category Legacy Query Functions
 * @param tagName Tag name to search for.
 * @param nodes Nodes to search through.
 * @param recurse Also consider child nodes.
 * @param limit Maximum number of nodes to return.
 * @returns All nodes with the supplied `tagName`.
 */
function getElementsByTagName(tagName, nodes, recurse = true, limit = Infinity) {
  return (0,_querying_js__WEBPACK_IMPORTED_MODULE_1__.filter)(Checks["tag_name"](tagName), nodes, recurse, limit);
}
/**
 * Returns all nodes with the supplied `type`.
 *
 * @category Legacy Query Functions
 * @param type Element type to look for.
 * @param nodes Nodes to search through.
 * @param recurse Also consider child nodes.
 * @param limit Maximum number of nodes to return.
 * @returns All nodes with the supplied `type`.
 */
function getElementsByTagType(type, nodes, recurse = true, limit = Infinity) {
  return (0,_querying_js__WEBPACK_IMPORTED_MODULE_1__.filter)(Checks["tag_type"](type), nodes, recurse, limit);
}

/***/ }),
/* 360 */
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   DocumentPosition: function() { return /* binding */ DocumentPosition; },
/* harmony export */   compareDocumentPosition: function() { return /* binding */ compareDocumentPosition; },
/* harmony export */   removeSubsets: function() { return /* binding */ removeSubsets; },
/* harmony export */   uniqueSort: function() { return /* binding */ uniqueSort; }
/* harmony export */ });
/* harmony import */ var domhandler__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(345);

/**
 * Given an array of nodes, remove any member that is contained by another
 * member.
 *
 * @category Helpers
 * @param nodes Nodes to filter.
 * @returns Remaining nodes that aren't contained by other nodes.
 */
function removeSubsets(nodes) {
  let idx = nodes.length;
  /*
   * Check if each node (or one of its ancestors) is already contained in the
   * array.
   */
  while (--idx >= 0) {
    const node = nodes[idx];
    /*
     * Remove the node if it is not unique.
     * We are going through the array from the end, so we only
     * have to check nodes that preceed the node under consideration in the array.
     */
    if (idx > 0 && nodes.lastIndexOf(node, idx - 1) >= 0) {
      nodes.splice(idx, 1);
      continue;
    }
    for (let ancestor = node.parent; ancestor; ancestor = ancestor.parent) {
      if (nodes.includes(ancestor)) {
        nodes.splice(idx, 1);
        break;
      }
    }
  }
  return nodes;
}
/**
 * @category Helpers
 * @see {@link http://dom.spec.whatwg.org/#dom-node-comparedocumentposition}
 */
var DocumentPosition;
(function (DocumentPosition) {
  DocumentPosition[DocumentPosition["DISCONNECTED"] = 1] = "DISCONNECTED";
  DocumentPosition[DocumentPosition["PRECEDING"] = 2] = "PRECEDING";
  DocumentPosition[DocumentPosition["FOLLOWING"] = 4] = "FOLLOWING";
  DocumentPosition[DocumentPosition["CONTAINS"] = 8] = "CONTAINS";
  DocumentPosition[DocumentPosition["CONTAINED_BY"] = 16] = "CONTAINED_BY";
})(DocumentPosition || (DocumentPosition = {}));
/**
 * Compare the position of one node against another node in any other document,
 * returning a bitmask with the values from {@link DocumentPosition}.
 *
 * Document order:
 * > There is an ordering, document order, defined on all the nodes in the
 * > document corresponding to the order in which the first character of the
 * > XML representation of each node occurs in the XML representation of the
 * > document after expansion of general entities. Thus, the document element
 * > node will be the first node. Element nodes occur before their children.
 * > Thus, document order orders element nodes in order of the occurrence of
 * > their start-tag in the XML (after expansion of entities). The attribute
 * > nodes of an element occur after the element and before its children. The
 * > relative order of attribute nodes is implementation-dependent.
 *
 * Source:
 * http://www.w3.org/TR/DOM-Level-3-Core/glossary.html#dt-document-order
 *
 * @category Helpers
 * @param nodeA The first node to use in the comparison
 * @param nodeB The second node to use in the comparison
 * @returns A bitmask describing the input nodes' relative position.
 *
 * See http://dom.spec.whatwg.org/#dom-node-comparedocumentposition for
 * a description of these values.
 */
function compareDocumentPosition(nodeA, nodeB) {
  const aParents = [];
  const bParents = [];
  if (nodeA === nodeB) {
    return 0;
  }
  let current = (0,domhandler__WEBPACK_IMPORTED_MODULE_0__.hasChildren)(nodeA) ? nodeA : nodeA.parent;
  while (current) {
    aParents.unshift(current);
    current = current.parent;
  }
  current = (0,domhandler__WEBPACK_IMPORTED_MODULE_0__.hasChildren)(nodeB) ? nodeB : nodeB.parent;
  while (current) {
    bParents.unshift(current);
    current = current.parent;
  }
  const maxIdx = Math.min(aParents.length, bParents.length);
  let idx = 0;
  while (idx < maxIdx && aParents[idx] === bParents[idx]) {
    idx++;
  }
  if (idx === 0) {
    return DocumentPosition.DISCONNECTED;
  }
  const sharedParent = aParents[idx - 1];
  const siblings = sharedParent.children;
  const aSibling = aParents[idx];
  const bSibling = bParents[idx];
  if (siblings.indexOf(aSibling) > siblings.indexOf(bSibling)) {
    if (sharedParent === nodeB) {
      return DocumentPosition.FOLLOWING | DocumentPosition.CONTAINED_BY;
    }
    return DocumentPosition.FOLLOWING;
  }
  if (sharedParent === nodeA) {
    return DocumentPosition.PRECEDING | DocumentPosition.CONTAINS;
  }
  return DocumentPosition.PRECEDING;
}
/**
 * Sort an array of nodes based on their relative position in the document,
 * removing any duplicate nodes. If the array contains nodes that do not belong
 * to the same document, sort order is unspecified.
 *
 * @category Helpers
 * @param nodes Array of DOM nodes.
 * @returns Collection of unique nodes, sorted in document order.
 */
function uniqueSort(nodes) {
  nodes = nodes.filter((node, i, arr) => !arr.includes(node, i + 1));
  nodes.sort((a, b) => {
    const relative = compareDocumentPosition(a, b);
    if (relative & DocumentPosition.PRECEDING) {
      return -1;
    } else if (relative & DocumentPosition.FOLLOWING) {
      return 1;
    }
    return 0;
  });
  return nodes;
}

/***/ }),
/* 361 */
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   getFeed: function() { return /* binding */ getFeed; }
/* harmony export */ });
/* harmony import */ var _stringify_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(349);
/* harmony import */ var _legacy_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(359);


/**
 * Get the feed object from the root of a DOM tree.
 *
 * @category Feeds
 * @param doc - The DOM to to extract the feed from.
 * @returns The feed.
 */
function getFeed(doc) {
  const feedRoot = getOneElement(isValidFeed, doc);
  return !feedRoot ? null : feedRoot.name === "feed" ? getAtomFeed(feedRoot) : getRssFeed(feedRoot);
}
/**
 * Parse an Atom feed.
 *
 * @param feedRoot The root of the feed.
 * @returns The parsed feed.
 */
function getAtomFeed(feedRoot) {
  var _a;
  const childs = feedRoot.children;
  const feed = {
    type: "atom",
    items: (0,_legacy_js__WEBPACK_IMPORTED_MODULE_1__.getElementsByTagName)("entry", childs).map(item => {
      var _a;
      const {
        children
      } = item;
      const entry = {
        media: getMediaElements(children)
      };
      addConditionally(entry, "id", "id", children);
      addConditionally(entry, "title", "title", children);
      const href = (_a = getOneElement("link", children)) === null || _a === void 0 ? void 0 : _a.attribs["href"];
      if (href) {
        entry.link = href;
      }
      const description = fetch("summary", children) || fetch("content", children);
      if (description) {
        entry.description = description;
      }
      const pubDate = fetch("updated", children);
      if (pubDate) {
        entry.pubDate = new Date(pubDate);
      }
      return entry;
    })
  };
  addConditionally(feed, "id", "id", childs);
  addConditionally(feed, "title", "title", childs);
  const href = (_a = getOneElement("link", childs)) === null || _a === void 0 ? void 0 : _a.attribs["href"];
  if (href) {
    feed.link = href;
  }
  addConditionally(feed, "description", "subtitle", childs);
  const updated = fetch("updated", childs);
  if (updated) {
    feed.updated = new Date(updated);
  }
  addConditionally(feed, "author", "email", childs, true);
  return feed;
}
/**
 * Parse a RSS feed.
 *
 * @param feedRoot The root of the feed.
 * @returns The parsed feed.
 */
function getRssFeed(feedRoot) {
  var _a, _b;
  const childs = (_b = (_a = getOneElement("channel", feedRoot.children)) === null || _a === void 0 ? void 0 : _a.children) !== null && _b !== void 0 ? _b : [];
  const feed = {
    type: feedRoot.name.substr(0, 3),
    id: "",
    items: (0,_legacy_js__WEBPACK_IMPORTED_MODULE_1__.getElementsByTagName)("item", feedRoot.children).map(item => {
      const {
        children
      } = item;
      const entry = {
        media: getMediaElements(children)
      };
      addConditionally(entry, "id", "guid", children);
      addConditionally(entry, "title", "title", children);
      addConditionally(entry, "link", "link", children);
      addConditionally(entry, "description", "description", children);
      const pubDate = fetch("pubDate", children) || fetch("dc:date", children);
      if (pubDate) entry.pubDate = new Date(pubDate);
      return entry;
    })
  };
  addConditionally(feed, "title", "title", childs);
  addConditionally(feed, "link", "link", childs);
  addConditionally(feed, "description", "description", childs);
  const updated = fetch("lastBuildDate", childs);
  if (updated) {
    feed.updated = new Date(updated);
  }
  addConditionally(feed, "author", "managingEditor", childs, true);
  return feed;
}
const MEDIA_KEYS_STRING = ["url", "type", "lang"];
const MEDIA_KEYS_INT = ["fileSize", "bitrate", "framerate", "samplingrate", "channels", "duration", "height", "width"];
/**
 * Get all media elements of a feed item.
 *
 * @param where Nodes to search in.
 * @returns Media elements.
 */
function getMediaElements(where) {
  return (0,_legacy_js__WEBPACK_IMPORTED_MODULE_1__.getElementsByTagName)("media:content", where).map(elem => {
    const {
      attribs
    } = elem;
    const media = {
      medium: attribs["medium"],
      isDefault: !!attribs["isDefault"]
    };
    for (const attrib of MEDIA_KEYS_STRING) {
      if (attribs[attrib]) {
        media[attrib] = attribs[attrib];
      }
    }
    for (const attrib of MEDIA_KEYS_INT) {
      if (attribs[attrib]) {
        media[attrib] = parseInt(attribs[attrib], 10);
      }
    }
    if (attribs["expression"]) {
      media.expression = attribs["expression"];
    }
    return media;
  });
}
/**
 * Get one element by tag name.
 *
 * @param tagName Tag name to look for
 * @param node Node to search in
 * @returns The element or null
 */
function getOneElement(tagName, node) {
  return (0,_legacy_js__WEBPACK_IMPORTED_MODULE_1__.getElementsByTagName)(tagName, node, true, 1)[0];
}
/**
 * Get the text content of an element with a certain tag name.
 *
 * @param tagName Tag name to look for.
 * @param where Node to search in.
 * @param recurse Whether to recurse into child nodes.
 * @returns The text content of the element.
 */
function fetch(tagName, where, recurse = false) {
  return (0,_stringify_js__WEBPACK_IMPORTED_MODULE_0__.textContent)((0,_legacy_js__WEBPACK_IMPORTED_MODULE_1__.getElementsByTagName)(tagName, where, recurse, 1)).trim();
}
/**
 * Adds a property to an object if it has a value.
 *
 * @param obj Object to be extended
 * @param prop Property name
 * @param tagName Tag name that contains the conditionally added property
 * @param where Element to search for the property
 * @param recurse Whether to recurse into child nodes.
 */
function addConditionally(obj, prop, tagName, where, recurse = false) {
  const val = fetch(tagName, where, recurse);
  if (val) obj[prop] = val;
}
/**
 * Checks if an element is a feed root node.
 *
 * @param value The name of the element to check.
 * @returns Whether an element is a feed root node.
 */
function isValidFeed(value) {
  return value === "rss" || value === "feed" || value === "rdf:RDF";
}

/***/ }),
/* 362 */
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _cjs_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(363);


// ensure compatibility with rollup umd build
/* harmony default export */ __webpack_exports__["default"] = (_cjs_index_js__WEBPACK_IMPORTED_MODULE_0__["default"] || _cjs_index_js__WEBPACK_IMPORTED_MODULE_0__);

/***/ }),
/* 363 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";


var __importDefault = this && this.__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = StyleToObject;
var inline_style_parser_1 = __importDefault(__webpack_require__(364));
/**
 * Parses inline style to object.
 *
 * @param style - Inline style.
 * @param iterator - Iterator.
 * @returns - Style object or null.
 *
 * @example Parsing inline style to object:
 *
 * ```js
 * import parse from 'style-to-object';
 * parse('line-height: 42;'); // { 'line-height': '42' }
 * ```
 */
function StyleToObject(style, iterator) {
  var styleObject = null;
  if (!style || typeof style !== 'string') {
    return styleObject;
  }
  var declarations = (0, inline_style_parser_1.default)(style);
  var hasIterator = typeof iterator === 'function';
  declarations.forEach(function (declaration) {
    if (declaration.type !== 'declaration') {
      return;
    }
    var property = declaration.property,
      value = declaration.value;
    if (hasIterator) {
      iterator(property, value, declaration);
    } else if (value) {
      styleObject = styleObject || {};
      styleObject[property] = value;
    }
  });
  return styleObject;
}

/***/ }),
/* 364 */
/***/ (function(module) {

// http://www.w3.org/TR/CSS21/grammar.html
// https://github.com/visionmedia/css-parse/pull/49#issuecomment-30088027
var COMMENT_REGEX = /\/\*[^*]*\*+([^/*][^*]*\*+)*\//g;
var NEWLINE_REGEX = /\n/g;
var WHITESPACE_REGEX = /^\s*/;

// declaration
var PROPERTY_REGEX = /^(\*?[-#/*\\\w]+(\[[0-9a-z_-]+\])?)\s*/;
var COLON_REGEX = /^:\s*/;
var VALUE_REGEX = /^((?:'(?:\\'|.)*?'|"(?:\\"|.)*?"|\([^)]*?\)|[^};])+)/;
var SEMICOLON_REGEX = /^[;\s]*/;

// https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/String/Trim#Polyfill
var TRIM_REGEX = /^\s+|\s+$/g;

// strings
var NEWLINE = '\n';
var FORWARD_SLASH = '/';
var ASTERISK = '*';
var EMPTY_STRING = '';

// types
var TYPE_COMMENT = 'comment';
var TYPE_DECLARATION = 'declaration';

/**
 * @param {String} style
 * @param {Object} [options]
 * @return {Object[]}
 * @throws {TypeError}
 * @throws {Error}
 */
module.exports = function (style, options) {
  if (typeof style !== 'string') {
    throw new TypeError('First argument must be a string');
  }
  if (!style) return [];
  options = options || {};

  /**
   * Positional.
   */
  var lineno = 1;
  var column = 1;

  /**
   * Update lineno and column based on `str`.
   *
   * @param {String} str
   */
  function updatePosition(str) {
    var lines = str.match(NEWLINE_REGEX);
    if (lines) lineno += lines.length;
    var i = str.lastIndexOf(NEWLINE);
    column = ~i ? str.length - i : column + str.length;
  }

  /**
   * Mark position and patch `node.position`.
   *
   * @return {Function}
   */
  function position() {
    var start = {
      line: lineno,
      column: column
    };
    return function (node) {
      node.position = new Position(start);
      whitespace();
      return node;
    };
  }

  /**
   * Store position information for a node.
   *
   * @constructor
   * @property {Object} start
   * @property {Object} end
   * @property {undefined|String} source
   */
  function Position(start) {
    this.start = start;
    this.end = {
      line: lineno,
      column: column
    };
    this.source = options.source;
  }

  /**
   * Non-enumerable source string.
   */
  Position.prototype.content = style;
  var errorsList = [];

  /**
   * Error `msg`.
   *
   * @param {String} msg
   * @throws {Error}
   */
  function error(msg) {
    var err = new Error(options.source + ':' + lineno + ':' + column + ': ' + msg);
    err.reason = msg;
    err.filename = options.source;
    err.line = lineno;
    err.column = column;
    err.source = style;
    if (options.silent) {
      errorsList.push(err);
    } else {
      throw err;
    }
  }

  /**
   * Match `re` and return captures.
   *
   * @param {RegExp} re
   * @return {undefined|Array}
   */
  function match(re) {
    var m = re.exec(style);
    if (!m) return;
    var str = m[0];
    updatePosition(str);
    style = style.slice(str.length);
    return m;
  }

  /**
   * Parse whitespace.
   */
  function whitespace() {
    match(WHITESPACE_REGEX);
  }

  /**
   * Parse comments.
   *
   * @param {Object[]} [rules]
   * @return {Object[]}
   */
  function comments(rules) {
    var c;
    rules = rules || [];
    while (c = comment()) {
      if (c !== false) {
        rules.push(c);
      }
    }
    return rules;
  }

  /**
   * Parse comment.
   *
   * @return {Object}
   * @throws {Error}
   */
  function comment() {
    var pos = position();
    if (FORWARD_SLASH != style.charAt(0) || ASTERISK != style.charAt(1)) return;
    var i = 2;
    while (EMPTY_STRING != style.charAt(i) && (ASTERISK != style.charAt(i) || FORWARD_SLASH != style.charAt(i + 1))) {
      ++i;
    }
    i += 2;
    if (EMPTY_STRING === style.charAt(i - 1)) {
      return error('End of comment missing');
    }
    var str = style.slice(2, i - 2);
    column += 2;
    updatePosition(str);
    style = style.slice(i);
    column += 2;
    return pos({
      type: TYPE_COMMENT,
      comment: str
    });
  }

  /**
   * Parse declaration.
   *
   * @return {Object}
   * @throws {Error}
   */
  function declaration() {
    var pos = position();

    // prop
    var prop = match(PROPERTY_REGEX);
    if (!prop) return;
    comment();

    // :
    if (!match(COLON_REGEX)) return error("property missing ':'");

    // val
    var val = match(VALUE_REGEX);
    var ret = pos({
      type: TYPE_DECLARATION,
      property: trim(prop[0].replace(COMMENT_REGEX, EMPTY_STRING)),
      value: val ? trim(val[0].replace(COMMENT_REGEX, EMPTY_STRING)) : EMPTY_STRING
    });

    // ;
    match(SEMICOLON_REGEX);
    return ret;
  }

  /**
   * Parse declarations.
   *
   * @return {Object[]}
   */
  function declarations() {
    var decls = [];
    comments(decls);

    // declarations
    var decl;
    while (decl = declaration()) {
      if (decl !== false) {
        decls.push(decl);
        comments(decls);
      }
    }
    return decls;
  }
  whitespace();
  return declarations();
};

/**
 * Trim `str`.
 *
 * @param {String} str
 * @return {String}
 */
function trim(str) {
  return str ? str.replace(TRIM_REGEX, EMPTY_STRING) : EMPTY_STRING;
}

/***/ }),
/* 365 */
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/**
 * A package to handle conversion from FHIR SDC Questionnaire to LForms
 *
 * It provides the following functions:
 * convertQuestionnaireToLForms()
 * -- Convert FHIR SDC QuestionnaireResponse data into corresponding LForms data
 * mergeQuestionnaireResponseToLForms()  (defined in sdc-import-common.js)
 * -- Merge FHIR SDC QuestionnaireResponse data into corresponding LForms data
 */
function addSDCImportFns(ns) {
  "use strict";

  var self = ns;

  // FHIR extension urls
  self.fhirExtUrlValueSetScore = "http://hl7.org/fhir/StructureDefinition/ordinalValue";

  /**
   * Extract contained VS (if any) from the given questionnaire resource object.
   * @param questionnaire the FHIR questionnaire resource object
   * @return when there are contained value sets, returns a hash from the ValueSet url to the answers
   *         options object, which, in turn, is a hash with 4 entries:
   *         - "answers" is the list of LF answers converted from the value set.
   *         - "systems" is the list of code systems for each answer item; and
   *         returns undefined if no contained value set is present.
   * @private
   */
  self._extractContainedVS = function (questionnaire) {
    var answersVS;
    if (questionnaire.contained && questionnaire.contained.length > 0) {
      answersVS = {};
      questionnaire.contained.forEach(function (vs) {
        if (vs.resourceType === 'ValueSet') {
          var answers = self.answersFromVS(vs);
          if (answers) {
            // Support both id and url based lookup - we are only supporting our non-standard url approach
            // for backward-compatibility with previous LForms versions. For more details on FHIR contained
            // resource references, please see "http://hl7.org/fhir/references.html#canonical-fragments"
            var lfVS = {
              answers: answers
            };
            if (vs.id) {
              answersVS['#' + vs.id] = lfVS;
            }
            if (vs.url) {
              answersVS[vs.url] = lfVS;
            }
          }
        }
      });
    }
    return answersVS;
  };

  /**
   * Parse questionnaire object for skip logic information
   *
   * @param lfItem {object} - LForms item object to assign the skip logic
   * @param qItem {object} - Questionnaire item object
   * @param linkIdItemMap - Map of items from link ID to item from the imported resource.
   * @private
   */
  self._processSkipLogic = function (lfItem, qItem, linkIdItemMap) {
    if (qItem.enableWhen) {
      lfItem.skipLogic = {
        conditions: [],
        action: 'show'
      };
      for (var i = 0; i < qItem.enableWhen.length; i++) {
        if (!qItem.enableWhen[i].question) {
          throw new Error("Question with linkId '" + qItem.linkId + "' contains enableWhen but is missing the enableWhen.question field.");
        }
        if (!linkIdItemMap[qItem.enableWhen[i].question]) {
          throw new Error("Question with linkId '" + qItem.linkId + "' contains enableWhen pointing to a question with linkId '" + qItem.enableWhen[i].question + "' that does not exist.");
        }
        var dataType = self._getDataType(linkIdItemMap[qItem.enableWhen[i].question]);
        var condition = {
          source: qItem.enableWhen[i].question,
          trigger: {}
        };
        var answer = self._getFHIRValueWithPrefixKey(qItem.enableWhen[i], /^answer/);
        var opMapping = self._operatorMapping[qItem.enableWhen[i].operator];
        if (!opMapping) {
          throw new Error('Unable to map FHIR enableWhen operator: ' + qItem.enableWhen[i].operator);
        }
        if (opMapping === 'exists') {
          condition.trigger.exists = answer; // boolean value here regardless of data type
        } else if (dataType === 'CODING') {
          condition.trigger[opMapping] = self._copyTriggerCoding(answer, null, false);
        } else if (dataType === 'QTY') {
          condition.trigger[opMapping] = answer.value;
        } else {
          condition.trigger[opMapping] = answer;
        }
        lfItem.skipLogic.conditions.push(condition);
      }
      if (qItem.enableBehavior) {
        lfItem.skipLogic.logic = qItem.enableBehavior.toUpperCase();
      }
    }
  };

  /**
   * Parse questionnaire item for answers list
   *
   * @param lfItem {object} - LForms item object to assign answer list
   * @param qItem {object} - Questionnaire item object
   * @param containedVS - contained ValueSet info, see _extractContainedVS() for data format details
   * @param containedImages contained images info, see buildContainedImageMap() for details.
   * @private
   */
  self._processAnswers = function (lfItem, qItem, containedVS, containedImages) {
    if (qItem.answerOption) {
      lfItem.answers = [];
      for (var i = 0; i < qItem.answerOption.length; i++) {
        var answer = {};
        var option = qItem.answerOption[i];
        var optionKey = Object.keys(option).filter(function (key) {
          return key.indexOf('value') === 0;
        });
        if (optionKey && optionKey.length > 0) {
          // For a given answerOption, only one value[x] is expectedOnly one kind of value[x] is expected
          if (optionKey[0] === 'valueCoding') {
            if (option[optionKey[0]].code !== undefined) answer.code = option[optionKey[0]].code;
            if (option[optionKey[0]].display !== undefined) answer.text = option[optionKey[0]].display;
            // TBD- Lforms has answer code system at item level, expects all options to have one code system!
            if (option[optionKey[0]].system !== undefined) {
              answer.system = option[optionKey[0]].system;
            }
            if (option[optionKey[0]]._display) {
              answer['obj_valueCoding_display'] = option[optionKey[0]]._display;
              // rendering-xhtml extension under "valueCoding._display".
              const xhtmlFormat = LForms.Util.findObjectInArray(answer['obj_valueCoding_display'].extension, 'url', "http://hl7.org/fhir/StructureDefinition/rendering-xhtml");
              if (xhtmlFormat) {
                LForms.Util._internalUtil.setAnswerTextHTML(answer, xhtmlFormat, self._widgetOptions?.allowHTML, containedImages);
              }
              // rendering-style extension under "valueCoding._display".
              const renderingStyle = LForms.Util.findObjectInArray(answer['obj_valueCoding_display'].extension, 'url', "http://hl7.org/fhir/StructureDefinition/rendering-style");
              if (renderingStyle) {
                answer._obj_CSS = renderingStyle.valueString;
              }
            }
          } else if (optionKey[0] === 'valueString' || optionKey[0] === 'valueDate' || optionKey[0] === 'valueTime') {
            answer.text = option[optionKey[0]];
            // rendering-xhtml extension under "_valueString".
            if (optionKey[0] === 'valueString' && option._valueString) {
              answer['obj_valueString'] = option._valueString;
              const xhtmlFormat = LForms.Util.findObjectInArray(answer['obj_valueString'].extension, 'url', "http://hl7.org/fhir/StructureDefinition/rendering-xhtml");
              if (xhtmlFormat) {
                LForms.Util._internalUtil.setAnswerTextHTML(answer, xhtmlFormat, self._widgetOptions?.allowHTML, containedImages);
              }
            }
            // rendering-style extension under "_valueString", "_valueDate" or "_valueTime".
            if (option[`_${optionKey[0]}`]) {
              answer[`obj_${optionKey[0]}`] = answer[`obj_${optionKey[0]}`] || option[`_${optionKey[0]}`];
              const renderingStyle = LForms.Util.findObjectInArray(answer[`obj_${optionKey[0]}`].extension, 'url', "http://hl7.org/fhir/StructureDefinition/rendering-style");
              if (renderingStyle) {
                answer._obj_CSS = renderingStyle.valueString;
              }
            }
          } else if (optionKey[0] === 'valueInteger') {
            answer.text = parseInt(option[optionKey[0]]);
            // rendering-style extension under "_valueIngeter".
            if (option._valueInteger) {
              answer['obj_valueInteger'] = option._valueInteger;
              const renderingStyle = LForms.Util.findObjectInArray(answer['obj_valueInteger'].extension, 'url', "http://hl7.org/fhir/StructureDefinition/rendering-style");
              if (renderingStyle) {
                answer._obj_CSS = renderingStyle.valueString;
              }
            }
          } else {
            throw new Error('Unable to handle data type in answerOption: ' + optionKey[0]);
          }
          var label = LForms.Util.findObjectInArray(option.extension, 'url', self.fhirExtUrlOptionPrefix);
          if (label) {
            answer.label = label.valueString;
          }
          // Any of the URLs in self.fhirExtUrlOptionScoreLookup should work on import regardless of the version of FHIR.
          var score = option.extension?.find(ext => self.fhirExtUrlOptionScoreUrlSet.has(ext.url));
          // Look for argonaut extension.
          score = !score ? LForms.Util.findObjectInArray(option.extension, 'url', self.argonautExtUrlExtensionScore) : score;
          if (score) {
            answer.score = parseFloat(score.valueDecimal);
          }
        }
        lfItem.answers.push(answer);
      }
    } else if (qItem.answerValueSet) {
      if (containedVS) var vs = containedVS[qItem.answerValueSet];
      if (vs && vs.answers) {
        // contained ValueSet with an expansion
        lfItem.answers = vs.answers;
        // To keep answerValueSet property during export.
        lfItem._answerValueSet = qItem.answerValueSet;
      } else lfItem.answerValueSet = qItem.answerValueSet; // a URI for a ValueSet, or an ID for a contained ValueSet with no expansion
    }
  };

  /**
   * Parse questionnaire item for question cardinality and answer cardinality
   *
   * @param lfItem {object} - LForms item object to assign question cardinality
   * @param qItem {object} - Questionnaire item object
   * @private
   */
  self._processFHIRQuestionAndAnswerCardinality = function (lfItem, qItem) {
    var min = LForms.Util.findObjectInArray(qItem.extension, 'url', self.fhirExtUrlCardinalityMin);
    var max = LForms.Util.findObjectInArray(qItem.extension, 'url', self.fhirExtUrlCardinalityMax);
    var repeats = qItem.repeats;
    var required = qItem.required;
    var answerCardinality, questionCardinality;
    // CODING, repeats handled by autocompleter with multiple answers in one question
    if (lfItem.dataType === 'CODING' || qItem.answerOption && (lfItem.dataType === 'ST' || lfItem.dataType === 'INT' || lfItem.dataType === 'DT' || lfItem.dataType === 'TM')) {
      if (repeats) {
        // if it has sub items that are not 'display'
        if (qItem.item && qItem.item.length >= 0 && qItem.item.some(item => item.type !== 'display')) {
          answerCardinality = {
            max: "1"
          };
          questionCardinality = max ? {
            max: max.valueInteger.toString()
          } : {
            max: "*"
          };
        } else {
          answerCardinality = max ? {
            max: max.valueInteger.toString()
          } : {
            max: "*"
          };
        }
      } else {
        answerCardinality = {
          max: "1"
        };
      }
      if (required) {
        answerCardinality.min = min ? min.valueInteger.toString() : "1";
      } else {
        answerCardinality.min = "0";
      }
    }
    // no answerOption, question repeats
    else {
      // repeats
      if (repeats) {
        questionCardinality = max ? {
          max: max.valueInteger.toString()
        } : {
          max: "*"
        };
      } else {
        questionCardinality = {
          max: "1"
        };
      }
      // required
      if (required) {
        questionCardinality.min = min ? min.valueInteger.toString() : "1";
        answerCardinality = {
          min: "1"
        };
      } else {
        questionCardinality.min = "1";
      }
    }
    if (questionCardinality) lfItem.questionCardinality = questionCardinality;
    if (answerCardinality) lfItem.answerCardinality = answerCardinality;
  };

  /**
   * Parse questionnaire item for editable
   *
   * @param lfItem {object} - LForms item object to assign editable
   * @param qItem {object} - Questionnaire item object
   * @private
   */
  self._processEditable = function (lfItem, qItem) {
    if (qItem.readOnly) {
      lfItem.editable = '0';
    }
  };

  /**
   * Parse questionnaire item for default answer
   *
   * @param lfItem {object} - LForms item object to assign default answer
   * @param qItem {object} - Questionnaire item object
   * @private
   */
  self._processDefaultAnswer = function (lfItem, qItem) {
    var vals = [];
    // check item.answerOption.initialSelected
    if (qItem.answerOption) {
      qItem.answerOption.forEach(function (elem) {
        if (elem.initialSelected) {
          self._processDefaultAnswerValue(elem, vals, qItem.type);
        }
      });
    }

    // check item.initial
    if (qItem.initial) {
      qItem.initial.forEach(function (elem) {
        self._processDefaultAnswerValue(elem, vals, qItem.type);
      });
    }

    // set default values
    if (vals.length > 0) this._processFHIRValues(lfItem, vals, true);
  };

  /**
   *  Returns the first initial quanitity for the given Questionnaire item, or
   *  null if there isn't one.
   */
  self.getFirstInitialQuantity = function (qItem) {
    return qItem.initial && qItem.initial.length > 0 && qItem.initial[0].valueQuantity || null;
  };

  /**
   * Parse 'linkId' for the LForms questionCode of a 'display' item, which does not have a 'code'
   *
   * @param lfItem {object} - LForms item object to assign questionCode
   * @param qItem {object} - Questionnaire item object
   * @private
   */
  self._processDisplayItemCode = function (lfItem, qItem) {
    if (qItem.type === "display" && qItem.linkId) {
      var codes = qItem.linkId.split("/");
      if (codes && codes[codes.length - 1]) {
        lfItem.questionCode = codes[codes.length - 1];
      }
    }
  };

  // Quesitonnaire Response Import
  let mergeQr = self._mergeQR;

  /**
   * Get structure information of a QuestionnaireResponse instance
   * @param qr a QuestionnaireResponse instance
   * @returns {{}} a QuestionnaireResponse data structure object
   * @private
   */
  mergeQr._getQRStructure = function (qr) {
    var qrInfo = {
      qrItemsInfo: []
    };
    if (qr) {
      this._checkQRItems(qrInfo, qr);
    }
    return qrInfo;
  };

  /**
   * Get structural info of a QuestionnaireResponse by going though each level of items
   * @param parentQRItemInfo the structural info of a parent item
   * @param parentItem a parent item in a QuestionnaireResponse object
   * @private
   */
  mergeQr._checkQRItems = function (parentQRItemInfo, parentQRItem) {
    var qrItemsInfo = [];
    var repeatingItemProcessed = {};
    if (parentQRItem && parentQRItem.item) {
      for (var i = 0, iLen = parentQRItem.item.length; i < iLen; i++) {
        var item = parentQRItem.item[i];
        var linkId = item.linkId; //code is not necessary included in linkId
        // first item that has the same code, either repeating or non-repeating
        if (!repeatingItemProcessed[linkId]) {
          var repeatingInfo = this._findTotalRepeatingNum(linkId, parentQRItem);

          // create structure info for the item
          var repeatingItems = repeatingInfo.repeatingItems;
          for (var j = 0, jLen = repeatingItems.length; j < jLen; j++) {
            var qrItemInfo = {
              linkId: linkId,
              item: repeatingItems[j],
              index: j,
              total: repeatingInfo.total
            };
            // check observation instances in the sub level
            this._checkQRItems(qrItemInfo, repeatingItems[j]);
            self._checkQRItemAnswerItems(qrItemInfo, repeatingItems[j]);
            qrItemsInfo.push(qrItemInfo);
          }
          repeatingItemProcessed[linkId] = true;
        }
      }
      parentQRItemInfo.qrItemsInfo = qrItemsInfo;
    }
  };

  /**
   * Find the number of the repeating items that have the same code
   * @param linkId an item's linkId
   * @param parentQRItem a parent item in a QuestionnaireResponse object
   * @returns a structural info object for a repeating item
   * @private
   */
  mergeQr._findTotalRepeatingNum = function (linkId, parentQRItem) {
    var total = 0;
    var repeatingItems = [];
    for (var i = 0, iLen = parentQRItem.item.length; i < iLen; i++) {
      var item = parentQRItem.item[i];
      if (linkId === item.linkId) {
        repeatingItems.push(item);
        if (Array.isArray(item.answer)) {
          total += item.answer.length; // answers for repeating questions and repeating answers
        } else {
          total += 1;
        }
      }
    }
    return {
      total: total,
      repeatingItems: repeatingItems
    };
  };

  /**
   * Add repeating items into LForms definition data object
   * @param parentItem a parent item
   * @param linkId linkId of a repeating item
   * @param total total number of the repeating item with the same code
   * @private
   */
  mergeQr._addRepeatingItems = function (parentItem, linkId, total) {
    // find the first (and the only one) item
    var item = null;
    if (parentItem.items) {
      for (var i = 0, iLen = parentItem.items.length; i < iLen; i++) {
        if (linkId === parentItem.items[i].linkId) {
          item = parentItem.items[i];
          break;
        }
      }
      // insert new items
      if (item) {
        while (total > 1) {
          var newItem = LForms.Util.deepCopy(item);
          parentItem.items.splice(i, 0, newItem);
          total -= 1;
        }
      }
    }
  };

  /**
   * Find a matching repeating item by item code and the index in the repeating item array
   * @param parentItem a parent item
   * @param linkId linkId of a repeating (or non-repeating) item
   * @param index index of the repeating item
   * @returns {{}} a matching item
   * @private
   */
  mergeQr._findTheMatchingItemByLinkIdAndIndex = function (parentItem, linkId, index) {
    var item = null;
    var idx = 0;
    if (parentItem.items) {
      for (var i = 0, iLen = parentItem.items.length; i < iLen; i++) {
        if (linkId === parentItem.items[i].linkId) {
          if (idx === index) {
            item = parentItem.items[i];
            break;
          } else {
            idx += 1;
          }
        }
      }
    }
    return item;
  };

  /**
   * Find a matching repeating item by item code alone
   * When used on the LForms definition data object, there is no repeating items yet.
   * @param parentItem a parent item
   * @param linkId linkId of an item
   * @returns {{}} a matching item
   * @private
   */
  mergeQr._findTheMatchingItemByLinkId = function (parentItem, linkId) {
    var item = null;
    if (parentItem.items) {
      for (var i = 0, iLen = parentItem.items.length; i < iLen; i++) {
        if (linkId === parentItem.items[i].linkId) {
          item = parentItem.items[i];
          break;
        }
      }
    }
    return item;
  };
}
/* harmony default export */ __webpack_exports__["default"] = (addSDCImportFns);

/***/ }),
/* 366 */
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/**
 * Additional functions to convert LForms to FHIR R5 Questionnaire/QuestionnaireResponse
 */
function addR5ExportFns(ns) {
  "use strict";

  const _isAnswerOptionType = {
    'CODING': true,
    'ST': true,
    'INT': true,
    'DT': true,
    'TM': true
  };
  var self = ns;
  self.stdQProfile = 'http://hl7.org/fhir/5.0/StructureDefinition/Questionnaire';
  self.stdQRProfile = 'http://hl7.org/fhir/5.0/StructureDefinition/QuestionnaireResponse';

  /**
   * Convert LForms data type to FHIR SDC data type
   * @param item an item in the LForms form object
   * @returns {string}
   * @private
   */
  self._getFhirDataType = function (item) {
    var dataType = this._getAssumedDataTypeForExport(item);
    var type = this._lformsTypesToFHIRTypes[dataType];
    // default is string
    if (!type) {
      type = 'string';
    }
    return type;
  };

  /**
   * Process answerConstraint
   * @param targetItem an item in FHIR SDC Questionnaire object
   * @param item an item in LForms form object
   * @private
   */
  self._handleAnswerConstraint = function (targetItem, item) {
    if (item.answerConstraint) {
      targetItem.answerConstraint = item.answerConstraint;
    }
  };

  /**
   * Process default values
   * @param targetItem an item in FHIR SDC Questionnaire object
   * @param item an item in LForms form object
   * @private
   */
  self._handleInitialValues = function (targetItem, item) {
    if (item.defaultAnswer === null || item.defaultAnswer === undefined || item.defaultAnswer === '') {
      return;
    }
    var dataType = this._getAssumedDataTypeForExport(item);

    // item.defaultAnswer could be an array of multiple default values or a single value
    var defaultAnswers = this._answerRepeats(item) && Array.isArray(item.defaultAnswer) ? item.defaultAnswer : [item.defaultAnswer];
    var valueKey = this._getValueKeyByDataType("value", item);
    var answer = null;
    let initialValues = [];

    // go through each default value and handle it based on the data type.
    for (var i = 0, iLen = defaultAnswers.length; i < iLen; i++) {
      let defaultAnswer = defaultAnswers[i];

      // for Coding, the default answer is partially handled in _handleAnswers(), where
      // initialSelected is set on the answer items.
      // Only the not-on-list values (string or Coding) in item.defaultAnswer is processed here
      if (dataType === "CODING") {
        // go through each default value and to see if it is one of answers in the answers list
        let onList = false;
        if (item.answers) {
          for (var j = 0, jLen = item.answers.length; j < jLen; j++) {
            if (LForms.Util.areTwoAnswersSame(defaultAnswer, item.answers[j], item)) {
              onList = true;
              break;
            }
          }
        }
        if (!onList) {
          // valueString, free text
          if (typeof defaultAnswer === "string") {
            initialValues.push({
              "valueString": defaultAnswer
            });
          }
          // valueCoding, off list coding // TODO: not fully supported yet
          else if (typeof defaultAnswer === "object") {
            let valCoding = LForms.Util.deepCopy(defaultAnswer);
            if (valCoding.text) {
              valCoding.display = valCoding.text;
              delete valCoding.text;
            }
            if (valCoding.system) {
              valCoding.system = LForms.Util.getCodeSystem(valCoding.system);
            }
            initialValues.push(valCoding);
          }
        }
      }
      // for Quantity,
      else if (dataType === 'QTY') {
        // SimpleQuantity (no comparators)
        answer = {};
        answer[valueKey] = this._makeQuantity(defaultAnswer, item.units);
        initialValues.push(answer);
      }
      // answerOption is date, time, integer or string
      else if (item.answers && (dataType === 'ST' || dataType === 'INT' || dataType === 'DT' || dataType === 'TM')) {
        if (typeof defaultAnswer === "string") {
          initialValues.push({
            "valueString": defaultAnswer
          });
        } else {
          initialValues.push({
            [valueKey]: defaultAnswer.text
          });
        }
      }
      // for boolean, decimal, integer, date, dateTime, instant, time, string, uri
      else if (dataType === "INT" || dataType === "REAL" || dataType === "BL" || dataType === "TM" || dataType === "ST" || dataType === "TX" || dataType === "URL") {
        answer = {};
        answer[valueKey] = defaultAnswer;
        initialValues.push(answer);
      } else if (dataType === "DT" || dataType === "DTM") {
        // transform to FHIR date/datetime format.
        var dateValue = LForms.Util.stringToDate(defaultAnswer);
        if (dateValue) {
          dateValue = dataType === "DTM" ? LForms.Util.dateToDTMString(dateValue) : LForms.Util.dateToDTStringISO(dateValue);
          initialValues.push({
            [valueKey]: dateValue
          });
        } else {
          // LForms.Util.stringToDate returns null on invalid string
          // TODO: should save the errors or emitting events.
          console.error(defaultAnswer + ': Invalid date/datetime string as defaultAnswer for ' + item.questionCode);
        }
      }
      // no support for reference
    }
    if (initialValues.length > 0) {
      targetItem.initial = initialValues;
    }
  };

  /**
   * Process item.disabledDisplay
   * @param targetItem an item in FHIR SDC Questionnaire object
   * @param item an item in LForms form object
   */
  self._handleDisabledDisplay = function (targetItem, item) {
    if (item.disabledDisplay) {
      targetItem.disabledDisplay = item.disabledDisplay;
    }
  };

  /**
  * Converting the given item's value to FHIR QuestionaireResponse.answer (an array).
  * This is almost straightly refactored out of the original function self._handleAnswerValues.
  * This function only looks at the item value itself and not its sub-items, if any.
  * Here are the details for a single value's conversion (to an element in the returned answer array)
  * - For item data type quantity (QTY), a valueQuantity answer element will be created IF
  *   either (or both) item value or item unit is available.
  * - For item data types boolean, decimal, integer, date, dateTime, instant, time, string, attachment, and url,
  *   it will be converted to a FHIR value{TYPE} entry if the value is not null, not undefined, and not
  *   an empty string.
  * - For CODING, a valueCoding entry is created IF at least one of the item value's code, text, or system
  *   is available
  * - No answer entry will be created in all other cases, e.g., for types reference, title, section, etc.
  * @param item the item whose value is to be converted
  * @return the converted FHIR QuestionnaireResponse answer (an array), or null if the value is not converted -
  *         see the function description above for more details.
  * @private
  */
  self._lfItemValueToFhirAnswer = function (item) {
    // item could have an empty value if its sub-item has a value
    if (item.value === undefined || item.value === null || item.value === '') return null;
    var dataType = this._getAssumedDataTypeForExport(item);
    var values = this._answerRepeats(item) ? item.value : [item.value];
    var answers = [];
    for (var i = 0; i < values.length; ++i) {
      var itemValue = values[i];
      if (itemValue !== undefined && itemValue !== null && itemValue !== '') {
        var answer = null;
        var ext = [];
        if (itemValue.score !== null && itemValue.score !== undefined) {
          ext.push({
            url: this.fhirExtUrlOptionScore,
            valueDecimal: itemValue.score
          });
        }
        // with an answer list
        if (item.answers || dataType === 'CODING') {
          if (_isAnswerOptionType[dataType]) {
            // for optionsOrString, the value could be string if it is a user typed, not-on-list value
            if (item.answerConstraint === 'optionsOrString' && typeof itemValue === 'string') {
              answer = {
                "valueString": itemValue
              };
              if (ext.length > 0) {
                answer['_valueString'] = {
                  extension: ext
                };
              }
            }
            // optionsOnly
            else if (!LForms.jQuery.isEmptyObject(itemValue)) {
              // for Coding
              if (dataType === 'CODING') {
                var answerCoding = this._setIfHasValue(null, 'system', LForms.Util.getCodeSystem(itemValue.system));
                answerCoding = this._setIfHasValue(answerCoding, 'code', itemValue.code);
                answerCoding = this._setIfHasValue(answerCoding, 'display', itemValue.text);
                if (answerCoding && ext.length > 0) {
                  answerCoding.extension = ext;
                }
                answer = this._setIfHasValue(null, 'valueCoding', answerCoding);
              }
              // for INT, ST, DT, TM
              else {
                var valueKey = this._getValueKeyByDataType("value", item);
                answer = {
                  [valueKey]: itemValue.text
                };
                if (ext.length > 0) {
                  answer['_' + valueKey] = {
                    extension: ext
                  };
                }
              }
            }
          }
        }
        // without an answer list
        // for Quantity
        else if (dataType === "QTY") {
          // SimpleQuantity (no comparators)
          // [{
          //   // from Element: extension
          //   "value" : <decimal>, // Numerical value (with implicit precision)
          //   "comparator" : "<code>", // < | <= | >= | > - how to understand the value
          //   "unit" : "<string>", // Unit representation
          //   "system" : "<uri>", // Code System that defines coded unit form
          //   "code" : "<code>" // Coded form of the unit
          // }]
          var answerQuantity = this._makeValueQuantity(itemValue, item.unit);
          if (answerQuantity && ext.length > 0) {
            answerQuantity.extension = ext;
          }
          answer = this._setIfHasValue(null, 'valueQuantity', answerQuantity);
        }
        // for boolean, decimal, integer, date, dateTime, instant, time, string, uri, attachment, coding
        else if (this._lformsTypesToFHIRFields[dataType]) {
          var valueKey = this._getValueKeyByDataType("value", item);
          answer = {
            [valueKey]: itemValue
          };
          if (ext.length > 0) {
            answer['_' + valueKey] = {
              extension: ext
            };
          }
        }
      }
      if (answer !== null) {
        answers.push(answer);
      }
    }
    return answers.length === 0 ? null : answers;
  };
}
/* harmony default export */ __webpack_exports__["default"] = (addR5ExportFns);

/***/ }),
/* 367 */
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _obs_prepop_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(368);


/**
 *  Defines SDC functions (used by both import and export, or for other
 *  SDC-related purposes) that are the same across the different FHIR versions.
 *  The function takes SDC namespace object defined in the sdc export code,
 *  and adds additional functions to it.
 */
function addCommonSDCFns(ns) {
  "use strict";

  var self = ns;
  self.requestLinkedObs = _obs_prepop_mjs__WEBPACK_IMPORTED_MODULE_0__.requestLinkedObs;

  // A mapping of data types of items from LHC-Forms to FHIR Questionnaire
  self._lformsTypesToFHIRTypes = {
    "SECTION": 'group',
    "TITLE": 'display',
    "ST": 'string',
    "BL": 'boolean',
    "REAL": 'decimal',
    "INT": 'integer',
    "DT": 'date',
    "DTM": 'dateTime',
    "TM": 'time',
    "TX": 'text',
    "URL": 'url',
    //"CNE": 'choice',  // deprecated
    //"CWE": 'open-choice', // deprecated
    "CODING": "coding",
    "QTY": 'quantity',
    "attachment": 'attachment'
  };

  // A mapping from LHC-Forms data types to the partial field names of the value fields
  // and initial value fields in FHIR Questionnaire
  self._lformsTypesToFHIRFields = {
    "attachment": "Attachment",
    "INT": 'Integer',
    "REAL": 'Decimal',
    "DT": 'Date',
    "DTM": 'DateTime',
    "TM": 'Time',
    "ST": 'String',
    "TX": 'String',
    "BL": 'Boolean',
    "URL": 'Url',
    //"CNE": 'Coding',  // deprecated
    //"CWE": 'Coding',  // deprecated
    "CODING": 'Coding',
    "QTY": 'Quantity'
  };
  self._operatorMapping = {
    'minExclusive': '>',
    'maxExclusive': '<',
    'minInclusive': '>=',
    'maxInclusive': '<=',
    'value': '=',
    'notEqual': '!=',
    '>': 'minExclusive',
    '<': 'maxExclusive',
    '>=': 'minInclusive',
    '<=': 'maxInclusive',
    '=': 'value',
    '!=': 'notEqual',
    'exists': 'exists'
  };

  /**
   * Check if a LForms item has repeating questions
   * @param item a LForms item
   * @returns {*|boolean}
   * @private
   */
  self._questionRepeats = function (item) {
    return item._questionRepeatable !== undefined ? item._questionRepeatable : item.questionCardinality && item.questionCardinality.max && (item.questionCardinality.max === "*" || parseInt(item.questionCardinality.max) > 1);
  };

  /**
   * Check if a LForms item has repeating answers
   * @param item a LForms item
   * @returns {*|boolean}
   * @private
   */
  self._answerRepeats = function (item) {
    return item._multipleAnswers !== undefined ? item._multipleAnswers : item.answerCardinality && item.answerCardinality.max && (item.answerCardinality.max === "*" || parseInt(item.answerCardinality.max) > 1);
  };

  /**
   * Do a shallow copy of specified fields from source to target.
   *
   * @param source - Source object
   * @param target - Target object
   * @param fieldList - Array of fields to copy from the source. If the field is
   * not found in the source, it is ignored.
   */
  self.copyFields = function (source, target, fieldList) {
    if (source && target && fieldList && fieldList.length > 0) {
      fieldList.forEach(function (field) {
        if (source.hasOwnProperty(field)) {
          target[field] = source[field];
        }
      });
    }
  };

  // Store the UCUM code system URI
  self.UCUM_URI = 'http://unitsofmeasure.org';

  /**
   * Set the given key/value to the object if the value is not undefined, not null, and not an empty string.
   * @param obj the object to set the key/value on. It can be null/undefined, and if so, a new object will
   *        be created and returned (only if the value is valid).
   * @param key the key for the given value to be set to the given object, required.
   * @param value the value to be set to the given object using the given key.
   * @return if the input object is not null/undefined, it will be returned;
   *         if the input object is null/undefined:
   *         - return the given object as is if the value is invalid, or
   *         - a newly created object with the given key/value set.
   * @private
   */
  self._setIfHasValue = function (obj, key, value) {
    if (value !== undefined && value !== null && value !== '') {
      if (!obj) {
        obj = {};
      }
      obj[key] = value;
    }
    return obj;
  };

  /**
   * Copy between lforms trigger value coding and FHIR enableWhen valueCoding. It only copies 3 fields:
   * code, system, and display/text (called "text" in lforms, "display" in FHIR)
   * @param srcCoding the coding object to copy from
   * @param dstCoding the coding object to copy to, may be null/undefined, and if null/undefined, a new object
   *        will be created but only if the srcCoding has at least one of code, system, display/text
   * @param lforms2Fhir The direction of copying, can be true or false. The direction matters because in lforms,
   *        the text/display field is called "text", while in FHIR, it's called "display"
   * @return the resulting dstCoding object.
   * @private
   */
  self._copyTriggerCoding = function (srcCoding, dstCoding, lforms2Fhir) {
    let srcTextField = lforms2Fhir ? 'text' : 'display';
    let dstTextField = lforms2Fhir ? 'display' : 'text';
    dstCoding = self._setIfHasValue(dstCoding, 'code', srcCoding.code);
    dstCoding = self._setIfHasValue(dstCoding, 'system', srcCoding.system);
    dstCoding = self._setIfHasValue(dstCoding, dstTextField, srcCoding[srcTextField]);
    return dstCoding;
  };

  /**
   *  Returns true if the given item (or LFormsData) has an expression
   *  which needs to be re-evaluated when the user changes their response.
   * @param itemOrLFData the item or LFormsData to be checked.  It is assumed
   *  that the relevant extensions will be in an _fhirExt hash where
   *  the key is the URI of the extension and the values are arrays of the FHIR
   *  extension structure.
   */
  self.hasResponsiveExpression = function (itemOrLFData) {
    var ext = itemOrLFData._fhirExt;
    return ext ? !!(ext[self.fhirExtCalculatedExp] || ext[self.fhirExtAnswerExp] || ext[self.fhirExtEnableWhenExp]) : false;
  };

  /**
   *  Returns true if the given item has an expression
   *  which sets the list.
   * @param item the item to be checked.  It is assumed
   *  that the relevant extensions will be in an _fhirExt hash where
   *  the key is the URI of the extension and the values are arrays of the FHIR
   *  extension structure.
   */
  self.hasListExpression = function (item) {
    var ext = item._fhirExt;
    // This should one day include a check for cqf-expression, when we add
    // support for it
    return ext ? !!ext[self.fhirExtAnswerExp] : false;
  };

  /**
   *  Returns true if the given item (or LFormsData) has an expression
   *  which needs to be evaluated only once, when form is first rendered.
   * @param itemOrLFData the item or LFormsData to be checked.  It is assumed
   *  that the relevant extensions will be in an _fhirExt hash where
   *  the key is the URI of the extension and the values are arrays of the FHIR
   *  extension structure.
   */
  self.hasInitialExpression = function (itemOrLFData) {
    return !!(itemOrLFData._fhirExt && itemOrLFData._fhirExt[self.fhirExtInitialExp]);
  };

  /**
   *  Builds a map from extension URIs to arrays of the FHIR extension
   *  structures, and stores it on the item.  Also builds an array of all
   *  Expression extensions.
   *
   * @param itemOrLFData a form item or an LFormsData which possibly contain
   *  FHIR extensions (in an "extension" property).
   */
  self.buildExtensionMap = function (itemOrLFData) {
    // Initialize a map for testing whether an extension is an Expression extension.
    // The keys are the URIs, and the values are see to true.
    if (!self.isExpressionExtension) {
      self.isExpressionExtension = [self.fhirExtCalculatedExp, self.fhirExtInitialExp, self.fhirExtAnswerExp, self.fhirExtVariable, self.fhirExtEnableWhenExp].reduce((x, k) => {
        x[k] = true;
        return x;
      }, {});
    }
    if (itemOrLFData.extension) {
      var m = {};
      var exprExtensions = [];
      for (let ext of itemOrLFData.extension) {
        var extArray = m[ext.url];
        if (!extArray) extArray = m[ext.url] = [];
        extArray.push(ext);
        if (self.isExpressionExtension[ext.url]) exprExtensions.push(ext);
      }
      itemOrLFData._fhirExt = m;
      if (exprExtensions.length) itemOrLFData._exprExtensions = exprExtensions;
    }
  };

  /**
   * Process image data from the "contained" in FHIR questionnaire
   * @param contained - the 'contained' property of an LForms or Questionnaire object to assign the extracted fields
   * @return images - a hash map where the keys are the id of image binary resources,
   *                  and the values are the image data.
   */
  self.buildContainedImageMap = function (contained) {
    let images = {},
      hasImage;
    if (contained && Array.isArray(contained)) {
      const validImageMimeTypes = ["image/bmp", "image/jpeg", "image/x-png", "image/png", "image/gif"];
      contained.forEach(resource => {
        if (resource.resourceType === "Binary" && resource.id && validImageMimeTypes.includes(resource.contentType)) {
          images[resource.id] = "data:" + resource.contentType + ";base64," + resource.data;
          hasImage = true;
        }
      });
    }
    return hasImage ? images : null;
  };

  /**
   *  Requests launchContext resources.  Assumes LForms.Util.setFHIRContext() has
   *  been called.
   * @param lfData a LFormsData object for the form.
   * @return an array of Promises which resolve when the attempt to load the
   *  resources has completed (succesful or not, they resolve without being
   *  rejected).
   */
  self.loadLaunchContext = function (lfData) {
    // launchContext
    var contextItems = LForms.Util.findObjectInArray(lfData.extension, 'url', self.fhirExtLaunchContext, 0, true);
    // Define a list of known, supported context variables, which we can get from the FHIR server,
    // and they resources they are allowed to take.
    const contextsFromServer = {
      patient: {
        Patient: 1
      },
      encounter: {
        Encounter: 1
      },
      user: {
        Patient: 1,
        Practitioner: 1,
        PractitionerRole: 1,
        RelatedPerson: 1
      }
    };
    const pendingPromises = [];

    /**
     *  Checks to make sure that the type of the resource is what it should be
     *  per FHIR's requirements, and if it is okay, assigns the resource to
     *  the Questionnaires' variables map.
     * @param name the name of the variable
     * @param typeList the list of types for the name as specified in the
     *  launchContext extension.
     * @param resource the resource that was obtained as the value of the variable.
     */
    function addIfValid(name, typeList, resource) {
      let resType = resource.resourceType;
      // Validate the "type"
      let permittedTypes = contextsFromServer[name];
      if (permittedTypes && !permittedTypes[resType]) {
        console.warn("a launch context resource of type " + restype + " was found for name " + name + ", but the supported types for name " + name + " are: " + Object.keys(permittedTypes).join(", "));
      } else if (typeList.indexOf(resType) == -1) {
        console.warn("Could not retrieve a resource of the requested" + " types for launch context name " + name);
      } else {
        lfData._fhirVariables[name] = resource;
      }
    }
    for (let i = 0, len = contextItems.length; i < len; ++i) {
      let contextItemExt = contextItems[i].extension;
      let name = null,
        typeList = [];
      for (var j = 0, jLen = contextItemExt.length; j < jLen; ++j) {
        var fieldExt = contextItemExt[j];
        if (!name && fieldExt.url === 'name') {
          if (fieldExt.valueId) {
            // Handle a change in the specification
            console.log("Warning:  The type of the launchContext 'name' field should be 'Coding', not 'id'.");
            name = fieldExt.valueId;
          } else name = fieldExt.valueCoding?.code;
          lfData._checkFHIRVarName(name); // might throw if the name is not valid as a variable name
        } else if (fieldExt.url === 'type') {
          // there can be more than one
          typeList.push(fieldExt.valueCode);
        }
      }
      if (name && typeList.length) {
        pendingPromises.push(new Promise(function (resolve, reject) {
          let fromMap = LForms.fhirContext.vars?.[name];
          let contextResource = LForms.fhirContext.client?.[name];
          if (!fromMap && !contextResource.id) {
            console.warn('A launch context resource of name ' + name + ' was requested by the form, but none was available');
            // The loading of this resource should not be critical for the
            // Questionnaire, because it is just for prepopulation.  Don't
            // reject the promise.
            resolve();
          } else {
            if (fromMap) {
              addIfValid(name, typeList, fromMap);
              resolve();
            } else {
              contextResource.read().then(function (resource) {
                if (resource) {
                  addIfValid(name, typeList, resource);
                }
                resolve();
              }, function fail(reason) {
                console.warn('A launch context of name ' + name + ' was requested, ' + 'but could not be read.');
                console.error(reason);
                resolve(); // per above, we are not rejecting the promise
              });
            }
          }
        }));
      }
    }
    return pendingPromises;
  };
}
/* harmony default export */ __webpack_exports__["default"] = (addCommonSDCFns);

/***/ }),
/* 368 */
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   requestLinkedObs: function() { return /* binding */ requestLinkedObs; }
/* harmony export */ });
// A module for Observation-based pre-population.

/**
 *  Starts the (likely asynchronous) requests to retrieve linked Observation
 *  resources for pre-population.  When the resources have been retrieved,
 *  prepoluation will be performed.
 * @param lfData the LFormsData object for the form being prepopulated.
 * @return a promise resolving after the resources have been retrieved and
 *  any prepopulation has been performed.
 */
function requestLinkedObs(lfData) {
  if (LForms.fhirContext?.client && lfData._fhir) {
    // We will need to know what version of FHIR the server is using.  Make
    // sure that is available before continuing.
    if (!LForms._serverFHIRReleaseID) {
      // Go fetch the server's FHIR version first before continuing
      return new Promise(function (resolve, reject) {
        LForms.Util.getServerFHIRReleaseID(function (relID) {
          if (!relID) reject("Unable to obtain the server's FHIR version");else resolve(requestLinkedObs(lfData));
        });
      });
    } else {
      var pendingPromises = [];
      LForms.Util.validateFHIRVersion(LForms._serverFHIRReleaseID);
      var serverFHIR = LForms.FHIR[LForms._serverFHIRReleaseID];
      let obsLinkURI = lfData._fhir.SDC.fhirExtObsLinkPeriod;
      for (var i = 0, len = lfData.itemList.length; i < len; ++i) {
        let item = lfData.itemList[i];
        const obsExt = item._fhirExt && item._fhirExt[obsLinkURI];
        if (obsExt) {
          // an array of at least 1 if present
          var duration = obsExt[0].valueDuration; // optional
          var fhirClient = LForms.fhirContext.client;

          // Get a comma separated list of codes
          const codeQuery = item.codeList.map(code => {
            const codeSystem = code.system === 'LOINC' ? serverFHIR.LOINC_URI : code.system;
            return [codeSystem, code.code].join('|');
          }).join(',');
          const queryParams = {
            code: codeQuery,
            _sort: '-date',
            status: 'final,amended,corrected',
            _count: 5 // only need one, but we need to filter out focus=true below
          };
          // Temporarily disabling the addition of the focus search
          // parameter, because of support issues.  Instead, for now, we
          // will check the focus parameter when the Observation is
          // returned.  Later, we might query the server to find out whether
          // :missing is supported.
          //if (LForms._serverFHIRReleaseID != 'STU3') // STU3 does not know about "focus"
          //  queryParams.focus = {$missing: true}; // TBD -- sometimes :missing is not supported

          // Constrain the date range
          if (duration && duration.value && duration.code) {
            // Convert value to milliseconds
            var result = LForms.ucumPkg.UcumLhcUtils.getInstance().convertUnitTo(duration.code, duration.value, 'ms');
            if (result.status === 'succeeded') {
              var date = new Date(new Date() - result.toVal);
              queryParams.date = 'gt' + date.toISOString();
            }
          }
          pendingPromises.push(fhirClient.patient.request(lfData._buildURL(['Observation'], queryParams)).then(function (successData) {
            var bundle = successData;
            if (bundle.entry) {
              var foundObs;
              for (var j = 0, jLen = bundle.entry.length; j < jLen && !foundObs; ++j) {
                var obs = bundle.entry[j].resource;
                if (!obs.focus) {
                  // in case we couldn't use focus:missing above
                  serverFHIR.SDC.importObsValue(item, obs);
                  if (item.value) {
                    // obs.value[x] could be missing
                    foundObs = true;
                    if (item.unit) lfData._setUnitDisplay(item.unit);
                  }
                }
              }
            }
            return item.questionCode; // code is not needed, but useful for debugging
          }));
        }
      }
      return Promise.all(pendingPromises);
    }
  }
}
;

/***/ }),
/* 369 */
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/**
 * Additional functions to convert FHIR R5 Questionnaire/QuestionnaireResponse to LForms
 */
function addR5ImportFns(ns) {
  "use strict";

  var self = ns;
  self.fhirExtUrlOptionScore = self.fhirExtUrlOptionScoreLookup['R5'];

  /**
   * Parse questionnaire item for data type
   *
   * @param lfItem {object} - LForms item object to assign data type
   * @param qItem {object} - Questionnaire item object
   * @private
   */
  self._processDataType = function (lfItem, qItem) {
    var type = self._getDataType(qItem);
    if (type === 'SECTION') {
      lfItem.header = true;
    }
    lfItem.dataType = type;
  };

  /**
   * Get LForms data type from questionnaire item
   *
   * @param qItem {object} - Questionnaire item object
   * @private
   */
  self._getDataType = function (qItem) {
    var type = 'string';
    switch (qItem.type) {
      case 'string':
        type = 'ST';
        break;
      case 'group':
        type = 'SECTION';
        break;
      // 'choice' is replaced by 'coding' in R5 since the Draft Ballot version, but still in R5 preview 1, 2 and 3
      // kept for backward compatibility, but issue a warning
      case "choice":
        type = 'CODING';
        console.log(`Warning: An item (linkId:${qItem.linkId}) has a type of 'choice', which is no longer a supported item type in R5.`);
        break;
      // 'open-choice' is replaced by 'coding' in R5 since the Draft Ballot version, but still in R5 preview 1, 2 and 3
      // kept for backward compatibility, but issue a warning
      case "open-choice":
        type = 'CODING';
        console.log(`Warning: An item (linkId:${qItem.linkId}) has a type of 'open-choice', which is no longer a supported item type in R5.`);
        break;
      case 'integer':
        type = 'INT';
        break;
      case 'decimal':
        type = 'REAL';
        break;
      case 'text':
        type = 'TX';
        break;
      case "boolean":
        type = 'BL';
        break;
      case "date":
        type = 'DT';
        break;
      case "dateTime":
        type = 'DTM';
        break;
      case "time":
        type = 'TM';
        break;
      case "display":
        type = 'TITLE';
        break;
      case "url":
        type = 'URL';
        break;
      case "quantity":
        type = 'QTY';
        break;
      case "attachment":
        type = 'attachment';
        break;
      // 'coding' is in R5 since the Draft Ballot version
      case "coding":
        type = 'CODING';
        break;
    }
    return type;
  };

  /**
   * Parse questionnaire item for answerConstraint
   * @param {*} lfItem LForms item
   * @param {*} qItem Questionnaire item
   */
  self._processAnswerConstraint = function (lfItem, qItem) {
    if (qItem.answerConstraint) {
      lfItem.answerConstraint = qItem.answerConstraint;
    }
  };

  /**
   * Process answer value
   * @param {*} answer an entry in item.answerOption or in item.initial
   * @param {*} vals an array that contains all default answers
   * @param {string} itemType questionnaire item's type
   */
  self._processDefaultAnswerValue = function (answer, vals, itemType) {
    let val;
    answer = LForms.Util.deepCopy(answer); // Use a clone to avoid changing the original

    switch (itemType) {
      case 'coding':
        if (answer.valueCoding) {
          val = answer.valueCoding;
          val._type = "Coding";
        } else if (answer.valueString) {
          val = answer.valueString;
        }
        break;
      case 'string':
        if (answer.valueString) {
          val = answer.valueString;
        }
        break;
      case 'integer':
        if (answer.valueInteger !== null && answer.valueInteger !== undefined) {
          val = answer.valueInteger;
        } else if (answer.valueString) {
          val = answer.valueString;
        }
        break;
      case 'date':
        if (answer.valueDate) {
          val = answer.valueDate;
        } else if (answer.valueString) {
          val = answer.valueString;
        }
        break;
      case 'time':
        if (answer.valueTime) {
          val = answer.valueTime;
        } else if (answer.valueString) {
          val = answer.valueString;
        }
        break;
      default:
        val = self._getFHIRValueWithPrefixKey(answer, /^value/);
    }
    if (val !== undefined && val !== null) vals.push(val);
  };

  /**
   * Process item.disabledDisplay
   * @param {*} lfItem LForms item
   * @param {*} qItem Questionnaire item
   */
  self._processDisabledDisplay = function (lfItem, qItem) {
    if (qItem.disabledDisplay) {
      lfItem.disabledDisplay = qItem.disabledDisplay;
    }
  };

  /**
   * Handle the item.value in QuestionnaireResponse for non-CODING typed items
   * @param {*} fhirValue a value of item in QuestionnaireResponse, without the 'valueX' key
   * @param {*} lfItem an item in lforms
   * @param {boolean} forDefault if true, the intented target of the values is the item's
   *   default value instead of the item value. The default value is false.
   * @returns the answer
   */
  self._processNonCodingAnswerValueInQR = function (fhirValue, lfItem, forDefault = false) {
    let answer;
    if (lfItem.dataType === "ST" || lfItem.dataType === "INT" || lfItem.dataType === "DT" || lfItem.dataType === "TM") {
      var itemAnswers = lfItem.answers;
      for (var j = 0, jLen = itemAnswers.length; j < jLen && !answer; ++j) {
        if (fhirValue === itemAnswers[j].text) {
          answer = itemAnswers[j];
          break;
        }
      }
      if (!answer) {
        answer = forDefault ? fhirValue : {
          "text": fhirValue,
          "_notOnList": true
        };
      }
    }
    return answer;
  };

  /**
   * Converts the given ValueSet into an array of answers that can be used with
   * a prefetch autocompleter.
   * @return the array of answers, or null if the extraction cannot be done.
   */
  self.answersFromVS = function (valueSet) {
    var vs = valueSet;
    var rtn = [];
    if (vs.expansion && vs.expansion.contains && vs.expansion.contains.length > 0) {
      vs.expansion.contains.forEach(function (vsItem) {
        var answer = {
          code: vsItem.code,
          text: vsItem.display,
          system: vsItem.system
        };
        // In R5, the "property" (ValueSet.expansion.contains.property) was
        // added so that if you do an expansion, you can request properties from
        // the CodeSystem at the same time (without having to do a CodeSytem
        // $lookup as in R4)
        const ordProp = LForms.Util.findObjectInArray(vsItem.property, 'code', 'itemWeight');
        if (ordProp) {
          answer.score = ordProp.valueDecimal;
        } else {
          // Still, someone could provide us with an R5 ValueSet.expansion that
          // put score extensions on the contained Codings
          const ordExt = LForms.Util.findObjectInArray(vsItem.extension, 'url', self.fhirExtUrlValueSetScore);
          if (ordExt) {
            answer.score = ordExt.valueDecimal;
          }
        }
        rtn.push(answer);
      });
    }
    return rtn.length > 0 ? rtn : null;
  };
}
/* harmony default export */ __webpack_exports__["default"] = (addR5ImportFns);

/***/ }),
/* 370 */
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   addCommonRuntimeFns: function() { return /* binding */ addCommonRuntimeFns; }
/* harmony export */ });
/* harmony import */ var _extensions_rendering_style__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(371);

var extProcessors = {};
extProcessors[_extensions_rendering_style__WEBPACK_IMPORTED_MODULE_0__["default"].extURL] = _extensions_rendering_style__WEBPACK_IMPORTED_MODULE_0__["default"].processExtension;
function addCommonRuntimeFns(ns) {
  var self = ns;

  /**
   *  Processes the extensions on either lfNode, or lfNode[lfFieldName], if
   *  lfFieldName is provided.  Only the extensions for which processors
   *  are written (in the "extensions" sub-directory) are considered.
   * @param lfNode the node in the LFormsData structure on which the information
   *  from the extension will be stored.
   * @param lfFieldName (optional).  Sometimes the extension information is on a
   *  sub-node, (e.g. 'obj_text') in which case this should be the field for
   *  retrieving that sub-node.
   */
  self.processExtensions = function (lfNode, lfFieldName) {
    var fieldData = lfFieldName ? lfNode[lfFieldName] : lfNode;
    if (fieldData) {
      var extensions = fieldData.extension;
      if (extensions) {
        for (var i = 0, len = extensions.length; i < len; ++i) {
          var extData = extensions[i];
          var extURL = extData.url;
          var processor = extProcessors[extURL];
          if (processor) processor(lfNode, lfFieldName, extData);
        }
      }
    }
  };
}

/***/ }),
/* 371 */
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
var extURL = 'http://hl7.org/fhir/StructureDefinition/rendering-style';

/**
 *  A generic API for processing an extension found on some node in the
 *  Questionnaire structure being imported.
 *  (The parameter list will likely get more complicated in the future.)
 * @param lfNode the node in the LFormsData structure on which the information
 *  from the extension will be stored.
 * @param fieldName the field name  on which the extension was found (e.g.
 *  'item' or 'title').  This forms part of the field name on lfNode where the
 *  data from the extension will be stored.
 * @param extNode the extension's structure with its data.
 */
function processExtension(lfNode, fieldName, extNode) {
  var css = extNode.valueString;
  if (css) lfNode['_' + fieldName + 'CSS'] = css;
}
/* harmony default export */ __webpack_exports__["default"] = ({
  extURL: extURL,
  processExtension: processExtension
});

/***/ }),
/* 372 */
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ExpressionProcessor: function() { return /* binding */ ExpressionProcessor; }
/* harmony export */ });
/* harmony import */ var fast_copy__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(242);
/* harmony import */ var deep_equal__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(243);
/* harmony import */ var deep_equal__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(deep_equal__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var string_replace_async__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(373);
// Processes FHIR Expression Extensions
// There are three types of expressions: FHIRPath, x-fhir-query (to a FHIR
// server), and CQL (but we do not yet support CQL).
// Various extensions have an Expression as a value, such as variable,
// initialExpression, calculatedExpression, and answerExpression.  When the
// Expression contains a name, that creates a variable which can be used by
// other Expressions defined either on the same item or a child item.
//
// The general processing pattern is depth-first traversal of the "tree" of the
// Questionnaire's items, and while we go through the expressions we keep track
// of whether a field has changed and whether a variable has changed.  If there
// are any changes, we traverse the tree again, but if the only things that
// changed were variables, then we only have to traverse the parts of the tree
// for which those variables are in scope.
//
// A further complication is that x-fhir-query Expressions require an
// asynchronous call.  So, after each traversal, we have to wait for those to
// complete before starting the next traversal (if one is needed).  This is also
// why the main function, runCalculations, returns a promise that resolves
// when the expression run has been completed.
//
// Also, because there is possibility of asynchronous queries, we have to handle
// the fact that runCalculations might get called again while before the first
// call has finished.

let ExpressionProcessor;



(function () {
  "use strict";

  // A class whose instances handle the running of FHIR expressions.

  /**
   *   Constructor.
   *  @param lfData an instance of LForms.LFormsData.  The _fhir attribute
   *   should be set before this is called.
   */
  ExpressionProcessor = function (lfData) {
    // A cache of x-fhir-query URIs to results
    this._queryCache = {};

    // An array of pending x-fhir-query results
    this._pendingQueries = [];

    // A hash of calculated values, where the keys are the part of item_.elememntId
    // minus the final repetition number (so it is shared by instances of
    // repeating fields).
    this._calculatedValues = {};

    // A hash of item._elementId values to "repetition key" values which can be used as
    // keys in this._calcualtedValues.
    this._repetitionKeys = {};

    // Keeps track of whether a request to run the calculations has come in
    // while we were already busy.
    this._pendingRun = false;

    // The promise returned by runCalculations, when a run is active.
    this._currentRunPromise = undefined;
    this._lfData = lfData;
    if (!lfData._fhir) throw new Error('lfData._fhir should be set');
    this._fhir = lfData._fhir;
    this._compiledExpressions = {};
  };
  ExpressionProcessor.prototype = {
    /**
     *   Runs the FHIR expressions in the form.  This the main function in this
     *   module.
     *  @param includeInitialExpr whether to include the "initialExpression"
     *   expressions (which should only be run once, after asynchronous loads
     *   from questionnaire-launchContext have been completed).
     *  @return a Promise that resolves when the expressions have been run, and
     *   there are no pending runs left to do.
     */
    runCalculations: function (includeInitialExpr) {
      // Defer running calculations while we are waiting for earlier runs to
      // finish.
      if (this._currentRunPromise)
        // then we will just return that promise
        this._pendingRun = true; // so we know to run them when we can
      else {
        this._pendingRun = false; // clear this because we are running them now
        this._runStart = new Date();
        // Create an export of Questionnaire for the %questionnaire variable in
        // FHIRPath.  We only need to do this once per form.
        var lfData = this._lfData;
        if (!lfData._fhirVariables.questionnaire) {
          lfData._fhirVariables.questionnaire = this._fhir.SDC.convertLFormsToQuestionnaire(lfData);
        }
        if (!this._linkIdToQItem) {
          this._linkIdToQItem = {};
          this._addToLinkIdToQItemMap(lfData._fhirVariables.questionnaire.item, this._linkIdToQItem);
        }
        this._regenerateQuestionnaireResp();
        const self = this;
        this._currentRunPromise = this._asyncRunCalculations(includeInitialExpr, false).then(() => {
          // At this point, every promise for the pending queries has been
          // resolved, and we are done.
          console.log("Ran expressions in " + (new Date() - self._runStart) + " ms");
          if (!self._firstExpressionRunComplete)
            // if this is the first run
            self._firstExpressionRunComplete = true;
          self._currentRunPromise = undefined;
          if (self._pendingRun) {
            return self.runCalculations(false); // will set self._currentRunPromise again
          }
        }, failureReason => {
          console.log("Run of expressions failed; reason follows");
          console.log(failureReason);
          self._currentRunPromise = undefined;
          self._pendingRun = false;
          self._pendingQueries = []; // reset
          throw failureReason;
        });
      }
      return this._currentRunPromise;
    },
    /**
     *  Waits for any pending queries.
     * @return a Promise the resolves when everything is finished, including any
     *  pending re-run request.  The returned promise will be rejected if something
     *  goes wrong.
     * @return the same map about changes as in _evaluateExpressions.
     */
    _handlePendingQueries: function () {
      const self = this;
      return Promise.allSettled(this._pendingQueries).then(function (results) {
        self._pendingQueries = []; // reset
        var varsChanged = false,
          fieldsChanged = false;
        for (var i = 0, len = results.length; (!varsChanged || !fieldsChanged) && i < len; ++i) {
          var changes = results[i].value;
          if (changes) {
            varsChanged = varsChanged || changes.variables;
            fieldsChanged = fieldsChanged || changes.fields;
          } else if (results[i].status == 'rejected') return Promise.reject(results[i].reason);
        }
        return {
          fields: fieldsChanged,
          variables: varsChanged
        };
      });
    },
    /**
     *  This is conceptually a part of runCalculations, but it is this part of
     *  it that might need to call itself if fields or variables update.
     *  The basic algorithm is a depth-first traversal of the items to run their
     *  expressions.  Some of those might be asynchronous (e.g. x-fhir-query
     *  variables), so we wait for those to complete before looking at what has
     *  changed and deciding whether to run the expressions again.
     * @param includeInitialExpr whether to include the "initialExpression"
     *  expressions (which should only be run once, after asynchronous loads
     *  from questionnaire-launchContext have been completed).
     * @param changesByVarsOnly whether to run all field expressions, or just the ones
     *  that are likely to have been affected by changes from variable expressions.
     * @return a promise that resolves when all Expressions which needed to be
     *  processed have been processed and the values have stablized.
     */
    _asyncRunCalculations: function (includeInitialExpr, changesByVarsOnly) {
      const self = this;
      const lfData = this._lfData;
      var changes = null; // data about what the calculations changed
      changes = this._evaluateExpressions(lfData, includeInitialExpr, changesByVarsOnly);
      // Wait for any asynchronous queries to complete
      return this._handlePendingQueries().then(function (queryChanges) {
        // Two types of reported changes are possible -- variables and field values
        let varsChanged = changes.variables || queryChanges.variables;
        let fieldsChanged = changes.fields || queryChanges.fields;
        if (varsChanged || fieldsChanged) {
          // Run again
          if (fieldsChanged) self._regenerateQuestionnaireResp();
          let onlyVarsChanged = !fieldsChanged;
          return self._asyncRunCalculations(includeInitialExpr, onlyVarsChanged);
        }
      });
    },
    /**
     *  Updates the value of an item's FHIR variable.  If the variable value has changed,
     *  item._varChanged will be set to true.
     * @param item the item on which the variable is defined
     * @param varName the name of the variable
     * @param newVal the new value of the variable.
     * @return whether the value changed.
     */
    _updateItemVariable: function (item, varName, newVal) {
      const itemVars = this._getItemVariables(item); // creates item._fhirVariables if necessary
      var oldVal = itemVars[varName];
      itemVars[varName] = newVal;
      if (!deep_equal__WEBPACK_IMPORTED_MODULE_1___default()(oldVal, newVal)) {
        item._varChanged = true; // flag for re-running expressions.
      }
      return item._varChanged;
    },
    /**
     * Ensures that an item's FHIR variable with the specified name exists even
     * if its value is undefined. We need to define variables to avoid errors
     * when evaluating FHIRPath expressions.
     * @param item the item on which the variable should be defined
     * @param varName the name of the variable
     */
    _ensureItemVariable: function (item, varName) {
      const itemVars = this._getItemVariables(item);
      itemVars[varName] = itemVars[varName];
    },
    /**
     *  Evaluates the expressions for a given item.
     * @param item an LFormsData or item from LFormsData.
     * @param includeInitialExpr whether or not to run expressions from
     *  initialExpression extensions (which should only be run when the form is
     *  loaded).
     * @param changesByVarsOnly whether to run all field expressions, or just the ones
     *  that are likely to have been affected by changes from variable expressions.
     * @return a map with two fields, "variables" and "fields", which will be
     *  present and set to true if the evaluation changed variables (including
     *  implicit variables created by named expressions of some other
     *  non-variable type) or field values, respectively.
     */
    _evaluateExpressions: function (item, includeInitialExpr, changesByVarsOnly) {
      var rtn = {};
      // If changesByVarsOnly, for any item that has _varChanged set, we run any field
      // expressions that are within that group (or item).
      if (changesByVarsOnly && item._varChanged) {
        item._varChanged = false; // clear flag
        changesByVarsOnly = false; // clear it, so we process this and all child items
      }
      if (!changesByVarsOnly) {
        // process this and all child items
        item._varChanged = false; // clear flag in case it was set
        var fhirExt = item._fhirExt;
        if (fhirExt) {
          var exts = item._exprExtensions;
          if (exts) {
            var fieldChanged = false;
            for (let i = 0, len = exts.length; i < len; ++i) {
              let ext = exts[i];
              if (this._evaluateExpression(item, ext, includeInitialExpr)) {
                fieldChanged = true;
              }
            }
            if (item._answerListReset) {
              item._answerListReset = false;
            }
            rtn = {
              fields: fieldChanged,
              variables: item._varChanged
            };
          }
        }
      }

      // Process child items
      if (item.items) {
        var childChanges;
        var childItems = item.items;
        for (var j = 0; j < childItems.length; ++j) {
          // childItem.length can change as we process expressions
          // Note:  We need to process all the child items; we cannot do an
          // early loop exit based on rtn.
          childChanges = this._evaluateExpressions(item.items[j], includeInitialExpr, changesByVarsOnly);
          if (childChanges.fields) {
            rtn.fields = true;
          }
          if (childChanges.variables) {
            rtn.variables = true;
          }
        }
      }
      return rtn;
    },
    /**
     * Evaluates an expression for a given item.
     * @param item an LFormsData or item from LFormsData.
     * @param ext  an FHIR extension structure.
     * @param includeInitialExpr whether or not to run expressions from
     *  initialExpression extensions (which should only be run when the form is
     *  loaded).
     * @returns true if the evaluation changed the field value, false otherwise.
     */
    _evaluateExpression: function (item, ext, includeInitialExpr) {
      let sdc = this._fhir.SDC;
      let self = this;
      let fieldChanged = false;
      // Skip initialExpressions if we are not including those.
      let isInitialExp = ext.url === sdc.fhirExtInitialExp;
      if (includeInitialExpr || !isInitialExp) {
        let isCalcExp = ext.url === sdc.fhirExtCalculatedExp;
        // We only run initialExpression or calculatedExpression
        // on one of the repeating items of the repeating group (the
        // last one, because there is a flag to mark the last one).
        if ((isCalcExp || isInitialExp) && item._questionRepeatable && !item._lastRepeatingItem) {
          return false; // skip to next expression extension for this item
        }

        // Skip calculated expressions of editable fields for which the user has
        // edited the value.
        // Compare the item.value to the last calculated value (if any).  If
        // they differ, then the user has edited the field, and in that case we
        // skip setting the value and halt further calculations for the field.
        var prevCalcVals = this._calculatedValues[this._getRepetitionKey(item)];
        let currentVals;
        if (isCalcExp && !item._userModifiedCalculatedValue && prevCalcVals) {
          // Get the current values for the item, which might be
          // repeating.
          currentVals = this._lfData.getItemValues(item);
          if (!item._answerListReset && !this._equalAnswers(prevCalcVals, currentVals)) {
            item._userModifiedCalculatedValue = true;
          }
        }
        if (!isCalcExp || !item._userModifiedCalculatedValue) {
          let varName = ext.valueExpression.name; // i.e., a variable name
          let newVal;
          if (ext.valueExpression.language === 'text/fhirpath') {
            newVal = this._evaluateFHIRPath(item, ext.valueExpression.expression);
            if (newVal instanceof Promise) {
              if (varName) {
                this._ensureItemVariable(item, varName);
              }
              this._pendingQueries.push(newVal.then(nv => {
                // Update the item with the fetched value, and
                // update the variable if there was a name defined.
                var fChanged = this._updateItemFromExp(item, ext.url, varName, nv, isCalcExp, currentVals);
                var vChanged = false;
                if (varName) {
                  vChanged = this._updateItemVariable(item, varName, nv);
                }
                if (item._answerListReset) {
                  item._answerListReset = false;
                }
                return {
                  fields: fChanged,
                  variables: vChanged
                };
              }));
            } else {
              // Update the item with the fetched value, and
              // update the variable if there was a name defined.
              var fChanged = this._updateItemFromExp(item, ext.url, varName, newVal, isCalcExp, currentVals);
              fieldChanged = fieldChanged || fChanged;
              if (varName) {
                this._updateItemVariable(item, varName, newVal);
              }
            }
          } else if (ext.valueExpression.language === 'application/x-fhir-query') {
            if (varName) {
              this._ensureItemVariable(item, varName);
            }

            // The expression might have embedded FHIRPath in the URI, inside {{...}}
            // Use "undefinedExprVal" to keep track of whether one of
            // the embedded FHIRPath expressions returns undefined (or
            // null).
            let undefinedExprVal = false;
            // Store the promise that handles the response. We
            // will have to wait for it later.
            this._pendingQueries.push((0,string_replace_async__WEBPACK_IMPORTED_MODULE_2__["default"])(ext.valueExpression.expression, /\{\{([^}]+)\}\}/g, function (match, fpExp) {
              // Replace the FHIRPath with the evaluated expressions
              return Promise.resolve(self._evaluateFHIRPath(item, fpExp)).then(r => {
                let result = r[0];
                if (result === null || result === undefined) {
                  undefinedExprVal = true; // i.e., URL likely not usable
                }
                return undefinedExprVal ? '' : '' + result;
              });
            }).then(queryURL => {
              if (!item._currentFhirQueryURLs) {
                item._currentFhirQueryURLs = {};
              }
              let oldQueryURL = item._currentFhirQueryURLs[varName];
              // If queryURL is not a new value, we don't need to do anything
              if (queryURL !== oldQueryURL) {
                item._currentFhirQueryURLs[varName] = queryURL;
                const newValPromise = undefinedExprVal ? Promise.resolve(undefined) : this._queryCache.hasOwnProperty(queryURL) ? Promise.resolve(this._queryCache[queryURL]) : this._fetch(queryURL).then(function (parsedJSON) {
                  return self._queryCache[queryURL] = parsedJSON;
                }, function fail() {
                  console.error('Unable to load FHIR data from ' + queryURL);
                });
                // Store the promise that handles the response. We
                // will have to wait for it later.
                return newValPromise.then(function (newVal) {
                  // Update the item with the fetched value, and
                  // update the variable if there was a name defined.
                  var fChanged = self._updateItemFromExp(item, ext.url, varName, newVal, isCalcExp, currentVals);
                  var vChanged = false;
                  if (varName) {
                    vChanged = self._updateItemVariable(item, varName, newVal);
                  }
                  if (item._answerListReset) {
                    item._answerListReset = false;
                  }
                  return {
                    fields: fChanged,
                    variables: vChanged
                  };
                });
              }
            }));
          }
          // else CQL (TBD)
        }
      }
      return fieldChanged;
    },
    /**
     *  Regenerates the QuestionnaireResponse resource and the map from
     *  LFormsData _elementIDs to items in the QuestionnaireResponse.
     */
    _regenerateQuestionnaireResp: function () {
      var questResp = this._fhir.SDC.convertLFormsToQuestionnaireResponse(this._lfData);
      if (!questResp) {
        throw new Error("Invalid data. Cannot generate a QuestionnaireResponse resource.");
      }
      this._lfData._fhirVariables.resource = questResp;
      this._elemIDToQRItem = this._createIDtoQRItemMap(questResp);
    },
    /**
     *  Returns the nearest ancestor of item (or item itelf) that has
     *  _fhirVariables defined.
     * @param item either an LFormsData or an item from an LFormsData.
     */
    _itemWithVars: function (item) {
      var itemWithVars = item;
      while (!itemWithVars._fhirVariables) itemWithVars = itemWithVars._parentItem; // should terminate at lfData
      return itemWithVars;
    },
    /**
     *  Gets or creates if not yet initialized, the item's _fhirVariables
     *  map (storing its variable values).  This should not be called until it is
     *  known that the item should have a _fhirVariables map.
     * @param item either an LFormsData or an item from an LFormsData.
     * @return the item's _fhirVariables map
     */
    _getItemVariables: function (item) {
      var rtn = item._fhirVariables;
      if (!rtn) {
        // Create a hash for variables that will have access to
        // variables defined higher up in the tree.
        rtn = item._fhirVariables = Object.create(this._itemWithVars(item)._fhirVariables);
      }
      return rtn;
    },
    /**
     *  Fetches an x-fhir-query URL.
     * @param queryURL the URL (possibly relative) to fetch.
     * @return a Promise that resolves to the (parsed) JSON response.
     */
    _fetch: function (queryURL) {
      var fetchPromise;
      // If the queryURL is a relative URL, then if there is a FHIR
      // context (set via LForms.Util.setFHIRContext), use that to send
      // the query; otherwise just use fetch.
      // Also, set the format to JSON.
      queryURL += (queryURL.indexOf('?') > 0 ? '&' : '?') + '_format=json';
      if (!/^https?:/.test(queryURL) && LForms.fhirContext?.client) {
        fetchPromise = LForms.fhirContext.client.request(queryURL);
      } else {
        fetchPromise = fetch(queryURL).then(function (response) {
          return response.json();
        });
      }
      return fetchPromise;
    },
    /**
     *  Updates an item's data following the run of an expression.
     * @param item either an LFormsData or an item from an LFormsData.
     * @param expURL the URL of the expression
     * @param varName variable name from the expression (if any)
     * @param newVal the new value of the variable (if any)
     * @param isCalcExp whether the expression was a calculated expression.
     *  This could be detected from expURL, but the caller already knows it.
     * @param currentVals (optional) the current values of item, if known
     * @return true if the field value changed
     */
    _updateItemFromExp(item, expURL, varName, newVal, isCalcExp, currentVals) {
      var fieldChanged = false;
      var sdc = this._fhir.SDC;
      if (isCalcExp || expURL != sdc.fhirExtVariable) {
        if (expURL == sdc.fhirExtAnswerExp) fieldChanged = this._setItemListFromFHIRPath(item, newVal);else if (expURL == sdc.fhirExtEnableWhenExp) {
          // The new value should be a boolean.  Coerce it to a boolean, and
          // report a warning if it was not a boolean.
          var actualNewVal = newVal[0];
          newVal = !!actualNewVal;
          if (newVal !== actualNewVal) {
            LForms.Util.showWarning('An expression from enableWhenExpression ' + 'did not resolve to a Boolean as required', item);
          }
          if (varName) {
            // if there is a variable name defined, a change in the value matters
            var oldVal = !!item._enableWhenExpVal; // _enableWhenExpVal could be undefined
            fieldChanged = oldVal != newVal;
          }
          item._enableWhenExpVal = newVal;
        } else
          // else initial or calculated expression
          fieldChanged = this._setItemValueFromFHIRPath(item, newVal, isCalcExp, currentVals);
      }
      return fieldChanged;
    },
    /**
     *  Evaluates the given FHIRPath expression defined in an extension on the
     *  given item.
     * @param item either an LFormsData or an item from an LFormsData.
     * @param expression the FHIRPath to evaluate with the context of item's
     *  equivalent node in the QuestionnaireResponse.
     * @returns the result of the expression.
     */
    _evaluateFHIRPath: function (item, expression) {
      var fhirPathVal;
      // Find the item-level fhirpathVars
      var itemVars = this._itemWithVars(item)._fhirVariables;
      try {
        // We need to flatten the fhirVariables chain into a simple hash of key/
        // value pairs.
        var fVars = {};
        for (var k in itemVars) fVars[k] = itemVars[k];
        let contextNode, base;
        if (item._elementId) {
          contextNode = this._elemIDToQRItem[item._elementId];
          contextNode ||= {}; // the item might not be present in the QR if there is no value
          base = 'QuestionnaireResponse.item';
          fVars['qitem'] = this._linkIdToQItem[item.linkId];
        } else {
          base = '';
          contextNode = this._lfData._fhirVariables.resource;
        }
        const terminologyServer = this._fhir.SDC._getTerminologyServer(item);
        const compiledExpressionKey = base + ';' + expression + ';' + terminologyServer;
        let compiledExpr = this._compiledExpressions[compiledExpressionKey];
        if (!compiledExpr) {
          if (base) expression = {
            base,
            expression
          };
          compiledExpr = this._compiledExpressions[compiledExpressionKey] = this._fhir.fhirpath.compile(expression, this._fhir.fhirpathModel, {
            async: true,
            ...(terminologyServer ? {
              terminologyUrl: terminologyServer
            } : {})
          });
        }
        fhirPathVal = compiledExpr(contextNode, fVars);
      } catch (e) {
        // Sometimes an expression will rely on data that hasn't been filled in yet.
        console.log(e);
      }
      return fhirPathVal;
    },
    /**
     *  Recursively adds items to a hash from the linkId of each item to the
     *  corresponding Questionnaire item.
     * @param qItems the items to be added the map
     * @param map the map to which entries will be added.
     */
    _addToLinkIdToQItemMap: function (qItems, map) {
      var qItem;
      if (qItems) {
        for (var i = 0, len = qItems.length; i < len; ++i) {
          qItem = qItems[i];
          map[qItem.linkId] = qItem;
          if (qItem.item) this._addToLinkIdToQItemMap(qItem.item, map);
        }
      }
    },
    /**
     *  Returns a hash from the LForms _elementId of each item to the
     *  corresponding QuestionnaireResponse item.
     * @param qr the QuestionnaireResponse corresponding to the current
     * LFormsData.
     */
    _createIDtoQRItemMap: function (qr) {
      var map = {};
      this._addToIDtoQRItemMap(this._lfData, qr, map);
      return map;
    },
    /**
     *  Adds to the map from LFormsData items to QuestionnaireResponse items and
     *  returns the number of items added.
     * @param lfItem an LFormsData, or an item within it.
     * @param qrItem the corresponding QuestionnaireResponse or an item within
     * it.
     * @param map the map to which entries will be added.
     * @return the number of items added to the map.
     */
    _addToIDtoQRItemMap: function (lfItem, qrItem, map) {
      var added = 0;
      if (lfItem.linkId === qrItem.linkId) {
        if (lfItem.items) {
          // lfItem.items might contain items that don't have values, but
          // qrItem.item will not, so we need to skip the blank items.
          //
          // Also, for a repeating question, there will be multiple answers on an
          // qrItem.item, but repeats of the item in lfItem.items with one answer
          // each, unless answerCardinality is '*' (list items), in which case
          // there can be multiple answers per lforms item.

          // LForms does not currently support items that contain both answers
          // and child items, but I am trying to accomodate that here for the
          // future.
          if (qrItem && qrItem.item && qrItem.item.length > 0) {
            var lfItems = lfItem.items,
              qrItems = qrItem.item;
            var numLFItems = lfItems.length;
            for (var i = 0, qrI = 0, len = qrItems.length; qrI < len && i < numLFItems; ++qrI) {
              // Answers are repeated in QR, but items are repeated in LForms
              var qrIthItem = qrItems[qrI];
              var lfIthItem = lfItems[i];
              if (!qrIthItem.answer) {
                // process item anyway to handle child items with data
                let newlyAdded = this._addToIDtoQRItemMap(lfIthItem, qrIthItem, map);
                if (newlyAdded === 0) {
                  // lfIthItem was blank, so qrIthItem must be for a following
                  // item.
                  --qrI; // so we try qrIthItem with the next lfIthItem
                } else added += newlyAdded;
                ++i;
              } else {
                // there are answers on the qrIthItem item
                var numAnswers = qrIthItem.answer ? qrIthItem.answer.length : 0;
                for (var a = 0; a < numAnswers; ++i) {
                  if (i >= numLFItems) throw new Error('Logic error in _addToIDtoQRITemMap; ran out of lfItems');
                  let lfIthItem = lfItems[i];
                  let newlyAdded = this._addToIDtoQRItemMap(lfIthItem, qrIthItem, map);
                  if (newlyAdded != 0) {
                    // lfItems[i] was not blank
                    if (Array.isArray(lfIthItem.value)) a += lfIthItem.value.length;else a += 1;
                  }
                  added += newlyAdded;
                }
              }
            }
          }
        }

        // this item has _elementId and has a value
        if (lfItem._elementId && (added || lfItem.value !== undefined && lfItem.value !== null && lfItem.value !== "")) {
          if (!qrItem) {
            // if there is data in lfItem, there should be a qrItem
            throw new Error('Logic error in _addToIDtoQRItemMap; missing qrItem');
          } else {
            map[lfItem._elementId] = qrItem;
            added += 1;
          }
        }
      }
      return added;
    },
    /**
     *  Assigns the given list result to the item.  If the list has changed, the
     *  field is cleared.
     * @param list an array of list items computed from a FHIRPath expression.
     * @return true if the list changed
     */
    _setItemListFromFHIRPath: function (item, list) {
      let currentList = item.answers;
      let hasCurrentList = !!currentList && Array.isArray(currentList);
      let listHasData = !!list && Array.isArray(list);
      let changed = hasCurrentList != listHasData || listHasData && list.length != currentList.length;
      let newList = []; // a reformatted version of "list"
      const scoreURI = this._fhir.SDC.fhirExtUrlOptionScore;
      if (listHasData) {
        // list should be an array of any item type, including Coding.
        // (In R5, FHIR will start supporting lists of types other than Coding.)
        for (let i = 0, len = list.length; i < len; ++i) {
          let entry = list[i];
          let newEntry = newList[i] = {};
          switch (item.dataType) {
            case "CODING":
              // Assume type "object" means a coding, and that otherwise what we have
              // is something useable as display text.
              if (typeof entry === 'object') {
                let code = entry.code;
                if (code !== undefined) newEntry.code = code;
                let display = entry.display;
                if (display !== undefined) newEntry.text = display;
                let system = entry.system;
                if (system !== undefined) newEntry.system = system;
                // A Coding can have the extension for scores
                let scoreExt = item._fhirExt && item._fhirExt[scoreURI];
                if (scoreExt) newEntry.score = scoreExt[0].valueDecimal;
              } else newEntry.text = '' + entry;
              if (!changed) {
                changed = !hasCurrentList || !this._lfData._objectEqual(newEntry, currentList[i]);
              }
              break;
            case "ST":
            case "DT":
            case "TM":
              if (typeof entry === 'string') {
                newEntry.text = entry;
                if (!changed) {
                  changed = !hasCurrentList || !this._lfData._objectEqual(newEntry, currentList[i]);
                }
              }
              break;
            case "INT":
              if (typeof entry === 'number' || typeof entry === 'string') {
                newEntry.text = parseInt(entry);
                if (!changed) {
                  changed = !hasCurrentList || !this._lfData._objectEqual(newEntry, currentList[i]);
                }
              }
              break;
          }
        }
      }
      if (changed) {
        // reset the answer list
        item.answers = newList;
        // reset item.value
        // 1) when there are user saved data from QuestionnaireResponse and
        //    the initial loading (and fhirpath expressions) have run once
        // 2) when there are no user saved data.
        if (this._lfData.hasSavedData && this._firstExpressionRunComplete || !this._lfData.hasSavedData) {
          // reset the previously selected answer (by user or by fhirpath expression)
          item.value = null;
          // reset the cached calculated value
          this._calculatedValues[this._getRepetitionKey(item)] = [];
          // user selected/typed value will be reset when the answer list has changed
          item._userModifiedCalculatedValue = false;
        }
        item._hasAnswerList = true;
        this._lfData._updateAutocompOptions(item, true);
        this._lfData._resetItemValueWithAnswers(item);
        item._answerListReset = true;
      }
      return changed;
    },
    /**
     *  Assigns the given FHIRPath result to the given item.
     * @param item the item from the LFormsData object that is receiving the new
     *  value.
     * @param fhirPathRes the result of a FHIRPath evaluation.
     * @param isCalcExp whether this is from a calculated expression, in which
     *  case a decision will be made whether to skip setting the value.
     * @param oldVal (optional) the item current item values, if known
     * @return true if the value changed
     */
    _setItemValueFromFHIRPath: function (item, fhirPathRes, isCalcExp, oldVal) {
      if (oldVal === undefined) oldVal = this._lfData.getItemValues(item);
      // If the FHIRPath expression resulted in an error, fhirPathRes is
      // undefined.  TBD - show an error to the user.  I think the safest thing
      // to do here is to leave the item untouched.
      var changed = false;
      if (fhirPathRes !== undefined) {
        var [newVal, messages] = this._fhir.SDC._convertFHIRValues(item, fhirPathRes);
        var nonEmptyNewVal = newVal.filter(x => !LForms.Util.isItemValueEmpty(x));
        const msgSource = 'FHIRPath value expression';
        changed = !deep_equal__WEBPACK_IMPORTED_MODULE_1___default()(oldVal, nonEmptyNewVal);
        // If this is the first run of the expressions, and there is
        // saved user data, then we check whether the calculated value matches
        // what the user entered (or erased) and if it doesn't, we halt further
        // calculations for this field and restore the saved value.
        if (changed && isCalcExp && !this._firstExpressionRunComplete && this._lfData.hasSavedData) {
          item._userModifiedCalculatedValue = true;
          changed = false;
        } else if (changed) {
          var newLastItem = this._lfData.setRepeatingItems(item, newVal, messages, msgSource);
        } else {
          // the messages might have changed
          this._lfData.setRepeatingItemMessages(item, messages, msgSource);
        }

        // Store the calculated value.
        this._calculatedValues[this._getRepetitionKey(item)] = nonEmptyNewVal;
      }
      return changed;
    },
    /**
     *  Returns the key used to store/retrieve the calculated value for a given
     *  item's repetitions.
     * @param item an instance of a repeating item.
     */
    _getRepetitionKey: function (item) {
      var rtn = this._repetitionKeys[item._elementId];
      if (!rtn && item._elementId) {
        var found = item._elementId.match(/\/\d+$/);
        if (found) {
          rtn = this._repetitionKeys[item._elementId] = item._elementId.substring(0, found.index);
        }
      }
      return rtn;
    },
    /**
     * Check if two answers or two arrays of answers have the same value,
     * ignoring any fields starting with "_"
     * @param {*} answer1 an array of answer values/objects
     * @param {*} answer2 an array of answer values/objects
     */
    _equalAnswers(answer1, answer2) {
      let ans1 = (0,fast_copy__WEBPACK_IMPORTED_MODULE_0__["default"])(answer1),
        ans2 = (0,fast_copy__WEBPACK_IMPORTED_MODULE_0__["default"])(answer2);

      // answer1 is an array
      if (Array.isArray(ans1)) {
        ans1.forEach(answer => {
          this._filterAnswerFields(answer);
        });
      }

      // answer2 is an array
      if (Array.isArray(ans2)) {
        ans2.forEach(answer => {
          this._filterAnswerFields(answer);
        });
      }
      let rtn = deep_equal__WEBPACK_IMPORTED_MODULE_1___default()(ans1, ans2);
      return rtn;
    },
    /**
     * a function to remove fields starting with "_" in an answer object
     * @param {*} answer an answer value/object
     */
    _filterAnswerFields(answer) {
      if (typeof answer === 'object' && !(answer instanceof Date)) {
        Object.keys(answer).forEach(key => {
          if (key && key[0] === "_") {
            delete answer[key];
          }
        });
      }
    }
  };
})();

/***/ }),
/* 373 */
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ replaceAsync; }
/* harmony export */ });
function replaceAsync(string, searchValue, replacer) {
  try {
    if (typeof replacer === "function") {
      // 1. Run fake pass of `replace`, collect values from `replacer` calls
      // 2. Resolve them with `Promise.all`
      // 3. Run `replace` with resolved values
      var values = [];
      String.prototype.replace.call(string, searchValue, function () {
        values.push(replacer.apply(undefined, arguments));
        return "";
      });
      return Promise.all(values).then(function (resolvedValues) {
        return String.prototype.replace.call(string, searchValue, function () {
          return resolvedValues.shift();
        });
      });
    } else {
      return Promise.resolve(String.prototype.replace.call(string, searchValue, replacer));
    }
  } catch (error) {
    return Promise.reject(error);
  }
}

/***/ })
/******/ 	]);
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			id: moduleId,
/******/ 			loaded: false,
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	!function() {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = function(module) {
/******/ 			var getter = module && module.__esModule ?
/******/ 				function() { return module['default']; } :
/******/ 				function() { return module; };
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	!function() {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = function(exports, definition) {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/global */
/******/ 	!function() {
/******/ 		__webpack_require__.g = (function() {
/******/ 			if (typeof globalThis === 'object') return globalThis;
/******/ 			try {
/******/ 				return this || new Function('return this')();
/******/ 			} catch (e) {
/******/ 				if (typeof window === 'object') return window;
/******/ 			}
/******/ 		})();
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	!function() {
/******/ 		__webpack_require__.o = function(obj, prop) { return Object.prototype.hasOwnProperty.call(obj, prop); }
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	!function() {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = function(exports) {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/node module decorator */
/******/ 	!function() {
/******/ 		__webpack_require__.nmd = function(module) {
/******/ 			module.paths = [];
/******/ 			if (!module.children) module.children = [];
/******/ 			return module;
/******/ 		};
/******/ 	}();
/******/ 	
/************************************************************************/
var __webpack_exports__ = {};
// This entry need to be wrapped in an IIFE because it need to be in strict mode.
!function() {
"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _common_fhir_common_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(1);
/* harmony import */ var _common_diagnostic_report_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(95);
/* harmony import */ var _R4R5_common_export_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(97);
/* harmony import */ var _R4R5_common_sdc_export_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(99);
/* harmony import */ var _common_sdc_export_common_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(100);
/* harmony import */ var _common_sdc_import_common_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(101);
/* harmony import */ var _R4R5_common_sdc_import_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(365);
/* harmony import */ var _sdc_export_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(366);
/* harmony import */ var _common_sdc_common_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(367);
/* harmony import */ var _sdc_import_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(369);
/* harmony import */ var _common_runtime_common_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(370);
/* harmony import */ var _expression_processor_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(372);
// Initializes the FHIR structure for R5
let fhirVersion = 'R5';
if (!LForms.FHIR) LForms.FHIR = {};

var fhir = LForms.FHIR[fhirVersion] = {
  LOINC_URI: _common_fhir_common_js__WEBPACK_IMPORTED_MODULE_0__.LOINC_URI
};
fhir.fhirpath = __webpack_require__(2);
fhir.fhirpathModel = __webpack_require__(89);

// Because we are assigning ./export.js to dr below, we need our own copy of the
// dr object.
fhir.DiagnosticReport = Object.assign({}, _common_diagnostic_report_js__WEBPACK_IMPORTED_MODULE_1__["default"]);

fhir.DiagnosticReport._commonExport = _R4R5_common_export_js__WEBPACK_IMPORTED_MODULE_2__["default"];

// need a copy of the object, to separate from R4
fhir.SDC = Object.assign({}, _R4R5_common_sdc_export_js__WEBPACK_IMPORTED_MODULE_3__["default"]);
fhir.SDC._commonExport = _R4R5_common_export_js__WEBPACK_IMPORTED_MODULE_2__["default"];

(0,_common_sdc_export_common_js__WEBPACK_IMPORTED_MODULE_4__["default"])(fhir.SDC);

(0,_common_sdc_import_common_js__WEBPACK_IMPORTED_MODULE_5__["default"])(fhir.SDC);

(0,_R4R5_common_sdc_import_js__WEBPACK_IMPORTED_MODULE_6__["default"])(fhir.SDC);

(0,_sdc_export_js__WEBPACK_IMPORTED_MODULE_7__["default"])(fhir.SDC);

(0,_common_sdc_common_js__WEBPACK_IMPORTED_MODULE_8__["default"])(fhir.SDC);

(0,_sdc_import_js__WEBPACK_IMPORTED_MODULE_9__["default"])(fhir.SDC);

(0,_common_runtime_common_js__WEBPACK_IMPORTED_MODULE_10__.addCommonRuntimeFns)(fhir.SDC);

fhir.SDC.ExpressionProcessor = _expression_processor_js__WEBPACK_IMPORTED_MODULE_11__.ExpressionProcessor;
fhir.SDC.fhirVersion = fhirVersion; // Needed by lfData for fhirpath, etc.

fhir.reservedVarNames = {};
['context', 'resource'].forEach(function (name) {
  fhir.reservedVarNames[name] = true;
});
}();
/******/ })()
;