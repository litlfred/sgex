"use strict";(self.webpackChunksgex_workbench=self.webpackChunksgex_workbench||[]).push([[9946],{18354:(e,t,o)=>{o.r(t),o.d(t,{default:()=>r});const r=new class{constructor(){this.storageKey="sgex_branch_context"}getRepositoryKey(e){var t,o;if(!e||!e.name)return null;const r=(null===(t=e.owner)||void 0===t?void 0:t.login)||(null===(o=e.full_name)||void 0===o?void 0:o.split("/")[0]);return r?"".concat(r,"/").concat(e.name):null}getSelectedBranch(e){if(!e)return null;try{const t=this.getBranchContext();return t[this.getRepositoryKey(e)]||null}catch(t){return console.warn("Failed to get branch context:",t),null}}setSelectedBranch(e,t){if(e&&t)try{const o=this.getBranchContext();o[this.getRepositoryKey(e)]=t,this.setBranchContext(o)}catch(o){console.warn("Failed to set branch context:",o)}}clearRepositoryBranch(e){if(e)try{const t=this.getBranchContext();delete t[this.getRepositoryKey(e)],this.setBranchContext(t)}catch(t){console.warn("Failed to clear repository branch context:",t)}}clearAllBranchContext(){try{sessionStorage.removeItem(this.storageKey)}catch(e){console.warn("Failed to clear branch context:",e)}}getBranchContext(){try{const e=sessionStorage.getItem(this.storageKey);return e?JSON.parse(e):{}}catch(e){return console.warn("Failed to parse branch context from storage:",e),{}}}setBranchContext(e){try{sessionStorage.setItem(this.storageKey,JSON.stringify(e))}catch(t){console.warn("Failed to save branch context to storage:",t)}}getDefaultBranchName(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:[];return e?t.some(e=>"main"===e.name)?"main":e.default_branch&&t.some(t=>t.name===e.default_branch)?e.default_branch:t.length>0?t[0].name:"main":"main"}hasBranchContext(e){return null!==this.getSelectedBranch(e)}getBranchDisplayInfo(e){const t=this.getSelectedBranch(e);if(!t)return null;const o=t===((null===e||void 0===e?void 0:e.default_branch)||"main");return{branch:t,isDefault:o,displayText:o?"".concat(t," (default)"):t}}}},29946:(e,t,o)=>{o.d(t,{A:()=>l});var r=o(89379),s=o(38659);async function a(e,t){let o=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};const{concurrency:r=5,onProgress:s=null,onItemComplete:a=null,onItemStart:n=null}=o;if(!e||0===e.length)return[];const i=new Array(e.length),c=e.length;let l=0;const h=e.map((e,t)=>({item:e,index:t})),u=Array(Math.min(r,e.length)).fill().map(()=>(async()=>{for(;h.length>0;){const{item:o,index:r}=h.shift();n&&n(o,r);try{const e=await t(o,r);i[r]=e,l++,s&&s(l,c,o,e),a&&a(o,e,null)}catch(e){i[r]={error:e,item:o},l++,s&&s(l,c,o,null),a&&a(o,null,e)}}})());return await Promise.all(u),i}const n=new class{constructor(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:30;this.cache=new Map,this.ttl=60*e*1e3}_getCacheKey(e,t){return"".concat(e,"/").concat(t)}_isValid(e){return Date.now()-e.timestamp<this.ttl}get(e,t){const o=this._getCacheKey(e,t),r=this.cache.get(o);return r?this._isValid(r)?r.compatible:(this.cache.delete(o),null):null}set(e,t,o){const r=this._getCacheKey(e,t);this.cache.set(r,{compatible:o,timestamp:Date.now()})}clear(){this.cache.clear()}cleanup(){const e=Date.now();for(const[t,o]of this.cache.entries())e-o.timestamp>=this.ttl&&this.cache.delete(t)}getStats(){return this.cleanup(),{size:this.cache.size,ttlMinutes:this.ttl/6e4,entries:Array.from(this.cache.entries()).map(e=>{let[t,o]=e;return{repository:t,compatible:o.compatible,ageMinutes:Math.round((Date.now()-o.timestamp)/6e4)}})}}};var i=o(85571);const c=new class{constructor(){this.logger=i.A.getLogger("SecureTokenStorage"),this.storageKey="sgex_secure_token",this.expirationHours=24,this.logger.debug("SecureTokenStorage instance created")}generateBrowserFingerprint(){const e=document.createElement("canvas"),t=e.getContext("2d");t.textBaseline="top",t.font="14px Arial",t.fillText("Browser fingerprint",2,2);const o=[navigator.userAgent,navigator.language,window.screen.width+"x"+window.screen.height,window.screen.colorDepth,(new Date).getTimezoneOffset(),e.toDataURL()].join("|");let r=0;for(let s=0;s<o.length;s++){r=(r<<5)-r+o.charCodeAt(s),r&=r}return Math.abs(r).toString(36)}xorCipher(e,t){let o="";for(let r=0;r<e.length;r++)o+=String.fromCharCode(e.charCodeAt(r)^t.charCodeAt(r%t.length));return o}validateTokenFormat(e){if(!e||"string"!==typeof e)return{isValid:!1,type:"invalid",reason:"Token is empty or not a string"};const t=e.trim();return t.match(/^ghp_[A-Za-z0-9]{36}$/)?{isValid:!0,type:"classic",token:t}:t.match(/^github_pat_[A-Za-z0-9]{22}_[A-Za-z0-9]{59}$/)?{isValid:!0,type:"fine-grained",token:t}:t.match(/^gho_[A-Za-z0-9]{36}$/)?{isValid:!0,type:"oauth",token:t}:t.match(/^[a-fA-F0-9]{40}$/)?{isValid:!0,type:"legacy",token:t}:{isValid:!1,type:"invalid",reason:"Token does not match expected GitHub PAT format"}}maskToken(e){if(!e||"string"!==typeof e)return"[INVALID_TOKEN]";const t=e.trim();return t.length<8?"[INVALID_TOKEN]":"".concat(t.substring(0,4)).concat("*".repeat(t.length-8)).concat(t.substring(t.length-4))}storeToken(e){try{this.logger.debug("Starting secure token storage");const t=this.validateTokenFormat(e);if(!t.isValid)return this.logger.warn("Token validation failed",{reason:t.reason,tokenMask:this.maskToken(e)}),!1;this.logger.debug("Token validation successful",{type:t.type,tokenMask:this.maskToken(e)});const o=this.generateBrowserFingerprint(),r="sgex_".concat(o,"_").concat(Date.now().toString(36)),s=this.xorCipher(t.token,r),a={token:btoa(s),key:btoa(r),type:t.type,created:Date.now(),expires:Date.now()+60*this.expirationHours*60*1e3,fingerprint:o};return sessionStorage.setItem(this.storageKey,JSON.stringify(a)),localStorage.removeItem("github_token"),sessionStorage.removeItem("github_token"),this.logger.debug("Token stored securely",{type:t.type,expires:new Date(a.expires).toISOString(),tokenMask:this.maskToken(e)}),!0}catch(t){return this.logger.error("Failed to store token securely",{error:t.message,tokenMask:this.maskToken(e)}),!1}}retrieveToken(){try{this.logger.debug("Attempting to retrieve secure token");const e=sessionStorage.getItem(this.storageKey);if(!e)return this.logger.debug("No secure token found in storage"),null;const t=JSON.parse(e);if(Date.now()>t.expires)return this.logger.warn("Stored token has expired"),this.clearToken(),null;const o=this.generateBrowserFingerprint();if(t.fingerprint!==o)return this.logger.warn("Browser fingerprint mismatch - possible security issue"),this.clearToken(),null;const r=atob(t.key),s=atob(t.token),a=this.xorCipher(s,r),n=this.validateTokenFormat(a);return n.isValid?(this.logger.debug("Token retrieved and decrypted successfully",{type:t.type,expires:new Date(t.expires).toISOString(),tokenMask:this.maskToken(a)}),{token:n.token,type:t.type,created:t.created,expires:t.expires}):(this.logger.error("Decrypted token failed validation"),this.clearToken(),null)}catch(e){return this.logger.error("Failed to retrieve secure token",{error:e.message}),this.clearToken(),null}}hasValidToken(){try{const e=sessionStorage.getItem(this.storageKey);if(!e)return!1;const t=JSON.parse(e);if(Date.now()>t.expires)return this.clearToken(),!1;const o=this.generateBrowserFingerprint();return t.fingerprint===o||(this.clearToken(),!1)}catch(e){return this.logger.error("Error checking token validity",{error:e.message}),this.clearToken(),!1}}clearToken(){this.logger.debug("Clearing secure token storage"),sessionStorage.removeItem(this.storageKey),sessionStorage.removeItem("github_token"),localStorage.removeItem("github_token")}getTokenInfo(){try{const e=sessionStorage.getItem(this.storageKey);if(!e)return null;const t=JSON.parse(e),o=t.expires-Date.now();return{type:t.type,created:new Date(t.created),expires:new Date(t.expires),timeRemaining:Math.max(0,o),isExpired:o<=0,isValid:this.hasValidToken()}}catch(e){return this.logger.error("Error getting token info",{error:e.message}),null}}migrateLegacyToken(){try{const e=sessionStorage.getItem("github_token")||localStorage.getItem("github_token");if(!e)return this.logger.debug("No legacy token found for migration"),!1;this.logger.debug("Migrating legacy token to secure storage");return this.storeToken(e)?(sessionStorage.removeItem("github_token"),localStorage.removeItem("github_token"),this.logger.debug("Legacy token migration completed successfully"),!0):(this.logger.error("Failed to migrate legacy token"),!1)}catch(e){return this.logger.error("Error during legacy token migration",{error:e.message}),!1}}};const l=new class{constructor(){this.octokit=null,this.isAuthenticated=!1,this.permissions=null,this.tokenType=null,this.logger=i.A.getLogger("GitHubService"),this.logger.debug("GitHubService instance created")}async createOctokitInstance(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:null;return new(await(0,s.sN)())(e?{auth:e}:{})}async authenticate(e){const t=Date.now();this.logger.auth("Starting authentication",{tokenProvided:!!e,tokenMask:e?c.maskToken(e):"none"});try{const o=c.validateTokenFormat(e);if(!o.isValid)return this.logger.warn("Token validation failed during authentication",{reason:o.reason,tokenMask:c.maskToken(e)}),this.isAuthenticated=!1,!1;this.octokit=await this.createOctokitInstance(o.token),this.isAuthenticated=!0,this.tokenType=o.type;const r=c.storeToken(o.token);r||this.logger.warn("Failed to store token securely, authentication will not persist");const s=Date.now()-t;return this.logger.auth("Authentication successful",{duration:s,tokenType:this.tokenType,tokenMask:c.maskToken(e),securelyStored:r}),this.logger.performance("GitHub authentication",s),!0}catch(o){const r=Date.now()-t;return this.logger.auth("Authentication failed",{error:o.message,duration:r,tokenMask:c.maskToken(e)}),console.error("Failed to authenticate with GitHub:",o),this.isAuthenticated=!1,c.clearToken(),!1}}authenticateWithOctokit(e){this.logger.auth("Starting OAuth authentication with Octokit instance");try{return this.octokit=e,this.isAuthenticated=!0,this.tokenType="oauth",this.logger.auth("OAuth authentication successful",{tokenType:this.tokenType}),!0}catch(t){return this.logger.auth("OAuth authentication failed",{error:t.message}),console.error("Failed to authenticate with Octokit instance:",t),this.isAuthenticated=!1,!1}}async initializeFromStoredToken(){this.logger.auth("Attempting to initialize from stored token");try{c.migrateLegacyToken()&&this.logger.debug("Successfully migrated legacy token to secure storage");const e=c.retrieveToken();return e?(this.octokit=await this.createOctokitInstance(e.token),this.isAuthenticated=!0,this.tokenType=e.type,this.logger.auth("Successfully initialized from stored token",{tokenType:this.tokenType,tokenMask:c.maskToken(e.token),expires:new Date(e.expires).toISOString()}),!0):(this.logger.debug("No valid stored token found"),!1)}catch(e){return this.logger.auth("Failed to initialize from stored token",{error:e.message}),this.isAuthenticated=!1,c.clearToken(),!1}}hasStoredToken(){return c.hasValidToken()}getStoredTokenInfo(){return c.getTokenInfo()}async checkTokenPermissions(){if(!this.isAuth()){const e=new Error("Not authenticated with GitHub");throw this.logger.error("Token permission check failed - not authenticated"),e}const e=Date.now();this.logger.apiCall("GET","/user",null);try{const o=await this.octokit.request("GET /user");this.logger.apiResponse("GET","/user",o.status,Date.now()-e);try{const e=Date.now();this.logger.apiCall("GET","/rate_limit",null);const t=await this.octokit.rest.rateLimit.get();this.logger.apiResponse("GET","/rate_limit",t.status,Date.now()-e),this.tokenType=t.data.resources.core?"classic":"fine-grained",this.logger.debug("Token type determined",{tokenType:this.tokenType,hasCore:!!t.data.resources.core})}catch(t){this.tokenType="unknown",this.logger.warn("Could not determine token type from rate limit",{error:t.message})}const r={type:this.tokenType,user:o.data};return this.permissions=r,this.logger.debug("Token permissions checked successfully",{tokenType:this.tokenType,username:o.data.login}),r}catch(o){const t=Date.now()-e;throw this.logger.apiError("GET","/user",o),this.logger.performance("Token permission check (failed)",t),console.error("Failed to check token permissions:",o),o}}async checkRepositoryWritePermissions(e,t){if(!this.isAuth())return this.logger.warn("Cannot check repository write permissions - not authenticated",{owner:e,repo:t}),!1;const o=Date.now();this.logger.debug("Checking write permissions for repository",{owner:e,repo:t});try{const r=(await this.getCurrentUser()).login;this.logger.apiCall("GET","/repos/".concat(e,"/").concat(t,"/collaborators/").concat(r,"/permission"),null);const{data:s}=await this.octokit.rest.repos.getCollaboratorPermissionLevel({owner:e,repo:t,username:r}),a=Date.now()-o;this.logger.apiResponse("GET","/repos/".concat(e,"/").concat(t,"/collaborators/").concat(r,"/permission"),200,a);const n=["write","maintain","admin"].includes(s.permission);return this.logger.debug("Repository write permissions checked",{owner:e,repo:t,permission:s.permission,hasWriteAccess:n,supportedLevels:["write","maintain","admin"]}),n}catch(a){var r,s;const n=Date.now()-o;return this.logger.apiError("GET","/repos/".concat(e,"/").concat(t,"/collaborators/*/permission"),a),this.logger.performance("Repository write permission check (failed)",n),console.warn("Could not check repository write permissions for ".concat(e,"/").concat(t,":"),{error:a.message,status:a.status,statusText:null===(r=a.response)||void 0===r?void 0:r.statusText,headers:null===(s=a.response)||void 0===s?void 0:s.headers}),this.logger.warn("Assuming no write access due to permission check failure",{owner:e,repo:t,error:a.message,status:a.status,userGuidance:"Check if your Personal Access Token has the required scopes: repo (classic) or Contents+Pull requests (fine-grained)"}),!1}}async checkRepositoryPermissions(e,t){return this.checkRepositoryWritePermissions(e,t)}async checkCommentPermissions(e,t){if(!this.isAuth())return this.logger.warn("Cannot check comment permissions - not authenticated",{owner:e,repo:t}),!1;const o=Date.now();this.logger.debug("Checking comment permissions for repository",{owner:e,repo:t});try{this.logger.apiCall("GET","/repos/".concat(e,"/").concat(t,"/issues"),{per_page:1}),await this.octokit.rest.issues.listForRepo({owner:e,repo:t,per_page:1,state:"all"});const r=Date.now()-o;return this.logger.apiResponse("GET","/repos/".concat(e,"/").concat(t,"/issues"),200,r),this.logger.debug("Issues endpoint accessible - comment permissions likely available",{owner:e,repo:t}),!0}catch(r){const s=Date.now()-o;return this.logger.apiError("GET","/repos/".concat(e,"/").concat(t,"/issues"),r),this.logger.performance("Comment permission check (failed)",s),403===r.status||401===r.status?(this.logger.warn("Token does not have permission to access issues/comments",{owner:e,repo:t,error:r.message,status:r.status}),!1):(this.logger.warn("Could not determine comment permissions, assuming available",{owner:e,repo:t,error:r.message}),!0)}}isAuth(){return this.isAuthenticated&&null!==this.octokit}async getCurrentUser(){if(!this.isAuth())throw new Error("Not authenticated with GitHub");try{const{data:e}=await this.octokit.rest.users.getAuthenticated();return e}catch(e){throw console.error("Failed to fetch user data:",e),e}}async getUserOrganizations(){if(!this.isAuth())throw new Error("Not authenticated with GitHub");try{const{data:e}=await this.octokit.rest.orgs.listForAuthenticatedUser();return e}catch(e){throw console.error("Failed to fetch organizations:",e),e}}async getOrganization(e){try{const t=this.octokit||await this.createOctokitInstance(),{data:o}=await t.rest.orgs.get({org:e});return o}catch(t){throw console.error("Failed to fetch organization ".concat(e,":"),t),t}}async getUser(e){try{const t=this.octokit||await this.createOctokitInstance(),{data:o}=await t.rest.users.getByUsername({username:e});return o}catch(t){throw console.error("Failed to fetch user ".concat(e,":"),t),t}}async getPublicRepositories(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"user";try{const o=this.octokit||await this.createOctokitInstance();let r=[],s=1,a=!0;for(;a;){let n;n="user"===t?await o.rest.repos.listForUser({username:e,sort:"updated",per_page:100,page:s}):await o.rest.repos.listForOrg({org:e,sort:"updated",per_page:100,page:s}),r=r.concat(n.data),a=100===n.data.length,s++}return r}catch(o){throw console.error("Failed to fetch public repositories for ".concat(e,":"),o),o}}async getWHOOrganization(){try{const e=await this.getOrganization("WorldHealthOrganization");return{id:e.id,login:e.login,display_name:e.name||"World Health Organization",description:e.description||"The World Health Organization is a specialized agency of the United Nations responsible for international public health.",avatar_url:e.avatar_url,html_url:e.html_url,type:"Organization",permissions:{can_create_repositories:!0,can_create_private_repositories:!0},plan:{name:"Organization",private_repos:"unlimited"},isWHO:!0}}catch(e){return console.warn("Could not fetch WHO organization data from API, using fallback:",e),{id:"who-organization",login:"WorldHealthOrganization",display_name:"World Health Organization",description:"The World Health Organization is a specialized agency of the United Nations responsible for international public health.",avatar_url:"https://avatars.githubusercontent.com/u/12261302?s=200&v=4",html_url:"https://github.com/WorldHealthOrganization",type:"Organization",permissions:{can_create_repositories:!0,can_create_private_repositories:!0},plan:{name:"Organization",private_repos:"unlimited"},isWHO:!0}}}async checkRateLimit(){try{const e=this.octokit||await this.createOctokitInstance(),{data:t}=await e.rest.rateLimit.get();return{core:{limit:t.rate.limit,remaining:t.rate.remaining,reset:t.rate.reset,used:t.rate.used},search:{limit:t.search.limit,remaining:t.search.remaining,reset:t.search.reset,used:t.search.used},isAuthenticated:this.isAuthenticated}}catch(e){return console.warn("Could not check rate limit:",e),{core:{limit:this.isAuthenticated?5e3:60,remaining:0,reset:Date.now()+36e5,used:this.isAuthenticated?5e3:60},search:{limit:this.isAuthenticated?30:10,remaining:0,reset:Date.now()+6e4,used:this.isAuthenticated?30:10},isAuthenticated:this.isAuthenticated}}}async shouldSkipApiCalls(){if(this.isAuthenticated)return!1;try{const e=(await this.checkRateLimit()).core.remaining;return e<10&&(console.warn("\ud83d\udeab Rate limit protection: Only ".concat(e," API calls remaining, skipping compatibility checks")),!0)}catch(e){return console.warn("\u26a0\ufe0f Cannot check rate limits, enabling conservative mode"),!this.isAuthenticated}}async getRepositories(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"user";return this.getSmartGuidelinesRepositories(e,t)}async checkSmartGuidelinesCompatibility(e,t){let o=arguments.length>2&&void 0!==arguments[2]?arguments[2]:2;const r=n.get(e,t);if(null!==r)return{compatible:r,cached:!0};if(!this.isAuthenticated)try{if(await this.shouldSkipApiCalls())return console.warn("\u26a1 Skipping compatibility check for ".concat(e,"/").concat(t," due to rate limit protection")),{compatible:!1,skipped:!0,reason:"Rate limit protection - API call skipped"}}catch(s){console.warn("Could not check rate limits, proceeding with API call:",s)}try{const o=this.octokit||await this.createOctokitInstance(),{data:r}=await o.rest.repos.getContent({owner:e,repo:t,path:"sushi-config.yaml"});if("file"===r.type&&r.content){const o=decodeURIComponent(escape(atob(r.content))).includes("smart.who.int.base");return n.set(e,t,o),{compatible:o}}return n.set(e,t,!1),{compatible:!1,reason:"No sushi-config.yaml file found"}}catch(a){if(404===a.status&&o>0){console.warn("File not found for ".concat(e,"/").concat(t,", retrying... (").concat(o," attempts left)"));const r=1e3;return await new Promise(e=>setTimeout(e,r)),this.checkSmartGuidelinesCompatibility(e,t,o-1)}if(403===a.status&&a.message.includes("SAML enforcement")&&this.octokit){console.log("SAML-protected repository ".concat(e,"/").concat(t,", trying public API fallback"));try{const o=await this.createOctokitInstance(),{data:r}=await o.rest.repos.getContent({owner:e,repo:t,path:"sushi-config.yaml"});if("file"===r.type&&r.content){const o=decodeURIComponent(escape(atob(r.content)));return o.includes("smart.who.int.base")?(console.log("Repository ".concat(e,"/").concat(t," is compatible via public API despite SAML protection")),n.set(e,t,!0),{compatible:!0,reason:"SMART Guidelines DAK (SAML-protected, verified via public API)",requiresAuthentication:!0}):(n.set(e,t,!1),{compatible:!1,reason:"No smart.who.int.base dependency found (via public API)"})}}catch(i){console.warn("Public API fallback also failed for ".concat(e,"/").concat(t,":"),i.message)}}const r={compatible:!1,error:a.message,errorType:this._categorizeError(a),status:a.status,retryable:this._isRetryableError(a)};return console.warn("Failed to check ".concat(e,"/").concat(t," for sushi-config.yaml with smart.who.int.base dependency:"),a.message),n.set(e,t,!1),r}}_categorizeError(e){return 403===e.status?e.message.includes("rate limit")?"rate_limit":"permission_denied":404===e.status?"not_found":401===e.status?"authentication_failed":"ENOTFOUND"===e.code||"ECONNRESET"===e.code?"network_error":"unknown_error"}_isRetryableError(e){return["rate_limit","network_error"].includes(this._categorizeError(e))}async getSmartGuidelinesRepositories(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"user",o=arguments.length>2&&void 0!==arguments[2]&&arguments[2];try{let s=[];if(this.isAuth()){let o=1,r=!0;for(;r;){let a;a="user"===t?await this.octokit.rest.repos.listForUser({username:e,sort:"updated",per_page:100,page:o}):await this.octokit.rest.repos.listForOrg({org:e,sort:"updated",per_page:100,page:o}),s=s.concat(a.data),r=100===a.data.length,o++}}else s=await this.getPublicRepositories(e,t);if(o)return console.log("\u26a1 Skipping compatibility checks for ".concat(s.length," repositories to avoid rate limiting")),s.map(e=>(0,r.A)((0,r.A)({},e),{},{smart_guidelines_compatible:!0}));const a=[];for(const e of s){(await this.checkSmartGuidelinesCompatibility(e.owner.login,e.name)).compatible&&a.push((0,r.A)((0,r.A)({},e),{},{smart_guidelines_compatible:!0}))}return a}catch(s){throw console.error("Failed to fetch SMART guidelines repositories:",s),s}}async getSmartGuidelinesRepositoriesProgressive(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"user",o=arguments.length>2&&void 0!==arguments[2]?arguments[2]:null,s=arguments.length>3&&void 0!==arguments[3]?arguments[3]:null,n=arguments.length>4&&void 0!==arguments[4]?arguments[4]:null;try{let i=[],c=1,l=!0;if(this.isAuth())for(;l;){let o;o="user"===t?await this.octokit.rest.repos.listForUser({username:e,sort:"updated",per_page:100,page:c}):await this.octokit.rest.repos.listForOrg({org:e,sort:"updated",per_page:100,page:c}),i=i.concat(o.data),l=100===o.data.length,c++}else i=await this.getPublicRepositories(e,t);if(0===i.length)return console.log("\ud83d\udcca No repositories found for user, completing scan immediately"),s&&s({current:0,total:0,currentRepo:"none",progress:100,completed:!0}),[];const h={rateLimited:[],networkErrors:[],permissionDenied:[],otherErrors:[],totalErrors:0,totalScanned:0},u=async(e,t)=>{await new Promise(e=>setTimeout(e,100+200*Math.random()));const s=await this.checkSmartGuidelinesCompatibility(e.owner.login,e.name);if(h.totalScanned++,s.compatible){const t=(0,r.A)((0,r.A)({},e),{},{smart_guidelines_compatible:!0});return o&&o(t),t}if(s.error){h.totalErrors++;const t={repo:e.name,error:s.error,errorType:s.errorType,retryable:s.retryable};switch(s.errorType){case"rate_limit":h.rateLimited.push(t);break;case"network_error":h.networkErrors.push(t);break;case"permission_denied":h.permissionDenied.push(t);break;default:h.otherErrors.push(t)}n&&n(t)}return null},g=(await a(i,u,{concurrency:5,onProgress:(e,t,o,r)=>{if(s){const r={current:e,total:t,currentRepo:o.name,progress:Math.round(e/t*100),completed:!0,scanningErrors:h.totalErrors>0?{totalErrors:h.totalErrors,rateLimitedCount:h.rateLimited.length,networkErrorCount:h.networkErrors.length,hasRetryableErrors:[...h.rateLimited,...h.networkErrors].some(e=>e.retryable)}:null};s(r)}},onItemStart:(e,t)=>{s&&s({current:t+1,total:i.length,currentRepo:e.name,progress:Math.round((t+1)/i.length*100),completed:!1,started:!0})}})).filter(e=>null!==e&&!e.error);return h.totalErrors>0&&(console.warn("Repository scanning completed with ".concat(h.totalErrors," errors out of ").concat(h.totalScanned," repositories checked:")),h.rateLimited.length>0&&console.warn("- Rate limited: ".concat(h.rateLimited.length," repositories")),h.networkErrors.length>0&&console.warn("- Network errors: ".concat(h.networkErrors.length," repositories")),h.permissionDenied.length>0&&console.warn("- Permission denied: ".concat(h.permissionDenied.length," repositories")),h.otherErrors.length>0&&console.warn("- Other errors: ".concat(h.otherErrors.length," repositories"))),{repositories:g,scanningErrors:h.totalErrors>0?h:null}}catch(i){throw console.error("Failed to fetch SMART guidelines repositories:",i),i}}async getRepository(e,t){try{const o=this.isAuth()?this.octokit:await this.createOctokitInstance(),{data:r}=await o.rest.repos.get({owner:e,repo:t});return r}catch(o){throw console.error("Failed to fetch repository:",o),o}}async getBranches(e,t){try{console.log("githubService.getBranches: Fetching branches for ".concat(e,"/").concat(t)),console.log("githubService.getBranches: Authentication status:",this.isAuth());const o=this.isAuth()?this.octokit:await this.createOctokitInstance();console.log("githubService.getBranches: Using",this.isAuth()?"authenticated":"public","octokit instance");const{data:r}=await o.rest.repos.listBranches({owner:e,repo:t,per_page:100});return console.log("githubService.getBranches: Successfully fetched ".concat(r.length," branches")),r}catch(o){throw console.error("githubService.getBranches: Failed to fetch branches:",o),console.error("githubService.getBranches: Error details:",{status:o.status,message:o.message,owner:e,repo:t}),o}}async createBranch(e,t,o){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:"main";if(!this.isAuth())throw new Error("Not authenticated with GitHub");try{const{data:s}=await this.octokit.rest.git.getRef({owner:e,repo:t,ref:"heads/".concat(r)}),{data:a}=await this.octokit.rest.git.createRef({owner:e,repo:t,ref:"refs/heads/".concat(o),sha:s.object.sha});return a}catch(s){throw console.error("Failed to create branch:",s),s}}async getBranch(e,t,o){try{const r=this.isAuth()?this.octokit:await this.createOctokitInstance(),{data:s}=await r.rest.repos.getBranch({owner:e,repo:t,branch:o});return s}catch(r){throw console.error("Failed to fetch branch:",r),r}}async getWorkflows(e,t){if(!this.isAuth())throw new Error("Not authenticated with GitHub");try{const{data:o}=await this.octokit.rest.actions.listRepoWorkflows({owner:e,repo:t});return o.workflows.map(e=>({id:e.id,name:e.name,filename:e.path.split("/").pop(),path:e.path,state:e.state,created_at:e.created_at,updated_at:e.updated_at,url:e.html_url,triggers:["unknown"],lastModified:e.updated_at}))}catch(o){if(404===o.status)return[];throw console.error("Failed to fetch workflows:",o),o}}async getWorkflowRuns(e,t){let o=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};if(!this.isAuth())throw new Error("Not authenticated with GitHub");try{const r={owner:e,repo:t,per_page:o.per_page||10,page:o.page||1};o.branch&&(r.branch=o.branch),o.workflow_id&&(r.workflow_id=o.workflow_id);const{data:s}=await this.octokit.rest.actions.listWorkflowRunsForRepo(r);return s}catch(r){throw console.error("Failed to fetch workflow runs:",r),r}}async getWorkflowRunsForWorkflow(e,t,o){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:{};if(!this.isAuth())throw new Error("Not authenticated with GitHub");try{const s={owner:e,repo:t,workflow_id:o,per_page:r.per_page||10,page:r.page||1};r.branch&&(s.branch=r.branch);const{data:a}=await this.octokit.rest.actions.listWorkflowRuns(s);return a}catch(s){throw console.error("Failed to fetch workflow runs for workflow:",s),s}}async triggerWorkflow(e,t,o){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:"main",s=arguments.length>4&&void 0!==arguments[4]?arguments[4]:{};if(!this.isAuth())throw new Error("Not authenticated with GitHub");try{const{data:a}=await this.octokit.rest.actions.createWorkflowDispatch({owner:e,repo:t,workflow_id:o,ref:r,inputs:s});return a}catch(a){throw console.error("Failed to trigger workflow:",a),a}}async rerunWorkflow(e,t,o){if(!this.isAuth())throw new Error("Not authenticated with GitHub");try{const{data:r}=await this.octokit.rest.actions.reRunWorkflow({owner:e,repo:t,run_id:o});return r}catch(r){throw console.error("Failed to re-run workflow:",r),r}}async getWorkflowRunLogs(e,t,o){if(!this.isAuth())throw new Error("Not authenticated with GitHub");try{const{data:r}=await this.octokit.rest.actions.downloadWorkflowRunLogs({owner:e,repo:t,run_id:o});return r}catch(r){throw console.error("Failed to get workflow run logs:",r),r}}async approveWorkflowRun(e,t,o){if(!this.isAuth())throw new Error("Not authenticated with GitHub");try{const{data:r}=await this.octokit.rest.actions.approveWorkflowRun({owner:e,repo:t,run_id:o});return r}catch(r){throw console.error("Failed to approve workflow run:",r),r}}async getCommitDiff(e,t,o,r){if(!this.isAuth())throw new Error("Not authenticated with GitHub");try{const{data:s}=await this.octokit.rest.repos.compareCommits({owner:e,repo:t,base:o,head:r});return s}catch(s){throw console.error("Failed to get commit diff:",s),s}}async getCommit(e,t,o){if(!this.isAuth())throw new Error("Not authenticated with GitHub");try{const{data:r}=await this.octokit.rest.repos.getCommit({owner:e,repo:t,ref:o});return r}catch(r){throw console.error("Failed to get commit details:",r),r}}async getReleases(e,t){let o=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};if(!this.isAuth())throw new Error("Not authenticated with GitHub");try{const{data:r}=await this.octokit.rest.repos.listReleases({owner:e,repo:t,per_page:o.per_page||10,page:o.page||1});return r}catch(r){throw console.error("Failed to fetch releases:",r),r}}async getLatestRelease(e,t){if(!this.isAuth())throw new Error("Not authenticated with GitHub");try{const{data:o}=await this.octokit.rest.repos.getLatestRelease({owner:e,repo:t});return o}catch(o){throw console.error("Failed to fetch latest release:",o),o}}async getBpmnFilesRecursive(e,t,o){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:"main",s=arguments.length>4&&void 0!==arguments[4]?arguments[4]:[];try{console.log("\ud83d\udd0e githubService.getBpmnFilesRecursive: Searching ".concat(e,"/").concat(t,"/").concat(o," (ref: ").concat(r,")"));const a=this.isAuth()?this.octokit:await this.createOctokitInstance();console.log("\ud83d\udd10 githubService.getBpmnFilesRecursive: Using ".concat(this.isAuth()?"authenticated":"public"," octokit"));const{data:n}=await a.rest.repos.getContent({owner:e,repo:t,path:o,ref:r});if(console.log("\ud83d\udce6 githubService.getBpmnFilesRecursive: Received data type: ".concat(Array.isArray(n)?"array":"single file",", length: ").concat(Array.isArray(n)?n.length:1)),!Array.isArray(n))return n.name.endsWith(".bpmn")&&(console.log("\ud83d\udcc4 githubService.getBpmnFilesRecursive: Found single BPMN file: ".concat(n.name)),s.push(n)),s;for(const o of n)"file"===o.type&&o.name.endsWith(".bpmn")?(console.log("\ud83d\udcc4 githubService.getBpmnFilesRecursive: Found BPMN file: ".concat(o.name)),s.push(o)):"dir"===o.type&&(console.log("\ud83d\udcc1 githubService.getBpmnFilesRecursive: Found subdirectory: ".concat(o.name,", recursing...")),await this.getBpmnFilesRecursive(e,t,o.path,r,s));return console.log("\u2705 githubService.getBpmnFilesRecursive: Completed search of ".concat(o,", found ").concat(s.length," total files so far")),s}catch(a){if(console.log("\u274c githubService.getBpmnFilesRecursive: Error searching ".concat(o,":"),a.status,a.message),404===a.status)return s;throw a}}async getBpmnFiles(e,t){let o=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"main";console.log("\ud83d\udd0d githubService.getBpmnFiles: Starting search for ".concat(e,"/").concat(t," (ref: ").concat(o,")"));const r=[],s=["input/business-processes","input/business-process"];for(const i of s)try{console.log("\ud83d\udcc1 githubService.getBpmnFiles: Searching in directory: ".concat(i));const s=await this.getBpmnFilesRecursive(e,t,i,o);console.log("\u2705 githubService.getBpmnFiles: Found ".concat(s.length," BPMN files in ").concat(i)),r.push(...s)}catch(n){404!==n.status?console.warn("\u274c Could not fetch BPMN files from ".concat(i,":"),n.message):console.log("\ud83d\udcc2 githubService.getBpmnFiles: Directory ".concat(i," not found (404) - this is expected if the directory doesn't exist"))}const a=r.filter((e,t,o)=>t===o.findIndex(t=>t.path===e.path));return console.log("\ud83c\udfaf githubService.getBpmnFiles: Final result - ".concat(a.length," unique BPMN files found")),console.log("\ud83d\udccb githubService.getBpmnFiles: File list:",a.map(e=>e.name)),a}async getFileContent(e,t,o){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:"main";const s=15e3;try{console.log("\ud83d\ude80 githubService.getFileContent: Starting request for ".concat(e,"/").concat(t,"/").concat(o," (ref: ").concat(r,")")),console.log("\ud83d\udd10 githubService.getFileContent: Authentication status:",this.isAuth()),console.log("\ud83d\udccb githubService.getFileContent: Request parameters:",{owner:e,repo:t,path:o,ref:r});const a=this.isAuth()?this.octokit:await this.createOctokitInstance();console.log("\ud83d\udd27 githubService.getFileContent: Using",this.isAuth()?"authenticated":"public","octokit instance");const i=new Promise((e,t)=>{console.log("\u23f0 githubService.getFileContent: Setting up ".concat(s,"ms timeout")),setTimeout(()=>{console.error("\u23f0 githubService.getFileContent: Request timed out after ".concat(s,"ms")),t(new Error("Request timeout after ".concat(s,"ms")))},s)});console.log("\ud83c\udf10 githubService.getFileContent: Creating GitHub API promise...");const c=a.rest.repos.getContent({owner:e,repo:t,path:o,ref:r});console.log("\ud83d\udce1 githubService.getFileContent: API request initiated, waiting for response...");const l=Date.now(),{data:h}=await Promise.race([c,i]),u=Date.now()-l;if(console.log("\u2705 githubService.getFileContent: API response received in ".concat(u,"ms")),console.log("\ud83d\udcc2 githubService.getFileContent: Response data type:",h.type),console.log("\ud83d\udcca githubService.getFileContent: Response details:",{type:h.type,name:h.name,size:h.size,encoding:h.encoding,hasContent:!!h.content}),"file"!==h.type||!h.content)throw console.error("\u274c githubService.getFileContent: Invalid response - not a file or no content"),console.error("\ud83d\udd0d githubService.getFileContent: Full response data:",JSON.stringify(h,null,2)),new Error("File not found or is not a file");console.log("\ud83d\udd27 githubService.getFileContent: Decoding base64 content..."),console.log("\ud83d\udcca githubService.getFileContent: Base64 content length:",h.content.length);try{const e=Buffer.from(h.content,"base64").toString("utf-8");return console.log("\u2705 githubService.getFileContent: Successfully fetched and decoded file content"),console.log("\ud83d\udccf githubService.getFileContent: Final content length:",e.length,"characters"),console.log("\ud83d\udc40 githubService.getFileContent: Content preview (first 200 chars):",e.substring(0,200)),e}catch(n){throw console.error("\u274c githubService.getFileContent: Base64 decoding failed:",n),console.error("\ud83d\udd0d githubService.getFileContent: Raw base64 content preview:",h.content.substring(0,100)),new Error("Failed to decode file content: ".concat(n.message))}}catch(i){var a;if(console.error("\ud83d\udca5 githubService.getFileContent: Failed to fetch file content from ".concat(e,"/").concat(t,"/").concat(o,":"),i),console.error("\ud83d\udd0d githubService.getFileContent: Error analysis:",{type:typeof i,status:i.status,message:i.message,name:i.name,stack:(null===(a=i.stack)||void 0===a?void 0:a.substring(0,500))+"..."}),i.message.includes("timeout"))throw console.error("\u23f0 githubService.getFileContent: Timeout error detected"),new Error("GitHub API request timed out after ".concat(15," seconds. Please try again."));if(403===i.status)throw console.error("\ud83d\udd12 githubService.getFileContent: 403 Forbidden error detected"),new Error("Access denied. This repository may be private or you may have hit rate limits.");if(404===i.status)throw console.error("\ud83d\udd0d githubService.getFileContent: 404 Not Found error detected"),new Error("File not found in the repository.");if(i.message.includes("rate limit"))throw console.error("\ud83d\udea6 githubService.getFileContent: Rate limit error detected"),new Error("GitHub API rate limit exceeded. Please try again later.");if(i.message.includes("Network Error")||i.message.includes("Failed to fetch"))throw console.error("\ud83c\udf10 githubService.getFileContent: Network error detected"),new Error("Network error occurred. Please check your internet connection and try again.");throw console.error("\u2753 githubService.getFileContent: Unknown error type, re-throwing original error"),i}}async createCommit(e,t,o,r,s){if(!this.isAuth())throw new Error("Not authenticated with GitHub");try{const{data:a}=await this.octokit.rest.git.getRef({owner:e,repo:t,ref:"heads/".concat(o)}),n=a.object.sha,{data:i}=await this.octokit.rest.git.getCommit({owner:e,repo:t,commit_sha:n}),c=i.tree.sha,l=await Promise.all(s.map(async o=>{const{data:r}=await this.octokit.rest.git.createBlob({owner:e,repo:t,content:o.content,encoding:"utf-8"});return{path:o.path,mode:"100644",type:"blob",sha:r.sha}})),{data:h}=await this.octokit.rest.git.createTree({owner:e,repo:t,base_tree:c,tree:l}),{data:u}=await this.octokit.rest.git.createCommit({owner:e,repo:t,message:r,tree:h.sha,parents:[n]});return await this.octokit.rest.git.updateRef({owner:e,repo:t,ref:"heads/".concat(o),sha:u.sha}),{sha:u.sha,html_url:"https://github.com/".concat(e,"/").concat(t,"/commit/").concat(u.sha),message:u.message,author:u.author,committer:u.committer}}catch(a){throw console.error("Failed to create commit:",a),a}}async getRecentCommits(e,t){let o=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"main",r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:5;if(!this.isAuth())throw new Error("Not authenticated with GitHub");const s=Date.now();this.logger.apiCall("GET","/repos/".concat(e,"/").concat(t,"/commits"),{sha:o,per_page:r});try{const a=await this.octokit.rest.repos.listCommits({owner:e,repo:t,sha:o,per_page:r});return this.logger.apiResponse("GET","/repos/".concat(e,"/").concat(t,"/commits"),a.status,Date.now()-s),a.data.map(e=>({sha:e.sha,message:e.commit.message,author:{name:e.commit.author.name,email:e.commit.author.email,date:e.commit.author.date},committer:{name:e.commit.committer.name,email:e.commit.committer.email,date:e.commit.committer.date},html_url:e.html_url,stats:e.stats}))}catch(a){throw this.logger.apiResponse("GET","/repos/".concat(e,"/").concat(t,"/commits"),a.status||"error",Date.now()-s),console.error("Failed to fetch recent commits:",a),a}}async getOpenPullRequestsCount(e,t){if(!this.isAuth())throw new Error("Not authenticated with GitHub");const o=Date.now();this.logger.apiCall("GET","/repos/".concat(e,"/").concat(t,"/pulls"),{state:"open",per_page:1});try{const r=await this.octokit.rest.pulls.list({owner:e,repo:t,state:"open",per_page:1});this.logger.apiResponse("GET","/repos/".concat(e,"/").concat(t,"/pulls"),r.status,Date.now()-o);const s=r.headers.link;if(s&&s.includes('rel="last"')){const e=s.match(/page=(\d+)>; rel="last"/);if(e)return parseInt(e[1],10)}return r.data.length}catch(r){throw this.logger.apiResponse("GET","/repos/".concat(e,"/").concat(t,"/pulls"),r.status||"error",Date.now()-o),console.error("Failed to fetch pull requests count:",r),r}}async getPullRequestForBranch(e,t,o){const r=await this.getPullRequestsForBranch(e,t,o);return r&&r.length>0?r[0]:null}async getPullRequestsForBranch(e,t,o){const r=this.isAuth()?this.octokit:await this.createOctokitInstance(),s=Date.now();this.logger.apiCall("GET","/repos/".concat(e,"/").concat(t,"/pulls"),{state:"open",head:"".concat(e,":").concat(o)});try{const a=await r.rest.pulls.list({owner:e,repo:t,state:"open",head:"".concat(e,":").concat(o),per_page:100});return this.logger.apiResponse("GET","/repos/".concat(e,"/").concat(t,"/pulls"),a.status,Date.now()-s),a.data||[]}catch(a){return this.logger.apiResponse("GET","/repos/".concat(e,"/").concat(t,"/pulls"),a.status||"error",Date.now()-s),console.error("Failed to fetch pull requests for branch:",a),[]}}async getPullRequestComments(e,t,o){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1,s=arguments.length>4&&void 0!==arguments[4]?arguments[4]:100;const a=this.isAuth()?this.octokit:await this.createOctokitInstance(),n=Date.now();this.logger.apiCall("GET","/repos/".concat(e,"/").concat(t,"/pulls/").concat(o,"/comments"),{page:r,per_page:s});try{const i=await a.rest.pulls.listReviewComments({owner:e,repo:t,pull_number:o,page:r,per_page:s});return this.logger.apiResponse("GET","/repos/".concat(e,"/").concat(t,"/pulls/").concat(o,"/comments"),i.status,Date.now()-n),i.data}catch(i){throw this.logger.apiResponse("GET","/repos/".concat(e,"/").concat(t,"/pulls/").concat(o,"/comments"),i.status||"error",Date.now()-n),console.error("Failed to fetch pull request comments:",i),i}}async getPullRequestIssueComments(e,t,o){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1,s=arguments.length>4&&void 0!==arguments[4]?arguments[4]:100;const a=this.isAuth()?this.octokit:await this.createOctokitInstance(),n=Date.now();this.logger.apiCall("GET","/repos/".concat(e,"/").concat(t,"/issues/").concat(o,"/comments"),{page:r,per_page:s});try{const i=await a.rest.issues.listComments({owner:e,repo:t,issue_number:o,page:r,per_page:s});return this.logger.apiResponse("GET","/repos/".concat(e,"/").concat(t,"/issues/").concat(o,"/comments"),i.status,Date.now()-n),i.data}catch(i){throw this.logger.apiResponse("GET","/repos/".concat(e,"/").concat(t,"/issues/").concat(o,"/comments"),i.status||"error",Date.now()-n),console.error("Failed to fetch pull request issue comments:",i),i}}async createPullRequestComment(e,t,o,r){if(!this.isAuth())throw new Error("Not authenticated with GitHub");const s=Date.now();this.logger.apiCall("POST","/repos/".concat(e,"/").concat(t,"/issues/").concat(o,"/comments"),{body:r});try{const a=await this.octokit.rest.issues.createComment({owner:e,repo:t,issue_number:o,body:r});return this.logger.apiResponse("POST","/repos/".concat(e,"/").concat(t,"/issues/").concat(o,"/comments"),a.status,Date.now()-s),a.data}catch(a){throw this.logger.apiResponse("POST","/repos/".concat(e,"/").concat(t,"/issues/").concat(o,"/comments"),a.status||"error",Date.now()-s),console.error("Failed to create pull request comment:",a),a}}async getPullRequestTimeline(e,t,o){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1,s=arguments.length>4&&void 0!==arguments[4]?arguments[4]:100;const a=this.isAuth()?this.octokit:await this.createOctokitInstance(),n=Date.now();this.logger.apiCall("GET","/repos/".concat(e,"/").concat(t,"/issues/").concat(o,"/timeline"),{page:r,per_page:s});try{const i=await a.rest.issues.listEventsForTimeline({owner:e,repo:t,issue_number:o,page:r,per_page:s});return this.logger.apiResponse("GET","/repos/".concat(e,"/").concat(t,"/issues/").concat(o,"/timeline"),i.status,Date.now()-n),i.data}catch(i){return this.logger.apiResponse("GET","/repos/".concat(e,"/").concat(t,"/issues/").concat(o,"/timeline"),i.status||"error",Date.now()-n),console.debug("Failed to fetch pull request timeline:",i),[]}}async mergePullRequest(e,t,o){let s=arguments.length>3&&void 0!==arguments[3]?arguments[3]:{};if(!this.isAuth())throw new Error("Not authenticated with GitHub");const a=Date.now();this.logger.apiCall("PUT","/repos/".concat(e,"/").concat(t,"/pulls/").concat(o,"/merge"),s);try{const n=(0,r.A)({owner:e,repo:t,pull_number:o,commit_title:s.commit_title,commit_message:s.commit_message,merge_method:s.merge_method||"merge"},s),i=await this.octokit.rest.pulls.merge(n);return this.logger.apiResponse("PUT","/repos/".concat(e,"/").concat(t,"/pulls/").concat(o,"/merge"),i.status,Date.now()-a),i.data}catch(n){throw this.logger.apiResponse("PUT","/repos/".concat(e,"/").concat(t,"/pulls/").concat(o,"/merge"),n.status||"error",Date.now()-a),console.error("Failed to merge pull request:",n),n}}async checkPullRequestMergePermissions(e,t,o){if(!this.isAuth())return this.logger.warn("Cannot check PR merge permissions - not authenticated",{owner:e,repo:t,pullNumber:o}),!1;try{const r=Date.now();this.logger.apiCall("GET","/repos/".concat(e,"/").concat(t,"/pulls/").concat(o),{});const s=await this.octokit.rest.pulls.get({owner:e,repo:t,pull_number:o});this.logger.apiResponse("GET","/repos/".concat(e,"/").concat(t,"/pulls/").concat(o),s.status,Date.now()-r);const a=s.data;if("open"!==a.state)return this.logger.debug("PR not mergeable - not open",{owner:e,repo:t,pullNumber:o,state:a.state}),!1;if(a.draft)return this.logger.debug("PR not mergeable - is draft",{owner:e,repo:t,pullNumber:o}),!1;return!!await this.checkRepositoryWritePermissions(e,t)||(this.logger.debug("PR not mergeable - no write access",{owner:e,repo:t,pullNumber:o}),!1)}catch(r){return this.logger.warn("Error checking PR merge permissions",{owner:e,repo:t,pullNumber:o,error:r.message}),!1}}async getOpenIssuesCount(e,t){if(!this.isAuth())throw new Error("Not authenticated with GitHub");const o=Date.now();this.logger.apiCall("GET","/repos/".concat(e,"/").concat(t,"/issues"),{state:"open",per_page:1});try{const r=await this.octokit.rest.issues.listForRepo({owner:e,repo:t,state:"open",per_page:1});this.logger.apiResponse("GET","/repos/".concat(e,"/").concat(t,"/issues"),r.status,Date.now()-o);const s=r.headers.link;if(s&&s.includes('rel="last"')){const e=s.match(/page=(\d+)>; rel="last"/);if(e)return parseInt(e[1],10)}return r.data.length}catch(r){throw this.logger.apiResponse("GET","/repos/".concat(e,"/").concat(t,"/issues"),r.status||"error",Date.now()-o),console.error("Failed to fetch issues count:",r),r}}async getRepositoryStats(e,t){let o=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"main";if(!this.isAuth())throw new Error("Not authenticated with GitHub");try{const[r,s,a]=await Promise.allSettled([this.getRecentCommits(e,t,o,1),this.getOpenPullRequestsCount(e,t),this.getOpenIssuesCount(e,t)]);return{recentCommits:"fulfilled"===r.status?r.value:[],openPullRequestsCount:"fulfilled"===s.status?s.value:0,openIssuesCount:"fulfilled"===a.status?a.value:0,errors:{recentCommits:"rejected"===r.status?r.reason:null,openPullRequestsCount:"rejected"===s.status?s.reason:null,openIssuesCount:"rejected"===a.status?a.reason:null}}}catch(r){throw console.error("Failed to fetch repository stats:",r),r}}async getDirectoryContents(e,t){let o=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"",r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:"main";try{const s=this.isAuth()?this.octokit:await this.createOctokitInstance(),{data:a}=await s.rest.repos.getContent({owner:e,repo:t,path:o,ref:r});if(Array.isArray(a))return a;throw new Error("Not a directory")}catch(s){throw console.error("Failed to get directory contents for ".concat(o,":"),s),s}}async updateFile(e,t,o,r,s){let a=arguments.length>5&&void 0!==arguments[5]?arguments[5]:"main";if(!this.isAuth())throw new Error("Authentication required to update files");try{const{data:n}=await this.octokit.rest.repos.getContent({owner:e,repo:t,path:o,ref:a});if(Array.isArray(n))throw new Error("Path is a directory, not a file");const{data:i}=await this.octokit.rest.repos.createOrUpdateFileContents({owner:e,repo:t,path:o,message:s,content:btoa(unescape(encodeURIComponent(r))),sha:n.sha,branch:a});return i}catch(n){throw console.error("Failed to update file ".concat(o,":"),n),n}}async getCommits(e,t){let o=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};try{const r=this.isAuth()?this.octokit:await this.createOctokitInstance(),s={owner:e,repo:t,per_page:o.per_page||10,page:o.page||1};o.sha&&(s.sha=o.sha),o.since&&(s.since=o.since),o.until&&(s.until=o.until);const{data:a}=await r.rest.repos.listCommits(s);return a}catch(r){throw console.error("Failed to fetch commits:",r),r}}async getIssues(e,t){let o=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};try{const r=this.isAuth()?this.octokit:await this.createOctokitInstance(),s={owner:e,repo:t,state:o.state||"all",per_page:o.per_page||30,page:o.page||1};o.labels&&(s.labels=o.labels),o.milestone&&(s.milestone=o.milestone);const{data:a}=await r.rest.issues.listForRepo(s);return a}catch(r){throw console.error("Failed to fetch issues:",r),r}}async getRepositoryIssues(e,t){let o=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};return this.getIssues(e,t,o)}async getForks(e,t){let o=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};const r=Date.now();this.logger.apiCall("GET","/repos/".concat(e,"/").concat(t,"/forks"),o);try{const s=this.isAuth()?this.octokit:await this.createOctokitInstance(),a={owner:e,repo:t,sort:o.sort||"newest",per_page:o.per_page||100,page:o.page||1},{data:n}=await s.rest.repos.listForks(a);return this.logger.apiResponse("GET","/repos/".concat(e,"/").concat(t,"/forks"),200,Date.now()-r),n.map(e=>({id:e.id,name:e.name,full_name:e.full_name,owner:{login:e.owner.login,avatar_url:e.owner.avatar_url,html_url:e.owner.html_url,type:e.owner.type},description:e.description,html_url:e.html_url,clone_url:e.clone_url,created_at:e.created_at,updated_at:e.updated_at,pushed_at:e.pushed_at,stargazers_count:e.stargazers_count,forks_count:e.forks_count,open_issues_count:e.open_issues_count,default_branch:e.default_branch,private:e.private,fork:e.fork,parent:e.parent?{full_name:e.parent.full_name,html_url:e.parent.html_url}:null}))}catch(s){throw this.logger.apiResponse("GET","/repos/".concat(e,"/").concat(t,"/forks"),s.status||"error",Date.now()-r),console.error("Failed to fetch repository forks:",s),s}}async getPullRequests(e,t){let o=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};const r=Date.now();this.logger.apiCall("GET","/repos/".concat(e,"/").concat(t,"/pulls"),o);try{const s=this.isAuth()?this.octokit:await this.createOctokitInstance(),a={owner:e,repo:t,state:o.state||"open",sort:o.sort||"updated",direction:o.direction||"desc",per_page:o.per_page||30,page:o.page||1};o.head&&(a.head=o.head),o.base&&(a.base=o.base);const{data:n}=await s.rest.pulls.list(a);return this.logger.apiResponse("GET","/repos/".concat(e,"/").concat(t,"/pulls"),200,Date.now()-r),n.map(e=>({id:e.id,number:e.number,title:e.title,body:e.body,state:e.state,locked:e.locked,user:{login:e.user.login,avatar_url:e.user.avatar_url,html_url:e.user.html_url,type:e.user.type},created_at:e.created_at,updated_at:e.updated_at,closed_at:e.closed_at,merged_at:e.merged_at,html_url:e.html_url,diff_url:e.diff_url,patch_url:e.patch_url,head:{ref:e.head.ref,sha:e.head.sha,repo:e.head.repo?{name:e.head.repo.name,full_name:e.head.repo.full_name,owner:{login:e.head.repo.owner.login,avatar_url:e.head.repo.owner.avatar_url},html_url:e.head.repo.html_url}:null},base:{ref:e.base.ref,sha:e.base.sha,repo:{name:e.base.repo.name,full_name:e.base.repo.full_name,owner:{login:e.base.repo.owner.login,avatar_url:e.base.repo.owner.avatar_url},html_url:e.base.repo.html_url}},draft:e.draft,mergeable:e.mergeable,mergeable_state:e.mergeable_state,comments:e.comments,review_comments:e.review_comments,commits:e.commits,additions:e.additions,deletions:e.deletions,changed_files:e.changed_files}))}catch(s){throw this.logger.apiResponse("GET","/repos/".concat(e,"/").concat(t,"/pulls"),s.status||"error",Date.now()-r),console.error("Failed to fetch pull requests:",s),s}}async createIssue(e,t,o,r){let s=arguments.length>4&&void 0!==arguments[4]?arguments[4]:[],a=arguments.length>5&&void 0!==arguments[5]?arguments[5]:[];if(!this.isAuth())throw new Error("Authentication required to create issues");const n=Date.now();this.logger.apiCall("POST","/repos/".concat(e,"/").concat(t,"/issues"),{title:o,bodyLength:null===r||void 0===r?void 0:r.length,labels:s,assignees:a});try{const i={owner:e,repo:t,title:o,body:r};s.length>0&&(i.labels=s),a.length>0&&(i.assignees=a);const c=await this.octokit.rest.issues.create(i);return this.logger.apiResponse("POST","/repos/".concat(e,"/").concat(t,"/issues"),c.status,Date.now()-n),{success:!0,issue:{id:c.data.id,number:c.data.number,title:c.data.title,body:c.data.body,html_url:c.data.html_url,state:c.data.state,created_at:c.data.created_at,user:{login:c.data.user.login,avatar_url:c.data.user.avatar_url},labels:c.data.labels.map(e=>({name:e.name,color:e.color}))}}}catch(i){return this.logger.apiResponse("POST","/repos/".concat(e,"/").concat(t,"/issues"),i.status||"error",Date.now()-n),console.error("Failed to create issue:",i),{success:!1,error:{message:i.message,status:i.status,type:403===i.status?"permission_denied":422===i.status?"validation_error":404===i.status?"repository_not_found":"unknown_error"}}}}async getIssue(e,t,o){if(!this.isAuth())throw new Error("Authentication required to get issue details");const r=Date.now();this.logger.apiCall("GET","/repos/".concat(e,"/").concat(t,"/issues/").concat(o));try{const s=await this.octokit.rest.issues.get({owner:e,repo:t,issue_number:o});return this.logger.apiResponse("GET","/repos/".concat(e,"/").concat(t,"/issues/").concat(o),s.status,Date.now()-r),{id:s.data.id,number:s.data.number,title:s.data.title,body:s.data.body,html_url:s.data.html_url,state:s.data.state,created_at:s.data.created_at,updated_at:s.data.updated_at,closed_at:s.data.closed_at,user:{login:s.data.user.login,avatar_url:s.data.user.avatar_url},labels:s.data.labels.map(e=>({name:e.name,color:e.color}))}}catch(s){throw this.logger.apiResponse("GET","/repos/".concat(e,"/").concat(t,"/issues/").concat(o),s.status||"error",Date.now()-r),console.error("Failed to get issue:",s),s}}async getPullRequest(e,t,o){if(!this.isAuth())throw new Error("Authentication required to get pull request details");const r=Date.now();this.logger.apiCall("GET","/repos/".concat(e,"/").concat(t,"/pulls/").concat(o));try{const s=await this.octokit.rest.pulls.get({owner:e,repo:t,pull_number:o});return this.logger.apiResponse("GET","/repos/".concat(e,"/").concat(t,"/pulls/").concat(o),s.status,Date.now()-r),{id:s.data.id,number:s.data.number,title:s.data.title,body:s.data.body,html_url:s.data.html_url,state:s.data.state,created_at:s.data.created_at,updated_at:s.data.updated_at,closed_at:s.data.closed_at,merged_at:s.data.merged_at,user:{login:s.data.user.login,avatar_url:s.data.user.avatar_url},head:{ref:s.data.head.ref,sha:s.data.head.sha},base:{ref:s.data.base.ref,sha:s.data.base.sha}}}catch(s){throw this.logger.apiResponse("GET","/repos/".concat(e,"/").concat(t,"/pulls/").concat(o),s.status||"error",Date.now()-r),console.error("Failed to get pull request:",s),s}}async searchIssues(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};if(!this.isAuth())throw new Error("Authentication required to search issues");const o=Date.now();this.logger.apiCall("GET","/search/issues",{query:e,type:"issue"});try{const r=await this.octokit.rest.search.issuesAndPullRequests({q:e,sort:t.sort||"created",order:t.order||"desc",per_page:t.per_page||30,page:t.page||1});return this.logger.apiResponse("GET","/search/issues",r.status,Date.now()-o),{total_count:r.data.total_count,incomplete_results:r.data.incomplete_results,items:r.data.items.map(e=>({id:e.id,number:e.number,title:e.title,body:e.body,html_url:e.html_url,state:e.state,created_at:e.created_at,updated_at:e.updated_at,closed_at:e.closed_at,labels:e.labels||[],user:{login:e.user.login,avatar_url:e.user.avatar_url},repository:e.repository_url?{name:e.repository_url.split("/").slice(-1)[0],full_name:e.repository_url.split("/").slice(-2).join("/")}:null}))}}catch(r){throw this.logger.apiResponse("GET","/search/issues",r.status||"error",Date.now()-o),console.error("Failed to search issues:",r),r}}async searchPullRequests(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};if(!this.isAuth())throw new Error("Authentication required to search pull requests");const o=Date.now();this.logger.apiCall("GET","/search/issues",{query:e,type:"pr"});try{const r=await this.octokit.rest.search.issuesAndPullRequests({q:e,sort:t.sort||"created",order:t.order||"desc",per_page:t.per_page||30,page:t.page||1});return this.logger.apiResponse("GET","/search/issues",r.status,Date.now()-o),{total_count:r.data.total_count,incomplete_results:r.data.incomplete_results,items:r.data.items.map(e=>({id:e.id,number:e.number,title:e.title,body:e.body,html_url:e.html_url,state:e.state,created_at:e.created_at,updated_at:e.updated_at,closed_at:e.closed_at,user:{login:e.user.login,avatar_url:e.user.avatar_url},repository:e.repository_url?{name:e.repository_url.split("/").slice(-1)[0],full_name:e.repository_url.split("/").slice(-2).join("/")}:null}))}}catch(r){throw this.logger.apiResponse("GET","/search/issues",r.status||"error",Date.now()-o),console.error("Failed to search pull requests:",r),r}}logout(){this.logger.auth("Logging out and clearing stored token"),this.octokit=null,this.isAuthenticated=!1,this.tokenType=null,this.permissions=null,c.clearToken();try{const{default:e}=o(18354);e.clearAllBranchContext()}catch(e){sessionStorage.removeItem("sgex_branch_context")}}async getRepositoryForks(e,t){let o=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};const r=Date.now();this.logger.debug("Fetching repository forks",{owner:e,repo:t,options:o});try{const s=this.isAuth()?this.octokit:await this.createOctokitInstance();this.logger.apiCall("GET","/repos/".concat(e,"/").concat(t,"/forks"),o);const{data:a}=await s.rest.repos.listForks({owner:e,repo:t,sort:"newest",per_page:o.per_page||100,page:o.page||1}),n=Date.now()-r;return this.logger.apiResponse("GET","/repos/".concat(e,"/").concat(t,"/forks"),200,n,{forkCount:a.length}),this.logger.performance("Repository forks fetch",n),a}catch(s){const o=Date.now()-r;throw this.logger.apiError("GET","/repos/".concat(e,"/").concat(t,"/forks"),s),this.logger.performance("Repository forks fetch (failed)",o),console.error("Failed to fetch forks for ".concat(e,"/").concat(t,":"),s),s}}async checkPullRequestReviewPermissions(e,t,o){try{if(!this.isAuth())return!1;if(await this.checkRepositoryWritePermissions(e,t))return!0;return 200===(await this.octokit.rest.repos.get({owner:e,repo:t})).status}catch(r){return console.debug("Cannot check PR review permissions:",r),!1}}async createPullRequestReview(e,t,o,r){let s=arguments.length>4&&void 0!==arguments[4]?arguments[4]:"";if(!this.isAuth())throw new Error("Authentication required to review pull requests");const a=Date.now();this.logger.apiCall("POST","/repos/".concat(e,"/").concat(t,"/pulls/").concat(o,"/reviews"),{event:r,bodyLength:null===s||void 0===s?void 0:s.length});try{const n={owner:e,repo:t,pull_number:o,event:r};s&&s.trim()&&(n.body=s);const i=await this.octokit.rest.pulls.createReview(n);return this.logger.apiResponse("POST","/repos/".concat(e,"/").concat(t,"/pulls/").concat(o,"/reviews"),i.status,Date.now()-a),{success:!0,review:{id:i.data.id,state:i.data.state,body:i.data.body,html_url:i.data.html_url,submitted_at:i.data.submitted_at,user:{login:i.data.user.login,avatar_url:i.data.user.avatar_url}}}}catch(n){throw this.logger.apiResponse("POST","/repos/".concat(e,"/").concat(t,"/pulls/").concat(o,"/reviews"),n.status||"error",Date.now()-a),console.error("Failed to create pull request review:",n),n}}async approvePullRequest(e,t,o){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:"";return this.createPullRequestReview(e,t,o,"APPROVE",r)}async requestPullRequestChanges(e,t,o,r){if(!r||!r.trim())throw new Error("A comment is required when requesting changes");return this.createPullRequestReview(e,t,o,"REQUEST_CHANGES",r)}async dismissPullRequestReview(e,t,o,r,s){if(!this.isAuth())throw new Error("Authentication required to dismiss reviews");const a=Date.now();this.logger.apiCall("PUT","/repos/".concat(e,"/").concat(t,"/pulls/").concat(o,"/reviews/").concat(r,"/dismissals"),{messageLength:null===s||void 0===s?void 0:s.length});try{const n=await this.octokit.rest.pulls.dismissReview({owner:e,repo:t,pull_number:o,review_id:r,message:s||"Review dismissed"});return this.logger.apiResponse("PUT","/repos/".concat(e,"/").concat(t,"/pulls/").concat(o,"/reviews/").concat(r,"/dismissals"),n.status,Date.now()-a),{success:!0,review:n.data}}catch(n){throw this.logger.apiResponse("PUT","/repos/".concat(e,"/").concat(t,"/pulls/").concat(o,"/reviews/").concat(r,"/dismissals"),n.status||"error",Date.now()-a),console.error("Failed to dismiss pull request review:",n),n}}}}}]);