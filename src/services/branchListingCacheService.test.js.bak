/**
 * Branch Listing Cache Service Tests
 */

// Mock logger to avoid localStorage conflicts
jest.mock('../utils/logger', () => ({
  __esModule: true,
  default: {
    getLogger: jest.fn(() => ({
      debug: jest.fn(),
      info: jest.fn(),
      warn: jest.fn(),
      error: jest.fn(),
      cache: jest.fn()
    }))
  }
}));

import branchListingCacheService from './branchListingCacheService';

// Mock localStorage
let mockLocalStorage = {};

const localStorageMock = (() => {
  let store = {};
  
  return {
    getItem(key) {
      console.log('getItem called with key:', key, 'found:', key in store);
      return store[key] || null;
    },
    setItem(key, value) {
      console.log('setItem called with key:', key, 'value length:', value.length);
      // Simulate storage quota exceeded for specific test
      if (store._simulateQuotaExceeded) {
        delete store._simulateQuotaExceeded;
        throw new Error('Storage quota exceeded');
      }
      store[key] = value;
      console.log('store after setItem:', Object.keys(store));
    },
    removeItem(key) {
      delete store[key];
    },
    clear() {
      store = {};
    },
    get length() {
      return Object.keys(store).length;
    },
    key(index) {
      return Object.keys(store)[index] || null;
    },
    // For testing
    _getStore() {
      return store;
    },
    _setStore(newStore) {
      store = newStore;
    }
  };
})();

// Create spies for the mock methods
const setItemSpy = jest.spyOn(localStorageMock, 'setItem');
const getItemSpy = jest.spyOn(localStorageMock, 'getItem');
const removeItemSpy = jest.spyOn(localStorageMock, 'removeItem');

Object.defineProperty(global, 'localStorage', {
  value: localStorageMock,
  writable: true
});

describe('BranchListingCacheService', () => {
  const testOwner = 'litlfred';
  const testRepo = 'sgex';
  const testBranches = [
    { name: 'main', commit: { sha: 'abc123' } },
    { name: 'feature-branch', commit: { sha: 'def456' } }
  ];
  const testPRs = [
    { id: 1, number: 123, title: 'Test PR', state: 'open' },
    { id: 2, number: 124, title: 'Another PR', state: 'closed' }
  ];

  beforeEach(() => {
    localStorageMock.clear();
    jest.clearAllMocks();
  });

  describe('Cache Key Generation', () => {
    test('should generate correct cache key', () => {
      const key = branchListingCacheService.getCacheKey(testOwner, testRepo);
      expect(key).toBe('sgex_branch_listing_cache_litlfred_sgex');
    });
  });

  describe('Cache Expiry', () => {
    test('should detect stale cache (older than 5 minutes)', () => {
      const now = Date.now();
      const fiveMinutesAgo = now - (5 * 60 * 1000);
      const sixMinutesAgo = now - (6 * 60 * 1000);

      expect(branchListingCacheService.isStale(fiveMinutesAgo)).toBe(false);
      expect(branchListingCacheService.isStale(sixMinutesAgo)).toBe(true);
    });
  });

  describe('Cache Operations', () => {
    test('should cache and retrieve data successfully', () => {
      // Cache data
      const result = branchListingCacheService.setCachedData(
        testOwner, 
        testRepo, 
        testBranches, 
        testPRs
      );
      expect(result).toBe(true);

      // Debug: Check what's in localStorage and if setItem was called
      const cacheKey = branchListingCacheService.getCacheKey(testOwner, testRepo);
      console.log('Cache key:', cacheKey);
      console.log('setItem calls:', setItemSpy.mock.calls);
      console.log('localStorageStore:', localStorageMock._getStore());
      
      const rawData = localStorageMock.getItem(cacheKey);
      console.log('Raw localStorage data:', rawData);
      
      if (rawData) {
        const parsedData = JSON.parse(rawData);
        console.log('Parsed data:', parsedData);
      }

      // Retrieve cached data
      const cached = branchListingCacheService.getCachedData(testOwner, testRepo);
      expect(cached).not.toBeNull();
      expect(cached.branches).toEqual(testBranches);
      expect(cached.pullRequests).toEqual(testPRs);
      expect(cached.owner).toBe(testOwner);
      expect(cached.repo).toBe(testRepo);
      expect(cached.timestamp).toBeCloseTo(Date.now(), -2); // Within 100ms
    });

    test('should return null for non-existent cache', () => {
      const cached = branchListingCacheService.getCachedData('nonexistent', 'repo');
      expect(cached).toBeNull();
    });

    test('should return null and remove stale cache', () => {
      // Mock old timestamp (6 minutes ago)
      const oldTimestamp = Date.now() - (6 * 60 * 1000);
      const staleData = {
        branches: testBranches,
        pullRequests: testPRs,
        timestamp: oldTimestamp,
        owner: testOwner,
        repo: testRepo
      };
      
      const cacheKey = branchListingCacheService.getCacheKey(testOwner, testRepo);
      mockLocalStorage[cacheKey] = JSON.stringify(staleData);

      // Should return null and remove stale cache
      const cached = branchListingCacheService.getCachedData(testOwner, testRepo);
      expect(cached).toBeNull();
      expect(removeItemSpy).toHaveBeenCalledWith(cacheKey);
    });

    test('should clear specific cache', () => {
      // Set cache
      branchListingCacheService.setCachedData(testOwner, testRepo, testBranches, testPRs);
      
      // Clear cache
      const result = branchListingCacheService.clearCache(testOwner, testRepo);
      expect(result).toBe(true);
      
      // Verify cache is gone
      const cached = branchListingCacheService.getCachedData(testOwner, testRepo);
      expect(cached).toBeNull();
    });

    test('should clear all caches', () => {
      // Set multiple caches
      branchListingCacheService.setCachedData('owner1', 'repo1', testBranches, testPRs);
      branchListingCacheService.setCachedData('owner2', 'repo2', testBranches, testPRs);
      
      // Clear all caches
      const result = branchListingCacheService.clearAllCaches();
      expect(result).toBe(true);
      
      // Verify all caches are gone
      expect(branchListingCacheService.getCachedData('owner1', 'repo1')).toBeNull();
      expect(branchListingCacheService.getCachedData('owner2', 'repo2')).toBeNull();
    });
  });

  describe('Cache Info', () => {
    test('should provide correct cache info for existing cache', () => {
      branchListingCacheService.setCachedData(testOwner, testRepo, testBranches, testPRs);
      
      const info = branchListingCacheService.getCacheInfo(testOwner, testRepo);
      expect(info.exists).toBe(true);
      expect(info.stale).toBe(false);
      expect(info.branchCount).toBe(2);
      expect(info.prCount).toBe(2);
      expect(info.ageMinutes).toBe(0);
    });

    test('should provide correct cache info for non-existent cache', () => {
      const info = branchListingCacheService.getCacheInfo('nonexistent', 'repo');
      expect(info.exists).toBe(false);
      expect(info.stale).toBe(true);
    });
  });

  describe('Force Refresh', () => {
    test('should clear cache when force refresh is called', () => {
      // Set cache
      branchListingCacheService.setCachedData(testOwner, testRepo, testBranches, testPRs);
      expect(branchListingCacheService.getCachedData(testOwner, testRepo)).not.toBeNull();
      
      // Force refresh
      const result = branchListingCacheService.forceRefresh(testOwner, testRepo);
      expect(result).toBe(true);
      
      // Verify cache is cleared
      expect(branchListingCacheService.getCachedData(testOwner, testRepo)).toBeNull();
    });
  });

  describe('Error Handling', () => {
    test('should handle localStorage errors gracefully', () => {
      // Trigger storage quota exceeded error 
      localStorageMock._getStore()._simulateQuotaExceeded = true;

      const result = branchListingCacheService.setCachedData(
        testOwner, 
        testRepo, 
        testBranches, 
        testPRs
      );
      expect(result).toBe(false);
    });

    test('should handle JSON parsing errors gracefully', () => {
      // Set invalid JSON in cache
      const cacheKey = branchListingCacheService.getCacheKey(testOwner, testRepo);
      mockLocalStorage[cacheKey] = 'invalid json';

      const cached = branchListingCacheService.getCachedData(testOwner, testRepo);
      expect(cached).toBeNull();
    });
  });
});