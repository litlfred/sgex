"use strict";(self.webpackChunksgex_workbench=self.webpackChunksgex_workbench||[]).push([[6309],{18354:(t,e,r)=>{r.r(e),r.d(e,{default:()=>o});const o=new class{constructor(){this.storageKey="sgex_branch_context"}getRepositoryKey(t){var e,r;if(!t||!t.name)return null;const o=(null===(e=t.owner)||void 0===e?void 0:e.login)||(null===(r=t.full_name)||void 0===r?void 0:r.split("/")[0]);return o?"".concat(o,"/").concat(t.name):null}getSelectedBranch(t){if(!t)return null;try{const e=this.getBranchContext();return e[this.getRepositoryKey(t)]||null}catch(e){return console.warn("Failed to get branch context:",e),null}}setSelectedBranch(t,e){if(t&&e)try{const r=this.getBranchContext();r[this.getRepositoryKey(t)]=e,this.setBranchContext(r)}catch(r){console.warn("Failed to set branch context:",r)}}clearRepositoryBranch(t){if(t)try{const e=this.getBranchContext();delete e[this.getRepositoryKey(t)],this.setBranchContext(e)}catch(e){console.warn("Failed to clear repository branch context:",e)}}clearAllBranchContext(){try{sessionStorage.removeItem(this.storageKey)}catch(t){console.warn("Failed to clear branch context:",t)}}getBranchContext(){try{const t=sessionStorage.getItem(this.storageKey);return t?JSON.parse(t):{}}catch(t){return console.warn("Failed to parse branch context from storage:",t),{}}}setBranchContext(t){try{sessionStorage.setItem(this.storageKey,JSON.stringify(t))}catch(e){console.warn("Failed to save branch context to storage:",e)}}getDefaultBranchName(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:[];return t?e.some(t=>"main"===t.name)?"main":t.default_branch&&e.some(e=>e.name===t.default_branch)?t.default_branch:e.length>0?e[0].name:"main":"main"}hasBranchContext(t){return null!==this.getSelectedBranch(t)}getBranchDisplayInfo(t){const e=this.getSelectedBranch(t);if(!e)return null;const r=e===((null===t||void 0===t?void 0:t.default_branch)||"main");return{branch:e,isDefault:r,displayText:r?"".concat(e," (default)"):e}}}},46901:(t,e,r)=>{r.d(e,{A:()=>l});var o=r(89379),s=r(57335);async function a(t,e){let r=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};const{concurrency:o=5,onProgress:s=null,onItemComplete:a=null,onItemStart:n=null}=r;if(!t||0===t.length)return[];const i=new Array(t.length),c=t.length;let l=0;const h=t.map((t,e)=>({item:t,index:e})),u=Array(Math.min(o,t.length)).fill().map(()=>(async()=>{for(;h.length>0;){const{item:r,index:o}=h.shift();n&&n(r,o);try{const t=await e(r,o);i[o]=t,l++,s&&s(l,c,r,t),a&&a(r,t,null)}catch(t){i[o]={error:t,item:r},l++,s&&s(l,c,r,null),a&&a(r,null,t)}}})());return await Promise.all(u),i}const n=new class{constructor(){let t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:30;this.cache=new Map,this.ttl=60*t*1e3}_getCacheKey(t,e){return"".concat(t,"/").concat(e)}_isValid(t){return Date.now()-t.timestamp<this.ttl}get(t,e){const r=this._getCacheKey(t,e),o=this.cache.get(r);return o?this._isValid(o)?o.compatible:(this.cache.delete(r),null):null}set(t,e,r){const o=this._getCacheKey(t,e);this.cache.set(o,{compatible:r,timestamp:Date.now()})}clear(){this.cache.clear()}cleanup(){const t=Date.now();for(const[e,r]of this.cache.entries())t-r.timestamp>=this.ttl&&this.cache.delete(e)}getStats(){return this.cleanup(),{size:this.cache.size,ttlMinutes:this.ttl/6e4,entries:Array.from(this.cache.entries()).map(t=>{let[e,r]=t;return{repository:e,compatible:r.compatible,ageMinutes:Math.round((Date.now()-r.timestamp)/6e4)}})}}};var i=r(78723),c=r(85571);const l=new class{constructor(){this.octokit=null,this.isAuthenticated=!1,this.permissions=null,this.tokenType=null,this.logger=c.A.getLogger("GitHubService"),this.logger.debug("GitHubService instance created")}async createOctokitInstance(){let t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:null;return new(await(0,s.sN)())(t?{auth:t}:{})}async authenticate(t){const e=Date.now();this.logger.auth("Starting authentication",{tokenProvided:!!t,tokenMask:t?i.A.maskToken(t):"none"});try{const r=i.A.validateTokenFormat(t);if(!r.isValid)return this.logger.warn("Token validation failed during authentication",{reason:r.reason,tokenMask:i.A.maskToken(t)}),this.isAuthenticated=!1,!1;this.octokit=await this.createOctokitInstance(r.token),this.isAuthenticated=!0,this.tokenType=r.type;const o=i.A.storeToken(r.token);o||this.logger.warn("Failed to store token securely, authentication will not persist");const s=Date.now()-e;return this.logger.auth("Authentication successful",{duration:s,tokenType:this.tokenType,tokenMask:i.A.maskToken(t),securelyStored:o}),this.logger.performance("GitHub authentication",s),!0}catch(r){const o=Date.now()-e;return this.logger.auth("Authentication failed",{error:r.message,duration:o,tokenMask:i.A.maskToken(t)}),console.error("Failed to authenticate with GitHub:",r),this.isAuthenticated=!1,i.A.clearToken(),!1}}authenticateWithOctokit(t){this.logger.auth("Starting OAuth authentication with Octokit instance");try{return this.octokit=t,this.isAuthenticated=!0,this.tokenType="oauth",this.logger.auth("OAuth authentication successful",{tokenType:this.tokenType}),!0}catch(e){return this.logger.auth("OAuth authentication failed",{error:e.message}),console.error("Failed to authenticate with Octokit instance:",e),this.isAuthenticated=!1,!1}}async initializeFromStoredToken(){this.logger.auth("Attempting to initialize from stored token");try{i.A.migrateLegacyToken()&&this.logger.debug("Successfully migrated legacy token to secure storage");const t=i.A.retrieveToken();return t?(this.octokit=await this.createOctokitInstance(t.token),this.isAuthenticated=!0,this.tokenType=t.type,this.logger.auth("Successfully initialized from stored token",{tokenType:this.tokenType,tokenMask:i.A.maskToken(t.token),expires:new Date(t.expires).toISOString()}),!0):(this.logger.debug("No valid stored token found"),!1)}catch(t){return this.logger.auth("Failed to initialize from stored token",{error:t.message}),this.isAuthenticated=!1,i.A.clearToken(),!1}}hasStoredToken(){return i.A.hasValidToken()}getStoredTokenInfo(){return i.A.getTokenInfo()}async checkTokenPermissions(){if(!this.isAuth()){const t=new Error("Not authenticated with GitHub");throw this.logger.error("Token permission check failed - not authenticated"),t}const t=Date.now();this.logger.apiCall("GET","/user",null);try{const r=await this.octokit.request("GET /user");this.logger.apiResponse("GET","/user",r.status,Date.now()-t);try{const t=Date.now();this.logger.apiCall("GET","/rate_limit",null);const e=await this.octokit.rest.rateLimit.get();this.logger.apiResponse("GET","/rate_limit",e.status,Date.now()-t),this.tokenType=e.data.resources.core?"classic":"fine-grained",this.logger.debug("Token type determined",{tokenType:this.tokenType,hasCore:!!e.data.resources.core})}catch(e){this.tokenType="unknown",this.logger.warn("Could not determine token type from rate limit",{error:e.message})}const o={type:this.tokenType,user:r.data};return this.permissions=o,this.logger.debug("Token permissions checked successfully",{tokenType:this.tokenType,username:r.data.login}),o}catch(r){const e=Date.now()-t;throw this.logger.apiError("GET","/user",r),this.logger.performance("Token permission check (failed)",e),console.error("Failed to check token permissions:",r),r}}async checkRepositoryWritePermissions(t,e){if(!this.isAuth())return this.logger.warn("Cannot check repository write permissions - not authenticated",{owner:t,repo:e}),!1;const r=Date.now();this.logger.debug("Checking write permissions for repository",{owner:t,repo:e});try{const o=(await this.getCurrentUser()).login;this.logger.apiCall("GET","/repos/".concat(t,"/").concat(e,"/collaborators/").concat(o,"/permission"),null);const{data:s}=await this.octokit.rest.repos.getCollaboratorPermissionLevel({owner:t,repo:e,username:o}),a=Date.now()-r;this.logger.apiResponse("GET","/repos/".concat(t,"/").concat(e,"/collaborators/").concat(o,"/permission"),200,a);const n=["write","maintain","admin"].includes(s.permission);return this.logger.debug("Repository write permissions checked",{owner:t,repo:e,permission:s.permission,hasWriteAccess:n,supportedLevels:["write","maintain","admin"]}),n}catch(a){var o,s;const n=Date.now()-r;return this.logger.apiError("GET","/repos/".concat(t,"/").concat(e,"/collaborators/*/permission"),a),this.logger.performance("Repository write permission check (failed)",n),console.warn("Could not check repository write permissions for ".concat(t,"/").concat(e,":"),{error:a.message,status:a.status,statusText:null===(o=a.response)||void 0===o?void 0:o.statusText,headers:null===(s=a.response)||void 0===s?void 0:s.headers}),this.logger.warn("Assuming no write access due to permission check failure",{owner:t,repo:e,error:a.message,status:a.status,userGuidance:"Check if your Personal Access Token has the required scopes: repo (classic) or Contents+Pull requests (fine-grained)"}),!1}}async checkRepositoryPermissions(t,e){return this.checkRepositoryWritePermissions(t,e)}async checkCommentPermissions(t,e){if(!this.isAuth())return this.logger.warn("Cannot check comment permissions - not authenticated",{owner:t,repo:e}),!1;const r=Date.now();this.logger.debug("Checking comment permissions for repository",{owner:t,repo:e});try{this.logger.apiCall("GET","/repos/".concat(t,"/").concat(e,"/issues"),{per_page:1}),await this.octokit.rest.issues.listForRepo({owner:t,repo:e,per_page:1,state:"all"});const o=Date.now()-r;return this.logger.apiResponse("GET","/repos/".concat(t,"/").concat(e,"/issues"),200,o),this.logger.debug("Issues endpoint accessible - comment permissions likely available",{owner:t,repo:e}),!0}catch(o){const s=Date.now()-r;return this.logger.apiError("GET","/repos/".concat(t,"/").concat(e,"/issues"),o),this.logger.performance("Comment permission check (failed)",s),403===o.status||401===o.status?(this.logger.warn("Token does not have permission to access issues/comments",{owner:t,repo:e,error:o.message,status:o.status}),!1):(this.logger.warn("Could not determine comment permissions, assuming available",{owner:t,repo:e,error:o.message}),!0)}}isAuth(){return this.isAuthenticated&&null!==this.octokit}async getCurrentUser(){if(!this.isAuth())throw new Error("Not authenticated with GitHub");try{const{data:t}=await this.octokit.rest.users.getAuthenticated();return t}catch(t){throw console.error("Failed to fetch user data:",t),t}}async getUserOrganizations(){if(!this.isAuth())throw new Error("Not authenticated with GitHub");try{const{data:t}=await this.octokit.rest.orgs.listForAuthenticatedUser();return t}catch(t){throw console.error("Failed to fetch organizations:",t),t}}async getOrganization(t){try{const e=this.octokit||await this.createOctokitInstance(),{data:r}=await e.rest.orgs.get({org:t});return r}catch(e){throw console.error("Failed to fetch organization ".concat(t,":"),e),e}}async getUser(t){try{const e=this.octokit||await this.createOctokitInstance(),{data:r}=await e.rest.users.getByUsername({username:t});return r}catch(e){throw console.error("Failed to fetch user ".concat(t,":"),e),e}}async getPublicRepositories(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"user";try{const r=this.octokit||await this.createOctokitInstance();let o=[],s=1,a=!0;for(;a;){let n;n="user"===e?await r.rest.repos.listForUser({username:t,sort:"updated",per_page:100,page:s}):await r.rest.repos.listForOrg({org:t,sort:"updated",per_page:100,page:s}),o=o.concat(n.data),a=100===n.data.length,s++}return o}catch(r){throw console.error("Failed to fetch public repositories for ".concat(t,":"),r),r}}async getWHOOrganization(){try{const t=await this.getOrganization("WorldHealthOrganization");return{id:t.id,login:t.login,display_name:t.name||"World Health Organization",description:t.description||"The World Health Organization is a specialized agency of the United Nations responsible for international public health.",avatar_url:t.avatar_url,html_url:t.html_url,type:"Organization",permissions:{can_create_repositories:!0,can_create_private_repositories:!0},plan:{name:"Organization",private_repos:"unlimited"},isWHO:!0}}catch(t){return console.warn("Could not fetch WHO organization data from API, using fallback:",t),{id:"who-organization",login:"WorldHealthOrganization",display_name:"World Health Organization",description:"The World Health Organization is a specialized agency of the United Nations responsible for international public health.",avatar_url:"https://avatars.githubusercontent.com/u/12261302?s=200&v=4",html_url:"https://github.com/WorldHealthOrganization",type:"Organization",permissions:{can_create_repositories:!0,can_create_private_repositories:!0},plan:{name:"Organization",private_repos:"unlimited"},isWHO:!0}}}async checkRateLimit(){try{const t=this.octokit||await this.createOctokitInstance(),{data:e}=await t.rest.rateLimit.get();return{core:{limit:e.rate.limit,remaining:e.rate.remaining,reset:e.rate.reset,used:e.rate.used},search:{limit:e.search.limit,remaining:e.search.remaining,reset:e.search.reset,used:e.search.used},isAuthenticated:this.isAuthenticated}}catch(t){return console.warn("Could not check rate limit:",t),{core:{limit:this.isAuthenticated?5e3:60,remaining:0,reset:Date.now()+36e5,used:this.isAuthenticated?5e3:60},search:{limit:this.isAuthenticated?30:10,remaining:0,reset:Date.now()+6e4,used:this.isAuthenticated?30:10},isAuthenticated:this.isAuthenticated}}}async shouldSkipApiCalls(){if(this.isAuthenticated)return!1;try{const t=(await this.checkRateLimit()).core.remaining;return t<10&&(console.warn("\ud83d\udeab Rate limit protection: Only ".concat(t," API calls remaining, skipping compatibility checks")),!0)}catch(t){return console.warn("\u26a0\ufe0f Cannot check rate limits, enabling conservative mode"),!this.isAuthenticated}}async getRepositories(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"user";return this.getSmartGuidelinesRepositories(t,e)}async checkSmartGuidelinesCompatibility(t,e){let r=arguments.length>2&&void 0!==arguments[2]?arguments[2]:2;const o=n.get(t,e);if(null!==o)return{compatible:o,cached:!0};if(!this.isAuthenticated)try{if(await this.shouldSkipApiCalls())return console.warn("\u26a1 Skipping compatibility check for ".concat(t,"/").concat(e," due to rate limit protection")),{compatible:!1,skipped:!0,reason:"Rate limit protection - API call skipped"}}catch(s){console.warn("Could not check rate limits, proceeding with API call:",s)}try{const r=this.octokit||await this.createOctokitInstance(),{data:o}=await r.rest.repos.getContent({owner:t,repo:e,path:"sushi-config.yaml"});if("file"===o.type&&o.content){const r=decodeURIComponent(escape(atob(o.content))).includes("smart.who.int.base");return n.set(t,e,r),{compatible:r}}return n.set(t,e,!1),{compatible:!1,reason:"No sushi-config.yaml file found"}}catch(a){if(404===a.status&&r>0){console.warn("File not found for ".concat(t,"/").concat(e,", retrying... (").concat(r," attempts left)"));const o=1e3;return await new Promise(t=>setTimeout(t,o)),this.checkSmartGuidelinesCompatibility(t,e,r-1)}if(403===a.status&&a.message.includes("SAML enforcement")&&this.octokit){console.log("SAML-protected repository ".concat(t,"/").concat(e,", trying public API fallback"));try{const r=await this.createOctokitInstance(),{data:o}=await r.rest.repos.getContent({owner:t,repo:e,path:"sushi-config.yaml"});if("file"===o.type&&o.content){const r=decodeURIComponent(escape(atob(o.content)));return r.includes("smart.who.int.base")?(console.log("Repository ".concat(t,"/").concat(e," is compatible via public API despite SAML protection")),n.set(t,e,!0),{compatible:!0,reason:"SMART Guidelines DAK (SAML-protected, verified via public API)",requiresAuthentication:!0}):(n.set(t,e,!1),{compatible:!1,reason:"No smart.who.int.base dependency found (via public API)"})}}catch(i){console.warn("Public API fallback also failed for ".concat(t,"/").concat(e,":"),i.message)}}const o={compatible:!1,error:a.message,errorType:this._categorizeError(a),status:a.status,retryable:this._isRetryableError(a)};return 404!==a.status&&console.warn("Failed to check ".concat(t,"/").concat(e," for sushi-config.yaml with smart.who.int.base dependency:"),a.message),n.set(t,e,!1),o}}_categorizeError(t){return 403===t.status?t.message.includes("rate limit")?"rate_limit":"permission_denied":404===t.status?"not_found":401===t.status?"authentication_failed":"ENOTFOUND"===t.code||"ECONNRESET"===t.code?"network_error":"unknown_error"}_isRetryableError(t){return["rate_limit","network_error"].includes(this._categorizeError(t))}async getSmartGuidelinesRepositories(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"user",r=arguments.length>2&&void 0!==arguments[2]&&arguments[2];try{let s=[];if(this.isAuth()){let r=1,o=!0;for(;o;){let a;a="user"===e?await this.octokit.rest.repos.listForUser({username:t,sort:"updated",per_page:100,page:r}):await this.octokit.rest.repos.listForOrg({org:t,sort:"updated",per_page:100,page:r}),s=s.concat(a.data),o=100===a.data.length,r++}}else s=await this.getPublicRepositories(t,e);if(r)return console.log("\u26a1 Skipping compatibility checks for ".concat(s.length," repositories to avoid rate limiting")),s.map(t=>(0,o.A)((0,o.A)({},t),{},{smart_guidelines_compatible:!0}));const a=[];for(const t of s){(await this.checkSmartGuidelinesCompatibility(t.owner.login,t.name)).compatible&&a.push((0,o.A)((0,o.A)({},t),{},{smart_guidelines_compatible:!0}))}return a}catch(s){throw console.error("Failed to fetch SMART guidelines repositories:",s),s}}async getSmartGuidelinesRepositoriesProgressive(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"user",r=arguments.length>2&&void 0!==arguments[2]?arguments[2]:null,s=arguments.length>3&&void 0!==arguments[3]?arguments[3]:null,n=arguments.length>4&&void 0!==arguments[4]?arguments[4]:null;try{let i=[],c=1,l=!0;if(this.isAuth())for(;l;){let r;r="user"===e?await this.octokit.rest.repos.listForUser({username:t,sort:"updated",per_page:100,page:c}):await this.octokit.rest.repos.listForOrg({org:t,sort:"updated",per_page:100,page:c}),i=i.concat(r.data),l=100===r.data.length,c++}else i=await this.getPublicRepositories(t,e);if(0===i.length)return console.log("\ud83d\udcca No repositories found for user, completing scan immediately"),s&&s({current:0,total:0,currentRepo:"none",progress:100,completed:!0}),[];const h={rateLimited:[],networkErrors:[],permissionDenied:[],otherErrors:[],totalErrors:0,totalScanned:0},u=async(t,e)=>{await new Promise(t=>setTimeout(t,100+200*Math.random()));const s=await this.checkSmartGuidelinesCompatibility(t.owner.login,t.name);if(h.totalScanned++,s.compatible){const e=(0,o.A)((0,o.A)({},t),{},{smart_guidelines_compatible:!0});return r&&r(e),e}if(s.error){h.totalErrors++;const e={repo:t.name,error:s.error,errorType:s.errorType,retryable:s.retryable};switch(s.errorType){case"rate_limit":h.rateLimited.push(e);break;case"network_error":h.networkErrors.push(e);break;case"permission_denied":h.permissionDenied.push(e);break;default:h.otherErrors.push(e)}n&&n(e)}return null},g=(await a(i,u,{concurrency:5,onProgress:(t,e,r,o)=>{if(s){const o={current:t,total:e,currentRepo:r.name,progress:Math.round(t/e*100),completed:!0,scanningErrors:h.totalErrors>0?{totalErrors:h.totalErrors,rateLimitedCount:h.rateLimited.length,networkErrorCount:h.networkErrors.length,hasRetryableErrors:[...h.rateLimited,...h.networkErrors].some(t=>t.retryable)}:null};s(o)}},onItemStart:(t,e)=>{s&&s({current:e+1,total:i.length,currentRepo:t.name,progress:Math.round((e+1)/i.length*100),completed:!1,started:!0})}})).filter(t=>null!==t&&!t.error);return h.totalErrors>0&&(console.warn("Repository scanning completed with ".concat(h.totalErrors," errors out of ").concat(h.totalScanned," repositories checked:")),h.rateLimited.length>0&&console.warn("- Rate limited: ".concat(h.rateLimited.length," repositories")),h.networkErrors.length>0&&console.warn("- Network errors: ".concat(h.networkErrors.length," repositories")),h.permissionDenied.length>0&&console.warn("- Permission denied: ".concat(h.permissionDenied.length," repositories")),h.otherErrors.length>0&&console.warn("- Other errors: ".concat(h.otherErrors.length," repositories"))),{repositories:g,scanningErrors:h.totalErrors>0?h:null}}catch(i){throw console.error("Failed to fetch SMART guidelines repositories:",i),i}}async getRepository(t,e){try{const r=this.isAuth()?this.octokit:await this.createOctokitInstance(),{data:o}=await r.rest.repos.get({owner:t,repo:e});return o}catch(r){throw console.error("Failed to fetch repository:",r),r}}async getBranches(t,e){try{console.log("githubService.getBranches: Fetching branches for ".concat(t,"/").concat(e)),console.log("githubService.getBranches: Authentication status:",this.isAuth());const r=this.isAuth()?this.octokit:await this.createOctokitInstance();console.log("githubService.getBranches: Using",this.isAuth()?"authenticated":"public","octokit instance");const{data:o}=await r.rest.repos.listBranches({owner:t,repo:e,per_page:100});return console.log("githubService.getBranches: Successfully fetched ".concat(o.length," branches")),o}catch(r){throw console.error("githubService.getBranches: Failed to fetch branches:",r),console.error("githubService.getBranches: Error details:",{status:r.status,message:r.message,owner:t,repo:e}),r}}async createBranch(t,e,r){let o=arguments.length>3&&void 0!==arguments[3]?arguments[3]:"main";if(!this.isAuth())throw new Error("Not authenticated with GitHub");try{const{data:s}=await this.octokit.rest.git.getRef({owner:t,repo:e,ref:"heads/".concat(o)}),{data:a}=await this.octokit.rest.git.createRef({owner:t,repo:e,ref:"refs/heads/".concat(r),sha:s.object.sha});return a}catch(s){throw console.error("Failed to create branch:",s),s}}async getBranch(t,e,r){try{const o=this.isAuth()?this.octokit:await this.createOctokitInstance(),{data:s}=await o.rest.repos.getBranch({owner:t,repo:e,branch:r});return s}catch(o){throw console.error("Failed to fetch branch:",o),o}}async getWorkflows(t,e){if(!this.isAuth())throw new Error("Not authenticated with GitHub");try{const{data:r}=await this.octokit.rest.actions.listRepoWorkflows({owner:t,repo:e});return r.workflows.map(t=>({id:t.id,name:t.name,filename:t.path.split("/").pop(),path:t.path,state:t.state,created_at:t.created_at,updated_at:t.updated_at,url:t.html_url,triggers:["unknown"],lastModified:t.updated_at}))}catch(r){if(404===r.status)return[];throw console.error("Failed to fetch workflows:",r),r}}async getWorkflowRuns(t,e){let r=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};if(!this.isAuth())throw new Error("Not authenticated with GitHub");try{const o={owner:t,repo:e,per_page:r.per_page||10,page:r.page||1};r.branch&&(o.branch=r.branch),r.workflow_id&&(o.workflow_id=r.workflow_id);const{data:s}=await this.octokit.rest.actions.listWorkflowRunsForRepo(o);return s}catch(o){throw console.error("Failed to fetch workflow runs:",o),o}}async getWorkflowRunsForWorkflow(t,e,r){let o=arguments.length>3&&void 0!==arguments[3]?arguments[3]:{};if(!this.isAuth())throw new Error("Not authenticated with GitHub");try{const s={owner:t,repo:e,workflow_id:r,per_page:o.per_page||10,page:o.page||1};o.branch&&(s.branch=o.branch);const{data:a}=await this.octokit.rest.actions.listWorkflowRuns(s);return a}catch(s){throw console.error("Failed to fetch workflow runs for workflow:",s),s}}async triggerWorkflow(t,e,r){let o=arguments.length>3&&void 0!==arguments[3]?arguments[3]:"main",s=arguments.length>4&&void 0!==arguments[4]?arguments[4]:{};if(!this.isAuth())throw new Error("Not authenticated with GitHub");try{const{data:a}=await this.octokit.rest.actions.createWorkflowDispatch({owner:t,repo:e,workflow_id:r,ref:o,inputs:s});return a}catch(a){throw console.error("Failed to trigger workflow:",a),a}}async rerunWorkflow(t,e,r){if(!this.isAuth())throw new Error("Not authenticated with GitHub");try{const{data:o}=await this.octokit.rest.actions.reRunWorkflow({owner:t,repo:e,run_id:r});return o}catch(o){throw console.error("Failed to re-run workflow:",o),o}}async getWorkflowRunLogs(t,e,r){if(!this.isAuth())throw new Error("Not authenticated with GitHub");try{const{data:o}=await this.octokit.rest.actions.downloadWorkflowRunLogs({owner:t,repo:e,run_id:r});return o}catch(o){throw console.error("Failed to get workflow run logs:",o),o}}async approveWorkflowRun(t,e,r){if(!this.isAuth())throw new Error("Not authenticated with GitHub");try{const{data:o}=await this.octokit.rest.actions.approveWorkflowRun({owner:t,repo:e,run_id:r});return o}catch(o){throw console.error("Failed to approve workflow run:",o),o}}async getCommitDiff(t,e,r,o){if(!this.isAuth())throw new Error("Not authenticated with GitHub");try{const{data:s}=await this.octokit.rest.repos.compareCommits({owner:t,repo:e,base:r,head:o});return s}catch(s){throw console.error("Failed to get commit diff:",s),s}}async getCommit(t,e,r){if(!this.isAuth())throw new Error("Not authenticated with GitHub");try{const{data:o}=await this.octokit.rest.repos.getCommit({owner:t,repo:e,ref:r});return o}catch(o){throw console.error("Failed to get commit details:",o),o}}async getReleases(t,e){let r=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};if(!this.isAuth())throw new Error("Not authenticated with GitHub");try{const{data:o}=await this.octokit.rest.repos.listReleases({owner:t,repo:e,per_page:r.per_page||10,page:r.page||1});return o}catch(o){throw console.error("Failed to fetch releases:",o),o}}async getLatestRelease(t,e){if(!this.isAuth())throw new Error("Not authenticated with GitHub");try{const{data:r}=await this.octokit.rest.repos.getLatestRelease({owner:t,repo:e});return r}catch(r){throw console.error("Failed to fetch latest release:",r),r}}async getBpmnFilesRecursive(t,e,r){let o=arguments.length>3&&void 0!==arguments[3]?arguments[3]:"main",s=arguments.length>4&&void 0!==arguments[4]?arguments[4]:[];try{console.log("\ud83d\udd0e githubService.getBpmnFilesRecursive: Searching ".concat(t,"/").concat(e,"/").concat(r," (ref: ").concat(o,")"));const a=this.isAuth()?this.octokit:await this.createOctokitInstance();console.log("\ud83d\udd10 githubService.getBpmnFilesRecursive: Using ".concat(this.isAuth()?"authenticated":"public"," octokit"));const{data:n}=await a.rest.repos.getContent({owner:t,repo:e,path:r,ref:o});if(console.log("\ud83d\udce6 githubService.getBpmnFilesRecursive: Received data type: ".concat(Array.isArray(n)?"array":"single file",", length: ").concat(Array.isArray(n)?n.length:1)),!Array.isArray(n))return n.name.endsWith(".bpmn")&&(console.log("\ud83d\udcc4 githubService.getBpmnFilesRecursive: Found single BPMN file: ".concat(n.name)),s.push(n)),s;for(const r of n)"file"===r.type&&r.name.endsWith(".bpmn")?(console.log("\ud83d\udcc4 githubService.getBpmnFilesRecursive: Found BPMN file: ".concat(r.name)),s.push(r)):"dir"===r.type&&(console.log("\ud83d\udcc1 githubService.getBpmnFilesRecursive: Found subdirectory: ".concat(r.name,", recursing...")),await this.getBpmnFilesRecursive(t,e,r.path,o,s));return console.log("\u2705 githubService.getBpmnFilesRecursive: Completed search of ".concat(r,", found ").concat(s.length," total files so far")),s}catch(a){if(console.log("\u274c githubService.getBpmnFilesRecursive: Error searching ".concat(r,":"),a.status,a.message),404===a.status)return s;throw a}}async getBpmnFiles(t,e){let r=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"main";console.log("\ud83d\udd0d githubService.getBpmnFiles: Starting search for ".concat(t,"/").concat(e," (ref: ").concat(r,")"));const o=[],s=["input/business-processes","input/business-process"];for(const i of s)try{console.log("\ud83d\udcc1 githubService.getBpmnFiles: Searching in directory: ".concat(i));const s=await this.getBpmnFilesRecursive(t,e,i,r);console.log("\u2705 githubService.getBpmnFiles: Found ".concat(s.length," BPMN files in ").concat(i)),o.push(...s)}catch(n){404!==n.status?console.warn("\u274c Could not fetch BPMN files from ".concat(i,":"),n.message):console.log("\ud83d\udcc2 githubService.getBpmnFiles: Directory ".concat(i," not found (404) - this is expected if the directory doesn't exist"))}const a=o.filter((t,e,r)=>e===r.findIndex(e=>e.path===t.path));return console.log("\ud83c\udfaf githubService.getBpmnFiles: Final result - ".concat(a.length," unique BPMN files found")),console.log("\ud83d\udccb githubService.getBpmnFiles: File list:",a.map(t=>t.name)),a}async getFileContent(t,e,r){let o=arguments.length>3&&void 0!==arguments[3]?arguments[3]:"main";const s=15e3;try{console.log("\ud83d\ude80 githubService.getFileContent: Starting request for ".concat(t,"/").concat(e,"/").concat(r," (ref: ").concat(o,")")),console.log("\ud83d\udd10 githubService.getFileContent: Authentication status:",this.isAuth()),console.log("\ud83d\udccb githubService.getFileContent: Request parameters:",{owner:t,repo:e,path:r,ref:o});const a=this.isAuth()?this.octokit:await this.createOctokitInstance();console.log("\ud83d\udd27 githubService.getFileContent: Using",this.isAuth()?"authenticated":"public","octokit instance");const i=new Promise((t,e)=>{console.log("\u23f0 githubService.getFileContent: Setting up ".concat(s,"ms timeout")),setTimeout(()=>{console.error("\u23f0 githubService.getFileContent: Request timed out after ".concat(s,"ms")),e(new Error("Request timeout after ".concat(s,"ms")))},s)});console.log("\ud83c\udf10 githubService.getFileContent: Creating GitHub API promise...");const c=a.rest.repos.getContent({owner:t,repo:e,path:r,ref:o});console.log("\ud83d\udce1 githubService.getFileContent: API request initiated, waiting for response...");const l=Date.now(),{data:h}=await Promise.race([c,i]),u=Date.now()-l;if(console.log("\u2705 githubService.getFileContent: API response received in ".concat(u,"ms")),console.log("\ud83d\udcc2 githubService.getFileContent: Response data type:",h.type),console.log("\ud83d\udcca githubService.getFileContent: Response details:",{type:h.type,name:h.name,size:h.size,encoding:h.encoding,hasContent:!!h.content}),"file"!==h.type||!h.content)throw console.error("\u274c githubService.getFileContent: Invalid response - not a file or no content"),console.error("\ud83d\udd0d githubService.getFileContent: Full response data:",JSON.stringify(h,null,2)),new Error("File not found or is not a file");console.log("\ud83d\udd27 githubService.getFileContent: Decoding base64 content..."),console.log("\ud83d\udcca githubService.getFileContent: Base64 content length:",h.content.length);try{const t=atob(h.content),e=decodeURIComponent(escape(t));return console.log("\u2705 githubService.getFileContent: Successfully fetched and decoded file content"),console.log("\ud83d\udccf githubService.getFileContent: Final content length:",e.length,"characters"),console.log("\ud83d\udc40 githubService.getFileContent: Content preview (first 200 chars):",e.substring(0,200)),e}catch(n){throw console.error("\u274c githubService.getFileContent: Base64 decoding failed:",n),console.error("\ud83d\udd0d githubService.getFileContent: Raw base64 content preview:",h.content.substring(0,100)),new Error("Failed to decode file content: ".concat(n.message))}}catch(i){var a;if(console.error("\ud83d\udca5 githubService.getFileContent: Failed to fetch file content from ".concat(t,"/").concat(e,"/").concat(r,":"),i),console.error("\ud83d\udd0d githubService.getFileContent: Error analysis:",{type:typeof i,status:i.status,message:i.message,name:i.name,stack:(null===(a=i.stack)||void 0===a?void 0:a.substring(0,500))+"..."}),i.message.includes("timeout"))throw console.error("\u23f0 githubService.getFileContent: Timeout error detected"),new Error("GitHub API request timed out after ".concat(15," seconds. Please try again."));if(403===i.status)throw console.error("\ud83d\udd12 githubService.getFileContent: 403 Forbidden error detected"),new Error("Access denied. This repository may be private or you may have hit rate limits.");if(404===i.status)throw console.error("\ud83d\udd0d githubService.getFileContent: 404 Not Found error detected"),new Error("File not found in the repository.");if(i.message.includes("rate limit"))throw console.error("\ud83d\udea6 githubService.getFileContent: Rate limit error detected"),new Error("GitHub API rate limit exceeded. Please try again later.");if(i.message.includes("Network Error")||i.message.includes("Failed to fetch"))throw console.error("\ud83c\udf10 githubService.getFileContent: Network error detected"),new Error("Network error occurred. Please check your internet connection and try again.");throw console.error("\u2753 githubService.getFileContent: Unknown error type, re-throwing original error"),i}}async createCommit(t,e,r,o,s){if(!this.isAuth())throw new Error("Not authenticated with GitHub");try{const{data:a}=await this.octokit.rest.git.getRef({owner:t,repo:e,ref:"heads/".concat(r)}),n=a.object.sha,{data:i}=await this.octokit.rest.git.getCommit({owner:t,repo:e,commit_sha:n}),c=i.tree.sha,l=await Promise.all(s.map(async r=>{const{data:o}=await this.octokit.rest.git.createBlob({owner:t,repo:e,content:r.content,encoding:"utf-8"});return{path:r.path,mode:"100644",type:"blob",sha:o.sha}})),{data:h}=await this.octokit.rest.git.createTree({owner:t,repo:e,base_tree:c,tree:l}),{data:u}=await this.octokit.rest.git.createCommit({owner:t,repo:e,message:o,tree:h.sha,parents:[n]});return await this.octokit.rest.git.updateRef({owner:t,repo:e,ref:"heads/".concat(r),sha:u.sha}),{sha:u.sha,html_url:"https://github.com/".concat(t,"/").concat(e,"/commit/").concat(u.sha),message:u.message,author:u.author,committer:u.committer}}catch(a){throw console.error("Failed to create commit:",a),a}}async getRecentCommits(t,e){let r=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"main",o=arguments.length>3&&void 0!==arguments[3]?arguments[3]:5;if(!this.isAuth())throw new Error("Not authenticated with GitHub");const s=Date.now();this.logger.apiCall("GET","/repos/".concat(t,"/").concat(e,"/commits"),{sha:r,per_page:o});try{const a=await this.octokit.rest.repos.listCommits({owner:t,repo:e,sha:r,per_page:o});return this.logger.apiResponse("GET","/repos/".concat(t,"/").concat(e,"/commits"),a.status,Date.now()-s),a.data.map(t=>({sha:t.sha,message:t.commit.message,author:{name:t.commit.author.name,email:t.commit.author.email,date:t.commit.author.date},committer:{name:t.commit.committer.name,email:t.commit.committer.email,date:t.commit.committer.date},html_url:t.html_url,stats:t.stats}))}catch(a){throw this.logger.apiResponse("GET","/repos/".concat(t,"/").concat(e,"/commits"),a.status||"error",Date.now()-s),console.error("Failed to fetch recent commits:",a),a}}async getOpenPullRequestsCount(t,e){if(!this.isAuth())throw new Error("Not authenticated with GitHub");const r=Date.now();this.logger.apiCall("GET","/repos/".concat(t,"/").concat(e,"/pulls"),{state:"open",per_page:1});try{const o=await this.octokit.rest.pulls.list({owner:t,repo:e,state:"open",per_page:1});this.logger.apiResponse("GET","/repos/".concat(t,"/").concat(e,"/pulls"),o.status,Date.now()-r);const s=o.headers.link;if(s&&s.includes('rel="last"')){const t=s.match(/page=(\d+)>; rel="last"/);if(t)return parseInt(t[1],10)}return o.data.length}catch(o){throw this.logger.apiResponse("GET","/repos/".concat(t,"/").concat(e,"/pulls"),o.status||"error",Date.now()-r),console.error("Failed to fetch pull requests count:",o),o}}async getPullRequestForBranch(t,e,r){const o=await this.getPullRequestsForBranch(t,e,r);return o&&o.length>0?o[0]:null}async getPullRequestsForBranch(t,e,r){const o=this.isAuth()?this.octokit:await this.createOctokitInstance(),s=Date.now();this.logger.apiCall("GET","/repos/".concat(t,"/").concat(e,"/pulls"),{state:"open",head:"".concat(t,":").concat(r)});try{const a=await o.rest.pulls.list({owner:t,repo:e,state:"open",head:"".concat(t,":").concat(r),per_page:100});return this.logger.apiResponse("GET","/repos/".concat(t,"/").concat(e,"/pulls"),a.status,Date.now()-s),a.data||[]}catch(a){return this.logger.apiResponse("GET","/repos/".concat(t,"/").concat(e,"/pulls"),a.status||"error",Date.now()-s),console.error("Failed to fetch pull requests for branch:",a),[]}}async getPullRequestComments(t,e,r){let o=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1,s=arguments.length>4&&void 0!==arguments[4]?arguments[4]:100;const a=this.isAuth()?this.octokit:await this.createOctokitInstance(),n=Date.now();this.logger.apiCall("GET","/repos/".concat(t,"/").concat(e,"/pulls/").concat(r,"/comments"),{page:o,per_page:s});try{const i=await a.rest.pulls.listReviewComments({owner:t,repo:e,pull_number:r,page:o,per_page:s});return this.logger.apiResponse("GET","/repos/".concat(t,"/").concat(e,"/pulls/").concat(r,"/comments"),i.status,Date.now()-n),i.data}catch(i){throw this.logger.apiResponse("GET","/repos/".concat(t,"/").concat(e,"/pulls/").concat(r,"/comments"),i.status||"error",Date.now()-n),console.error("Failed to fetch pull request comments:",i),i}}async getPullRequestIssueComments(t,e,r){let o=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1,s=arguments.length>4&&void 0!==arguments[4]?arguments[4]:100;const a=this.isAuth()?this.octokit:await this.createOctokitInstance(),n=Date.now();this.logger.apiCall("GET","/repos/".concat(t,"/").concat(e,"/issues/").concat(r,"/comments"),{page:o,per_page:s});try{const i=await a.rest.issues.listComments({owner:t,repo:e,issue_number:r,page:o,per_page:s});return this.logger.apiResponse("GET","/repos/".concat(t,"/").concat(e,"/issues/").concat(r,"/comments"),i.status,Date.now()-n),i.data}catch(i){throw this.logger.apiResponse("GET","/repos/".concat(t,"/").concat(e,"/issues/").concat(r,"/comments"),i.status||"error",Date.now()-n),console.error("Failed to fetch pull request issue comments:",i),i}}async createPullRequestComment(t,e,r,o){if(!this.isAuth())throw new Error("Not authenticated with GitHub");const s=Date.now();this.logger.apiCall("POST","/repos/".concat(t,"/").concat(e,"/issues/").concat(r,"/comments"),{body:o});try{const a=await this.octokit.rest.issues.createComment({owner:t,repo:e,issue_number:r,body:o});return this.logger.apiResponse("POST","/repos/".concat(t,"/").concat(e,"/issues/").concat(r,"/comments"),a.status,Date.now()-s),a.data}catch(a){throw this.logger.apiResponse("POST","/repos/".concat(t,"/").concat(e,"/issues/").concat(r,"/comments"),a.status||"error",Date.now()-s),console.error("Failed to create pull request comment:",a),a}}async getPullRequestTimeline(t,e,r){let o=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1,s=arguments.length>4&&void 0!==arguments[4]?arguments[4]:100;const a=this.isAuth()?this.octokit:await this.createOctokitInstance(),n=Date.now();this.logger.apiCall("GET","/repos/".concat(t,"/").concat(e,"/issues/").concat(r,"/timeline"),{page:o,per_page:s});try{const i=await a.rest.issues.listEventsForTimeline({owner:t,repo:e,issue_number:r,page:o,per_page:s});return this.logger.apiResponse("GET","/repos/".concat(t,"/").concat(e,"/issues/").concat(r,"/timeline"),i.status,Date.now()-n),i.data}catch(i){return this.logger.apiResponse("GET","/repos/".concat(t,"/").concat(e,"/issues/").concat(r,"/timeline"),i.status||"error",Date.now()-n),console.debug("Failed to fetch pull request timeline:",i),[]}}async mergePullRequest(t,e,r){let s=arguments.length>3&&void 0!==arguments[3]?arguments[3]:{};if(!this.isAuth())throw new Error("Not authenticated with GitHub");const a=Date.now();this.logger.apiCall("PUT","/repos/".concat(t,"/").concat(e,"/pulls/").concat(r,"/merge"),s);try{const n=(0,o.A)({owner:t,repo:e,pull_number:r,commit_title:s.commit_title,commit_message:s.commit_message,merge_method:s.merge_method||"merge"},s),i=await this.octokit.rest.pulls.merge(n);return this.logger.apiResponse("PUT","/repos/".concat(t,"/").concat(e,"/pulls/").concat(r,"/merge"),i.status,Date.now()-a),i.data}catch(n){throw this.logger.apiResponse("PUT","/repos/".concat(t,"/").concat(e,"/pulls/").concat(r,"/merge"),n.status||"error",Date.now()-a),console.error("Failed to merge pull request:",n),n}}async checkPullRequestMergePermissions(t,e,r){if(!this.isAuth())return this.logger.warn("Cannot check PR merge permissions - not authenticated",{owner:t,repo:e,pullNumber:r}),!1;try{const o=Date.now();this.logger.apiCall("GET","/repos/".concat(t,"/").concat(e,"/pulls/").concat(r),{});const s=await this.octokit.rest.pulls.get({owner:t,repo:e,pull_number:r});this.logger.apiResponse("GET","/repos/".concat(t,"/").concat(e,"/pulls/").concat(r),s.status,Date.now()-o);const a=s.data;if("open"!==a.state)return this.logger.debug("PR not mergeable - not open",{owner:t,repo:e,pullNumber:r,state:a.state}),!1;if(a.draft)return this.logger.debug("PR not mergeable - is draft",{owner:t,repo:e,pullNumber:r}),!1;return!!await this.checkRepositoryWritePermissions(t,e)||(this.logger.debug("PR not mergeable - no write access",{owner:t,repo:e,pullNumber:r}),!1)}catch(o){return this.logger.warn("Error checking PR merge permissions",{owner:t,repo:e,pullNumber:r,error:o.message}),!1}}async getOpenIssuesCount(t,e){if(!this.isAuth())throw new Error("Not authenticated with GitHub");const r=Date.now();this.logger.apiCall("GET","/repos/".concat(t,"/").concat(e,"/issues"),{state:"open",per_page:1});try{const o=await this.octokit.rest.issues.listForRepo({owner:t,repo:e,state:"open",per_page:1});this.logger.apiResponse("GET","/repos/".concat(t,"/").concat(e,"/issues"),o.status,Date.now()-r);const s=o.headers.link;if(s&&s.includes('rel="last"')){const t=s.match(/page=(\d+)>; rel="last"/);if(t)return parseInt(t[1],10)}return o.data.length}catch(o){throw this.logger.apiResponse("GET","/repos/".concat(t,"/").concat(e,"/issues"),o.status||"error",Date.now()-r),console.error("Failed to fetch issues count:",o),o}}async getRepositoryStats(t,e){let r=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"main";if(!this.isAuth())throw new Error("Not authenticated with GitHub");try{const[o,s,a]=await Promise.allSettled([this.getRecentCommits(t,e,r,1),this.getOpenPullRequestsCount(t,e),this.getOpenIssuesCount(t,e)]);return{recentCommits:"fulfilled"===o.status?o.value:[],openPullRequestsCount:"fulfilled"===s.status?s.value:0,openIssuesCount:"fulfilled"===a.status?a.value:0,errors:{recentCommits:"rejected"===o.status?o.reason:null,openPullRequestsCount:"rejected"===s.status?s.reason:null,openIssuesCount:"rejected"===a.status?a.reason:null}}}catch(o){throw console.error("Failed to fetch repository stats:",o),o}}async getDirectoryContents(t,e){let r=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"",o=arguments.length>3&&void 0!==arguments[3]?arguments[3]:"main";try{const s=this.isAuth()?this.octokit:await this.createOctokitInstance(),{data:a}=await s.rest.repos.getContent({owner:t,repo:e,path:r,ref:o});if(Array.isArray(a))return a;throw new Error("Not a directory")}catch(s){throw console.error("Failed to get directory contents for ".concat(r,":"),s),s}}async updateFile(t,e,r,o,s){let a=arguments.length>5&&void 0!==arguments[5]?arguments[5]:"main";if(!this.isAuth())throw new Error("Authentication required to update files");try{const{data:n}=await this.octokit.rest.repos.getContent({owner:t,repo:e,path:r,ref:a});if(Array.isArray(n))throw new Error("Path is a directory, not a file");const{data:i}=await this.octokit.rest.repos.createOrUpdateFileContents({owner:t,repo:e,path:r,message:s,content:btoa(unescape(encodeURIComponent(o))),sha:n.sha,branch:a});return i}catch(n){throw console.error("Failed to update file ".concat(r,":"),n),n}}async getCommits(t,e){let r=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};try{const o=this.isAuth()?this.octokit:await this.createOctokitInstance(),s={owner:t,repo:e,per_page:r.per_page||10,page:r.page||1};r.sha&&(s.sha=r.sha),r.since&&(s.since=r.since),r.until&&(s.until=r.until);const{data:a}=await o.rest.repos.listCommits(s);return a}catch(o){throw console.error("Failed to fetch commits:",o),o}}async getIssues(t,e){let r=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};try{const o=this.isAuth()?this.octokit:await this.createOctokitInstance(),s={owner:t,repo:e,state:r.state||"all",per_page:r.per_page||30,page:r.page||1};r.labels&&(s.labels=r.labels),r.milestone&&(s.milestone=r.milestone);const{data:a}=await o.rest.issues.listForRepo(s);return a}catch(o){throw console.error("Failed to fetch issues:",o),o}}async getRepositoryIssues(t,e){let r=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};return this.getIssues(t,e,r)}async getForks(t,e){let r=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};const o=Date.now();this.logger.apiCall("GET","/repos/".concat(t,"/").concat(e,"/forks"),r);try{const s=this.isAuth()?this.octokit:await this.createOctokitInstance(),a={owner:t,repo:e,sort:r.sort||"newest",per_page:r.per_page||100,page:r.page||1},{data:n}=await s.rest.repos.listForks(a);return this.logger.apiResponse("GET","/repos/".concat(t,"/").concat(e,"/forks"),200,Date.now()-o),n.map(t=>({id:t.id,name:t.name,full_name:t.full_name,owner:{login:t.owner.login,avatar_url:t.owner.avatar_url,html_url:t.owner.html_url,type:t.owner.type},description:t.description,html_url:t.html_url,clone_url:t.clone_url,created_at:t.created_at,updated_at:t.updated_at,pushed_at:t.pushed_at,stargazers_count:t.stargazers_count,forks_count:t.forks_count,open_issues_count:t.open_issues_count,default_branch:t.default_branch,private:t.private,fork:t.fork,parent:t.parent?{full_name:t.parent.full_name,html_url:t.parent.html_url}:null}))}catch(s){throw this.logger.apiResponse("GET","/repos/".concat(t,"/").concat(e,"/forks"),s.status||"error",Date.now()-o),console.error("Failed to fetch repository forks:",s),s}}async getPullRequests(t,e){let r=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};const o=Date.now();this.logger.apiCall("GET","/repos/".concat(t,"/").concat(e,"/pulls"),r);try{const s=this.isAuth()?this.octokit:await this.createOctokitInstance(),a={owner:t,repo:e,state:r.state||"open",sort:r.sort||"updated",direction:r.direction||"desc",per_page:r.per_page||30,page:r.page||1};r.head&&(a.head=r.head),r.base&&(a.base=r.base);const{data:n}=await s.rest.pulls.list(a);return this.logger.apiResponse("GET","/repos/".concat(t,"/").concat(e,"/pulls"),200,Date.now()-o),n.map(t=>({id:t.id,number:t.number,title:t.title,body:t.body,state:t.state,locked:t.locked,user:{login:t.user.login,avatar_url:t.user.avatar_url,html_url:t.user.html_url,type:t.user.type},created_at:t.created_at,updated_at:t.updated_at,closed_at:t.closed_at,merged_at:t.merged_at,html_url:t.html_url,diff_url:t.diff_url,patch_url:t.patch_url,head:{ref:t.head.ref,sha:t.head.sha,repo:t.head.repo?{name:t.head.repo.name,full_name:t.head.repo.full_name,owner:{login:t.head.repo.owner.login,avatar_url:t.head.repo.owner.avatar_url},html_url:t.head.repo.html_url}:null},base:{ref:t.base.ref,sha:t.base.sha,repo:{name:t.base.repo.name,full_name:t.base.repo.full_name,owner:{login:t.base.repo.owner.login,avatar_url:t.base.repo.owner.avatar_url},html_url:t.base.repo.html_url}},draft:t.draft,mergeable:t.mergeable,mergeable_state:t.mergeable_state,comments:t.comments,review_comments:t.review_comments,commits:t.commits,additions:t.additions,deletions:t.deletions,changed_files:t.changed_files}))}catch(s){throw this.logger.apiResponse("GET","/repos/".concat(t,"/").concat(e,"/pulls"),s.status||"error",Date.now()-o),console.error("Failed to fetch pull requests:",s),s}}async createIssue(t,e,r,o){let s=arguments.length>4&&void 0!==arguments[4]?arguments[4]:[],a=arguments.length>5&&void 0!==arguments[5]?arguments[5]:[];if(!this.isAuth())throw new Error("Authentication required to create issues");const n=Date.now();this.logger.apiCall("POST","/repos/".concat(t,"/").concat(e,"/issues"),{title:r,bodyLength:null===o||void 0===o?void 0:o.length,labels:s,assignees:a});try{const i={owner:t,repo:e,title:r,body:o};s.length>0&&(i.labels=s),a.length>0&&(i.assignees=a);const c=await this.octokit.rest.issues.create(i);return this.logger.apiResponse("POST","/repos/".concat(t,"/").concat(e,"/issues"),c.status,Date.now()-n),{success:!0,issue:{id:c.data.id,number:c.data.number,title:c.data.title,body:c.data.body,html_url:c.data.html_url,state:c.data.state,created_at:c.data.created_at,user:{login:c.data.user.login,avatar_url:c.data.user.avatar_url},labels:c.data.labels.map(t=>({name:t.name,color:t.color}))}}}catch(i){return this.logger.apiResponse("POST","/repos/".concat(t,"/").concat(e,"/issues"),i.status||"error",Date.now()-n),console.error("Failed to create issue:",i),{success:!1,error:{message:i.message,status:i.status,type:403===i.status?"permission_denied":422===i.status?"validation_error":404===i.status?"repository_not_found":"unknown_error"}}}}async getIssue(t,e,r){if(!this.isAuth())throw new Error("Authentication required to get issue details");const o=Date.now();this.logger.apiCall("GET","/repos/".concat(t,"/").concat(e,"/issues/").concat(r));try{const s=await this.octokit.rest.issues.get({owner:t,repo:e,issue_number:r});return this.logger.apiResponse("GET","/repos/".concat(t,"/").concat(e,"/issues/").concat(r),s.status,Date.now()-o),{id:s.data.id,number:s.data.number,title:s.data.title,body:s.data.body,html_url:s.data.html_url,state:s.data.state,created_at:s.data.created_at,updated_at:s.data.updated_at,closed_at:s.data.closed_at,user:{login:s.data.user.login,avatar_url:s.data.user.avatar_url},labels:s.data.labels.map(t=>({name:t.name,color:t.color}))}}catch(s){throw this.logger.apiResponse("GET","/repos/".concat(t,"/").concat(e,"/issues/").concat(r),s.status||"error",Date.now()-o),console.error("Failed to get issue:",s),s}}async getPullRequest(t,e,r){if(!this.isAuth())throw new Error("Authentication required to get pull request details");const o=Date.now();this.logger.apiCall("GET","/repos/".concat(t,"/").concat(e,"/pulls/").concat(r));try{const s=await this.octokit.rest.pulls.get({owner:t,repo:e,pull_number:r});return this.logger.apiResponse("GET","/repos/".concat(t,"/").concat(e,"/pulls/").concat(r),s.status,Date.now()-o),{id:s.data.id,number:s.data.number,title:s.data.title,body:s.data.body,html_url:s.data.html_url,state:s.data.state,created_at:s.data.created_at,updated_at:s.data.updated_at,closed_at:s.data.closed_at,merged_at:s.data.merged_at,user:{login:s.data.user.login,avatar_url:s.data.user.avatar_url},head:{ref:s.data.head.ref,sha:s.data.head.sha},base:{ref:s.data.base.ref,sha:s.data.base.sha}}}catch(s){throw this.logger.apiResponse("GET","/repos/".concat(t,"/").concat(e,"/pulls/").concat(r),s.status||"error",Date.now()-o),console.error("Failed to get pull request:",s),s}}async searchIssues(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};if(!this.isAuth())throw new Error("Authentication required to search issues");const r=Date.now();this.logger.apiCall("GET","/search/issues",{query:t,type:"issue"});try{const o=await this.octokit.rest.search.issuesAndPullRequests({q:t,sort:e.sort||"created",order:e.order||"desc",per_page:e.per_page||30,page:e.page||1});return this.logger.apiResponse("GET","/search/issues",o.status,Date.now()-r),{total_count:o.data.total_count,incomplete_results:o.data.incomplete_results,items:o.data.items.map(t=>({id:t.id,number:t.number,title:t.title,body:t.body,html_url:t.html_url,state:t.state,created_at:t.created_at,updated_at:t.updated_at,closed_at:t.closed_at,labels:t.labels||[],user:{login:t.user.login,avatar_url:t.user.avatar_url},repository:t.repository_url?{name:t.repository_url.split("/").slice(-1)[0],full_name:t.repository_url.split("/").slice(-2).join("/")}:null}))}}catch(o){throw this.logger.apiResponse("GET","/search/issues",o.status||"error",Date.now()-r),console.error("Failed to search issues:",o),o}}async searchPullRequests(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};if(!this.isAuth())throw new Error("Authentication required to search pull requests");const r=Date.now();this.logger.apiCall("GET","/search/issues",{query:t,type:"pr"});try{const o=await this.octokit.rest.search.issuesAndPullRequests({q:t,sort:e.sort||"created",order:e.order||"desc",per_page:e.per_page||30,page:e.page||1});return this.logger.apiResponse("GET","/search/issues",o.status,Date.now()-r),{total_count:o.data.total_count,incomplete_results:o.data.incomplete_results,items:o.data.items.map(t=>({id:t.id,number:t.number,title:t.title,body:t.body,html_url:t.html_url,state:t.state,created_at:t.created_at,updated_at:t.updated_at,closed_at:t.closed_at,user:{login:t.user.login,avatar_url:t.user.avatar_url},repository:t.repository_url?{name:t.repository_url.split("/").slice(-1)[0],full_name:t.repository_url.split("/").slice(-2).join("/")}:null}))}}catch(o){throw this.logger.apiResponse("GET","/search/issues",o.status||"error",Date.now()-r),console.error("Failed to search pull requests:",o),o}}logout(){this.logger.auth("Logging out and clearing stored token"),this.octokit=null,this.isAuthenticated=!1,this.tokenType=null,this.permissions=null,i.A.clearToken();try{const{default:t}=r(18354);t.clearAllBranchContext()}catch(t){sessionStorage.removeItem("sgex_branch_context")}}async getRepositoryForks(t,e){let r=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};const o=Date.now();this.logger.debug("Fetching repository forks",{owner:t,repo:e,options:r});try{const s=this.isAuth()?this.octokit:await this.createOctokitInstance();this.logger.apiCall("GET","/repos/".concat(t,"/").concat(e,"/forks"),r);const{data:a}=await s.rest.repos.listForks({owner:t,repo:e,sort:"newest",per_page:r.per_page||100,page:r.page||1}),n=Date.now()-o;return this.logger.apiResponse("GET","/repos/".concat(t,"/").concat(e,"/forks"),200,n,{forkCount:a.length}),this.logger.performance("Repository forks fetch",n),a}catch(s){const r=Date.now()-o;throw this.logger.apiError("GET","/repos/".concat(t,"/").concat(e,"/forks"),s),this.logger.performance("Repository forks fetch (failed)",r),console.error("Failed to fetch forks for ".concat(t,"/").concat(e,":"),s),s}}async checkPullRequestReviewPermissions(t,e,r){try{if(!this.isAuth())return!1;if(await this.checkRepositoryWritePermissions(t,e))return!0;return 200===(await this.octokit.rest.repos.get({owner:t,repo:e})).status}catch(o){return console.debug("Cannot check PR review permissions:",o),!1}}async createPullRequestReview(t,e,r,o){let s=arguments.length>4&&void 0!==arguments[4]?arguments[4]:"";if(!this.isAuth())throw new Error("Authentication required to review pull requests");const a=Date.now();this.logger.apiCall("POST","/repos/".concat(t,"/").concat(e,"/pulls/").concat(r,"/reviews"),{event:o,bodyLength:null===s||void 0===s?void 0:s.length});try{const n={owner:t,repo:e,pull_number:r,event:o};s&&s.trim()&&(n.body=s);const i=await this.octokit.rest.pulls.createReview(n);return this.logger.apiResponse("POST","/repos/".concat(t,"/").concat(e,"/pulls/").concat(r,"/reviews"),i.status,Date.now()-a),{success:!0,review:{id:i.data.id,state:i.data.state,body:i.data.body,html_url:i.data.html_url,submitted_at:i.data.submitted_at,user:{login:i.data.user.login,avatar_url:i.data.user.avatar_url}}}}catch(n){throw this.logger.apiResponse("POST","/repos/".concat(t,"/").concat(e,"/pulls/").concat(r,"/reviews"),n.status||"error",Date.now()-a),console.error("Failed to create pull request review:",n),n}}async approvePullRequest(t,e,r){let o=arguments.length>3&&void 0!==arguments[3]?arguments[3]:"";return this.createPullRequestReview(t,e,r,"APPROVE",o)}async requestPullRequestChanges(t,e,r,o){if(!o||!o.trim())throw new Error("A comment is required when requesting changes");return this.createPullRequestReview(t,e,r,"REQUEST_CHANGES",o)}async dismissPullRequestReview(t,e,r,o,s){if(!this.isAuth())throw new Error("Authentication required to dismiss reviews");const a=Date.now();this.logger.apiCall("PUT","/repos/".concat(t,"/").concat(e,"/pulls/").concat(r,"/reviews/").concat(o,"/dismissals"),{messageLength:null===s||void 0===s?void 0:s.length});try{const n=await this.octokit.rest.pulls.dismissReview({owner:t,repo:e,pull_number:r,review_id:o,message:s||"Review dismissed"});return this.logger.apiResponse("PUT","/repos/".concat(t,"/").concat(e,"/pulls/").concat(r,"/reviews/").concat(o,"/dismissals"),n.status,Date.now()-a),{success:!0,review:n.data}}catch(n){throw this.logger.apiResponse("PUT","/repos/".concat(t,"/").concat(e,"/pulls/").concat(r,"/reviews/").concat(o,"/dismissals"),n.status||"error",Date.now()-a),console.error("Failed to dismiss pull request review:",n),n}}async markPullRequestReadyForReview(t,e,r){if(!this.isAuth())throw new Error("Authentication required to mark PR as ready for review");const o=Date.now();this.logger.apiCall("PATCH","/repos/".concat(t,"/").concat(e,"/pulls/").concat(r),{draft:!1});try{const s=await this.octokit.rest.pulls.update({owner:t,repo:e,pull_number:r,draft:!1});return this.logger.apiResponse("PATCH","/repos/".concat(t,"/").concat(e,"/pulls/").concat(r),s.status,Date.now()-o),{success:!0,pullRequest:{id:s.data.id,number:s.data.number,draft:s.data.draft,state:s.data.state,title:s.data.title,html_url:s.data.html_url}}}catch(s){throw this.logger.apiResponse("PATCH","/repos/".concat(t,"/").concat(e,"/pulls/").concat(r),s.status||"error",Date.now()-o),console.error("Failed to mark pull request as ready for review:",s),s}}}},57335:(t,e,r)=>{r.d(e,{LC:()=>c,M3:()=>n,Ys:()=>h,_r:()=>u,cb:()=>i,ef:()=>g,hP:()=>l,k$:()=>p,sN:()=>s,uW:()=>a});const o=new Map;async function s(){const t="octokit";if(o.has(t))return o.get(t);const{Octokit:e}=await r.e(112).then(r.bind(r,10112));return o.set(t,e),e}async function a(){const t="bpmn-modeler";if(o.has(t))return o.get(t);const e=(await Promise.all([r.e(9225),r.e(5426)]).then(r.bind(r,5426))).default;return o.set(t,e),e}async function n(){const t="bpmn-viewer";if(o.has(t))return o.get(t);const e=(await r.e(9225).then(r.bind(r,9225))).default;return o.set(t,e),e}async function i(){const t="js-yaml";if(o.has(t))return o.get(t);const e=(await r.e(6558).then(r.bind(r,16558))).default;return o.set(t,e),e}async function c(){const t="md-editor";if(o.has(t))return o.get(t);const e=(await Promise.all([r.e(3738),r.e(7845),r.e(2383),r.e(5743)]).then(r.bind(r,25743))).default;return o.set(t,e),e}async function l(){const t="react-markdown";if(o.has(t))return o.get(t);const e=(await Promise.all([r.e(3738),r.e(7845),r.e(4044)]).then(r.bind(r,14044))).default;return o.set(t,e),e}async function h(){const t="ajv";if(o.has(t))return o.get(t);const e=(await r.e(8900).then(r.t.bind(r,58900,23))).default;return o.set(t,e),e}async function u(){const t="ajv-formats";if(o.has(t))return o.get(t);const e=(await Promise.all([r.e(8900),r.e(988)]).then(r.t.bind(r,90988,23))).default;return o.set(t,e),e}async function g(){const t="dompurify";if(o.has(t))return o.get(t);let e=(await r.e(7082).then(r.bind(r,7082))).default;if("undefined"!==typeof window&&"function"===typeof e)try{e=e(window)}catch(s){console.debug("DOMPurify initialization note:",s.message)}return o.set(t,e),e}async function p(){const t="rehype-raw";if(o.has(t))return o.get(t);const e=(await Promise.all([r.e(3738),r.e(2383),r.e(5906)]).then(r.bind(r,55906))).default;return o.set(t,e),e}},57561:(t,e,r)=>{r.d(e,{A:()=>n});var o=r(80045),s=r(89379);const a=["savedAt"];const n=new class{constructor(){this.listeners=new Set,this.currentRepository=null,this.currentBranch=null}initialize(t,e){this.currentRepository=t,this.currentBranch=e,this.notifyListeners()}getStorageKey(){if(!this.currentRepository||!this.currentBranch)throw new Error("Staging ground not initialized");return"sgex_staging_".concat(this.currentRepository.full_name,"_").concat(this.currentBranch)}getStagingGround(){try{const t=this.getStorageKey(),e=localStorage.getItem(t);return e?JSON.parse(e):this.createEmptyStagingGround()}catch(t){return console.warn("Error reading staging ground from localStorage:",t),this.createEmptyStagingGround()}}createEmptyStagingGround(){var t;return{message:"",files:[],timestamp:Date.now(),branch:this.currentBranch,repository:null===(t=this.currentRepository)||void 0===t?void 0:t.full_name}}saveStagingGround(t){try{var e;const r=this.getStorageKey();return t.timestamp=Date.now(),t.branch=this.currentBranch,t.repository=null===(e=this.currentRepository)||void 0===e?void 0:e.full_name,localStorage.setItem(r,JSON.stringify(t)),this.saveToHistory(t),this.notifyListeners(),!0}catch(r){return console.error("Error saving staging ground to localStorage:",r),!1}}updateFile(t,e){let r=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};const o=this.getStagingGround(),a=o.files.findIndex(e=>e.path===t),n={path:t,content:e,metadata:(0,s.A)((0,s.A)({},r),{},{lastModified:Date.now()}),timestamp:Date.now()};return a>=0?o.files[a]=n:o.files.push(n),this.saveStagingGround(o)}removeFile(t){const e=this.getStagingGround();return e.files=e.files.filter(e=>e.path!==t),this.saveStagingGround(e)}updateCommitMessage(t){const e=this.getStagingGround();return e.message=t,this.saveStagingGround(e)}hasChanges(){return this.getStagingGround().files.length>0}getChangedFilesCount(){return this.getStagingGround().files.length}clearStagingGround(){const t=this.createEmptyStagingGround();return this.saveStagingGround(t)}saveToHistory(t){try{const e="".concat(this.getStorageKey(),"_history"),r=this.getHistory();r.push((0,s.A)((0,s.A)({},t),{},{savedAt:Date.now()}));const o=r.slice(-10);localStorage.setItem(e,JSON.stringify(o))}catch(e){console.warn("Error saving to history:",e)}}getHistory(){try{const t="".concat(this.getStorageKey(),"_history"),e=localStorage.getItem(t);return e?JSON.parse(e):[]}catch(t){return console.warn("Error reading history:",t),[]}}rollbackToSave(t){const e=this.getHistory().find(e=>e.savedAt===t);if(!e)throw new Error("Save not found in history");const{savedAt:r}=e,s=(0,o.A)(e,a);return this.saveStagingGround(s)}exportStagingGround(){var t;return{current:this.getStagingGround(),history:this.getHistory(),exportedAt:Date.now(),repository:null===(t=this.currentRepository)||void 0===t?void 0:t.full_name,branch:this.currentBranch}}importStagingGround(t){var e;if(!t.current||!t.repository||!t.branch)throw new Error("Invalid export data format");if(t.repository!==(null===(e=this.currentRepository)||void 0===e?void 0:e.full_name)||t.branch!==this.currentBranch)throw new Error("Export data is for different repository or branch");if(this.saveStagingGround(t.current),t.history)try{const e="".concat(this.getStorageKey(),"_history");localStorage.setItem(e,JSON.stringify(t.history))}catch(r){console.warn("Error importing history:",r)}return!0}cleanup(){let t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:6048e5;try{const r=Date.now(),o=[];for(let s=0;s<localStorage.length;s++){const a=localStorage.key(s);if(a&&a.startsWith("sgex_staging_"))try{const e=JSON.parse(localStorage.getItem(a));e.timestamp&&r-e.timestamp>t&&(o.push(a),o.push("".concat(a,"_history")))}catch(e){o.push(a)}}return o.forEach(t=>{localStorage.removeItem(t)}),o.length}catch(e){return console.error("Error during cleanup:",e),0}}addListener(t){return this.listeners.add(t),()=>{this.listeners.delete(t)}}notifyListeners(){const t=this.getStagingGround();this.listeners.forEach(e=>{try{e(t)}catch(r){console.error("Error in staging ground listener:",r)}})}contributeFiles(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};Array.isArray(t)||(t=[t]);let r=!0;const o=[];return t.forEach(t=>{if(!t.path||!t.content)return o.push({path:t.path,success:!1,error:"Missing path or content"}),void(r=!1);const a=this.updateFile(t.path,t.content,(0,s.A)((0,s.A)({},e),{},{source:e.tool||"unknown",contributedAt:Date.now()}));o.push({path:t.path,success:a}),a||(r=!1)}),{success:r,results:o}}getStatus(){var t;const e=this.getStagingGround();return{hasChanges:this.hasChanges(),filesCount:this.getChangedFilesCount(),lastModified:e.timestamp,branch:this.currentBranch,repository:null===(t=this.currentRepository)||void 0===t?void 0:t.full_name}}}},78723:(t,e,r)=>{r.d(e,{A:()=>s});var o=r(85571);const s=new class{constructor(){this.logger=o.A.getLogger("SecureTokenStorage"),this.storageKey="sgex_secure_token",this.expirationHours=24,this.logger.debug("SecureTokenStorage instance created")}generateBrowserFingerprint(){const t=document.createElement("canvas"),e=t.getContext("2d");e.textBaseline="top",e.font="14px Arial",e.fillText("Browser fingerprint",2,2);const r=[navigator.userAgent,navigator.language,window.screen.width+"x"+window.screen.height,window.screen.colorDepth,(new Date).getTimezoneOffset(),t.toDataURL()].join("|");let o=0;for(let s=0;s<r.length;s++){o=(o<<5)-o+r.charCodeAt(s),o&=o}return Math.abs(o).toString(36)}xorCipher(t,e){let r="";for(let o=0;o<t.length;o++)r+=String.fromCharCode(t.charCodeAt(o)^e.charCodeAt(o%e.length));return r}validateTokenFormat(t){if(!t||"string"!==typeof t)return{isValid:!1,type:"invalid",reason:"Token is empty or not a string"};const e=t.trim();return e.match(/^ghp_[A-Za-z0-9]{36}$/)?{isValid:!0,type:"classic",token:e}:e.match(/^github_pat_[A-Za-z0-9]{22}_[A-Za-z0-9]{59}$/)?{isValid:!0,type:"fine-grained",token:e}:e.match(/^gho_[A-Za-z0-9]{36}$/)?{isValid:!0,type:"oauth",token:e}:e.match(/^[a-fA-F0-9]{40}$/)?{isValid:!0,type:"legacy",token:e}:{isValid:!1,type:"invalid",reason:"Token does not match expected GitHub PAT format"}}maskToken(t){if(!t||"string"!==typeof t)return"[INVALID_TOKEN]";const e=t.trim();return e.length<8?"[INVALID_TOKEN]":"".concat(e.substring(0,4)).concat("*".repeat(e.length-8)).concat(e.substring(e.length-4))}storeToken(t){try{this.logger.debug("Starting secure token storage");const e=this.validateTokenFormat(t);if(!e.isValid)return this.logger.warn("Token validation failed",{reason:e.reason,tokenMask:this.maskToken(t)}),!1;this.logger.debug("Token validation successful",{type:e.type,tokenMask:this.maskToken(t)});const r=this.generateBrowserFingerprint(),o="sgex_".concat(r,"_").concat(Date.now().toString(36)),s=this.xorCipher(e.token,o),a={token:btoa(s),key:btoa(o),type:e.type,created:Date.now(),expires:Date.now()+60*this.expirationHours*60*1e3,fingerprint:r};return sessionStorage.setItem(this.storageKey,JSON.stringify(a)),localStorage.removeItem("github_token"),sessionStorage.removeItem("github_token"),this.logger.debug("Token stored securely",{type:e.type,expires:new Date(a.expires).toISOString(),tokenMask:this.maskToken(t)}),!0}catch(e){return this.logger.error("Failed to store token securely",{error:e.message,tokenMask:this.maskToken(t)}),!1}}retrieveToken(){try{this.logger.debug("Attempting to retrieve secure token");const t=sessionStorage.getItem(this.storageKey);if(!t)return this.logger.debug("No secure token found in storage"),null;const e=JSON.parse(t);if(Date.now()>e.expires)return this.logger.warn("Stored token has expired"),this.clearToken(),null;const r=this.generateBrowserFingerprint();if(e.fingerprint!==r)return this.logger.warn("Browser fingerprint mismatch - possible security issue"),this.clearToken(),null;const o=atob(e.key),s=atob(e.token),a=this.xorCipher(s,o),n=this.validateTokenFormat(a);return n.isValid?(this.logger.debug("Token retrieved and decrypted successfully",{type:e.type,expires:new Date(e.expires).toISOString(),tokenMask:this.maskToken(a)}),{token:n.token,type:e.type,created:e.created,expires:e.expires}):(this.logger.error("Decrypted token failed validation"),this.clearToken(),null)}catch(t){return this.logger.error("Failed to retrieve secure token",{error:t.message}),this.clearToken(),null}}hasValidToken(){try{const t=sessionStorage.getItem(this.storageKey);if(!t)return!1;const e=JSON.parse(t);if(Date.now()>e.expires)return this.clearToken(),!1;const r=this.generateBrowserFingerprint();return e.fingerprint===r||(this.clearToken(),!1)}catch(t){return this.logger.error("Error checking token validity",{error:t.message}),this.clearToken(),!1}}clearToken(){this.logger.debug("Clearing secure token storage"),sessionStorage.removeItem(this.storageKey),sessionStorage.removeItem("github_token"),localStorage.removeItem("github_token")}getTokenInfo(){try{const t=sessionStorage.getItem(this.storageKey);if(!t)return null;const e=JSON.parse(t),r=e.expires-Date.now();return{type:e.type,created:new Date(e.created),expires:new Date(e.expires),timeRemaining:Math.max(0,r),isExpired:r<=0,isValid:this.hasValidToken()}}catch(t){return this.logger.error("Error getting token info",{error:t.message}),null}}migrateLegacyToken(){try{const t=sessionStorage.getItem("github_token")||localStorage.getItem("github_token");if(!t)return this.logger.debug("No legacy token found for migration"),!1;this.logger.debug("Migrating legacy token to secure storage");return this.storeToken(t)?(sessionStorage.removeItem("github_token"),localStorage.removeItem("github_token"),this.logger.debug("Legacy token migration completed successfully"),!0):(this.logger.error("Failed to migrate legacy token"),!1)}catch(t){return this.logger.error("Error during legacy token migration",{error:t.message}),!1}}}}}]);