{"version":3,"file":"static/js/566.37d33993.chunk.js","mappings":"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","sources":["services/stagingGroundService.js","services/secureTokenStorage.js","services/branchContextService.js","utils/concurrency.js","utils/repositoryCompatibilityCache.js","services/githubService.js"],"sourcesContent":["/**\n * Staging Ground Service\n * \n * Manages local changes to DAK components before they are committed to GitHub.\n * Provides persistent storage, versioning, and integration interfaces for DAK editing tools.\n */\n\nclass StagingGroundService {\n  constructor() {\n    this.listeners = new Set();\n    this.currentRepository = null;\n    this.currentBranch = null;\n  }\n\n  /**\n   * Initialize staging ground for a specific repository and branch\n   */\n  initialize(repository, branch) {\n    this.currentRepository = repository;\n    this.currentBranch = branch;\n    this.notifyListeners();\n  }\n\n  /**\n   * Get the storage key for current repository and branch\n   */\n  getStorageKey() {\n    if (!this.currentRepository || !this.currentBranch) {\n      throw new Error('Staging ground not initialized');\n    }\n    return `sgex_staging_${this.currentRepository.full_name}_${this.currentBranch}`;\n  }\n\n  /**\n   * Get current staging ground state\n   */\n  getStagingGround() {\n    try {\n      const key = this.getStorageKey();\n      const stored = localStorage.getItem(key);\n      if (!stored) {\n        return this.createEmptyStagingGround();\n      }\n      return JSON.parse(stored);\n    } catch (error) {\n      console.warn('Error reading staging ground from localStorage:', error);\n      return this.createEmptyStagingGround();\n    }\n  }\n\n  /**\n   * Create empty staging ground structure\n   */\n  createEmptyStagingGround() {\n    return {\n      message: '',\n      files: [],\n      timestamp: Date.now(),\n      branch: this.currentBranch,\n      repository: this.currentRepository?.full_name\n    };\n  }\n\n  /**\n   * Save staging ground state to localStorage\n   */\n  saveStagingGround(stagingGround) {\n    try {\n      const key = this.getStorageKey();\n      stagingGround.timestamp = Date.now();\n      stagingGround.branch = this.currentBranch;\n      stagingGround.repository = this.currentRepository?.full_name;\n      \n      localStorage.setItem(key, JSON.stringify(stagingGround));\n      this.saveToHistory(stagingGround);\n      this.notifyListeners();\n      return true;\n    } catch (error) {\n      console.error('Error saving staging ground to localStorage:', error);\n      return false;\n    }\n  }\n\n  /**\n   * Add or update a file in the staging ground\n   */\n  updateFile(filePath, content, metadata = {}) {\n    const stagingGround = this.getStagingGround();\n    \n    // Find existing file or create new one\n    const existingFileIndex = stagingGround.files.findIndex(f => f.path === filePath);\n    const fileObject = {\n      path: filePath,\n      content: content,\n      metadata: {\n        ...metadata,\n        lastModified: Date.now()\n      },\n      timestamp: Date.now()\n    };\n\n    if (existingFileIndex >= 0) {\n      stagingGround.files[existingFileIndex] = fileObject;\n    } else {\n      stagingGround.files.push(fileObject);\n    }\n\n    return this.saveStagingGround(stagingGround);\n  }\n\n  /**\n   * Remove a file from the staging ground\n   */\n  removeFile(filePath) {\n    const stagingGround = this.getStagingGround();\n    stagingGround.files = stagingGround.files.filter(f => f.path !== filePath);\n    return this.saveStagingGround(stagingGround);\n  }\n\n  /**\n   * Update commit message\n   */\n  updateCommitMessage(message) {\n    const stagingGround = this.getStagingGround();\n    stagingGround.message = message;\n    return this.saveStagingGround(stagingGround);\n  }\n\n  /**\n   * Check if staging ground has changes\n   */\n  hasChanges() {\n    const stagingGround = this.getStagingGround();\n    return stagingGround.files.length > 0;\n  }\n\n  /**\n   * Get count of changed files\n   */\n  getChangedFilesCount() {\n    const stagingGround = this.getStagingGround();\n    return stagingGround.files.length;\n  }\n\n  /**\n   * Clear all changes in staging ground\n   */\n  clearStagingGround() {\n    const empty = this.createEmptyStagingGround();\n    return this.saveStagingGround(empty);\n  }\n\n  /**\n   * Save current state to history for rollback\n   */\n  saveToHistory(stagingGround) {\n    try {\n      const historyKey = `${this.getStorageKey()}_history`;\n      const history = this.getHistory();\n      \n      // Add current state to history\n      history.push({\n        ...stagingGround,\n        savedAt: Date.now()\n      });\n\n      // Keep only last 10 saves\n      const recentHistory = history.slice(-10);\n      localStorage.setItem(historyKey, JSON.stringify(recentHistory));\n      \n    } catch (error) {\n      console.warn('Error saving to history:', error);\n    }\n  }\n\n  /**\n   * Get history of saves\n   */\n  getHistory() {\n    try {\n      const historyKey = `${this.getStorageKey()}_history`;\n      const stored = localStorage.getItem(historyKey);\n      return stored ? JSON.parse(stored) : [];\n    } catch (error) {\n      console.warn('Error reading history:', error);\n      return [];\n    }\n  }\n\n  /**\n   * Rollback to a previous save\n   */\n  rollbackToSave(timestamp) {\n    const history = this.getHistory();\n    const save = history.find(s => s.savedAt === timestamp);\n    \n    if (!save) {\n      throw new Error('Save not found in history');\n    }\n\n    // Remove the savedAt timestamp before restoring\n    const { savedAt, ...stagingGroundState } = save;\n    return this.saveStagingGround(stagingGroundState);\n  }\n\n  /**\n   * Export staging ground state for backup/sharing\n   */\n  exportStagingGround() {\n    const stagingGround = this.getStagingGround();\n    const history = this.getHistory();\n    \n    return {\n      current: stagingGround,\n      history: history,\n      exportedAt: Date.now(),\n      repository: this.currentRepository?.full_name,\n      branch: this.currentBranch\n    };\n  }\n\n  /**\n   * Import staging ground state from backup\n   */\n  importStagingGround(exportedData) {\n    if (!exportedData.current || !exportedData.repository || !exportedData.branch) {\n      throw new Error('Invalid export data format');\n    }\n\n    if (exportedData.repository !== this.currentRepository?.full_name ||\n        exportedData.branch !== this.currentBranch) {\n      throw new Error('Export data is for different repository or branch');\n    }\n\n    // Save current state and import new one\n    this.saveStagingGround(exportedData.current);\n    \n    // Import history if available\n    if (exportedData.history) {\n      try {\n        const historyKey = `${this.getStorageKey()}_history`;\n        localStorage.setItem(historyKey, JSON.stringify(exportedData.history));\n      } catch (error) {\n        console.warn('Error importing history:', error);\n      }\n    }\n\n    return true;\n  }\n\n  /**\n   * Clean up old staging grounds and history\n   */\n  cleanup(maxAge = 7 * 24 * 60 * 60 * 1000) { // 7 days default\n    try {\n      const now = Date.now();\n      const keysToRemove = [];\n\n      // Check all localStorage keys for old staging grounds\n      for (let i = 0; i < localStorage.length; i++) {\n        const key = localStorage.key(i);\n        if (key && key.startsWith('sgex_staging_')) {\n          try {\n            const data = JSON.parse(localStorage.getItem(key));\n            if (data.timestamp && (now - data.timestamp) > maxAge) {\n              keysToRemove.push(key);\n              keysToRemove.push(`${key}_history`);\n            }\n          } catch (error) {\n            // Invalid data, mark for removal\n            keysToRemove.push(key);\n          }\n        }\n      }\n\n      // Remove old entries\n      keysToRemove.forEach(key => {\n        localStorage.removeItem(key);\n      });\n\n      return keysToRemove.length;\n    } catch (error) {\n      console.error('Error during cleanup:', error);\n      return 0;\n    }\n  }\n\n  /**\n   * Add listener for staging ground changes\n   */\n  addListener(callback) {\n    this.listeners.add(callback);\n    \n    // Return unsubscribe function\n    return () => {\n      this.listeners.delete(callback);\n    };\n  }\n\n  /**\n   * Notify all listeners of changes\n   */\n  notifyListeners() {\n    const stagingGround = this.getStagingGround();\n    this.listeners.forEach(callback => {\n      try {\n        callback(stagingGround);\n      } catch (error) {\n        console.error('Error in staging ground listener:', error);\n      }\n    });\n  }\n\n  /**\n   * Interface for DAK editing tools to contribute files\n   */\n  contributeFiles(files, metadata = {}) {\n    if (!Array.isArray(files)) {\n      files = [files];\n    }\n\n    let success = true;\n    const results = [];\n\n    files.forEach(file => {\n      if (!file.path || !file.content) {\n        results.push({ path: file.path, success: false, error: 'Missing path or content' });\n        success = false;\n        return;\n      }\n\n      const result = this.updateFile(file.path, file.content, {\n        ...metadata,\n        source: metadata.tool || 'unknown',\n        contributedAt: Date.now()\n      });\n\n      results.push({ path: file.path, success: result });\n      if (!result) success = false;\n    });\n\n    return { success, results };\n  }\n\n  /**\n   * Get status for DAK editing tools\n   */\n  getStatus() {\n    const stagingGround = this.getStagingGround();\n    return {\n      hasChanges: this.hasChanges(),\n      filesCount: this.getChangedFilesCount(),\n      lastModified: stagingGround.timestamp,\n      branch: this.currentBranch,\n      repository: this.currentRepository?.full_name\n    };\n  }\n}\n\n// Create singleton instance\nconst stagingGroundService = new StagingGroundService();\n\nexport default stagingGroundService;","/**\n * SecureTokenStorage - Secure storage for GitHub Personal Access Tokens\n * \n * Features:\n * - XOR encryption using browser fingerprint-based keys\n * - Token format validation (classic and fine-grained PATs)\n * - Automatic token expiration (24 hours)\n * - Secure token masking for logs and error messages\n */\n\nimport logger from '../utils/logger';\n\nclass SecureTokenStorage {\n  constructor() {\n    this.logger = logger.getLogger('SecureTokenStorage');\n    this.storageKey = 'sgex_secure_token';\n    this.expirationHours = 24;\n    this.logger.debug('SecureTokenStorage instance created');\n  }\n\n  /**\n   * Generate a browser fingerprint for encryption key\n   * @returns {string} Browser fingerprint\n   */\n  generateBrowserFingerprint() {\n    const canvas = document.createElement('canvas');\n    const ctx = canvas.getContext('2d');\n    ctx.textBaseline = 'top';\n    ctx.font = '14px Arial';\n    ctx.fillText('Browser fingerprint', 2, 2);\n    \n    const fingerprint = [\n      navigator.userAgent,\n      navigator.language,\n      window.screen.width + 'x' + window.screen.height,\n      window.screen.colorDepth,\n      new Date().getTimezoneOffset(),\n      canvas.toDataURL()\n    ].join('|');\n    \n    // Create a simple hash of the fingerprint\n    let hash = 0;\n    for (let i = 0; i < fingerprint.length; i++) {\n      const char = fingerprint.charCodeAt(i);\n      hash = ((hash << 5) - hash) + char;\n      hash = hash & hash; // Convert to 32-bit integer\n    }\n    \n    return Math.abs(hash).toString(36);\n  }\n\n  /**\n   * XOR encrypt/decrypt text using a key\n   * @param {string} text - Text to encrypt/decrypt\n   * @param {string} key - Encryption key\n   * @returns {string} Encrypted/decrypted text\n   */\n  xorCipher(text, key) {\n    let result = '';\n    for (let i = 0; i < text.length; i++) {\n      result += String.fromCharCode(\n        text.charCodeAt(i) ^ key.charCodeAt(i % key.length)\n      );\n    }\n    return result;\n  }\n\n  /**\n   * Validate GitHub Personal Access Token format\n   * @param {string} token - Token to validate\n   * @returns {object} Validation result with type and validity\n   */\n  validateTokenFormat(token) {\n    if (!token || typeof token !== 'string') {\n      return { isValid: false, type: 'invalid', reason: 'Token is empty or not a string' };\n    }\n\n    // Remove any whitespace\n    const cleanToken = token.trim();\n\n    // Classic Personal Access Token format: ghp_[36 characters A-Za-z0-9]\n    if (cleanToken.match(/^ghp_[A-Za-z0-9]{36}$/)) {\n      return { isValid: true, type: 'classic', token: cleanToken };\n    }\n\n    // Fine-grained Personal Access Token format: github_pat_[22 characters]_[59 characters]\n    if (cleanToken.match(/^github_pat_[A-Za-z0-9]{22}_[A-Za-z0-9]{59}$/)) {\n      return { isValid: true, type: 'fine-grained', token: cleanToken };\n    }\n\n    // OAuth token format: gho_[36 characters] (for completeness)\n    if (cleanToken.match(/^gho_[A-Za-z0-9]{36}$/)) {\n      return { isValid: true, type: 'oauth', token: cleanToken };\n    }\n\n    // Check for old-style tokens (40 hex characters) - deprecated but might still work\n    if (cleanToken.match(/^[a-fA-F0-9]{40}$/)) {\n      return { isValid: true, type: 'legacy', token: cleanToken };\n    }\n\n    return { \n      isValid: false, \n      type: 'invalid', \n      reason: 'Token does not match expected GitHub PAT format'\n    };\n  }\n\n  /**\n   * Mask token for safe logging\n   * @param {string} token - Token to mask\n   * @returns {string} Masked token\n   */\n  maskToken(token) {\n    if (!token || typeof token !== 'string') {\n      return '[INVALID_TOKEN]';\n    }\n\n    const cleanToken = token.trim();\n    if (cleanToken.length < 8) {\n      return '[INVALID_TOKEN]';\n    }\n\n    // Show first 4 and last 4 characters for debugging purposes\n    return `${cleanToken.substring(0, 4)}${'*'.repeat(cleanToken.length - 8)}${cleanToken.substring(cleanToken.length - 4)}`;\n  }\n\n  /**\n   * Store token securely with encryption and expiration\n   * @param {string} token - GitHub Personal Access Token\n   * @returns {boolean} Success status\n   */\n  storeToken(token) {\n    try {\n      this.logger.debug('Starting secure token storage');\n\n      // Validate token format\n      const validation = this.validateTokenFormat(token);\n      if (!validation.isValid) {\n        this.logger.warn('Token validation failed', { \n          reason: validation.reason,\n          tokenMask: this.maskToken(token)\n        });\n        return false;\n      }\n\n      this.logger.debug('Token validation successful', { \n        type: validation.type,\n        tokenMask: this.maskToken(token)\n      });\n\n      // Generate encryption key\n      const fingerprint = this.generateBrowserFingerprint();\n      const encryptionKey = `sgex_${fingerprint}_${Date.now().toString(36)}`;\n\n      // Encrypt token\n      const encryptedToken = this.xorCipher(validation.token, encryptionKey);\n      \n      // Create storage object with metadata\n      const storageData = {\n        token: btoa(encryptedToken), // Base64 encode for safe storage\n        key: btoa(encryptionKey), // Base64 encode the key\n        type: validation.type,\n        created: Date.now(),\n        expires: Date.now() + (this.expirationHours * 60 * 60 * 1000),\n        fingerprint: fingerprint\n      };\n\n      // Store in sessionStorage (more secure than localStorage for tokens)\n      sessionStorage.setItem(this.storageKey, JSON.stringify(storageData));\n      \n      // Clear any old tokens from localStorage\n      localStorage.removeItem('github_token');\n      sessionStorage.removeItem('github_token');\n\n      this.logger.debug('Token stored securely', { \n        type: validation.type,\n        expires: new Date(storageData.expires).toISOString(),\n        tokenMask: this.maskToken(token)\n      });\n\n      return true;\n    } catch (error) {\n      this.logger.error('Failed to store token securely', { \n        error: error.message,\n        tokenMask: this.maskToken(token)\n      });\n      return false;\n    }\n  }\n\n  /**\n   * Retrieve and decrypt stored token\n   * @returns {object|null} Token data or null if not found/expired\n   */\n  retrieveToken() {\n    try {\n      this.logger.debug('Attempting to retrieve secure token');\n\n      const storedData = sessionStorage.getItem(this.storageKey);\n      if (!storedData) {\n        this.logger.debug('No secure token found in storage');\n        return null;\n      }\n\n      const data = JSON.parse(storedData);\n      \n      // Check expiration\n      if (Date.now() > data.expires) {\n        this.logger.warn('Stored token has expired');\n        this.clearToken();\n        return null;\n      }\n\n      // Verify browser fingerprint\n      const currentFingerprint = this.generateBrowserFingerprint();\n      if (data.fingerprint !== currentFingerprint) {\n        this.logger.warn('Browser fingerprint mismatch - possible security issue');\n        this.clearToken();\n        return null;\n      }\n\n      // Decrypt token\n      const encryptionKey = atob(data.key);\n      const encryptedToken = atob(data.token);\n      const decryptedToken = this.xorCipher(encryptedToken, encryptionKey);\n\n      // Validate decrypted token\n      const validation = this.validateTokenFormat(decryptedToken);\n      if (!validation.isValid) {\n        this.logger.error('Decrypted token failed validation');\n        this.clearToken();\n        return null;\n      }\n\n      this.logger.debug('Token retrieved and decrypted successfully', { \n        type: data.type,\n        expires: new Date(data.expires).toISOString(),\n        tokenMask: this.maskToken(decryptedToken)\n      });\n\n      return {\n        token: validation.token,\n        type: data.type,\n        created: data.created,\n        expires: data.expires\n      };\n    } catch (error) {\n      this.logger.error('Failed to retrieve secure token', { error: error.message });\n      this.clearToken();\n      return null;\n    }\n  }\n\n  /**\n   * Check if a valid token exists without retrieving it\n   * @returns {boolean} True if valid token exists\n   */\n  hasValidToken() {\n    try {\n      const storedData = sessionStorage.getItem(this.storageKey);\n      if (!storedData) {\n        return false;\n      }\n\n      const data = JSON.parse(storedData);\n      \n      // Check expiration\n      if (Date.now() > data.expires) {\n        this.clearToken();\n        return false;\n      }\n\n      // Verify browser fingerprint\n      const currentFingerprint = this.generateBrowserFingerprint();\n      if (data.fingerprint !== currentFingerprint) {\n        this.clearToken();\n        return false;\n      }\n\n      return true;\n    } catch (error) {\n      this.logger.error('Error checking token validity', { error: error.message });\n      this.clearToken();\n      return false;\n    }\n  }\n\n  /**\n   * Clear stored token and cleanup\n   */\n  clearToken() {\n    this.logger.debug('Clearing secure token storage');\n    \n    sessionStorage.removeItem(this.storageKey);\n    \n    // Also clear legacy token storage\n    sessionStorage.removeItem('github_token');\n    localStorage.removeItem('github_token');\n  }\n\n  /**\n   * Get token expiration info\n   * @returns {object|null} Expiration info or null if no token\n   */\n  getTokenInfo() {\n    try {\n      const storedData = sessionStorage.getItem(this.storageKey);\n      if (!storedData) {\n        return null;\n      }\n\n      const data = JSON.parse(storedData);\n      const timeRemaining = data.expires - Date.now();\n      \n      return {\n        type: data.type,\n        created: new Date(data.created),\n        expires: new Date(data.expires),\n        timeRemaining: Math.max(0, timeRemaining),\n        isExpired: timeRemaining <= 0,\n        isValid: this.hasValidToken()\n      };\n    } catch (error) {\n      this.logger.error('Error getting token info', { error: error.message });\n      return null;\n    }\n  }\n\n  /**\n   * Migrate from legacy token storage\n   * @returns {boolean} True if migration was successful\n   */\n  migrateLegacyToken() {\n    try {\n      // Check for tokens in legacy storage\n      const legacyToken = sessionStorage.getItem('github_token') || localStorage.getItem('github_token');\n      \n      if (!legacyToken) {\n        this.logger.debug('No legacy token found for migration');\n        return false;\n      }\n\n      this.logger.debug('Migrating legacy token to secure storage');\n\n      // Store using new secure method\n      const success = this.storeToken(legacyToken);\n      \n      if (success) {\n        // Clear legacy storage\n        sessionStorage.removeItem('github_token');\n        localStorage.removeItem('github_token');\n        this.logger.debug('Legacy token migration completed successfully');\n        return true;\n      } else {\n        this.logger.error('Failed to migrate legacy token');\n        return false;\n      }\n    } catch (error) {\n      this.logger.error('Error during legacy token migration', { error: error.message });\n      return false;\n    }\n  }\n}\n\n// Create singleton instance\nconst secureTokenStorage = new SecureTokenStorage();\n\nexport default secureTokenStorage;","/**\n * Service for managing DAK branch context in session storage\n * Stores selected branch per repository to maintain context during DAK editing\n */\n\nclass BranchContextService {\n  constructor() {\n    this.storageKey = 'sgex_branch_context';\n  }\n\n  // Get the storage key for a specific repository\n  getRepositoryKey(repository) {\n    if (!repository || !repository.name) return null;\n    const owner = repository.owner?.login || repository.full_name?.split('/')[0];\n    if (!owner) return null;\n    return `${owner}/${repository.name}`;\n  }\n\n  // Get the selected branch for a repository\n  getSelectedBranch(repository) {\n    if (!repository) return null;\n    \n    try {\n      const branchContext = this.getBranchContext();\n      const repoKey = this.getRepositoryKey(repository);\n      return branchContext[repoKey] || null;\n    } catch (error) {\n      console.warn('Failed to get branch context:', error);\n      return null;\n    }\n  }\n\n  // Set the selected branch for a repository\n  setSelectedBranch(repository, branch) {\n    if (!repository || !branch) return;\n\n    try {\n      const branchContext = this.getBranchContext();\n      const repoKey = this.getRepositoryKey(repository);\n      branchContext[repoKey] = branch;\n      this.setBranchContext(branchContext);\n    } catch (error) {\n      console.warn('Failed to set branch context:', error);\n    }\n  }\n\n  // Clear branch context for a specific repository\n  clearRepositoryBranch(repository) {\n    if (!repository) return;\n\n    try {\n      const branchContext = this.getBranchContext();\n      const repoKey = this.getRepositoryKey(repository);\n      delete branchContext[repoKey];\n      this.setBranchContext(branchContext);\n    } catch (error) {\n      console.warn('Failed to clear repository branch context:', error);\n    }\n  }\n\n  // Clear all branch context (e.g., on logout)\n  clearAllBranchContext() {\n    try {\n      sessionStorage.removeItem(this.storageKey);\n    } catch (error) {\n      console.warn('Failed to clear branch context:', error);\n    }\n  }\n\n  // Get all branch context from storage\n  getBranchContext() {\n    try {\n      const stored = sessionStorage.getItem(this.storageKey);\n      return stored ? JSON.parse(stored) : {};\n    } catch (error) {\n      console.warn('Failed to parse branch context from storage:', error);\n      return {};\n    }\n  }\n\n  // Set branch context to storage\n  setBranchContext(context) {\n    try {\n      sessionStorage.setItem(this.storageKey, JSON.stringify(context));\n    } catch (error) {\n      console.warn('Failed to save branch context to storage:', error);\n    }\n  }\n\n  // Get default branch name (prefer 'main' over 'master')\n  getDefaultBranchName(repository, availableBranches = []) {\n    if (!repository) return 'main';\n\n    // First try 'main'\n    if (availableBranches.some(b => b.name === 'main')) {\n      return 'main';\n    }\n\n    // Then try the repository's default branch\n    if (repository.default_branch && \n        availableBranches.some(b => b.name === repository.default_branch)) {\n      return repository.default_branch;\n    }\n\n    // Finally fall back to the first available branch or 'main'\n    return availableBranches.length > 0 ? availableBranches[0].name : 'main';\n  }\n\n  // Check if a branch context exists for a repository\n  hasBranchContext(repository) {\n    return this.getSelectedBranch(repository) !== null;\n  }\n\n  // Get a formatted display string for the current branch context\n  getBranchDisplayInfo(repository) {\n    const selectedBranch = this.getSelectedBranch(repository);\n    if (!selectedBranch) return null;\n\n    const isDefault = selectedBranch === (repository?.default_branch || 'main');\n    return {\n      branch: selectedBranch,\n      isDefault,\n      displayText: isDefault ? `${selectedBranch} (default)` : selectedBranch\n    };\n  }\n}\n\n// Create a singleton instance\nconst branchContextService = new BranchContextService();\n\nexport default branchContextService;","/**\n * Utility for managing concurrent async operations with rate limiting\n */\n\n/**\n * Processes items concurrently with a specified concurrency limit\n * @param {Array} items - Items to process\n * @param {Function} processor - Async function to process each item\n * @param {Object} options - Options for concurrency control\n * @param {number} options.concurrency - Maximum concurrent operations (default: 5)\n * @param {Function} options.onProgress - Progress callback (current, total, item, result)\n * @param {Function} options.onItemComplete - Callback when item completes (item, result, error)\n * @param {Function} options.onItemStart - Callback when item starts processing (item, index)\n * @returns {Promise<Array>} Array of results (in original order)\n */\nexport async function processConcurrently(items, processor, options = {}) {\n  const {\n    concurrency = 5,\n    onProgress = null,\n    onItemComplete = null,\n    onItemStart = null\n  } = options;\n\n  if (!items || items.length === 0) {\n    return [];\n  }\n\n  const results = new Array(items.length);\n  const total = items.length;\n  let completed = 0;\n\n  // Create a queue of work items\n  const queue = items.map((item, index) => ({ item, index }));\n  \n  // Worker function that processes items from the queue\n  const worker = async () => {\n    while (queue.length > 0) {\n      const { item, index } = queue.shift();\n      \n      // Notify that processing is starting\n      if (onItemStart) {\n        onItemStart(item, index);\n      }\n      \n      try {\n        const result = await processor(item, index);\n        results[index] = result;\n        \n        completed++;\n        \n        // Call callbacks\n        if (onProgress) {\n          onProgress(completed, total, item, result);\n        }\n        if (onItemComplete) {\n          onItemComplete(item, result, null);\n        }\n      } catch (error) {\n        // Store error as result\n        results[index] = { error, item };\n        \n        completed++;\n        \n        // Call callbacks\n        if (onProgress) {\n          onProgress(completed, total, item, null);\n        }\n        if (onItemComplete) {\n          onItemComplete(item, null, error);\n        }\n      }\n    }\n  };\n\n  // Start worker promises (limited by concurrency)\n  const workers = Array(Math.min(concurrency, items.length))\n    .fill()\n    .map(() => worker());\n\n  // Wait for all workers to complete\n  await Promise.all(workers);\n\n  return results;\n}\n\n/**\n * Rate-limited function executor\n * Useful for API calls that need to respect rate limits\n */\nexport class RateLimiter {\n  constructor(requestsPerSecond = 5) {\n    this.requestsPerSecond = requestsPerSecond;\n    this.requests = [];\n    this.interval = 1000 / requestsPerSecond; // ms between requests\n  }\n\n  /**\n   * Execute a function with rate limiting\n   * @param {Function} fn - Function to execute\n   * @returns {Promise} Result of the function\n   */\n  async execute(fn) {\n    const now = Date.now();\n    \n    // Remove requests older than 1 second\n    this.requests = this.requests.filter(time => now - time < 1000);\n    \n    // If we're at the limit, wait\n    if (this.requests.length >= this.requestsPerSecond) {\n      const oldestRequest = Math.min(...this.requests);\n      const waitTime = 1000 - (now - oldestRequest) + 10; // Add 10ms buffer\n      if (waitTime > 0) {\n        await new Promise(resolve => setTimeout(resolve, waitTime));\n      }\n    }\n    \n    // Record this request\n    this.requests.push(Date.now());\n    \n    // Execute the function\n    return await fn();\n  }\n}","/**\n * Simple in-memory cache for repository compatibility checks\n * Prevents redundant sushi-config.yaml downloads during scanning\n */\n\nclass RepositoryCompatibilityCache {\n  constructor(ttlMinutes = 30) {\n    this.cache = new Map();\n    this.ttl = ttlMinutes * 60 * 1000; // Convert to milliseconds\n  }\n\n  /**\n   * Generate cache key for a repository\n   * @param {string} owner - Repository owner\n   * @param {string} repo - Repository name\n   * @returns {string} Cache key\n   */\n  _getCacheKey(owner, repo) {\n    return `${owner}/${repo}`;\n  }\n\n  /**\n   * Check if cache entry is still valid\n   * @param {Object} entry - Cache entry\n   * @returns {boolean} True if valid\n   */\n  _isValid(entry) {\n    return Date.now() - entry.timestamp < this.ttl;\n  }\n\n  /**\n   * Get cached compatibility result\n   * @param {string} owner - Repository owner\n   * @param {string} repo - Repository name\n   * @returns {boolean|null} Cached result or null if not cached/expired\n   */\n  get(owner, repo) {\n    const key = this._getCacheKey(owner, repo);\n    const entry = this.cache.get(key);\n    \n    if (!entry) {\n      return null;\n    }\n    \n    if (!this._isValid(entry)) {\n      this.cache.delete(key);\n      return null;\n    }\n    \n    return entry.compatible;\n  }\n\n  /**\n   * Set cached compatibility result\n   * @param {string} owner - Repository owner\n   * @param {string} repo - Repository name\n   * @param {boolean} compatible - Whether repository is SMART guidelines compatible\n   */\n  set(owner, repo, compatible) {\n    const key = this._getCacheKey(owner, repo);\n    this.cache.set(key, {\n      compatible,\n      timestamp: Date.now()\n    });\n  }\n\n  /**\n   * Clear all cached entries\n   */\n  clear() {\n    this.cache.clear();\n  }\n\n  /**\n   * Clean up expired entries\n   */\n  cleanup() {\n    const now = Date.now();\n    for (const [key, entry] of this.cache.entries()) {\n      if (now - entry.timestamp >= this.ttl) {\n        this.cache.delete(key);\n      }\n    }\n  }\n\n  /**\n   * Get cache statistics\n   * @returns {Object} Cache stats\n   */\n  getStats() {\n    this.cleanup();\n    return {\n      size: this.cache.size,\n      ttlMinutes: this.ttl / (60 * 1000),\n      entries: Array.from(this.cache.entries()).map(([key, entry]) => ({\n        repository: key,\n        compatible: entry.compatible,\n        ageMinutes: Math.round((Date.now() - entry.timestamp) / (60 * 1000))\n      }))\n    };\n  }\n}\n\n// Create a singleton instance\nconst repositoryCompatibilityCache = new RepositoryCompatibilityCache();\n\nexport default repositoryCompatibilityCache;","import { Octokit } from '@octokit/rest';\nimport { processConcurrently } from '../utils/concurrency';\nimport repositoryCompatibilityCache from '../utils/repositoryCompatibilityCache';\nimport secureTokenStorage from './secureTokenStorage';\nimport logger from '../utils/logger';\n\nclass GitHubService {\n  constructor() {\n    this.octokit = null;\n    this.isAuthenticated = false;\n    this.permissions = null;\n    this.tokenType = null; // 'classic', 'fine-grained', or 'oauth'\n    this.logger = logger.getLogger('GitHubService');\n    this.logger.debug('GitHubService instance created');\n  }\n\n  // Initialize with a GitHub token (supports both OAuth and PAT tokens)\n  authenticate(token) {\n    const startTime = Date.now();\n    this.logger.auth('Starting authentication', { \n      tokenProvided: !!token, \n      tokenMask: token ? secureTokenStorage.maskToken(token) : 'none'\n    });\n    \n    try {\n      // Validate token format using SecureTokenStorage\n      const validation = secureTokenStorage.validateTokenFormat(token);\n      if (!validation.isValid) {\n        this.logger.warn('Token validation failed during authentication', { \n          reason: validation.reason,\n          tokenMask: secureTokenStorage.maskToken(token)\n        });\n        this.isAuthenticated = false;\n        return false;\n      }\n\n      this.octokit = new Octokit({\n        auth: validation.token,\n      });\n      this.isAuthenticated = true;\n      this.tokenType = validation.type;\n      \n      // Store token securely\n      const stored = secureTokenStorage.storeToken(validation.token);\n      if (!stored) {\n        this.logger.warn('Failed to store token securely, authentication will not persist');\n      }\n      \n      const duration = Date.now() - startTime;\n      this.logger.auth('Authentication successful', { \n        duration, \n        tokenType: this.tokenType,\n        tokenMask: secureTokenStorage.maskToken(token),\n        securelyStored: stored\n      });\n      this.logger.performance('GitHub authentication', duration);\n      \n      return true;\n    } catch (error) {\n      const duration = Date.now() - startTime;\n      this.logger.auth('Authentication failed', { \n        error: error.message, \n        duration,\n        tokenMask: secureTokenStorage.maskToken(token)\n      });\n      console.error('Failed to authenticate with GitHub:', error);\n      this.isAuthenticated = false;\n      secureTokenStorage.clearToken(); // Clear any partially stored data\n      return false;\n    }\n  }\n\n  // Initialize with an existing Octokit instance (for OAuth flow)\n  authenticateWithOctokit(octokitInstance) {\n    this.logger.auth('Starting OAuth authentication with Octokit instance');\n    \n    try {\n      this.octokit = octokitInstance;\n      this.isAuthenticated = true;\n      this.tokenType = 'oauth';\n      \n      this.logger.auth('OAuth authentication successful', { tokenType: this.tokenType });\n      return true;\n    } catch (error) {\n      this.logger.auth('OAuth authentication failed', { error: error.message });\n      console.error('Failed to authenticate with Octokit instance:', error);\n      this.isAuthenticated = false;\n      return false;\n    }\n  }\n\n  // Initialize authentication from securely stored token\n  initializeFromStoredToken() {\n    this.logger.auth('Attempting to initialize from stored token');\n    \n    try {\n      // First try to migrate any legacy tokens\n      const migrated = secureTokenStorage.migrateLegacyToken();\n      if (migrated) {\n        this.logger.debug('Successfully migrated legacy token to secure storage');\n      }\n\n      // Retrieve token from secure storage\n      const tokenData = secureTokenStorage.retrieveToken();\n      if (!tokenData) {\n        this.logger.debug('No valid stored token found');\n        return false;\n      }\n\n      // Initialize Octokit with stored token\n      this.octokit = new Octokit({\n        auth: tokenData.token,\n      });\n      this.isAuthenticated = true;\n      this.tokenType = tokenData.type;\n      \n      this.logger.auth('Successfully initialized from stored token', {\n        tokenType: this.tokenType,\n        tokenMask: secureTokenStorage.maskToken(tokenData.token),\n        expires: new Date(tokenData.expires).toISOString()\n      });\n      \n      return true;\n    } catch (error) {\n      this.logger.auth('Failed to initialize from stored token', { error: error.message });\n      this.isAuthenticated = false;\n      secureTokenStorage.clearToken();\n      return false;\n    }\n  }\n\n  // Check if there's a valid stored token\n  hasStoredToken() {\n    return secureTokenStorage.hasValidToken();\n  }\n\n  // Get information about stored token\n  getStoredTokenInfo() {\n    return secureTokenStorage.getTokenInfo();\n  }\n\n  // Check token permissions and type\n  async checkTokenPermissions() {\n    if (!this.isAuth()) {\n      const error = new Error('Not authenticated with GitHub');\n      this.logger.error('Token permission check failed - not authenticated');\n      throw error;\n    }\n\n    const startTime = Date.now();\n    this.logger.apiCall('GET', '/user', null);\n\n    try {\n      // Try to get token info to determine type and permissions\n      const response = await this.octokit.request('GET /user');\n      this.logger.apiResponse('GET', '/user', response.status, Date.now() - startTime);\n      \n      // Check if this is a fine-grained token by trying to access rate limit info\n      try {\n        const rateLimitStart = Date.now();\n        this.logger.apiCall('GET', '/rate_limit', null);\n        const rateLimit = await this.octokit.rest.rateLimit.get();\n        this.logger.apiResponse('GET', '/rate_limit', rateLimit.status, Date.now() - rateLimitStart);\n        \n        // Fine-grained tokens have different rate limit structure\n        this.tokenType = rateLimit.data.resources.core ? 'classic' : 'fine-grained';\n        this.logger.debug('Token type determined', { tokenType: this.tokenType, hasCore: !!rateLimit.data.resources.core });\n      } catch (rateLimitError) {\n        this.tokenType = 'unknown';\n        this.logger.warn('Could not determine token type from rate limit', { error: rateLimitError.message });\n      }\n\n      const permissions = {\n        type: this.tokenType,\n        user: response.data\n      };\n      \n      this.permissions = permissions;\n      this.logger.debug('Token permissions checked successfully', { \n        tokenType: this.tokenType, \n        username: response.data.login \n      });\n      \n      return permissions;\n    } catch (error) {\n      const duration = Date.now() - startTime;\n      this.logger.apiError('GET', '/user', error);\n      this.logger.performance('Token permission check (failed)', duration);\n      console.error('Failed to check token permissions:', error);\n      throw error;\n    }\n  }\n\n  // Check if we have write permissions for a specific repository\n  async checkRepositoryWritePermissions(owner, repo) {\n    if (!this.isAuth()) {\n      this.logger.warn('Cannot check repository write permissions - not authenticated', { owner, repo });\n      return false;\n    }\n\n    const startTime = Date.now();\n    this.logger.debug('Checking write permissions for repository', { owner, repo });\n\n    try {\n      // Get current user first\n      const currentUser = await this.getCurrentUser();\n      const username = currentUser.login;\n      \n      this.logger.apiCall('GET', `/repos/${owner}/${repo}/collaborators/${username}/permission`, null);\n      \n      // Try to get repository collaborator permissions\n      const { data } = await this.octokit.rest.repos.getCollaboratorPermissionLevel({\n        owner,\n        repo,\n        username\n      });\n      \n      const duration = Date.now() - startTime;\n      this.logger.apiResponse('GET', `/repos/${owner}/${repo}/collaborators/${username}/permission`, 200, duration);\n      \n      const hasWriteAccess = ['write', 'admin'].includes(data.permission);\n      this.logger.debug('Repository write permissions checked', { \n        owner, \n        repo, \n        permission: data.permission, \n        hasWriteAccess \n      });\n      \n      return hasWriteAccess;\n    } catch (error) {\n      const duration = Date.now() - startTime;\n      this.logger.apiError('GET', `/repos/${owner}/${repo}/collaborators/*/permission`, error);\n      this.logger.performance('Repository write permission check (failed)', duration);\n      \n      // If we can't check permissions, assume we don't have write access\n      console.warn('Could not check repository write permissions:', error);\n      this.logger.warn('Assuming no write access due to permission check failure', { owner, repo, error: error.message });\n      return false;\n    }\n  }\n\n  // Alias method for backward compatibility - delegates to checkRepositoryWritePermissions\n  async checkRepositoryPermissions(owner, repo) {\n    return this.checkRepositoryWritePermissions(owner, repo);\n  }\n\n  // Check if authenticated\n  isAuth() {\n    return this.isAuthenticated && this.octokit !== null;\n  }\n\n  // Get current user data\n  async getCurrentUser() {\n    if (!this.isAuth()) {\n      throw new Error('Not authenticated with GitHub');\n    }\n\n    try {\n      const { data } = await this.octokit.rest.users.getAuthenticated();\n      return data;\n    } catch (error) {\n      console.error('Failed to fetch user data:', error);\n      throw error;\n    }\n  }\n\n  // Get user's organizations\n  async getUserOrganizations() {\n    if (!this.isAuth()) {\n      throw new Error('Not authenticated with GitHub');\n    }\n\n    try {\n      const { data } = await this.octokit.rest.orgs.listForAuthenticatedUser();\n      return data;\n    } catch (error) {\n      console.error('Failed to fetch organizations:', error);\n      throw error;\n    }\n  }\n\n  // Get specific organization data (public data, no auth required)\n  async getOrganization(orgLogin) {\n    try {\n      // Create a temporary Octokit instance for public API calls if we don't have one\n      const octokit = this.octokit || new Octokit();\n      \n      const { data } = await octokit.rest.orgs.get({\n        org: orgLogin\n      });\n      return data;\n    } catch (error) {\n      console.error(`Failed to fetch organization ${orgLogin}:`, error);\n      throw error;\n    }\n  }\n\n  // Get specific user data (public data, no auth required)\n  async getUser(username) {\n    try {\n      // Create a temporary Octokit instance for public API calls if we don't have one\n      const octokit = this.octokit || new Octokit();\n      \n      const { data } = await octokit.rest.users.getByUsername({\n        username\n      });\n      return data;\n    } catch (error) {\n      console.error(`Failed to fetch user ${username}:`, error);\n      throw error;\n    }\n  }\n\n  // Get WHO organization data with fresh avatar\n  async getWHOOrganization() {\n    try {\n      const whoData = await this.getOrganization('WorldHealthOrganization');\n      return {\n        id: whoData.id,\n        login: whoData.login,\n        display_name: whoData.name || 'World Health Organization',\n        description: whoData.description || 'The World Health Organization is a specialized agency of the United Nations responsible for international public health.',\n        avatar_url: whoData.avatar_url,\n        html_url: whoData.html_url,\n        type: 'Organization',\n        permissions: {\n          can_create_repositories: true,\n          can_create_private_repositories: true\n        },\n        plan: {\n          name: 'Organization',\n          private_repos: 'unlimited'\n        },\n        isWHO: true\n      };\n    } catch (error) {\n      console.warn('Could not fetch WHO organization data from API, using fallback:', error);\n      // Return hardcoded fallback data\n      return {\n        id: 'who-organization',\n        login: 'WorldHealthOrganization',\n        display_name: 'World Health Organization',\n        description: 'The World Health Organization is a specialized agency of the United Nations responsible for international public health.',\n        avatar_url: 'https://avatars.githubusercontent.com/u/12261302?s=200&v=4',\n        html_url: 'https://github.com/WorldHealthOrganization',\n        type: 'Organization',\n        permissions: {\n          can_create_repositories: true,\n          can_create_private_repositories: true\n        },\n        plan: {\n          name: 'Organization',\n          private_repos: 'unlimited'\n        },\n        isWHO: true\n      };\n    }\n  }\n\n  // Get repositories for a user or organization (now filters by SMART Guidelines compatibility)\n  async getRepositories(owner, type = 'user', isDemo = false) {\n    // Handle demo mode - return demo repositories without requiring authentication\n    if (isDemo || owner === 'demo-user') {\n      return this.getDemoRepositories(owner);\n    }\n    \n    // Use the new SMART guidelines filtering method\n    return this.getSmartGuidelinesRepositories(owner, type);\n  }\n\n  // Get demo repositories for demo mode (no authentication required)\n  getDemoRepositories(owner) {\n    const demoRepos = [\n      {\n        id: 'demo-smart-anc',\n        name: 'smart-anc',\n        full_name: `${owner}/smart-anc`,\n        description: 'Demo SMART Guidelines Digital Adaptation Kit for Antenatal Care',\n        private: false,\n        owner: {\n          login: owner,\n          id: 'demo-owner',\n          avatar_url: `https://github.com/${owner}.png`,\n          type: 'User'\n        },\n        html_url: `https://github.com/${owner}/smart-anc`,\n        clone_url: `https://github.com/${owner}/smart-anc.git`,\n        language: 'FSH',\n        stargazers_count: 15,\n        forks_count: 3,\n        open_issues_count: 2,\n        topics: ['who', 'smart-guidelines', 'dak', 'antenatal-care', 'health'],\n        created_at: '2023-01-15T10:00:00Z',\n        updated_at: '2024-12-15T14:30:00Z',\n        pushed_at: '2024-12-15T14:30:00Z',\n        default_branch: 'main',\n        smart_guidelines_compatible: true,\n        isDemo: true\n      },\n      {\n        id: 'demo-smart-tb',\n        name: 'smart-tb',\n        full_name: `${owner}/smart-tb`,\n        description: 'Demo SMART Guidelines Digital Adaptation Kit for Tuberculosis Care',\n        private: false,\n        owner: {\n          login: owner,\n          id: 'demo-owner',\n          avatar_url: `https://github.com/${owner}.png`,\n          type: 'User'\n        },\n        html_url: `https://github.com/${owner}/smart-tb`,\n        clone_url: `https://github.com/${owner}/smart-tb.git`,\n        language: 'FSH',\n        stargazers_count: 8,\n        forks_count: 1,\n        open_issues_count: 0,\n        topics: ['who', 'smart-guidelines', 'dak', 'tuberculosis', 'health'],\n        created_at: '2023-03-20T15:00:00Z',\n        updated_at: '2024-11-30T09:15:00Z',\n        pushed_at: '2024-11-30T09:15:00Z',\n        default_branch: 'main',\n        smart_guidelines_compatible: true,\n        isDemo: true\n      },\n      {\n        id: 'demo-smart-ips-pilgrimage',\n        name: 'smart-ips-pilgrimage',\n        full_name: `${owner}/smart-ips-pilgrimage`,\n        description: 'Demo SMART Guidelines International Patient Summary for Pilgrimage',\n        private: false,\n        owner: {\n          login: owner,\n          id: 'demo-owner',\n          avatar_url: `https://github.com/${owner}.png`,\n          type: 'User'\n        },\n        html_url: `https://github.com/${owner}/smart-ips-pilgrimage`,\n        clone_url: `https://github.com/${owner}/smart-ips-pilgrimage.git`,\n        language: 'FSH',\n        stargazers_count: 12,\n        forks_count: 2,\n        open_issues_count: 1,\n        topics: ['who', 'smart-guidelines', 'dak', 'ips', 'pilgrimage', 'health'],\n        created_at: '2023-06-10T12:00:00Z',\n        updated_at: '2024-12-01T16:45:00Z',\n        pushed_at: '2024-12-01T16:45:00Z',\n        default_branch: 'main',\n        smart_guidelines_compatible: true,\n        isDemo: true\n      }\n    ];\n\n    return Promise.resolve(demoRepos);\n  }\n\n  // Check if a repository has sushi-config.yaml with smart.who.int.base dependency\n  async checkSmartGuidelinesCompatibility(owner, repo, retryCount = 2) {\n    if (!this.isAuth()) {\n      return false;\n    }\n\n    // Check cache first to prevent redundant downloads\n    const cachedResult = repositoryCompatibilityCache.get(owner, repo);\n    if (cachedResult !== null) {\n      return cachedResult;\n    }\n\n    try {\n      // Try to get sushi-config.yaml from the repository root\n      const { data } = await this.octokit.rest.repos.getContent({\n        owner,\n        repo,\n        path: 'sushi-config.yaml',\n      });\n\n      if (data.type === 'file' && data.content) {\n        // Decode base64 content (browser-compatible)\n        const content = decodeURIComponent(escape(atob(data.content)));\n        \n        // Check if the content contains smart.who.int.base in dependencies\n        const isCompatible = content.includes('smart.who.int.base');\n        \n        // Cache the result\n        repositoryCompatibilityCache.set(owner, repo, isCompatible);\n        return isCompatible;\n      }\n      \n      // Cache negative result\n      repositoryCompatibilityCache.set(owner, repo, false);\n      return false;\n    } catch (error) {\n      // If it's a 404 (file not found), retry once more in case of temporary issues\n      if (error.status === 404 && retryCount > 0) {\n        console.warn(`File not found for ${owner}/${repo}, retrying... (${retryCount} attempts left)`);\n        // Use shorter delay in test environment\n        const delay = process.env.NODE_ENV === 'test' ? 10 : 1000;\n        await new Promise(resolve => setTimeout(resolve, delay));\n        return this.checkSmartGuidelinesCompatibility(owner, repo, retryCount - 1);\n      }\n      \n      // For any error (including rate limiting, network errors, or file not found after retries),\n      // strictly return false - no fallback logic\n      console.warn(`Failed to check ${owner}/${repo} for sushi-config.yaml with smart.who.int.base dependency:`, error.message);\n      \n      // Cache negative result\n      repositoryCompatibilityCache.set(owner, repo, false);\n      return false;\n    }\n  }\n\n\n\n  // Get repositories that are SMART guidelines compatible\n  async getSmartGuidelinesRepositories(owner, type = 'user') {\n    if (!this.isAuth()) {\n      throw new Error('Not authenticated with GitHub');\n    }\n\n    try {\n      let repositories = [];\n      let page = 1;\n      let hasMorePages = true;\n\n      // Fetch all repositories using pagination\n      while (hasMorePages) {\n        let response;\n        if (type === 'user') {\n          response = await this.octokit.rest.repos.listForUser({\n            username: owner,\n            sort: 'updated',\n            per_page: 100,\n            page: page,\n          });\n        } else {\n          response = await this.octokit.rest.repos.listForOrg({\n            org: owner,\n            sort: 'updated',\n            per_page: 100,\n            page: page,\n          });\n        }\n\n        repositories = repositories.concat(response.data);\n        \n        // Check if there are more pages\n        hasMorePages = response.data.length === 100;\n        page++;\n      }\n\n      // Check each repository for SMART guidelines compatibility\n      const smartGuidelinesRepos = [];\n      for (const repo of repositories) {\n        const isCompatible = await this.checkSmartGuidelinesCompatibility(repo.owner.login, repo.name);\n        if (isCompatible) {\n          smartGuidelinesRepos.push({\n            ...repo,\n            smart_guidelines_compatible: true\n          });\n        }\n      }\n\n      return smartGuidelinesRepos;\n    } catch (error) {\n      console.error('Failed to fetch SMART guidelines repositories:', error);\n      throw error;\n    }\n  }\n\n  // Get repositories with progressive scanning (for real-time updates)\n  async getSmartGuidelinesRepositoriesProgressive(owner, type = 'user', onRepositoryFound = null, onProgress = null) {\n    if (!this.isAuth()) {\n      throw new Error('Not authenticated with GitHub');\n    }\n\n    try {\n      let repositories = [];\n      let page = 1;\n      let hasMorePages = true;\n\n      // Fetch all repositories using pagination\n      while (hasMorePages) {\n        let response;\n        if (type === 'user') {\n          response = await this.octokit.rest.repos.listForUser({\n            username: owner,\n            sort: 'updated',\n            per_page: 100,\n            page: page,\n          });\n        } else {\n          response = await this.octokit.rest.repos.listForOrg({\n            org: owner,\n            sort: 'updated',\n            per_page: 100,\n            page: page,\n          });\n        }\n\n        repositories = repositories.concat(response.data);\n        \n        // Check if there are more pages\n        hasMorePages = response.data.length === 100;\n        page++;\n      }\n\n      // Handle case where user has no repositories\n      if (repositories.length === 0) {\n        console.log(' No repositories found for user, completing scan immediately');\n        // Call progress callback to indicate completion\n        if (onProgress) {\n          onProgress({\n            current: 0,\n            total: 0,\n            currentRepo: 'none',\n            progress: 100,\n            completed: true\n          });\n        }\n        return [];\n      }\n\n      // Process repositories concurrently with rate limiting and enhanced display\n      const processor = async (repo, index) => {\n        // Add a small delay to make scanning progress visible (similar to demo mode)\n        await new Promise(resolve => setTimeout(resolve, 100 + Math.random() * 200));\n        \n        const isCompatible = await this.checkSmartGuidelinesCompatibility(repo.owner.login, repo.name);\n        \n        if (isCompatible) {\n          const smartRepo = {\n            ...repo,\n            smart_guidelines_compatible: true\n          };\n          \n          // Notify that a repository was found\n          if (onRepositoryFound) {\n            onRepositoryFound(smartRepo);\n          }\n          \n          return smartRepo;\n        }\n        \n        return null;\n      };\n\n      // Use concurrent processing with max 5 parallel requests\n      const results = await processConcurrently(repositories, processor, {\n        concurrency: 5,\n        onProgress: (completed, total, repo, result) => {\n          // Progress callback for completed items\n          if (onProgress) {\n            onProgress({\n              current: completed,\n              total: total,\n              currentRepo: repo.name,\n              progress: Math.round((completed / total) * 100),\n              completed: true\n            });\n          }\n        },\n        onItemStart: (repo, index) => {\n          // Progress callback for started items\n          if (onProgress) {\n            onProgress({\n              current: index + 1,\n              total: repositories.length,\n              currentRepo: repo.name,\n              progress: Math.round(((index + 1) / repositories.length) * 100),\n              completed: false,\n              started: true\n            });\n          }\n        }\n      });\n\n      // Filter out null results and collect smart repositories\n      const validResults = results.filter(result => result !== null && !result.error);\n      \n      return validResults;\n    } catch (error) {\n      console.error('Failed to fetch SMART guidelines repositories:', error);\n      throw error;\n    }\n  }\n\n  // Get a specific repository\n  async getRepository(owner, repo) {\n    try {\n      // Use authenticated octokit if available, otherwise create a public instance for public repos\n      const octokit = this.isAuth() ? this.octokit : new Octokit();\n      \n      const { data } = await octokit.rest.repos.get({\n        owner,\n        repo,\n      });\n      return data;\n    } catch (error) {\n      console.error('Failed to fetch repository:', error);\n      throw error;\n    }  \n  }\n\n  // Get repository branches\n  async getBranches(owner, repo) {\n    try {\n      console.log(`githubService.getBranches: Fetching branches for ${owner}/${repo}`);\n      console.log('githubService.getBranches: Authentication status:', this.isAuth());\n      \n      // Use authenticated octokit if available, otherwise create a public instance for public repos\n      const octokit = this.isAuth() ? this.octokit : new Octokit();\n      console.log('githubService.getBranches: Using', this.isAuth() ? 'authenticated' : 'public', 'octokit instance');\n      \n      const { data } = await octokit.rest.repos.listBranches({\n        owner,\n        repo,\n        per_page: 100\n      });\n      \n      console.log(`githubService.getBranches: Successfully fetched ${data.length} branches`);\n      return data;\n    } catch (error) {\n      console.error('githubService.getBranches: Failed to fetch branches:', error);\n      console.error('githubService.getBranches: Error details:', {\n        status: error.status,\n        message: error.message,\n        owner,\n        repo\n      });\n      throw error;\n    }\n  }\n\n  // Create a new branch\n  async createBranch(owner, repo, branchName, fromBranch = 'main') {\n    if (!this.isAuth()) {\n      throw new Error('Not authenticated with GitHub');\n    }\n\n    try {\n      // First get the SHA of the source branch\n      const { data: refData } = await this.octokit.rest.git.getRef({\n        owner,\n        repo,\n        ref: `heads/${fromBranch}`\n      });\n\n      // Create the new branch\n      const { data } = await this.octokit.rest.git.createRef({\n        owner,\n        repo,\n        ref: `refs/heads/${branchName}`,\n        sha: refData.object.sha\n      });\n\n      return data;\n    } catch (error) {\n      console.error('Failed to create branch:', error);\n      throw error;\n    }\n  }\n\n  // Get a specific branch\n  async getBranch(owner, repo, branch) {\n    try {\n      // Use authenticated octokit if available, otherwise create a public instance for public repos\n      const octokit = this.isAuth() ? this.octokit : new Octokit();\n      \n      const { data } = await octokit.rest.repos.getBranch({\n        owner,\n        repo,\n        branch\n      });\n      return data;\n    } catch (error) {\n      console.error('Failed to fetch branch:', error);\n      throw error;\n    }\n  }\n\n  // GitHub Actions API methods\n  \n  // Get workflows for a repository (using GitHub API to include workflow IDs)\n  async getWorkflows(owner, repo) {\n    if (!this.isAuth()) {\n      throw new Error('Not authenticated with GitHub');\n    }\n\n    try {\n      // Use GitHub Actions API to get workflows with their IDs\n      const { data } = await this.octokit.rest.actions.listRepoWorkflows({\n        owner,\n        repo\n      });\n\n      return data.workflows.map(workflow => ({\n        id: workflow.id, // This is the crucial missing piece!\n        name: workflow.name,\n        filename: workflow.path.split('/').pop(), // Extract filename from path\n        path: workflow.path,\n        state: workflow.state,\n        created_at: workflow.created_at,\n        updated_at: workflow.updated_at,\n        url: workflow.html_url,\n        triggers: ['unknown'], // GitHub API doesn't provide trigger info directly\n        lastModified: workflow.updated_at\n      }));\n    } catch (error) {\n      if (error.status === 404) {\n        // No workflows or repository not found\n        return [];\n      }\n      console.error('Failed to fetch workflows:', error);\n      throw error;\n    }\n  }\n\n  // Get workflow runs for a repository\n  async getWorkflowRuns(owner, repo, options = {}) {\n    if (!this.isAuth()) {\n      throw new Error('Not authenticated with GitHub');\n    }\n\n    try {\n      const params = {\n        owner,\n        repo,\n        per_page: options.per_page || 10,\n        page: options.page || 1\n      };\n\n      if (options.branch) {\n        params.branch = options.branch;\n      }\n\n      if (options.workflow_id) {\n        params.workflow_id = options.workflow_id;\n      }\n\n      const { data } = await this.octokit.rest.actions.listWorkflowRunsForRepo(params);\n      return data;\n    } catch (error) {\n      console.error('Failed to fetch workflow runs:', error);\n      throw error;\n    }\n  }\n\n  // Get workflow runs for a specific workflow\n  async getWorkflowRunsForWorkflow(owner, repo, workflow_id, options = {}) {\n    if (!this.isAuth()) {\n      throw new Error('Not authenticated with GitHub');\n    }\n\n    try {\n      const params = {\n        owner,\n        repo,\n        workflow_id,\n        per_page: options.per_page || 10,\n        page: options.page || 1\n      };\n\n      if (options.branch) {\n        params.branch = options.branch;\n      }\n\n      const { data } = await this.octokit.rest.actions.listWorkflowRuns(params);\n      return data;\n    } catch (error) {\n      console.error('Failed to fetch workflow runs for workflow:', error);\n      throw error;\n    }\n  }\n\n  // Trigger a workflow run\n  async triggerWorkflow(owner, repo, workflow_id, ref = 'main', inputs = {}) {\n    if (!this.isAuth()) {\n      throw new Error('Not authenticated with GitHub');\n    }\n\n    try {\n      const { data } = await this.octokit.rest.actions.createWorkflowDispatch({\n        owner,\n        repo,\n        workflow_id,\n        ref,\n        inputs\n      });\n      return data;\n    } catch (error) {\n      console.error('Failed to trigger workflow:', error);\n      throw error;\n    }\n  }\n\n  // Re-run a workflow\n  async rerunWorkflow(owner, repo, run_id) {\n    if (!this.isAuth()) {\n      throw new Error('Not authenticated with GitHub');\n    }\n\n    try {\n      const { data } = await this.octokit.rest.actions.reRunWorkflow({\n        owner,\n        repo,\n        run_id\n      });\n      return data;\n    } catch (error) {\n      console.error('Failed to re-run workflow:', error);\n      throw error;\n    }\n  }\n\n  // Get workflow run logs\n  async getWorkflowRunLogs(owner, repo, run_id) {\n    if (!this.isAuth()) {\n      throw new Error('Not authenticated with GitHub');\n    }\n\n    try {\n      const { data } = await this.octokit.rest.actions.downloadWorkflowRunLogs({\n        owner,\n        repo,\n        run_id\n      });\n      return data;\n    } catch (error) {\n      console.error('Failed to get workflow run logs:', error);\n      throw error;\n    }\n  }\n\n  // Approve a workflow run\n  async approveWorkflowRun(owner, repo, run_id) {\n    if (!this.isAuth()) {\n      throw new Error('Not authenticated with GitHub');\n    }\n\n    try {\n      const { data } = await this.octokit.rest.actions.approveWorkflowRun({\n        owner,\n        repo,\n        run_id\n      });\n      return data;\n    } catch (error) {\n      console.error('Failed to approve workflow run:', error);\n      throw error;\n    }\n  }\n\n  // Get commit comparison (diff)\n  async getCommitDiff(owner, repo, base, head) {\n    if (!this.isAuth()) {\n      throw new Error('Not authenticated with GitHub');\n    }\n\n    try {\n      const { data } = await this.octokit.rest.repos.compareCommits({\n        owner,\n        repo,\n        base,\n        head\n      });\n      return data;\n    } catch (error) {\n      console.error('Failed to get commit diff:', error);\n      throw error;\n    }\n  }\n\n  // Get commit details\n  async getCommit(owner, repo, sha) {\n    if (!this.isAuth()) {\n      throw new Error('Not authenticated with GitHub');\n    }\n\n    try {\n      const { data } = await this.octokit.rest.repos.getCommit({\n        owner,\n        repo,\n        ref: sha\n      });\n      return data;\n    } catch (error) {\n      console.error('Failed to get commit details:', error);\n      throw error;\n    }\n  }\n\n  // Releases API methods\n\n  // Get releases for a repository\n  async getReleases(owner, repo, options = {}) {\n    if (!this.isAuth()) {\n      throw new Error('Not authenticated with GitHub');\n    }\n\n    try {\n      const { data } = await this.octokit.rest.repos.listReleases({\n        owner,\n        repo,\n        per_page: options.per_page || 10,\n        page: options.page || 1\n      });\n      return data;\n    } catch (error) {\n      console.error('Failed to fetch releases:', error);\n      throw error;\n    }\n  }\n\n  // Get latest release\n  async getLatestRelease(owner, repo) {\n    if (!this.isAuth()) {\n      throw new Error('Not authenticated with GitHub');\n    }\n\n    try {\n      const { data } = await this.octokit.rest.repos.getLatestRelease({\n        owner,\n        repo\n      });\n      return data;\n    } catch (error) {\n      console.error('Failed to fetch latest release:', error);\n      throw error;\n    }\n  }\n\n  // Recursively fetch BPMN files from a directory and its subdirectories\n  async getBpmnFilesRecursive(owner, repo, path, ref = 'main', allFiles = []) {\n    try {\n      console.log(` githubService.getBpmnFilesRecursive: Searching ${owner}/${repo}/${path} (ref: ${ref})`);\n      // Use authenticated octokit if available, otherwise create a public instance\n      const octokit = this.isAuth() ? this.octokit : new Octokit();\n      console.log(` githubService.getBpmnFilesRecursive: Using ${this.isAuth() ? 'authenticated' : 'public'} octokit`);\n      \n      const { data } = await octokit.rest.repos.getContent({\n        owner,\n        repo,\n        path,\n        ref\n      });\n\n      console.log(` githubService.getBpmnFilesRecursive: Received data type: ${Array.isArray(data) ? 'array' : 'single file'}, length: ${Array.isArray(data) ? data.length : 1}`);\n\n      // Handle single file response\n      if (!Array.isArray(data)) {\n        if (data.name.endsWith('.bpmn')) {\n          console.log(` githubService.getBpmnFilesRecursive: Found single BPMN file: ${data.name}`);\n          allFiles.push(data);\n        }\n        return allFiles;\n      }\n\n      // Handle directory response\n      for (const item of data) {\n        if (item.type === 'file' && item.name.endsWith('.bpmn')) {\n          console.log(` githubService.getBpmnFilesRecursive: Found BPMN file: ${item.name}`);\n          allFiles.push(item);\n        } else if (item.type === 'dir') {\n          console.log(` githubService.getBpmnFilesRecursive: Found subdirectory: ${item.name}, recursing...`);\n          // Recursively search subdirectories\n          await this.getBpmnFilesRecursive(owner, repo, item.path, ref, allFiles);\n        }\n      }\n\n      console.log(` githubService.getBpmnFilesRecursive: Completed search of ${path}, found ${allFiles.length} total files so far`);\n      return allFiles;\n    } catch (error) {\n      console.log(` githubService.getBpmnFilesRecursive: Error searching ${path}:`, error.status, error.message);\n      // If directory doesn't exist, return empty array (not an error)\n      if (error.status === 404) {\n        return allFiles;\n      }\n      throw error;\n    }\n  }\n\n  // Get all BPMN files from a repository's business process directories\n  async getBpmnFiles(owner, repo, ref = 'main') {\n    console.log(` githubService.getBpmnFiles: Starting search for ${owner}/${repo} (ref: ${ref})`);\n    const allBpmnFiles = [];\n    \n    // Search for BPMN files in the specified business process directories\n    const possiblePaths = [\n      'input/business-processes',\n      'input/business-process'\n    ];\n\n    for (const path of possiblePaths) {\n      try {\n        console.log(` githubService.getBpmnFiles: Searching in directory: ${path}`);\n        const files = await this.getBpmnFilesRecursive(owner, repo, path, ref);\n        console.log(` githubService.getBpmnFiles: Found ${files.length} BPMN files in ${path}`);\n        allBpmnFiles.push(...files);\n      } catch (error) {\n        // Only log warnings for unexpected errors (not 404s which are expected when directories don't exist)\n        if (error.status !== 404) {\n          console.warn(` Could not fetch BPMN files from ${path}:`, error.message);\n        } else {\n          console.log(` githubService.getBpmnFiles: Directory ${path} not found (404) - this is expected if the directory doesn't exist`);\n        }\n        // Continue trying other paths\n      }\n    }\n\n    // Remove duplicates based on path (in case both directories exist and have overlapping files)\n    const uniqueFiles = allBpmnFiles.filter((file, index, self) => \n      index === self.findIndex(f => f.path === file.path)\n    );\n\n    console.log(` githubService.getBpmnFiles: Final result - ${uniqueFiles.length} unique BPMN files found`);\n    console.log(` githubService.getBpmnFiles: File list:`, uniqueFiles.map(f => f.name));\n    return uniqueFiles;\n  }\n\n  // Get file content from GitHub repository with timeout handling\n  async getFileContent(owner, repo, path, ref = 'main') {\n    const timeoutMs = 15000; // 15 second timeout\n    \n    try {\n      console.log(` githubService.getFileContent: Starting request for ${owner}/${repo}/${path} (ref: ${ref})`);\n      console.log(' githubService.getFileContent: Authentication status:', this.isAuth());\n      console.log(' githubService.getFileContent: Request parameters:', { owner, repo, path, ref });\n      \n      // Use authenticated octokit if available, otherwise create a public instance for public repos\n      const octokit = this.isAuth() ? this.octokit : new Octokit();\n      console.log(' githubService.getFileContent: Using', this.isAuth() ? 'authenticated' : 'public', 'octokit instance');\n      \n      // Create a promise that rejects after timeout\n      const timeoutPromise = new Promise((_, reject) => {\n        console.log(` githubService.getFileContent: Setting up ${timeoutMs}ms timeout`);\n        setTimeout(() => {\n          console.error(` githubService.getFileContent: Request timed out after ${timeoutMs}ms`);\n          reject(new Error(`Request timeout after ${timeoutMs}ms`));\n        }, timeoutMs);\n      });\n      \n      // Race the GitHub API call against the timeout\n      console.log(' githubService.getFileContent: Creating GitHub API promise...');\n      const apiPromise = octokit.rest.repos.getContent({\n        owner,\n        repo,\n        path,\n        ref\n      });\n      \n      console.log(' githubService.getFileContent: API request initiated, waiting for response...');\n      const startTime = Date.now();\n      \n      const { data } = await Promise.race([apiPromise, timeoutPromise]);\n      const responseTime = Date.now() - startTime;\n      \n      console.log(` githubService.getFileContent: API response received in ${responseTime}ms`);\n      console.log(' githubService.getFileContent: Response data type:', data.type);\n      console.log(' githubService.getFileContent: Response details:', {\n        type: data.type,\n        name: data.name,\n        size: data.size,\n        encoding: data.encoding,\n        hasContent: !!data.content\n      });\n\n      // Handle file content\n      if (data.type === 'file' && data.content) {\n        // Decode base64 content\n        console.log(' githubService.getFileContent: Decoding base64 content...');\n        console.log(' githubService.getFileContent: Base64 content length:', data.content.length);\n        \n        const content = decodeURIComponent(escape(atob(data.content)));\n        console.log(` githubService.getFileContent: Successfully fetched and decoded file content`);\n        console.log(' githubService.getFileContent: Final content length:', content.length, 'characters');\n        console.log(' githubService.getFileContent: Content preview (first 200 chars):', content.substring(0, 200));\n        \n        return content;\n      } else {\n        console.error(' githubService.getFileContent: Invalid response - not a file or no content');\n        console.error(' githubService.getFileContent: Full response data:', JSON.stringify(data, null, 2));\n        throw new Error('File not found or is not a file');\n      }\n    } catch (error) {\n      console.error(` githubService.getFileContent: Failed to fetch file content from ${owner}/${repo}/${path}:`, error);\n      console.error(' githubService.getFileContent: Error analysis:', {\n        type: typeof error,\n        status: error.status,\n        message: error.message,\n        name: error.name,\n        stack: error.stack?.substring(0, 500) + '...'\n      });\n      \n      // Provide more specific error messages\n      if (error.message.includes('timeout')) {\n        console.error(' githubService.getFileContent: Timeout error detected');\n        throw new Error(`GitHub API request timed out after ${timeoutMs / 1000} seconds. Please try again.`);\n      } else if (error.status === 403) {\n        console.error(' githubService.getFileContent: 403 Forbidden error detected');\n        throw new Error('Access denied. This repository may be private or you may have hit rate limits.');\n      } else if (error.status === 404) {\n        console.error(' githubService.getFileContent: 404 Not Found error detected');\n        throw new Error('File not found in the repository.');\n      } else if (error.message.includes('rate limit')) {\n        console.error(' githubService.getFileContent: Rate limit error detected');\n        throw new Error('GitHub API rate limit exceeded. Please try again later.');\n      } else if (error.message.includes('Network Error') || error.message.includes('Failed to fetch')) {\n        console.error(' githubService.getFileContent: Network error detected');\n        throw new Error('Network error occurred. Please check your internet connection and try again.');\n      }\n      \n      console.error(' githubService.getFileContent: Unknown error type, re-throwing original error');\n      throw error;\n    }\n  }\n\n  // Create a commit with multiple files\n  async createCommit(owner, repo, branch, message, files) {\n    if (!this.isAuth()) {\n      throw new Error('Not authenticated with GitHub');\n    }\n\n    try {\n      // Get the latest commit SHA\n      const { data: refData } = await this.octokit.rest.git.getRef({\n        owner,\n        repo,\n        ref: `heads/${branch}`\n      });\n      const latestCommitSha = refData.object.sha;\n\n      // Get the tree SHA from the latest commit\n      const { data: commitData } = await this.octokit.rest.git.getCommit({\n        owner,\n        repo,\n        commit_sha: latestCommitSha\n      });\n      const baseTreeSha = commitData.tree.sha;\n\n      // Create blobs for all files\n      const blobs = await Promise.all(\n        files.map(async (file) => {\n          const { data: blobData } = await this.octokit.rest.git.createBlob({\n            owner,\n            repo,\n            content: file.content,\n            encoding: 'utf-8'\n          });\n          return {\n            path: file.path,\n            mode: '100644',\n            type: 'blob',\n            sha: blobData.sha\n          };\n        })\n      );\n\n      // Create a new tree with the blobs\n      const { data: treeData } = await this.octokit.rest.git.createTree({\n        owner,\n        repo,\n        base_tree: baseTreeSha,\n        tree: blobs\n      });\n\n      // Create the commit\n      const { data: newCommitData } = await this.octokit.rest.git.createCommit({\n        owner,\n        repo,\n        message,\n        tree: treeData.sha,\n        parents: [latestCommitSha]\n      });\n\n      // Update the branch reference\n      await this.octokit.rest.git.updateRef({\n        owner,\n        repo,\n        ref: `heads/${branch}`,\n        sha: newCommitData.sha\n      });\n\n      return {\n        sha: newCommitData.sha,\n        html_url: `https://github.com/${owner}/${repo}/commit/${newCommitData.sha}`,\n        message: newCommitData.message,\n        author: newCommitData.author,\n        committer: newCommitData.committer\n      };\n    } catch (error) {\n      console.error('Failed to create commit:', error);\n      throw error;\n    }\n  }\n\n  // Get recent commits for a repository branch\n  async getRecentCommits(owner, repo, branch = 'main', per_page = 5) {\n    if (!this.isAuth()) {\n      throw new Error('Not authenticated with GitHub');\n    }\n\n    const startTime = Date.now();\n    this.logger.apiCall('GET', `/repos/${owner}/${repo}/commits`, { sha: branch, per_page });\n\n    try {\n      const response = await this.octokit.rest.repos.listCommits({\n        owner,\n        repo,\n        sha: branch,\n        per_page\n      });\n\n      this.logger.apiResponse('GET', `/repos/${owner}/${repo}/commits`, response.status, Date.now() - startTime);\n      \n      return response.data.map(commit => ({\n        sha: commit.sha,\n        message: commit.commit.message,\n        author: {\n          name: commit.commit.author.name,\n          email: commit.commit.author.email,\n          date: commit.commit.author.date\n        },\n        committer: {\n          name: commit.commit.committer.name,\n          email: commit.commit.committer.email,\n          date: commit.commit.committer.date\n        },\n        html_url: commit.html_url,\n        stats: commit.stats\n      }));\n    } catch (error) {\n      this.logger.apiResponse('GET', `/repos/${owner}/${repo}/commits`, error.status || 'error', Date.now() - startTime);\n      console.error('Failed to fetch recent commits:', error);\n      throw error;\n    }\n  }\n\n  // Get open pull requests count\n  async getOpenPullRequestsCount(owner, repo) {\n    if (!this.isAuth()) {\n      throw new Error('Not authenticated with GitHub');\n    }\n\n    const startTime = Date.now();\n    this.logger.apiCall('GET', `/repos/${owner}/${repo}/pulls`, { state: 'open', per_page: 1 });\n\n    try {\n      const response = await this.octokit.rest.pulls.list({\n        owner,\n        repo,\n        state: 'open',\n        per_page: 1\n      });\n\n      this.logger.apiResponse('GET', `/repos/${owner}/${repo}/pulls`, response.status, Date.now() - startTime);\n      \n      // GitHub includes the total count in the response headers\n      const linkHeader = response.headers.link;\n      if (linkHeader && linkHeader.includes('rel=\"last\"')) {\n        const lastPageMatch = linkHeader.match(/page=(\\d+)>; rel=\"last\"/);\n        if (lastPageMatch) {\n          return parseInt(lastPageMatch[1], 10);\n        }\n      }\n      \n      // Fallback: use the length of returned items (may not be accurate for large counts)\n      return response.data.length;\n    } catch (error) {\n      this.logger.apiResponse('GET', `/repos/${owner}/${repo}/pulls`, error.status || 'error', Date.now() - startTime);\n      console.error('Failed to fetch pull requests count:', error);\n      throw error;\n    }\n  }\n\n  // Get pull request for a specific branch (returns first PR only for backward compatibility)\n  async getPullRequestForBranch(owner, repo, branchName) {\n    const prs = await this.getPullRequestsForBranch(owner, repo, branchName);\n    return prs && prs.length > 0 ? prs[0] : null;\n  }\n\n  // Get all pull requests for a specific branch\n  async getPullRequestsForBranch(owner, repo, branchName) {\n    // Use authenticated octokit if available, otherwise create a public instance for public repos\n    const octokit = this.isAuth() ? this.octokit : new Octokit();\n\n    const startTime = Date.now();\n    this.logger.apiCall('GET', `/repos/${owner}/${repo}/pulls`, { state: 'open', head: `${owner}:${branchName}` });\n\n    try {\n      const response = await octokit.rest.pulls.list({\n        owner,\n        repo,\n        state: 'open',\n        head: `${owner}:${branchName}`,\n        per_page: 100 // Get up to 100 PRs for a branch\n      });\n\n      this.logger.apiResponse('GET', `/repos/${owner}/${repo}/pulls`, response.status, Date.now() - startTime);\n      \n      // Return all matching PRs or empty array if none found\n      return response.data || [];\n    } catch (error) {\n      this.logger.apiResponse('GET', `/repos/${owner}/${repo}/pulls`, error.status || 'error', Date.now() - startTime);\n      console.error('Failed to fetch pull requests for branch:', error);\n      return []; // Return empty array instead of throwing to allow graceful fallback\n    }\n  }\n\n  // Get pull request comments\n  async getPullRequestComments(owner, repo, pullNumber) {\n    if (!this.isAuth()) {\n      throw new Error('Not authenticated with GitHub');\n    }\n\n    const startTime = Date.now();\n    this.logger.apiCall('GET', `/repos/${owner}/${repo}/pulls/${pullNumber}/comments`, {});\n\n    try {\n      const response = await this.octokit.rest.pulls.listReviewComments({\n        owner,\n        repo,\n        pull_number: pullNumber,\n        per_page: 100\n      });\n\n      this.logger.apiResponse('GET', `/repos/${owner}/${repo}/pulls/${pullNumber}/comments`, response.status, Date.now() - startTime);\n      return response.data;\n    } catch (error) {\n      this.logger.apiResponse('GET', `/repos/${owner}/${repo}/pulls/${pullNumber}/comments`, error.status || 'error', Date.now() - startTime);\n      console.error('Failed to fetch pull request comments:', error);\n      throw error;\n    }\n  }\n\n  // Get pull request issue comments (general comments on the PR conversation)\n  async getPullRequestIssueComments(owner, repo, pullNumber) {\n    if (!this.isAuth()) {\n      throw new Error('Not authenticated with GitHub');\n    }\n\n    const startTime = Date.now();\n    this.logger.apiCall('GET', `/repos/${owner}/${repo}/issues/${pullNumber}/comments`, {});\n\n    try {\n      const response = await this.octokit.rest.issues.listComments({\n        owner,\n        repo,\n        issue_number: pullNumber,\n        per_page: 100\n      });\n\n      this.logger.apiResponse('GET', `/repos/${owner}/${repo}/issues/${pullNumber}/comments`, response.status, Date.now() - startTime);\n      return response.data;\n    } catch (error) {\n      this.logger.apiResponse('GET', `/repos/${owner}/${repo}/issues/${pullNumber}/comments`, error.status || 'error', Date.now() - startTime);\n      console.error('Failed to fetch pull request issue comments:', error);\n      throw error;\n    }\n  }\n\n  // Create a comment on a pull request\n  async createPullRequestComment(owner, repo, pullNumber, body) {\n    if (!this.isAuth()) {\n      throw new Error('Not authenticated with GitHub');\n    }\n\n    const startTime = Date.now();\n    this.logger.apiCall('POST', `/repos/${owner}/${repo}/issues/${pullNumber}/comments`, { body });\n\n    try {\n      const response = await this.octokit.rest.issues.createComment({\n        owner,\n        repo,\n        issue_number: pullNumber,\n        body\n      });\n\n      this.logger.apiResponse('POST', `/repos/${owner}/${repo}/issues/${pullNumber}/comments`, response.status, Date.now() - startTime);\n      return response.data;\n    } catch (error) {\n      this.logger.apiResponse('POST', `/repos/${owner}/${repo}/issues/${pullNumber}/comments`, error.status || 'error', Date.now() - startTime);\n      console.error('Failed to create pull request comment:', error);\n      throw error;\n    }\n  }\n\n  // Get open issues count\n  async getOpenIssuesCount(owner, repo) {\n    if (!this.isAuth()) {\n      throw new Error('Not authenticated with GitHub');\n    }\n\n    const startTime = Date.now();\n    this.logger.apiCall('GET', `/repos/${owner}/${repo}/issues`, { state: 'open', per_page: 1 });\n\n    try {\n      const response = await this.octokit.rest.issues.listForRepo({\n        owner,\n        repo,\n        state: 'open',\n        per_page: 1\n      });\n\n      this.logger.apiResponse('GET', `/repos/${owner}/${repo}/issues`, response.status, Date.now() - startTime);\n      \n      // GitHub includes the total count in the response headers\n      const linkHeader = response.headers.link;\n      if (linkHeader && linkHeader.includes('rel=\"last\"')) {\n        const lastPageMatch = linkHeader.match(/page=(\\d+)>; rel=\"last\"/);\n        if (lastPageMatch) {\n          return parseInt(lastPageMatch[1], 10);\n        }\n      }\n      \n      // Fallback: use the length of returned items (may not be accurate for large counts)\n      return response.data.length;\n    } catch (error) {\n      this.logger.apiResponse('GET', `/repos/${owner}/${repo}/issues`, error.status || 'error', Date.now() - startTime);\n      console.error('Failed to fetch issues count:', error);\n      throw error;\n    }\n  }\n\n  // Get repository statistics (combined method for efficiency)\n  async getRepositoryStats(owner, repo, branch = 'main') {\n    if (!this.isAuth()) {\n      throw new Error('Not authenticated with GitHub');\n    }\n\n    try {\n      const [recentCommits, openPRsCount, openIssuesCount] = await Promise.allSettled([\n        this.getRecentCommits(owner, repo, branch, 1),\n        this.getOpenPullRequestsCount(owner, repo),\n        this.getOpenIssuesCount(owner, repo)\n      ]);\n\n      return {\n        recentCommits: recentCommits.status === 'fulfilled' ? recentCommits.value : [],\n        openPullRequestsCount: openPRsCount.status === 'fulfilled' ? openPRsCount.value : 0,\n        openIssuesCount: openIssuesCount.status === 'fulfilled' ? openIssuesCount.value : 0,\n        errors: {\n          recentCommits: recentCommits.status === 'rejected' ? recentCommits.reason : null,\n          openPullRequestsCount: openPRsCount.status === 'rejected' ? openPRsCount.reason : null,\n          openIssuesCount: openIssuesCount.status === 'rejected' ? openIssuesCount.reason : null\n        }\n      };\n    } catch (error) {\n      console.error('Failed to fetch repository stats:', error);\n      throw error;\n    }\n  }\n\n  // Get directory contents (supports both authenticated and unauthenticated access)\n  async getDirectoryContents(owner, repo, path = '', ref = 'main') {\n    try {\n      // Create temporary Octokit instance for unauthenticated access if needed\n      const octokit = this.isAuth() ? this.octokit : new Octokit();\n      \n      const { data } = await octokit.rest.repos.getContent({\n        owner,\n        repo,\n        path,\n        ref\n      });\n\n      if (Array.isArray(data)) {\n        return data;\n      } else {\n        throw new Error('Not a directory');\n      }\n    } catch (error) {\n      console.error(`Failed to get directory contents for ${path}:`, error);\n      throw error;\n    }\n  }\n\n  // Update file content (requires authentication)\n  async updateFile(owner, repo, path, content, message, branch = 'main') {\n    if (!this.isAuth()) {\n      throw new Error('Authentication required to update files');\n    }\n\n    try {\n      // First, get the current file to get its SHA\n      const { data: currentFile } = await this.octokit.rest.repos.getContent({\n        owner,\n        repo,\n        path,\n        ref: branch\n      });\n\n      if (Array.isArray(currentFile)) {\n        throw new Error('Path is a directory, not a file');\n      }\n\n      // Update the file\n      const { data } = await this.octokit.rest.repos.createOrUpdateFileContents({\n        owner,\n        repo,\n        path,\n        message,\n        content: btoa(unescape(encodeURIComponent(content))),\n        sha: currentFile.sha,\n        branch\n      });\n\n      return data;\n    } catch (error) {\n      console.error(`Failed to update file ${path}:`, error);\n      throw error;\n    }\n  }\n\n  // Get commits for a repository (supports unauthenticated access)\n  async getCommits(owner, repo, options = {}) {\n    try {\n      // Create temporary Octokit instance for unauthenticated access if needed\n      const octokit = this.isAuth() ? this.octokit : new Octokit();\n      \n      const params = {\n        owner,\n        repo,\n        per_page: options.per_page || 10,\n        page: options.page || 1\n      };\n\n      if (options.sha) {\n        params.sha = options.sha;\n      }\n\n      if (options.since) {\n        params.since = options.since;\n      }\n\n      if (options.until) {\n        params.until = options.until;\n      }\n\n      const { data } = await octokit.rest.repos.listCommits(params);\n      return data;\n    } catch (error) {\n      console.error('Failed to fetch commits:', error);\n      throw error;\n    }\n  }\n\n  // Get issues for a repository (supports unauthenticated access)\n  async getIssues(owner, repo, options = {}) {\n    try {\n      // Create temporary Octokit instance for unauthenticated access if needed\n      const octokit = this.isAuth() ? this.octokit : new Octokit();\n      \n      const params = {\n        owner,\n        repo,\n        state: options.state || 'all',\n        per_page: options.per_page || 30,\n        page: options.page || 1\n      };\n\n      if (options.labels) {\n        params.labels = options.labels;\n      }\n\n      if (options.milestone) {\n        params.milestone = options.milestone;\n      }\n\n      const { data } = await octokit.rest.issues.listForRepo(params);\n      return data;\n    } catch (error) {\n      console.error('Failed to fetch issues:', error);\n      throw error;\n    }\n  }\n\n  // Alias method for backward compatibility - delegates to getIssues\n  async getRepositoryIssues(owner, repo, options = {}) {\n    return this.getIssues(owner, repo, options);\n  }\n\n  // Get repository forks\n  async getForks(owner, repo, options = {}) {\n    const startTime = Date.now();\n    this.logger.apiCall('GET', `/repos/${owner}/${repo}/forks`, options);\n\n    try {\n      // Use the GitHub API to fetch forks, no authentication required for public repos\n      const octokit = this.isAuth() ? this.octokit : new Octokit();\n      \n      const params = {\n        owner,\n        repo,\n        sort: options.sort || 'newest',\n        per_page: options.per_page || 100,\n        page: options.page || 1\n      };\n\n      const { data } = await octokit.rest.repos.listForks(params);\n      \n      this.logger.apiResponse('GET', `/repos/${owner}/${repo}/forks`, 200, Date.now() - startTime);\n      \n      // Return formatted fork data\n      return data.map(fork => ({\n        id: fork.id,\n        name: fork.name,\n        full_name: fork.full_name,\n        owner: {\n          login: fork.owner.login,\n          avatar_url: fork.owner.avatar_url,\n          html_url: fork.owner.html_url,\n          type: fork.owner.type\n        },\n        description: fork.description,\n        html_url: fork.html_url,\n        clone_url: fork.clone_url,\n        created_at: fork.created_at,\n        updated_at: fork.updated_at,\n        pushed_at: fork.pushed_at,\n        stargazers_count: fork.stargazers_count,\n        forks_count: fork.forks_count,\n        open_issues_count: fork.open_issues_count,\n        default_branch: fork.default_branch,\n        private: fork.private,\n        fork: fork.fork,\n        parent: fork.parent ? {\n          full_name: fork.parent.full_name,\n          html_url: fork.parent.html_url\n        } : null\n      }));\n    } catch (error) {\n      this.logger.apiResponse('GET', `/repos/${owner}/${repo}/forks`, error.status || 'error', Date.now() - startTime);\n      console.error('Failed to fetch repository forks:', error);\n      throw error;\n    }\n  }\n\n  // Get pull requests for a specific repository\n  async getPullRequests(owner, repo, options = {}) {\n    const startTime = Date.now();\n    this.logger.apiCall('GET', `/repos/${owner}/${repo}/pulls`, options);\n\n    try {\n      // Use the GitHub API to fetch pull requests, no authentication required for public repos\n      const octokit = this.isAuth() ? this.octokit : new Octokit();\n      \n      const params = {\n        owner,\n        repo,\n        state: options.state || 'open',\n        sort: options.sort || 'updated',\n        direction: options.direction || 'desc',\n        per_page: options.per_page || 30,\n        page: options.page || 1\n      };\n\n      // Add optional filters\n      if (options.head) {\n        params.head = options.head;\n      }\n      if (options.base) {\n        params.base = options.base;\n      }\n\n      const { data } = await octokit.rest.pulls.list(params);\n      \n      this.logger.apiResponse('GET', `/repos/${owner}/${repo}/pulls`, 200, Date.now() - startTime);\n      \n      // Return formatted pull request data\n      return data.map(pr => ({\n        id: pr.id,\n        number: pr.number,\n        title: pr.title,\n        body: pr.body,\n        state: pr.state,\n        locked: pr.locked,\n        user: {\n          login: pr.user.login,\n          avatar_url: pr.user.avatar_url,\n          html_url: pr.user.html_url,\n          type: pr.user.type\n        },\n        created_at: pr.created_at,\n        updated_at: pr.updated_at,\n        closed_at: pr.closed_at,\n        merged_at: pr.merged_at,\n        html_url: pr.html_url,\n        diff_url: pr.diff_url,\n        patch_url: pr.patch_url,\n        head: {\n          ref: pr.head.ref,\n          sha: pr.head.sha,\n          repo: pr.head.repo ? {\n            name: pr.head.repo.name,\n            full_name: pr.head.repo.full_name,\n            owner: {\n              login: pr.head.repo.owner.login,\n              avatar_url: pr.head.repo.owner.avatar_url\n            },\n            html_url: pr.head.repo.html_url\n          } : null\n        },\n        base: {\n          ref: pr.base.ref,\n          sha: pr.base.sha,\n          repo: {\n            name: pr.base.repo.name,\n            full_name: pr.base.repo.full_name,\n            owner: {\n              login: pr.base.repo.owner.login,\n              avatar_url: pr.base.repo.owner.avatar_url\n            },\n            html_url: pr.base.repo.html_url\n          }\n        },\n        draft: pr.draft,\n        mergeable: pr.mergeable,\n        mergeable_state: pr.mergeable_state,\n        comments: pr.comments,\n        review_comments: pr.review_comments,\n        commits: pr.commits,\n        additions: pr.additions,\n        deletions: pr.deletions,\n        changed_files: pr.changed_files\n      }));\n    } catch (error) {\n      this.logger.apiResponse('GET', `/repos/${owner}/${repo}/pulls`, error.status || 'error', Date.now() - startTime);\n      console.error('Failed to fetch pull requests:', error);\n      throw error;\n    }\n  }\n\n  // Logout\n  logout() {\n    this.logger.auth('Logging out and clearing stored token');\n    \n    this.octokit = null;\n    this.isAuthenticated = false;\n    this.tokenType = null;\n    this.permissions = null;\n    \n    // Clear secure token storage\n    secureTokenStorage.clearToken();\n    \n    // Clear branch context on logout\n    try {\n      const { default: branchContextService } = require('../services/branchContextService');\n      branchContextService.clearAllBranchContext();\n    } catch (error) {\n      // Service might not be available during testing\n      sessionStorage.removeItem('sgex_branch_context');\n    }\n  }\n\n  // Get repository forks\n  async getRepositoryForks(owner, repo, options = {}) {\n    const startTime = Date.now();\n    this.logger.debug('Fetching repository forks', { owner, repo, options });\n\n    try {\n      // Create temporary Octokit instance for unauthenticated access if needed\n      const octokit = this.isAuth() ? this.octokit : new Octokit();\n      \n      this.logger.apiCall('GET', `/repos/${owner}/${repo}/forks`, options);\n      \n      const { data } = await octokit.rest.repos.listForks({\n        owner,\n        repo,\n        sort: 'newest', // Sort by newest first\n        per_page: options.per_page || 100,\n        page: options.page || 1\n      });\n\n      const duration = Date.now() - startTime;\n      this.logger.apiResponse('GET', `/repos/${owner}/${repo}/forks`, 200, duration, { forkCount: data.length });\n      this.logger.performance('Repository forks fetch', duration);\n\n      return data;\n    } catch (error) {\n      const duration = Date.now() - startTime;\n      this.logger.apiError('GET', `/repos/${owner}/${repo}/forks`, error);\n      this.logger.performance('Repository forks fetch (failed)', duration);\n      console.error(`Failed to fetch forks for ${owner}/${repo}:`, error);\n      throw error;\n    }\n  }\n}\n\n// Create a singleton instance\nconst githubService = new GitHubService();\n\nexport default githubService;"],"names":["constructor","this","listeners","Set","currentRepository","currentBranch","initialize","repository","branch","notifyListeners","getStorageKey","Error","concat","full_name","getStagingGround","key","stored","localStorage","getItem","JSON","parse","createEmptyStagingGround","error","console","warn","_this$currentReposito","message","files","timestamp","Date","now","saveStagingGround","stagingGround","_this$currentReposito2","setItem","stringify","saveToHistory","updateFile","filePath","content","metadata","arguments","length","undefined","existingFileIndex","findIndex","f","path","fileObject","_objectSpread","lastModified","push","removeFile","filter","updateCommitMessage","hasChanges","getChangedFilesCount","clearStagingGround","empty","historyKey","history","getHistory","savedAt","recentHistory","slice","rollbackToSave","save","find","s","stagingGroundState","_objectWithoutProperties","_excluded","exportStagingGround","_this$currentReposito3","current","exportedAt","importStagingGround","exportedData","_this$currentReposito4","cleanup","maxAge","keysToRemove","i","startsWith","data","forEach","removeItem","addListener","callback","add","delete","contributeFiles","Array","isArray","success","results","file","result","source","tool","contributedAt","getStatus","_this$currentReposito5","filesCount","logger","getLogger","storageKey","expirationHours","debug","generateBrowserFingerprint","canvas","document","createElement","ctx","getContext","textBaseline","font","fillText","fingerprint","navigator","userAgent","language","window","screen","width","height","colorDepth","getTimezoneOffset","toDataURL","join","hash","charCodeAt","Math","abs","toString","xorCipher","text","String","fromCharCode","validateTokenFormat","token","isValid","type","reason","cleanToken","trim","match","maskToken","substring","repeat","storeToken","validation","tokenMask","encryptionKey","encryptedToken","storageData","btoa","created","expires","sessionStorage","toISOString","retrieveToken","storedData","clearToken","currentFingerprint","atob","decryptedToken","hasValidToken","getTokenInfo","timeRemaining","max","isExpired","migrateLegacyToken","legacyToken","getRepositoryKey","_repository$owner","_repository$full_name","name","owner","login","split","getSelectedBranch","branchContext","getBranchContext","setSelectedBranch","setBranchContext","clearRepositoryBranch","clearAllBranchContext","context","getDefaultBranchName","availableBranches","some","b","default_branch","hasBranchContext","getBranchDisplayInfo","selectedBranch","isDefault","displayText","async","processConcurrently","items","processor","options","concurrency","onProgress","onItemComplete","onItemStart","total","completed","queue","map","item","index","workers","min","fill","shift","worker","Promise","all","ttlMinutes","cache","Map","ttl","_getCacheKey","repo","_isValid","entry","get","compatible","set","clear","entries","getStats","size","from","_ref","ageMinutes","round","octokit","isAuthenticated","permissions","tokenType","authenticate","startTime","auth","tokenProvided","secureTokenStorage","Octokit","duration","securelyStored","performance","authenticateWithOctokit","octokitInstance","initializeFromStoredToken","tokenData","hasStoredToken","getStoredTokenInfo","checkTokenPermissions","isAuth","apiCall","response","request","apiResponse","status","rateLimitStart","rateLimit","rest","resources","core","hasCore","rateLimitError","user","username","apiError","checkRepositoryWritePermissions","getCurrentUser","repos","getCollaboratorPermissionLevel","hasWriteAccess","includes","permission","checkRepositoryPermissions","users","getAuthenticated","getUserOrganizations","orgs","listForAuthenticatedUser","getOrganization","orgLogin","org","getUser","getByUsername","getWHOOrganization","whoData","id","display_name","description","avatar_url","html_url","can_create_repositories","can_create_private_repositories","plan","private_repos","isWHO","getRepositories","getDemoRepositories","getSmartGuidelinesRepositories","demoRepos","private","clone_url","stargazers_count","forks_count","open_issues_count","topics","created_at","updated_at","pushed_at","smart_guidelines_compatible","isDemo","resolve","checkSmartGuidelinesCompatibility","retryCount","cachedResult","repositoryCompatibilityCache","getContent","isCompatible","decodeURIComponent","escape","delay","setTimeout","repositories","page","hasMorePages","listForUser","sort","per_page","listForOrg","smartGuidelinesRepos","getSmartGuidelinesRepositoriesProgressive","onRepositoryFound","log","currentRepo","progress","random","smartRepo","started","getRepository","getBranches","listBranches","createBranch","branchName","fromBranch","refData","git","getRef","ref","createRef","sha","object","getBranch","getWorkflows","actions","listRepoWorkflows","workflows","workflow","filename","pop","state","url","triggers","getWorkflowRuns","params","workflow_id","listWorkflowRunsForRepo","getWorkflowRunsForWorkflow","listWorkflowRuns","triggerWorkflow","inputs","createWorkflowDispatch","rerunWorkflow","run_id","reRunWorkflow","getWorkflowRunLogs","downloadWorkflowRunLogs","approveWorkflowRun","getCommitDiff","base","head","compareCommits","getCommit","getReleases","listReleases","getLatestRelease","getBpmnFilesRecursive","allFiles","endsWith","getBpmnFiles","allBpmnFiles","possiblePaths","uniqueFiles","self","getFileContent","timeoutMs","timeoutPromise","_","reject","apiPromise","race","responseTime","encoding","hasContent","_error$stack","stack","createCommit","latestCommitSha","commitData","commit_sha","baseTreeSha","tree","blobs","blobData","createBlob","mode","treeData","createTree","base_tree","newCommitData","parents","updateRef","author","committer","getRecentCommits","listCommits","commit","email","date","stats","getOpenPullRequestsCount","pulls","list","linkHeader","headers","link","lastPageMatch","parseInt","getPullRequestForBranch","prs","getPullRequestsForBranch","getPullRequestComments","pullNumber","listReviewComments","pull_number","getPullRequestIssueComments","issues","listComments","issue_number","createPullRequestComment","body","createComment","getOpenIssuesCount","listForRepo","getRepositoryStats","recentCommits","openPRsCount","openIssuesCount","allSettled","value","openPullRequestsCount","errors","getDirectoryContents","currentFile","createOrUpdateFileContents","unescape","encodeURIComponent","getCommits","since","until","getIssues","labels","milestone","getRepositoryIssues","getForks","listForks","fork","parent","getPullRequests","direction","pr","number","title","locked","closed_at","merged_at","diff_url","patch_url","draft","mergeable","mergeable_state","comments","review_comments","commits","additions","deletions","changed_files","logout","default","branchContextService","require","getRepositoryForks","forkCount"],"sourceRoot":""}