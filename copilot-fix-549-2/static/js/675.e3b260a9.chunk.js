"use strict";(self.webpackChunksgex_workbench=self.webpackChunksgex_workbench||[]).push([[675],{22392:(t,e,o)=>{o.d(e,{A:()=>n});var r=o(80045),s=o(89379);const a=["savedAt"];const n=new class{constructor(){this.listeners=new Set,this.currentRepository=null,this.currentBranch=null}initialize(t,e){this.currentRepository=t,this.currentBranch=e,this.notifyListeners()}getStorageKey(){if(!this.currentRepository||!this.currentBranch)throw new Error("Staging ground not initialized");return"sgex_staging_".concat(this.currentRepository.full_name,"_").concat(this.currentBranch)}getStagingGround(){try{const t=this.getStorageKey(),e=localStorage.getItem(t);return e?JSON.parse(e):this.createEmptyStagingGround()}catch(t){return console.warn("Error reading staging ground from localStorage:",t),this.createEmptyStagingGround()}}createEmptyStagingGround(){var t;return{message:"",files:[],timestamp:Date.now(),branch:this.currentBranch,repository:null===(t=this.currentRepository)||void 0===t?void 0:t.full_name}}saveStagingGround(t){try{var e;const o=this.getStorageKey();return t.timestamp=Date.now(),t.branch=this.currentBranch,t.repository=null===(e=this.currentRepository)||void 0===e?void 0:e.full_name,localStorage.setItem(o,JSON.stringify(t)),this.saveToHistory(t),this.notifyListeners(),!0}catch(o){return console.error("Error saving staging ground to localStorage:",o),!1}}updateFile(t,e){let o=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};const r=this.getStagingGround(),a=r.files.findIndex(e=>e.path===t),n={path:t,content:e,metadata:(0,s.A)((0,s.A)({},o),{},{lastModified:Date.now()}),timestamp:Date.now()};return a>=0?r.files[a]=n:r.files.push(n),this.saveStagingGround(r)}removeFile(t){const e=this.getStagingGround();return e.files=e.files.filter(e=>e.path!==t),this.saveStagingGround(e)}updateCommitMessage(t){const e=this.getStagingGround();return e.message=t,this.saveStagingGround(e)}hasChanges(){return this.getStagingGround().files.length>0}getChangedFilesCount(){return this.getStagingGround().files.length}clearStagingGround(){const t=this.createEmptyStagingGround();return this.saveStagingGround(t)}saveToHistory(t){try{const e="".concat(this.getStorageKey(),"_history"),o=this.getHistory();o.push((0,s.A)((0,s.A)({},t),{},{savedAt:Date.now()}));const r=o.slice(-10);localStorage.setItem(e,JSON.stringify(r))}catch(e){console.warn("Error saving to history:",e)}}getHistory(){try{const t="".concat(this.getStorageKey(),"_history"),e=localStorage.getItem(t);return e?JSON.parse(e):[]}catch(t){return console.warn("Error reading history:",t),[]}}rollbackToSave(t){const e=this.getHistory().find(e=>e.savedAt===t);if(!e)throw new Error("Save not found in history");const{savedAt:o}=e,s=(0,r.A)(e,a);return this.saveStagingGround(s)}exportStagingGround(){var t;return{current:this.getStagingGround(),history:this.getHistory(),exportedAt:Date.now(),repository:null===(t=this.currentRepository)||void 0===t?void 0:t.full_name,branch:this.currentBranch}}importStagingGround(t){var e;if(!t.current||!t.repository||!t.branch)throw new Error("Invalid export data format");if(t.repository!==(null===(e=this.currentRepository)||void 0===e?void 0:e.full_name)||t.branch!==this.currentBranch)throw new Error("Export data is for different repository or branch");if(this.saveStagingGround(t.current),t.history)try{const e="".concat(this.getStorageKey(),"_history");localStorage.setItem(e,JSON.stringify(t.history))}catch(o){console.warn("Error importing history:",o)}return!0}cleanup(){let t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:6048e5;try{const o=Date.now(),r=[];for(let s=0;s<localStorage.length;s++){const a=localStorage.key(s);if(a&&a.startsWith("sgex_staging_"))try{const e=JSON.parse(localStorage.getItem(a));e.timestamp&&o-e.timestamp>t&&(r.push(a),r.push("".concat(a,"_history")))}catch(e){r.push(a)}}return r.forEach(t=>{localStorage.removeItem(t)}),r.length}catch(e){return console.error("Error during cleanup:",e),0}}addListener(t){return this.listeners.add(t),()=>{this.listeners.delete(t)}}notifyListeners(){const t=this.getStagingGround();this.listeners.forEach(e=>{try{e(t)}catch(o){console.error("Error in staging ground listener:",o)}})}contributeFiles(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};Array.isArray(t)||(t=[t]);let o=!0;const r=[];return t.forEach(t=>{if(!t.path||!t.content)return r.push({path:t.path,success:!1,error:"Missing path or content"}),void(o=!1);const a=this.updateFile(t.path,t.content,(0,s.A)((0,s.A)({},e),{},{source:e.tool||"unknown",contributedAt:Date.now()}));r.push({path:t.path,success:a}),a||(o=!1)}),{success:o,results:r}}getStatus(){var t;const e=this.getStagingGround();return{hasChanges:this.hasChanges(),filesCount:this.getChangedFilesCount(),lastModified:e.timestamp,branch:this.currentBranch,repository:null===(t=this.currentRepository)||void 0===t?void 0:t.full_name}}}},50404:(t,e,o)=>{o.d(e,{A:()=>l});var r=o(89379),s=o(97036);async function a(t,e){let o=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};const{concurrency:r=5,onProgress:s=null,onItemComplete:a=null,onItemStart:n=null}=o;if(!t||0===t.length)return[];const i=new Array(t.length),c=t.length;let l=0;const h=t.map((t,e)=>({item:t,index:e})),u=Array(Math.min(r,t.length)).fill().map(()=>(async()=>{for(;h.length>0;){const{item:o,index:r}=h.shift();n&&n(o,r);try{const t=await e(o,r);i[r]=t,l++,s&&s(l,c,o,t),a&&a(o,t,null)}catch(t){i[r]={error:t,item:o},l++,s&&s(l,c,o,null),a&&a(o,null,t)}}})());return await Promise.all(u),i}const n=new class{constructor(){let t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:30;this.cache=new Map,this.ttl=60*t*1e3}_getCacheKey(t,e){return"".concat(t,"/").concat(e)}_isValid(t){return Date.now()-t.timestamp<this.ttl}get(t,e){const o=this._getCacheKey(t,e),r=this.cache.get(o);return r?this._isValid(r)?r.compatible:(this.cache.delete(o),null):null}set(t,e,o){const r=this._getCacheKey(t,e);this.cache.set(r,{compatible:o,timestamp:Date.now()})}clear(){this.cache.clear()}cleanup(){const t=Date.now();for(const[e,o]of this.cache.entries())t-o.timestamp>=this.ttl&&this.cache.delete(e)}getStats(){return this.cleanup(),{size:this.cache.size,ttlMinutes:this.ttl/6e4,entries:Array.from(this.cache.entries()).map(t=>{let[e,o]=t;return{repository:e,compatible:o.compatible,ageMinutes:Math.round((Date.now()-o.timestamp)/6e4)}})}}};var i=o(5452);const c=new class{constructor(){this.logger=i.A.getLogger("SecureTokenStorage"),this.storageKey="sgex_secure_token",this.expirationHours=24,this.logger.debug("SecureTokenStorage instance created")}generateBrowserFingerprint(){const t=document.createElement("canvas"),e=t.getContext("2d");e.textBaseline="top",e.font="14px Arial",e.fillText("Browser fingerprint",2,2);const o=[navigator.userAgent,navigator.language,window.screen.width+"x"+window.screen.height,window.screen.colorDepth,(new Date).getTimezoneOffset(),t.toDataURL()].join("|");let r=0;for(let s=0;s<o.length;s++){r=(r<<5)-r+o.charCodeAt(s),r&=r}return Math.abs(r).toString(36)}xorCipher(t,e){let o="";for(let r=0;r<t.length;r++)o+=String.fromCharCode(t.charCodeAt(r)^e.charCodeAt(r%e.length));return o}validateTokenFormat(t){if(!t||"string"!==typeof t)return{isValid:!1,type:"invalid",reason:"Token is empty or not a string"};const e=t.trim();return e.match(/^ghp_[A-Za-z0-9]{36}$/)?{isValid:!0,type:"classic",token:e}:e.match(/^github_pat_[A-Za-z0-9]{22}_[A-Za-z0-9]{59}$/)?{isValid:!0,type:"fine-grained",token:e}:e.match(/^gho_[A-Za-z0-9]{36}$/)?{isValid:!0,type:"oauth",token:e}:e.match(/^[a-fA-F0-9]{40}$/)?{isValid:!0,type:"legacy",token:e}:{isValid:!1,type:"invalid",reason:"Token does not match expected GitHub PAT format"}}maskToken(t){if(!t||"string"!==typeof t)return"[INVALID_TOKEN]";const e=t.trim();return e.length<8?"[INVALID_TOKEN]":"".concat(e.substring(0,4)).concat("*".repeat(e.length-8)).concat(e.substring(e.length-4))}storeToken(t){try{this.logger.debug("Starting secure token storage");const e=this.validateTokenFormat(t);if(!e.isValid)return this.logger.warn("Token validation failed",{reason:e.reason,tokenMask:this.maskToken(t)}),!1;this.logger.debug("Token validation successful",{type:e.type,tokenMask:this.maskToken(t)});const o=this.generateBrowserFingerprint(),r="sgex_".concat(o,"_").concat(Date.now().toString(36)),s=this.xorCipher(e.token,r),a={token:btoa(s),key:btoa(r),type:e.type,created:Date.now(),expires:Date.now()+60*this.expirationHours*60*1e3,fingerprint:o};return sessionStorage.setItem(this.storageKey,JSON.stringify(a)),localStorage.removeItem("github_token"),sessionStorage.removeItem("github_token"),this.logger.debug("Token stored securely",{type:e.type,expires:new Date(a.expires).toISOString(),tokenMask:this.maskToken(t)}),!0}catch(e){return this.logger.error("Failed to store token securely",{error:e.message,tokenMask:this.maskToken(t)}),!1}}retrieveToken(){try{this.logger.debug("Attempting to retrieve secure token");const t=sessionStorage.getItem(this.storageKey);if(!t)return this.logger.debug("No secure token found in storage"),null;const e=JSON.parse(t);if(Date.now()>e.expires)return this.logger.warn("Stored token has expired"),this.clearToken(),null;const o=this.generateBrowserFingerprint();if(e.fingerprint!==o)return this.logger.warn("Browser fingerprint mismatch - possible security issue"),this.clearToken(),null;const r=atob(e.key),s=atob(e.token),a=this.xorCipher(s,r),n=this.validateTokenFormat(a);return n.isValid?(this.logger.debug("Token retrieved and decrypted successfully",{type:e.type,expires:new Date(e.expires).toISOString(),tokenMask:this.maskToken(a)}),{token:n.token,type:e.type,created:e.created,expires:e.expires}):(this.logger.error("Decrypted token failed validation"),this.clearToken(),null)}catch(t){return this.logger.error("Failed to retrieve secure token",{error:t.message}),this.clearToken(),null}}hasValidToken(){try{const t=sessionStorage.getItem(this.storageKey);if(!t)return!1;const e=JSON.parse(t);if(Date.now()>e.expires)return this.clearToken(),!1;const o=this.generateBrowserFingerprint();return e.fingerprint===o||(this.clearToken(),!1)}catch(t){return this.logger.error("Error checking token validity",{error:t.message}),this.clearToken(),!1}}clearToken(){this.logger.debug("Clearing secure token storage"),sessionStorage.removeItem(this.storageKey),sessionStorage.removeItem("github_token"),localStorage.removeItem("github_token")}getTokenInfo(){try{const t=sessionStorage.getItem(this.storageKey);if(!t)return null;const e=JSON.parse(t),o=e.expires-Date.now();return{type:e.type,created:new Date(e.created),expires:new Date(e.expires),timeRemaining:Math.max(0,o),isExpired:o<=0,isValid:this.hasValidToken()}}catch(t){return this.logger.error("Error getting token info",{error:t.message}),null}}migrateLegacyToken(){try{const t=sessionStorage.getItem("github_token")||localStorage.getItem("github_token");if(!t)return this.logger.debug("No legacy token found for migration"),!1;this.logger.debug("Migrating legacy token to secure storage");return this.storeToken(t)?(sessionStorage.removeItem("github_token"),localStorage.removeItem("github_token"),this.logger.debug("Legacy token migration completed successfully"),!0):(this.logger.error("Failed to migrate legacy token"),!1)}catch(t){return this.logger.error("Error during legacy token migration",{error:t.message}),!1}}};const l=new class{constructor(){this.octokit=null,this.isAuthenticated=!1,this.permissions=null,this.tokenType=null,this.logger=i.A.getLogger("GitHubService"),this.logger.debug("GitHubService instance created")}authenticate(t){const e=Date.now();this.logger.auth("Starting authentication",{tokenProvided:!!t,tokenMask:t?c.maskToken(t):"none"});try{const o=c.validateTokenFormat(t);if(!o.isValid)return this.logger.warn("Token validation failed during authentication",{reason:o.reason,tokenMask:c.maskToken(t)}),this.isAuthenticated=!1,!1;this.octokit=new s.Octokit({auth:o.token}),this.isAuthenticated=!0,this.tokenType=o.type;const r=c.storeToken(o.token);r||this.logger.warn("Failed to store token securely, authentication will not persist");const a=Date.now()-e;return this.logger.auth("Authentication successful",{duration:a,tokenType:this.tokenType,tokenMask:c.maskToken(t),securelyStored:r}),this.logger.performance("GitHub authentication",a),!0}catch(o){const r=Date.now()-e;return this.logger.auth("Authentication failed",{error:o.message,duration:r,tokenMask:c.maskToken(t)}),console.error("Failed to authenticate with GitHub:",o),this.isAuthenticated=!1,c.clearToken(),!1}}authenticateWithOctokit(t){this.logger.auth("Starting OAuth authentication with Octokit instance");try{return this.octokit=t,this.isAuthenticated=!0,this.tokenType="oauth",this.logger.auth("OAuth authentication successful",{tokenType:this.tokenType}),!0}catch(e){return this.logger.auth("OAuth authentication failed",{error:e.message}),console.error("Failed to authenticate with Octokit instance:",e),this.isAuthenticated=!1,!1}}initializeFromStoredToken(){this.logger.auth("Attempting to initialize from stored token");try{c.migrateLegacyToken()&&this.logger.debug("Successfully migrated legacy token to secure storage");const t=c.retrieveToken();return t?(this.octokit=new s.Octokit({auth:t.token}),this.isAuthenticated=!0,this.tokenType=t.type,this.logger.auth("Successfully initialized from stored token",{tokenType:this.tokenType,tokenMask:c.maskToken(t.token),expires:new Date(t.expires).toISOString()}),!0):(this.logger.debug("No valid stored token found"),!1)}catch(t){return this.logger.auth("Failed to initialize from stored token",{error:t.message}),this.isAuthenticated=!1,c.clearToken(),!1}}hasStoredToken(){return c.hasValidToken()}getStoredTokenInfo(){return c.getTokenInfo()}async checkTokenPermissions(){if(!this.isAuth()){const t=new Error("Not authenticated with GitHub");throw this.logger.error("Token permission check failed - not authenticated"),t}const t=Date.now();this.logger.apiCall("GET","/user",null);try{const o=await this.octokit.request("GET /user");this.logger.apiResponse("GET","/user",o.status,Date.now()-t);try{const t=Date.now();this.logger.apiCall("GET","/rate_limit",null);const e=await this.octokit.rest.rateLimit.get();this.logger.apiResponse("GET","/rate_limit",e.status,Date.now()-t),this.tokenType=e.data.resources.core?"classic":"fine-grained",this.logger.debug("Token type determined",{tokenType:this.tokenType,hasCore:!!e.data.resources.core})}catch(e){this.tokenType="unknown",this.logger.warn("Could not determine token type from rate limit",{error:e.message})}const r={type:this.tokenType,user:o.data};return this.permissions=r,this.logger.debug("Token permissions checked successfully",{tokenType:this.tokenType,username:o.data.login}),r}catch(o){const e=Date.now()-t;throw this.logger.apiError("GET","/user",o),this.logger.performance("Token permission check (failed)",e),console.error("Failed to check token permissions:",o),o}}async checkRepositoryWritePermissions(t,e){if(!this.isAuth())return this.logger.warn("Cannot check repository write permissions - not authenticated",{owner:t,repo:e}),!1;const o=Date.now();this.logger.debug("Checking write permissions for repository",{owner:t,repo:e});try{const r=(await this.getCurrentUser()).login;this.logger.apiCall("GET","/repos/".concat(t,"/").concat(e,"/collaborators/").concat(r,"/permission"),null);const{data:s}=await this.octokit.rest.repos.getCollaboratorPermissionLevel({owner:t,repo:e,username:r}),a=Date.now()-o;this.logger.apiResponse("GET","/repos/".concat(t,"/").concat(e,"/collaborators/").concat(r,"/permission"),200,a);const n=["write","admin"].includes(s.permission);return this.logger.debug("Repository write permissions checked",{owner:t,repo:e,permission:s.permission,hasWriteAccess:n}),n}catch(r){const s=Date.now()-o;return this.logger.apiError("GET","/repos/".concat(t,"/").concat(e,"/collaborators/*/permission"),r),this.logger.performance("Repository write permission check (failed)",s),console.warn("Could not check repository write permissions:",r),this.logger.warn("Assuming no write access due to permission check failure",{owner:t,repo:e,error:r.message}),!1}}async checkRepositoryPermissions(t,e){return this.checkRepositoryWritePermissions(t,e)}async checkCommentPermissions(t,e){if(!this.isAuth())return this.logger.warn("Cannot check comment permissions - not authenticated",{owner:t,repo:e}),!1;const o=Date.now();this.logger.debug("Checking comment permissions for repository",{owner:t,repo:e});try{this.logger.apiCall("GET","/repos/".concat(t,"/").concat(e,"/issues"),{per_page:1}),await this.octokit.rest.issues.listForRepo({owner:t,repo:e,per_page:1,state:"all"});const r=Date.now()-o;return this.logger.apiResponse("GET","/repos/".concat(t,"/").concat(e,"/issues"),200,r),this.logger.debug("Issues endpoint accessible - comment permissions likely available",{owner:t,repo:e}),!0}catch(r){const s=Date.now()-o;return this.logger.apiError("GET","/repos/".concat(t,"/").concat(e,"/issues"),r),this.logger.performance("Comment permission check (failed)",s),403===r.status||401===r.status?(this.logger.warn("Token does not have permission to access issues/comments",{owner:t,repo:e,error:r.message,status:r.status}),!1):(this.logger.warn("Could not determine comment permissions, assuming available",{owner:t,repo:e,error:r.message}),!0)}}isAuth(){return this.isAuthenticated&&null!==this.octokit}async getCurrentUser(){if(!this.isAuth())throw new Error("Not authenticated with GitHub");try{const{data:t}=await this.octokit.rest.users.getAuthenticated();return t}catch(t){throw console.error("Failed to fetch user data:",t),t}}async getUserOrganizations(){if(!this.isAuth())throw new Error("Not authenticated with GitHub");try{const{data:t}=await this.octokit.rest.orgs.listForAuthenticatedUser();return t}catch(t){throw console.error("Failed to fetch organizations:",t),t}}async getOrganization(t){try{const e=this.octokit||new s.Octokit,{data:o}=await e.rest.orgs.get({org:t});return o}catch(e){throw console.error("Failed to fetch organization ".concat(t,":"),e),e}}async getUser(t){try{const e=this.octokit||new s.Octokit,{data:o}=await e.rest.users.getByUsername({username:t});return o}catch(e){throw console.error("Failed to fetch user ".concat(t,":"),e),e}}async getPublicRepositories(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"user";try{const o=this.octokit||new s.Octokit;let r=[],a=1,n=!0;for(;n;){let s;s="user"===e?await o.rest.repos.listForUser({username:t,sort:"updated",per_page:100,page:a}):await o.rest.repos.listForOrg({org:t,sort:"updated",per_page:100,page:a}),r=r.concat(s.data),n=100===s.data.length,a++}return r}catch(o){throw console.error("Failed to fetch public repositories for ".concat(t,":"),o),o}}async getWHOOrganization(){try{const t=await this.getOrganization("WorldHealthOrganization");return{id:t.id,login:t.login,display_name:t.name||"World Health Organization",description:t.description||"The World Health Organization is a specialized agency of the United Nations responsible for international public health.",avatar_url:t.avatar_url,html_url:t.html_url,type:"Organization",permissions:{can_create_repositories:!0,can_create_private_repositories:!0},plan:{name:"Organization",private_repos:"unlimited"},isWHO:!0}}catch(t){return console.warn("Could not fetch WHO organization data from API, using fallback:",t),{id:"who-organization",login:"WorldHealthOrganization",display_name:"World Health Organization",description:"The World Health Organization is a specialized agency of the United Nations responsible for international public health.",avatar_url:"https://avatars.githubusercontent.com/u/12261302?s=200&v=4",html_url:"https://github.com/WorldHealthOrganization",type:"Organization",permissions:{can_create_repositories:!0,can_create_private_repositories:!0},plan:{name:"Organization",private_repos:"unlimited"},isWHO:!0}}}async getRepositories(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"user";return arguments.length>2&&void 0!==arguments[2]&&arguments[2]||"demo-user"===t?this.getDemoRepositories(t):this.getSmartGuidelinesRepositories(t,e)}getDemoRepositories(t){const e=[{id:"demo-smart-anc",name:"smart-anc",full_name:"".concat(t,"/smart-anc"),description:"Demo SMART Guidelines Digital Adaptation Kit for Antenatal Care",private:!1,owner:{login:t,id:"demo-owner",avatar_url:"https://github.com/".concat(t,".png"),type:"User"},html_url:"https://github.com/".concat(t,"/smart-anc"),clone_url:"https://github.com/".concat(t,"/smart-anc.git"),language:"FSH",stargazers_count:15,forks_count:3,open_issues_count:2,topics:["who","smart-guidelines","dak","antenatal-care","health"],created_at:"2023-01-15T10:00:00Z",updated_at:"2024-12-15T14:30:00Z",pushed_at:"2024-12-15T14:30:00Z",default_branch:"main",smart_guidelines_compatible:!0,isDemo:!0},{id:"demo-smart-tb",name:"smart-tb",full_name:"".concat(t,"/smart-tb"),description:"Demo SMART Guidelines Digital Adaptation Kit for Tuberculosis Care",private:!1,owner:{login:t,id:"demo-owner",avatar_url:"https://github.com/".concat(t,".png"),type:"User"},html_url:"https://github.com/".concat(t,"/smart-tb"),clone_url:"https://github.com/".concat(t,"/smart-tb.git"),language:"FSH",stargazers_count:8,forks_count:1,open_issues_count:0,topics:["who","smart-guidelines","dak","tuberculosis","health"],created_at:"2023-03-20T15:00:00Z",updated_at:"2024-11-30T09:15:00Z",pushed_at:"2024-11-30T09:15:00Z",default_branch:"main",smart_guidelines_compatible:!0,isDemo:!0},{id:"demo-smart-ips-pilgrimage",name:"smart-ips-pilgrimage",full_name:"".concat(t,"/smart-ips-pilgrimage"),description:"Demo SMART Guidelines International Patient Summary for Pilgrimage",private:!1,owner:{login:t,id:"demo-owner",avatar_url:"https://github.com/".concat(t,".png"),type:"User"},html_url:"https://github.com/".concat(t,"/smart-ips-pilgrimage"),clone_url:"https://github.com/".concat(t,"/smart-ips-pilgrimage.git"),language:"FSH",stargazers_count:12,forks_count:2,open_issues_count:1,topics:["who","smart-guidelines","dak","ips","pilgrimage","health"],created_at:"2023-06-10T12:00:00Z",updated_at:"2024-12-01T16:45:00Z",pushed_at:"2024-12-01T16:45:00Z",default_branch:"main",smart_guidelines_compatible:!0,isDemo:!0}];return Promise.resolve(e)}async checkSmartGuidelinesCompatibility(t,e){let o=arguments.length>2&&void 0!==arguments[2]?arguments[2]:2;const r=n.get(t,e);if(null!==r)return r;try{const o=this.octokit||new s.Octokit,{data:r}=await o.rest.repos.getContent({owner:t,repo:e,path:"sushi-config.yaml"});if("file"===r.type&&r.content){const o=decodeURIComponent(escape(atob(r.content))).includes("smart.who.int.base");return n.set(t,e,o),o}return n.set(t,e,!1),!1}catch(a){if(404===a.status&&o>0){console.warn("File not found for ".concat(t,"/").concat(e,", retrying... (").concat(o," attempts left)"));const r=1e3;return await new Promise(t=>setTimeout(t,r)),this.checkSmartGuidelinesCompatibility(t,e,o-1)}return console.warn("Failed to check ".concat(t,"/").concat(e," for sushi-config.yaml with smart.who.int.base dependency:"),a.message),n.set(t,e,!1),!1}}async getSmartGuidelinesRepositories(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"user";try{let o=[];if(this.isAuth()){let r=1,s=!0;for(;s;){let a;a="user"===e?await this.octokit.rest.repos.listForUser({username:t,sort:"updated",per_page:100,page:r}):await this.octokit.rest.repos.listForOrg({org:t,sort:"updated",per_page:100,page:r}),o=o.concat(a.data),s=100===a.data.length,r++}}else o=await this.getPublicRepositories(t,e);const s=[];for(const t of o){await this.checkSmartGuidelinesCompatibility(t.owner.login,t.name)&&s.push((0,r.A)((0,r.A)({},t),{},{smart_guidelines_compatible:!0}))}return s}catch(o){throw console.error("Failed to fetch SMART guidelines repositories:",o),o}}async getSmartGuidelinesRepositoriesProgressive(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"user",o=arguments.length>2&&void 0!==arguments[2]?arguments[2]:null,s=arguments.length>3&&void 0!==arguments[3]?arguments[3]:null;if(!this.isAuth())throw new Error("Not authenticated with GitHub");try{let n=[],i=1,c=!0;for(;c;){let o;o="user"===e?await this.octokit.rest.repos.listForUser({username:t,sort:"updated",per_page:100,page:i}):await this.octokit.rest.repos.listForOrg({org:t,sort:"updated",per_page:100,page:i}),n=n.concat(o.data),c=100===o.data.length,i++}if(0===n.length)return console.log("\ud83d\udcca No repositories found for user, completing scan immediately"),s&&s({current:0,total:0,currentRepo:"none",progress:100,completed:!0}),[];const l=async(t,e)=>{await new Promise(t=>setTimeout(t,100+200*Math.random()));if(await this.checkSmartGuidelinesCompatibility(t.owner.login,t.name)){const e=(0,r.A)((0,r.A)({},t),{},{smart_guidelines_compatible:!0});return o&&o(e),e}return null},h=await a(n,l,{concurrency:5,onProgress:(t,e,o,r)=>{s&&s({current:t,total:e,currentRepo:o.name,progress:Math.round(t/e*100),completed:!0})},onItemStart:(t,e)=>{s&&s({current:e+1,total:n.length,currentRepo:t.name,progress:Math.round((e+1)/n.length*100),completed:!1,started:!0})}});return h.filter(t=>null!==t&&!t.error)}catch(n){throw console.error("Failed to fetch SMART guidelines repositories:",n),n}}async getRepository(t,e){try{const o=this.isAuth()?this.octokit:new s.Octokit,{data:r}=await o.rest.repos.get({owner:t,repo:e});return r}catch(o){throw console.error("Failed to fetch repository:",o),o}}async getBranches(t,e){try{console.log("githubService.getBranches: Fetching branches for ".concat(t,"/").concat(e)),console.log("githubService.getBranches: Authentication status:",this.isAuth());const o=this.isAuth()?this.octokit:new s.Octokit;console.log("githubService.getBranches: Using",this.isAuth()?"authenticated":"public","octokit instance");const{data:r}=await o.rest.repos.listBranches({owner:t,repo:e,per_page:100});return console.log("githubService.getBranches: Successfully fetched ".concat(r.length," branches")),r}catch(o){throw console.error("githubService.getBranches: Failed to fetch branches:",o),console.error("githubService.getBranches: Error details:",{status:o.status,message:o.message,owner:t,repo:e}),o}}async createBranch(t,e,o){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:"main";if(!this.isAuth())throw new Error("Not authenticated with GitHub");try{const{data:s}=await this.octokit.rest.git.getRef({owner:t,repo:e,ref:"heads/".concat(r)}),{data:a}=await this.octokit.rest.git.createRef({owner:t,repo:e,ref:"refs/heads/".concat(o),sha:s.object.sha});return a}catch(s){throw console.error("Failed to create branch:",s),s}}async getBranch(t,e,o){try{const r=this.isAuth()?this.octokit:new s.Octokit,{data:a}=await r.rest.repos.getBranch({owner:t,repo:e,branch:o});return a}catch(r){throw console.error("Failed to fetch branch:",r),r}}async getWorkflows(t,e){if(!this.isAuth())throw new Error("Not authenticated with GitHub");try{const{data:o}=await this.octokit.rest.actions.listRepoWorkflows({owner:t,repo:e});return o.workflows.map(t=>({id:t.id,name:t.name,filename:t.path.split("/").pop(),path:t.path,state:t.state,created_at:t.created_at,updated_at:t.updated_at,url:t.html_url,triggers:["unknown"],lastModified:t.updated_at}))}catch(o){if(404===o.status)return[];throw console.error("Failed to fetch workflows:",o),o}}async getWorkflowRuns(t,e){let o=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};if(!this.isAuth())throw new Error("Not authenticated with GitHub");try{const r={owner:t,repo:e,per_page:o.per_page||10,page:o.page||1};o.branch&&(r.branch=o.branch),o.workflow_id&&(r.workflow_id=o.workflow_id);const{data:s}=await this.octokit.rest.actions.listWorkflowRunsForRepo(r);return s}catch(r){throw console.error("Failed to fetch workflow runs:",r),r}}async getWorkflowRunsForWorkflow(t,e,o){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:{};if(!this.isAuth())throw new Error("Not authenticated with GitHub");try{const s={owner:t,repo:e,workflow_id:o,per_page:r.per_page||10,page:r.page||1};r.branch&&(s.branch=r.branch);const{data:a}=await this.octokit.rest.actions.listWorkflowRuns(s);return a}catch(s){throw console.error("Failed to fetch workflow runs for workflow:",s),s}}async triggerWorkflow(t,e,o){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:"main",s=arguments.length>4&&void 0!==arguments[4]?arguments[4]:{};if(!this.isAuth())throw new Error("Not authenticated with GitHub");try{const{data:a}=await this.octokit.rest.actions.createWorkflowDispatch({owner:t,repo:e,workflow_id:o,ref:r,inputs:s});return a}catch(a){throw console.error("Failed to trigger workflow:",a),a}}async rerunWorkflow(t,e,o){if(!this.isAuth())throw new Error("Not authenticated with GitHub");try{const{data:r}=await this.octokit.rest.actions.reRunWorkflow({owner:t,repo:e,run_id:o});return r}catch(r){throw console.error("Failed to re-run workflow:",r),r}}async getWorkflowRunLogs(t,e,o){if(!this.isAuth())throw new Error("Not authenticated with GitHub");try{const{data:r}=await this.octokit.rest.actions.downloadWorkflowRunLogs({owner:t,repo:e,run_id:o});return r}catch(r){throw console.error("Failed to get workflow run logs:",r),r}}async approveWorkflowRun(t,e,o){if(!this.isAuth())throw new Error("Not authenticated with GitHub");try{const{data:r}=await this.octokit.rest.actions.approveWorkflowRun({owner:t,repo:e,run_id:o});return r}catch(r){throw console.error("Failed to approve workflow run:",r),r}}async getCommitDiff(t,e,o,r){if(!this.isAuth())throw new Error("Not authenticated with GitHub");try{const{data:s}=await this.octokit.rest.repos.compareCommits({owner:t,repo:e,base:o,head:r});return s}catch(s){throw console.error("Failed to get commit diff:",s),s}}async getCommit(t,e,o){if(!this.isAuth())throw new Error("Not authenticated with GitHub");try{const{data:r}=await this.octokit.rest.repos.getCommit({owner:t,repo:e,ref:o});return r}catch(r){throw console.error("Failed to get commit details:",r),r}}async getReleases(t,e){let o=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};if(!this.isAuth())throw new Error("Not authenticated with GitHub");try{const{data:r}=await this.octokit.rest.repos.listReleases({owner:t,repo:e,per_page:o.per_page||10,page:o.page||1});return r}catch(r){throw console.error("Failed to fetch releases:",r),r}}async getLatestRelease(t,e){if(!this.isAuth())throw new Error("Not authenticated with GitHub");try{const{data:o}=await this.octokit.rest.repos.getLatestRelease({owner:t,repo:e});return o}catch(o){throw console.error("Failed to fetch latest release:",o),o}}async getBpmnFilesRecursive(t,e,o){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:"main",a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:[];try{console.log("\ud83d\udd0e githubService.getBpmnFilesRecursive: Searching ".concat(t,"/").concat(e,"/").concat(o," (ref: ").concat(r,")"));const n=this.isAuth()?this.octokit:new s.Octokit;console.log("\ud83d\udd10 githubService.getBpmnFilesRecursive: Using ".concat(this.isAuth()?"authenticated":"public"," octokit"));const{data:i}=await n.rest.repos.getContent({owner:t,repo:e,path:o,ref:r});if(console.log("\ud83d\udce6 githubService.getBpmnFilesRecursive: Received data type: ".concat(Array.isArray(i)?"array":"single file",", length: ").concat(Array.isArray(i)?i.length:1)),!Array.isArray(i))return i.name.endsWith(".bpmn")&&(console.log("\ud83d\udcc4 githubService.getBpmnFilesRecursive: Found single BPMN file: ".concat(i.name)),a.push(i)),a;for(const o of i)"file"===o.type&&o.name.endsWith(".bpmn")?(console.log("\ud83d\udcc4 githubService.getBpmnFilesRecursive: Found BPMN file: ".concat(o.name)),a.push(o)):"dir"===o.type&&(console.log("\ud83d\udcc1 githubService.getBpmnFilesRecursive: Found subdirectory: ".concat(o.name,", recursing...")),await this.getBpmnFilesRecursive(t,e,o.path,r,a));return console.log("\u2705 githubService.getBpmnFilesRecursive: Completed search of ".concat(o,", found ").concat(a.length," total files so far")),a}catch(n){if(console.log("\u274c githubService.getBpmnFilesRecursive: Error searching ".concat(o,":"),n.status,n.message),404===n.status)return a;throw n}}async getBpmnFiles(t,e){let o=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"main";console.log("\ud83d\udd0d githubService.getBpmnFiles: Starting search for ".concat(t,"/").concat(e," (ref: ").concat(o,")"));const r=[],s=["input/business-processes","input/business-process"];for(const i of s)try{console.log("\ud83d\udcc1 githubService.getBpmnFiles: Searching in directory: ".concat(i));const s=await this.getBpmnFilesRecursive(t,e,i,o);console.log("\u2705 githubService.getBpmnFiles: Found ".concat(s.length," BPMN files in ").concat(i)),r.push(...s)}catch(n){404!==n.status?console.warn("\u274c Could not fetch BPMN files from ".concat(i,":"),n.message):console.log("\ud83d\udcc2 githubService.getBpmnFiles: Directory ".concat(i," not found (404) - this is expected if the directory doesn't exist"))}const a=r.filter((t,e,o)=>e===o.findIndex(e=>e.path===t.path));return console.log("\ud83c\udfaf githubService.getBpmnFiles: Final result - ".concat(a.length," unique BPMN files found")),console.log("\ud83d\udccb githubService.getBpmnFiles: File list:",a.map(t=>t.name)),a}async getFileContent(t,e,o){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:"main";const a=15e3;try{console.log("\ud83d\ude80 githubService.getFileContent: Starting request for ".concat(t,"/").concat(e,"/").concat(o," (ref: ").concat(r,")")),console.log("\ud83d\udd10 githubService.getFileContent: Authentication status:",this.isAuth()),console.log("\ud83d\udccb githubService.getFileContent: Request parameters:",{owner:t,repo:e,path:o,ref:r});const n=this.isAuth()?this.octokit:new s.Octokit;console.log("\ud83d\udd27 githubService.getFileContent: Using",this.isAuth()?"authenticated":"public","octokit instance");const i=new Promise((t,e)=>{console.log("\u23f0 githubService.getFileContent: Setting up ".concat(a,"ms timeout")),setTimeout(()=>{console.error("\u23f0 githubService.getFileContent: Request timed out after ".concat(a,"ms")),e(new Error("Request timeout after ".concat(a,"ms")))},a)});console.log("\ud83c\udf10 githubService.getFileContent: Creating GitHub API promise...");const c=n.rest.repos.getContent({owner:t,repo:e,path:o,ref:r});console.log("\ud83d\udce1 githubService.getFileContent: API request initiated, waiting for response...");const l=Date.now(),{data:h}=await Promise.race([c,i]),u=Date.now()-l;if(console.log("\u2705 githubService.getFileContent: API response received in ".concat(u,"ms")),console.log("\ud83d\udcc2 githubService.getFileContent: Response data type:",h.type),console.log("\ud83d\udcca githubService.getFileContent: Response details:",{type:h.type,name:h.name,size:h.size,encoding:h.encoding,hasContent:!!h.content}),"file"===h.type&&h.content){console.log("\ud83d\udd27 githubService.getFileContent: Decoding base64 content..."),console.log("\ud83d\udcca githubService.getFileContent: Base64 content length:",h.content.length);const t=decodeURIComponent(escape(atob(h.content)));return console.log("\u2705 githubService.getFileContent: Successfully fetched and decoded file content"),console.log("\ud83d\udccf githubService.getFileContent: Final content length:",t.length,"characters"),console.log("\ud83d\udc40 githubService.getFileContent: Content preview (first 200 chars):",t.substring(0,200)),t}throw console.error("\u274c githubService.getFileContent: Invalid response - not a file or no content"),console.error("\ud83d\udd0d githubService.getFileContent: Full response data:",JSON.stringify(h,null,2)),new Error("File not found or is not a file")}catch(i){var n;if(console.error("\ud83d\udca5 githubService.getFileContent: Failed to fetch file content from ".concat(t,"/").concat(e,"/").concat(o,":"),i),console.error("\ud83d\udd0d githubService.getFileContent: Error analysis:",{type:typeof i,status:i.status,message:i.message,name:i.name,stack:(null===(n=i.stack)||void 0===n?void 0:n.substring(0,500))+"..."}),i.message.includes("timeout"))throw console.error("\u23f0 githubService.getFileContent: Timeout error detected"),new Error("GitHub API request timed out after ".concat(15," seconds. Please try again."));if(403===i.status)throw console.error("\ud83d\udd12 githubService.getFileContent: 403 Forbidden error detected"),new Error("Access denied. This repository may be private or you may have hit rate limits.");if(404===i.status)throw console.error("\ud83d\udd0d githubService.getFileContent: 404 Not Found error detected"),new Error("File not found in the repository.");if(i.message.includes("rate limit"))throw console.error("\ud83d\udea6 githubService.getFileContent: Rate limit error detected"),new Error("GitHub API rate limit exceeded. Please try again later.");if(i.message.includes("Network Error")||i.message.includes("Failed to fetch"))throw console.error("\ud83c\udf10 githubService.getFileContent: Network error detected"),new Error("Network error occurred. Please check your internet connection and try again.");throw console.error("\u2753 githubService.getFileContent: Unknown error type, re-throwing original error"),i}}async createCommit(t,e,o,r,s){if(!this.isAuth())throw new Error("Not authenticated with GitHub");try{const{data:a}=await this.octokit.rest.git.getRef({owner:t,repo:e,ref:"heads/".concat(o)}),n=a.object.sha,{data:i}=await this.octokit.rest.git.getCommit({owner:t,repo:e,commit_sha:n}),c=i.tree.sha,l=await Promise.all(s.map(async o=>{const{data:r}=await this.octokit.rest.git.createBlob({owner:t,repo:e,content:o.content,encoding:"utf-8"});return{path:o.path,mode:"100644",type:"blob",sha:r.sha}})),{data:h}=await this.octokit.rest.git.createTree({owner:t,repo:e,base_tree:c,tree:l}),{data:u}=await this.octokit.rest.git.createCommit({owner:t,repo:e,message:r,tree:h.sha,parents:[n]});return await this.octokit.rest.git.updateRef({owner:t,repo:e,ref:"heads/".concat(o),sha:u.sha}),{sha:u.sha,html_url:"https://github.com/".concat(t,"/").concat(e,"/commit/").concat(u.sha),message:u.message,author:u.author,committer:u.committer}}catch(a){throw console.error("Failed to create commit:",a),a}}async getRecentCommits(t,e){let o=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"main",r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:5;if(!this.isAuth())throw new Error("Not authenticated with GitHub");const s=Date.now();this.logger.apiCall("GET","/repos/".concat(t,"/").concat(e,"/commits"),{sha:o,per_page:r});try{const a=await this.octokit.rest.repos.listCommits({owner:t,repo:e,sha:o,per_page:r});return this.logger.apiResponse("GET","/repos/".concat(t,"/").concat(e,"/commits"),a.status,Date.now()-s),a.data.map(t=>({sha:t.sha,message:t.commit.message,author:{name:t.commit.author.name,email:t.commit.author.email,date:t.commit.author.date},committer:{name:t.commit.committer.name,email:t.commit.committer.email,date:t.commit.committer.date},html_url:t.html_url,stats:t.stats}))}catch(a){throw this.logger.apiResponse("GET","/repos/".concat(t,"/").concat(e,"/commits"),a.status||"error",Date.now()-s),console.error("Failed to fetch recent commits:",a),a}}async getOpenPullRequestsCount(t,e){if(!this.isAuth())throw new Error("Not authenticated with GitHub");const o=Date.now();this.logger.apiCall("GET","/repos/".concat(t,"/").concat(e,"/pulls"),{state:"open",per_page:1});try{const r=await this.octokit.rest.pulls.list({owner:t,repo:e,state:"open",per_page:1});this.logger.apiResponse("GET","/repos/".concat(t,"/").concat(e,"/pulls"),r.status,Date.now()-o);const s=r.headers.link;if(s&&s.includes('rel="last"')){const t=s.match(/page=(\d+)>; rel="last"/);if(t)return parseInt(t[1],10)}return r.data.length}catch(r){throw this.logger.apiResponse("GET","/repos/".concat(t,"/").concat(e,"/pulls"),r.status||"error",Date.now()-o),console.error("Failed to fetch pull requests count:",r),r}}async getPullRequestForBranch(t,e,o){const r=await this.getPullRequestsForBranch(t,e,o);return r&&r.length>0?r[0]:null}async getPullRequestsForBranch(t,e,o){const r=this.isAuth()?this.octokit:new s.Octokit,a=Date.now();this.logger.apiCall("GET","/repos/".concat(t,"/").concat(e,"/pulls"),{state:"open",head:"".concat(t,":").concat(o)});try{const s=await r.rest.pulls.list({owner:t,repo:e,state:"open",head:"".concat(t,":").concat(o),per_page:100});return this.logger.apiResponse("GET","/repos/".concat(t,"/").concat(e,"/pulls"),s.status,Date.now()-a),s.data||[]}catch(n){return this.logger.apiResponse("GET","/repos/".concat(t,"/").concat(e,"/pulls"),n.status||"error",Date.now()-a),console.error("Failed to fetch pull requests for branch:",n),[]}}async getPullRequestComments(t,e,o){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1,a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:100;const n=this.isAuth()?this.octokit:new s.Octokit,i=Date.now();this.logger.apiCall("GET","/repos/".concat(t,"/").concat(e,"/pulls/").concat(o,"/comments"),{page:r,per_page:a});try{const s=await n.rest.pulls.listReviewComments({owner:t,repo:e,pull_number:o,page:r,per_page:a});return this.logger.apiResponse("GET","/repos/".concat(t,"/").concat(e,"/pulls/").concat(o,"/comments"),s.status,Date.now()-i),s.data}catch(c){throw this.logger.apiResponse("GET","/repos/".concat(t,"/").concat(e,"/pulls/").concat(o,"/comments"),c.status||"error",Date.now()-i),console.error("Failed to fetch pull request comments:",c),c}}async getPullRequestIssueComments(t,e,o){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1,a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:100;const n=this.isAuth()?this.octokit:new s.Octokit,i=Date.now();this.logger.apiCall("GET","/repos/".concat(t,"/").concat(e,"/issues/").concat(o,"/comments"),{page:r,per_page:a});try{const s=await n.rest.issues.listComments({owner:t,repo:e,issue_number:o,page:r,per_page:a});return this.logger.apiResponse("GET","/repos/".concat(t,"/").concat(e,"/issues/").concat(o,"/comments"),s.status,Date.now()-i),s.data}catch(c){throw this.logger.apiResponse("GET","/repos/".concat(t,"/").concat(e,"/issues/").concat(o,"/comments"),c.status||"error",Date.now()-i),console.error("Failed to fetch pull request issue comments:",c),c}}async createPullRequestComment(t,e,o,r){if(!this.isAuth())throw new Error("Not authenticated with GitHub");const s=Date.now();this.logger.apiCall("POST","/repos/".concat(t,"/").concat(e,"/issues/").concat(o,"/comments"),{body:r});try{const a=await this.octokit.rest.issues.createComment({owner:t,repo:e,issue_number:o,body:r});return this.logger.apiResponse("POST","/repos/".concat(t,"/").concat(e,"/issues/").concat(o,"/comments"),a.status,Date.now()-s),a.data}catch(a){throw this.logger.apiResponse("POST","/repos/".concat(t,"/").concat(e,"/issues/").concat(o,"/comments"),a.status||"error",Date.now()-s),console.error("Failed to create pull request comment:",a),a}}async getOpenIssuesCount(t,e){if(!this.isAuth())throw new Error("Not authenticated with GitHub");const o=Date.now();this.logger.apiCall("GET","/repos/".concat(t,"/").concat(e,"/issues"),{state:"open",per_page:1});try{const r=await this.octokit.rest.issues.listForRepo({owner:t,repo:e,state:"open",per_page:1});this.logger.apiResponse("GET","/repos/".concat(t,"/").concat(e,"/issues"),r.status,Date.now()-o);const s=r.headers.link;if(s&&s.includes('rel="last"')){const t=s.match(/page=(\d+)>; rel="last"/);if(t)return parseInt(t[1],10)}return r.data.length}catch(r){throw this.logger.apiResponse("GET","/repos/".concat(t,"/").concat(e,"/issues"),r.status||"error",Date.now()-o),console.error("Failed to fetch issues count:",r),r}}async getRepositoryStats(t,e){let o=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"main";if(!this.isAuth())throw new Error("Not authenticated with GitHub");try{const[r,s,a]=await Promise.allSettled([this.getRecentCommits(t,e,o,1),this.getOpenPullRequestsCount(t,e),this.getOpenIssuesCount(t,e)]);return{recentCommits:"fulfilled"===r.status?r.value:[],openPullRequestsCount:"fulfilled"===s.status?s.value:0,openIssuesCount:"fulfilled"===a.status?a.value:0,errors:{recentCommits:"rejected"===r.status?r.reason:null,openPullRequestsCount:"rejected"===s.status?s.reason:null,openIssuesCount:"rejected"===a.status?a.reason:null}}}catch(r){throw console.error("Failed to fetch repository stats:",r),r}}async getDirectoryContents(t,e){let o=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"",r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:"main";try{const a=this.isAuth()?this.octokit:new s.Octokit,{data:n}=await a.rest.repos.getContent({owner:t,repo:e,path:o,ref:r});if(Array.isArray(n))return n;throw new Error("Not a directory")}catch(a){throw console.error("Failed to get directory contents for ".concat(o,":"),a),a}}async updateFile(t,e,o,r,s){let a=arguments.length>5&&void 0!==arguments[5]?arguments[5]:"main";if(!this.isAuth())throw new Error("Authentication required to update files");try{const{data:n}=await this.octokit.rest.repos.getContent({owner:t,repo:e,path:o,ref:a});if(Array.isArray(n))throw new Error("Path is a directory, not a file");const{data:i}=await this.octokit.rest.repos.createOrUpdateFileContents({owner:t,repo:e,path:o,message:s,content:btoa(unescape(encodeURIComponent(r))),sha:n.sha,branch:a});return i}catch(n){throw console.error("Failed to update file ".concat(o,":"),n),n}}async getCommits(t,e){let o=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};try{const r=this.isAuth()?this.octokit:new s.Octokit,a={owner:t,repo:e,per_page:o.per_page||10,page:o.page||1};o.sha&&(a.sha=o.sha),o.since&&(a.since=o.since),o.until&&(a.until=o.until);const{data:n}=await r.rest.repos.listCommits(a);return n}catch(r){throw console.error("Failed to fetch commits:",r),r}}async getIssues(t,e){let o=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};try{const r=this.isAuth()?this.octokit:new s.Octokit,a={owner:t,repo:e,state:o.state||"all",per_page:o.per_page||30,page:o.page||1};o.labels&&(a.labels=o.labels),o.milestone&&(a.milestone=o.milestone);const{data:n}=await r.rest.issues.listForRepo(a);return n}catch(r){throw console.error("Failed to fetch issues:",r),r}}async getRepositoryIssues(t,e){let o=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};return this.getIssues(t,e,o)}async getForks(t,e){let o=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};const r=Date.now();this.logger.apiCall("GET","/repos/".concat(t,"/").concat(e,"/forks"),o);try{const a=this.isAuth()?this.octokit:new s.Octokit,n={owner:t,repo:e,sort:o.sort||"newest",per_page:o.per_page||100,page:o.page||1},{data:i}=await a.rest.repos.listForks(n);return this.logger.apiResponse("GET","/repos/".concat(t,"/").concat(e,"/forks"),200,Date.now()-r),i.map(t=>({id:t.id,name:t.name,full_name:t.full_name,owner:{login:t.owner.login,avatar_url:t.owner.avatar_url,html_url:t.owner.html_url,type:t.owner.type},description:t.description,html_url:t.html_url,clone_url:t.clone_url,created_at:t.created_at,updated_at:t.updated_at,pushed_at:t.pushed_at,stargazers_count:t.stargazers_count,forks_count:t.forks_count,open_issues_count:t.open_issues_count,default_branch:t.default_branch,private:t.private,fork:t.fork,parent:t.parent?{full_name:t.parent.full_name,html_url:t.parent.html_url}:null}))}catch(a){throw this.logger.apiResponse("GET","/repos/".concat(t,"/").concat(e,"/forks"),a.status||"error",Date.now()-r),console.error("Failed to fetch repository forks:",a),a}}async getPullRequests(t,e){let o=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};const r=Date.now();this.logger.apiCall("GET","/repos/".concat(t,"/").concat(e,"/pulls"),o);try{const a=this.isAuth()?this.octokit:new s.Octokit,n={owner:t,repo:e,state:o.state||"open",sort:o.sort||"updated",direction:o.direction||"desc",per_page:o.per_page||30,page:o.page||1};o.head&&(n.head=o.head),o.base&&(n.base=o.base);const{data:i}=await a.rest.pulls.list(n);return this.logger.apiResponse("GET","/repos/".concat(t,"/").concat(e,"/pulls"),200,Date.now()-r),i.map(t=>({id:t.id,number:t.number,title:t.title,body:t.body,state:t.state,locked:t.locked,user:{login:t.user.login,avatar_url:t.user.avatar_url,html_url:t.user.html_url,type:t.user.type},created_at:t.created_at,updated_at:t.updated_at,closed_at:t.closed_at,merged_at:t.merged_at,html_url:t.html_url,diff_url:t.diff_url,patch_url:t.patch_url,head:{ref:t.head.ref,sha:t.head.sha,repo:t.head.repo?{name:t.head.repo.name,full_name:t.head.repo.full_name,owner:{login:t.head.repo.owner.login,avatar_url:t.head.repo.owner.avatar_url},html_url:t.head.repo.html_url}:null},base:{ref:t.base.ref,sha:t.base.sha,repo:{name:t.base.repo.name,full_name:t.base.repo.full_name,owner:{login:t.base.repo.owner.login,avatar_url:t.base.repo.owner.avatar_url},html_url:t.base.repo.html_url}},draft:t.draft,mergeable:t.mergeable,mergeable_state:t.mergeable_state,comments:t.comments,review_comments:t.review_comments,commits:t.commits,additions:t.additions,deletions:t.deletions,changed_files:t.changed_files}))}catch(a){throw this.logger.apiResponse("GET","/repos/".concat(t,"/").concat(e,"/pulls"),a.status||"error",Date.now()-r),console.error("Failed to fetch pull requests:",a),a}}async createIssue(t,e,o,r){let s=arguments.length>4&&void 0!==arguments[4]?arguments[4]:[],a=arguments.length>5&&void 0!==arguments[5]?arguments[5]:[];if(!this.isAuth())throw new Error("Authentication required to create issues");const n=Date.now();this.logger.apiCall("POST","/repos/".concat(t,"/").concat(e,"/issues"),{title:o,bodyLength:null===r||void 0===r?void 0:r.length,labels:s,assignees:a});try{const i={owner:t,repo:e,title:o,body:r};s.length>0&&(i.labels=s),a.length>0&&(i.assignees=a);const c=await this.octokit.rest.issues.create(i);return this.logger.apiResponse("POST","/repos/".concat(t,"/").concat(e,"/issues"),c.status,Date.now()-n),{success:!0,issue:{id:c.data.id,number:c.data.number,title:c.data.title,body:c.data.body,html_url:c.data.html_url,state:c.data.state,created_at:c.data.created_at,user:{login:c.data.user.login,avatar_url:c.data.user.avatar_url},labels:c.data.labels.map(t=>({name:t.name,color:t.color}))}}}catch(i){return this.logger.apiResponse("POST","/repos/".concat(t,"/").concat(e,"/issues"),i.status||"error",Date.now()-n),console.error("Failed to create issue:",i),{success:!1,error:{message:i.message,status:i.status,type:403===i.status?"permission_denied":422===i.status?"validation_error":404===i.status?"repository_not_found":"unknown_error"}}}}async getIssue(t,e,o){if(!this.isAuth())throw new Error("Authentication required to get issue details");const r=Date.now();this.logger.apiCall("GET","/repos/".concat(t,"/").concat(e,"/issues/").concat(o));try{const s=await this.octokit.rest.issues.get({owner:t,repo:e,issue_number:o});return this.logger.apiResponse("GET","/repos/".concat(t,"/").concat(e,"/issues/").concat(o),s.status,Date.now()-r),{id:s.data.id,number:s.data.number,title:s.data.title,body:s.data.body,html_url:s.data.html_url,state:s.data.state,created_at:s.data.created_at,updated_at:s.data.updated_at,closed_at:s.data.closed_at,user:{login:s.data.user.login,avatar_url:s.data.user.avatar_url},labels:s.data.labels.map(t=>({name:t.name,color:t.color}))}}catch(s){throw this.logger.apiResponse("GET","/repos/".concat(t,"/").concat(e,"/issues/").concat(o),s.status||"error",Date.now()-r),console.error("Failed to get issue:",s),s}}async getPullRequest(t,e,o){if(!this.isAuth())throw new Error("Authentication required to get pull request details");const r=Date.now();this.logger.apiCall("GET","/repos/".concat(t,"/").concat(e,"/pulls/").concat(o));try{const s=await this.octokit.rest.pulls.get({owner:t,repo:e,pull_number:o});return this.logger.apiResponse("GET","/repos/".concat(t,"/").concat(e,"/pulls/").concat(o),s.status,Date.now()-r),{id:s.data.id,number:s.data.number,title:s.data.title,body:s.data.body,html_url:s.data.html_url,state:s.data.state,created_at:s.data.created_at,updated_at:s.data.updated_at,closed_at:s.data.closed_at,merged_at:s.data.merged_at,user:{login:s.data.user.login,avatar_url:s.data.user.avatar_url},head:{ref:s.data.head.ref,sha:s.data.head.sha},base:{ref:s.data.base.ref,sha:s.data.base.sha}}}catch(s){throw this.logger.apiResponse("GET","/repos/".concat(t,"/").concat(e,"/pulls/").concat(o),s.status||"error",Date.now()-r),console.error("Failed to get pull request:",s),s}}async searchPullRequests(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};if(!this.isAuth())throw new Error("Authentication required to search pull requests");const o=Date.now();this.logger.apiCall("GET","/search/issues",{query:t,type:"pr"});try{const r=await this.octokit.rest.search.issuesAndPullRequests({q:t,sort:e.sort||"created",order:e.order||"desc",per_page:e.per_page||30,page:e.page||1});return this.logger.apiResponse("GET","/search/issues",r.status,Date.now()-o),{total_count:r.data.total_count,incomplete_results:r.data.incomplete_results,items:r.data.items.map(t=>({id:t.id,number:t.number,title:t.title,body:t.body,html_url:t.html_url,state:t.state,created_at:t.created_at,updated_at:t.updated_at,closed_at:t.closed_at,user:{login:t.user.login,avatar_url:t.user.avatar_url},repository:t.repository_url?{name:t.repository_url.split("/").slice(-1)[0],full_name:t.repository_url.split("/").slice(-2).join("/")}:null}))}}catch(r){throw this.logger.apiResponse("GET","/search/issues",r.status||"error",Date.now()-o),console.error("Failed to search pull requests:",r),r}}logout(){this.logger.auth("Logging out and clearing stored token"),this.octokit=null,this.isAuthenticated=!1,this.tokenType=null,this.permissions=null,c.clearToken();try{const{default:t}=o(88691);t.clearAllBranchContext()}catch(t){sessionStorage.removeItem("sgex_branch_context")}}async getRepositoryForks(t,e){let o=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};const r=Date.now();this.logger.debug("Fetching repository forks",{owner:t,repo:e,options:o});try{const a=this.isAuth()?this.octokit:new s.Octokit;this.logger.apiCall("GET","/repos/".concat(t,"/").concat(e,"/forks"),o);const{data:n}=await a.rest.repos.listForks({owner:t,repo:e,sort:"newest",per_page:o.per_page||100,page:o.page||1}),i=Date.now()-r;return this.logger.apiResponse("GET","/repos/".concat(t,"/").concat(e,"/forks"),200,i,{forkCount:n.length}),this.logger.performance("Repository forks fetch",i),n}catch(a){const o=Date.now()-r;throw this.logger.apiError("GET","/repos/".concat(t,"/").concat(e,"/forks"),a),this.logger.performance("Repository forks fetch (failed)",o),console.error("Failed to fetch forks for ".concat(t,"/").concat(e,":"),a),a}}}},88691:(t,e,o)=>{o.r(e),o.d(e,{default:()=>r});const r=new class{constructor(){this.storageKey="sgex_branch_context"}getRepositoryKey(t){var e,o;if(!t||!t.name)return null;const r=(null===(e=t.owner)||void 0===e?void 0:e.login)||(null===(o=t.full_name)||void 0===o?void 0:o.split("/")[0]);return r?"".concat(r,"/").concat(t.name):null}getSelectedBranch(t){if(!t)return null;try{const e=this.getBranchContext();return e[this.getRepositoryKey(t)]||null}catch(e){return console.warn("Failed to get branch context:",e),null}}setSelectedBranch(t,e){if(t&&e)try{const o=this.getBranchContext();o[this.getRepositoryKey(t)]=e,this.setBranchContext(o)}catch(o){console.warn("Failed to set branch context:",o)}}clearRepositoryBranch(t){if(t)try{const e=this.getBranchContext();delete e[this.getRepositoryKey(t)],this.setBranchContext(e)}catch(e){console.warn("Failed to clear repository branch context:",e)}}clearAllBranchContext(){try{sessionStorage.removeItem(this.storageKey)}catch(t){console.warn("Failed to clear branch context:",t)}}getBranchContext(){try{const t=sessionStorage.getItem(this.storageKey);return t?JSON.parse(t):{}}catch(t){return console.warn("Failed to parse branch context from storage:",t),{}}}setBranchContext(t){try{sessionStorage.setItem(this.storageKey,JSON.stringify(t))}catch(e){console.warn("Failed to save branch context to storage:",e)}}getDefaultBranchName(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:[];return t?e.some(t=>"main"===t.name)?"main":t.default_branch&&e.some(e=>e.name===t.default_branch)?t.default_branch:e.length>0?e[0].name:"main":"main"}hasBranchContext(t){return null!==this.getSelectedBranch(t)}getBranchDisplayInfo(t){const e=this.getSelectedBranch(t);if(!e)return null;const o=e===((null===t||void 0===t?void 0:t.default_branch)||"main");return{branch:e,isDefault:o,displayText:o?"".concat(e," (default)"):e}}}}}]);
//# sourceMappingURL=675.e3b260a9.chunk.js.map