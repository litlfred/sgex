{"version":3,"file":"static/js/675.e3b260a9.chunk.js","mappings":"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","sources":["services/stagingGroundService.js","utils/concurrency.js","utils/repositoryCompatibilityCache.js","services/secureTokenStorage.js","services/githubService.js","services/branchContextService.js"],"sourcesContent":["/**\n * Staging Ground Service\n * \n * Manages local changes to DAK components before they are committed to GitHub.\n * Provides persistent storage, versioning, and integration interfaces for DAK editing tools.\n */\n\nclass StagingGroundService {\n  constructor() {\n    this.listeners = new Set();\n    this.currentRepository = null;\n    this.currentBranch = null;\n  }\n\n  /**\n   * Initialize staging ground for a specific repository and branch\n   */\n  initialize(repository, branch) {\n    this.currentRepository = repository;\n    this.currentBranch = branch;\n    this.notifyListeners();\n  }\n\n  /**\n   * Get the storage key for current repository and branch\n   */\n  getStorageKey() {\n    if (!this.currentRepository || !this.currentBranch) {\n      throw new Error('Staging ground not initialized');\n    }\n    return `sgex_staging_${this.currentRepository.full_name}_${this.currentBranch}`;\n  }\n\n  /**\n   * Get current staging ground state\n   */\n  getStagingGround() {\n    try {\n      const key = this.getStorageKey();\n      const stored = localStorage.getItem(key);\n      if (!stored) {\n        return this.createEmptyStagingGround();\n      }\n      return JSON.parse(stored);\n    } catch (error) {\n      console.warn('Error reading staging ground from localStorage:', error);\n      return this.createEmptyStagingGround();\n    }\n  }\n\n  /**\n   * Create empty staging ground structure\n   */\n  createEmptyStagingGround() {\n    return {\n      message: '',\n      files: [],\n      timestamp: Date.now(),\n      branch: this.currentBranch,\n      repository: this.currentRepository?.full_name\n    };\n  }\n\n  /**\n   * Save staging ground state to localStorage\n   */\n  saveStagingGround(stagingGround) {\n    try {\n      const key = this.getStorageKey();\n      stagingGround.timestamp = Date.now();\n      stagingGround.branch = this.currentBranch;\n      stagingGround.repository = this.currentRepository?.full_name;\n      \n      localStorage.setItem(key, JSON.stringify(stagingGround));\n      this.saveToHistory(stagingGround);\n      this.notifyListeners();\n      return true;\n    } catch (error) {\n      console.error('Error saving staging ground to localStorage:', error);\n      return false;\n    }\n  }\n\n  /**\n   * Add or update a file in the staging ground\n   */\n  updateFile(filePath, content, metadata = {}) {\n    const stagingGround = this.getStagingGround();\n    \n    // Find existing file or create new one\n    const existingFileIndex = stagingGround.files.findIndex(f => f.path === filePath);\n    const fileObject = {\n      path: filePath,\n      content: content,\n      metadata: {\n        ...metadata,\n        lastModified: Date.now()\n      },\n      timestamp: Date.now()\n    };\n\n    if (existingFileIndex >= 0) {\n      stagingGround.files[existingFileIndex] = fileObject;\n    } else {\n      stagingGround.files.push(fileObject);\n    }\n\n    return this.saveStagingGround(stagingGround);\n  }\n\n  /**\n   * Remove a file from the staging ground\n   */\n  removeFile(filePath) {\n    const stagingGround = this.getStagingGround();\n    stagingGround.files = stagingGround.files.filter(f => f.path !== filePath);\n    return this.saveStagingGround(stagingGround);\n  }\n\n  /**\n   * Update commit message\n   */\n  updateCommitMessage(message) {\n    const stagingGround = this.getStagingGround();\n    stagingGround.message = message;\n    return this.saveStagingGround(stagingGround);\n  }\n\n  /**\n   * Check if staging ground has changes\n   */\n  hasChanges() {\n    const stagingGround = this.getStagingGround();\n    return stagingGround.files.length > 0;\n  }\n\n  /**\n   * Get count of changed files\n   */\n  getChangedFilesCount() {\n    const stagingGround = this.getStagingGround();\n    return stagingGround.files.length;\n  }\n\n  /**\n   * Clear all changes in staging ground\n   */\n  clearStagingGround() {\n    const empty = this.createEmptyStagingGround();\n    return this.saveStagingGround(empty);\n  }\n\n  /**\n   * Save current state to history for rollback\n   */\n  saveToHistory(stagingGround) {\n    try {\n      const historyKey = `${this.getStorageKey()}_history`;\n      const history = this.getHistory();\n      \n      // Add current state to history\n      history.push({\n        ...stagingGround,\n        savedAt: Date.now()\n      });\n\n      // Keep only last 10 saves\n      const recentHistory = history.slice(-10);\n      localStorage.setItem(historyKey, JSON.stringify(recentHistory));\n      \n    } catch (error) {\n      console.warn('Error saving to history:', error);\n    }\n  }\n\n  /**\n   * Get history of saves\n   */\n  getHistory() {\n    try {\n      const historyKey = `${this.getStorageKey()}_history`;\n      const stored = localStorage.getItem(historyKey);\n      return stored ? JSON.parse(stored) : [];\n    } catch (error) {\n      console.warn('Error reading history:', error);\n      return [];\n    }\n  }\n\n  /**\n   * Rollback to a previous save\n   */\n  rollbackToSave(timestamp) {\n    const history = this.getHistory();\n    const save = history.find(s => s.savedAt === timestamp);\n    \n    if (!save) {\n      throw new Error('Save not found in history');\n    }\n\n    // Remove the savedAt timestamp before restoring\n    const { savedAt, ...stagingGroundState } = save;\n    return this.saveStagingGround(stagingGroundState);\n  }\n\n  /**\n   * Export staging ground state for backup/sharing\n   */\n  exportStagingGround() {\n    const stagingGround = this.getStagingGround();\n    const history = this.getHistory();\n    \n    return {\n      current: stagingGround,\n      history: history,\n      exportedAt: Date.now(),\n      repository: this.currentRepository?.full_name,\n      branch: this.currentBranch\n    };\n  }\n\n  /**\n   * Import staging ground state from backup\n   */\n  importStagingGround(exportedData) {\n    if (!exportedData.current || !exportedData.repository || !exportedData.branch) {\n      throw new Error('Invalid export data format');\n    }\n\n    if (exportedData.repository !== this.currentRepository?.full_name ||\n        exportedData.branch !== this.currentBranch) {\n      throw new Error('Export data is for different repository or branch');\n    }\n\n    // Save current state and import new one\n    this.saveStagingGround(exportedData.current);\n    \n    // Import history if available\n    if (exportedData.history) {\n      try {\n        const historyKey = `${this.getStorageKey()}_history`;\n        localStorage.setItem(historyKey, JSON.stringify(exportedData.history));\n      } catch (error) {\n        console.warn('Error importing history:', error);\n      }\n    }\n\n    return true;\n  }\n\n  /**\n   * Clean up old staging grounds and history\n   */\n  cleanup(maxAge = 7 * 24 * 60 * 60 * 1000) { // 7 days default\n    try {\n      const now = Date.now();\n      const keysToRemove = [];\n\n      // Check all localStorage keys for old staging grounds\n      for (let i = 0; i < localStorage.length; i++) {\n        const key = localStorage.key(i);\n        if (key && key.startsWith('sgex_staging_')) {\n          try {\n            const data = JSON.parse(localStorage.getItem(key));\n            if (data.timestamp && (now - data.timestamp) > maxAge) {\n              keysToRemove.push(key);\n              keysToRemove.push(`${key}_history`);\n            }\n          } catch (error) {\n            // Invalid data, mark for removal\n            keysToRemove.push(key);\n          }\n        }\n      }\n\n      // Remove old entries\n      keysToRemove.forEach(key => {\n        localStorage.removeItem(key);\n      });\n\n      return keysToRemove.length;\n    } catch (error) {\n      console.error('Error during cleanup:', error);\n      return 0;\n    }\n  }\n\n  /**\n   * Add listener for staging ground changes\n   */\n  addListener(callback) {\n    this.listeners.add(callback);\n    \n    // Return unsubscribe function\n    return () => {\n      this.listeners.delete(callback);\n    };\n  }\n\n  /**\n   * Notify all listeners of changes\n   */\n  notifyListeners() {\n    const stagingGround = this.getStagingGround();\n    this.listeners.forEach(callback => {\n      try {\n        callback(stagingGround);\n      } catch (error) {\n        console.error('Error in staging ground listener:', error);\n      }\n    });\n  }\n\n  /**\n   * Interface for DAK editing tools to contribute files\n   */\n  contributeFiles(files, metadata = {}) {\n    if (!Array.isArray(files)) {\n      files = [files];\n    }\n\n    let success = true;\n    const results = [];\n\n    files.forEach(file => {\n      if (!file.path || !file.content) {\n        results.push({ path: file.path, success: false, error: 'Missing path or content' });\n        success = false;\n        return;\n      }\n\n      const result = this.updateFile(file.path, file.content, {\n        ...metadata,\n        source: metadata.tool || 'unknown',\n        contributedAt: Date.now()\n      });\n\n      results.push({ path: file.path, success: result });\n      if (!result) success = false;\n    });\n\n    return { success, results };\n  }\n\n  /**\n   * Get status for DAK editing tools\n   */\n  getStatus() {\n    const stagingGround = this.getStagingGround();\n    return {\n      hasChanges: this.hasChanges(),\n      filesCount: this.getChangedFilesCount(),\n      lastModified: stagingGround.timestamp,\n      branch: this.currentBranch,\n      repository: this.currentRepository?.full_name\n    };\n  }\n}\n\n// Create singleton instance\nconst stagingGroundService = new StagingGroundService();\n\nexport default stagingGroundService;","/**\n * Utility for managing concurrent async operations with rate limiting\n */\n\n/**\n * Processes items concurrently with a specified concurrency limit\n * @param {Array} items - Items to process\n * @param {Function} processor - Async function to process each item\n * @param {Object} options - Options for concurrency control\n * @param {number} options.concurrency - Maximum concurrent operations (default: 5)\n * @param {Function} options.onProgress - Progress callback (current, total, item, result)\n * @param {Function} options.onItemComplete - Callback when item completes (item, result, error)\n * @param {Function} options.onItemStart - Callback when item starts processing (item, index)\n * @returns {Promise<Array>} Array of results (in original order)\n */\nexport async function processConcurrently(items, processor, options = {}) {\n  const {\n    concurrency = 5,\n    onProgress = null,\n    onItemComplete = null,\n    onItemStart = null\n  } = options;\n\n  if (!items || items.length === 0) {\n    return [];\n  }\n\n  const results = new Array(items.length);\n  const total = items.length;\n  let completed = 0;\n\n  // Create a queue of work items\n  const queue = items.map((item, index) => ({ item, index }));\n  \n  // Worker function that processes items from the queue\n  const worker = async () => {\n    while (queue.length > 0) {\n      const { item, index } = queue.shift();\n      \n      // Notify that processing is starting\n      if (onItemStart) {\n        onItemStart(item, index);\n      }\n      \n      try {\n        const result = await processor(item, index);\n        results[index] = result;\n        \n        completed++;\n        \n        // Call callbacks\n        if (onProgress) {\n          onProgress(completed, total, item, result);\n        }\n        if (onItemComplete) {\n          onItemComplete(item, result, null);\n        }\n      } catch (error) {\n        // Store error as result\n        results[index] = { error, item };\n        \n        completed++;\n        \n        // Call callbacks\n        if (onProgress) {\n          onProgress(completed, total, item, null);\n        }\n        if (onItemComplete) {\n          onItemComplete(item, null, error);\n        }\n      }\n    }\n  };\n\n  // Start worker promises (limited by concurrency)\n  const workers = Array(Math.min(concurrency, items.length))\n    .fill()\n    .map(() => worker());\n\n  // Wait for all workers to complete\n  await Promise.all(workers);\n\n  return results;\n}\n\n/**\n * Rate-limited function executor\n * Useful for API calls that need to respect rate limits\n */\nexport class RateLimiter {\n  constructor(requestsPerSecond = 5) {\n    this.requestsPerSecond = requestsPerSecond;\n    this.requests = [];\n    this.interval = 1000 / requestsPerSecond; // ms between requests\n  }\n\n  /**\n   * Execute a function with rate limiting\n   * @param {Function} fn - Function to execute\n   * @returns {Promise} Result of the function\n   */\n  async execute(fn) {\n    const now = Date.now();\n    \n    // Remove requests older than 1 second\n    this.requests = this.requests.filter(time => now - time < 1000);\n    \n    // If we're at the limit, wait\n    if (this.requests.length >= this.requestsPerSecond) {\n      const oldestRequest = Math.min(...this.requests);\n      const waitTime = 1000 - (now - oldestRequest) + 10; // Add 10ms buffer\n      if (waitTime > 0) {\n        await new Promise(resolve => setTimeout(resolve, waitTime));\n      }\n    }\n    \n    // Record this request\n    this.requests.push(Date.now());\n    \n    // Execute the function\n    return await fn();\n  }\n}","/**\n * Simple in-memory cache for repository compatibility checks\n * Prevents redundant sushi-config.yaml downloads during scanning\n */\n\nclass RepositoryCompatibilityCache {\n  constructor(ttlMinutes = 30) {\n    this.cache = new Map();\n    this.ttl = ttlMinutes * 60 * 1000; // Convert to milliseconds\n  }\n\n  /**\n   * Generate cache key for a repository\n   * @param {string} owner - Repository owner\n   * @param {string} repo - Repository name\n   * @returns {string} Cache key\n   */\n  _getCacheKey(owner, repo) {\n    return `${owner}/${repo}`;\n  }\n\n  /**\n   * Check if cache entry is still valid\n   * @param {Object} entry - Cache entry\n   * @returns {boolean} True if valid\n   */\n  _isValid(entry) {\n    return Date.now() - entry.timestamp < this.ttl;\n  }\n\n  /**\n   * Get cached compatibility result\n   * @param {string} owner - Repository owner\n   * @param {string} repo - Repository name\n   * @returns {boolean|null} Cached result or null if not cached/expired\n   */\n  get(owner, repo) {\n    const key = this._getCacheKey(owner, repo);\n    const entry = this.cache.get(key);\n    \n    if (!entry) {\n      return null;\n    }\n    \n    if (!this._isValid(entry)) {\n      this.cache.delete(key);\n      return null;\n    }\n    \n    return entry.compatible;\n  }\n\n  /**\n   * Set cached compatibility result\n   * @param {string} owner - Repository owner\n   * @param {string} repo - Repository name\n   * @param {boolean} compatible - Whether repository is SMART guidelines compatible\n   */\n  set(owner, repo, compatible) {\n    const key = this._getCacheKey(owner, repo);\n    this.cache.set(key, {\n      compatible,\n      timestamp: Date.now()\n    });\n  }\n\n  /**\n   * Clear all cached entries\n   */\n  clear() {\n    this.cache.clear();\n  }\n\n  /**\n   * Clean up expired entries\n   */\n  cleanup() {\n    const now = Date.now();\n    for (const [key, entry] of this.cache.entries()) {\n      if (now - entry.timestamp >= this.ttl) {\n        this.cache.delete(key);\n      }\n    }\n  }\n\n  /**\n   * Get cache statistics\n   * @returns {Object} Cache stats\n   */\n  getStats() {\n    this.cleanup();\n    return {\n      size: this.cache.size,\n      ttlMinutes: this.ttl / (60 * 1000),\n      entries: Array.from(this.cache.entries()).map(([key, entry]) => ({\n        repository: key,\n        compatible: entry.compatible,\n        ageMinutes: Math.round((Date.now() - entry.timestamp) / (60 * 1000))\n      }))\n    };\n  }\n}\n\n// Create a singleton instance\nconst repositoryCompatibilityCache = new RepositoryCompatibilityCache();\n\nexport default repositoryCompatibilityCache;","/**\n * SecureTokenStorage - Secure storage for GitHub Personal Access Tokens\n * \n * Features:\n * - XOR encryption using browser fingerprint-based keys\n * - Token format validation (classic and fine-grained PATs)\n * - Automatic token expiration (24 hours)\n * - Secure token masking for logs and error messages\n */\n\nimport logger from '../utils/logger';\n\nclass SecureTokenStorage {\n  constructor() {\n    this.logger = logger.getLogger('SecureTokenStorage');\n    this.storageKey = 'sgex_secure_token';\n    this.expirationHours = 24;\n    this.logger.debug('SecureTokenStorage instance created');\n  }\n\n  /**\n   * Generate a browser fingerprint for encryption key\n   * @returns {string} Browser fingerprint\n   */\n  generateBrowserFingerprint() {\n    const canvas = document.createElement('canvas');\n    const ctx = canvas.getContext('2d');\n    ctx.textBaseline = 'top';\n    ctx.font = '14px Arial';\n    ctx.fillText('Browser fingerprint', 2, 2);\n    \n    const fingerprint = [\n      navigator.userAgent,\n      navigator.language,\n      window.screen.width + 'x' + window.screen.height,\n      window.screen.colorDepth,\n      new Date().getTimezoneOffset(),\n      canvas.toDataURL()\n    ].join('|');\n    \n    // Create a simple hash of the fingerprint\n    let hash = 0;\n    for (let i = 0; i < fingerprint.length; i++) {\n      const char = fingerprint.charCodeAt(i);\n      hash = ((hash << 5) - hash) + char;\n      hash = hash & hash; // Convert to 32-bit integer\n    }\n    \n    return Math.abs(hash).toString(36);\n  }\n\n  /**\n   * XOR encrypt/decrypt text using a key\n   * @param {string} text - Text to encrypt/decrypt\n   * @param {string} key - Encryption key\n   * @returns {string} Encrypted/decrypted text\n   */\n  xorCipher(text, key) {\n    let result = '';\n    for (let i = 0; i < text.length; i++) {\n      result += String.fromCharCode(\n        text.charCodeAt(i) ^ key.charCodeAt(i % key.length)\n      );\n    }\n    return result;\n  }\n\n  /**\n   * Validate GitHub Personal Access Token format\n   * @param {string} token - Token to validate\n   * @returns {object} Validation result with type and validity\n   */\n  validateTokenFormat(token) {\n    if (!token || typeof token !== 'string') {\n      return { isValid: false, type: 'invalid', reason: 'Token is empty or not a string' };\n    }\n\n    // Remove any whitespace\n    const cleanToken = token.trim();\n\n    // Classic Personal Access Token format: ghp_[36 characters A-Za-z0-9]\n    if (cleanToken.match(/^ghp_[A-Za-z0-9]{36}$/)) {\n      return { isValid: true, type: 'classic', token: cleanToken };\n    }\n\n    // Fine-grained Personal Access Token format: github_pat_[22 characters]_[59 characters]\n    if (cleanToken.match(/^github_pat_[A-Za-z0-9]{22}_[A-Za-z0-9]{59}$/)) {\n      return { isValid: true, type: 'fine-grained', token: cleanToken };\n    }\n\n    // OAuth token format: gho_[36 characters] (for completeness)\n    if (cleanToken.match(/^gho_[A-Za-z0-9]{36}$/)) {\n      return { isValid: true, type: 'oauth', token: cleanToken };\n    }\n\n    // Check for old-style tokens (40 hex characters) - deprecated but might still work\n    if (cleanToken.match(/^[a-fA-F0-9]{40}$/)) {\n      return { isValid: true, type: 'legacy', token: cleanToken };\n    }\n\n    return { \n      isValid: false, \n      type: 'invalid', \n      reason: 'Token does not match expected GitHub PAT format'\n    };\n  }\n\n  /**\n   * Mask token for safe logging\n   * @param {string} token - Token to mask\n   * @returns {string} Masked token\n   */\n  maskToken(token) {\n    if (!token || typeof token !== 'string') {\n      return '[INVALID_TOKEN]';\n    }\n\n    const cleanToken = token.trim();\n    if (cleanToken.length < 8) {\n      return '[INVALID_TOKEN]';\n    }\n\n    // Show first 4 and last 4 characters for debugging purposes\n    return `${cleanToken.substring(0, 4)}${'*'.repeat(cleanToken.length - 8)}${cleanToken.substring(cleanToken.length - 4)}`;\n  }\n\n  /**\n   * Store token securely with encryption and expiration\n   * @param {string} token - GitHub Personal Access Token\n   * @returns {boolean} Success status\n   */\n  storeToken(token) {\n    try {\n      this.logger.debug('Starting secure token storage');\n\n      // Validate token format\n      const validation = this.validateTokenFormat(token);\n      if (!validation.isValid) {\n        this.logger.warn('Token validation failed', { \n          reason: validation.reason,\n          tokenMask: this.maskToken(token)\n        });\n        return false;\n      }\n\n      this.logger.debug('Token validation successful', { \n        type: validation.type,\n        tokenMask: this.maskToken(token)\n      });\n\n      // Generate encryption key\n      const fingerprint = this.generateBrowserFingerprint();\n      const encryptionKey = `sgex_${fingerprint}_${Date.now().toString(36)}`;\n\n      // Encrypt token\n      const encryptedToken = this.xorCipher(validation.token, encryptionKey);\n      \n      // Create storage object with metadata\n      const storageData = {\n        token: btoa(encryptedToken), // Base64 encode for safe storage\n        key: btoa(encryptionKey), // Base64 encode the key\n        type: validation.type,\n        created: Date.now(),\n        expires: Date.now() + (this.expirationHours * 60 * 60 * 1000),\n        fingerprint: fingerprint\n      };\n\n      // Store in sessionStorage (more secure than localStorage for tokens)\n      sessionStorage.setItem(this.storageKey, JSON.stringify(storageData));\n      \n      // Clear any old tokens from localStorage\n      localStorage.removeItem('github_token');\n      sessionStorage.removeItem('github_token');\n\n      this.logger.debug('Token stored securely', { \n        type: validation.type,\n        expires: new Date(storageData.expires).toISOString(),\n        tokenMask: this.maskToken(token)\n      });\n\n      return true;\n    } catch (error) {\n      this.logger.error('Failed to store token securely', { \n        error: error.message,\n        tokenMask: this.maskToken(token)\n      });\n      return false;\n    }\n  }\n\n  /**\n   * Retrieve and decrypt stored token\n   * @returns {object|null} Token data or null if not found/expired\n   */\n  retrieveToken() {\n    try {\n      this.logger.debug('Attempting to retrieve secure token');\n\n      const storedData = sessionStorage.getItem(this.storageKey);\n      if (!storedData) {\n        this.logger.debug('No secure token found in storage');\n        return null;\n      }\n\n      const data = JSON.parse(storedData);\n      \n      // Check expiration\n      if (Date.now() > data.expires) {\n        this.logger.warn('Stored token has expired');\n        this.clearToken();\n        return null;\n      }\n\n      // Verify browser fingerprint\n      const currentFingerprint = this.generateBrowserFingerprint();\n      if (data.fingerprint !== currentFingerprint) {\n        this.logger.warn('Browser fingerprint mismatch - possible security issue');\n        this.clearToken();\n        return null;\n      }\n\n      // Decrypt token\n      const encryptionKey = atob(data.key);\n      const encryptedToken = atob(data.token);\n      const decryptedToken = this.xorCipher(encryptedToken, encryptionKey);\n\n      // Validate decrypted token\n      const validation = this.validateTokenFormat(decryptedToken);\n      if (!validation.isValid) {\n        this.logger.error('Decrypted token failed validation');\n        this.clearToken();\n        return null;\n      }\n\n      this.logger.debug('Token retrieved and decrypted successfully', { \n        type: data.type,\n        expires: new Date(data.expires).toISOString(),\n        tokenMask: this.maskToken(decryptedToken)\n      });\n\n      return {\n        token: validation.token,\n        type: data.type,\n        created: data.created,\n        expires: data.expires\n      };\n    } catch (error) {\n      this.logger.error('Failed to retrieve secure token', { error: error.message });\n      this.clearToken();\n      return null;\n    }\n  }\n\n  /**\n   * Check if a valid token exists without retrieving it\n   * @returns {boolean} True if valid token exists\n   */\n  hasValidToken() {\n    try {\n      const storedData = sessionStorage.getItem(this.storageKey);\n      if (!storedData) {\n        return false;\n      }\n\n      const data = JSON.parse(storedData);\n      \n      // Check expiration\n      if (Date.now() > data.expires) {\n        this.clearToken();\n        return false;\n      }\n\n      // Verify browser fingerprint\n      const currentFingerprint = this.generateBrowserFingerprint();\n      if (data.fingerprint !== currentFingerprint) {\n        this.clearToken();\n        return false;\n      }\n\n      return true;\n    } catch (error) {\n      this.logger.error('Error checking token validity', { error: error.message });\n      this.clearToken();\n      return false;\n    }\n  }\n\n  /**\n   * Clear stored token and cleanup\n   */\n  clearToken() {\n    this.logger.debug('Clearing secure token storage');\n    \n    sessionStorage.removeItem(this.storageKey);\n    \n    // Also clear legacy token storage\n    sessionStorage.removeItem('github_token');\n    localStorage.removeItem('github_token');\n  }\n\n  /**\n   * Get token expiration info\n   * @returns {object|null} Expiration info or null if no token\n   */\n  getTokenInfo() {\n    try {\n      const storedData = sessionStorage.getItem(this.storageKey);\n      if (!storedData) {\n        return null;\n      }\n\n      const data = JSON.parse(storedData);\n      const timeRemaining = data.expires - Date.now();\n      \n      return {\n        type: data.type,\n        created: new Date(data.created),\n        expires: new Date(data.expires),\n        timeRemaining: Math.max(0, timeRemaining),\n        isExpired: timeRemaining <= 0,\n        isValid: this.hasValidToken()\n      };\n    } catch (error) {\n      this.logger.error('Error getting token info', { error: error.message });\n      return null;\n    }\n  }\n\n  /**\n   * Migrate from legacy token storage\n   * @returns {boolean} True if migration was successful\n   */\n  migrateLegacyToken() {\n    try {\n      // Check for tokens in legacy storage\n      const legacyToken = sessionStorage.getItem('github_token') || localStorage.getItem('github_token');\n      \n      if (!legacyToken) {\n        this.logger.debug('No legacy token found for migration');\n        return false;\n      }\n\n      this.logger.debug('Migrating legacy token to secure storage');\n\n      // Store using new secure method\n      const success = this.storeToken(legacyToken);\n      \n      if (success) {\n        // Clear legacy storage\n        sessionStorage.removeItem('github_token');\n        localStorage.removeItem('github_token');\n        this.logger.debug('Legacy token migration completed successfully');\n        return true;\n      } else {\n        this.logger.error('Failed to migrate legacy token');\n        return false;\n      }\n    } catch (error) {\n      this.logger.error('Error during legacy token migration', { error: error.message });\n      return false;\n    }\n  }\n}\n\n// Create singleton instance\nconst secureTokenStorage = new SecureTokenStorage();\n\nexport default secureTokenStorage;","import { Octokit } from '@octokit/rest';\nimport { processConcurrently } from '../utils/concurrency';\nimport repositoryCompatibilityCache from '../utils/repositoryCompatibilityCache';\nimport secureTokenStorage from './secureTokenStorage';\nimport logger from '../utils/logger';\n\nclass GitHubService {\n  constructor() {\n    this.octokit = null;\n    this.isAuthenticated = false;\n    this.permissions = null;\n    this.tokenType = null; // 'classic', 'fine-grained', or 'oauth'\n    this.logger = logger.getLogger('GitHubService');\n    this.logger.debug('GitHubService instance created');\n  }\n\n  // Initialize with a GitHub token (supports both OAuth and PAT tokens)\n  authenticate(token) {\n    const startTime = Date.now();\n    this.logger.auth('Starting authentication', { \n      tokenProvided: !!token, \n      tokenMask: token ? secureTokenStorage.maskToken(token) : 'none'\n    });\n    \n    try {\n      // Validate token format using SecureTokenStorage\n      const validation = secureTokenStorage.validateTokenFormat(token);\n      if (!validation.isValid) {\n        this.logger.warn('Token validation failed during authentication', { \n          reason: validation.reason,\n          tokenMask: secureTokenStorage.maskToken(token)\n        });\n        this.isAuthenticated = false;\n        return false;\n      }\n\n      this.octokit = new Octokit({\n        auth: validation.token,\n      });\n      this.isAuthenticated = true;\n      this.tokenType = validation.type;\n      \n      // Store token securely\n      const stored = secureTokenStorage.storeToken(validation.token);\n      if (!stored) {\n        this.logger.warn('Failed to store token securely, authentication will not persist');\n      }\n      \n      const duration = Date.now() - startTime;\n      this.logger.auth('Authentication successful', { \n        duration, \n        tokenType: this.tokenType,\n        tokenMask: secureTokenStorage.maskToken(token),\n        securelyStored: stored\n      });\n      this.logger.performance('GitHub authentication', duration);\n      \n      return true;\n    } catch (error) {\n      const duration = Date.now() - startTime;\n      this.logger.auth('Authentication failed', { \n        error: error.message, \n        duration,\n        tokenMask: secureTokenStorage.maskToken(token)\n      });\n      console.error('Failed to authenticate with GitHub:', error);\n      this.isAuthenticated = false;\n      secureTokenStorage.clearToken(); // Clear any partially stored data\n      return false;\n    }\n  }\n\n  // Initialize with an existing Octokit instance (for OAuth flow)\n  authenticateWithOctokit(octokitInstance) {\n    this.logger.auth('Starting OAuth authentication with Octokit instance');\n    \n    try {\n      this.octokit = octokitInstance;\n      this.isAuthenticated = true;\n      this.tokenType = 'oauth';\n      \n      this.logger.auth('OAuth authentication successful', { tokenType: this.tokenType });\n      return true;\n    } catch (error) {\n      this.logger.auth('OAuth authentication failed', { error: error.message });\n      console.error('Failed to authenticate with Octokit instance:', error);\n      this.isAuthenticated = false;\n      return false;\n    }\n  }\n\n  // Initialize authentication from securely stored token\n  initializeFromStoredToken() {\n    this.logger.auth('Attempting to initialize from stored token');\n    \n    try {\n      // First try to migrate any legacy tokens\n      const migrated = secureTokenStorage.migrateLegacyToken();\n      if (migrated) {\n        this.logger.debug('Successfully migrated legacy token to secure storage');\n      }\n\n      // Retrieve token from secure storage\n      const tokenData = secureTokenStorage.retrieveToken();\n      if (!tokenData) {\n        this.logger.debug('No valid stored token found');\n        return false;\n      }\n\n      // Initialize Octokit with stored token\n      this.octokit = new Octokit({\n        auth: tokenData.token,\n      });\n      this.isAuthenticated = true;\n      this.tokenType = tokenData.type;\n      \n      this.logger.auth('Successfully initialized from stored token', {\n        tokenType: this.tokenType,\n        tokenMask: secureTokenStorage.maskToken(tokenData.token),\n        expires: new Date(tokenData.expires).toISOString()\n      });\n      \n      return true;\n    } catch (error) {\n      this.logger.auth('Failed to initialize from stored token', { error: error.message });\n      this.isAuthenticated = false;\n      secureTokenStorage.clearToken();\n      return false;\n    }\n  }\n\n  // Check if there's a valid stored token\n  hasStoredToken() {\n    return secureTokenStorage.hasValidToken();\n  }\n\n  // Get information about stored token\n  getStoredTokenInfo() {\n    return secureTokenStorage.getTokenInfo();\n  }\n\n  // Check token permissions and type\n  async checkTokenPermissions() {\n    if (!this.isAuth()) {\n      const error = new Error('Not authenticated with GitHub');\n      this.logger.error('Token permission check failed - not authenticated');\n      throw error;\n    }\n\n    const startTime = Date.now();\n    this.logger.apiCall('GET', '/user', null);\n\n    try {\n      // Try to get token info to determine type and permissions\n      const response = await this.octokit.request('GET /user');\n      this.logger.apiResponse('GET', '/user', response.status, Date.now() - startTime);\n      \n      // Check if this is a fine-grained token by trying to access rate limit info\n      try {\n        const rateLimitStart = Date.now();\n        this.logger.apiCall('GET', '/rate_limit', null);\n        const rateLimit = await this.octokit.rest.rateLimit.get();\n        this.logger.apiResponse('GET', '/rate_limit', rateLimit.status, Date.now() - rateLimitStart);\n        \n        // Fine-grained tokens have different rate limit structure\n        this.tokenType = rateLimit.data.resources.core ? 'classic' : 'fine-grained';\n        this.logger.debug('Token type determined', { tokenType: this.tokenType, hasCore: !!rateLimit.data.resources.core });\n      } catch (rateLimitError) {\n        this.tokenType = 'unknown';\n        this.logger.warn('Could not determine token type from rate limit', { error: rateLimitError.message });\n      }\n\n      const permissions = {\n        type: this.tokenType,\n        user: response.data\n      };\n      \n      this.permissions = permissions;\n      this.logger.debug('Token permissions checked successfully', { \n        tokenType: this.tokenType, \n        username: response.data.login \n      });\n      \n      return permissions;\n    } catch (error) {\n      const duration = Date.now() - startTime;\n      this.logger.apiError('GET', '/user', error);\n      this.logger.performance('Token permission check (failed)', duration);\n      console.error('Failed to check token permissions:', error);\n      throw error;\n    }\n  }\n\n  // Check if we have write permissions for a specific repository\n  async checkRepositoryWritePermissions(owner, repo) {\n    if (!this.isAuth()) {\n      this.logger.warn('Cannot check repository write permissions - not authenticated', { owner, repo });\n      return false;\n    }\n\n    const startTime = Date.now();\n    this.logger.debug('Checking write permissions for repository', { owner, repo });\n\n    try {\n      // Get current user first\n      const currentUser = await this.getCurrentUser();\n      const username = currentUser.login;\n      \n      this.logger.apiCall('GET', `/repos/${owner}/${repo}/collaborators/${username}/permission`, null);\n      \n      // Try to get repository collaborator permissions\n      const { data } = await this.octokit.rest.repos.getCollaboratorPermissionLevel({\n        owner,\n        repo,\n        username\n      });\n      \n      const duration = Date.now() - startTime;\n      this.logger.apiResponse('GET', `/repos/${owner}/${repo}/collaborators/${username}/permission`, 200, duration);\n      \n      const hasWriteAccess = ['write', 'admin'].includes(data.permission);\n      this.logger.debug('Repository write permissions checked', { \n        owner, \n        repo, \n        permission: data.permission, \n        hasWriteAccess \n      });\n      \n      return hasWriteAccess;\n    } catch (error) {\n      const duration = Date.now() - startTime;\n      this.logger.apiError('GET', `/repos/${owner}/${repo}/collaborators/*/permission`, error);\n      this.logger.performance('Repository write permission check (failed)', duration);\n      \n      // If we can't check permissions, assume we don't have write access\n      console.warn('Could not check repository write permissions:', error);\n      this.logger.warn('Assuming no write access due to permission check failure', { owner, repo, error: error.message });\n      return false;\n    }\n  }\n\n  // Alias method for backward compatibility - delegates to checkRepositoryWritePermissions\n  async checkRepositoryPermissions(owner, repo) {\n    return this.checkRepositoryWritePermissions(owner, repo);\n  }\n\n  // Check if the token has permission to create comments on issues/PRs\n  async checkCommentPermissions(owner, repo) {\n    if (!this.isAuth()) {\n      this.logger.warn('Cannot check comment permissions - not authenticated', { owner, repo });\n      return false;\n    }\n\n    const startTime = Date.now();\n    this.logger.debug('Checking comment permissions for repository', { owner, repo });\n\n    try {\n      // Try to access the issues endpoint, which is required for commenting on PRs\n      // This is a safe read operation that will fail gracefully if no permission\n      this.logger.apiCall('GET', `/repos/${owner}/${repo}/issues`, { per_page: 1 });\n      \n      await this.octokit.rest.issues.listForRepo({\n        owner,\n        repo,\n        per_page: 1,\n        state: 'all'\n      });\n      \n      const duration = Date.now() - startTime;\n      this.logger.apiResponse('GET', `/repos/${owner}/${repo}/issues`, 200, duration);\n      \n      // If we can read issues, we likely can comment on them\n      // But this is just a heuristic - the actual test is when we try to comment\n      this.logger.debug('Issues endpoint accessible - comment permissions likely available', { owner, repo });\n      return true;\n    } catch (error) {\n      const duration = Date.now() - startTime;\n      this.logger.apiError('GET', `/repos/${owner}/${repo}/issues`, error);\n      this.logger.performance('Comment permission check (failed)', duration);\n      \n      // Check if it's a permissions error\n      if (error.status === 403 || error.status === 401) {\n        this.logger.warn('Token does not have permission to access issues/comments', { \n          owner, \n          repo, \n          error: error.message,\n          status: error.status \n        });\n        return false;\n      }\n      \n      // For other errors, assume we have permission and let the actual comment attempt handle it\n      this.logger.warn('Could not determine comment permissions, assuming available', { \n        owner, \n        repo, \n        error: error.message \n      });\n      return true;\n    }\n  }\n\n  // Check if authenticated\n  isAuth() {\n    return this.isAuthenticated && this.octokit !== null;\n  }\n\n  // Get current user data\n  async getCurrentUser() {\n    if (!this.isAuth()) {\n      throw new Error('Not authenticated with GitHub');\n    }\n\n    try {\n      const { data } = await this.octokit.rest.users.getAuthenticated();\n      return data;\n    } catch (error) {\n      console.error('Failed to fetch user data:', error);\n      throw error;\n    }\n  }\n\n  // Get user's organizations\n  async getUserOrganizations() {\n    if (!this.isAuth()) {\n      throw new Error('Not authenticated with GitHub');\n    }\n\n    try {\n      const { data } = await this.octokit.rest.orgs.listForAuthenticatedUser();\n      return data;\n    } catch (error) {\n      console.error('Failed to fetch organizations:', error);\n      throw error;\n    }\n  }\n\n  // Get specific organization data (public data, no auth required)\n  async getOrganization(orgLogin) {\n    try {\n      // Create a temporary Octokit instance for public API calls if we don't have one\n      const octokit = this.octokit || new Octokit();\n      \n      const { data } = await octokit.rest.orgs.get({\n        org: orgLogin\n      });\n      return data;\n    } catch (error) {\n      console.error(`Failed to fetch organization ${orgLogin}:`, error);\n      throw error;\n    }\n  }\n\n  // Get specific user data (public data, no auth required)\n  async getUser(username) {\n    try {\n      // Create a temporary Octokit instance for public API calls if we don't have one\n      const octokit = this.octokit || new Octokit();\n      \n      const { data } = await octokit.rest.users.getByUsername({\n        username\n      });\n      return data;\n    } catch (error) {\n      console.error(`Failed to fetch user ${username}:`, error);\n      throw error;\n    }\n  }\n\n  // Get public repositories for a user or organization (no auth required)\n  async getPublicRepositories(owner, type = 'user') {\n    try {\n      // Create a temporary Octokit instance for public API calls if we don't have one\n      const octokit = this.octokit || new Octokit();\n      \n      let repositories = [];\n      let page = 1;\n      let hasMorePages = true;\n\n      // Fetch all public repositories using pagination\n      while (hasMorePages) {\n        let response;\n        if (type === 'user') {\n          response = await octokit.rest.repos.listForUser({\n            username: owner,\n            sort: 'updated',\n            per_page: 100,\n            page: page,\n          });\n        } else {\n          response = await octokit.rest.repos.listForOrg({\n            org: owner,\n            sort: 'updated',\n            per_page: 100,\n            page: page,\n          });\n        }\n\n        repositories = repositories.concat(response.data);\n        \n        // Check if there are more pages\n        hasMorePages = response.data.length === 100;\n        page++;\n      }\n\n      return repositories;\n    } catch (error) {\n      console.error(`Failed to fetch public repositories for ${owner}:`, error);\n      throw error;\n    }\n  }\n\n  // Get WHO organization data with fresh avatar\n  async getWHOOrganization() {\n    try {\n      const whoData = await this.getOrganization('WorldHealthOrganization');\n      return {\n        id: whoData.id,\n        login: whoData.login,\n        display_name: whoData.name || 'World Health Organization',\n        description: whoData.description || 'The World Health Organization is a specialized agency of the United Nations responsible for international public health.',\n        avatar_url: whoData.avatar_url,\n        html_url: whoData.html_url,\n        type: 'Organization',\n        permissions: {\n          can_create_repositories: true,\n          can_create_private_repositories: true\n        },\n        plan: {\n          name: 'Organization',\n          private_repos: 'unlimited'\n        },\n        isWHO: true\n      };\n    } catch (error) {\n      console.warn('Could not fetch WHO organization data from API, using fallback:', error);\n      // Return hardcoded fallback data\n      return {\n        id: 'who-organization',\n        login: 'WorldHealthOrganization',\n        display_name: 'World Health Organization',\n        description: 'The World Health Organization is a specialized agency of the United Nations responsible for international public health.',\n        avatar_url: 'https://avatars.githubusercontent.com/u/12261302?s=200&v=4',\n        html_url: 'https://github.com/WorldHealthOrganization',\n        type: 'Organization',\n        permissions: {\n          can_create_repositories: true,\n          can_create_private_repositories: true\n        },\n        plan: {\n          name: 'Organization',\n          private_repos: 'unlimited'\n        },\n        isWHO: true\n      };\n    }\n  }\n\n  // Get repositories for a user or organization (now filters by SMART Guidelines compatibility)\n  async getRepositories(owner, type = 'user', isDemo = false) {\n    // Handle demo mode - return demo repositories without requiring authentication\n    if (isDemo || owner === 'demo-user') {\n      return this.getDemoRepositories(owner);\n    }\n    \n    // Use the new SMART guidelines filtering method\n    return this.getSmartGuidelinesRepositories(owner, type);\n  }\n\n  // Get demo repositories for demo mode (no authentication required)\n  getDemoRepositories(owner) {\n    const demoRepos = [\n      {\n        id: 'demo-smart-anc',\n        name: 'smart-anc',\n        full_name: `${owner}/smart-anc`,\n        description: 'Demo SMART Guidelines Digital Adaptation Kit for Antenatal Care',\n        private: false,\n        owner: {\n          login: owner,\n          id: 'demo-owner',\n          avatar_url: `https://github.com/${owner}.png`,\n          type: 'User'\n        },\n        html_url: `https://github.com/${owner}/smart-anc`,\n        clone_url: `https://github.com/${owner}/smart-anc.git`,\n        language: 'FSH',\n        stargazers_count: 15,\n        forks_count: 3,\n        open_issues_count: 2,\n        topics: ['who', 'smart-guidelines', 'dak', 'antenatal-care', 'health'],\n        created_at: '2023-01-15T10:00:00Z',\n        updated_at: '2024-12-15T14:30:00Z',\n        pushed_at: '2024-12-15T14:30:00Z',\n        default_branch: 'main',\n        smart_guidelines_compatible: true,\n        isDemo: true\n      },\n      {\n        id: 'demo-smart-tb',\n        name: 'smart-tb',\n        full_name: `${owner}/smart-tb`,\n        description: 'Demo SMART Guidelines Digital Adaptation Kit for Tuberculosis Care',\n        private: false,\n        owner: {\n          login: owner,\n          id: 'demo-owner',\n          avatar_url: `https://github.com/${owner}.png`,\n          type: 'User'\n        },\n        html_url: `https://github.com/${owner}/smart-tb`,\n        clone_url: `https://github.com/${owner}/smart-tb.git`,\n        language: 'FSH',\n        stargazers_count: 8,\n        forks_count: 1,\n        open_issues_count: 0,\n        topics: ['who', 'smart-guidelines', 'dak', 'tuberculosis', 'health'],\n        created_at: '2023-03-20T15:00:00Z',\n        updated_at: '2024-11-30T09:15:00Z',\n        pushed_at: '2024-11-30T09:15:00Z',\n        default_branch: 'main',\n        smart_guidelines_compatible: true,\n        isDemo: true\n      },\n      {\n        id: 'demo-smart-ips-pilgrimage',\n        name: 'smart-ips-pilgrimage',\n        full_name: `${owner}/smart-ips-pilgrimage`,\n        description: 'Demo SMART Guidelines International Patient Summary for Pilgrimage',\n        private: false,\n        owner: {\n          login: owner,\n          id: 'demo-owner',\n          avatar_url: `https://github.com/${owner}.png`,\n          type: 'User'\n        },\n        html_url: `https://github.com/${owner}/smart-ips-pilgrimage`,\n        clone_url: `https://github.com/${owner}/smart-ips-pilgrimage.git`,\n        language: 'FSH',\n        stargazers_count: 12,\n        forks_count: 2,\n        open_issues_count: 1,\n        topics: ['who', 'smart-guidelines', 'dak', 'ips', 'pilgrimage', 'health'],\n        created_at: '2023-06-10T12:00:00Z',\n        updated_at: '2024-12-01T16:45:00Z',\n        pushed_at: '2024-12-01T16:45:00Z',\n        default_branch: 'main',\n        smart_guidelines_compatible: true,\n        isDemo: true\n      }\n    ];\n\n    return Promise.resolve(demoRepos);\n  }\n\n  // Check if a repository has sushi-config.yaml with smart.who.int.base dependency\n  async checkSmartGuidelinesCompatibility(owner, repo, retryCount = 2) {\n    // Check cache first to prevent redundant downloads\n    const cachedResult = repositoryCompatibilityCache.get(owner, repo);\n    if (cachedResult !== null) {\n      return cachedResult;\n    }\n\n    try {\n      // Use authenticated or public API depending on authentication state\n      const octokit = this.octokit || new Octokit();\n      \n      // Try to get sushi-config.yaml from the repository root\n      const { data } = await octokit.rest.repos.getContent({\n        owner,\n        repo,\n        path: 'sushi-config.yaml',\n      });\n\n      if (data.type === 'file' && data.content) {\n        // Decode base64 content (browser-compatible)\n        const content = decodeURIComponent(escape(atob(data.content)));\n        \n        // Check if the content contains smart.who.int.base in dependencies\n        const isCompatible = content.includes('smart.who.int.base');\n        \n        // Cache the result\n        repositoryCompatibilityCache.set(owner, repo, isCompatible);\n        return isCompatible;\n      }\n      \n      // Cache negative result\n      repositoryCompatibilityCache.set(owner, repo, false);\n      return false;\n    } catch (error) {\n      // If it's a 404 (file not found), retry once more in case of temporary issues\n      if (error.status === 404 && retryCount > 0) {\n        console.warn(`File not found for ${owner}/${repo}, retrying... (${retryCount} attempts left)`);\n        // Use shorter delay in test environment\n        const delay = process.env.NODE_ENV === 'test' ? 10 : 1000;\n        await new Promise(resolve => setTimeout(resolve, delay));\n        return this.checkSmartGuidelinesCompatibility(owner, repo, retryCount - 1);\n      }\n      \n      // For any error (including rate limiting, network errors, or file not found after retries),\n      // strictly return false - no fallback logic\n      console.warn(`Failed to check ${owner}/${repo} for sushi-config.yaml with smart.who.int.base dependency:`, error.message);\n      \n      // Cache negative result\n      repositoryCompatibilityCache.set(owner, repo, false);\n      return false;\n    }\n  }\n\n\n\n  // Get repositories that are SMART guidelines compatible\n  async getSmartGuidelinesRepositories(owner, type = 'user') {\n    try {\n      let repositories = [];\n      \n      if (this.isAuth()) {\n        // Use authenticated API for full access\n        let page = 1;\n        let hasMorePages = true;\n\n        // Fetch all repositories using pagination\n        while (hasMorePages) {\n          let response;\n          if (type === 'user') {\n            response = await this.octokit.rest.repos.listForUser({\n              username: owner,\n              sort: 'updated',\n              per_page: 100,\n              page: page,\n            });\n          } else {\n            response = await this.octokit.rest.repos.listForOrg({\n              org: owner,\n              sort: 'updated',\n              per_page: 100,\n              page: page,\n            });\n          }\n\n          repositories = repositories.concat(response.data);\n          \n          // Check if there are more pages\n          hasMorePages = response.data.length === 100;\n          page++;\n        }\n      } else {\n        // Use public API for unauthenticated access (only public repositories)\n        repositories = await this.getPublicRepositories(owner, type);\n      }\n\n      // Check each repository for SMART guidelines compatibility\n      const smartGuidelinesRepos = [];\n      for (const repo of repositories) {\n        const isCompatible = await this.checkSmartGuidelinesCompatibility(repo.owner.login, repo.name);\n        if (isCompatible) {\n          smartGuidelinesRepos.push({\n            ...repo,\n            smart_guidelines_compatible: true\n          });\n        }\n      }\n\n      return smartGuidelinesRepos;\n    } catch (error) {\n      console.error('Failed to fetch SMART guidelines repositories:', error);\n      throw error;\n    }\n  }\n\n  // Get repositories with progressive scanning (for real-time updates)\n  async getSmartGuidelinesRepositoriesProgressive(owner, type = 'user', onRepositoryFound = null, onProgress = null) {\n    if (!this.isAuth()) {\n      throw new Error('Not authenticated with GitHub');\n    }\n\n    try {\n      let repositories = [];\n      let page = 1;\n      let hasMorePages = true;\n\n      // Fetch all repositories using pagination\n      while (hasMorePages) {\n        let response;\n        if (type === 'user') {\n          response = await this.octokit.rest.repos.listForUser({\n            username: owner,\n            sort: 'updated',\n            per_page: 100,\n            page: page,\n          });\n        } else {\n          response = await this.octokit.rest.repos.listForOrg({\n            org: owner,\n            sort: 'updated',\n            per_page: 100,\n            page: page,\n          });\n        }\n\n        repositories = repositories.concat(response.data);\n        \n        // Check if there are more pages\n        hasMorePages = response.data.length === 100;\n        page++;\n      }\n\n      // Handle case where user has no repositories\n      if (repositories.length === 0) {\n        console.log(' No repositories found for user, completing scan immediately');\n        // Call progress callback to indicate completion\n        if (onProgress) {\n          onProgress({\n            current: 0,\n            total: 0,\n            currentRepo: 'none',\n            progress: 100,\n            completed: true\n          });\n        }\n        return [];\n      }\n\n      // Process repositories concurrently with rate limiting and enhanced display\n      const processor = async (repo, index) => {\n        // Add a small delay to make scanning progress visible (similar to demo mode)\n        await new Promise(resolve => setTimeout(resolve, 100 + Math.random() * 200));\n        \n        const isCompatible = await this.checkSmartGuidelinesCompatibility(repo.owner.login, repo.name);\n        \n        if (isCompatible) {\n          const smartRepo = {\n            ...repo,\n            smart_guidelines_compatible: true\n          };\n          \n          // Notify that a repository was found\n          if (onRepositoryFound) {\n            onRepositoryFound(smartRepo);\n          }\n          \n          return smartRepo;\n        }\n        \n        return null;\n      };\n\n      // Use concurrent processing with max 5 parallel requests\n      const results = await processConcurrently(repositories, processor, {\n        concurrency: 5,\n        onProgress: (completed, total, repo, result) => {\n          // Progress callback for completed items\n          if (onProgress) {\n            onProgress({\n              current: completed,\n              total: total,\n              currentRepo: repo.name,\n              progress: Math.round((completed / total) * 100),\n              completed: true\n            });\n          }\n        },\n        onItemStart: (repo, index) => {\n          // Progress callback for started items\n          if (onProgress) {\n            onProgress({\n              current: index + 1,\n              total: repositories.length,\n              currentRepo: repo.name,\n              progress: Math.round(((index + 1) / repositories.length) * 100),\n              completed: false,\n              started: true\n            });\n          }\n        }\n      });\n\n      // Filter out null results and collect smart repositories\n      const validResults = results.filter(result => result !== null && !result.error);\n      \n      return validResults;\n    } catch (error) {\n      console.error('Failed to fetch SMART guidelines repositories:', error);\n      throw error;\n    }\n  }\n\n  // Get a specific repository\n  async getRepository(owner, repo) {\n    try {\n      // Use authenticated octokit if available, otherwise create a public instance for public repos\n      const octokit = this.isAuth() ? this.octokit : new Octokit();\n      \n      const { data } = await octokit.rest.repos.get({\n        owner,\n        repo,\n      });\n      return data;\n    } catch (error) {\n      console.error('Failed to fetch repository:', error);\n      throw error;\n    }  \n  }\n\n  // Get repository branches\n  async getBranches(owner, repo) {\n    try {\n      console.log(`githubService.getBranches: Fetching branches for ${owner}/${repo}`);\n      console.log('githubService.getBranches: Authentication status:', this.isAuth());\n      \n      // Use authenticated octokit if available, otherwise create a public instance for public repos\n      const octokit = this.isAuth() ? this.octokit : new Octokit();\n      console.log('githubService.getBranches: Using', this.isAuth() ? 'authenticated' : 'public', 'octokit instance');\n      \n      const { data } = await octokit.rest.repos.listBranches({\n        owner,\n        repo,\n        per_page: 100\n      });\n      \n      console.log(`githubService.getBranches: Successfully fetched ${data.length} branches`);\n      return data;\n    } catch (error) {\n      console.error('githubService.getBranches: Failed to fetch branches:', error);\n      console.error('githubService.getBranches: Error details:', {\n        status: error.status,\n        message: error.message,\n        owner,\n        repo\n      });\n      throw error;\n    }\n  }\n\n  // Create a new branch\n  async createBranch(owner, repo, branchName, fromBranch = 'main') {\n    if (!this.isAuth()) {\n      throw new Error('Not authenticated with GitHub');\n    }\n\n    try {\n      // First get the SHA of the source branch\n      const { data: refData } = await this.octokit.rest.git.getRef({\n        owner,\n        repo,\n        ref: `heads/${fromBranch}`\n      });\n\n      // Create the new branch\n      const { data } = await this.octokit.rest.git.createRef({\n        owner,\n        repo,\n        ref: `refs/heads/${branchName}`,\n        sha: refData.object.sha\n      });\n\n      return data;\n    } catch (error) {\n      console.error('Failed to create branch:', error);\n      throw error;\n    }\n  }\n\n  // Get a specific branch\n  async getBranch(owner, repo, branch) {\n    try {\n      // Use authenticated octokit if available, otherwise create a public instance for public repos\n      const octokit = this.isAuth() ? this.octokit : new Octokit();\n      \n      const { data } = await octokit.rest.repos.getBranch({\n        owner,\n        repo,\n        branch\n      });\n      return data;\n    } catch (error) {\n      console.error('Failed to fetch branch:', error);\n      throw error;\n    }\n  }\n\n  // GitHub Actions API methods\n  \n  // Get workflows for a repository (using GitHub API to include workflow IDs)\n  async getWorkflows(owner, repo) {\n    if (!this.isAuth()) {\n      throw new Error('Not authenticated with GitHub');\n    }\n\n    try {\n      // Use GitHub Actions API to get workflows with their IDs\n      const { data } = await this.octokit.rest.actions.listRepoWorkflows({\n        owner,\n        repo\n      });\n\n      return data.workflows.map(workflow => ({\n        id: workflow.id, // This is the crucial missing piece!\n        name: workflow.name,\n        filename: workflow.path.split('/').pop(), // Extract filename from path\n        path: workflow.path,\n        state: workflow.state,\n        created_at: workflow.created_at,\n        updated_at: workflow.updated_at,\n        url: workflow.html_url,\n        triggers: ['unknown'], // GitHub API doesn't provide trigger info directly\n        lastModified: workflow.updated_at\n      }));\n    } catch (error) {\n      if (error.status === 404) {\n        // No workflows or repository not found\n        return [];\n      }\n      console.error('Failed to fetch workflows:', error);\n      throw error;\n    }\n  }\n\n  // Get workflow runs for a repository\n  async getWorkflowRuns(owner, repo, options = {}) {\n    if (!this.isAuth()) {\n      throw new Error('Not authenticated with GitHub');\n    }\n\n    try {\n      const params = {\n        owner,\n        repo,\n        per_page: options.per_page || 10,\n        page: options.page || 1\n      };\n\n      if (options.branch) {\n        params.branch = options.branch;\n      }\n\n      if (options.workflow_id) {\n        params.workflow_id = options.workflow_id;\n      }\n\n      const { data } = await this.octokit.rest.actions.listWorkflowRunsForRepo(params);\n      return data;\n    } catch (error) {\n      console.error('Failed to fetch workflow runs:', error);\n      throw error;\n    }\n  }\n\n  // Get workflow runs for a specific workflow\n  async getWorkflowRunsForWorkflow(owner, repo, workflow_id, options = {}) {\n    if (!this.isAuth()) {\n      throw new Error('Not authenticated with GitHub');\n    }\n\n    try {\n      const params = {\n        owner,\n        repo,\n        workflow_id,\n        per_page: options.per_page || 10,\n        page: options.page || 1\n      };\n\n      if (options.branch) {\n        params.branch = options.branch;\n      }\n\n      const { data } = await this.octokit.rest.actions.listWorkflowRuns(params);\n      return data;\n    } catch (error) {\n      console.error('Failed to fetch workflow runs for workflow:', error);\n      throw error;\n    }\n  }\n\n  // Trigger a workflow run\n  async triggerWorkflow(owner, repo, workflow_id, ref = 'main', inputs = {}) {\n    if (!this.isAuth()) {\n      throw new Error('Not authenticated with GitHub');\n    }\n\n    try {\n      const { data } = await this.octokit.rest.actions.createWorkflowDispatch({\n        owner,\n        repo,\n        workflow_id,\n        ref,\n        inputs\n      });\n      return data;\n    } catch (error) {\n      console.error('Failed to trigger workflow:', error);\n      throw error;\n    }\n  }\n\n  // Re-run a workflow\n  async rerunWorkflow(owner, repo, run_id) {\n    if (!this.isAuth()) {\n      throw new Error('Not authenticated with GitHub');\n    }\n\n    try {\n      const { data } = await this.octokit.rest.actions.reRunWorkflow({\n        owner,\n        repo,\n        run_id\n      });\n      return data;\n    } catch (error) {\n      console.error('Failed to re-run workflow:', error);\n      throw error;\n    }\n  }\n\n  // Get workflow run logs\n  async getWorkflowRunLogs(owner, repo, run_id) {\n    if (!this.isAuth()) {\n      throw new Error('Not authenticated with GitHub');\n    }\n\n    try {\n      const { data } = await this.octokit.rest.actions.downloadWorkflowRunLogs({\n        owner,\n        repo,\n        run_id\n      });\n      return data;\n    } catch (error) {\n      console.error('Failed to get workflow run logs:', error);\n      throw error;\n    }\n  }\n\n  // Approve a workflow run\n  async approveWorkflowRun(owner, repo, run_id) {\n    if (!this.isAuth()) {\n      throw new Error('Not authenticated with GitHub');\n    }\n\n    try {\n      const { data } = await this.octokit.rest.actions.approveWorkflowRun({\n        owner,\n        repo,\n        run_id\n      });\n      return data;\n    } catch (error) {\n      console.error('Failed to approve workflow run:', error);\n      throw error;\n    }\n  }\n\n  // Get commit comparison (diff)\n  async getCommitDiff(owner, repo, base, head) {\n    if (!this.isAuth()) {\n      throw new Error('Not authenticated with GitHub');\n    }\n\n    try {\n      const { data } = await this.octokit.rest.repos.compareCommits({\n        owner,\n        repo,\n        base,\n        head\n      });\n      return data;\n    } catch (error) {\n      console.error('Failed to get commit diff:', error);\n      throw error;\n    }\n  }\n\n  // Get commit details\n  async getCommit(owner, repo, sha) {\n    if (!this.isAuth()) {\n      throw new Error('Not authenticated with GitHub');\n    }\n\n    try {\n      const { data } = await this.octokit.rest.repos.getCommit({\n        owner,\n        repo,\n        ref: sha\n      });\n      return data;\n    } catch (error) {\n      console.error('Failed to get commit details:', error);\n      throw error;\n    }\n  }\n\n  // Releases API methods\n\n  // Get releases for a repository\n  async getReleases(owner, repo, options = {}) {\n    if (!this.isAuth()) {\n      throw new Error('Not authenticated with GitHub');\n    }\n\n    try {\n      const { data } = await this.octokit.rest.repos.listReleases({\n        owner,\n        repo,\n        per_page: options.per_page || 10,\n        page: options.page || 1\n      });\n      return data;\n    } catch (error) {\n      console.error('Failed to fetch releases:', error);\n      throw error;\n    }\n  }\n\n  // Get latest release\n  async getLatestRelease(owner, repo) {\n    if (!this.isAuth()) {\n      throw new Error('Not authenticated with GitHub');\n    }\n\n    try {\n      const { data } = await this.octokit.rest.repos.getLatestRelease({\n        owner,\n        repo\n      });\n      return data;\n    } catch (error) {\n      console.error('Failed to fetch latest release:', error);\n      throw error;\n    }\n  }\n\n  // Recursively fetch BPMN files from a directory and its subdirectories\n  async getBpmnFilesRecursive(owner, repo, path, ref = 'main', allFiles = []) {\n    try {\n      console.log(` githubService.getBpmnFilesRecursive: Searching ${owner}/${repo}/${path} (ref: ${ref})`);\n      // Use authenticated octokit if available, otherwise create a public instance\n      const octokit = this.isAuth() ? this.octokit : new Octokit();\n      console.log(` githubService.getBpmnFilesRecursive: Using ${this.isAuth() ? 'authenticated' : 'public'} octokit`);\n      \n      const { data } = await octokit.rest.repos.getContent({\n        owner,\n        repo,\n        path,\n        ref\n      });\n\n      console.log(` githubService.getBpmnFilesRecursive: Received data type: ${Array.isArray(data) ? 'array' : 'single file'}, length: ${Array.isArray(data) ? data.length : 1}`);\n\n      // Handle single file response\n      if (!Array.isArray(data)) {\n        if (data.name.endsWith('.bpmn')) {\n          console.log(` githubService.getBpmnFilesRecursive: Found single BPMN file: ${data.name}`);\n          allFiles.push(data);\n        }\n        return allFiles;\n      }\n\n      // Handle directory response\n      for (const item of data) {\n        if (item.type === 'file' && item.name.endsWith('.bpmn')) {\n          console.log(` githubService.getBpmnFilesRecursive: Found BPMN file: ${item.name}`);\n          allFiles.push(item);\n        } else if (item.type === 'dir') {\n          console.log(` githubService.getBpmnFilesRecursive: Found subdirectory: ${item.name}, recursing...`);\n          // Recursively search subdirectories\n          await this.getBpmnFilesRecursive(owner, repo, item.path, ref, allFiles);\n        }\n      }\n\n      console.log(` githubService.getBpmnFilesRecursive: Completed search of ${path}, found ${allFiles.length} total files so far`);\n      return allFiles;\n    } catch (error) {\n      console.log(` githubService.getBpmnFilesRecursive: Error searching ${path}:`, error.status, error.message);\n      // If directory doesn't exist, return empty array (not an error)\n      if (error.status === 404) {\n        return allFiles;\n      }\n      throw error;\n    }\n  }\n\n  // Get all BPMN files from a repository's business process directories\n  async getBpmnFiles(owner, repo, ref = 'main') {\n    console.log(` githubService.getBpmnFiles: Starting search for ${owner}/${repo} (ref: ${ref})`);\n    const allBpmnFiles = [];\n    \n    // Search for BPMN files in the specified business process directories\n    const possiblePaths = [\n      'input/business-processes',\n      'input/business-process'\n    ];\n\n    for (const path of possiblePaths) {\n      try {\n        console.log(` githubService.getBpmnFiles: Searching in directory: ${path}`);\n        const files = await this.getBpmnFilesRecursive(owner, repo, path, ref);\n        console.log(` githubService.getBpmnFiles: Found ${files.length} BPMN files in ${path}`);\n        allBpmnFiles.push(...files);\n      } catch (error) {\n        // Only log warnings for unexpected errors (not 404s which are expected when directories don't exist)\n        if (error.status !== 404) {\n          console.warn(` Could not fetch BPMN files from ${path}:`, error.message);\n        } else {\n          console.log(` githubService.getBpmnFiles: Directory ${path} not found (404) - this is expected if the directory doesn't exist`);\n        }\n        // Continue trying other paths\n      }\n    }\n\n    // Remove duplicates based on path (in case both directories exist and have overlapping files)\n    const uniqueFiles = allBpmnFiles.filter((file, index, self) => \n      index === self.findIndex(f => f.path === file.path)\n    );\n\n    console.log(` githubService.getBpmnFiles: Final result - ${uniqueFiles.length} unique BPMN files found`);\n    console.log(` githubService.getBpmnFiles: File list:`, uniqueFiles.map(f => f.name));\n    return uniqueFiles;\n  }\n\n  // Get file content from GitHub repository with timeout handling\n  async getFileContent(owner, repo, path, ref = 'main') {\n    const timeoutMs = 15000; // 15 second timeout\n    \n    try {\n      console.log(` githubService.getFileContent: Starting request for ${owner}/${repo}/${path} (ref: ${ref})`);\n      console.log(' githubService.getFileContent: Authentication status:', this.isAuth());\n      console.log(' githubService.getFileContent: Request parameters:', { owner, repo, path, ref });\n      \n      // Use authenticated octokit if available, otherwise create a public instance for public repos\n      const octokit = this.isAuth() ? this.octokit : new Octokit();\n      console.log(' githubService.getFileContent: Using', this.isAuth() ? 'authenticated' : 'public', 'octokit instance');\n      \n      // Create a promise that rejects after timeout\n      const timeoutPromise = new Promise((_, reject) => {\n        console.log(` githubService.getFileContent: Setting up ${timeoutMs}ms timeout`);\n        setTimeout(() => {\n          console.error(` githubService.getFileContent: Request timed out after ${timeoutMs}ms`);\n          reject(new Error(`Request timeout after ${timeoutMs}ms`));\n        }, timeoutMs);\n      });\n      \n      // Race the GitHub API call against the timeout\n      console.log(' githubService.getFileContent: Creating GitHub API promise...');\n      const apiPromise = octokit.rest.repos.getContent({\n        owner,\n        repo,\n        path,\n        ref\n      });\n      \n      console.log(' githubService.getFileContent: API request initiated, waiting for response...');\n      const startTime = Date.now();\n      \n      const { data } = await Promise.race([apiPromise, timeoutPromise]);\n      const responseTime = Date.now() - startTime;\n      \n      console.log(` githubService.getFileContent: API response received in ${responseTime}ms`);\n      console.log(' githubService.getFileContent: Response data type:', data.type);\n      console.log(' githubService.getFileContent: Response details:', {\n        type: data.type,\n        name: data.name,\n        size: data.size,\n        encoding: data.encoding,\n        hasContent: !!data.content\n      });\n\n      // Handle file content\n      if (data.type === 'file' && data.content) {\n        // Decode base64 content\n        console.log(' githubService.getFileContent: Decoding base64 content...');\n        console.log(' githubService.getFileContent: Base64 content length:', data.content.length);\n        \n        const content = decodeURIComponent(escape(atob(data.content)));\n        console.log(` githubService.getFileContent: Successfully fetched and decoded file content`);\n        console.log(' githubService.getFileContent: Final content length:', content.length, 'characters');\n        console.log(' githubService.getFileContent: Content preview (first 200 chars):', content.substring(0, 200));\n        \n        return content;\n      } else {\n        console.error(' githubService.getFileContent: Invalid response - not a file or no content');\n        console.error(' githubService.getFileContent: Full response data:', JSON.stringify(data, null, 2));\n        throw new Error('File not found or is not a file');\n      }\n    } catch (error) {\n      console.error(` githubService.getFileContent: Failed to fetch file content from ${owner}/${repo}/${path}:`, error);\n      console.error(' githubService.getFileContent: Error analysis:', {\n        type: typeof error,\n        status: error.status,\n        message: error.message,\n        name: error.name,\n        stack: error.stack?.substring(0, 500) + '...'\n      });\n      \n      // Provide more specific error messages\n      if (error.message.includes('timeout')) {\n        console.error(' githubService.getFileContent: Timeout error detected');\n        throw new Error(`GitHub API request timed out after ${timeoutMs / 1000} seconds. Please try again.`);\n      } else if (error.status === 403) {\n        console.error(' githubService.getFileContent: 403 Forbidden error detected');\n        throw new Error('Access denied. This repository may be private or you may have hit rate limits.');\n      } else if (error.status === 404) {\n        console.error(' githubService.getFileContent: 404 Not Found error detected');\n        throw new Error('File not found in the repository.');\n      } else if (error.message.includes('rate limit')) {\n        console.error(' githubService.getFileContent: Rate limit error detected');\n        throw new Error('GitHub API rate limit exceeded. Please try again later.');\n      } else if (error.message.includes('Network Error') || error.message.includes('Failed to fetch')) {\n        console.error(' githubService.getFileContent: Network error detected');\n        throw new Error('Network error occurred. Please check your internet connection and try again.');\n      }\n      \n      console.error(' githubService.getFileContent: Unknown error type, re-throwing original error');\n      throw error;\n    }\n  }\n\n  // Create a commit with multiple files\n  async createCommit(owner, repo, branch, message, files) {\n    if (!this.isAuth()) {\n      throw new Error('Not authenticated with GitHub');\n    }\n\n    try {\n      // Get the latest commit SHA\n      const { data: refData } = await this.octokit.rest.git.getRef({\n        owner,\n        repo,\n        ref: `heads/${branch}`\n      });\n      const latestCommitSha = refData.object.sha;\n\n      // Get the tree SHA from the latest commit\n      const { data: commitData } = await this.octokit.rest.git.getCommit({\n        owner,\n        repo,\n        commit_sha: latestCommitSha\n      });\n      const baseTreeSha = commitData.tree.sha;\n\n      // Create blobs for all files\n      const blobs = await Promise.all(\n        files.map(async (file) => {\n          const { data: blobData } = await this.octokit.rest.git.createBlob({\n            owner,\n            repo,\n            content: file.content,\n            encoding: 'utf-8'\n          });\n          return {\n            path: file.path,\n            mode: '100644',\n            type: 'blob',\n            sha: blobData.sha\n          };\n        })\n      );\n\n      // Create a new tree with the blobs\n      const { data: treeData } = await this.octokit.rest.git.createTree({\n        owner,\n        repo,\n        base_tree: baseTreeSha,\n        tree: blobs\n      });\n\n      // Create the commit\n      const { data: newCommitData } = await this.octokit.rest.git.createCommit({\n        owner,\n        repo,\n        message,\n        tree: treeData.sha,\n        parents: [latestCommitSha]\n      });\n\n      // Update the branch reference\n      await this.octokit.rest.git.updateRef({\n        owner,\n        repo,\n        ref: `heads/${branch}`,\n        sha: newCommitData.sha\n      });\n\n      return {\n        sha: newCommitData.sha,\n        html_url: `https://github.com/${owner}/${repo}/commit/${newCommitData.sha}`,\n        message: newCommitData.message,\n        author: newCommitData.author,\n        committer: newCommitData.committer\n      };\n    } catch (error) {\n      console.error('Failed to create commit:', error);\n      throw error;\n    }\n  }\n\n  // Get recent commits for a repository branch\n  async getRecentCommits(owner, repo, branch = 'main', per_page = 5) {\n    if (!this.isAuth()) {\n      throw new Error('Not authenticated with GitHub');\n    }\n\n    const startTime = Date.now();\n    this.logger.apiCall('GET', `/repos/${owner}/${repo}/commits`, { sha: branch, per_page });\n\n    try {\n      const response = await this.octokit.rest.repos.listCommits({\n        owner,\n        repo,\n        sha: branch,\n        per_page\n      });\n\n      this.logger.apiResponse('GET', `/repos/${owner}/${repo}/commits`, response.status, Date.now() - startTime);\n      \n      return response.data.map(commit => ({\n        sha: commit.sha,\n        message: commit.commit.message,\n        author: {\n          name: commit.commit.author.name,\n          email: commit.commit.author.email,\n          date: commit.commit.author.date\n        },\n        committer: {\n          name: commit.commit.committer.name,\n          email: commit.commit.committer.email,\n          date: commit.commit.committer.date\n        },\n        html_url: commit.html_url,\n        stats: commit.stats\n      }));\n    } catch (error) {\n      this.logger.apiResponse('GET', `/repos/${owner}/${repo}/commits`, error.status || 'error', Date.now() - startTime);\n      console.error('Failed to fetch recent commits:', error);\n      throw error;\n    }\n  }\n\n  // Get open pull requests count\n  async getOpenPullRequestsCount(owner, repo) {\n    if (!this.isAuth()) {\n      throw new Error('Not authenticated with GitHub');\n    }\n\n    const startTime = Date.now();\n    this.logger.apiCall('GET', `/repos/${owner}/${repo}/pulls`, { state: 'open', per_page: 1 });\n\n    try {\n      const response = await this.octokit.rest.pulls.list({\n        owner,\n        repo,\n        state: 'open',\n        per_page: 1\n      });\n\n      this.logger.apiResponse('GET', `/repos/${owner}/${repo}/pulls`, response.status, Date.now() - startTime);\n      \n      // GitHub includes the total count in the response headers\n      const linkHeader = response.headers.link;\n      if (linkHeader && linkHeader.includes('rel=\"last\"')) {\n        const lastPageMatch = linkHeader.match(/page=(\\d+)>; rel=\"last\"/);\n        if (lastPageMatch) {\n          return parseInt(lastPageMatch[1], 10);\n        }\n      }\n      \n      // Fallback: use the length of returned items (may not be accurate for large counts)\n      return response.data.length;\n    } catch (error) {\n      this.logger.apiResponse('GET', `/repos/${owner}/${repo}/pulls`, error.status || 'error', Date.now() - startTime);\n      console.error('Failed to fetch pull requests count:', error);\n      throw error;\n    }\n  }\n\n  // Get pull request for a specific branch (returns first PR only for backward compatibility)\n  async getPullRequestForBranch(owner, repo, branchName) {\n    const prs = await this.getPullRequestsForBranch(owner, repo, branchName);\n    return prs && prs.length > 0 ? prs[0] : null;\n  }\n\n  // Get all pull requests for a specific branch\n  async getPullRequestsForBranch(owner, repo, branchName) {\n    // Use authenticated octokit if available, otherwise create a public instance for public repos\n    const octokit = this.isAuth() ? this.octokit : new Octokit();\n\n    const startTime = Date.now();\n    this.logger.apiCall('GET', `/repos/${owner}/${repo}/pulls`, { state: 'open', head: `${owner}:${branchName}` });\n\n    try {\n      const response = await octokit.rest.pulls.list({\n        owner,\n        repo,\n        state: 'open',\n        head: `${owner}:${branchName}`,\n        per_page: 100 // Get up to 100 PRs for a branch\n      });\n\n      this.logger.apiResponse('GET', `/repos/${owner}/${repo}/pulls`, response.status, Date.now() - startTime);\n      \n      // Return all matching PRs or empty array if none found\n      return response.data || [];\n    } catch (error) {\n      this.logger.apiResponse('GET', `/repos/${owner}/${repo}/pulls`, error.status || 'error', Date.now() - startTime);\n      console.error('Failed to fetch pull requests for branch:', error);\n      return []; // Return empty array instead of throwing to allow graceful fallback\n    }\n  }\n\n  // Get pull request comments\n  async getPullRequestComments(owner, repo, pullNumber, page = 1, per_page = 100) {\n    // Use authenticated octokit if available, otherwise create a public instance for public repos\n    const octokit = this.isAuth() ? this.octokit : new Octokit();\n\n    const startTime = Date.now();\n    this.logger.apiCall('GET', `/repos/${owner}/${repo}/pulls/${pullNumber}/comments`, { page, per_page });\n\n    try {\n      const response = await octokit.rest.pulls.listReviewComments({\n        owner,\n        repo,\n        pull_number: pullNumber,\n        page,\n        per_page\n      });\n\n      this.logger.apiResponse('GET', `/repos/${owner}/${repo}/pulls/${pullNumber}/comments`, response.status, Date.now() - startTime);\n      return response.data;\n    } catch (error) {\n      this.logger.apiResponse('GET', `/repos/${owner}/${repo}/pulls/${pullNumber}/comments`, error.status || 'error', Date.now() - startTime);\n      console.error('Failed to fetch pull request comments:', error);\n      throw error;\n    }\n  }\n\n  // Get pull request issue comments (general comments on the PR conversation)\n  async getPullRequestIssueComments(owner, repo, pullNumber, page = 1, per_page = 100) {\n    // Use authenticated octokit if available, otherwise create a public instance for public repos\n    const octokit = this.isAuth() ? this.octokit : new Octokit();\n\n    const startTime = Date.now();\n    this.logger.apiCall('GET', `/repos/${owner}/${repo}/issues/${pullNumber}/comments`, { page, per_page });\n\n    try {\n      const response = await octokit.rest.issues.listComments({\n        owner,\n        repo,\n        issue_number: pullNumber,\n        page,\n        per_page\n      });\n\n      this.logger.apiResponse('GET', `/repos/${owner}/${repo}/issues/${pullNumber}/comments`, response.status, Date.now() - startTime);\n      return response.data;\n    } catch (error) {\n      this.logger.apiResponse('GET', `/repos/${owner}/${repo}/issues/${pullNumber}/comments`, error.status || 'error', Date.now() - startTime);\n      console.error('Failed to fetch pull request issue comments:', error);\n      throw error;\n    }\n  }\n\n  // Create a comment on a pull request\n  async createPullRequestComment(owner, repo, pullNumber, body) {\n    if (!this.isAuth()) {\n      throw new Error('Not authenticated with GitHub');\n    }\n\n    const startTime = Date.now();\n    this.logger.apiCall('POST', `/repos/${owner}/${repo}/issues/${pullNumber}/comments`, { body });\n\n    try {\n      const response = await this.octokit.rest.issues.createComment({\n        owner,\n        repo,\n        issue_number: pullNumber,\n        body\n      });\n\n      this.logger.apiResponse('POST', `/repos/${owner}/${repo}/issues/${pullNumber}/comments`, response.status, Date.now() - startTime);\n      return response.data;\n    } catch (error) {\n      this.logger.apiResponse('POST', `/repos/${owner}/${repo}/issues/${pullNumber}/comments`, error.status || 'error', Date.now() - startTime);\n      console.error('Failed to create pull request comment:', error);\n      throw error;\n    }\n  }\n\n  // Get open issues count\n  async getOpenIssuesCount(owner, repo) {\n    if (!this.isAuth()) {\n      throw new Error('Not authenticated with GitHub');\n    }\n\n    const startTime = Date.now();\n    this.logger.apiCall('GET', `/repos/${owner}/${repo}/issues`, { state: 'open', per_page: 1 });\n\n    try {\n      const response = await this.octokit.rest.issues.listForRepo({\n        owner,\n        repo,\n        state: 'open',\n        per_page: 1\n      });\n\n      this.logger.apiResponse('GET', `/repos/${owner}/${repo}/issues`, response.status, Date.now() - startTime);\n      \n      // GitHub includes the total count in the response headers\n      const linkHeader = response.headers.link;\n      if (linkHeader && linkHeader.includes('rel=\"last\"')) {\n        const lastPageMatch = linkHeader.match(/page=(\\d+)>; rel=\"last\"/);\n        if (lastPageMatch) {\n          return parseInt(lastPageMatch[1], 10);\n        }\n      }\n      \n      // Fallback: use the length of returned items (may not be accurate for large counts)\n      return response.data.length;\n    } catch (error) {\n      this.logger.apiResponse('GET', `/repos/${owner}/${repo}/issues`, error.status || 'error', Date.now() - startTime);\n      console.error('Failed to fetch issues count:', error);\n      throw error;\n    }\n  }\n\n  // Get repository statistics (combined method for efficiency)\n  async getRepositoryStats(owner, repo, branch = 'main') {\n    if (!this.isAuth()) {\n      throw new Error('Not authenticated with GitHub');\n    }\n\n    try {\n      const [recentCommits, openPRsCount, openIssuesCount] = await Promise.allSettled([\n        this.getRecentCommits(owner, repo, branch, 1),\n        this.getOpenPullRequestsCount(owner, repo),\n        this.getOpenIssuesCount(owner, repo)\n      ]);\n\n      return {\n        recentCommits: recentCommits.status === 'fulfilled' ? recentCommits.value : [],\n        openPullRequestsCount: openPRsCount.status === 'fulfilled' ? openPRsCount.value : 0,\n        openIssuesCount: openIssuesCount.status === 'fulfilled' ? openIssuesCount.value : 0,\n        errors: {\n          recentCommits: recentCommits.status === 'rejected' ? recentCommits.reason : null,\n          openPullRequestsCount: openPRsCount.status === 'rejected' ? openPRsCount.reason : null,\n          openIssuesCount: openIssuesCount.status === 'rejected' ? openIssuesCount.reason : null\n        }\n      };\n    } catch (error) {\n      console.error('Failed to fetch repository stats:', error);\n      throw error;\n    }\n  }\n\n  // Get directory contents (supports both authenticated and unauthenticated access)\n  async getDirectoryContents(owner, repo, path = '', ref = 'main') {\n    try {\n      // Create temporary Octokit instance for unauthenticated access if needed\n      const octokit = this.isAuth() ? this.octokit : new Octokit();\n      \n      const { data } = await octokit.rest.repos.getContent({\n        owner,\n        repo,\n        path,\n        ref\n      });\n\n      if (Array.isArray(data)) {\n        return data;\n      } else {\n        throw new Error('Not a directory');\n      }\n    } catch (error) {\n      console.error(`Failed to get directory contents for ${path}:`, error);\n      throw error;\n    }\n  }\n\n  // Update file content (requires authentication)\n  async updateFile(owner, repo, path, content, message, branch = 'main') {\n    if (!this.isAuth()) {\n      throw new Error('Authentication required to update files');\n    }\n\n    try {\n      // First, get the current file to get its SHA\n      const { data: currentFile } = await this.octokit.rest.repos.getContent({\n        owner,\n        repo,\n        path,\n        ref: branch\n      });\n\n      if (Array.isArray(currentFile)) {\n        throw new Error('Path is a directory, not a file');\n      }\n\n      // Update the file\n      const { data } = await this.octokit.rest.repos.createOrUpdateFileContents({\n        owner,\n        repo,\n        path,\n        message,\n        content: btoa(unescape(encodeURIComponent(content))),\n        sha: currentFile.sha,\n        branch\n      });\n\n      return data;\n    } catch (error) {\n      console.error(`Failed to update file ${path}:`, error);\n      throw error;\n    }\n  }\n\n  // Get commits for a repository (supports unauthenticated access)\n  async getCommits(owner, repo, options = {}) {\n    try {\n      // Create temporary Octokit instance for unauthenticated access if needed\n      const octokit = this.isAuth() ? this.octokit : new Octokit();\n      \n      const params = {\n        owner,\n        repo,\n        per_page: options.per_page || 10,\n        page: options.page || 1\n      };\n\n      if (options.sha) {\n        params.sha = options.sha;\n      }\n\n      if (options.since) {\n        params.since = options.since;\n      }\n\n      if (options.until) {\n        params.until = options.until;\n      }\n\n      const { data } = await octokit.rest.repos.listCommits(params);\n      return data;\n    } catch (error) {\n      console.error('Failed to fetch commits:', error);\n      throw error;\n    }\n  }\n\n  // Get issues for a repository (supports unauthenticated access)\n  async getIssues(owner, repo, options = {}) {\n    try {\n      // Create temporary Octokit instance for unauthenticated access if needed\n      const octokit = this.isAuth() ? this.octokit : new Octokit();\n      \n      const params = {\n        owner,\n        repo,\n        state: options.state || 'all',\n        per_page: options.per_page || 30,\n        page: options.page || 1\n      };\n\n      if (options.labels) {\n        params.labels = options.labels;\n      }\n\n      if (options.milestone) {\n        params.milestone = options.milestone;\n      }\n\n      const { data } = await octokit.rest.issues.listForRepo(params);\n      return data;\n    } catch (error) {\n      console.error('Failed to fetch issues:', error);\n      throw error;\n    }\n  }\n\n  // Alias method for backward compatibility - delegates to getIssues\n  async getRepositoryIssues(owner, repo, options = {}) {\n    return this.getIssues(owner, repo, options);\n  }\n\n  // Get repository forks\n  async getForks(owner, repo, options = {}) {\n    const startTime = Date.now();\n    this.logger.apiCall('GET', `/repos/${owner}/${repo}/forks`, options);\n\n    try {\n      // Use the GitHub API to fetch forks, no authentication required for public repos\n      const octokit = this.isAuth() ? this.octokit : new Octokit();\n      \n      const params = {\n        owner,\n        repo,\n        sort: options.sort || 'newest',\n        per_page: options.per_page || 100,\n        page: options.page || 1\n      };\n\n      const { data } = await octokit.rest.repos.listForks(params);\n      \n      this.logger.apiResponse('GET', `/repos/${owner}/${repo}/forks`, 200, Date.now() - startTime);\n      \n      // Return formatted fork data\n      return data.map(fork => ({\n        id: fork.id,\n        name: fork.name,\n        full_name: fork.full_name,\n        owner: {\n          login: fork.owner.login,\n          avatar_url: fork.owner.avatar_url,\n          html_url: fork.owner.html_url,\n          type: fork.owner.type\n        },\n        description: fork.description,\n        html_url: fork.html_url,\n        clone_url: fork.clone_url,\n        created_at: fork.created_at,\n        updated_at: fork.updated_at,\n        pushed_at: fork.pushed_at,\n        stargazers_count: fork.stargazers_count,\n        forks_count: fork.forks_count,\n        open_issues_count: fork.open_issues_count,\n        default_branch: fork.default_branch,\n        private: fork.private,\n        fork: fork.fork,\n        parent: fork.parent ? {\n          full_name: fork.parent.full_name,\n          html_url: fork.parent.html_url\n        } : null\n      }));\n    } catch (error) {\n      this.logger.apiResponse('GET', `/repos/${owner}/${repo}/forks`, error.status || 'error', Date.now() - startTime);\n      console.error('Failed to fetch repository forks:', error);\n      throw error;\n    }\n  }\n\n  // Get pull requests for a specific repository\n  async getPullRequests(owner, repo, options = {}) {\n    const startTime = Date.now();\n    this.logger.apiCall('GET', `/repos/${owner}/${repo}/pulls`, options);\n\n    try {\n      // Use the GitHub API to fetch pull requests, no authentication required for public repos\n      const octokit = this.isAuth() ? this.octokit : new Octokit();\n      \n      const params = {\n        owner,\n        repo,\n        state: options.state || 'open',\n        sort: options.sort || 'updated',\n        direction: options.direction || 'desc',\n        per_page: options.per_page || 30,\n        page: options.page || 1\n      };\n\n      // Add optional filters\n      if (options.head) {\n        params.head = options.head;\n      }\n      if (options.base) {\n        params.base = options.base;\n      }\n\n      const { data } = await octokit.rest.pulls.list(params);\n      \n      this.logger.apiResponse('GET', `/repos/${owner}/${repo}/pulls`, 200, Date.now() - startTime);\n      \n      // Return formatted pull request data\n      return data.map(pr => ({\n        id: pr.id,\n        number: pr.number,\n        title: pr.title,\n        body: pr.body,\n        state: pr.state,\n        locked: pr.locked,\n        user: {\n          login: pr.user.login,\n          avatar_url: pr.user.avatar_url,\n          html_url: pr.user.html_url,\n          type: pr.user.type\n        },\n        created_at: pr.created_at,\n        updated_at: pr.updated_at,\n        closed_at: pr.closed_at,\n        merged_at: pr.merged_at,\n        html_url: pr.html_url,\n        diff_url: pr.diff_url,\n        patch_url: pr.patch_url,\n        head: {\n          ref: pr.head.ref,\n          sha: pr.head.sha,\n          repo: pr.head.repo ? {\n            name: pr.head.repo.name,\n            full_name: pr.head.repo.full_name,\n            owner: {\n              login: pr.head.repo.owner.login,\n              avatar_url: pr.head.repo.owner.avatar_url\n            },\n            html_url: pr.head.repo.html_url\n          } : null\n        },\n        base: {\n          ref: pr.base.ref,\n          sha: pr.base.sha,\n          repo: {\n            name: pr.base.repo.name,\n            full_name: pr.base.repo.full_name,\n            owner: {\n              login: pr.base.repo.owner.login,\n              avatar_url: pr.base.repo.owner.avatar_url\n            },\n            html_url: pr.base.repo.html_url\n          }\n        },\n        draft: pr.draft,\n        mergeable: pr.mergeable,\n        mergeable_state: pr.mergeable_state,\n        comments: pr.comments,\n        review_comments: pr.review_comments,\n        commits: pr.commits,\n        additions: pr.additions,\n        deletions: pr.deletions,\n        changed_files: pr.changed_files\n      }));\n    } catch (error) {\n      this.logger.apiResponse('GET', `/repos/${owner}/${repo}/pulls`, error.status || 'error', Date.now() - startTime);\n      console.error('Failed to fetch pull requests:', error);\n      throw error;\n    }\n  }\n\n  // Create an issue (requires authentication)\n  async createIssue(owner, repo, title, body, labels = [], assignees = []) {\n    if (!this.isAuth()) {\n      throw new Error('Authentication required to create issues');\n    }\n\n    const startTime = Date.now();\n    this.logger.apiCall('POST', `/repos/${owner}/${repo}/issues`, { title, bodyLength: body?.length, labels, assignees });\n\n    try {\n      const params = {\n        owner,\n        repo,\n        title,\n        body\n      };\n\n      // Add optional parameters if provided\n      if (labels.length > 0) {\n        params.labels = labels;\n      }\n      \n      if (assignees.length > 0) {\n        params.assignees = assignees;\n      }\n\n      const response = await this.octokit.rest.issues.create(params);\n      \n      this.logger.apiResponse('POST', `/repos/${owner}/${repo}/issues`, response.status, Date.now() - startTime);\n      \n      return {\n        success: true,\n        issue: {\n          id: response.data.id,\n          number: response.data.number,\n          title: response.data.title,\n          body: response.data.body,\n          html_url: response.data.html_url,\n          state: response.data.state,\n          created_at: response.data.created_at,\n          user: {\n            login: response.data.user.login,\n            avatar_url: response.data.user.avatar_url\n          },\n          labels: response.data.labels.map(label => ({\n            name: label.name,\n            color: label.color\n          }))\n        }\n      };\n    } catch (error) {\n      this.logger.apiResponse('POST', `/repos/${owner}/${repo}/issues`, error.status || 'error', Date.now() - startTime);\n      console.error('Failed to create issue:', error);\n      \n      // Return structured error response\n      return {\n        success: false,\n        error: {\n          message: error.message,\n          status: error.status,\n          type: error.status === 403 ? 'permission_denied' : \n                error.status === 422 ? 'validation_error' : \n                error.status === 404 ? 'repository_not_found' : 'unknown_error'\n        }\n      };\n    }\n  }\n\n  // Get a specific issue\n  async getIssue(owner, repo, issueNumber) {\n    if (!this.isAuth()) {\n      throw new Error('Authentication required to get issue details');\n    }\n\n    const startTime = Date.now();\n    this.logger.apiCall('GET', `/repos/${owner}/${repo}/issues/${issueNumber}`);\n\n    try {\n      const response = await this.octokit.rest.issues.get({\n        owner,\n        repo,\n        issue_number: issueNumber\n      });\n\n      this.logger.apiResponse('GET', `/repos/${owner}/${repo}/issues/${issueNumber}`, response.status, Date.now() - startTime);\n\n      return {\n        id: response.data.id,\n        number: response.data.number,\n        title: response.data.title,\n        body: response.data.body,\n        html_url: response.data.html_url,\n        state: response.data.state,\n        created_at: response.data.created_at,\n        updated_at: response.data.updated_at,\n        closed_at: response.data.closed_at,\n        user: {\n          login: response.data.user.login,\n          avatar_url: response.data.user.avatar_url\n        },\n        labels: response.data.labels.map(label => ({\n          name: label.name,\n          color: label.color\n        }))\n      };\n    } catch (error) {\n      this.logger.apiResponse('GET', `/repos/${owner}/${repo}/issues/${issueNumber}`, error.status || 'error', Date.now() - startTime);\n      console.error('Failed to get issue:', error);\n      throw error;\n    }\n  }\n\n  // Get a specific pull request\n  async getPullRequest(owner, repo, pullNumber) {\n    if (!this.isAuth()) {\n      throw new Error('Authentication required to get pull request details');\n    }\n\n    const startTime = Date.now();\n    this.logger.apiCall('GET', `/repos/${owner}/${repo}/pulls/${pullNumber}`);\n\n    try {\n      const response = await this.octokit.rest.pulls.get({\n        owner,\n        repo,\n        pull_number: pullNumber\n      });\n\n      this.logger.apiResponse('GET', `/repos/${owner}/${repo}/pulls/${pullNumber}`, response.status, Date.now() - startTime);\n\n      return {\n        id: response.data.id,\n        number: response.data.number,\n        title: response.data.title,\n        body: response.data.body,\n        html_url: response.data.html_url,\n        state: response.data.state,\n        created_at: response.data.created_at,\n        updated_at: response.data.updated_at,\n        closed_at: response.data.closed_at,\n        merged_at: response.data.merged_at,\n        user: {\n          login: response.data.user.login,\n          avatar_url: response.data.user.avatar_url\n        },\n        head: {\n          ref: response.data.head.ref,\n          sha: response.data.head.sha\n        },\n        base: {\n          ref: response.data.base.ref,\n          sha: response.data.base.sha\n        }\n      };\n    } catch (error) {\n      this.logger.apiResponse('GET', `/repos/${owner}/${repo}/pulls/${pullNumber}`, error.status || 'error', Date.now() - startTime);\n      console.error('Failed to get pull request:', error);\n      throw error;\n    }\n  }\n\n  // Search pull requests using GitHub search API\n  async searchPullRequests(query, options = {}) {\n    if (!this.isAuth()) {\n      throw new Error('Authentication required to search pull requests');\n    }\n\n    const startTime = Date.now();\n    this.logger.apiCall('GET', '/search/issues', { query, type: 'pr' });\n\n    try {\n      const response = await this.octokit.rest.search.issuesAndPullRequests({\n        q: query,\n        sort: options.sort || 'created',\n        order: options.order || 'desc',\n        per_page: options.per_page || 30,\n        page: options.page || 1\n      });\n\n      this.logger.apiResponse('GET', '/search/issues', response.status, Date.now() - startTime);\n\n      return {\n        total_count: response.data.total_count,\n        incomplete_results: response.data.incomplete_results,\n        items: response.data.items.map(item => ({\n          id: item.id,\n          number: item.number,\n          title: item.title,\n          body: item.body,\n          html_url: item.html_url,\n          state: item.state,\n          created_at: item.created_at,\n          updated_at: item.updated_at,\n          closed_at: item.closed_at,\n          user: {\n            login: item.user.login,\n            avatar_url: item.user.avatar_url\n          },\n          repository: item.repository_url ? {\n            name: item.repository_url.split('/').slice(-1)[0],\n            full_name: item.repository_url.split('/').slice(-2).join('/')\n          } : null\n        }))\n      };\n    } catch (error) {\n      this.logger.apiResponse('GET', '/search/issues', error.status || 'error', Date.now() - startTime);\n      console.error('Failed to search pull requests:', error);\n      throw error;\n    }\n  }\n\n  // Logout\n  logout() {\n    this.logger.auth('Logging out and clearing stored token');\n    \n    this.octokit = null;\n    this.isAuthenticated = false;\n    this.tokenType = null;\n    this.permissions = null;\n    \n    // Clear secure token storage\n    secureTokenStorage.clearToken();\n    \n    // Clear branch context on logout\n    try {\n      const { default: branchContextService } = require('../services/branchContextService');\n      branchContextService.clearAllBranchContext();\n    } catch (error) {\n      // Service might not be available during testing\n      sessionStorage.removeItem('sgex_branch_context');\n    }\n  }\n\n  // Get repository forks\n  async getRepositoryForks(owner, repo, options = {}) {\n    const startTime = Date.now();\n    this.logger.debug('Fetching repository forks', { owner, repo, options });\n\n    try {\n      // Create temporary Octokit instance for unauthenticated access if needed\n      const octokit = this.isAuth() ? this.octokit : new Octokit();\n      \n      this.logger.apiCall('GET', `/repos/${owner}/${repo}/forks`, options);\n      \n      const { data } = await octokit.rest.repos.listForks({\n        owner,\n        repo,\n        sort: 'newest', // Sort by newest first\n        per_page: options.per_page || 100,\n        page: options.page || 1\n      });\n\n      const duration = Date.now() - startTime;\n      this.logger.apiResponse('GET', `/repos/${owner}/${repo}/forks`, 200, duration, { forkCount: data.length });\n      this.logger.performance('Repository forks fetch', duration);\n\n      return data;\n    } catch (error) {\n      const duration = Date.now() - startTime;\n      this.logger.apiError('GET', `/repos/${owner}/${repo}/forks`, error);\n      this.logger.performance('Repository forks fetch (failed)', duration);\n      console.error(`Failed to fetch forks for ${owner}/${repo}:`, error);\n      throw error;\n    }\n  }\n}\n\n// Create a singleton instance\nconst githubService = new GitHubService();\n\nexport default githubService;","/**\n * Service for managing DAK branch context in session storage\n * Stores selected branch per repository to maintain context during DAK editing\n */\n\nclass BranchContextService {\n  constructor() {\n    this.storageKey = 'sgex_branch_context';\n  }\n\n  // Get the storage key for a specific repository\n  getRepositoryKey(repository) {\n    if (!repository || !repository.name) return null;\n    const owner = repository.owner?.login || repository.full_name?.split('/')[0];\n    if (!owner) return null;\n    return `${owner}/${repository.name}`;\n  }\n\n  // Get the selected branch for a repository\n  getSelectedBranch(repository) {\n    if (!repository) return null;\n    \n    try {\n      const branchContext = this.getBranchContext();\n      const repoKey = this.getRepositoryKey(repository);\n      return branchContext[repoKey] || null;\n    } catch (error) {\n      console.warn('Failed to get branch context:', error);\n      return null;\n    }\n  }\n\n  // Set the selected branch for a repository\n  setSelectedBranch(repository, branch) {\n    if (!repository || !branch) return;\n\n    try {\n      const branchContext = this.getBranchContext();\n      const repoKey = this.getRepositoryKey(repository);\n      branchContext[repoKey] = branch;\n      this.setBranchContext(branchContext);\n    } catch (error) {\n      console.warn('Failed to set branch context:', error);\n    }\n  }\n\n  // Clear branch context for a specific repository\n  clearRepositoryBranch(repository) {\n    if (!repository) return;\n\n    try {\n      const branchContext = this.getBranchContext();\n      const repoKey = this.getRepositoryKey(repository);\n      delete branchContext[repoKey];\n      this.setBranchContext(branchContext);\n    } catch (error) {\n      console.warn('Failed to clear repository branch context:', error);\n    }\n  }\n\n  // Clear all branch context (e.g., on logout)\n  clearAllBranchContext() {\n    try {\n      sessionStorage.removeItem(this.storageKey);\n    } catch (error) {\n      console.warn('Failed to clear branch context:', error);\n    }\n  }\n\n  // Get all branch context from storage\n  getBranchContext() {\n    try {\n      const stored = sessionStorage.getItem(this.storageKey);\n      return stored ? JSON.parse(stored) : {};\n    } catch (error) {\n      console.warn('Failed to parse branch context from storage:', error);\n      return {};\n    }\n  }\n\n  // Set branch context to storage\n  setBranchContext(context) {\n    try {\n      sessionStorage.setItem(this.storageKey, JSON.stringify(context));\n    } catch (error) {\n      console.warn('Failed to save branch context to storage:', error);\n    }\n  }\n\n  // Get default branch name (prefer 'main' over 'master')\n  getDefaultBranchName(repository, availableBranches = []) {\n    if (!repository) return 'main';\n\n    // First try 'main'\n    if (availableBranches.some(b => b.name === 'main')) {\n      return 'main';\n    }\n\n    // Then try the repository's default branch\n    if (repository.default_branch && \n        availableBranches.some(b => b.name === repository.default_branch)) {\n      return repository.default_branch;\n    }\n\n    // Finally fall back to the first available branch or 'main'\n    return availableBranches.length > 0 ? availableBranches[0].name : 'main';\n  }\n\n  // Check if a branch context exists for a repository\n  hasBranchContext(repository) {\n    return this.getSelectedBranch(repository) !== null;\n  }\n\n  // Get a formatted display string for the current branch context\n  getBranchDisplayInfo(repository) {\n    const selectedBranch = this.getSelectedBranch(repository);\n    if (!selectedBranch) return null;\n\n    const isDefault = selectedBranch === (repository?.default_branch || 'main');\n    return {\n      branch: selectedBranch,\n      isDefault,\n      displayText: isDefault ? `${selectedBranch} (default)` : selectedBranch\n    };\n  }\n}\n\n// Create a singleton instance\nconst branchContextService = new BranchContextService();\n\nexport default branchContextService;"],"names":["constructor","this","listeners","Set","currentRepository","currentBranch","initialize","repository","branch","notifyListeners","getStorageKey","Error","concat","full_name","getStagingGround","key","stored","localStorage","getItem","JSON","parse","createEmptyStagingGround","error","console","warn","_this$currentReposito","message","files","timestamp","Date","now","saveStagingGround","stagingGround","_this$currentReposito2","setItem","stringify","saveToHistory","updateFile","filePath","content","metadata","arguments","length","undefined","existingFileIndex","findIndex","f","path","fileObject","_objectSpread","lastModified","push","removeFile","filter","updateCommitMessage","hasChanges","getChangedFilesCount","clearStagingGround","empty","historyKey","history","getHistory","savedAt","recentHistory","slice","rollbackToSave","save","find","s","stagingGroundState","_objectWithoutProperties","_excluded","exportStagingGround","_this$currentReposito3","current","exportedAt","importStagingGround","exportedData","_this$currentReposito4","cleanup","maxAge","keysToRemove","i","startsWith","data","forEach","removeItem","addListener","callback","add","delete","contributeFiles","Array","isArray","success","results","file","result","source","tool","contributedAt","getStatus","_this$currentReposito5","filesCount","async","processConcurrently","items","processor","options","concurrency","onProgress","onItemComplete","onItemStart","total","completed","queue","map","item","index","workers","Math","min","fill","shift","worker","Promise","all","ttlMinutes","cache","Map","ttl","_getCacheKey","owner","repo","_isValid","entry","get","compatible","set","clear","entries","getStats","size","from","_ref","ageMinutes","round","logger","getLogger","storageKey","expirationHours","debug","generateBrowserFingerprint","canvas","document","createElement","ctx","getContext","textBaseline","font","fillText","fingerprint","navigator","userAgent","language","window","screen","width","height","colorDepth","getTimezoneOffset","toDataURL","join","hash","charCodeAt","abs","toString","xorCipher","text","String","fromCharCode","validateTokenFormat","token","isValid","type","reason","cleanToken","trim","match","maskToken","substring","repeat","storeToken","validation","tokenMask","encryptionKey","encryptedToken","storageData","btoa","created","expires","sessionStorage","toISOString","retrieveToken","storedData","clearToken","currentFingerprint","atob","decryptedToken","hasValidToken","getTokenInfo","timeRemaining","max","isExpired","migrateLegacyToken","legacyToken","octokit","isAuthenticated","permissions","tokenType","authenticate","startTime","auth","tokenProvided","secureTokenStorage","Octokit","duration","securelyStored","performance","authenticateWithOctokit","octokitInstance","initializeFromStoredToken","tokenData","hasStoredToken","getStoredTokenInfo","checkTokenPermissions","isAuth","apiCall","response","request","apiResponse","status","rateLimitStart","rateLimit","rest","resources","core","hasCore","rateLimitError","user","username","login","apiError","checkRepositoryWritePermissions","getCurrentUser","repos","getCollaboratorPermissionLevel","hasWriteAccess","includes","permission","checkRepositoryPermissions","checkCommentPermissions","per_page","issues","listForRepo","state","users","getAuthenticated","getUserOrganizations","orgs","listForAuthenticatedUser","getOrganization","orgLogin","org","getUser","getByUsername","getPublicRepositories","repositories","page","hasMorePages","listForUser","sort","listForOrg","getWHOOrganization","whoData","id","display_name","name","description","avatar_url","html_url","can_create_repositories","can_create_private_repositories","plan","private_repos","isWHO","getRepositories","getDemoRepositories","getSmartGuidelinesRepositories","demoRepos","private","clone_url","stargazers_count","forks_count","open_issues_count","topics","created_at","updated_at","pushed_at","default_branch","smart_guidelines_compatible","isDemo","resolve","checkSmartGuidelinesCompatibility","retryCount","cachedResult","repositoryCompatibilityCache","getContent","isCompatible","decodeURIComponent","escape","delay","setTimeout","smartGuidelinesRepos","getSmartGuidelinesRepositoriesProgressive","onRepositoryFound","log","currentRepo","progress","random","smartRepo","started","getRepository","getBranches","listBranches","createBranch","branchName","fromBranch","refData","git","getRef","ref","createRef","sha","object","getBranch","getWorkflows","actions","listRepoWorkflows","workflows","workflow","filename","split","pop","url","triggers","getWorkflowRuns","params","workflow_id","listWorkflowRunsForRepo","getWorkflowRunsForWorkflow","listWorkflowRuns","triggerWorkflow","inputs","createWorkflowDispatch","rerunWorkflow","run_id","reRunWorkflow","getWorkflowRunLogs","downloadWorkflowRunLogs","approveWorkflowRun","getCommitDiff","base","head","compareCommits","getCommit","getReleases","listReleases","getLatestRelease","getBpmnFilesRecursive","allFiles","endsWith","getBpmnFiles","allBpmnFiles","possiblePaths","uniqueFiles","self","getFileContent","timeoutMs","timeoutPromise","_","reject","apiPromise","race","responseTime","encoding","hasContent","_error$stack","stack","createCommit","latestCommitSha","commitData","commit_sha","baseTreeSha","tree","blobs","blobData","createBlob","mode","treeData","createTree","base_tree","newCommitData","parents","updateRef","author","committer","getRecentCommits","listCommits","commit","email","date","stats","getOpenPullRequestsCount","pulls","list","linkHeader","headers","link","lastPageMatch","parseInt","getPullRequestForBranch","prs","getPullRequestsForBranch","getPullRequestComments","pullNumber","listReviewComments","pull_number","getPullRequestIssueComments","listComments","issue_number","createPullRequestComment","body","createComment","getOpenIssuesCount","getRepositoryStats","recentCommits","openPRsCount","openIssuesCount","allSettled","value","openPullRequestsCount","errors","getDirectoryContents","currentFile","createOrUpdateFileContents","unescape","encodeURIComponent","getCommits","since","until","getIssues","labels","milestone","getRepositoryIssues","getForks","listForks","fork","parent","getPullRequests","direction","pr","number","title","locked","closed_at","merged_at","diff_url","patch_url","draft","mergeable","mergeable_state","comments","review_comments","commits","additions","deletions","changed_files","createIssue","assignees","bodyLength","create","issue","label","color","getIssue","issueNumber","getPullRequest","searchPullRequests","query","search","issuesAndPullRequests","q","order","total_count","incomplete_results","repository_url","logout","default","branchContextService","require","clearAllBranchContext","getRepositoryForks","forkCount","getRepositoryKey","_repository$owner","_repository$full_name","getSelectedBranch","branchContext","getBranchContext","setSelectedBranch","setBranchContext","clearRepositoryBranch","context","getDefaultBranchName","availableBranches","some","b","hasBranchContext","getBranchDisplayInfo","selectedBranch","isDefault","displayText"],"sourceRoot":""}