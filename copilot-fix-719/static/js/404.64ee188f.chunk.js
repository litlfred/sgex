"use strict";(self.webpackChunksgex_workbench=self.webpackChunksgex_workbench||[]).push([[404],{50404:(t,e,o)=>{o.d(e,{A:()=>l});var r=o(89379),s=o(97036);async function n(t,e){let o=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};const{concurrency:r=5,onProgress:s=null,onItemComplete:n=null,onItemStart:a=null}=o;if(!t||0===t.length)return[];const i=new Array(t.length),c=t.length;let l=0;const h=t.map((t,e)=>({item:t,index:e})),u=Array(Math.min(r,t.length)).fill().map(()=>(async()=>{for(;h.length>0;){const{item:o,index:r}=h.shift();a&&a(o,r);try{const t=await e(o,r);i[r]=t,l++,s&&s(l,c,o,t),n&&n(o,t,null)}catch(t){i[r]={error:t,item:o},l++,s&&s(l,c,o,null),n&&n(o,null,t)}}})());return await Promise.all(u),i}const a=new class{constructor(){let t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:30;this.cache=new Map,this.ttl=60*t*1e3}_getCacheKey(t,e){return"".concat(t,"/").concat(e)}_isValid(t){return Date.now()-t.timestamp<this.ttl}get(t,e){const o=this._getCacheKey(t,e),r=this.cache.get(o);return r?this._isValid(r)?r.compatible:(this.cache.delete(o),null):null}set(t,e,o){const r=this._getCacheKey(t,e);this.cache.set(r,{compatible:o,timestamp:Date.now()})}clear(){this.cache.clear()}cleanup(){const t=Date.now();for(const[e,o]of this.cache.entries())t-o.timestamp>=this.ttl&&this.cache.delete(e)}getStats(){return this.cleanup(),{size:this.cache.size,ttlMinutes:this.ttl/6e4,entries:Array.from(this.cache.entries()).map(t=>{let[e,o]=t;return{repository:e,compatible:o.compatible,ageMinutes:Math.round((Date.now()-o.timestamp)/6e4)}})}}};var i=o(5452);const c=new class{constructor(){this.logger=i.A.getLogger("SecureTokenStorage"),this.storageKey="sgex_secure_token",this.expirationHours=24,this.logger.debug("SecureTokenStorage instance created")}generateBrowserFingerprint(){const t=document.createElement("canvas"),e=t.getContext("2d");e.textBaseline="top",e.font="14px Arial",e.fillText("Browser fingerprint",2,2);const o=[navigator.userAgent,navigator.language,window.screen.width+"x"+window.screen.height,window.screen.colorDepth,(new Date).getTimezoneOffset(),t.toDataURL()].join("|");let r=0;for(let s=0;s<o.length;s++){r=(r<<5)-r+o.charCodeAt(s),r&=r}return Math.abs(r).toString(36)}xorCipher(t,e){let o="";for(let r=0;r<t.length;r++)o+=String.fromCharCode(t.charCodeAt(r)^e.charCodeAt(r%e.length));return o}validateTokenFormat(t){if(!t||"string"!==typeof t)return{isValid:!1,type:"invalid",reason:"Token is empty or not a string"};const e=t.trim();return e.match(/^ghp_[A-Za-z0-9]{36}$/)?{isValid:!0,type:"classic",token:e}:e.match(/^github_pat_[A-Za-z0-9]{22}_[A-Za-z0-9]{59}$/)?{isValid:!0,type:"fine-grained",token:e}:e.match(/^gho_[A-Za-z0-9]{36}$/)?{isValid:!0,type:"oauth",token:e}:e.match(/^[a-fA-F0-9]{40}$/)?{isValid:!0,type:"legacy",token:e}:{isValid:!1,type:"invalid",reason:"Token does not match expected GitHub PAT format"}}maskToken(t){if(!t||"string"!==typeof t)return"[INVALID_TOKEN]";const e=t.trim();return e.length<8?"[INVALID_TOKEN]":"".concat(e.substring(0,4)).concat("*".repeat(e.length-8)).concat(e.substring(e.length-4))}storeToken(t){try{this.logger.debug("Starting secure token storage");const e=this.validateTokenFormat(t);if(!e.isValid)return this.logger.warn("Token validation failed",{reason:e.reason,tokenMask:this.maskToken(t)}),!1;this.logger.debug("Token validation successful",{type:e.type,tokenMask:this.maskToken(t)});const o=this.generateBrowserFingerprint(),r="sgex_".concat(o,"_").concat(Date.now().toString(36)),s=this.xorCipher(e.token,r),n={token:btoa(s),key:btoa(r),type:e.type,created:Date.now(),expires:Date.now()+60*this.expirationHours*60*1e3,fingerprint:o};return sessionStorage.setItem(this.storageKey,JSON.stringify(n)),localStorage.removeItem("github_token"),sessionStorage.removeItem("github_token"),this.logger.debug("Token stored securely",{type:e.type,expires:new Date(n.expires).toISOString(),tokenMask:this.maskToken(t)}),!0}catch(e){return this.logger.error("Failed to store token securely",{error:e.message,tokenMask:this.maskToken(t)}),!1}}retrieveToken(){try{this.logger.debug("Attempting to retrieve secure token");const t=sessionStorage.getItem(this.storageKey);if(!t)return this.logger.debug("No secure token found in storage"),null;const e=JSON.parse(t);if(Date.now()>e.expires)return this.logger.warn("Stored token has expired"),this.clearToken(),null;const o=this.generateBrowserFingerprint();if(e.fingerprint!==o)return this.logger.warn("Browser fingerprint mismatch - possible security issue"),this.clearToken(),null;const r=atob(e.key),s=atob(e.token),n=this.xorCipher(s,r),a=this.validateTokenFormat(n);return a.isValid?(this.logger.debug("Token retrieved and decrypted successfully",{type:e.type,expires:new Date(e.expires).toISOString(),tokenMask:this.maskToken(n)}),{token:a.token,type:e.type,created:e.created,expires:e.expires}):(this.logger.error("Decrypted token failed validation"),this.clearToken(),null)}catch(t){return this.logger.error("Failed to retrieve secure token",{error:t.message}),this.clearToken(),null}}hasValidToken(){try{const t=sessionStorage.getItem(this.storageKey);if(!t)return!1;const e=JSON.parse(t);if(Date.now()>e.expires)return this.clearToken(),!1;const o=this.generateBrowserFingerprint();return e.fingerprint===o||(this.clearToken(),!1)}catch(t){return this.logger.error("Error checking token validity",{error:t.message}),this.clearToken(),!1}}clearToken(){this.logger.debug("Clearing secure token storage"),sessionStorage.removeItem(this.storageKey),sessionStorage.removeItem("github_token"),localStorage.removeItem("github_token")}getTokenInfo(){try{const t=sessionStorage.getItem(this.storageKey);if(!t)return null;const e=JSON.parse(t),o=e.expires-Date.now();return{type:e.type,created:new Date(e.created),expires:new Date(e.expires),timeRemaining:Math.max(0,o),isExpired:o<=0,isValid:this.hasValidToken()}}catch(t){return this.logger.error("Error getting token info",{error:t.message}),null}}migrateLegacyToken(){try{const t=sessionStorage.getItem("github_token")||localStorage.getItem("github_token");if(!t)return this.logger.debug("No legacy token found for migration"),!1;this.logger.debug("Migrating legacy token to secure storage");return this.storeToken(t)?(sessionStorage.removeItem("github_token"),localStorage.removeItem("github_token"),this.logger.debug("Legacy token migration completed successfully"),!0):(this.logger.error("Failed to migrate legacy token"),!1)}catch(t){return this.logger.error("Error during legacy token migration",{error:t.message}),!1}}};const l=new class{constructor(){this.octokit=null,this.isAuthenticated=!1,this.permissions=null,this.tokenType=null,this.logger=i.A.getLogger("GitHubService"),this.logger.debug("GitHubService instance created")}authenticate(t){const e=Date.now();this.logger.auth("Starting authentication",{tokenProvided:!!t,tokenMask:t?c.maskToken(t):"none"});try{const o=c.validateTokenFormat(t);if(!o.isValid)return this.logger.warn("Token validation failed during authentication",{reason:o.reason,tokenMask:c.maskToken(t)}),this.isAuthenticated=!1,!1;this.octokit=new s.Octokit({auth:o.token}),this.isAuthenticated=!0,this.tokenType=o.type;const r=c.storeToken(o.token);r||this.logger.warn("Failed to store token securely, authentication will not persist");const n=Date.now()-e;return this.logger.auth("Authentication successful",{duration:n,tokenType:this.tokenType,tokenMask:c.maskToken(t),securelyStored:r}),this.logger.performance("GitHub authentication",n),!0}catch(o){const r=Date.now()-e;return this.logger.auth("Authentication failed",{error:o.message,duration:r,tokenMask:c.maskToken(t)}),console.error("Failed to authenticate with GitHub:",o),this.isAuthenticated=!1,c.clearToken(),!1}}authenticateWithOctokit(t){this.logger.auth("Starting OAuth authentication with Octokit instance");try{return this.octokit=t,this.isAuthenticated=!0,this.tokenType="oauth",this.logger.auth("OAuth authentication successful",{tokenType:this.tokenType}),!0}catch(e){return this.logger.auth("OAuth authentication failed",{error:e.message}),console.error("Failed to authenticate with Octokit instance:",e),this.isAuthenticated=!1,!1}}initializeFromStoredToken(){this.logger.auth("Attempting to initialize from stored token");try{c.migrateLegacyToken()&&this.logger.debug("Successfully migrated legacy token to secure storage");const t=c.retrieveToken();return t?(this.octokit=new s.Octokit({auth:t.token}),this.isAuthenticated=!0,this.tokenType=t.type,this.logger.auth("Successfully initialized from stored token",{tokenType:this.tokenType,tokenMask:c.maskToken(t.token),expires:new Date(t.expires).toISOString()}),!0):(this.logger.debug("No valid stored token found"),!1)}catch(t){return this.logger.auth("Failed to initialize from stored token",{error:t.message}),this.isAuthenticated=!1,c.clearToken(),!1}}hasStoredToken(){return c.hasValidToken()}getStoredTokenInfo(){return c.getTokenInfo()}async checkTokenPermissions(){if(!this.isAuth()){const t=new Error("Not authenticated with GitHub");throw this.logger.error("Token permission check failed - not authenticated"),t}const t=Date.now();this.logger.apiCall("GET","/user",null);try{const o=await this.octokit.request("GET /user");this.logger.apiResponse("GET","/user",o.status,Date.now()-t);try{const t=Date.now();this.logger.apiCall("GET","/rate_limit",null);const e=await this.octokit.rest.rateLimit.get();this.logger.apiResponse("GET","/rate_limit",e.status,Date.now()-t),this.tokenType=e.data.resources.core?"classic":"fine-grained",this.logger.debug("Token type determined",{tokenType:this.tokenType,hasCore:!!e.data.resources.core})}catch(e){this.tokenType="unknown",this.logger.warn("Could not determine token type from rate limit",{error:e.message})}const r={type:this.tokenType,user:o.data};return this.permissions=r,this.logger.debug("Token permissions checked successfully",{tokenType:this.tokenType,username:o.data.login}),r}catch(o){const e=Date.now()-t;throw this.logger.apiError("GET","/user",o),this.logger.performance("Token permission check (failed)",e),console.error("Failed to check token permissions:",o),o}}async checkRepositoryWritePermissions(t,e){if(!this.isAuth())return this.logger.warn("Cannot check repository write permissions - not authenticated",{owner:t,repo:e}),!1;const o=Date.now();this.logger.debug("Checking write permissions for repository",{owner:t,repo:e});try{const r=(await this.getCurrentUser()).login;this.logger.apiCall("GET","/repos/".concat(t,"/").concat(e,"/collaborators/").concat(r,"/permission"),null);const{data:s}=await this.octokit.rest.repos.getCollaboratorPermissionLevel({owner:t,repo:e,username:r}),n=Date.now()-o;this.logger.apiResponse("GET","/repos/".concat(t,"/").concat(e,"/collaborators/").concat(r,"/permission"),200,n);const a=["write","admin"].includes(s.permission);return this.logger.debug("Repository write permissions checked",{owner:t,repo:e,permission:s.permission,hasWriteAccess:a}),a}catch(r){const s=Date.now()-o;return this.logger.apiError("GET","/repos/".concat(t,"/").concat(e,"/collaborators/*/permission"),r),this.logger.performance("Repository write permission check (failed)",s),console.warn("Could not check repository write permissions:",r),this.logger.warn("Assuming no write access due to permission check failure",{owner:t,repo:e,error:r.message}),!1}}async checkRepositoryPermissions(t,e){return this.checkRepositoryWritePermissions(t,e)}async checkCommentPermissions(t,e){if(!this.isAuth())return this.logger.warn("Cannot check comment permissions - not authenticated",{owner:t,repo:e}),!1;const o=Date.now();this.logger.debug("Checking comment permissions for repository",{owner:t,repo:e});try{this.logger.apiCall("GET","/repos/".concat(t,"/").concat(e,"/issues"),{per_page:1}),await this.octokit.rest.issues.listForRepo({owner:t,repo:e,per_page:1,state:"all"});const r=Date.now()-o;return this.logger.apiResponse("GET","/repos/".concat(t,"/").concat(e,"/issues"),200,r),this.logger.debug("Issues endpoint accessible - comment permissions likely available",{owner:t,repo:e}),!0}catch(r){const s=Date.now()-o;return this.logger.apiError("GET","/repos/".concat(t,"/").concat(e,"/issues"),r),this.logger.performance("Comment permission check (failed)",s),403===r.status||401===r.status?(this.logger.warn("Token does not have permission to access issues/comments",{owner:t,repo:e,error:r.message,status:r.status}),!1):(this.logger.warn("Could not determine comment permissions, assuming available",{owner:t,repo:e,error:r.message}),!0)}}isAuth(){return this.isAuthenticated&&null!==this.octokit}async getCurrentUser(){if(!this.isAuth())throw new Error("Not authenticated with GitHub");try{const{data:t}=await this.octokit.rest.users.getAuthenticated();return t}catch(t){throw console.error("Failed to fetch user data:",t),t}}async getUserOrganizations(){if(!this.isAuth())throw new Error("Not authenticated with GitHub");try{const{data:t}=await this.octokit.rest.orgs.listForAuthenticatedUser();return t}catch(t){throw console.error("Failed to fetch organizations:",t),t}}async getOrganization(t){try{const e=this.octokit||new s.Octokit,{data:o}=await e.rest.orgs.get({org:t});return o}catch(e){throw console.error("Failed to fetch organization ".concat(t,":"),e),e}}async getUser(t){try{const e=this.octokit||new s.Octokit,{data:o}=await e.rest.users.getByUsername({username:t});return o}catch(e){throw console.error("Failed to fetch user ".concat(t,":"),e),e}}async getPublicRepositories(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"user";try{const o=this.octokit||new s.Octokit;let r=[],n=1,a=!0;for(;a;){let s;s="user"===e?await o.rest.repos.listForUser({username:t,sort:"updated",per_page:100,page:n}):await o.rest.repos.listForOrg({org:t,sort:"updated",per_page:100,page:n}),r=r.concat(s.data),a=100===s.data.length,n++}return r}catch(o){throw console.error("Failed to fetch public repositories for ".concat(t,":"),o),o}}async getWHOOrganization(){try{const t=await this.getOrganization("WorldHealthOrganization");return{id:t.id,login:t.login,display_name:t.name||"World Health Organization",description:t.description||"The World Health Organization is a specialized agency of the United Nations responsible for international public health.",avatar_url:t.avatar_url,html_url:t.html_url,type:"Organization",permissions:{can_create_repositories:!0,can_create_private_repositories:!0},plan:{name:"Organization",private_repos:"unlimited"},isWHO:!0}}catch(t){return console.warn("Could not fetch WHO organization data from API, using fallback:",t),{id:"who-organization",login:"WorldHealthOrganization",display_name:"World Health Organization",description:"The World Health Organization is a specialized agency of the United Nations responsible for international public health.",avatar_url:"https://avatars.githubusercontent.com/u/12261302?s=200&v=4",html_url:"https://github.com/WorldHealthOrganization",type:"Organization",permissions:{can_create_repositories:!0,can_create_private_repositories:!0},plan:{name:"Organization",private_repos:"unlimited"},isWHO:!0}}}async getRepositories(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"user";return arguments.length>2&&void 0!==arguments[2]&&arguments[2]||"demo-user"===t?this.getDemoRepositories(t):this.getSmartGuidelinesRepositories(t,e)}getDemoRepositories(t){const e=[{id:"demo-smart-anc",name:"smart-anc",full_name:"".concat(t,"/smart-anc"),description:"Demo SMART Guidelines Digital Adaptation Kit for Antenatal Care",private:!1,owner:{login:t,id:"demo-owner",avatar_url:"https://github.com/".concat(t,".png"),type:"User"},html_url:"https://github.com/".concat(t,"/smart-anc"),clone_url:"https://github.com/".concat(t,"/smart-anc.git"),language:"FSH",stargazers_count:15,forks_count:3,open_issues_count:2,topics:["who","smart-guidelines","dak","antenatal-care","health"],created_at:"2023-01-15T10:00:00Z",updated_at:"2024-12-15T14:30:00Z",pushed_at:"2024-12-15T14:30:00Z",default_branch:"main",smart_guidelines_compatible:!0,isDemo:!0},{id:"demo-smart-tb",name:"smart-tb",full_name:"".concat(t,"/smart-tb"),description:"Demo SMART Guidelines Digital Adaptation Kit for Tuberculosis Care",private:!1,owner:{login:t,id:"demo-owner",avatar_url:"https://github.com/".concat(t,".png"),type:"User"},html_url:"https://github.com/".concat(t,"/smart-tb"),clone_url:"https://github.com/".concat(t,"/smart-tb.git"),language:"FSH",stargazers_count:8,forks_count:1,open_issues_count:0,topics:["who","smart-guidelines","dak","tuberculosis","health"],created_at:"2023-03-20T15:00:00Z",updated_at:"2024-11-30T09:15:00Z",pushed_at:"2024-11-30T09:15:00Z",default_branch:"main",smart_guidelines_compatible:!0,isDemo:!0},{id:"demo-smart-ips-pilgrimage",name:"smart-ips-pilgrimage",full_name:"".concat(t,"/smart-ips-pilgrimage"),description:"Demo SMART Guidelines International Patient Summary for Pilgrimage",private:!1,owner:{login:t,id:"demo-owner",avatar_url:"https://github.com/".concat(t,".png"),type:"User"},html_url:"https://github.com/".concat(t,"/smart-ips-pilgrimage"),clone_url:"https://github.com/".concat(t,"/smart-ips-pilgrimage.git"),language:"FSH",stargazers_count:12,forks_count:2,open_issues_count:1,topics:["who","smart-guidelines","dak","ips","pilgrimage","health"],created_at:"2023-06-10T12:00:00Z",updated_at:"2024-12-01T16:45:00Z",pushed_at:"2024-12-01T16:45:00Z",default_branch:"main",smart_guidelines_compatible:!0,isDemo:!0}];return Promise.resolve(e)}async checkSmartGuidelinesCompatibility(t,e){let o=arguments.length>2&&void 0!==arguments[2]?arguments[2]:2;const r=a.get(t,e);if(null!==r)return r;try{const o=this.octokit||new s.Octokit,{data:r}=await o.rest.repos.getContent({owner:t,repo:e,path:"sushi-config.yaml"});if("file"===r.type&&r.content){const o=decodeURIComponent(escape(atob(r.content))).includes("smart.who.int.base");return a.set(t,e,o),o}return a.set(t,e,!1),!1}catch(n){if(404===n.status&&o>0){console.warn("File not found for ".concat(t,"/").concat(e,", retrying... (").concat(o," attempts left)"));const r=1e3;return await new Promise(t=>setTimeout(t,r)),this.checkSmartGuidelinesCompatibility(t,e,o-1)}return console.warn("Failed to check ".concat(t,"/").concat(e," for sushi-config.yaml with smart.who.int.base dependency:"),n.message),a.set(t,e,!1),!1}}async getSmartGuidelinesRepositories(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"user";try{let o=[];if(this.isAuth()){let r=1,s=!0;for(;s;){let n;n="user"===e?await this.octokit.rest.repos.listForUser({username:t,sort:"updated",per_page:100,page:r}):await this.octokit.rest.repos.listForOrg({org:t,sort:"updated",per_page:100,page:r}),o=o.concat(n.data),s=100===n.data.length,r++}}else o=await this.getPublicRepositories(t,e);const s=[];for(const t of o){await this.checkSmartGuidelinesCompatibility(t.owner.login,t.name)&&s.push((0,r.A)((0,r.A)({},t),{},{smart_guidelines_compatible:!0}))}return s}catch(o){throw console.error("Failed to fetch SMART guidelines repositories:",o),o}}async getSmartGuidelinesRepositoriesProgressive(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"user",o=arguments.length>2&&void 0!==arguments[2]?arguments[2]:null,s=arguments.length>3&&void 0!==arguments[3]?arguments[3]:null;if(!this.isAuth())throw new Error("Not authenticated with GitHub");try{let a=[],i=1,c=!0;for(;c;){let o;o="user"===e?await this.octokit.rest.repos.listForUser({username:t,sort:"updated",per_page:100,page:i}):await this.octokit.rest.repos.listForOrg({org:t,sort:"updated",per_page:100,page:i}),a=a.concat(o.data),c=100===o.data.length,i++}if(0===a.length)return console.log("\ud83d\udcca No repositories found for user, completing scan immediately"),s&&s({current:0,total:0,currentRepo:"none",progress:100,completed:!0}),[];const l=async(t,e)=>{await new Promise(t=>setTimeout(t,100+200*Math.random()));if(await this.checkSmartGuidelinesCompatibility(t.owner.login,t.name)){const e=(0,r.A)((0,r.A)({},t),{},{smart_guidelines_compatible:!0});return o&&o(e),e}return null},h=await n(a,l,{concurrency:5,onProgress:(t,e,o,r)=>{s&&s({current:t,total:e,currentRepo:o.name,progress:Math.round(t/e*100),completed:!0})},onItemStart:(t,e)=>{s&&s({current:e+1,total:a.length,currentRepo:t.name,progress:Math.round((e+1)/a.length*100),completed:!1,started:!0})}});return h.filter(t=>null!==t&&!t.error)}catch(a){throw console.error("Failed to fetch SMART guidelines repositories:",a),a}}async getRepository(t,e){try{const o=this.isAuth()?this.octokit:new s.Octokit,{data:r}=await o.rest.repos.get({owner:t,repo:e});return r}catch(o){throw console.error("Failed to fetch repository:",o),o}}async getBranches(t,e){try{console.log("githubService.getBranches: Fetching branches for ".concat(t,"/").concat(e)),console.log("githubService.getBranches: Authentication status:",this.isAuth());const o=this.isAuth()?this.octokit:new s.Octokit;console.log("githubService.getBranches: Using",this.isAuth()?"authenticated":"public","octokit instance");const{data:r}=await o.rest.repos.listBranches({owner:t,repo:e,per_page:100});return console.log("githubService.getBranches: Successfully fetched ".concat(r.length," branches")),r}catch(o){throw console.error("githubService.getBranches: Failed to fetch branches:",o),console.error("githubService.getBranches: Error details:",{status:o.status,message:o.message,owner:t,repo:e}),o}}async createBranch(t,e,o){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:"main";if(!this.isAuth())throw new Error("Not authenticated with GitHub");try{const{data:s}=await this.octokit.rest.git.getRef({owner:t,repo:e,ref:"heads/".concat(r)}),{data:n}=await this.octokit.rest.git.createRef({owner:t,repo:e,ref:"refs/heads/".concat(o),sha:s.object.sha});return n}catch(s){throw console.error("Failed to create branch:",s),s}}async getBranch(t,e,o){try{const r=this.isAuth()?this.octokit:new s.Octokit,{data:n}=await r.rest.repos.getBranch({owner:t,repo:e,branch:o});return n}catch(r){throw console.error("Failed to fetch branch:",r),r}}async getWorkflows(t,e){if(!this.isAuth())throw new Error("Not authenticated with GitHub");try{const{data:o}=await this.octokit.rest.actions.listRepoWorkflows({owner:t,repo:e});return o.workflows.map(t=>({id:t.id,name:t.name,filename:t.path.split("/").pop(),path:t.path,state:t.state,created_at:t.created_at,updated_at:t.updated_at,url:t.html_url,triggers:["unknown"],lastModified:t.updated_at}))}catch(o){if(404===o.status)return[];throw console.error("Failed to fetch workflows:",o),o}}async getWorkflowRuns(t,e){let o=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};if(!this.isAuth())throw new Error("Not authenticated with GitHub");try{const r={owner:t,repo:e,per_page:o.per_page||10,page:o.page||1};o.branch&&(r.branch=o.branch),o.workflow_id&&(r.workflow_id=o.workflow_id);const{data:s}=await this.octokit.rest.actions.listWorkflowRunsForRepo(r);return s}catch(r){throw console.error("Failed to fetch workflow runs:",r),r}}async getWorkflowRunsForWorkflow(t,e,o){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:{};if(!this.isAuth())throw new Error("Not authenticated with GitHub");try{const s={owner:t,repo:e,workflow_id:o,per_page:r.per_page||10,page:r.page||1};r.branch&&(s.branch=r.branch);const{data:n}=await this.octokit.rest.actions.listWorkflowRuns(s);return n}catch(s){throw console.error("Failed to fetch workflow runs for workflow:",s),s}}async triggerWorkflow(t,e,o){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:"main",s=arguments.length>4&&void 0!==arguments[4]?arguments[4]:{};if(!this.isAuth())throw new Error("Not authenticated with GitHub");try{const{data:n}=await this.octokit.rest.actions.createWorkflowDispatch({owner:t,repo:e,workflow_id:o,ref:r,inputs:s});return n}catch(n){throw console.error("Failed to trigger workflow:",n),n}}async rerunWorkflow(t,e,o){if(!this.isAuth())throw new Error("Not authenticated with GitHub");try{const{data:r}=await this.octokit.rest.actions.reRunWorkflow({owner:t,repo:e,run_id:o});return r}catch(r){throw console.error("Failed to re-run workflow:",r),r}}async getWorkflowRunLogs(t,e,o){if(!this.isAuth())throw new Error("Not authenticated with GitHub");try{const{data:r}=await this.octokit.rest.actions.downloadWorkflowRunLogs({owner:t,repo:e,run_id:o});return r}catch(r){throw console.error("Failed to get workflow run logs:",r),r}}async approveWorkflowRun(t,e,o){if(!this.isAuth())throw new Error("Not authenticated with GitHub");try{const{data:r}=await this.octokit.rest.actions.approveWorkflowRun({owner:t,repo:e,run_id:o});return r}catch(r){throw console.error("Failed to approve workflow run:",r),r}}async getCommitDiff(t,e,o,r){if(!this.isAuth())throw new Error("Not authenticated with GitHub");try{const{data:s}=await this.octokit.rest.repos.compareCommits({owner:t,repo:e,base:o,head:r});return s}catch(s){throw console.error("Failed to get commit diff:",s),s}}async getCommit(t,e,o){if(!this.isAuth())throw new Error("Not authenticated with GitHub");try{const{data:r}=await this.octokit.rest.repos.getCommit({owner:t,repo:e,ref:o});return r}catch(r){throw console.error("Failed to get commit details:",r),r}}async getReleases(t,e){let o=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};if(!this.isAuth())throw new Error("Not authenticated with GitHub");try{const{data:r}=await this.octokit.rest.repos.listReleases({owner:t,repo:e,per_page:o.per_page||10,page:o.page||1});return r}catch(r){throw console.error("Failed to fetch releases:",r),r}}async getLatestRelease(t,e){if(!this.isAuth())throw new Error("Not authenticated with GitHub");try{const{data:o}=await this.octokit.rest.repos.getLatestRelease({owner:t,repo:e});return o}catch(o){throw console.error("Failed to fetch latest release:",o),o}}async getBpmnFilesRecursive(t,e,o){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:"main",n=arguments.length>4&&void 0!==arguments[4]?arguments[4]:[];try{console.log("\ud83d\udd0e githubService.getBpmnFilesRecursive: Searching ".concat(t,"/").concat(e,"/").concat(o," (ref: ").concat(r,")"));const a=this.isAuth()?this.octokit:new s.Octokit;console.log("\ud83d\udd10 githubService.getBpmnFilesRecursive: Using ".concat(this.isAuth()?"authenticated":"public"," octokit"));const{data:i}=await a.rest.repos.getContent({owner:t,repo:e,path:o,ref:r});if(console.log("\ud83d\udce6 githubService.getBpmnFilesRecursive: Received data type: ".concat(Array.isArray(i)?"array":"single file",", length: ").concat(Array.isArray(i)?i.length:1)),!Array.isArray(i))return i.name.endsWith(".bpmn")&&(console.log("\ud83d\udcc4 githubService.getBpmnFilesRecursive: Found single BPMN file: ".concat(i.name)),n.push(i)),n;for(const o of i)"file"===o.type&&o.name.endsWith(".bpmn")?(console.log("\ud83d\udcc4 githubService.getBpmnFilesRecursive: Found BPMN file: ".concat(o.name)),n.push(o)):"dir"===o.type&&(console.log("\ud83d\udcc1 githubService.getBpmnFilesRecursive: Found subdirectory: ".concat(o.name,", recursing...")),await this.getBpmnFilesRecursive(t,e,o.path,r,n));return console.log("\u2705 githubService.getBpmnFilesRecursive: Completed search of ".concat(o,", found ").concat(n.length," total files so far")),n}catch(a){if(console.log("\u274c githubService.getBpmnFilesRecursive: Error searching ".concat(o,":"),a.status,a.message),404===a.status)return n;throw a}}async getBpmnFiles(t,e){let o=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"main";console.log("\ud83d\udd0d githubService.getBpmnFiles: Starting search for ".concat(t,"/").concat(e," (ref: ").concat(o,")"));const r=[],s=["input/business-processes","input/business-process"];for(const i of s)try{console.log("\ud83d\udcc1 githubService.getBpmnFiles: Searching in directory: ".concat(i));const s=await this.getBpmnFilesRecursive(t,e,i,o);console.log("\u2705 githubService.getBpmnFiles: Found ".concat(s.length," BPMN files in ").concat(i)),r.push(...s)}catch(a){404!==a.status?console.warn("\u274c Could not fetch BPMN files from ".concat(i,":"),a.message):console.log("\ud83d\udcc2 githubService.getBpmnFiles: Directory ".concat(i," not found (404) - this is expected if the directory doesn't exist"))}const n=r.filter((t,e,o)=>e===o.findIndex(e=>e.path===t.path));return console.log("\ud83c\udfaf githubService.getBpmnFiles: Final result - ".concat(n.length," unique BPMN files found")),console.log("\ud83d\udccb githubService.getBpmnFiles: File list:",n.map(t=>t.name)),n}async getFileContent(t,e,o){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:"main";const n=15e3;try{console.log("\ud83d\ude80 githubService.getFileContent: Starting request for ".concat(t,"/").concat(e,"/").concat(o," (ref: ").concat(r,")")),console.log("\ud83d\udd10 githubService.getFileContent: Authentication status:",this.isAuth()),console.log("\ud83d\udccb githubService.getFileContent: Request parameters:",{owner:t,repo:e,path:o,ref:r});const a=this.isAuth()?this.octokit:new s.Octokit;console.log("\ud83d\udd27 githubService.getFileContent: Using",this.isAuth()?"authenticated":"public","octokit instance");const i=new Promise((t,e)=>{console.log("\u23f0 githubService.getFileContent: Setting up ".concat(n,"ms timeout")),setTimeout(()=>{console.error("\u23f0 githubService.getFileContent: Request timed out after ".concat(n,"ms")),e(new Error("Request timeout after ".concat(n,"ms")))},n)});console.log("\ud83c\udf10 githubService.getFileContent: Creating GitHub API promise...");const c=a.rest.repos.getContent({owner:t,repo:e,path:o,ref:r});console.log("\ud83d\udce1 githubService.getFileContent: API request initiated, waiting for response...");const l=Date.now(),{data:h}=await Promise.race([c,i]),u=Date.now()-l;if(console.log("\u2705 githubService.getFileContent: API response received in ".concat(u,"ms")),console.log("\ud83d\udcc2 githubService.getFileContent: Response data type:",h.type),console.log("\ud83d\udcca githubService.getFileContent: Response details:",{type:h.type,name:h.name,size:h.size,encoding:h.encoding,hasContent:!!h.content}),"file"===h.type&&h.content){console.log("\ud83d\udd27 githubService.getFileContent: Decoding base64 content..."),console.log("\ud83d\udcca githubService.getFileContent: Base64 content length:",h.content.length);const t=decodeURIComponent(escape(atob(h.content)));return console.log("\u2705 githubService.getFileContent: Successfully fetched and decoded file content"),console.log("\ud83d\udccf githubService.getFileContent: Final content length:",t.length,"characters"),console.log("\ud83d\udc40 githubService.getFileContent: Content preview (first 200 chars):",t.substring(0,200)),t}throw console.error("\u274c githubService.getFileContent: Invalid response - not a file or no content"),console.error("\ud83d\udd0d githubService.getFileContent: Full response data:",JSON.stringify(h,null,2)),new Error("File not found or is not a file")}catch(i){var a;if(console.error("\ud83d\udca5 githubService.getFileContent: Failed to fetch file content from ".concat(t,"/").concat(e,"/").concat(o,":"),i),console.error("\ud83d\udd0d githubService.getFileContent: Error analysis:",{type:typeof i,status:i.status,message:i.message,name:i.name,stack:(null===(a=i.stack)||void 0===a?void 0:a.substring(0,500))+"..."}),i.message.includes("timeout"))throw console.error("\u23f0 githubService.getFileContent: Timeout error detected"),new Error("GitHub API request timed out after ".concat(15," seconds. Please try again."));if(403===i.status)throw console.error("\ud83d\udd12 githubService.getFileContent: 403 Forbidden error detected"),new Error("Access denied. This repository may be private or you may have hit rate limits.");if(404===i.status)throw console.error("\ud83d\udd0d githubService.getFileContent: 404 Not Found error detected"),new Error("File not found in the repository.");if(i.message.includes("rate limit"))throw console.error("\ud83d\udea6 githubService.getFileContent: Rate limit error detected"),new Error("GitHub API rate limit exceeded. Please try again later.");if(i.message.includes("Network Error")||i.message.includes("Failed to fetch"))throw console.error("\ud83c\udf10 githubService.getFileContent: Network error detected"),new Error("Network error occurred. Please check your internet connection and try again.");throw console.error("\u2753 githubService.getFileContent: Unknown error type, re-throwing original error"),i}}async createCommit(t,e,o,r,s){if(!this.isAuth())throw new Error("Not authenticated with GitHub");try{const{data:n}=await this.octokit.rest.git.getRef({owner:t,repo:e,ref:"heads/".concat(o)}),a=n.object.sha,{data:i}=await this.octokit.rest.git.getCommit({owner:t,repo:e,commit_sha:a}),c=i.tree.sha,l=await Promise.all(s.map(async o=>{const{data:r}=await this.octokit.rest.git.createBlob({owner:t,repo:e,content:o.content,encoding:"utf-8"});return{path:o.path,mode:"100644",type:"blob",sha:r.sha}})),{data:h}=await this.octokit.rest.git.createTree({owner:t,repo:e,base_tree:c,tree:l}),{data:u}=await this.octokit.rest.git.createCommit({owner:t,repo:e,message:r,tree:h.sha,parents:[a]});return await this.octokit.rest.git.updateRef({owner:t,repo:e,ref:"heads/".concat(o),sha:u.sha}),{sha:u.sha,html_url:"https://github.com/".concat(t,"/").concat(e,"/commit/").concat(u.sha),message:u.message,author:u.author,committer:u.committer}}catch(n){throw console.error("Failed to create commit:",n),n}}async getRecentCommits(t,e){let o=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"main",r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:5;if(!this.isAuth())throw new Error("Not authenticated with GitHub");const s=Date.now();this.logger.apiCall("GET","/repos/".concat(t,"/").concat(e,"/commits"),{sha:o,per_page:r});try{const n=await this.octokit.rest.repos.listCommits({owner:t,repo:e,sha:o,per_page:r});return this.logger.apiResponse("GET","/repos/".concat(t,"/").concat(e,"/commits"),n.status,Date.now()-s),n.data.map(t=>({sha:t.sha,message:t.commit.message,author:{name:t.commit.author.name,email:t.commit.author.email,date:t.commit.author.date},committer:{name:t.commit.committer.name,email:t.commit.committer.email,date:t.commit.committer.date},html_url:t.html_url,stats:t.stats}))}catch(n){throw this.logger.apiResponse("GET","/repos/".concat(t,"/").concat(e,"/commits"),n.status||"error",Date.now()-s),console.error("Failed to fetch recent commits:",n),n}}async getOpenPullRequestsCount(t,e){if(!this.isAuth())throw new Error("Not authenticated with GitHub");const o=Date.now();this.logger.apiCall("GET","/repos/".concat(t,"/").concat(e,"/pulls"),{state:"open",per_page:1});try{const r=await this.octokit.rest.pulls.list({owner:t,repo:e,state:"open",per_page:1});this.logger.apiResponse("GET","/repos/".concat(t,"/").concat(e,"/pulls"),r.status,Date.now()-o);const s=r.headers.link;if(s&&s.includes('rel="last"')){const t=s.match(/page=(\d+)>; rel="last"/);if(t)return parseInt(t[1],10)}return r.data.length}catch(r){throw this.logger.apiResponse("GET","/repos/".concat(t,"/").concat(e,"/pulls"),r.status||"error",Date.now()-o),console.error("Failed to fetch pull requests count:",r),r}}async getPullRequestForBranch(t,e,o){const r=await this.getPullRequestsForBranch(t,e,o);return r&&r.length>0?r[0]:null}async getPullRequestsForBranch(t,e,o){const r=this.isAuth()?this.octokit:new s.Octokit,n=Date.now();this.logger.apiCall("GET","/repos/".concat(t,"/").concat(e,"/pulls"),{state:"open",head:"".concat(t,":").concat(o)});try{const s=await r.rest.pulls.list({owner:t,repo:e,state:"open",head:"".concat(t,":").concat(o),per_page:100});return this.logger.apiResponse("GET","/repos/".concat(t,"/").concat(e,"/pulls"),s.status,Date.now()-n),s.data||[]}catch(a){return this.logger.apiResponse("GET","/repos/".concat(t,"/").concat(e,"/pulls"),a.status||"error",Date.now()-n),console.error("Failed to fetch pull requests for branch:",a),[]}}async getPullRequestComments(t,e,o){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1,n=arguments.length>4&&void 0!==arguments[4]?arguments[4]:100;const a=this.isAuth()?this.octokit:new s.Octokit,i=Date.now();this.logger.apiCall("GET","/repos/".concat(t,"/").concat(e,"/pulls/").concat(o,"/comments"),{page:r,per_page:n});try{const s=await a.rest.pulls.listReviewComments({owner:t,repo:e,pull_number:o,page:r,per_page:n});return this.logger.apiResponse("GET","/repos/".concat(t,"/").concat(e,"/pulls/").concat(o,"/comments"),s.status,Date.now()-i),s.data}catch(c){throw this.logger.apiResponse("GET","/repos/".concat(t,"/").concat(e,"/pulls/").concat(o,"/comments"),c.status||"error",Date.now()-i),console.error("Failed to fetch pull request comments:",c),c}}async getPullRequestIssueComments(t,e,o){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1,n=arguments.length>4&&void 0!==arguments[4]?arguments[4]:100;const a=this.isAuth()?this.octokit:new s.Octokit,i=Date.now();this.logger.apiCall("GET","/repos/".concat(t,"/").concat(e,"/issues/").concat(o,"/comments"),{page:r,per_page:n});try{const s=await a.rest.issues.listComments({owner:t,repo:e,issue_number:o,page:r,per_page:n});return this.logger.apiResponse("GET","/repos/".concat(t,"/").concat(e,"/issues/").concat(o,"/comments"),s.status,Date.now()-i),s.data}catch(c){throw this.logger.apiResponse("GET","/repos/".concat(t,"/").concat(e,"/issues/").concat(o,"/comments"),c.status||"error",Date.now()-i),console.error("Failed to fetch pull request issue comments:",c),c}}async createPullRequestComment(t,e,o,r){if(!this.isAuth())throw new Error("Not authenticated with GitHub");const s=Date.now();this.logger.apiCall("POST","/repos/".concat(t,"/").concat(e,"/issues/").concat(o,"/comments"),{body:r});try{const n=await this.octokit.rest.issues.createComment({owner:t,repo:e,issue_number:o,body:r});return this.logger.apiResponse("POST","/repos/".concat(t,"/").concat(e,"/issues/").concat(o,"/comments"),n.status,Date.now()-s),n.data}catch(n){throw this.logger.apiResponse("POST","/repos/".concat(t,"/").concat(e,"/issues/").concat(o,"/comments"),n.status||"error",Date.now()-s),console.error("Failed to create pull request comment:",n),n}}async getOpenIssuesCount(t,e){if(!this.isAuth())throw new Error("Not authenticated with GitHub");const o=Date.now();this.logger.apiCall("GET","/repos/".concat(t,"/").concat(e,"/issues"),{state:"open",per_page:1});try{const r=await this.octokit.rest.issues.listForRepo({owner:t,repo:e,state:"open",per_page:1});this.logger.apiResponse("GET","/repos/".concat(t,"/").concat(e,"/issues"),r.status,Date.now()-o);const s=r.headers.link;if(s&&s.includes('rel="last"')){const t=s.match(/page=(\d+)>; rel="last"/);if(t)return parseInt(t[1],10)}return r.data.length}catch(r){throw this.logger.apiResponse("GET","/repos/".concat(t,"/").concat(e,"/issues"),r.status||"error",Date.now()-o),console.error("Failed to fetch issues count:",r),r}}async getRepositoryStats(t,e){let o=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"main";if(!this.isAuth())throw new Error("Not authenticated with GitHub");try{const[r,s,n]=await Promise.allSettled([this.getRecentCommits(t,e,o,1),this.getOpenPullRequestsCount(t,e),this.getOpenIssuesCount(t,e)]);return{recentCommits:"fulfilled"===r.status?r.value:[],openPullRequestsCount:"fulfilled"===s.status?s.value:0,openIssuesCount:"fulfilled"===n.status?n.value:0,errors:{recentCommits:"rejected"===r.status?r.reason:null,openPullRequestsCount:"rejected"===s.status?s.reason:null,openIssuesCount:"rejected"===n.status?n.reason:null}}}catch(r){throw console.error("Failed to fetch repository stats:",r),r}}async getDirectoryContents(t,e){let o=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"",r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:"main";try{const n=this.isAuth()?this.octokit:new s.Octokit,{data:a}=await n.rest.repos.getContent({owner:t,repo:e,path:o,ref:r});if(Array.isArray(a))return a;throw new Error("Not a directory")}catch(n){throw console.error("Failed to get directory contents for ".concat(o,":"),n),n}}async updateFile(t,e,o,r,s){let n=arguments.length>5&&void 0!==arguments[5]?arguments[5]:"main";if(!this.isAuth())throw new Error("Authentication required to update files");try{const{data:a}=await this.octokit.rest.repos.getContent({owner:t,repo:e,path:o,ref:n});if(Array.isArray(a))throw new Error("Path is a directory, not a file");const{data:i}=await this.octokit.rest.repos.createOrUpdateFileContents({owner:t,repo:e,path:o,message:s,content:btoa(unescape(encodeURIComponent(r))),sha:a.sha,branch:n});return i}catch(a){throw console.error("Failed to update file ".concat(o,":"),a),a}}async getCommits(t,e){let o=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};try{const r=this.isAuth()?this.octokit:new s.Octokit,n={owner:t,repo:e,per_page:o.per_page||10,page:o.page||1};o.sha&&(n.sha=o.sha),o.since&&(n.since=o.since),o.until&&(n.until=o.until);const{data:a}=await r.rest.repos.listCommits(n);return a}catch(r){throw console.error("Failed to fetch commits:",r),r}}async getIssues(t,e){let o=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};try{const r=this.isAuth()?this.octokit:new s.Octokit,n={owner:t,repo:e,state:o.state||"all",per_page:o.per_page||30,page:o.page||1};o.labels&&(n.labels=o.labels),o.milestone&&(n.milestone=o.milestone);const{data:a}=await r.rest.issues.listForRepo(n);return a}catch(r){throw console.error("Failed to fetch issues:",r),r}}async getRepositoryIssues(t,e){let o=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};return this.getIssues(t,e,o)}async getForks(t,e){let o=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};const r=Date.now();this.logger.apiCall("GET","/repos/".concat(t,"/").concat(e,"/forks"),o);try{const n=this.isAuth()?this.octokit:new s.Octokit,a={owner:t,repo:e,sort:o.sort||"newest",per_page:o.per_page||100,page:o.page||1},{data:i}=await n.rest.repos.listForks(a);return this.logger.apiResponse("GET","/repos/".concat(t,"/").concat(e,"/forks"),200,Date.now()-r),i.map(t=>({id:t.id,name:t.name,full_name:t.full_name,owner:{login:t.owner.login,avatar_url:t.owner.avatar_url,html_url:t.owner.html_url,type:t.owner.type},description:t.description,html_url:t.html_url,clone_url:t.clone_url,created_at:t.created_at,updated_at:t.updated_at,pushed_at:t.pushed_at,stargazers_count:t.stargazers_count,forks_count:t.forks_count,open_issues_count:t.open_issues_count,default_branch:t.default_branch,private:t.private,fork:t.fork,parent:t.parent?{full_name:t.parent.full_name,html_url:t.parent.html_url}:null}))}catch(n){throw this.logger.apiResponse("GET","/repos/".concat(t,"/").concat(e,"/forks"),n.status||"error",Date.now()-r),console.error("Failed to fetch repository forks:",n),n}}async getPullRequests(t,e){let o=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};const r=Date.now();this.logger.apiCall("GET","/repos/".concat(t,"/").concat(e,"/pulls"),o);try{const n=this.isAuth()?this.octokit:new s.Octokit,a={owner:t,repo:e,state:o.state||"open",sort:o.sort||"updated",direction:o.direction||"desc",per_page:o.per_page||30,page:o.page||1};o.head&&(a.head=o.head),o.base&&(a.base=o.base);const{data:i}=await n.rest.pulls.list(a);return this.logger.apiResponse("GET","/repos/".concat(t,"/").concat(e,"/pulls"),200,Date.now()-r),i.map(t=>({id:t.id,number:t.number,title:t.title,body:t.body,state:t.state,locked:t.locked,user:{login:t.user.login,avatar_url:t.user.avatar_url,html_url:t.user.html_url,type:t.user.type},created_at:t.created_at,updated_at:t.updated_at,closed_at:t.closed_at,merged_at:t.merged_at,html_url:t.html_url,diff_url:t.diff_url,patch_url:t.patch_url,head:{ref:t.head.ref,sha:t.head.sha,repo:t.head.repo?{name:t.head.repo.name,full_name:t.head.repo.full_name,owner:{login:t.head.repo.owner.login,avatar_url:t.head.repo.owner.avatar_url},html_url:t.head.repo.html_url}:null},base:{ref:t.base.ref,sha:t.base.sha,repo:{name:t.base.repo.name,full_name:t.base.repo.full_name,owner:{login:t.base.repo.owner.login,avatar_url:t.base.repo.owner.avatar_url},html_url:t.base.repo.html_url}},draft:t.draft,mergeable:t.mergeable,mergeable_state:t.mergeable_state,comments:t.comments,review_comments:t.review_comments,commits:t.commits,additions:t.additions,deletions:t.deletions,changed_files:t.changed_files}))}catch(n){throw this.logger.apiResponse("GET","/repos/".concat(t,"/").concat(e,"/pulls"),n.status||"error",Date.now()-r),console.error("Failed to fetch pull requests:",n),n}}logout(){this.logger.auth("Logging out and clearing stored token"),this.octokit=null,this.isAuthenticated=!1,this.tokenType=null,this.permissions=null,c.clearToken();try{const{default:t}=o(88691);t.clearAllBranchContext()}catch(t){sessionStorage.removeItem("sgex_branch_context")}}async getRepositoryForks(t,e){let o=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};const r=Date.now();this.logger.debug("Fetching repository forks",{owner:t,repo:e,options:o});try{const n=this.isAuth()?this.octokit:new s.Octokit;this.logger.apiCall("GET","/repos/".concat(t,"/").concat(e,"/forks"),o);const{data:a}=await n.rest.repos.listForks({owner:t,repo:e,sort:"newest",per_page:o.per_page||100,page:o.page||1}),i=Date.now()-r;return this.logger.apiResponse("GET","/repos/".concat(t,"/").concat(e,"/forks"),200,i,{forkCount:a.length}),this.logger.performance("Repository forks fetch",i),a}catch(n){const o=Date.now()-r;throw this.logger.apiError("GET","/repos/".concat(t,"/").concat(e,"/forks"),n),this.logger.performance("Repository forks fetch (failed)",o),console.error("Failed to fetch forks for ".concat(t,"/").concat(e,":"),n),n}}}},88691:(t,e,o)=>{o.r(e),o.d(e,{default:()=>r});const r=new class{constructor(){this.storageKey="sgex_branch_context"}getRepositoryKey(t){var e,o;if(!t||!t.name)return null;const r=(null===(e=t.owner)||void 0===e?void 0:e.login)||(null===(o=t.full_name)||void 0===o?void 0:o.split("/")[0]);return r?"".concat(r,"/").concat(t.name):null}getSelectedBranch(t){if(!t)return null;try{const e=this.getBranchContext();return e[this.getRepositoryKey(t)]||null}catch(e){return console.warn("Failed to get branch context:",e),null}}setSelectedBranch(t,e){if(t&&e)try{const o=this.getBranchContext();o[this.getRepositoryKey(t)]=e,this.setBranchContext(o)}catch(o){console.warn("Failed to set branch context:",o)}}clearRepositoryBranch(t){if(t)try{const e=this.getBranchContext();delete e[this.getRepositoryKey(t)],this.setBranchContext(e)}catch(e){console.warn("Failed to clear repository branch context:",e)}}clearAllBranchContext(){try{sessionStorage.removeItem(this.storageKey)}catch(t){console.warn("Failed to clear branch context:",t)}}getBranchContext(){try{const t=sessionStorage.getItem(this.storageKey);return t?JSON.parse(t):{}}catch(t){return console.warn("Failed to parse branch context from storage:",t),{}}}setBranchContext(t){try{sessionStorage.setItem(this.storageKey,JSON.stringify(t))}catch(e){console.warn("Failed to save branch context to storage:",e)}}getDefaultBranchName(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:[];return t?e.some(t=>"main"===t.name)?"main":t.default_branch&&e.some(e=>e.name===t.default_branch)?t.default_branch:e.length>0?e[0].name:"main":"main"}hasBranchContext(t){return null!==this.getSelectedBranch(t)}getBranchDisplayInfo(t){const e=this.getSelectedBranch(t);if(!e)return null;const o=e===((null===t||void 0===t?void 0:t.default_branch)||"main");return{branch:e,isDefault:o,displayText:o?"".concat(e," (default)"):e}}}}}]);
//# sourceMappingURL=404.64ee188f.chunk.js.map