"use strict";(self.webpackChunksgex_workbench=self.webpackChunksgex_workbench||[]).push([[7018],{49162:(e,t,s)=>{s.d(t,{Q5:()=>n,hI:()=>a,kv:()=>c,q_:()=>i,uC:()=>o,x:()=>r});const r={DAK:"dak",COMPONENT:"component",ASSET:"asset"};class n{constructor(e){let{id:t,level:s,title:r,description:n,parameters:a=[],tags:i=[],version:o="1.0.0",isTemplate:c=!1,componentTypes:l=[],assetTypes:u=[]}=e;this.id=t,this.level=s,this.title=r,this.description=n,this.parameters=a,this.tags=i,this.version=o,this.isTemplate=c,this.componentTypes=l,this.assetTypes=u}}class a{constructor(e){let{name:t,type:s="string",required:r=!1,description:n="",defaultValue:a=null,validation:i={}}=e;this.name=t,this.type=s,this.required=r,this.description=n,this.defaultValue=a,this.validation=i}}class i{constructor(e){let{repository:t,locale:s="en_US",branch:r="main",user:n=null,assetFile:a=null,componentType:i=null,storage:o=null}=e;this.repository=t,this.locale=s,this.branch=r,this.user=n,this.assetFile=a,this.componentType=i,this.storage=o}}class o{constructor(e){let{structured:t={},narrative:s="",warnings:r=[],errors:n=[],meta:a={}}=e;this.structured=t,this.narrative=s,this.warnings=r,this.errors=n,this.meta=a}}class c{constructor(e){let{scope:t="repository",key:s="",ttl:r=3600,dependencies:n=[]}=e;this.scope=t,this.key=s,this.ttl=r,this.dependencies=n}}},87018:(e,t,s)=>{s.d(t,{A:()=>u});var r=s(89379),n=s(49162),a=s(16558);const i=new class{constructor(){this.registry=null,this.loaded=!1}loadFromYaml(e){try{this.registry=a.default.load(e),this.loaded=!0}catch(t){throw new Error("Failed to parse parameter registry YAML: ".concat(t.message))}}getParameters(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null;if(!this.loaded||!this.registry)throw new Error("Parameter registry not loaded");const s=[];if(this.registry.defaults)for(const[r,i]of Object.entries(this.registry.defaults))s.push(new n.hI({name:r,type:i.type,required:i.required||!1,description:i.description||"",defaultValue:i.default||null,validation:i.validation||{}}));if(this.registry[e])if(t&&this.registry[e][t])for(const[i,o]of Object.entries(this.registry[e][t]))s.push(new n.hI((0,r.A)({name:i},o)));else if(!t)for(const[i,o]of Object.entries(this.registry[e]))"object"===typeof o&&o.type&&s.push(new n.hI((0,r.A)({name:i},o)));const a=new Map;return s.forEach(e=>{a.set(e.name,e)}),Array.from(a.values())}validateParameters(e,t){let s=arguments.length>2&&void 0!==arguments[2]?arguments[2]:null;const r=this.getParameters(t,s),n={},a=[];for(const i of r){const t=e[i.name];if(i.required&&(void 0===t||null===t)){a.push("Required parameter '".concat(i.name,"' is missing"));continue}const s=void 0!==t?t:i.defaultValue;if(null!==s&&void 0!==s){const e=this.validateParameterType(s,i);if(e){a.push("Parameter '".concat(i.name,"': ").concat(e));continue}const t=this.validateParameterCustom(s,i);if(t){a.push("Parameter '".concat(i.name,"': ").concat(t));continue}}n[i.name]=s}for(const i of Object.keys(e))r.find(e=>e.name===i)||a.push("Unknown parameter '".concat(i,"'"));return{normalized:n,errors:a,isValid:0===a.length}}validateParameterType(e,t){const s=t.type,r=typeof e;switch(s){case"string":if("string"!==r)return"Expected string, got ".concat(r);break;case"boolean":if("boolean"!==r)return"Expected boolean, got ".concat(r);break;case"number":if("number"!==r||isNaN(e))return"Expected number, got ".concat(r);break;case"array":if(!Array.isArray(e))return"Expected array, got ".concat(r);break;case"object":if("object"!==r||Array.isArray(e))return"Expected object, got ".concat(r);break;default:return"Unknown type: ".concat(s)}return null}validateParameterCustom(e,t){if(!t.validation)return null;const s=t.validation;if(s.pattern&&"string"===typeof e){if(!new RegExp(s.pattern).test(e))return"Value does not match pattern ".concat(s.pattern)}return s.enum&&Array.isArray(s.enum)&&!s.enum.includes(e)?"Value must be one of: ".concat(s.enum.join(", ")):void 0!==s.minLength&&"string"===typeof e&&e.length<s.minLength?"String must be at least ".concat(s.minLength," characters"):void 0!==s.maxLength&&"string"===typeof e&&e.length>s.maxLength?"String must be at most ".concat(s.maxLength," characters"):void 0!==s.min&&"number"===typeof e&&e<s.min?"Number must be at least ".concat(s.min):void 0!==s.max&&"number"===typeof e&&e>s.max?"Number must be at most ".concat(s.max):null}getParameterSchema(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null;const s=this.getParameters(e,t),r={},n=[];for(const a of s){const e={type:a.type,description:a.description};null!==a.defaultValue&&(e.default=a.defaultValue),a.validation&&Object.assign(e,a.validation),r[a.name]=e,a.required&&n.push(a.name)}return{type:"object",properties:r,required:n}}};i.loadFromYaml('\ndefaults:\n  repository:\n    type: string\n    required: true\n    description: "Repository context (always required)"\n  locale:\n    type: string\n    required: false\n    default: "en_US"\n    description: "Locale for responses"\n  branch:\n    type: string\n    required: false\n    default: "main"\n    description: "Git branch context"\n\ndak:\n\ncomponent:\n  businessProcess:\n    componentType:\n      type: string\n      required: true\n      default: "businessProcess"\n      description: "Type of component being analyzed"\n\nasset:\n  lesson:\n    assetFile:\n      type: string\n      required: true\n      description: "Relative path to the lesson file"\n');const o=i;class c{async readFile(e){throw new Error("readFile must be implemented by subclass")}async fileExists(e){throw new Error("fileExists must be implemented by subclass")}async listFiles(e){throw new Error("listFiles must be implemented by subclass")}async getFileInfo(e){throw new Error("getFileInfo must be implemented by subclass")}}class l extends c{constructor(e,t){let s=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"main";super(),this.githubService=e,this.repository=t,this.branch=s,this.cache=new Map}parseRepository(e){if("string"===typeof e){if(e.includes("github.com")){const t=e.match(/github\.com\/([^/]+)\/([^/?#]+)/);if(t)return{owner:t[1],repo:t[2].replace(/\.git$/,"")}}const t=e.split("/");if(2===t.length)return{owner:t[0],repo:t[1]}}throw new Error("Invalid repository format: ".concat(e))}async readFile(e){const t="".concat(this.repository,":").concat(this.branch,":").concat(e);if(this.cache.has(t))return console.log("GitHubStorage.readFile: Cache hit for ".concat(e)),this.cache.get(t);try{const{owner:s,repo:r}=this.parseRepository(this.repository);console.log("GitHubStorage.readFile: Reading file ".concat(e," from ").concat(s,"/").concat(r," (branch: ").concat(this.branch,")"));const n=await this.githubService.getFileContent(s,r,e,this.branch),a=Buffer.from(n.content,"base64");return this.cache.set(t,a),console.log("GitHubStorage.readFile: Successfully read file ".concat(e,", size: ").concat(a.length," bytes")),a}catch(s){throw console.error("GitHubStorage.readFile: Failed to read file ".concat(e,":"),s.message),new Error("Failed to read file ".concat(e,": ").concat(s.message))}}async fileExists(e){try{return console.log("GitHubStorage.fileExists: Checking if file exists: ".concat(e)),console.log("GitHubStorage.fileExists: Repository: ".concat(this.repository,", Branch: ").concat(this.branch)),await this.readFile(e),console.log("GitHubStorage.fileExists: File ".concat(e," exists")),!0}catch(t){return console.log("GitHubStorage.fileExists: File ".concat(e," does not exist:"),t.message),!1}}async listFiles(e){try{const{owner:t,repo:s}=this.parseRepository(this.repository),r=(await this.githubService.getRepositoryTree(t,s,this.branch,!0)).tree.filter(e=>"blob"===e.type).map(e=>e.path);if(e.includes("*")||e.includes("?")){const t=e.replace(/\./g,"\\.").replace(/\*/g,".*").replace(/\?/g,"."),s=new RegExp("^".concat(t,"$"));return r.filter(e=>s.test(e))}return r.filter(t=>t.startsWith(e))}catch(t){throw new Error("Failed to list files: ".concat(t.message))}}async getFileInfo(e){try{const{owner:t,repo:s}=this.parseRepository(this.repository),r=await this.githubService.getFileContent(t,s,e,this.branch);return{size:Buffer.from(r.content,"base64").length,sha:r.sha,path:r.path,type:r.type,url:r.html_url}}catch(t){throw new Error("Failed to get file info for ".concat(e,": ").concat(t.message))}}}const u=new class{constructor(){this.questionRegistry=new Map,this.initialized=!1}async initialize(){if(!this.initialized)try{await this.loadQuestions(),this.initialized=!0}catch(e){throw new Error("Failed to initialize FAQ engine: ".concat(e.message))}}async loadQuestions(){const e=[{id:"dak-name",module:()=>s.e(399).then(s.bind(s,30399))},{id:"dak-version",module:()=>s.e(3714).then(s.bind(s,33714))},{id:"business-process-workflows",module:()=>s.e(7076).then(s.bind(s,97076))},{id:"decision-table-inputs",module:()=>s.e(5619).then(s.bind(s,85619))}];for(const s of e)try{const e=await s.module();e.metadata&&e.execute?this.questionRegistry.set(s.id,{metadata:e.metadata,execute:e.execute,Render:e.Render||null}):console.warn("Question ".concat(s.id," is missing required exports (metadata, execute)"))}catch(t){console.error("Failed to load question ".concat(s.id,":"),t)}}getCatalog(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};if(!this.initialized)throw new Error("FAQ engine not initialized");let t=Array.from(this.questionRegistry.values()).map(e=>e.metadata);return e.level&&(t=t.filter(t=>t.level===e.level)),e.tags&&Array.isArray(e.tags)&&(t=t.filter(t=>e.tags.some(e=>t.tags.includes(e)))),e.componentType&&(t=t.filter(t=>!t.componentTypes||0===t.componentTypes.length||t.componentTypes.includes(e.componentType))),e.assetType&&(t=t.filter(t=>!t.assetTypes||0===t.assetTypes.length||t.assetTypes.includes(e.assetType))),t}async executeBatch(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};this.initialized||await this.initialize();const s=[];for(const a of e)try{const e=await this.executeQuestion(a,t);s.push({questionId:a.questionId,success:!0,result:e})}catch(r){s.push({questionId:a.questionId,success:!1,error:r.message,result:new n.uC({structured:{},narrative:this.getErrorNarrative(a.locale||"en_US",r.message),errors:[r.message],meta:{}})})}return s}async executeQuestion(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};const{questionId:s,parameters:a={},assetFiles:i=[]}=e,c=this.questionRegistry.get(s);if(!c)throw new Error("Question not found: ".concat(s));if(c.metadata.isTemplate&&i.length>0)return await this.executeTemplateQuestion(c,e,t);const l=o.validateParameters(a,c.metadata.level,this.getQuestionType(c.metadata));if(!l.isValid)throw new Error("Parameter validation failed: ".concat(l.errors.join(", ")));const u=this.createStorage(l.normalized,t),h=new n.q_({repository:l.normalized.repository,locale:l.normalized.locale||"en_US",branch:l.normalized.branch||"main",user:t.user||null,assetFile:l.normalized.assetFile||null,componentType:l.normalized.componentType||null,storage:u}),d=(0,r.A)((0,r.A)({},l.normalized),{},{storage:u,context:h});return await c.execute(d)}async executeTemplateQuestion(e,t,s){const{parameters:a={},assetFiles:i=[]}=t,c=[],l=[],u=[];for(const m of i)try{const t=(0,r.A)((0,r.A)({},a),{},{assetFile:m}),i=o.validateParameters(t,e.metadata.level,this.getQuestionType(e.metadata));if(!i.isValid){u.push("Asset ".concat(m,": ").concat(i.errors.join(", ")));continue}const h=this.createStorage(i.normalized,s),d=new n.q_({repository:i.normalized.repository,locale:i.normalized.locale||"en_US",branch:i.normalized.branch||"main",user:s.user||null,assetFile:m,componentType:i.normalized.componentType||null,storage:h}),p=(0,r.A)((0,r.A)({},i.normalized),{},{storage:h,context:d}),g=await e.execute(p);c.push({assetFile:m,result:g}),g.warnings&&l.push(...g.warnings),g.errors&&u.push(...g.errors)}catch(p){u.push("Asset ".concat(m,": ").concat(p.message))}const h={assets:c.map(e=>(0,r.A)({assetFile:e.assetFile},e.result.structured)),summary:{totalAssets:i.length,successfulAssets:c.length,failedAssets:i.length-c.length}},d=this.aggregateNarratives(c,t.locale||"en_US");return new n.uC({structured:h,narrative:d,warnings:l,errors:u,meta:{isAggregated:!0,questionId:e.metadata.id,assetCount:i.length}})}createStorage(e,t){if(t.githubService)return new l(t.githubService,e.repository,e.branch||"main");throw new Error("Local storage not implemented in web context")}getQuestionType(e){return e.componentTypes&&e.componentTypes.length>0?e.componentTypes[0]:e.assetTypes&&e.assetTypes.length>0?e.assetTypes[0]:null}aggregateNarratives(e,t){if(0===e.length)return"<h4>No Results</h4><p>No assets were processed successfully.</p>";let s="<h4>Asset Analysis Results</h4>";s+="<p>Processed ".concat(e.length," asset(s):</p>"),s+="<ul>";for(const{assetFile:r,result:n}of e)s+="<li><strong>".concat(r,"</strong>"),n.errors&&n.errors.length>0?s+=' <span class="error">('.concat(n.errors.length," error(s))</span>"):n.warnings&&n.warnings.length>0?s+=' <span class="warning">('.concat(n.warnings.length," warning(s))</span>"):s+=' <span class="success">\u2713</span>',s+="</li>";return s+="</ul>",s}getErrorNarrative(e,t){const s={en_US:'<h4>Error</h4><p class="error">An error occurred while executing the question: '.concat(t,"</p>"),fr_FR:"<h4>Erreur</h4><p class=\"error\">Une erreur s'est produite lors de l'ex\xe9cution de la question: ".concat(t,"</p>"),es_ES:'<h4>Error</h4><p class="error">Ocurri\xf3 un error al ejecutar la pregunta: '.concat(t,"</p>")};return s[e]||s.en_US}normalizeLocale(e){if(!e)return"en_US";const t=e.replace("-","_");if(["en_US","fr_FR","es_ES","ar_AR","zh_CN","ru_RU"].includes(t))return t;return{en:"en_US",fr:"fr_FR",es:"es_ES",ar:"ar_AR",zh:"zh_CN",ru:"ru_RU"}[t.split("_")[0]]||"en_US"}}}}]);