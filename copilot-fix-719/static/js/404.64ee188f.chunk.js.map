{"version":3,"file":"static/js/404.64ee188f.chunk.js","mappings":"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","sources":["utils/concurrency.js","utils/repositoryCompatibilityCache.js","services/secureTokenStorage.js","services/githubService.js","services/branchContextService.js"],"sourcesContent":["/**\n * Utility for managing concurrent async operations with rate limiting\n */\n\n/**\n * Processes items concurrently with a specified concurrency limit\n * @param {Array} items - Items to process\n * @param {Function} processor - Async function to process each item\n * @param {Object} options - Options for concurrency control\n * @param {number} options.concurrency - Maximum concurrent operations (default: 5)\n * @param {Function} options.onProgress - Progress callback (current, total, item, result)\n * @param {Function} options.onItemComplete - Callback when item completes (item, result, error)\n * @param {Function} options.onItemStart - Callback when item starts processing (item, index)\n * @returns {Promise<Array>} Array of results (in original order)\n */\nexport async function processConcurrently(items, processor, options = {}) {\n  const {\n    concurrency = 5,\n    onProgress = null,\n    onItemComplete = null,\n    onItemStart = null\n  } = options;\n\n  if (!items || items.length === 0) {\n    return [];\n  }\n\n  const results = new Array(items.length);\n  const total = items.length;\n  let completed = 0;\n\n  // Create a queue of work items\n  const queue = items.map((item, index) => ({ item, index }));\n  \n  // Worker function that processes items from the queue\n  const worker = async () => {\n    while (queue.length > 0) {\n      const { item, index } = queue.shift();\n      \n      // Notify that processing is starting\n      if (onItemStart) {\n        onItemStart(item, index);\n      }\n      \n      try {\n        const result = await processor(item, index);\n        results[index] = result;\n        \n        completed++;\n        \n        // Call callbacks\n        if (onProgress) {\n          onProgress(completed, total, item, result);\n        }\n        if (onItemComplete) {\n          onItemComplete(item, result, null);\n        }\n      } catch (error) {\n        // Store error as result\n        results[index] = { error, item };\n        \n        completed++;\n        \n        // Call callbacks\n        if (onProgress) {\n          onProgress(completed, total, item, null);\n        }\n        if (onItemComplete) {\n          onItemComplete(item, null, error);\n        }\n      }\n    }\n  };\n\n  // Start worker promises (limited by concurrency)\n  const workers = Array(Math.min(concurrency, items.length))\n    .fill()\n    .map(() => worker());\n\n  // Wait for all workers to complete\n  await Promise.all(workers);\n\n  return results;\n}\n\n/**\n * Rate-limited function executor\n * Useful for API calls that need to respect rate limits\n */\nexport class RateLimiter {\n  constructor(requestsPerSecond = 5) {\n    this.requestsPerSecond = requestsPerSecond;\n    this.requests = [];\n    this.interval = 1000 / requestsPerSecond; // ms between requests\n  }\n\n  /**\n   * Execute a function with rate limiting\n   * @param {Function} fn - Function to execute\n   * @returns {Promise} Result of the function\n   */\n  async execute(fn) {\n    const now = Date.now();\n    \n    // Remove requests older than 1 second\n    this.requests = this.requests.filter(time => now - time < 1000);\n    \n    // If we're at the limit, wait\n    if (this.requests.length >= this.requestsPerSecond) {\n      const oldestRequest = Math.min(...this.requests);\n      const waitTime = 1000 - (now - oldestRequest) + 10; // Add 10ms buffer\n      if (waitTime > 0) {\n        await new Promise(resolve => setTimeout(resolve, waitTime));\n      }\n    }\n    \n    // Record this request\n    this.requests.push(Date.now());\n    \n    // Execute the function\n    return await fn();\n  }\n}","/**\n * Simple in-memory cache for repository compatibility checks\n * Prevents redundant sushi-config.yaml downloads during scanning\n */\n\nclass RepositoryCompatibilityCache {\n  constructor(ttlMinutes = 30) {\n    this.cache = new Map();\n    this.ttl = ttlMinutes * 60 * 1000; // Convert to milliseconds\n  }\n\n  /**\n   * Generate cache key for a repository\n   * @param {string} owner - Repository owner\n   * @param {string} repo - Repository name\n   * @returns {string} Cache key\n   */\n  _getCacheKey(owner, repo) {\n    return `${owner}/${repo}`;\n  }\n\n  /**\n   * Check if cache entry is still valid\n   * @param {Object} entry - Cache entry\n   * @returns {boolean} True if valid\n   */\n  _isValid(entry) {\n    return Date.now() - entry.timestamp < this.ttl;\n  }\n\n  /**\n   * Get cached compatibility result\n   * @param {string} owner - Repository owner\n   * @param {string} repo - Repository name\n   * @returns {boolean|null} Cached result or null if not cached/expired\n   */\n  get(owner, repo) {\n    const key = this._getCacheKey(owner, repo);\n    const entry = this.cache.get(key);\n    \n    if (!entry) {\n      return null;\n    }\n    \n    if (!this._isValid(entry)) {\n      this.cache.delete(key);\n      return null;\n    }\n    \n    return entry.compatible;\n  }\n\n  /**\n   * Set cached compatibility result\n   * @param {string} owner - Repository owner\n   * @param {string} repo - Repository name\n   * @param {boolean} compatible - Whether repository is SMART guidelines compatible\n   */\n  set(owner, repo, compatible) {\n    const key = this._getCacheKey(owner, repo);\n    this.cache.set(key, {\n      compatible,\n      timestamp: Date.now()\n    });\n  }\n\n  /**\n   * Clear all cached entries\n   */\n  clear() {\n    this.cache.clear();\n  }\n\n  /**\n   * Clean up expired entries\n   */\n  cleanup() {\n    const now = Date.now();\n    for (const [key, entry] of this.cache.entries()) {\n      if (now - entry.timestamp >= this.ttl) {\n        this.cache.delete(key);\n      }\n    }\n  }\n\n  /**\n   * Get cache statistics\n   * @returns {Object} Cache stats\n   */\n  getStats() {\n    this.cleanup();\n    return {\n      size: this.cache.size,\n      ttlMinutes: this.ttl / (60 * 1000),\n      entries: Array.from(this.cache.entries()).map(([key, entry]) => ({\n        repository: key,\n        compatible: entry.compatible,\n        ageMinutes: Math.round((Date.now() - entry.timestamp) / (60 * 1000))\n      }))\n    };\n  }\n}\n\n// Create a singleton instance\nconst repositoryCompatibilityCache = new RepositoryCompatibilityCache();\n\nexport default repositoryCompatibilityCache;","/**\n * SecureTokenStorage - Secure storage for GitHub Personal Access Tokens\n * \n * Features:\n * - XOR encryption using browser fingerprint-based keys\n * - Token format validation (classic and fine-grained PATs)\n * - Automatic token expiration (24 hours)\n * - Secure token masking for logs and error messages\n */\n\nimport logger from '../utils/logger';\n\nclass SecureTokenStorage {\n  constructor() {\n    this.logger = logger.getLogger('SecureTokenStorage');\n    this.storageKey = 'sgex_secure_token';\n    this.expirationHours = 24;\n    this.logger.debug('SecureTokenStorage instance created');\n  }\n\n  /**\n   * Generate a browser fingerprint for encryption key\n   * @returns {string} Browser fingerprint\n   */\n  generateBrowserFingerprint() {\n    const canvas = document.createElement('canvas');\n    const ctx = canvas.getContext('2d');\n    ctx.textBaseline = 'top';\n    ctx.font = '14px Arial';\n    ctx.fillText('Browser fingerprint', 2, 2);\n    \n    const fingerprint = [\n      navigator.userAgent,\n      navigator.language,\n      window.screen.width + 'x' + window.screen.height,\n      window.screen.colorDepth,\n      new Date().getTimezoneOffset(),\n      canvas.toDataURL()\n    ].join('|');\n    \n    // Create a simple hash of the fingerprint\n    let hash = 0;\n    for (let i = 0; i < fingerprint.length; i++) {\n      const char = fingerprint.charCodeAt(i);\n      hash = ((hash << 5) - hash) + char;\n      hash = hash & hash; // Convert to 32-bit integer\n    }\n    \n    return Math.abs(hash).toString(36);\n  }\n\n  /**\n   * XOR encrypt/decrypt text using a key\n   * @param {string} text - Text to encrypt/decrypt\n   * @param {string} key - Encryption key\n   * @returns {string} Encrypted/decrypted text\n   */\n  xorCipher(text, key) {\n    let result = '';\n    for (let i = 0; i < text.length; i++) {\n      result += String.fromCharCode(\n        text.charCodeAt(i) ^ key.charCodeAt(i % key.length)\n      );\n    }\n    return result;\n  }\n\n  /**\n   * Validate GitHub Personal Access Token format\n   * @param {string} token - Token to validate\n   * @returns {object} Validation result with type and validity\n   */\n  validateTokenFormat(token) {\n    if (!token || typeof token !== 'string') {\n      return { isValid: false, type: 'invalid', reason: 'Token is empty or not a string' };\n    }\n\n    // Remove any whitespace\n    const cleanToken = token.trim();\n\n    // Classic Personal Access Token format: ghp_[36 characters A-Za-z0-9]\n    if (cleanToken.match(/^ghp_[A-Za-z0-9]{36}$/)) {\n      return { isValid: true, type: 'classic', token: cleanToken };\n    }\n\n    // Fine-grained Personal Access Token format: github_pat_[22 characters]_[59 characters]\n    if (cleanToken.match(/^github_pat_[A-Za-z0-9]{22}_[A-Za-z0-9]{59}$/)) {\n      return { isValid: true, type: 'fine-grained', token: cleanToken };\n    }\n\n    // OAuth token format: gho_[36 characters] (for completeness)\n    if (cleanToken.match(/^gho_[A-Za-z0-9]{36}$/)) {\n      return { isValid: true, type: 'oauth', token: cleanToken };\n    }\n\n    // Check for old-style tokens (40 hex characters) - deprecated but might still work\n    if (cleanToken.match(/^[a-fA-F0-9]{40}$/)) {\n      return { isValid: true, type: 'legacy', token: cleanToken };\n    }\n\n    return { \n      isValid: false, \n      type: 'invalid', \n      reason: 'Token does not match expected GitHub PAT format'\n    };\n  }\n\n  /**\n   * Mask token for safe logging\n   * @param {string} token - Token to mask\n   * @returns {string} Masked token\n   */\n  maskToken(token) {\n    if (!token || typeof token !== 'string') {\n      return '[INVALID_TOKEN]';\n    }\n\n    const cleanToken = token.trim();\n    if (cleanToken.length < 8) {\n      return '[INVALID_TOKEN]';\n    }\n\n    // Show first 4 and last 4 characters for debugging purposes\n    return `${cleanToken.substring(0, 4)}${'*'.repeat(cleanToken.length - 8)}${cleanToken.substring(cleanToken.length - 4)}`;\n  }\n\n  /**\n   * Store token securely with encryption and expiration\n   * @param {string} token - GitHub Personal Access Token\n   * @returns {boolean} Success status\n   */\n  storeToken(token) {\n    try {\n      this.logger.debug('Starting secure token storage');\n\n      // Validate token format\n      const validation = this.validateTokenFormat(token);\n      if (!validation.isValid) {\n        this.logger.warn('Token validation failed', { \n          reason: validation.reason,\n          tokenMask: this.maskToken(token)\n        });\n        return false;\n      }\n\n      this.logger.debug('Token validation successful', { \n        type: validation.type,\n        tokenMask: this.maskToken(token)\n      });\n\n      // Generate encryption key\n      const fingerprint = this.generateBrowserFingerprint();\n      const encryptionKey = `sgex_${fingerprint}_${Date.now().toString(36)}`;\n\n      // Encrypt token\n      const encryptedToken = this.xorCipher(validation.token, encryptionKey);\n      \n      // Create storage object with metadata\n      const storageData = {\n        token: btoa(encryptedToken), // Base64 encode for safe storage\n        key: btoa(encryptionKey), // Base64 encode the key\n        type: validation.type,\n        created: Date.now(),\n        expires: Date.now() + (this.expirationHours * 60 * 60 * 1000),\n        fingerprint: fingerprint\n      };\n\n      // Store in sessionStorage (more secure than localStorage for tokens)\n      sessionStorage.setItem(this.storageKey, JSON.stringify(storageData));\n      \n      // Clear any old tokens from localStorage\n      localStorage.removeItem('github_token');\n      sessionStorage.removeItem('github_token');\n\n      this.logger.debug('Token stored securely', { \n        type: validation.type,\n        expires: new Date(storageData.expires).toISOString(),\n        tokenMask: this.maskToken(token)\n      });\n\n      return true;\n    } catch (error) {\n      this.logger.error('Failed to store token securely', { \n        error: error.message,\n        tokenMask: this.maskToken(token)\n      });\n      return false;\n    }\n  }\n\n  /**\n   * Retrieve and decrypt stored token\n   * @returns {object|null} Token data or null if not found/expired\n   */\n  retrieveToken() {\n    try {\n      this.logger.debug('Attempting to retrieve secure token');\n\n      const storedData = sessionStorage.getItem(this.storageKey);\n      if (!storedData) {\n        this.logger.debug('No secure token found in storage');\n        return null;\n      }\n\n      const data = JSON.parse(storedData);\n      \n      // Check expiration\n      if (Date.now() > data.expires) {\n        this.logger.warn('Stored token has expired');\n        this.clearToken();\n        return null;\n      }\n\n      // Verify browser fingerprint\n      const currentFingerprint = this.generateBrowserFingerprint();\n      if (data.fingerprint !== currentFingerprint) {\n        this.logger.warn('Browser fingerprint mismatch - possible security issue');\n        this.clearToken();\n        return null;\n      }\n\n      // Decrypt token\n      const encryptionKey = atob(data.key);\n      const encryptedToken = atob(data.token);\n      const decryptedToken = this.xorCipher(encryptedToken, encryptionKey);\n\n      // Validate decrypted token\n      const validation = this.validateTokenFormat(decryptedToken);\n      if (!validation.isValid) {\n        this.logger.error('Decrypted token failed validation');\n        this.clearToken();\n        return null;\n      }\n\n      this.logger.debug('Token retrieved and decrypted successfully', { \n        type: data.type,\n        expires: new Date(data.expires).toISOString(),\n        tokenMask: this.maskToken(decryptedToken)\n      });\n\n      return {\n        token: validation.token,\n        type: data.type,\n        created: data.created,\n        expires: data.expires\n      };\n    } catch (error) {\n      this.logger.error('Failed to retrieve secure token', { error: error.message });\n      this.clearToken();\n      return null;\n    }\n  }\n\n  /**\n   * Check if a valid token exists without retrieving it\n   * @returns {boolean} True if valid token exists\n   */\n  hasValidToken() {\n    try {\n      const storedData = sessionStorage.getItem(this.storageKey);\n      if (!storedData) {\n        return false;\n      }\n\n      const data = JSON.parse(storedData);\n      \n      // Check expiration\n      if (Date.now() > data.expires) {\n        this.clearToken();\n        return false;\n      }\n\n      // Verify browser fingerprint\n      const currentFingerprint = this.generateBrowserFingerprint();\n      if (data.fingerprint !== currentFingerprint) {\n        this.clearToken();\n        return false;\n      }\n\n      return true;\n    } catch (error) {\n      this.logger.error('Error checking token validity', { error: error.message });\n      this.clearToken();\n      return false;\n    }\n  }\n\n  /**\n   * Clear stored token and cleanup\n   */\n  clearToken() {\n    this.logger.debug('Clearing secure token storage');\n    \n    sessionStorage.removeItem(this.storageKey);\n    \n    // Also clear legacy token storage\n    sessionStorage.removeItem('github_token');\n    localStorage.removeItem('github_token');\n  }\n\n  /**\n   * Get token expiration info\n   * @returns {object|null} Expiration info or null if no token\n   */\n  getTokenInfo() {\n    try {\n      const storedData = sessionStorage.getItem(this.storageKey);\n      if (!storedData) {\n        return null;\n      }\n\n      const data = JSON.parse(storedData);\n      const timeRemaining = data.expires - Date.now();\n      \n      return {\n        type: data.type,\n        created: new Date(data.created),\n        expires: new Date(data.expires),\n        timeRemaining: Math.max(0, timeRemaining),\n        isExpired: timeRemaining <= 0,\n        isValid: this.hasValidToken()\n      };\n    } catch (error) {\n      this.logger.error('Error getting token info', { error: error.message });\n      return null;\n    }\n  }\n\n  /**\n   * Migrate from legacy token storage\n   * @returns {boolean} True if migration was successful\n   */\n  migrateLegacyToken() {\n    try {\n      // Check for tokens in legacy storage\n      const legacyToken = sessionStorage.getItem('github_token') || localStorage.getItem('github_token');\n      \n      if (!legacyToken) {\n        this.logger.debug('No legacy token found for migration');\n        return false;\n      }\n\n      this.logger.debug('Migrating legacy token to secure storage');\n\n      // Store using new secure method\n      const success = this.storeToken(legacyToken);\n      \n      if (success) {\n        // Clear legacy storage\n        sessionStorage.removeItem('github_token');\n        localStorage.removeItem('github_token');\n        this.logger.debug('Legacy token migration completed successfully');\n        return true;\n      } else {\n        this.logger.error('Failed to migrate legacy token');\n        return false;\n      }\n    } catch (error) {\n      this.logger.error('Error during legacy token migration', { error: error.message });\n      return false;\n    }\n  }\n}\n\n// Create singleton instance\nconst secureTokenStorage = new SecureTokenStorage();\n\nexport default secureTokenStorage;","import { Octokit } from '@octokit/rest';\nimport { processConcurrently } from '../utils/concurrency';\nimport repositoryCompatibilityCache from '../utils/repositoryCompatibilityCache';\nimport secureTokenStorage from './secureTokenStorage';\nimport logger from '../utils/logger';\n\nclass GitHubService {\n  constructor() {\n    this.octokit = null;\n    this.isAuthenticated = false;\n    this.permissions = null;\n    this.tokenType = null; // 'classic', 'fine-grained', or 'oauth'\n    this.logger = logger.getLogger('GitHubService');\n    this.logger.debug('GitHubService instance created');\n  }\n\n  // Initialize with a GitHub token (supports both OAuth and PAT tokens)\n  authenticate(token) {\n    const startTime = Date.now();\n    this.logger.auth('Starting authentication', { \n      tokenProvided: !!token, \n      tokenMask: token ? secureTokenStorage.maskToken(token) : 'none'\n    });\n    \n    try {\n      // Validate token format using SecureTokenStorage\n      const validation = secureTokenStorage.validateTokenFormat(token);\n      if (!validation.isValid) {\n        this.logger.warn('Token validation failed during authentication', { \n          reason: validation.reason,\n          tokenMask: secureTokenStorage.maskToken(token)\n        });\n        this.isAuthenticated = false;\n        return false;\n      }\n\n      this.octokit = new Octokit({\n        auth: validation.token,\n      });\n      this.isAuthenticated = true;\n      this.tokenType = validation.type;\n      \n      // Store token securely\n      const stored = secureTokenStorage.storeToken(validation.token);\n      if (!stored) {\n        this.logger.warn('Failed to store token securely, authentication will not persist');\n      }\n      \n      const duration = Date.now() - startTime;\n      this.logger.auth('Authentication successful', { \n        duration, \n        tokenType: this.tokenType,\n        tokenMask: secureTokenStorage.maskToken(token),\n        securelyStored: stored\n      });\n      this.logger.performance('GitHub authentication', duration);\n      \n      return true;\n    } catch (error) {\n      const duration = Date.now() - startTime;\n      this.logger.auth('Authentication failed', { \n        error: error.message, \n        duration,\n        tokenMask: secureTokenStorage.maskToken(token)\n      });\n      console.error('Failed to authenticate with GitHub:', error);\n      this.isAuthenticated = false;\n      secureTokenStorage.clearToken(); // Clear any partially stored data\n      return false;\n    }\n  }\n\n  // Initialize with an existing Octokit instance (for OAuth flow)\n  authenticateWithOctokit(octokitInstance) {\n    this.logger.auth('Starting OAuth authentication with Octokit instance');\n    \n    try {\n      this.octokit = octokitInstance;\n      this.isAuthenticated = true;\n      this.tokenType = 'oauth';\n      \n      this.logger.auth('OAuth authentication successful', { tokenType: this.tokenType });\n      return true;\n    } catch (error) {\n      this.logger.auth('OAuth authentication failed', { error: error.message });\n      console.error('Failed to authenticate with Octokit instance:', error);\n      this.isAuthenticated = false;\n      return false;\n    }\n  }\n\n  // Initialize authentication from securely stored token\n  initializeFromStoredToken() {\n    this.logger.auth('Attempting to initialize from stored token');\n    \n    try {\n      // First try to migrate any legacy tokens\n      const migrated = secureTokenStorage.migrateLegacyToken();\n      if (migrated) {\n        this.logger.debug('Successfully migrated legacy token to secure storage');\n      }\n\n      // Retrieve token from secure storage\n      const tokenData = secureTokenStorage.retrieveToken();\n      if (!tokenData) {\n        this.logger.debug('No valid stored token found');\n        return false;\n      }\n\n      // Initialize Octokit with stored token\n      this.octokit = new Octokit({\n        auth: tokenData.token,\n      });\n      this.isAuthenticated = true;\n      this.tokenType = tokenData.type;\n      \n      this.logger.auth('Successfully initialized from stored token', {\n        tokenType: this.tokenType,\n        tokenMask: secureTokenStorage.maskToken(tokenData.token),\n        expires: new Date(tokenData.expires).toISOString()\n      });\n      \n      return true;\n    } catch (error) {\n      this.logger.auth('Failed to initialize from stored token', { error: error.message });\n      this.isAuthenticated = false;\n      secureTokenStorage.clearToken();\n      return false;\n    }\n  }\n\n  // Check if there's a valid stored token\n  hasStoredToken() {\n    return secureTokenStorage.hasValidToken();\n  }\n\n  // Get information about stored token\n  getStoredTokenInfo() {\n    return secureTokenStorage.getTokenInfo();\n  }\n\n  // Check token permissions and type\n  async checkTokenPermissions() {\n    if (!this.isAuth()) {\n      const error = new Error('Not authenticated with GitHub');\n      this.logger.error('Token permission check failed - not authenticated');\n      throw error;\n    }\n\n    const startTime = Date.now();\n    this.logger.apiCall('GET', '/user', null);\n\n    try {\n      // Try to get token info to determine type and permissions\n      const response = await this.octokit.request('GET /user');\n      this.logger.apiResponse('GET', '/user', response.status, Date.now() - startTime);\n      \n      // Check if this is a fine-grained token by trying to access rate limit info\n      try {\n        const rateLimitStart = Date.now();\n        this.logger.apiCall('GET', '/rate_limit', null);\n        const rateLimit = await this.octokit.rest.rateLimit.get();\n        this.logger.apiResponse('GET', '/rate_limit', rateLimit.status, Date.now() - rateLimitStart);\n        \n        // Fine-grained tokens have different rate limit structure\n        this.tokenType = rateLimit.data.resources.core ? 'classic' : 'fine-grained';\n        this.logger.debug('Token type determined', { tokenType: this.tokenType, hasCore: !!rateLimit.data.resources.core });\n      } catch (rateLimitError) {\n        this.tokenType = 'unknown';\n        this.logger.warn('Could not determine token type from rate limit', { error: rateLimitError.message });\n      }\n\n      const permissions = {\n        type: this.tokenType,\n        user: response.data\n      };\n      \n      this.permissions = permissions;\n      this.logger.debug('Token permissions checked successfully', { \n        tokenType: this.tokenType, \n        username: response.data.login \n      });\n      \n      return permissions;\n    } catch (error) {\n      const duration = Date.now() - startTime;\n      this.logger.apiError('GET', '/user', error);\n      this.logger.performance('Token permission check (failed)', duration);\n      console.error('Failed to check token permissions:', error);\n      throw error;\n    }\n  }\n\n  // Check if we have write permissions for a specific repository\n  async checkRepositoryWritePermissions(owner, repo) {\n    if (!this.isAuth()) {\n      this.logger.warn('Cannot check repository write permissions - not authenticated', { owner, repo });\n      return false;\n    }\n\n    const startTime = Date.now();\n    this.logger.debug('Checking write permissions for repository', { owner, repo });\n\n    try {\n      // Get current user first\n      const currentUser = await this.getCurrentUser();\n      const username = currentUser.login;\n      \n      this.logger.apiCall('GET', `/repos/${owner}/${repo}/collaborators/${username}/permission`, null);\n      \n      // Try to get repository collaborator permissions\n      const { data } = await this.octokit.rest.repos.getCollaboratorPermissionLevel({\n        owner,\n        repo,\n        username\n      });\n      \n      const duration = Date.now() - startTime;\n      this.logger.apiResponse('GET', `/repos/${owner}/${repo}/collaborators/${username}/permission`, 200, duration);\n      \n      const hasWriteAccess = ['write', 'admin'].includes(data.permission);\n      this.logger.debug('Repository write permissions checked', { \n        owner, \n        repo, \n        permission: data.permission, \n        hasWriteAccess \n      });\n      \n      return hasWriteAccess;\n    } catch (error) {\n      const duration = Date.now() - startTime;\n      this.logger.apiError('GET', `/repos/${owner}/${repo}/collaborators/*/permission`, error);\n      this.logger.performance('Repository write permission check (failed)', duration);\n      \n      // If we can't check permissions, assume we don't have write access\n      console.warn('Could not check repository write permissions:', error);\n      this.logger.warn('Assuming no write access due to permission check failure', { owner, repo, error: error.message });\n      return false;\n    }\n  }\n\n  // Alias method for backward compatibility - delegates to checkRepositoryWritePermissions\n  async checkRepositoryPermissions(owner, repo) {\n    return this.checkRepositoryWritePermissions(owner, repo);\n  }\n\n  // Check if the token has permission to create comments on issues/PRs\n  async checkCommentPermissions(owner, repo) {\n    if (!this.isAuth()) {\n      this.logger.warn('Cannot check comment permissions - not authenticated', { owner, repo });\n      return false;\n    }\n\n    const startTime = Date.now();\n    this.logger.debug('Checking comment permissions for repository', { owner, repo });\n\n    try {\n      // Try to access the issues endpoint, which is required for commenting on PRs\n      // This is a safe read operation that will fail gracefully if no permission\n      this.logger.apiCall('GET', `/repos/${owner}/${repo}/issues`, { per_page: 1 });\n      \n      await this.octokit.rest.issues.listForRepo({\n        owner,\n        repo,\n        per_page: 1,\n        state: 'all'\n      });\n      \n      const duration = Date.now() - startTime;\n      this.logger.apiResponse('GET', `/repos/${owner}/${repo}/issues`, 200, duration);\n      \n      // If we can read issues, we likely can comment on them\n      // But this is just a heuristic - the actual test is when we try to comment\n      this.logger.debug('Issues endpoint accessible - comment permissions likely available', { owner, repo });\n      return true;\n    } catch (error) {\n      const duration = Date.now() - startTime;\n      this.logger.apiError('GET', `/repos/${owner}/${repo}/issues`, error);\n      this.logger.performance('Comment permission check (failed)', duration);\n      \n      // Check if it's a permissions error\n      if (error.status === 403 || error.status === 401) {\n        this.logger.warn('Token does not have permission to access issues/comments', { \n          owner, \n          repo, \n          error: error.message,\n          status: error.status \n        });\n        return false;\n      }\n      \n      // For other errors, assume we have permission and let the actual comment attempt handle it\n      this.logger.warn('Could not determine comment permissions, assuming available', { \n        owner, \n        repo, \n        error: error.message \n      });\n      return true;\n    }\n  }\n\n  // Check if authenticated\n  isAuth() {\n    return this.isAuthenticated && this.octokit !== null;\n  }\n\n  // Get current user data\n  async getCurrentUser() {\n    if (!this.isAuth()) {\n      throw new Error('Not authenticated with GitHub');\n    }\n\n    try {\n      const { data } = await this.octokit.rest.users.getAuthenticated();\n      return data;\n    } catch (error) {\n      console.error('Failed to fetch user data:', error);\n      throw error;\n    }\n  }\n\n  // Get user's organizations\n  async getUserOrganizations() {\n    if (!this.isAuth()) {\n      throw new Error('Not authenticated with GitHub');\n    }\n\n    try {\n      const { data } = await this.octokit.rest.orgs.listForAuthenticatedUser();\n      return data;\n    } catch (error) {\n      console.error('Failed to fetch organizations:', error);\n      throw error;\n    }\n  }\n\n  // Get specific organization data (public data, no auth required)\n  async getOrganization(orgLogin) {\n    try {\n      // Create a temporary Octokit instance for public API calls if we don't have one\n      const octokit = this.octokit || new Octokit();\n      \n      const { data } = await octokit.rest.orgs.get({\n        org: orgLogin\n      });\n      return data;\n    } catch (error) {\n      console.error(`Failed to fetch organization ${orgLogin}:`, error);\n      throw error;\n    }\n  }\n\n  // Get specific user data (public data, no auth required)\n  async getUser(username) {\n    try {\n      // Create a temporary Octokit instance for public API calls if we don't have one\n      const octokit = this.octokit || new Octokit();\n      \n      const { data } = await octokit.rest.users.getByUsername({\n        username\n      });\n      return data;\n    } catch (error) {\n      console.error(`Failed to fetch user ${username}:`, error);\n      throw error;\n    }\n  }\n\n  // Get public repositories for a user or organization (no auth required)\n  async getPublicRepositories(owner, type = 'user') {\n    try {\n      // Create a temporary Octokit instance for public API calls if we don't have one\n      const octokit = this.octokit || new Octokit();\n      \n      let repositories = [];\n      let page = 1;\n      let hasMorePages = true;\n\n      // Fetch all public repositories using pagination\n      while (hasMorePages) {\n        let response;\n        if (type === 'user') {\n          response = await octokit.rest.repos.listForUser({\n            username: owner,\n            sort: 'updated',\n            per_page: 100,\n            page: page,\n          });\n        } else {\n          response = await octokit.rest.repos.listForOrg({\n            org: owner,\n            sort: 'updated',\n            per_page: 100,\n            page: page,\n          });\n        }\n\n        repositories = repositories.concat(response.data);\n        \n        // Check if there are more pages\n        hasMorePages = response.data.length === 100;\n        page++;\n      }\n\n      return repositories;\n    } catch (error) {\n      console.error(`Failed to fetch public repositories for ${owner}:`, error);\n      throw error;\n    }\n  }\n\n  // Get WHO organization data with fresh avatar\n  async getWHOOrganization() {\n    try {\n      const whoData = await this.getOrganization('WorldHealthOrganization');\n      return {\n        id: whoData.id,\n        login: whoData.login,\n        display_name: whoData.name || 'World Health Organization',\n        description: whoData.description || 'The World Health Organization is a specialized agency of the United Nations responsible for international public health.',\n        avatar_url: whoData.avatar_url,\n        html_url: whoData.html_url,\n        type: 'Organization',\n        permissions: {\n          can_create_repositories: true,\n          can_create_private_repositories: true\n        },\n        plan: {\n          name: 'Organization',\n          private_repos: 'unlimited'\n        },\n        isWHO: true\n      };\n    } catch (error) {\n      console.warn('Could not fetch WHO organization data from API, using fallback:', error);\n      // Return hardcoded fallback data\n      return {\n        id: 'who-organization',\n        login: 'WorldHealthOrganization',\n        display_name: 'World Health Organization',\n        description: 'The World Health Organization is a specialized agency of the United Nations responsible for international public health.',\n        avatar_url: 'https://avatars.githubusercontent.com/u/12261302?s=200&v=4',\n        html_url: 'https://github.com/WorldHealthOrganization',\n        type: 'Organization',\n        permissions: {\n          can_create_repositories: true,\n          can_create_private_repositories: true\n        },\n        plan: {\n          name: 'Organization',\n          private_repos: 'unlimited'\n        },\n        isWHO: true\n      };\n    }\n  }\n\n  // Get repositories for a user or organization (now filters by SMART Guidelines compatibility)\n  async getRepositories(owner, type = 'user', isDemo = false) {\n    // Handle demo mode - return demo repositories without requiring authentication\n    if (isDemo || owner === 'demo-user') {\n      return this.getDemoRepositories(owner);\n    }\n    \n    // Use the new SMART guidelines filtering method\n    return this.getSmartGuidelinesRepositories(owner, type);\n  }\n\n  // Get demo repositories for demo mode (no authentication required)\n  getDemoRepositories(owner) {\n    const demoRepos = [\n      {\n        id: 'demo-smart-anc',\n        name: 'smart-anc',\n        full_name: `${owner}/smart-anc`,\n        description: 'Demo SMART Guidelines Digital Adaptation Kit for Antenatal Care',\n        private: false,\n        owner: {\n          login: owner,\n          id: 'demo-owner',\n          avatar_url: `https://github.com/${owner}.png`,\n          type: 'User'\n        },\n        html_url: `https://github.com/${owner}/smart-anc`,\n        clone_url: `https://github.com/${owner}/smart-anc.git`,\n        language: 'FSH',\n        stargazers_count: 15,\n        forks_count: 3,\n        open_issues_count: 2,\n        topics: ['who', 'smart-guidelines', 'dak', 'antenatal-care', 'health'],\n        created_at: '2023-01-15T10:00:00Z',\n        updated_at: '2024-12-15T14:30:00Z',\n        pushed_at: '2024-12-15T14:30:00Z',\n        default_branch: 'main',\n        smart_guidelines_compatible: true,\n        isDemo: true\n      },\n      {\n        id: 'demo-smart-tb',\n        name: 'smart-tb',\n        full_name: `${owner}/smart-tb`,\n        description: 'Demo SMART Guidelines Digital Adaptation Kit for Tuberculosis Care',\n        private: false,\n        owner: {\n          login: owner,\n          id: 'demo-owner',\n          avatar_url: `https://github.com/${owner}.png`,\n          type: 'User'\n        },\n        html_url: `https://github.com/${owner}/smart-tb`,\n        clone_url: `https://github.com/${owner}/smart-tb.git`,\n        language: 'FSH',\n        stargazers_count: 8,\n        forks_count: 1,\n        open_issues_count: 0,\n        topics: ['who', 'smart-guidelines', 'dak', 'tuberculosis', 'health'],\n        created_at: '2023-03-20T15:00:00Z',\n        updated_at: '2024-11-30T09:15:00Z',\n        pushed_at: '2024-11-30T09:15:00Z',\n        default_branch: 'main',\n        smart_guidelines_compatible: true,\n        isDemo: true\n      },\n      {\n        id: 'demo-smart-ips-pilgrimage',\n        name: 'smart-ips-pilgrimage',\n        full_name: `${owner}/smart-ips-pilgrimage`,\n        description: 'Demo SMART Guidelines International Patient Summary for Pilgrimage',\n        private: false,\n        owner: {\n          login: owner,\n          id: 'demo-owner',\n          avatar_url: `https://github.com/${owner}.png`,\n          type: 'User'\n        },\n        html_url: `https://github.com/${owner}/smart-ips-pilgrimage`,\n        clone_url: `https://github.com/${owner}/smart-ips-pilgrimage.git`,\n        language: 'FSH',\n        stargazers_count: 12,\n        forks_count: 2,\n        open_issues_count: 1,\n        topics: ['who', 'smart-guidelines', 'dak', 'ips', 'pilgrimage', 'health'],\n        created_at: '2023-06-10T12:00:00Z',\n        updated_at: '2024-12-01T16:45:00Z',\n        pushed_at: '2024-12-01T16:45:00Z',\n        default_branch: 'main',\n        smart_guidelines_compatible: true,\n        isDemo: true\n      }\n    ];\n\n    return Promise.resolve(demoRepos);\n  }\n\n  // Check if a repository has sushi-config.yaml with smart.who.int.base dependency\n  async checkSmartGuidelinesCompatibility(owner, repo, retryCount = 2) {\n    // Check cache first to prevent redundant downloads\n    const cachedResult = repositoryCompatibilityCache.get(owner, repo);\n    if (cachedResult !== null) {\n      return cachedResult;\n    }\n\n    try {\n      // Use authenticated or public API depending on authentication state\n      const octokit = this.octokit || new Octokit();\n      \n      // Try to get sushi-config.yaml from the repository root\n      const { data } = await octokit.rest.repos.getContent({\n        owner,\n        repo,\n        path: 'sushi-config.yaml',\n      });\n\n      if (data.type === 'file' && data.content) {\n        // Decode base64 content (browser-compatible)\n        const content = decodeURIComponent(escape(atob(data.content)));\n        \n        // Check if the content contains smart.who.int.base in dependencies\n        const isCompatible = content.includes('smart.who.int.base');\n        \n        // Cache the result\n        repositoryCompatibilityCache.set(owner, repo, isCompatible);\n        return isCompatible;\n      }\n      \n      // Cache negative result\n      repositoryCompatibilityCache.set(owner, repo, false);\n      return false;\n    } catch (error) {\n      // If it's a 404 (file not found), retry once more in case of temporary issues\n      if (error.status === 404 && retryCount > 0) {\n        console.warn(`File not found for ${owner}/${repo}, retrying... (${retryCount} attempts left)`);\n        // Use shorter delay in test environment\n        const delay = process.env.NODE_ENV === 'test' ? 10 : 1000;\n        await new Promise(resolve => setTimeout(resolve, delay));\n        return this.checkSmartGuidelinesCompatibility(owner, repo, retryCount - 1);\n      }\n      \n      // For any error (including rate limiting, network errors, or file not found after retries),\n      // strictly return false - no fallback logic\n      console.warn(`Failed to check ${owner}/${repo} for sushi-config.yaml with smart.who.int.base dependency:`, error.message);\n      \n      // Cache negative result\n      repositoryCompatibilityCache.set(owner, repo, false);\n      return false;\n    }\n  }\n\n\n\n  // Get repositories that are SMART guidelines compatible\n  async getSmartGuidelinesRepositories(owner, type = 'user') {\n    try {\n      let repositories = [];\n      \n      if (this.isAuth()) {\n        // Use authenticated API for full access\n        let page = 1;\n        let hasMorePages = true;\n\n        // Fetch all repositories using pagination\n        while (hasMorePages) {\n          let response;\n          if (type === 'user') {\n            response = await this.octokit.rest.repos.listForUser({\n              username: owner,\n              sort: 'updated',\n              per_page: 100,\n              page: page,\n            });\n          } else {\n            response = await this.octokit.rest.repos.listForOrg({\n              org: owner,\n              sort: 'updated',\n              per_page: 100,\n              page: page,\n            });\n          }\n\n          repositories = repositories.concat(response.data);\n          \n          // Check if there are more pages\n          hasMorePages = response.data.length === 100;\n          page++;\n        }\n      } else {\n        // Use public API for unauthenticated access (only public repositories)\n        repositories = await this.getPublicRepositories(owner, type);\n      }\n\n      // Check each repository for SMART guidelines compatibility\n      const smartGuidelinesRepos = [];\n      for (const repo of repositories) {\n        const isCompatible = await this.checkSmartGuidelinesCompatibility(repo.owner.login, repo.name);\n        if (isCompatible) {\n          smartGuidelinesRepos.push({\n            ...repo,\n            smart_guidelines_compatible: true\n          });\n        }\n      }\n\n      return smartGuidelinesRepos;\n    } catch (error) {\n      console.error('Failed to fetch SMART guidelines repositories:', error);\n      throw error;\n    }\n  }\n\n  // Get repositories with progressive scanning (for real-time updates)\n  async getSmartGuidelinesRepositoriesProgressive(owner, type = 'user', onRepositoryFound = null, onProgress = null) {\n    if (!this.isAuth()) {\n      throw new Error('Not authenticated with GitHub');\n    }\n\n    try {\n      let repositories = [];\n      let page = 1;\n      let hasMorePages = true;\n\n      // Fetch all repositories using pagination\n      while (hasMorePages) {\n        let response;\n        if (type === 'user') {\n          response = await this.octokit.rest.repos.listForUser({\n            username: owner,\n            sort: 'updated',\n            per_page: 100,\n            page: page,\n          });\n        } else {\n          response = await this.octokit.rest.repos.listForOrg({\n            org: owner,\n            sort: 'updated',\n            per_page: 100,\n            page: page,\n          });\n        }\n\n        repositories = repositories.concat(response.data);\n        \n        // Check if there are more pages\n        hasMorePages = response.data.length === 100;\n        page++;\n      }\n\n      // Handle case where user has no repositories\n      if (repositories.length === 0) {\n        console.log('📊 No repositories found for user, completing scan immediately');\n        // Call progress callback to indicate completion\n        if (onProgress) {\n          onProgress({\n            current: 0,\n            total: 0,\n            currentRepo: 'none',\n            progress: 100,\n            completed: true\n          });\n        }\n        return [];\n      }\n\n      // Process repositories concurrently with rate limiting and enhanced display\n      const processor = async (repo, index) => {\n        // Add a small delay to make scanning progress visible (similar to demo mode)\n        await new Promise(resolve => setTimeout(resolve, 100 + Math.random() * 200));\n        \n        const isCompatible = await this.checkSmartGuidelinesCompatibility(repo.owner.login, repo.name);\n        \n        if (isCompatible) {\n          const smartRepo = {\n            ...repo,\n            smart_guidelines_compatible: true\n          };\n          \n          // Notify that a repository was found\n          if (onRepositoryFound) {\n            onRepositoryFound(smartRepo);\n          }\n          \n          return smartRepo;\n        }\n        \n        return null;\n      };\n\n      // Use concurrent processing with max 5 parallel requests\n      const results = await processConcurrently(repositories, processor, {\n        concurrency: 5,\n        onProgress: (completed, total, repo, result) => {\n          // Progress callback for completed items\n          if (onProgress) {\n            onProgress({\n              current: completed,\n              total: total,\n              currentRepo: repo.name,\n              progress: Math.round((completed / total) * 100),\n              completed: true\n            });\n          }\n        },\n        onItemStart: (repo, index) => {\n          // Progress callback for started items\n          if (onProgress) {\n            onProgress({\n              current: index + 1,\n              total: repositories.length,\n              currentRepo: repo.name,\n              progress: Math.round(((index + 1) / repositories.length) * 100),\n              completed: false,\n              started: true\n            });\n          }\n        }\n      });\n\n      // Filter out null results and collect smart repositories\n      const validResults = results.filter(result => result !== null && !result.error);\n      \n      return validResults;\n    } catch (error) {\n      console.error('Failed to fetch SMART guidelines repositories:', error);\n      throw error;\n    }\n  }\n\n  // Get a specific repository\n  async getRepository(owner, repo) {\n    try {\n      // Use authenticated octokit if available, otherwise create a public instance for public repos\n      const octokit = this.isAuth() ? this.octokit : new Octokit();\n      \n      const { data } = await octokit.rest.repos.get({\n        owner,\n        repo,\n      });\n      return data;\n    } catch (error) {\n      console.error('Failed to fetch repository:', error);\n      throw error;\n    }  \n  }\n\n  // Get repository branches\n  async getBranches(owner, repo) {\n    try {\n      console.log(`githubService.getBranches: Fetching branches for ${owner}/${repo}`);\n      console.log('githubService.getBranches: Authentication status:', this.isAuth());\n      \n      // Use authenticated octokit if available, otherwise create a public instance for public repos\n      const octokit = this.isAuth() ? this.octokit : new Octokit();\n      console.log('githubService.getBranches: Using', this.isAuth() ? 'authenticated' : 'public', 'octokit instance');\n      \n      const { data } = await octokit.rest.repos.listBranches({\n        owner,\n        repo,\n        per_page: 100\n      });\n      \n      console.log(`githubService.getBranches: Successfully fetched ${data.length} branches`);\n      return data;\n    } catch (error) {\n      console.error('githubService.getBranches: Failed to fetch branches:', error);\n      console.error('githubService.getBranches: Error details:', {\n        status: error.status,\n        message: error.message,\n        owner,\n        repo\n      });\n      throw error;\n    }\n  }\n\n  // Create a new branch\n  async createBranch(owner, repo, branchName, fromBranch = 'main') {\n    if (!this.isAuth()) {\n      throw new Error('Not authenticated with GitHub');\n    }\n\n    try {\n      // First get the SHA of the source branch\n      const { data: refData } = await this.octokit.rest.git.getRef({\n        owner,\n        repo,\n        ref: `heads/${fromBranch}`\n      });\n\n      // Create the new branch\n      const { data } = await this.octokit.rest.git.createRef({\n        owner,\n        repo,\n        ref: `refs/heads/${branchName}`,\n        sha: refData.object.sha\n      });\n\n      return data;\n    } catch (error) {\n      console.error('Failed to create branch:', error);\n      throw error;\n    }\n  }\n\n  // Get a specific branch\n  async getBranch(owner, repo, branch) {\n    try {\n      // Use authenticated octokit if available, otherwise create a public instance for public repos\n      const octokit = this.isAuth() ? this.octokit : new Octokit();\n      \n      const { data } = await octokit.rest.repos.getBranch({\n        owner,\n        repo,\n        branch\n      });\n      return data;\n    } catch (error) {\n      console.error('Failed to fetch branch:', error);\n      throw error;\n    }\n  }\n\n  // GitHub Actions API methods\n  \n  // Get workflows for a repository (using GitHub API to include workflow IDs)\n  async getWorkflows(owner, repo) {\n    if (!this.isAuth()) {\n      throw new Error('Not authenticated with GitHub');\n    }\n\n    try {\n      // Use GitHub Actions API to get workflows with their IDs\n      const { data } = await this.octokit.rest.actions.listRepoWorkflows({\n        owner,\n        repo\n      });\n\n      return data.workflows.map(workflow => ({\n        id: workflow.id, // This is the crucial missing piece!\n        name: workflow.name,\n        filename: workflow.path.split('/').pop(), // Extract filename from path\n        path: workflow.path,\n        state: workflow.state,\n        created_at: workflow.created_at,\n        updated_at: workflow.updated_at,\n        url: workflow.html_url,\n        triggers: ['unknown'], // GitHub API doesn't provide trigger info directly\n        lastModified: workflow.updated_at\n      }));\n    } catch (error) {\n      if (error.status === 404) {\n        // No workflows or repository not found\n        return [];\n      }\n      console.error('Failed to fetch workflows:', error);\n      throw error;\n    }\n  }\n\n  // Get workflow runs for a repository\n  async getWorkflowRuns(owner, repo, options = {}) {\n    if (!this.isAuth()) {\n      throw new Error('Not authenticated with GitHub');\n    }\n\n    try {\n      const params = {\n        owner,\n        repo,\n        per_page: options.per_page || 10,\n        page: options.page || 1\n      };\n\n      if (options.branch) {\n        params.branch = options.branch;\n      }\n\n      if (options.workflow_id) {\n        params.workflow_id = options.workflow_id;\n      }\n\n      const { data } = await this.octokit.rest.actions.listWorkflowRunsForRepo(params);\n      return data;\n    } catch (error) {\n      console.error('Failed to fetch workflow runs:', error);\n      throw error;\n    }\n  }\n\n  // Get workflow runs for a specific workflow\n  async getWorkflowRunsForWorkflow(owner, repo, workflow_id, options = {}) {\n    if (!this.isAuth()) {\n      throw new Error('Not authenticated with GitHub');\n    }\n\n    try {\n      const params = {\n        owner,\n        repo,\n        workflow_id,\n        per_page: options.per_page || 10,\n        page: options.page || 1\n      };\n\n      if (options.branch) {\n        params.branch = options.branch;\n      }\n\n      const { data } = await this.octokit.rest.actions.listWorkflowRuns(params);\n      return data;\n    } catch (error) {\n      console.error('Failed to fetch workflow runs for workflow:', error);\n      throw error;\n    }\n  }\n\n  // Trigger a workflow run\n  async triggerWorkflow(owner, repo, workflow_id, ref = 'main', inputs = {}) {\n    if (!this.isAuth()) {\n      throw new Error('Not authenticated with GitHub');\n    }\n\n    try {\n      const { data } = await this.octokit.rest.actions.createWorkflowDispatch({\n        owner,\n        repo,\n        workflow_id,\n        ref,\n        inputs\n      });\n      return data;\n    } catch (error) {\n      console.error('Failed to trigger workflow:', error);\n      throw error;\n    }\n  }\n\n  // Re-run a workflow\n  async rerunWorkflow(owner, repo, run_id) {\n    if (!this.isAuth()) {\n      throw new Error('Not authenticated with GitHub');\n    }\n\n    try {\n      const { data } = await this.octokit.rest.actions.reRunWorkflow({\n        owner,\n        repo,\n        run_id\n      });\n      return data;\n    } catch (error) {\n      console.error('Failed to re-run workflow:', error);\n      throw error;\n    }\n  }\n\n  // Get workflow run logs\n  async getWorkflowRunLogs(owner, repo, run_id) {\n    if (!this.isAuth()) {\n      throw new Error('Not authenticated with GitHub');\n    }\n\n    try {\n      const { data } = await this.octokit.rest.actions.downloadWorkflowRunLogs({\n        owner,\n        repo,\n        run_id\n      });\n      return data;\n    } catch (error) {\n      console.error('Failed to get workflow run logs:', error);\n      throw error;\n    }\n  }\n\n  // Approve a workflow run\n  async approveWorkflowRun(owner, repo, run_id) {\n    if (!this.isAuth()) {\n      throw new Error('Not authenticated with GitHub');\n    }\n\n    try {\n      const { data } = await this.octokit.rest.actions.approveWorkflowRun({\n        owner,\n        repo,\n        run_id\n      });\n      return data;\n    } catch (error) {\n      console.error('Failed to approve workflow run:', error);\n      throw error;\n    }\n  }\n\n  // Get commit comparison (diff)\n  async getCommitDiff(owner, repo, base, head) {\n    if (!this.isAuth()) {\n      throw new Error('Not authenticated with GitHub');\n    }\n\n    try {\n      const { data } = await this.octokit.rest.repos.compareCommits({\n        owner,\n        repo,\n        base,\n        head\n      });\n      return data;\n    } catch (error) {\n      console.error('Failed to get commit diff:', error);\n      throw error;\n    }\n  }\n\n  // Get commit details\n  async getCommit(owner, repo, sha) {\n    if (!this.isAuth()) {\n      throw new Error('Not authenticated with GitHub');\n    }\n\n    try {\n      const { data } = await this.octokit.rest.repos.getCommit({\n        owner,\n        repo,\n        ref: sha\n      });\n      return data;\n    } catch (error) {\n      console.error('Failed to get commit details:', error);\n      throw error;\n    }\n  }\n\n  // Releases API methods\n\n  // Get releases for a repository\n  async getReleases(owner, repo, options = {}) {\n    if (!this.isAuth()) {\n      throw new Error('Not authenticated with GitHub');\n    }\n\n    try {\n      const { data } = await this.octokit.rest.repos.listReleases({\n        owner,\n        repo,\n        per_page: options.per_page || 10,\n        page: options.page || 1\n      });\n      return data;\n    } catch (error) {\n      console.error('Failed to fetch releases:', error);\n      throw error;\n    }\n  }\n\n  // Get latest release\n  async getLatestRelease(owner, repo) {\n    if (!this.isAuth()) {\n      throw new Error('Not authenticated with GitHub');\n    }\n\n    try {\n      const { data } = await this.octokit.rest.repos.getLatestRelease({\n        owner,\n        repo\n      });\n      return data;\n    } catch (error) {\n      console.error('Failed to fetch latest release:', error);\n      throw error;\n    }\n  }\n\n  // Recursively fetch BPMN files from a directory and its subdirectories\n  async getBpmnFilesRecursive(owner, repo, path, ref = 'main', allFiles = []) {\n    try {\n      console.log(`🔎 githubService.getBpmnFilesRecursive: Searching ${owner}/${repo}/${path} (ref: ${ref})`);\n      // Use authenticated octokit if available, otherwise create a public instance\n      const octokit = this.isAuth() ? this.octokit : new Octokit();\n      console.log(`🔐 githubService.getBpmnFilesRecursive: Using ${this.isAuth() ? 'authenticated' : 'public'} octokit`);\n      \n      const { data } = await octokit.rest.repos.getContent({\n        owner,\n        repo,\n        path,\n        ref\n      });\n\n      console.log(`📦 githubService.getBpmnFilesRecursive: Received data type: ${Array.isArray(data) ? 'array' : 'single file'}, length: ${Array.isArray(data) ? data.length : 1}`);\n\n      // Handle single file response\n      if (!Array.isArray(data)) {\n        if (data.name.endsWith('.bpmn')) {\n          console.log(`📄 githubService.getBpmnFilesRecursive: Found single BPMN file: ${data.name}`);\n          allFiles.push(data);\n        }\n        return allFiles;\n      }\n\n      // Handle directory response\n      for (const item of data) {\n        if (item.type === 'file' && item.name.endsWith('.bpmn')) {\n          console.log(`📄 githubService.getBpmnFilesRecursive: Found BPMN file: ${item.name}`);\n          allFiles.push(item);\n        } else if (item.type === 'dir') {\n          console.log(`📁 githubService.getBpmnFilesRecursive: Found subdirectory: ${item.name}, recursing...`);\n          // Recursively search subdirectories\n          await this.getBpmnFilesRecursive(owner, repo, item.path, ref, allFiles);\n        }\n      }\n\n      console.log(`✅ githubService.getBpmnFilesRecursive: Completed search of ${path}, found ${allFiles.length} total files so far`);\n      return allFiles;\n    } catch (error) {\n      console.log(`❌ githubService.getBpmnFilesRecursive: Error searching ${path}:`, error.status, error.message);\n      // If directory doesn't exist, return empty array (not an error)\n      if (error.status === 404) {\n        return allFiles;\n      }\n      throw error;\n    }\n  }\n\n  // Get all BPMN files from a repository's business process directories\n  async getBpmnFiles(owner, repo, ref = 'main') {\n    console.log(`🔍 githubService.getBpmnFiles: Starting search for ${owner}/${repo} (ref: ${ref})`);\n    const allBpmnFiles = [];\n    \n    // Search for BPMN files in the specified business process directories\n    const possiblePaths = [\n      'input/business-processes',\n      'input/business-process'\n    ];\n\n    for (const path of possiblePaths) {\n      try {\n        console.log(`📁 githubService.getBpmnFiles: Searching in directory: ${path}`);\n        const files = await this.getBpmnFilesRecursive(owner, repo, path, ref);\n        console.log(`✅ githubService.getBpmnFiles: Found ${files.length} BPMN files in ${path}`);\n        allBpmnFiles.push(...files);\n      } catch (error) {\n        // Only log warnings for unexpected errors (not 404s which are expected when directories don't exist)\n        if (error.status !== 404) {\n          console.warn(`❌ Could not fetch BPMN files from ${path}:`, error.message);\n        } else {\n          console.log(`📂 githubService.getBpmnFiles: Directory ${path} not found (404) - this is expected if the directory doesn't exist`);\n        }\n        // Continue trying other paths\n      }\n    }\n\n    // Remove duplicates based on path (in case both directories exist and have overlapping files)\n    const uniqueFiles = allBpmnFiles.filter((file, index, self) => \n      index === self.findIndex(f => f.path === file.path)\n    );\n\n    console.log(`🎯 githubService.getBpmnFiles: Final result - ${uniqueFiles.length} unique BPMN files found`);\n    console.log(`📋 githubService.getBpmnFiles: File list:`, uniqueFiles.map(f => f.name));\n    return uniqueFiles;\n  }\n\n  // Get file content from GitHub repository with timeout handling\n  async getFileContent(owner, repo, path, ref = 'main') {\n    const timeoutMs = 15000; // 15 second timeout\n    \n    try {\n      console.log(`🚀 githubService.getFileContent: Starting request for ${owner}/${repo}/${path} (ref: ${ref})`);\n      console.log('🔐 githubService.getFileContent: Authentication status:', this.isAuth());\n      console.log('📋 githubService.getFileContent: Request parameters:', { owner, repo, path, ref });\n      \n      // Use authenticated octokit if available, otherwise create a public instance for public repos\n      const octokit = this.isAuth() ? this.octokit : new Octokit();\n      console.log('🔧 githubService.getFileContent: Using', this.isAuth() ? 'authenticated' : 'public', 'octokit instance');\n      \n      // Create a promise that rejects after timeout\n      const timeoutPromise = new Promise((_, reject) => {\n        console.log(`⏰ githubService.getFileContent: Setting up ${timeoutMs}ms timeout`);\n        setTimeout(() => {\n          console.error(`⏰ githubService.getFileContent: Request timed out after ${timeoutMs}ms`);\n          reject(new Error(`Request timeout after ${timeoutMs}ms`));\n        }, timeoutMs);\n      });\n      \n      // Race the GitHub API call against the timeout\n      console.log('🌐 githubService.getFileContent: Creating GitHub API promise...');\n      const apiPromise = octokit.rest.repos.getContent({\n        owner,\n        repo,\n        path,\n        ref\n      });\n      \n      console.log('📡 githubService.getFileContent: API request initiated, waiting for response...');\n      const startTime = Date.now();\n      \n      const { data } = await Promise.race([apiPromise, timeoutPromise]);\n      const responseTime = Date.now() - startTime;\n      \n      console.log(`✅ githubService.getFileContent: API response received in ${responseTime}ms`);\n      console.log('📂 githubService.getFileContent: Response data type:', data.type);\n      console.log('📊 githubService.getFileContent: Response details:', {\n        type: data.type,\n        name: data.name,\n        size: data.size,\n        encoding: data.encoding,\n        hasContent: !!data.content\n      });\n\n      // Handle file content\n      if (data.type === 'file' && data.content) {\n        // Decode base64 content\n        console.log('🔧 githubService.getFileContent: Decoding base64 content...');\n        console.log('📊 githubService.getFileContent: Base64 content length:', data.content.length);\n        \n        const content = decodeURIComponent(escape(atob(data.content)));\n        console.log(`✅ githubService.getFileContent: Successfully fetched and decoded file content`);\n        console.log('📏 githubService.getFileContent: Final content length:', content.length, 'characters');\n        console.log('👀 githubService.getFileContent: Content preview (first 200 chars):', content.substring(0, 200));\n        \n        return content;\n      } else {\n        console.error('❌ githubService.getFileContent: Invalid response - not a file or no content');\n        console.error('🔍 githubService.getFileContent: Full response data:', JSON.stringify(data, null, 2));\n        throw new Error('File not found or is not a file');\n      }\n    } catch (error) {\n      console.error(`💥 githubService.getFileContent: Failed to fetch file content from ${owner}/${repo}/${path}:`, error);\n      console.error('🔍 githubService.getFileContent: Error analysis:', {\n        type: typeof error,\n        status: error.status,\n        message: error.message,\n        name: error.name,\n        stack: error.stack?.substring(0, 500) + '...'\n      });\n      \n      // Provide more specific error messages\n      if (error.message.includes('timeout')) {\n        console.error('⏰ githubService.getFileContent: Timeout error detected');\n        throw new Error(`GitHub API request timed out after ${timeoutMs / 1000} seconds. Please try again.`);\n      } else if (error.status === 403) {\n        console.error('🔒 githubService.getFileContent: 403 Forbidden error detected');\n        throw new Error('Access denied. This repository may be private or you may have hit rate limits.');\n      } else if (error.status === 404) {\n        console.error('🔍 githubService.getFileContent: 404 Not Found error detected');\n        throw new Error('File not found in the repository.');\n      } else if (error.message.includes('rate limit')) {\n        console.error('🚦 githubService.getFileContent: Rate limit error detected');\n        throw new Error('GitHub API rate limit exceeded. Please try again later.');\n      } else if (error.message.includes('Network Error') || error.message.includes('Failed to fetch')) {\n        console.error('🌐 githubService.getFileContent: Network error detected');\n        throw new Error('Network error occurred. Please check your internet connection and try again.');\n      }\n      \n      console.error('❓ githubService.getFileContent: Unknown error type, re-throwing original error');\n      throw error;\n    }\n  }\n\n  // Create a commit with multiple files\n  async createCommit(owner, repo, branch, message, files) {\n    if (!this.isAuth()) {\n      throw new Error('Not authenticated with GitHub');\n    }\n\n    try {\n      // Get the latest commit SHA\n      const { data: refData } = await this.octokit.rest.git.getRef({\n        owner,\n        repo,\n        ref: `heads/${branch}`\n      });\n      const latestCommitSha = refData.object.sha;\n\n      // Get the tree SHA from the latest commit\n      const { data: commitData } = await this.octokit.rest.git.getCommit({\n        owner,\n        repo,\n        commit_sha: latestCommitSha\n      });\n      const baseTreeSha = commitData.tree.sha;\n\n      // Create blobs for all files\n      const blobs = await Promise.all(\n        files.map(async (file) => {\n          const { data: blobData } = await this.octokit.rest.git.createBlob({\n            owner,\n            repo,\n            content: file.content,\n            encoding: 'utf-8'\n          });\n          return {\n            path: file.path,\n            mode: '100644',\n            type: 'blob',\n            sha: blobData.sha\n          };\n        })\n      );\n\n      // Create a new tree with the blobs\n      const { data: treeData } = await this.octokit.rest.git.createTree({\n        owner,\n        repo,\n        base_tree: baseTreeSha,\n        tree: blobs\n      });\n\n      // Create the commit\n      const { data: newCommitData } = await this.octokit.rest.git.createCommit({\n        owner,\n        repo,\n        message,\n        tree: treeData.sha,\n        parents: [latestCommitSha]\n      });\n\n      // Update the branch reference\n      await this.octokit.rest.git.updateRef({\n        owner,\n        repo,\n        ref: `heads/${branch}`,\n        sha: newCommitData.sha\n      });\n\n      return {\n        sha: newCommitData.sha,\n        html_url: `https://github.com/${owner}/${repo}/commit/${newCommitData.sha}`,\n        message: newCommitData.message,\n        author: newCommitData.author,\n        committer: newCommitData.committer\n      };\n    } catch (error) {\n      console.error('Failed to create commit:', error);\n      throw error;\n    }\n  }\n\n  // Get recent commits for a repository branch\n  async getRecentCommits(owner, repo, branch = 'main', per_page = 5) {\n    if (!this.isAuth()) {\n      throw new Error('Not authenticated with GitHub');\n    }\n\n    const startTime = Date.now();\n    this.logger.apiCall('GET', `/repos/${owner}/${repo}/commits`, { sha: branch, per_page });\n\n    try {\n      const response = await this.octokit.rest.repos.listCommits({\n        owner,\n        repo,\n        sha: branch,\n        per_page\n      });\n\n      this.logger.apiResponse('GET', `/repos/${owner}/${repo}/commits`, response.status, Date.now() - startTime);\n      \n      return response.data.map(commit => ({\n        sha: commit.sha,\n        message: commit.commit.message,\n        author: {\n          name: commit.commit.author.name,\n          email: commit.commit.author.email,\n          date: commit.commit.author.date\n        },\n        committer: {\n          name: commit.commit.committer.name,\n          email: commit.commit.committer.email,\n          date: commit.commit.committer.date\n        },\n        html_url: commit.html_url,\n        stats: commit.stats\n      }));\n    } catch (error) {\n      this.logger.apiResponse('GET', `/repos/${owner}/${repo}/commits`, error.status || 'error', Date.now() - startTime);\n      console.error('Failed to fetch recent commits:', error);\n      throw error;\n    }\n  }\n\n  // Get open pull requests count\n  async getOpenPullRequestsCount(owner, repo) {\n    if (!this.isAuth()) {\n      throw new Error('Not authenticated with GitHub');\n    }\n\n    const startTime = Date.now();\n    this.logger.apiCall('GET', `/repos/${owner}/${repo}/pulls`, { state: 'open', per_page: 1 });\n\n    try {\n      const response = await this.octokit.rest.pulls.list({\n        owner,\n        repo,\n        state: 'open',\n        per_page: 1\n      });\n\n      this.logger.apiResponse('GET', `/repos/${owner}/${repo}/pulls`, response.status, Date.now() - startTime);\n      \n      // GitHub includes the total count in the response headers\n      const linkHeader = response.headers.link;\n      if (linkHeader && linkHeader.includes('rel=\"last\"')) {\n        const lastPageMatch = linkHeader.match(/page=(\\d+)>; rel=\"last\"/);\n        if (lastPageMatch) {\n          return parseInt(lastPageMatch[1], 10);\n        }\n      }\n      \n      // Fallback: use the length of returned items (may not be accurate for large counts)\n      return response.data.length;\n    } catch (error) {\n      this.logger.apiResponse('GET', `/repos/${owner}/${repo}/pulls`, error.status || 'error', Date.now() - startTime);\n      console.error('Failed to fetch pull requests count:', error);\n      throw error;\n    }\n  }\n\n  // Get pull request for a specific branch (returns first PR only for backward compatibility)\n  async getPullRequestForBranch(owner, repo, branchName) {\n    const prs = await this.getPullRequestsForBranch(owner, repo, branchName);\n    return prs && prs.length > 0 ? prs[0] : null;\n  }\n\n  // Get all pull requests for a specific branch\n  async getPullRequestsForBranch(owner, repo, branchName) {\n    // Use authenticated octokit if available, otherwise create a public instance for public repos\n    const octokit = this.isAuth() ? this.octokit : new Octokit();\n\n    const startTime = Date.now();\n    this.logger.apiCall('GET', `/repos/${owner}/${repo}/pulls`, { state: 'open', head: `${owner}:${branchName}` });\n\n    try {\n      const response = await octokit.rest.pulls.list({\n        owner,\n        repo,\n        state: 'open',\n        head: `${owner}:${branchName}`,\n        per_page: 100 // Get up to 100 PRs for a branch\n      });\n\n      this.logger.apiResponse('GET', `/repos/${owner}/${repo}/pulls`, response.status, Date.now() - startTime);\n      \n      // Return all matching PRs or empty array if none found\n      return response.data || [];\n    } catch (error) {\n      this.logger.apiResponse('GET', `/repos/${owner}/${repo}/pulls`, error.status || 'error', Date.now() - startTime);\n      console.error('Failed to fetch pull requests for branch:', error);\n      return []; // Return empty array instead of throwing to allow graceful fallback\n    }\n  }\n\n  // Get pull request comments\n  async getPullRequestComments(owner, repo, pullNumber, page = 1, per_page = 100) {\n    // Use authenticated octokit if available, otherwise create a public instance for public repos\n    const octokit = this.isAuth() ? this.octokit : new Octokit();\n\n    const startTime = Date.now();\n    this.logger.apiCall('GET', `/repos/${owner}/${repo}/pulls/${pullNumber}/comments`, { page, per_page });\n\n    try {\n      const response = await octokit.rest.pulls.listReviewComments({\n        owner,\n        repo,\n        pull_number: pullNumber,\n        page,\n        per_page\n      });\n\n      this.logger.apiResponse('GET', `/repos/${owner}/${repo}/pulls/${pullNumber}/comments`, response.status, Date.now() - startTime);\n      return response.data;\n    } catch (error) {\n      this.logger.apiResponse('GET', `/repos/${owner}/${repo}/pulls/${pullNumber}/comments`, error.status || 'error', Date.now() - startTime);\n      console.error('Failed to fetch pull request comments:', error);\n      throw error;\n    }\n  }\n\n  // Get pull request issue comments (general comments on the PR conversation)\n  async getPullRequestIssueComments(owner, repo, pullNumber, page = 1, per_page = 100) {\n    // Use authenticated octokit if available, otherwise create a public instance for public repos\n    const octokit = this.isAuth() ? this.octokit : new Octokit();\n\n    const startTime = Date.now();\n    this.logger.apiCall('GET', `/repos/${owner}/${repo}/issues/${pullNumber}/comments`, { page, per_page });\n\n    try {\n      const response = await octokit.rest.issues.listComments({\n        owner,\n        repo,\n        issue_number: pullNumber,\n        page,\n        per_page\n      });\n\n      this.logger.apiResponse('GET', `/repos/${owner}/${repo}/issues/${pullNumber}/comments`, response.status, Date.now() - startTime);\n      return response.data;\n    } catch (error) {\n      this.logger.apiResponse('GET', `/repos/${owner}/${repo}/issues/${pullNumber}/comments`, error.status || 'error', Date.now() - startTime);\n      console.error('Failed to fetch pull request issue comments:', error);\n      throw error;\n    }\n  }\n\n  // Create a comment on a pull request\n  async createPullRequestComment(owner, repo, pullNumber, body) {\n    if (!this.isAuth()) {\n      throw new Error('Not authenticated with GitHub');\n    }\n\n    const startTime = Date.now();\n    this.logger.apiCall('POST', `/repos/${owner}/${repo}/issues/${pullNumber}/comments`, { body });\n\n    try {\n      const response = await this.octokit.rest.issues.createComment({\n        owner,\n        repo,\n        issue_number: pullNumber,\n        body\n      });\n\n      this.logger.apiResponse('POST', `/repos/${owner}/${repo}/issues/${pullNumber}/comments`, response.status, Date.now() - startTime);\n      return response.data;\n    } catch (error) {\n      this.logger.apiResponse('POST', `/repos/${owner}/${repo}/issues/${pullNumber}/comments`, error.status || 'error', Date.now() - startTime);\n      console.error('Failed to create pull request comment:', error);\n      throw error;\n    }\n  }\n\n  // Get open issues count\n  async getOpenIssuesCount(owner, repo) {\n    if (!this.isAuth()) {\n      throw new Error('Not authenticated with GitHub');\n    }\n\n    const startTime = Date.now();\n    this.logger.apiCall('GET', `/repos/${owner}/${repo}/issues`, { state: 'open', per_page: 1 });\n\n    try {\n      const response = await this.octokit.rest.issues.listForRepo({\n        owner,\n        repo,\n        state: 'open',\n        per_page: 1\n      });\n\n      this.logger.apiResponse('GET', `/repos/${owner}/${repo}/issues`, response.status, Date.now() - startTime);\n      \n      // GitHub includes the total count in the response headers\n      const linkHeader = response.headers.link;\n      if (linkHeader && linkHeader.includes('rel=\"last\"')) {\n        const lastPageMatch = linkHeader.match(/page=(\\d+)>; rel=\"last\"/);\n        if (lastPageMatch) {\n          return parseInt(lastPageMatch[1], 10);\n        }\n      }\n      \n      // Fallback: use the length of returned items (may not be accurate for large counts)\n      return response.data.length;\n    } catch (error) {\n      this.logger.apiResponse('GET', `/repos/${owner}/${repo}/issues`, error.status || 'error', Date.now() - startTime);\n      console.error('Failed to fetch issues count:', error);\n      throw error;\n    }\n  }\n\n  // Get repository statistics (combined method for efficiency)\n  async getRepositoryStats(owner, repo, branch = 'main') {\n    if (!this.isAuth()) {\n      throw new Error('Not authenticated with GitHub');\n    }\n\n    try {\n      const [recentCommits, openPRsCount, openIssuesCount] = await Promise.allSettled([\n        this.getRecentCommits(owner, repo, branch, 1),\n        this.getOpenPullRequestsCount(owner, repo),\n        this.getOpenIssuesCount(owner, repo)\n      ]);\n\n      return {\n        recentCommits: recentCommits.status === 'fulfilled' ? recentCommits.value : [],\n        openPullRequestsCount: openPRsCount.status === 'fulfilled' ? openPRsCount.value : 0,\n        openIssuesCount: openIssuesCount.status === 'fulfilled' ? openIssuesCount.value : 0,\n        errors: {\n          recentCommits: recentCommits.status === 'rejected' ? recentCommits.reason : null,\n          openPullRequestsCount: openPRsCount.status === 'rejected' ? openPRsCount.reason : null,\n          openIssuesCount: openIssuesCount.status === 'rejected' ? openIssuesCount.reason : null\n        }\n      };\n    } catch (error) {\n      console.error('Failed to fetch repository stats:', error);\n      throw error;\n    }\n  }\n\n  // Get directory contents (supports both authenticated and unauthenticated access)\n  async getDirectoryContents(owner, repo, path = '', ref = 'main') {\n    try {\n      // Create temporary Octokit instance for unauthenticated access if needed\n      const octokit = this.isAuth() ? this.octokit : new Octokit();\n      \n      const { data } = await octokit.rest.repos.getContent({\n        owner,\n        repo,\n        path,\n        ref\n      });\n\n      if (Array.isArray(data)) {\n        return data;\n      } else {\n        throw new Error('Not a directory');\n      }\n    } catch (error) {\n      console.error(`Failed to get directory contents for ${path}:`, error);\n      throw error;\n    }\n  }\n\n  // Update file content (requires authentication)\n  async updateFile(owner, repo, path, content, message, branch = 'main') {\n    if (!this.isAuth()) {\n      throw new Error('Authentication required to update files');\n    }\n\n    try {\n      // First, get the current file to get its SHA\n      const { data: currentFile } = await this.octokit.rest.repos.getContent({\n        owner,\n        repo,\n        path,\n        ref: branch\n      });\n\n      if (Array.isArray(currentFile)) {\n        throw new Error('Path is a directory, not a file');\n      }\n\n      // Update the file\n      const { data } = await this.octokit.rest.repos.createOrUpdateFileContents({\n        owner,\n        repo,\n        path,\n        message,\n        content: btoa(unescape(encodeURIComponent(content))),\n        sha: currentFile.sha,\n        branch\n      });\n\n      return data;\n    } catch (error) {\n      console.error(`Failed to update file ${path}:`, error);\n      throw error;\n    }\n  }\n\n  // Get commits for a repository (supports unauthenticated access)\n  async getCommits(owner, repo, options = {}) {\n    try {\n      // Create temporary Octokit instance for unauthenticated access if needed\n      const octokit = this.isAuth() ? this.octokit : new Octokit();\n      \n      const params = {\n        owner,\n        repo,\n        per_page: options.per_page || 10,\n        page: options.page || 1\n      };\n\n      if (options.sha) {\n        params.sha = options.sha;\n      }\n\n      if (options.since) {\n        params.since = options.since;\n      }\n\n      if (options.until) {\n        params.until = options.until;\n      }\n\n      const { data } = await octokit.rest.repos.listCommits(params);\n      return data;\n    } catch (error) {\n      console.error('Failed to fetch commits:', error);\n      throw error;\n    }\n  }\n\n  // Get issues for a repository (supports unauthenticated access)\n  async getIssues(owner, repo, options = {}) {\n    try {\n      // Create temporary Octokit instance for unauthenticated access if needed\n      const octokit = this.isAuth() ? this.octokit : new Octokit();\n      \n      const params = {\n        owner,\n        repo,\n        state: options.state || 'all',\n        per_page: options.per_page || 30,\n        page: options.page || 1\n      };\n\n      if (options.labels) {\n        params.labels = options.labels;\n      }\n\n      if (options.milestone) {\n        params.milestone = options.milestone;\n      }\n\n      const { data } = await octokit.rest.issues.listForRepo(params);\n      return data;\n    } catch (error) {\n      console.error('Failed to fetch issues:', error);\n      throw error;\n    }\n  }\n\n  // Alias method for backward compatibility - delegates to getIssues\n  async getRepositoryIssues(owner, repo, options = {}) {\n    return this.getIssues(owner, repo, options);\n  }\n\n  // Get repository forks\n  async getForks(owner, repo, options = {}) {\n    const startTime = Date.now();\n    this.logger.apiCall('GET', `/repos/${owner}/${repo}/forks`, options);\n\n    try {\n      // Use the GitHub API to fetch forks, no authentication required for public repos\n      const octokit = this.isAuth() ? this.octokit : new Octokit();\n      \n      const params = {\n        owner,\n        repo,\n        sort: options.sort || 'newest',\n        per_page: options.per_page || 100,\n        page: options.page || 1\n      };\n\n      const { data } = await octokit.rest.repos.listForks(params);\n      \n      this.logger.apiResponse('GET', `/repos/${owner}/${repo}/forks`, 200, Date.now() - startTime);\n      \n      // Return formatted fork data\n      return data.map(fork => ({\n        id: fork.id,\n        name: fork.name,\n        full_name: fork.full_name,\n        owner: {\n          login: fork.owner.login,\n          avatar_url: fork.owner.avatar_url,\n          html_url: fork.owner.html_url,\n          type: fork.owner.type\n        },\n        description: fork.description,\n        html_url: fork.html_url,\n        clone_url: fork.clone_url,\n        created_at: fork.created_at,\n        updated_at: fork.updated_at,\n        pushed_at: fork.pushed_at,\n        stargazers_count: fork.stargazers_count,\n        forks_count: fork.forks_count,\n        open_issues_count: fork.open_issues_count,\n        default_branch: fork.default_branch,\n        private: fork.private,\n        fork: fork.fork,\n        parent: fork.parent ? {\n          full_name: fork.parent.full_name,\n          html_url: fork.parent.html_url\n        } : null\n      }));\n    } catch (error) {\n      this.logger.apiResponse('GET', `/repos/${owner}/${repo}/forks`, error.status || 'error', Date.now() - startTime);\n      console.error('Failed to fetch repository forks:', error);\n      throw error;\n    }\n  }\n\n  // Get pull requests for a specific repository\n  async getPullRequests(owner, repo, options = {}) {\n    const startTime = Date.now();\n    this.logger.apiCall('GET', `/repos/${owner}/${repo}/pulls`, options);\n\n    try {\n      // Use the GitHub API to fetch pull requests, no authentication required for public repos\n      const octokit = this.isAuth() ? this.octokit : new Octokit();\n      \n      const params = {\n        owner,\n        repo,\n        state: options.state || 'open',\n        sort: options.sort || 'updated',\n        direction: options.direction || 'desc',\n        per_page: options.per_page || 30,\n        page: options.page || 1\n      };\n\n      // Add optional filters\n      if (options.head) {\n        params.head = options.head;\n      }\n      if (options.base) {\n        params.base = options.base;\n      }\n\n      const { data } = await octokit.rest.pulls.list(params);\n      \n      this.logger.apiResponse('GET', `/repos/${owner}/${repo}/pulls`, 200, Date.now() - startTime);\n      \n      // Return formatted pull request data\n      return data.map(pr => ({\n        id: pr.id,\n        number: pr.number,\n        title: pr.title,\n        body: pr.body,\n        state: pr.state,\n        locked: pr.locked,\n        user: {\n          login: pr.user.login,\n          avatar_url: pr.user.avatar_url,\n          html_url: pr.user.html_url,\n          type: pr.user.type\n        },\n        created_at: pr.created_at,\n        updated_at: pr.updated_at,\n        closed_at: pr.closed_at,\n        merged_at: pr.merged_at,\n        html_url: pr.html_url,\n        diff_url: pr.diff_url,\n        patch_url: pr.patch_url,\n        head: {\n          ref: pr.head.ref,\n          sha: pr.head.sha,\n          repo: pr.head.repo ? {\n            name: pr.head.repo.name,\n            full_name: pr.head.repo.full_name,\n            owner: {\n              login: pr.head.repo.owner.login,\n              avatar_url: pr.head.repo.owner.avatar_url\n            },\n            html_url: pr.head.repo.html_url\n          } : null\n        },\n        base: {\n          ref: pr.base.ref,\n          sha: pr.base.sha,\n          repo: {\n            name: pr.base.repo.name,\n            full_name: pr.base.repo.full_name,\n            owner: {\n              login: pr.base.repo.owner.login,\n              avatar_url: pr.base.repo.owner.avatar_url\n            },\n            html_url: pr.base.repo.html_url\n          }\n        },\n        draft: pr.draft,\n        mergeable: pr.mergeable,\n        mergeable_state: pr.mergeable_state,\n        comments: pr.comments,\n        review_comments: pr.review_comments,\n        commits: pr.commits,\n        additions: pr.additions,\n        deletions: pr.deletions,\n        changed_files: pr.changed_files\n      }));\n    } catch (error) {\n      this.logger.apiResponse('GET', `/repos/${owner}/${repo}/pulls`, error.status || 'error', Date.now() - startTime);\n      console.error('Failed to fetch pull requests:', error);\n      throw error;\n    }\n  }\n\n  // Logout\n  logout() {\n    this.logger.auth('Logging out and clearing stored token');\n    \n    this.octokit = null;\n    this.isAuthenticated = false;\n    this.tokenType = null;\n    this.permissions = null;\n    \n    // Clear secure token storage\n    secureTokenStorage.clearToken();\n    \n    // Clear branch context on logout\n    try {\n      const { default: branchContextService } = require('../services/branchContextService');\n      branchContextService.clearAllBranchContext();\n    } catch (error) {\n      // Service might not be available during testing\n      sessionStorage.removeItem('sgex_branch_context');\n    }\n  }\n\n  // Get repository forks\n  async getRepositoryForks(owner, repo, options = {}) {\n    const startTime = Date.now();\n    this.logger.debug('Fetching repository forks', { owner, repo, options });\n\n    try {\n      // Create temporary Octokit instance for unauthenticated access if needed\n      const octokit = this.isAuth() ? this.octokit : new Octokit();\n      \n      this.logger.apiCall('GET', `/repos/${owner}/${repo}/forks`, options);\n      \n      const { data } = await octokit.rest.repos.listForks({\n        owner,\n        repo,\n        sort: 'newest', // Sort by newest first\n        per_page: options.per_page || 100,\n        page: options.page || 1\n      });\n\n      const duration = Date.now() - startTime;\n      this.logger.apiResponse('GET', `/repos/${owner}/${repo}/forks`, 200, duration, { forkCount: data.length });\n      this.logger.performance('Repository forks fetch', duration);\n\n      return data;\n    } catch (error) {\n      const duration = Date.now() - startTime;\n      this.logger.apiError('GET', `/repos/${owner}/${repo}/forks`, error);\n      this.logger.performance('Repository forks fetch (failed)', duration);\n      console.error(`Failed to fetch forks for ${owner}/${repo}:`, error);\n      throw error;\n    }\n  }\n}\n\n// Create a singleton instance\nconst githubService = new GitHubService();\n\nexport default githubService;","/**\n * Service for managing DAK branch context in session storage\n * Stores selected branch per repository to maintain context during DAK editing\n */\n\nclass BranchContextService {\n  constructor() {\n    this.storageKey = 'sgex_branch_context';\n  }\n\n  // Get the storage key for a specific repository\n  getRepositoryKey(repository) {\n    if (!repository || !repository.name) return null;\n    const owner = repository.owner?.login || repository.full_name?.split('/')[0];\n    if (!owner) return null;\n    return `${owner}/${repository.name}`;\n  }\n\n  // Get the selected branch for a repository\n  getSelectedBranch(repository) {\n    if (!repository) return null;\n    \n    try {\n      const branchContext = this.getBranchContext();\n      const repoKey = this.getRepositoryKey(repository);\n      return branchContext[repoKey] || null;\n    } catch (error) {\n      console.warn('Failed to get branch context:', error);\n      return null;\n    }\n  }\n\n  // Set the selected branch for a repository\n  setSelectedBranch(repository, branch) {\n    if (!repository || !branch) return;\n\n    try {\n      const branchContext = this.getBranchContext();\n      const repoKey = this.getRepositoryKey(repository);\n      branchContext[repoKey] = branch;\n      this.setBranchContext(branchContext);\n    } catch (error) {\n      console.warn('Failed to set branch context:', error);\n    }\n  }\n\n  // Clear branch context for a specific repository\n  clearRepositoryBranch(repository) {\n    if (!repository) return;\n\n    try {\n      const branchContext = this.getBranchContext();\n      const repoKey = this.getRepositoryKey(repository);\n      delete branchContext[repoKey];\n      this.setBranchContext(branchContext);\n    } catch (error) {\n      console.warn('Failed to clear repository branch context:', error);\n    }\n  }\n\n  // Clear all branch context (e.g., on logout)\n  clearAllBranchContext() {\n    try {\n      sessionStorage.removeItem(this.storageKey);\n    } catch (error) {\n      console.warn('Failed to clear branch context:', error);\n    }\n  }\n\n  // Get all branch context from storage\n  getBranchContext() {\n    try {\n      const stored = sessionStorage.getItem(this.storageKey);\n      return stored ? JSON.parse(stored) : {};\n    } catch (error) {\n      console.warn('Failed to parse branch context from storage:', error);\n      return {};\n    }\n  }\n\n  // Set branch context to storage\n  setBranchContext(context) {\n    try {\n      sessionStorage.setItem(this.storageKey, JSON.stringify(context));\n    } catch (error) {\n      console.warn('Failed to save branch context to storage:', error);\n    }\n  }\n\n  // Get default branch name (prefer 'main' over 'master')\n  getDefaultBranchName(repository, availableBranches = []) {\n    if (!repository) return 'main';\n\n    // First try 'main'\n    if (availableBranches.some(b => b.name === 'main')) {\n      return 'main';\n    }\n\n    // Then try the repository's default branch\n    if (repository.default_branch && \n        availableBranches.some(b => b.name === repository.default_branch)) {\n      return repository.default_branch;\n    }\n\n    // Finally fall back to the first available branch or 'main'\n    return availableBranches.length > 0 ? availableBranches[0].name : 'main';\n  }\n\n  // Check if a branch context exists for a repository\n  hasBranchContext(repository) {\n    return this.getSelectedBranch(repository) !== null;\n  }\n\n  // Get a formatted display string for the current branch context\n  getBranchDisplayInfo(repository) {\n    const selectedBranch = this.getSelectedBranch(repository);\n    if (!selectedBranch) return null;\n\n    const isDefault = selectedBranch === (repository?.default_branch || 'main');\n    return {\n      branch: selectedBranch,\n      isDefault,\n      displayText: isDefault ? `${selectedBranch} (default)` : selectedBranch\n    };\n  }\n}\n\n// Create a singleton instance\nconst branchContextService = new BranchContextService();\n\nexport default branchContextService;"],"names":["async","processConcurrently","items","processor","options","arguments","length","undefined","concurrency","onProgress","onItemComplete","onItemStart","results","Array","total","completed","queue","map","item","index","workers","Math","min","fill","shift","result","error","worker","Promise","all","constructor","ttlMinutes","this","cache","Map","ttl","_getCacheKey","owner","repo","concat","_isValid","entry","Date","now","timestamp","get","key","compatible","delete","set","clear","cleanup","entries","getStats","size","from","_ref","repository","ageMinutes","round","logger","getLogger","storageKey","expirationHours","debug","generateBrowserFingerprint","canvas","document","createElement","ctx","getContext","textBaseline","font","fillText","fingerprint","navigator","userAgent","language","window","screen","width","height","colorDepth","getTimezoneOffset","toDataURL","join","hash","i","charCodeAt","abs","toString","xorCipher","text","String","fromCharCode","validateTokenFormat","token","isValid","type","reason","cleanToken","trim","match","maskToken","substring","repeat","storeToken","validation","warn","tokenMask","encryptionKey","encryptedToken","storageData","btoa","created","expires","sessionStorage","setItem","JSON","stringify","localStorage","removeItem","toISOString","message","retrieveToken","storedData","getItem","data","parse","clearToken","currentFingerprint","atob","decryptedToken","hasValidToken","getTokenInfo","timeRemaining","max","isExpired","migrateLegacyToken","legacyToken","octokit","isAuthenticated","permissions","tokenType","authenticate","startTime","auth","tokenProvided","secureTokenStorage","Octokit","stored","duration","securelyStored","performance","console","authenticateWithOctokit","octokitInstance","initializeFromStoredToken","tokenData","hasStoredToken","getStoredTokenInfo","checkTokenPermissions","isAuth","Error","apiCall","response","request","apiResponse","status","rateLimitStart","rateLimit","rest","resources","core","hasCore","rateLimitError","user","username","login","apiError","checkRepositoryWritePermissions","getCurrentUser","repos","getCollaboratorPermissionLevel","hasWriteAccess","includes","permission","checkRepositoryPermissions","checkCommentPermissions","per_page","issues","listForRepo","state","users","getAuthenticated","getUserOrganizations","orgs","listForAuthenticatedUser","getOrganization","orgLogin","org","getUser","getByUsername","getPublicRepositories","repositories","page","hasMorePages","listForUser","sort","listForOrg","getWHOOrganization","whoData","id","display_name","name","description","avatar_url","html_url","can_create_repositories","can_create_private_repositories","plan","private_repos","isWHO","getRepositories","getDemoRepositories","getSmartGuidelinesRepositories","demoRepos","full_name","private","clone_url","stargazers_count","forks_count","open_issues_count","topics","created_at","updated_at","pushed_at","default_branch","smart_guidelines_compatible","isDemo","resolve","checkSmartGuidelinesCompatibility","retryCount","cachedResult","repositoryCompatibilityCache","getContent","path","content","isCompatible","decodeURIComponent","escape","delay","setTimeout","smartGuidelinesRepos","push","_objectSpread","getSmartGuidelinesRepositoriesProgressive","onRepositoryFound","log","current","currentRepo","progress","random","smartRepo","started","filter","getRepository","getBranches","listBranches","createBranch","branchName","fromBranch","refData","git","getRef","ref","createRef","sha","object","getBranch","branch","getWorkflows","actions","listRepoWorkflows","workflows","workflow","filename","split","pop","url","triggers","lastModified","getWorkflowRuns","params","workflow_id","listWorkflowRunsForRepo","getWorkflowRunsForWorkflow","listWorkflowRuns","triggerWorkflow","inputs","createWorkflowDispatch","rerunWorkflow","run_id","reRunWorkflow","getWorkflowRunLogs","downloadWorkflowRunLogs","approveWorkflowRun","getCommitDiff","base","head","compareCommits","getCommit","getReleases","listReleases","getLatestRelease","getBpmnFilesRecursive","allFiles","isArray","endsWith","getBpmnFiles","allBpmnFiles","possiblePaths","files","uniqueFiles","file","self","findIndex","f","getFileContent","timeoutMs","timeoutPromise","_","reject","apiPromise","race","responseTime","encoding","hasContent","_error$stack","stack","createCommit","latestCommitSha","commitData","commit_sha","baseTreeSha","tree","blobs","blobData","createBlob","mode","treeData","createTree","base_tree","newCommitData","parents","updateRef","author","committer","getRecentCommits","listCommits","commit","email","date","stats","getOpenPullRequestsCount","pulls","list","linkHeader","headers","link","lastPageMatch","parseInt","getPullRequestForBranch","prs","getPullRequestsForBranch","getPullRequestComments","pullNumber","listReviewComments","pull_number","getPullRequestIssueComments","listComments","issue_number","createPullRequestComment","body","createComment","getOpenIssuesCount","getRepositoryStats","recentCommits","openPRsCount","openIssuesCount","allSettled","value","openPullRequestsCount","errors","getDirectoryContents","updateFile","currentFile","createOrUpdateFileContents","unescape","encodeURIComponent","getCommits","since","until","getIssues","labels","milestone","getRepositoryIssues","getForks","listForks","fork","parent","getPullRequests","direction","pr","number","title","locked","closed_at","merged_at","diff_url","patch_url","draft","mergeable","mergeable_state","comments","review_comments","commits","additions","deletions","changed_files","logout","default","branchContextService","require","clearAllBranchContext","getRepositoryForks","forkCount","getRepositoryKey","_repository$owner","_repository$full_name","getSelectedBranch","branchContext","getBranchContext","setSelectedBranch","setBranchContext","clearRepositoryBranch","context","getDefaultBranchName","availableBranches","some","b","hasBranchContext","getBranchDisplayInfo","selectedBranch","isDefault","displayText"],"sourceRoot":""}