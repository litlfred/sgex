"use strict";(self.webpackChunksgex_workbench=self.webpackChunksgex_workbench||[]).push([[7018],{49162:(e,t,s)=>{s.d(t,{Q5:()=>n,hI:()=>o,kv:()=>c,q_:()=>i,uC:()=>a,x:()=>r});const r={DAK:"dak",COMPONENT:"component",ASSET:"asset"};class n{constructor(e){let{id:t,level:s,title:r,description:n,parameters:o=[],tags:i=[],version:a="1.0.0",isTemplate:c=!1,componentTypes:l=[],assetTypes:u=[]}=e;this.id=t,this.level=s,this.title=r,this.description=n,this.parameters=o,this.tags=i,this.version=a,this.isTemplate=c,this.componentTypes=l,this.assetTypes=u}}class o{constructor(e){let{name:t,type:s="string",required:r=!1,description:n="",defaultValue:o=null,validation:i={}}=e;this.name=t,this.type=s,this.required=r,this.description=n,this.defaultValue=o,this.validation=i}}class i{constructor(e){let{repository:t,locale:s="en_US",branch:r="main",user:n=null,assetFile:o=null,componentType:i=null,storage:a=null}=e;this.repository=t,this.locale=s,this.branch=r,this.user=n,this.assetFile=o,this.componentType=i,this.storage=a}}class a{constructor(e){let{structured:t={},narrative:s="",warnings:r=[],errors:n=[],meta:o={}}=e;this.structured=t,this.narrative=s,this.warnings=r,this.errors=n,this.meta=o}}class c{constructor(e){let{scope:t="repository",key:s="",ttl:r=3600,dependencies:n=[]}=e;this.scope=t,this.key=s,this.ttl=r,this.dependencies=n}}},87018:(e,t,s)=>{s.d(t,{A:()=>u});var r=s(89379),n=s(49162),o=s(16558);const i=new class{constructor(){this.registry=null,this.loaded=!1}loadFromYaml(e){try{this.registry=o.default.load(e),this.loaded=!0}catch(t){throw new Error("Failed to parse parameter registry YAML: ".concat(t.message))}}getParameters(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null;if(!this.loaded||!this.registry)throw new Error("Parameter registry not loaded");const s=[];if(this.registry.defaults)for(const[r,i]of Object.entries(this.registry.defaults))s.push(new n.hI({name:r,type:i.type,required:i.required||!1,description:i.description||"",defaultValue:i.default||null,validation:i.validation||{}}));if(this.registry[e])if(t&&this.registry[e][t])for(const[i,a]of Object.entries(this.registry[e][t]))s.push(new n.hI((0,r.A)({name:i},a)));else if(!t)for(const[i,a]of Object.entries(this.registry[e]))"object"===typeof a&&a.type&&s.push(new n.hI((0,r.A)({name:i},a)));const o=new Map;return s.forEach(e=>{o.set(e.name,e)}),Array.from(o.values())}validateParameters(e,t){let s=arguments.length>2&&void 0!==arguments[2]?arguments[2]:null;const r=this.getParameters(t,s),n={},o=[];for(const i of r){const t=e[i.name];if(i.required&&(void 0===t||null===t)){o.push("Required parameter '".concat(i.name,"' is missing"));continue}const s=void 0!==t?t:i.defaultValue;if(null!==s&&void 0!==s){const e=this.validateParameterType(s,i);if(e){o.push("Parameter '".concat(i.name,"': ").concat(e));continue}const t=this.validateParameterCustom(s,i);if(t){o.push("Parameter '".concat(i.name,"': ").concat(t));continue}}n[i.name]=s}for(const i of Object.keys(e))r.find(e=>e.name===i)||o.push("Unknown parameter '".concat(i,"'"));return{normalized:n,errors:o,isValid:0===o.length}}validateParameterType(e,t){const s=t.type,r=typeof e;switch(s){case"string":if("string"!==r)return"Expected string, got ".concat(r);break;case"boolean":if("boolean"!==r)return"Expected boolean, got ".concat(r);break;case"number":if("number"!==r||isNaN(e))return"Expected number, got ".concat(r);break;case"array":if(!Array.isArray(e))return"Expected array, got ".concat(r);break;case"object":if("object"!==r||Array.isArray(e))return"Expected object, got ".concat(r);break;default:return"Unknown type: ".concat(s)}return null}validateParameterCustom(e,t){if(!t.validation)return null;const s=t.validation;if(s.pattern&&"string"===typeof e){if(!new RegExp(s.pattern).test(e))return"Value does not match pattern ".concat(s.pattern)}return s.enum&&Array.isArray(s.enum)&&!s.enum.includes(e)?"Value must be one of: ".concat(s.enum.join(", ")):void 0!==s.minLength&&"string"===typeof e&&e.length<s.minLength?"String must be at least ".concat(s.minLength," characters"):void 0!==s.maxLength&&"string"===typeof e&&e.length>s.maxLength?"String must be at most ".concat(s.maxLength," characters"):void 0!==s.min&&"number"===typeof e&&e<s.min?"Number must be at least ".concat(s.min):void 0!==s.max&&"number"===typeof e&&e>s.max?"Number must be at most ".concat(s.max):null}getParameterSchema(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null;const s=this.getParameters(e,t),r={},n=[];for(const o of s){const e={type:o.type,description:o.description};null!==o.defaultValue&&(e.default=o.defaultValue),o.validation&&Object.assign(e,o.validation),r[o.name]=e,o.required&&n.push(o.name)}return{type:"object",properties:r,required:n}}};i.loadFromYaml('\ndefaults:\n  repository:\n    type: string\n    required: true\n    description: "Repository context (always required)"\n  locale:\n    type: string\n    required: false\n    default: "en_US"\n    description: "Locale for responses"\n  branch:\n    type: string\n    required: false\n    default: "main"\n    description: "Git branch context"\n\ndak:\n\ncomponent:\n  businessProcess:\n    componentType:\n      type: string\n      required: true\n      default: "businessProcess"\n      description: "Type of component being analyzed"\n\nasset:\n  lesson:\n    assetFile:\n      type: string\n      required: true\n      description: "Relative path to the lesson file"\n');const a=i;class c{async readFile(e){throw new Error("readFile must be implemented by subclass")}async fileExists(e){throw new Error("fileExists must be implemented by subclass")}async listFiles(e){throw new Error("listFiles must be implemented by subclass")}async getFileInfo(e){throw new Error("getFileInfo must be implemented by subclass")}}class l extends c{constructor(e,t){let s=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"main";super(),this.githubService=e,this.repository=t,this.branch=s,this.cache=new Map}parseRepository(e){if("string"===typeof e){if(e.includes("github.com")){const t=e.match(/github\.com\/([^/]+)\/([^/?#]+)/);if(t)return{owner:t[1],repo:t[2].replace(/\.git$/,"")}}const t=e.split("/");if(2===t.length)return{owner:t[0],repo:t[1]}}throw new Error("Invalid repository format: ".concat(e))}async readFile(e){const t="".concat(this.repository,":").concat(this.branch,":").concat(e);if(this.cache.has(t))return console.log("GitHubStorage.readFile: Cache hit for ".concat(e)),this.cache.get(t);try{const{owner:s,repo:r}=this.parseRepository(this.repository);console.log("GitHubStorage.readFile: Reading file ".concat(e," from ").concat(s,"/").concat(r," (branch: ").concat(this.branch,")")),console.log("GitHubStorage.readFile: About to call githubService.getFileContent...");const n=await this.githubService.getFileContent(s,r,e,this.branch);if(console.log("GitHubStorage.readFile: \u2705 GitHub service call completed successfully"),console.log("GitHubStorage.readFile: Received content - type: ".concat(typeof n,", length: ").concat((null===n||void 0===n?void 0:n.length)||"undefined")),"string"!==typeof n)throw console.error("GitHubStorage.readFile: \u274c Expected string but got ".concat(typeof n,":"),n),new Error("GitHub service returned invalid content type: ".concat(typeof n));0===n.length&&console.warn("GitHubStorage.readFile: \u26a0\ufe0f Content string is empty for ".concat(e)),console.log("GitHubStorage.readFile: Converting string to Uint8Array...");const o=(new TextEncoder).encode(n);return console.log("GitHubStorage.readFile: \u2705 Uint8Array created successfully, size: ".concat(o.length," bytes")),this.cache.set(t,o),console.log("GitHubStorage.readFile: \u2705 Successfully read file ".concat(e,", cached and returning content")),console.log("GitHubStorage.readFile: Content preview (first 200 chars):",n.substring(0,200)),o}catch(r){var s;throw console.error("GitHubStorage.readFile: \u274c Failed to read file ".concat(e,":"),r),console.error("GitHubStorage.readFile: Error details:",{message:r.message,name:r.name,stack:null===(s=r.stack)||void 0===s?void 0:s.substring(0,500)}),new Error("Failed to read file ".concat(e,": ").concat(r.message))}}async fileExists(e){try{console.log("GitHubStorage.fileExists: Checking if file exists: ".concat(e)),console.log("GitHubStorage.fileExists: Repository: ".concat(this.repository,", Branch: ").concat(this.branch));const{owner:t,repo:s}=this.parseRepository(this.repository);console.log("GitHubStorage.fileExists: Parsed repository - owner: ".concat(t,", repo: ").concat(s)),this.githubService&&this.githubService.isAuth?console.log("GitHubStorage.fileExists: Authentication status: ".concat(this.githubService.isAuth())):console.log("GitHubStorage.fileExists: GitHub service not available or no auth method"),console.log("GitHubStorage.fileExists: About to call readFile...");const r=await this.readFile(e);return console.log("GitHubStorage.fileExists: readFile completed successfully for ".concat(e,", content size: ").concat((null===r||void 0===r?void 0:r.length)||"undefined")),console.log("GitHubStorage.fileExists: File ".concat(e," exists - returning true")),!0}catch(s){var t;return console.error("GitHubStorage.fileExists: readFile failed for ".concat(e,":"),s.message),console.error("GitHubStorage.fileExists: Full error details:",{name:s.name,message:s.message,stack:null===(t=s.stack)||void 0===t?void 0:t.substring(0,300)}),console.log("GitHubStorage.fileExists: File ".concat(e," does not exist - returning false")),!1}}async listFiles(e){try{const{owner:t,repo:s}=this.parseRepository(this.repository),r=(await this.githubService.getRepositoryTree(t,s,this.branch,!0)).tree.filter(e=>"blob"===e.type).map(e=>e.path);if(e.includes("*")||e.includes("?")){const t=e.replace(/\./g,"\\.").replace(/\*/g,".*").replace(/\?/g,"."),s=new RegExp("^".concat(t,"$"));return r.filter(e=>s.test(e))}return r.filter(t=>t.startsWith(e))}catch(t){throw new Error("Failed to list files: ".concat(t.message))}}async getFileInfo(e){try{const{owner:t,repo:s}=this.parseRepository(this.repository),r=await this.githubService.getFileContent(t,s,e,this.branch);return{size:atob(r.content).length,sha:r.sha,path:r.path,type:r.type,url:r.html_url}}catch(t){throw new Error("Failed to get file info for ".concat(e,": ").concat(t.message))}}}const u=new class{constructor(){this.questionRegistry=new Map,this.initialized=!1}async initialize(){if(!this.initialized)try{await this.loadQuestions(),this.initialized=!0}catch(e){throw new Error("Failed to initialize FAQ engine: ".concat(e.message))}}async loadQuestions(){const e=[{id:"dak-name",module:()=>s.e(399).then(s.bind(s,30399))},{id:"dak-version",module:()=>s.e(3714).then(s.bind(s,33714))},{id:"business-process-workflows",module:()=>s.e(7076).then(s.bind(s,97076))},{id:"decision-table-inputs",module:()=>s.e(5619).then(s.bind(s,85619))}];for(const s of e)try{const e=await s.module();e.metadata&&e.execute?this.questionRegistry.set(s.id,{metadata:e.metadata,execute:e.execute,Render:e.Render||null}):console.warn("Question ".concat(s.id," is missing required exports (metadata, execute)"))}catch(t){console.error("Failed to load question ".concat(s.id,":"),t)}}getCatalog(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};if(!this.initialized)throw new Error("FAQ engine not initialized");let t=Array.from(this.questionRegistry.values()).map(e=>e.metadata);return e.level&&(t=t.filter(t=>t.level===e.level)),e.tags&&Array.isArray(e.tags)&&(t=t.filter(t=>e.tags.some(e=>t.tags.includes(e)))),e.componentType&&(t=t.filter(t=>!t.componentTypes||0===t.componentTypes.length||t.componentTypes.includes(e.componentType))),e.assetType&&(t=t.filter(t=>!t.assetTypes||0===t.assetTypes.length||t.assetTypes.includes(e.assetType))),t}async executeBatch(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};this.initialized||await this.initialize();const s=[];for(const o of e)try{const e=await this.executeQuestion(o,t);s.push({questionId:o.questionId,success:!0,result:e})}catch(r){s.push({questionId:o.questionId,success:!1,error:r.message,result:new n.uC({structured:{},narrative:this.getErrorNarrative(o.locale||"en_US",r.message),errors:[r.message],meta:{}})})}return s}async executeQuestion(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};const{questionId:s,parameters:o={},assetFiles:i=[]}=e,c=this.questionRegistry.get(s);if(!c)throw new Error("Question not found: ".concat(s));if(c.metadata.isTemplate&&i.length>0)return await this.executeTemplateQuestion(c,e,t);const l=a.validateParameters(o,c.metadata.level,this.getQuestionType(c.metadata));if(!l.isValid)throw new Error("Parameter validation failed: ".concat(l.errors.join(", ")));const u=this.createStorage(l.normalized,t),h=new n.q_({repository:l.normalized.repository,locale:l.normalized.locale||"en_US",branch:l.normalized.branch||"main",user:t.user||null,assetFile:l.normalized.assetFile||null,componentType:l.normalized.componentType||null,storage:u}),d=(0,r.A)((0,r.A)({},l.normalized),{},{storage:u,context:h});return await c.execute(d)}async executeTemplateQuestion(e,t,s){const{parameters:o={},assetFiles:i=[]}=t,c=[],l=[],u=[];for(const g of i)try{const t=(0,r.A)((0,r.A)({},o),{},{assetFile:g}),i=a.validateParameters(t,e.metadata.level,this.getQuestionType(e.metadata));if(!i.isValid){u.push("Asset ".concat(g,": ").concat(i.errors.join(", ")));continue}const h=this.createStorage(i.normalized,s),d=new n.q_({repository:i.normalized.repository,locale:i.normalized.locale||"en_US",branch:i.normalized.branch||"main",user:s.user||null,assetFile:g,componentType:i.normalized.componentType||null,storage:h}),p=(0,r.A)((0,r.A)({},i.normalized),{},{storage:h,context:d}),m=await e.execute(p);c.push({assetFile:g,result:m}),m.warnings&&l.push(...m.warnings),m.errors&&u.push(...m.errors)}catch(p){u.push("Asset ".concat(g,": ").concat(p.message))}const h={assets:c.map(e=>(0,r.A)({assetFile:e.assetFile},e.result.structured)),summary:{totalAssets:i.length,successfulAssets:c.length,failedAssets:i.length-c.length}},d=this.aggregateNarratives(c,t.locale||"en_US");return new n.uC({structured:h,narrative:d,warnings:l,errors:u,meta:{isAggregated:!0,questionId:e.metadata.id,assetCount:i.length}})}createStorage(e,t){if(t.githubService)return new l(t.githubService,e.repository,e.branch||"main");throw new Error("Local storage not implemented in web context")}getQuestionType(e){return e.componentTypes&&e.componentTypes.length>0?e.componentTypes[0]:e.assetTypes&&e.assetTypes.length>0?e.assetTypes[0]:null}aggregateNarratives(e,t){if(0===e.length)return"<h4>No Results</h4><p>No assets were processed successfully.</p>";let s="<h4>Asset Analysis Results</h4>";s+="<p>Processed ".concat(e.length," asset(s):</p>"),s+="<ul>";for(const{assetFile:r,result:n}of e)s+="<li><strong>".concat(r,"</strong>"),n.errors&&n.errors.length>0?s+=' <span class="error">('.concat(n.errors.length," error(s))</span>"):n.warnings&&n.warnings.length>0?s+=' <span class="warning">('.concat(n.warnings.length," warning(s))</span>"):s+=' <span class="success">\u2713</span>',s+="</li>";return s+="</ul>",s}getErrorNarrative(e,t){const s={en_US:'<h4>Error</h4><p class="error">An error occurred while executing the question: '.concat(t,"</p>"),fr_FR:"<h4>Erreur</h4><p class=\"error\">Une erreur s'est produite lors de l'ex\xe9cution de la question: ".concat(t,"</p>"),es_ES:'<h4>Error</h4><p class="error">Ocurri\xf3 un error al ejecutar la pregunta: '.concat(t,"</p>")};return s[e]||s.en_US}normalizeLocale(e){if(!e)return"en_US";const t=e.replace("-","_");if(["en_US","fr_FR","es_ES","ar_AR","zh_CN","ru_RU"].includes(t))return t;return{en:"en_US",fr:"fr_FR",es:"es_ES",ar:"ar_AR",zh:"zh_CN",ru:"ru_RU"}[t.split("_")[0]]||"en_US"}}}}]);