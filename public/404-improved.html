<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <title>SGEX Workbench</title>
    <script type="text/javascript">
      // SGEX Simplified Dynamic URL Routing
      // Focuses on reliable URL preservation and basic pattern matching
      // Reduces complexity while maintaining all functionality
      // Supports: /{component}(/{user}(/{repo}(/{branch}(/{asset}*))))?

      (function(l) {
        // Prevent infinite redirects
        if (l.search && l.search.indexOf('?/') === 0) {
          console.error('SGEX 404.html: Redirect loop detected');
          return;
        }

        // Check for recent redirect attempts to prevent loops
        var redirectKey = 'sgex-redirect-attempts';
        var currentPath = l.pathname;
        var now = Date.now();
        var attempts = JSON.parse(sessionStorage.getItem(redirectKey) || '[]');
        
        // Clean old attempts (>30 seconds)
        attempts = attempts.filter(function(a) { return now - a.time < 30000; });
        
        // Count recent attempts for this path
        var recentCount = attempts.filter(function(a) { return a.path === currentPath; }).length;
        
        if (recentCount >= 3) {
          console.error('SGEX 404.html: Too many redirects for path:', currentPath);
          // Fallback to main SGEX page
          l.replace(l.protocol + '//' + l.host + '/sgex/');
          return;
        }
        
        // Record this attempt
        attempts.push({ path: currentPath, time: now });
        sessionStorage.setItem(redirectKey, JSON.stringify(attempts));

        var pathSegments = l.pathname.split('/').filter(Boolean);
        
        // Determine deployment context
        var isGitHubPages = l.hostname.endsWith('.github.io');
        var basePath = '/sgex/';
        
        // Handle different deployment scenarios
        if (isGitHubPages) {
          handleGitHubPagesRouting(pathSegments, l, basePath);
        } else {
          handleLocalRouting(pathSegments, l, basePath);
        }

        function handleGitHubPagesRouting(segments, location, base) {
          // GitHub Pages: URLs must start with /sgex/
          if (segments.length === 0 || segments[0] !== 'sgex') {
            console.warn('SGEX: Invalid GitHub Pages URL pattern');
            redirectToSPA(base, '');
            return;
          }

          if (segments.length === 1) {
            // /sgex/ -> main app
            redirectToSPA(base, '');
            return;
          }

          // Check for branch deployment pattern: /sgex/{branch}/...
          if (segments.length >= 2) {
            var secondSegment = segments[1];
            
            // Handle documentation routes specially
            if (secondSegment === 'docs') {
              var docRoute = segments.slice(1).join('/');
              redirectToSPA(base, docRoute);
              return;
            }
            
            // Check if this could be a branch deployment
            if (segments.length === 2) {
              // /sgex/{branch}/ -> branch root
              var branchPath = '/sgex/' + secondSegment + '/';
              redirectToSPA(branchPath, '');
              return;
            }
            
            // For longer paths, determine if it's branch-first or component-first
            if (segments.length >= 3) {
              var thirdSegment = segments[2];
              
              // Branch docs: /sgex/{branch}/docs/...
              if (thirdSegment === 'docs') {
                var branchPath = '/sgex/' + secondSegment + '/';
                var docRoute = segments.slice(2).join('/');
                redirectToSPA(branchPath, docRoute);
                return;
              }
              
              // Try to determine if this is branch-first or component-first
              // Heuristic: if secondSegment looks like a branch name (contains dash, known pattern)
              // and thirdSegment looks like a component, treat as branch-first
              var looksLikeBranch = isLikelyBranchName(secondSegment);
              var looksLikeComponent = isLikelyComponentName(thirdSegment);
              
              if (looksLikeBranch && looksLikeComponent) {
                // Branch-first: /sgex/{branch}/{component}/...
                var branchPath = '/sgex/' + secondSegment + '/';
                var routePath = segments.slice(2).join('/');
                storeContextFromURL(segments);
                redirectToSPA(branchPath, routePath);
                return;
              }
              
              // Default to component-first: /sgex/{component}/{user}/{repo}/...
              if (segments.length >= 4) {
                var routePath = segments.slice(1).join('/');
                storeContextFromURL(segments);
                redirectToSPA(base, routePath);
                return;
              }
              
              // Fallback: treat as branch deployment
              var branchPath = '/sgex/' + secondSegment + '/';
              var routePath = segments.slice(2).join('/');
              storeContextFromURL(segments);
              redirectToSPA(branchPath, routePath);
              return;
            }
          }
          
          // Default fallback
          redirectToSPA(base, '');
        }

        function isLikelyBranchName(name) {
          // Branch names often contain dashes, version numbers, or known patterns
          return /^(main|master|develop|dev|feature-|fix-|hotfix-|release-|copilot-|deploy)/.test(name) ||
                 /^v?\d+\.\d+/.test(name); // version patterns like v1.0, 1.2.3
        }

        function isLikelyComponentName(name) {
          // Component names are typically kebab-case DAK component names
          var knownComponents = [
            'dashboard', 'testing-viewer', 'core-data-dictionary-viewer',
            'health-interventions', 'actor-editor', 'business-process-selection',
            'bpmn-editor', 'bpmn-viewer', 'bpmn-source', 'decision-support-logic',
            'questionnaire-editor', 'docs', 'pages', 'faq-demo',
            'dak-action', 'dak-selection', 'repositories'
          ];
          
          return knownComponents.includes(name) ||
                 (/^[a-z]+(-[a-z]+)*$/.test(name) && 
                  !name.includes('.') && 
                  !/^v?\d+/.test(name) &&
                  !name.startsWith('feature-') &&
                  !name.startsWith('fix-') &&
                  !name.startsWith('copilot-'));
        }

        function handleLocalRouting(segments, location, base) {
          // Local development: handle both /sgex/ prefixed and root URLs
          
          if (segments.length === 0) {
            redirectToSPA('/', '');
            return;
          }
          
          // If starts with sgex, treat as GitHub Pages pattern
          if (segments[0] === 'sgex') {
            handleGitHubPagesRouting(segments, location, base);
            return;
          }
          
          // Direct component access: /{component}/...
          var routePath = segments.join('/');
          storeContextFromURL(segments);
          redirectToSPA('/', routePath);
        }

        function storeContextFromURL(segments) {
          // Extract and store context for React app
          try {
            if (typeof Storage === 'undefined') return;
            
            // Detect pattern type and extract accordingly
            if (segments.length >= 4 && segments[0] === 'sgex') {
              var secondSegment = segments[1];
              var thirdSegment = segments[2];
              
              // Check if this is branch-first or component-first
              var looksLikeBranch = isLikelyBranchName(secondSegment);
              var looksLikeComponent = isLikelyComponentName(thirdSegment);
              
              if (looksLikeBranch && looksLikeComponent) {
                // Branch-first: /sgex/{branch}/{component}/{user}/{repo}/...
                if (segments.length >= 5) {
                  var user = segments[3];
                  var repo = segments[4];
                  sessionStorage.setItem('sgex_selected_user', user);
                  sessionStorage.setItem('sgex_selected_repo', repo);
                  sessionStorage.setItem('sgex_deployment_branch', secondSegment);
                  
                  if (segments.length > 5) {
                    sessionStorage.setItem('sgex_selected_branch', segments[5]);
                  }
                  
                  if (segments.length > 6) {
                    sessionStorage.setItem('sgex_selected_asset', segments.slice(6).join('/'));
                  }
                }
              } else {
                // Component-first: /sgex/{component}/{user}/{repo}/...
                var user = segments[2];
                var repo = segments[3];
                sessionStorage.setItem('sgex_selected_user', user);
                sessionStorage.setItem('sgex_selected_repo', repo);
                
                if (segments.length > 4) {
                  sessionStorage.setItem('sgex_selected_branch', segments[4]);
                }
                
                if (segments.length > 5) {
                  sessionStorage.setItem('sgex_selected_asset', segments.slice(5).join('/'));
                }
              }
            }
            
            // For direct patterns without sgex prefix
            else if (segments.length >= 3) {
              var user = segments[1];
              var repo = segments[2];
              if (user && repo && /^[a-zA-Z0-9._-]+$/.test(user) && /^[a-zA-Z0-9._-]+$/.test(repo)) {
                sessionStorage.setItem('sgex_selected_user', user);
                sessionStorage.setItem('sgex_selected_repo', repo);
                
                if (segments.length > 3) {
                  sessionStorage.setItem('sgex_selected_branch', segments[3]);
                }
                
                if (segments.length > 4) {
                  sessionStorage.setItem('sgex_selected_asset', segments.slice(4).join('/'));
                }
              }
            }
          } catch (error) {
            console.warn('Could not store URL context:', error);
          }
        }

        function redirectToSPA(basePath, routePath) {
          var newUrl = l.protocol + '//' + l.host + basePath;
          
          // Add route path as query parameter
          if (routePath) {
            newUrl += '?/' + encodeURIComponent(routePath);
          }
          
          // Preserve existing query parameters (except the routing one)
          if (l.search && !l.search.startsWith('?/')) {
            var searchParams = l.search.startsWith('?') ? l.search.substring(1) : l.search;
            if (routePath) {
              newUrl += '&' + searchParams;
            } else {
              newUrl += '?' + searchParams;
            }
          }
          
          // Preserve hash fragments
          if (l.hash) {
            newUrl += l.hash;
          }
          
          console.log('SGEX Routing:', {
            from: l.pathname + l.search + l.hash,
            to: newUrl,
            basePath: basePath,
            routePath: routePath
          });
          
          l.replace(newUrl);
        }

      })(window.location);
    </script>
  </head>
  <body>
    <!-- SGEX Simplified Routing Handler -->
    <!-- Preserves URL fragments, query parameters, and context -->
    <!-- Supports all deployment scenarios with minimal complexity -->
  </body>
</html>