{"version":3,"file":"static/js/483.49c76d4e.chunk.js","mappings":"2GAYA,SAAgBA,EAAeC,EAAyBC,GACtD,OAAOA,EAAMC,MAAMC,KAAMC,GAASC,EAAcL,EAAQI,GAC1D,CAEA,SAAgBC,EAAcL,EAAyBI,G,MACrD,YAC2BE,IAAzBN,EAAOI,EAAKG,WACc,QAA1BC,EAAAJ,EAAKK,WAAWC,kBAAU,IAAAF,OAAA,EAAAA,EAAEL,KAAMQ,QAAwBL,IAAhBN,EAAOW,IAErD,C,iHAjBAC,EAAAA,sBAAA,SAAqCC,EAEnCC,GAAc,IADd,OAACd,EAAM,KAAEe,GAAmBF,EAG5B,MAAMZ,EAAQc,EAAKC,MAAMC,MAAMH,GAC/B,OAAOb,IAAmB,IAAVA,GAAkBF,EAAeC,EAAQC,EAC3D,EAEAW,EAAAA,eAAAb,EAIAa,EAAAA,cAAAP,C,UCVAa,EAAON,QAAU,SAASO,EAAMC,EAAGC,GACjC,GAAID,IAAMC,EAAG,OAAO,EAEpB,GAAID,GAAKC,GAAiB,iBAALD,GAA6B,iBAALC,EAAe,CAC1D,GAAID,EAAEE,cAAgBD,EAAEC,YAAa,OAAO,EAE5C,IAAIC,EAAQC,EAAGC,EACf,GAAIC,MAAMC,QAAQP,GAAI,CAEpB,IADAG,EAASH,EAAEG,SACGF,EAAEE,OAAQ,OAAO,EAC/B,IAAKC,EAAID,EAAgB,IAARC,KACf,IAAKL,EAAMC,EAAEI,GAAIH,EAAEG,IAAK,OAAO,EACjC,OAAO,CACT,CAIA,GAAIJ,EAAEE,cAAgBM,OAAQ,OAAOR,EAAES,SAAWR,EAAEQ,QAAUT,EAAEU,QAAUT,EAAES,MAC5E,GAAIV,EAAEW,UAAYC,OAAOC,UAAUF,QAAS,OAAOX,EAAEW,YAAcV,EAAEU,UACrE,GAAIX,EAAEc,WAAaF,OAAOC,UAAUC,SAAU,OAAOd,EAAEc,aAAeb,EAAEa,WAIxE,IADAX,GADAE,EAAOO,OAAOP,KAAKL,IACLG,UACCS,OAAOP,KAAKJ,GAAGE,OAAQ,OAAO,EAE7C,IAAKC,EAAID,EAAgB,IAARC,KACf,IAAKQ,OAAOC,UAAUE,eAAeC,KAAKf,EAAGI,EAAKD,IAAK,OAAO,EAEhE,IAAKA,EAAID,EAAgB,IAARC,KAAY,CAC3B,IAAIa,EAAMZ,EAAKD,GAEf,IAAKL,EAAMC,EAAEiB,GAAMhB,EAAEgB,IAAO,OAAO,CACrC,CAEA,OAAO,CACT,CAGA,OAAOjB,IAAIA,GAAKC,IAAIA,CACtB,C,yFC5CA,MAAAiB,EAAAC,EAAA,OACAC,EAAAD,EAAA,OAaA,SAASE,EAAcC,EAAkBC,EAAuBC,GAC9D,MAAM,IAACC,EAAG,cAAEC,EAAa,KAAEC,EAAI,KAAEC,GAAQN,EACzC,QAAqBpC,IAAjBsC,EAA4B,OAChC,MAAMK,EAAYX,EAAAY,CAAC,GAAGH,KAAO,EAAAT,EAAAa,aAAYR,KACzC,GAAIG,EAEF,YADA,EAAAN,EAAAY,iBAAgBV,EAAI,2BAA2BO,KAIjD,IAAII,EAAYf,EAAAY,CAAC,GAAGD,kBACK,UAArBD,EAAKM,cACPD,EAAYf,EAAAY,CAAC,GAAGG,QAAgBJ,iBAAyBA,YAI3DJ,EAAIU,GAAGF,EAAWf,EAAAY,CAAC,GAAGD,QAAe,EAAAX,EAAAkB,WAAUZ,KACjD,CA3BAhC,EAAAA,eAAA,SAA+B8B,EAAkBe,GAC/C,MAAM,WAACC,EAAU,MAAEC,GAASjB,EAAG1C,OAC/B,GAAW,WAAPyD,GAAmBC,EACrB,IAAK,MAAMrB,KAAOqB,EAChBjB,EAAcC,EAAIL,EAAKqB,EAAWrB,GAAKuB,aAEzB,UAAPH,GAAkB/B,MAAMC,QAAQgC,IACzCA,EAAME,QAAQ,CAACC,EAAKtC,IAAciB,EAAcC,EAAIlB,EAAGsC,EAAIF,SAE/D,C,yFCXA,MAAAtB,EAAAC,EAAA,OACAC,EAAAD,EAAA,OACAwB,EAAAxB,EAAA,OAEMyB,EAA6B,CACjCzD,QAAS,QACTO,KAAM,QACNmD,WAAY,CAAC,SAAU,QAAS,WAChCC,OAAQ,cACRC,IAAAA,CAAKC,GACH,MAAM,OAACpE,EAAM,GAAE0C,GAAM0B,EACrB,GAAI1C,MAAMC,QAAQ3B,GAAS,OAAOqE,EAAcD,EAAK,kBAAmBpE,GACxE0C,EAAGiB,OAAQ,GACP,EAAAnB,EAAA8B,mBAAkB5B,EAAI1C,IAC1BoE,EAAIG,IAAG,EAAAR,EAAAS,eAAcJ,GACvB,GAGF,SAAgBC,EACdD,EACAK,GACgC,IAAhCC,EAAAC,UAAApD,OAAA,QAAAjB,IAAAqE,UAAA,GAAAA,UAAA,GAAsBP,EAAIpE,OAE1B,MAAM,IAAC6C,EAAG,aAAE+B,EAAY,KAAE7B,EAAI,QAAExC,EAAO,GAAEmC,GAAM0B,GAsB/C,SAA0BN,GACxB,MAAM,KAACd,EAAI,cAAE6B,GAAiBnC,EACxBoC,EAAIJ,EAAOnD,OACXwD,EAAYD,IAAMhB,EAAIkB,WAAaF,IAAMhB,EAAImB,WAAgC,IAApBnB,EAAIW,IACnE,GAAIzB,EAAKkC,eAAiBH,EAAW,CACnC,MAAMI,EAAM,IAAI5E,SAAeuE,qCAAqCL,6CAAsDI,MAC1H,EAAArC,EAAAY,iBAAgBV,EAAIyC,EAAKnC,EAAKkC,aAChC,CACF,CA7BAE,CAAiBR,GACblC,EAAGM,KAAKqC,aAAeX,EAAOnD,SAAuB,IAAbmB,EAAGiB,QAC7CjB,EAAGiB,MAAQnB,EAAA8C,eAAe3B,MAAMd,EAAK6B,EAAOnD,OAAQmB,EAAGiB,QAEzD,MAAM4B,EAAQ1C,EAAI2C,KAAK,SACjBC,EAAM5C,EAAI6C,MAAM,MAAOpD,EAAAY,CAAC,GAAGH,YACjC2B,EAAOb,QAAQ,CAACC,EAAgBtC,MAC1B,EAAAgB,EAAA8B,mBAAkB5B,EAAIoB,KAC1BjB,EAAIU,GAAGjB,EAAAY,CAAC,GAAGuC,OAASjE,IAAK,IACvB4C,EAAIuB,UACF,CACEpF,UACAqF,WAAYpE,EACZqE,SAAUrE,GAEZ+D,IAGJnB,EAAIG,GAAGgB,KAYX,CApCA3E,EAAAA,cAAAyD,EAsCAzD,EAAAA,QAAeoD,C,iBCxDf,MAAM,IAAE8B,GAAQvD,EAAQ,OAElBwD,EAAW,2FAEjB,SAASC,EAAeC,GACtB,GAAIC,EAAUD,EAAM,KAAO,EAAK,MAAO,CAAEA,OAAME,QAAQ,GACvD,MAAMC,EAAUH,EAAKI,MAAMN,IAAa,IACjCO,GAAWF,EAClB,OAAIE,EACK,CAAEL,KAAMM,EAAkBD,EAAS,KAAMH,QAAQ,GAEjD,CAAEF,OAAME,QAAQ,EAE3B,CAOA,SAASK,EAA0BC,GAAyB,IAAlBC,EAAQ/B,UAAApD,OAAA,QAAAjB,IAAAqE,UAAA,IAAAA,UAAA,GAC5CgC,EAAM,GACNC,GAAQ,EACZ,IAAK,MAAMC,KAAKJ,EAAO,CACrB,QAAenG,IAAXwF,EAAIe,GAAkB,OAChB,MAANA,IAAuB,IAAVD,IAAgBA,GAAQ,GACpCA,IAAOD,GAAOE,EACrB,CAEA,OADIH,GAA2B,IAAfC,EAAIpF,SAAcoF,EAAM,KACjCA,CACT,CAoEA,SAASG,EAAeb,GACtB,GAAIC,EAAUD,EAAM,KAAO,EAAK,MAAO,CAAEA,OAAMc,QAAQ,GACvD,MAAMC,EApER,SAAkBP,GAChB,IAAIQ,EAAa,EACjB,MAAMC,EAAS,CAAEC,OAAO,EAAOb,QAAS,GAAIc,KAAM,IAC5Cd,EAAU,GACVe,EAAS,GACf,IAAIC,GAAS,EACTC,GAAqB,EACrBC,GAAU,EAEd,SAASC,IACP,GAAIJ,EAAO9F,OAAQ,CACjB,IAAe,IAAX+F,EAAkB,CACpB,MAAMI,EAAMlB,EAAyBa,GACrC,QAAY/G,IAARoH,EAIF,OADAR,EAAOC,OAAQ,GACR,EAHPb,EAAQqB,KAAKD,EAKjB,CACAL,EAAO9F,OAAS,CAClB,CACA,OAAO,CACT,CAEA,IAAK,IAAIC,EAAI,EAAGA,EAAIiF,EAAMlF,OAAQC,IAAK,CACrC,MAAMoG,EAASnB,EAAMjF,GACrB,GAAe,MAAXoG,GAA6B,MAAXA,EACtB,GAAe,MAAXA,EAgBG,GAAe,MAAXA,EAAJ,CACL,IAAKH,IAAa,MAElBH,GAAS,CAIX,MAFED,EAAOM,KAAKC,OArBd,CAIE,IAH2B,IAAvBL,IACFC,GAAU,IAEPC,IAAa,MAGlB,GAFAR,IACAX,EAAQqB,KAAK,KACTV,EAAa,EAAG,CAElBC,EAAOC,OAAQ,EACf,KACF,CACI3F,EAAI,GAAK,GAAsB,MAAjBiF,EAAMjF,EAAI,KAC1B+F,GAAqB,EAUzB,CACF,CAWA,OAVIF,EAAO9F,SACL+F,EACFJ,EAAOE,KAAOC,EAAOQ,KAAK,IACjBL,EACTlB,EAAQqB,KAAKN,EAAOQ,KAAK,KAEzBvB,EAAQqB,KAAKnB,EAAyBa,KAG1CH,EAAOZ,QAAUA,EAAQuB,KAAK,IACvBX,CACT,CAIeY,CAAQ7B,GAErB,GAAKe,EAAKG,MASR,MAAO,CAAElB,OAAMc,QAAQ,GATR,CACf,IAAIgB,EAAUf,EAAKV,QACf0B,EAAchB,EAAKV,QAKvB,OAJIU,EAAKI,OACPW,GAAW,IAAMf,EAAKI,KACtBY,GAAe,MAAQhB,EAAKI,MAEvB,CAAEnB,KAAM8B,EAASC,cAAajB,QAAQ,EAC/C,CAGF,CAEA,SAASR,EAAmB0B,EAAKC,GAC/B,IAAIC,EAAM,GACNC,GAAO,EACX,MAAMtD,EAAImD,EAAI1G,OACd,IAAK,IAAIC,EAAI,EAAGA,EAAIsD,EAAGtD,IAAK,CAC1B,MAAMqF,EAAIoB,EAAIzG,GACJ,MAANqF,GAAauB,GACV5G,EAAI,GAAKsD,GAAKmD,EAAIzG,EAAI,KAAO0G,GAAU1G,EAAI,IAAMsD,KACpDqD,GAAOtB,EACPuB,GAAO,IAIPA,EADEvB,IAAMqB,EAKVC,GAAOtB,EAEX,CACA,OAAOsB,CACT,CAEA,SAASjC,EAAW+B,EAAKC,GACvB,IAAIG,EAAM,EACV,IAAK,IAAI7G,EAAI,EAAGA,EAAIyG,EAAI1G,OAAQC,IAC1ByG,EAAIzG,KAAO0G,GAAOG,IAExB,OAAOA,CACT,CAEA,MAAMC,EAAO,YACPC,EAAO,iBACPC,EAAO,mBACPC,EAAO,0BAqFbvH,EAAON,QAAU,CACf8H,mBAlCF,SAA6BC,GAC3B,MAAMC,EAAY,GAOlB,QAL4BtI,IAAxBqI,EAAWE,WACbD,EAAUjB,KAAKgB,EAAWE,UAC1BD,EAAUjB,KAAK,WAGOrH,IAApBqI,EAAW1C,KAAoB,CACjC,IAAIA,EAAO6C,SAASH,EAAW1C,MAC/B,MAAM8C,EAAU/C,EAAcC,GAE9B,GAAI8C,EAAQ5C,OACVF,EAAO8C,EAAQ9C,SACV,CACL,MAAM+C,EAAUlC,EAAciC,EAAQ9C,MAEpCA,GADqB,IAAnB+C,EAAQjC,OACH,IAAIiC,EAAQhB,eAEZW,EAAW1C,IAEtB,CACA2C,EAAUjB,KAAK1B,EACjB,CAOA,MAL+B,kBAApB0C,EAAWM,MAAgD,kBAApBN,EAAWM,OAC3DL,EAAUjB,KAAK,KACfiB,EAAUjB,KAAKuB,OAAOP,EAAWM,QAG5BL,EAAUrH,OAASqH,EAAUf,KAAK,SAAMvH,CACjD,EAIE6I,2BA1DF,SAAqCR,EAAYS,GAC/C,MAAMC,GAAe,IAARD,EAAeE,OAASR,SAmBrC,YAlB0BxI,IAAtBqI,EAAWY,SACbZ,EAAWY,OAASF,EAAKV,EAAWY,cAEVjJ,IAAxBqI,EAAWE,WACbF,EAAWE,SAAWQ,EAAKV,EAAWE,gBAEhBvI,IAApBqI,EAAW1C,OACb0C,EAAW1C,KAAOoD,EAAKV,EAAW1C,YAEZ3F,IAApBqI,EAAWa,OACbb,EAAWa,KAAOH,EAAKV,EAAWa,YAEXlJ,IAArBqI,EAAWc,QACbd,EAAWc,MAAQJ,EAAKV,EAAWc,aAETnJ,IAAxBqI,EAAWe,WACbf,EAAWe,SAAWL,EAAKV,EAAWe,WAEjCf,CACT,EAsCEgB,kBAtFF,SAA4BlD,GAC1B,MAAMS,EAAS,GAEf,KAAOT,EAAMlF,QACX,GAAIkF,EAAMJ,MAAMiC,GACd7B,EAAQA,EAAMmD,QAAQtB,EAAM,SACvB,GAAI7B,EAAMJ,MAAMkC,GACrB9B,EAAQA,EAAMmD,QAAQrB,EAAM,UACvB,GAAI9B,EAAMJ,MAAMmC,GACrB/B,EAAQA,EAAMmD,QAAQpB,EAAM,KAC5BtB,EAAO2C,WACF,GAAc,MAAVpD,GAA2B,OAAVA,EAC1BA,EAAQ,OACH,CACL,MAAMqD,EAAKrD,EAAMJ,MAAMoC,GACvB,IAAIqB,EAKF,MAAM,IAAIC,MAAM,oCALV,CACN,MAAMC,EAAIF,EAAG,GACbrD,EAAQA,EAAMwD,MAAMD,EAAEzI,QACtB2F,EAAOS,KAAKqC,EACd,CAGF,CAEF,OAAO9C,EAAOW,KAAK,GACrB,EA8DE7B,gBACAc,gBACAN,2B,oIChPF,MAAAlE,EAAAC,EAAA,OACAC,EAAAD,EAAA,OA6CA3B,EAAAA,aAAA,SACE8B,EAAgB7B,GACqE,IAArF,QAACN,EAAO,WAAEqF,EAAU,OAAE5F,EAAM,WAAEkK,EAAU,cAAErF,EAAa,aAAEsF,GAA4BtJ,EAErF,QAAgBP,IAAZC,QAAoCD,IAAXN,EAC3B,MAAM,IAAI+J,MAAM,wDAGlB,QAAgBzJ,IAAZC,EAAuB,CACzB,MAAMuD,EAAMpB,EAAG1C,OAAOO,GACtB,YAAsBD,IAAfsF,EACH,CACE5F,OAAQ8D,EACRoG,WAAY5H,EAAAY,CAAC,GAAGR,EAAGwH,cAAa,EAAA5H,EAAAa,aAAY5C,KAC5CsE,cAAe,GAAGnC,EAAGmC,iBAAiBtE,KAExC,CACEP,OAAQ8D,EAAI8B,GACZsE,WAAY5H,EAAAY,CAAC,GAAGR,EAAGwH,cAAa,EAAA5H,EAAAa,aAAY5C,MAAW,EAAA+B,EAAAa,aAAYyC,KACnEf,cAAe,GAAGnC,EAAGmC,iBAAiBtE,MAAW,EAAAiC,EAAA4H,gBAAexE,KAExE,CAEA,QAAetF,IAAXN,EAAsB,CACxB,QAAmBM,IAAf4J,QAA8C5J,IAAlBuE,QAAgDvE,IAAjB6J,EAC7D,MAAM,IAAIJ,MAAM,+EAElB,MAAO,CACL/J,SACAkK,aACAC,eACAtF,gBAEJ,CAEA,MAAM,IAAIkF,MAAM,8CAClB,EAEAnJ,EAAAA,oBAAA,SACE+E,EACAjD,EAAgB2H,GAC8D,IAA9E,SAACxE,EAAUyE,aAAcC,EAAM,KAAExH,EAAI,UAAEyH,EAAS,aAAEC,GAA4BJ,EAE9E,QAAa/J,IAATyC,QAAmCzC,IAAbuF,EACxB,MAAM,IAAIkE,MAAM,uDAGlB,MAAM,IAAClH,GAAOH,EAEd,QAAiBpC,IAAbuF,EAAwB,CAC1B,MAAM,UAAC6E,EAAS,YAAEC,EAAW,KAAE3H,GAAQN,EAEvCkI,EADiB/H,EAAIgI,IAAI,OAAQvI,EAAAY,CAAC,GAAGR,EAAGK,QAAO,EAAAT,EAAAa,aAAY0C,MAAa,IAExEF,EAAU+E,UAAYpI,EAAA2F,GAAG,GAAGyC,KAAY,EAAAlI,EAAAsI,cAAajF,EAAU0E,EAAQvH,EAAK+H,oBAC5EpF,EAAUqF,mBAAqB1I,EAAAY,CAAC,GAAG2C,IACnCF,EAAUgF,YAAc,IAAIA,EAAahF,EAAUqF,mBACrD,CAEA,QAAa1K,IAATyC,EAAoB,CAEtB6H,EADiB7H,aAAgBT,EAAA2I,KAAOlI,EAAOF,EAAIgI,IAAI,OAAQ9H,GAAM,SAEhDzC,IAAjBmK,IAA4B9E,EAAU8E,aAAeA,EAE3D,CAIA,SAASG,EAAiBM,GACxBvF,EAAU5C,KAAOmI,EACjBvF,EAAUwF,UAAYzI,EAAGyI,UAAY,EACrCxF,EAAU6E,UAAY,GACtB9H,EAAG0I,kBAAoB,IAAIC,IAC3B1F,EAAU2F,WAAa5I,EAAGK,KAC1B4C,EAAU4F,UAAY,IAAI7I,EAAG6I,UAAWL,EAC1C,CATIV,IAAW7E,EAAU6E,UAAYA,EAUvC,EAEA5J,EAAAA,oBAAA,SACE+E,EAA2B6F,GAC2D,IAAtF,iBAACC,EAAgB,YAAEC,EAAW,cAAE5I,EAAa,aAAE6I,EAAY,UAAEC,GAAyBJ,OAEhElL,IAAlBwC,IAA6B6C,EAAU7C,cAAgBA,QACtCxC,IAAjBqL,IAA4BhG,EAAUgG,aAAeA,QACvCrL,IAAdsL,IAAyBjG,EAAUiG,UAAYA,GACnDjG,EAAU8F,iBAAmBA,EAC7B9F,EAAU+F,YAAcA,CAC1B,C,kECpIA,MAAApJ,EAAAC,EAAA,OAEMsJ,EAAMvJ,EAAAwJ,UAMNC,EAAgE,CACpEC,QAAS,CAACC,MAAO,KAAM1H,GAAIsH,EAAIK,IAAKC,KAAMN,EAAIO,IAC9CC,QAAS,CAACJ,MAAO,KAAM1H,GAAIsH,EAAIS,IAAKH,KAAMN,EAAIU,IAC9CC,iBAAkB,CAACP,MAAO,IAAK1H,GAAIsH,EAAIU,GAAIJ,KAAMN,EAAIS,KACrDG,iBAAkB,CAACR,MAAO,IAAK1H,GAAIsH,EAAIO,GAAID,KAAMN,EAAIK,MASjD/E,EAAgC,CACpCuF,QAAS7L,IAAA,IAAC,QAACN,EAAO,WAAEoM,GAAW9L,EAAA,OAAKyB,EAAA2F,GAAG,WAAW8D,EAAKxL,GAAgB0L,SAASU,KAChFC,OAAQvC,IAAA,IAAC,QAAC9J,EAAO,WAAEoM,GAAWtC,EAAA,OAC5B/H,EAAAY,CAAC,gBAAgB6I,EAAKxL,GAAgB0L,iBAAiBU,OAGrD3I,EAA6B,CACjCzD,QAASyB,OAAOP,KAAKsK,GACrBjL,KAAM,SACNmD,WAAY,SACZ4I,OAAO,EACP1F,QACAhD,IAAAA,CAAKC,GACH,MAAM,QAAC7D,EAAO,KAAEwC,EAAI,WAAE4J,GAAcvI,EACpCA,EAAI0I,UAAUxK,EAAAY,CAAC,GAAGH,KAAQgJ,EAAKxL,GAAgB4L,QAAQQ,cAAuB5J,KAChF,GAGFnC,EAAAA,QAAeoD,C,iGCvCf,MAAA+I,EAAAxK,EAAA,OACAwB,EAAAxB,EAAA,OACAD,EAAAC,EAAA,OACAyK,EAAAzK,EAAA,OACA0K,EAAA1K,EAAA,OACAC,EAAAD,EAAA,OAEMyB,EAA6B,CACjCzD,QAAS,OACT0D,WAAY,SACZE,IAAAA,CAAKC,GACH,MAAM,IAACvB,EAAK7C,OAAQkN,EAAI,GAAExK,GAAM0B,GAC1B,OAAC+I,EAAQC,UAAWC,EAAG,aAAEC,EAAY,KAAEtK,EAAI,KAAEjC,GAAQ2B,GACrD,KAAC6K,GAAQF,EACf,IAAc,MAATH,GAAyB,OAATA,IAAkBC,IAAWI,EAAKJ,OAAQ,OAM/D,WACE,GAAIE,IAAQE,EAAM,OAAOC,EAAQpJ,EAAKkJ,EAAcD,EAAKA,EAAII,QAC7D,MAAMC,EAAW7K,EAAI8K,WAAW,OAAQ,CAACC,IAAKL,IAC9C,OAAOC,EAAQpJ,EAAK9B,EAAAY,CAAC,GAAGwK,aAAqBH,EAAMA,EAAKE,OAC1D,CAVsEI,GACtE,MAAMC,EAAWb,EAAAc,WAAW3L,KAAKrB,EAAMwM,EAAMJ,EAAQD,GACrD,QAAiB5M,IAAbwN,EAAwB,MAAM,IAAIf,EAAAnJ,QAAgBlB,EAAGM,KAAKgL,YAAab,EAAQD,GACnF,OAAIY,aAAoBb,EAAAgB,UASxB,SAAsBnK,GACpB,MAAMoK,EAAIC,EAAY/J,EAAKN,GAC3B0J,EAAQpJ,EAAK8J,EAAGpK,EAAKA,EAAI2J,OAC3B,CAZ0CW,CAAaN,GAcvD,SAAyBhK,GACvB,MAAMuK,EAAUxL,EAAI8K,WAClB,UACqB,IAArB3K,EAAKmB,KAAKtC,OAAkB,CAAC+L,IAAK9J,EAAKK,MAAM,EAAA7B,EAAAkB,WAAUM,IAAQ,CAAC8J,IAAK9J,IAEjEyB,EAAQ1C,EAAI2C,KAAK,SACjB8I,EAASlK,EAAIuB,UACjB,CACE3F,OAAQ8D,EACR0G,UAAW,GACXN,WAAY5H,EAAAiM,IACZpE,aAAckE,EACdxJ,cAAeqI,GAEjB3H,GAEFnB,EAAIkB,eAAegJ,GACnBlK,EAAIG,GAAGgB,EACT,CA/BOiJ,CAAgBV,EAgCzB,GAGF,SAAgBK,EAAY/J,EAAiBN,GAC3C,MAAM,IAACjB,GAAOuB,EACd,OAAON,EAAI2K,SACP5L,EAAI8K,WAAW,WAAY,CAACC,IAAK9J,EAAI2K,WACrCnM,EAAAY,CAAC,GAAGL,EAAI8K,WAAW,UAAW,CAACC,IAAK9J,cAC1C,CAEA,SAAgB0J,EAAQpJ,EAAiB8J,EAASpK,EAAiB2J,GACjE,MAAM,IAAC5K,EAAG,GAAEH,GAAM0B,GACZ,UAACwH,EAAWwB,UAAWC,EAAG,KAAErK,GAAQN,EACpCgM,EAAU1L,EAAK2L,YAAc3B,EAAApJ,QAAEgL,KAAOtM,EAAAiM,IA8B5C,SAASM,EAAchN,GACrB,MAAMiN,EAAOxM,EAAAY,CAAC,GAAGrB,WACjBgB,EAAIkM,OAAO/B,EAAApJ,QAAEoL,QAAS1M,EAAAY,CAAC,GAAG8J,EAAApJ,QAAEoL,sBAAsBF,OAAU9B,EAAApJ,QAAEoL,kBAAkBF,MAChFjM,EAAIkM,OAAO/B,EAAApJ,QAAEqL,OAAQ3M,EAAAY,CAAC,GAAG8J,EAAApJ,QAAEoL,iBAC7B,CAEA,SAASE,EAAiBrN,G,MACxB,IAAKa,EAAGM,KAAKqC,YAAa,OAC1B,MAAM8J,EAA4B,QAAb3O,EAAG,OAAHsD,QAAG,IAAHA,OAAG,EAAHA,EAAK2K,gBAAQ,IAAAjO,OAAA,EAAAA,EAAE4O,UAEpC,IAAiB,IAAb1M,EAAG2M,MACL,GAAIF,IAAiBA,EAAaG,kBACLhP,IAAvB6O,EAAaE,QACf3M,EAAG2M,MAAQ7M,EAAA8C,eAAe+J,MAAMxM,EAAKsM,EAAaE,MAAO3M,EAAG2M,YAEzD,CACL,MAAMA,EAAQxM,EAAI0M,IAAI,QAASjN,EAAAY,CAAC,GAAGrB,qBACnCa,EAAG2M,MAAQ7M,EAAA8C,eAAe+J,MAAMxM,EAAKwM,EAAO3M,EAAG2M,MAAO/M,EAAA2I,KACxD,CAEF,IAAiB,IAAbvI,EAAGiB,MACL,GAAIwL,IAAiBA,EAAaK,kBACLlP,IAAvB6O,EAAaxL,QACfjB,EAAGiB,MAAQnB,EAAA8C,eAAe3B,MAAMd,EAAKsM,EAAaxL,MAAOjB,EAAGiB,YAEzD,CACL,MAAMA,EAAQd,EAAI0M,IAAI,QAASjN,EAAAY,CAAC,GAAGrB,qBACnCa,EAAGiB,MAAQnB,EAAA8C,eAAe3B,MAAMd,EAAKc,EAAOjB,EAAGiB,MAAOrB,EAAA2I,KACxD,CAEJ,CA3DIwC,EAGJ,WACE,IAAKJ,EAAII,OAAQ,MAAM,IAAI1D,MAAM,0CACjC,MAAMxE,EAAQ1C,EAAIgI,IAAI,SACtBhI,EAAI4M,IACF,KACE5M,EAAIsB,KAAK7B,EAAAY,CAAC,UAAS,EAAAa,EAAA2L,kBAAiBtL,EAAK8J,EAAGQ,MAC5CQ,EAAiBhB,GACZtC,GAAW/I,EAAIkM,OAAOxJ,GAAO,IAEnCoK,IACC9M,EAAIU,GAAGjB,EAAAY,CAAC,KAAKyM,gBAAgBjN,EAAGkN,mBAA4B,IAAM/M,EAAIgN,MAAMF,IAC5Ed,EAAcc,GACT/D,GAAW/I,EAAIkM,OAAOxJ,GAAO,KAGtCnB,EAAIG,GAAGgB,EACT,CAnBYuK,GAsBV1L,EAAI2L,QACF,EAAAhM,EAAA2L,kBAAiBtL,EAAK8J,EAAGQ,GACzB,IAAMQ,EAAiBhB,GACvB,IAAMW,EAAcX,GAmC1B,CAvEAtN,EAAAA,YAAAuN,EAOAvN,EAAAA,QAAA4M,EAkEA5M,EAAAA,QAAeoD,C,kEC/Hf,MAAAgM,EAAAzN,EAAA,OACA0N,EAAA1N,EAAA,MAEM2N,EAAmB,CACvB,UACA,MACA,QACA,cACA,CAAC3P,QAAS,YACV,cACAyP,EAAApM,QACAqM,EAAArM,SAGFhD,EAAAA,QAAesP,C,eCbf,IAAYC,E,qEAAZ,SAAYA,GACVA,EAAA,UACAA,EAAA,iBACD,CAHD,CAAYA,IAAUvP,EAAAA,WAAVuP,EAAU,I,mECOtB,MAAA7N,EAAAC,EAAA,OAkBMyB,EAA6B,CACjCzD,QAAS,SACTO,KAAM,CAAC,SAAU,UACjBmD,WAAY,SACZ4I,OAAO,EACP1F,MAVoC,CACpCuF,QAAS7L,IAAA,IAAC,WAAC8L,GAAW9L,EAAA,OAAKyB,EAAA2F,GAAG,sBAAsB0E,MACpDC,OAAQvC,IAAA,IAAC,WAACsC,GAAWtC,EAAA,OAAK/H,EAAAY,CAAC,YAAYyJ,OASvCxI,IAAAA,CAAKC,EAAiBgM,GACpB,MAAM,IAACvN,EAAG,KAAEE,EAAI,MAAE8J,EAAK,OAAE7M,EAAM,WAAE2M,EAAU,GAAEjK,GAAM0B,GAC7C,KAACpB,EAAI,cAAE6B,EAAa,UAAEuI,EAAS,KAAErM,GAAQ2B,EAC1CM,EAAKqN,kBAENxD,EAGJ,WACE,MAAMyD,EAAOzN,EAAI8K,WAAW,UAAW,CACrCC,IAAK7M,EAAKwP,QACVpM,KAAMnB,EAAKmB,KAAKoM,UAEZC,EAAO3N,EAAI6C,MAAM,OAAQpD,EAAAY,CAAC,GAAGoN,KAAQ3D,MACrC8D,EAAQ5N,EAAIgI,IAAI,SAChB6F,EAAS7N,EAAIgI,IAAI,UAEvBhI,EAAIU,GACFjB,EAAAY,CAAC,UAAUsN,sBAAyBA,uBACpC,IAAM3N,EAAIkM,OAAO0B,EAAOnO,EAAAY,CAAC,GAAGsN,sBAAyBzB,OAAO2B,EAAQpO,EAAAY,CAAC,GAAGsN,cACxE,IAAM3N,EAAIkM,OAAO0B,EAAOnO,EAAAY,CAAC,YAAY6L,OAAO2B,EAAQF,IAEtDpM,EAAI0I,WAAU,EAAAxK,EAAAqO,KAGc,IAAtB3N,EAAK4N,aAA+BtO,EAAAiM,IACjCjM,EAAAY,CAAC,GAAGyJ,SAAkB+D,IAG/B,WACE,MAAMG,EAAazD,EAAUK,OACzBnL,EAAAY,CAAC,IAAIsN,mBAAsBE,KAAU3N,QAAW2N,KAAU3N,MAC1DT,EAAAY,CAAC,GAAGwN,KAAU3N,KACZ+N,EAAYxO,EAAAY,CAAC,WAAWwN,qBAA0BG,OAAgBH,UAAe3N,MACvF,OAAOT,EAAAY,CAAC,GAAGwN,QAAaA,iBAAsBD,SAAaL,SAAgBU,GAC7E,CAb+BC,IAcjC,CA/BWC,GAiCX,WACE,MAAMC,EAAqClQ,EAAKwP,QAAQvQ,GACxD,IAAKiR,EAEH,YAMF,WACE,IAA0B,IAAtBjO,EAAK4N,aAEP,YADA7P,EAAKmQ,OAAOC,KAAKC,KAGnB,MAAM,IAAIrH,MAAMqH,KAEhB,SAASA,IACP,MAAO,mBAAmBpR,iCAAgD6E,IAC5E,CACF,CAjBEwM,GAGF,IAAkB,IAAdJ,EAAoB,OACxB,MAAOK,EAASZ,EAAQa,GAexB,SAAmBC,GACjB,MAAMrN,EACJqN,aAAkB5P,QACd,EAAAU,EAAAmP,YAAWD,GACXxO,EAAKmB,KAAKoM,QACVjO,EAAAY,CAAC,GAAGF,EAAKmB,KAAKoM,WAAU,EAAAjO,EAAAa,aAAYnD,UACpCM,EACAoR,EAAM7O,EAAI8K,WAAW,UAAW,CAACtL,IAAKrC,EAAQ4N,IAAK4D,EAAQrN,SACjE,GAAqB,iBAAVqN,KAAwBA,aAAkB5P,QACnD,MAAO,CAAC4P,EAAO1Q,MAAQ,SAAU0Q,EAAO/C,SAAUnM,EAAAY,CAAC,GAAGwO,cAGxD,MAAO,CAAC,SAAUF,EAAQE,EAC5B,CA5BkCC,CAAUV,GACxCK,IAAYlB,GAAUhM,EAAIwN,KA6B9B,WACE,GAAwB,iBAAbX,KAA2BA,aAAqBrP,SAAWqP,EAAUY,MAAO,CACrF,IAAKzE,EAAUK,OAAQ,MAAM,IAAI1D,MAAM,+BACvC,OAAOzH,EAAAY,CAAC,SAASqO,KAAUxO,IAC7B,CACA,MAAwB,mBAAV2N,EAAuBpO,EAAAY,CAAC,GAAGqO,KAAUxO,KAAUT,EAAAY,CAAC,GAAGqO,UAAexO,IAClF,CAnCmC+O,GAoCrC,CA5EKC,GA6EP,GAGFnR,EAAAA,QAAeoD,C,gBCrHf,SAAwBgO,EAAW/J,GACjC,MAAMxC,EAAMwC,EAAI1G,OAChB,IAEI0Q,EAFA1Q,EAAS,EACT2Q,EAAM,EAEV,KAAOA,EAAMzM,GACXlE,IACA0Q,EAAQhK,EAAIkK,WAAWD,KACnBD,GAAS,OAAUA,GAAS,OAAUC,EAAMzM,IAE9CwM,EAAQhK,EAAIkK,WAAWD,GACE,SAAZ,MAARD,IAA4BC,KAGrC,OAAO3Q,CACT,C,iDAfAX,EAAAA,QAAAoR,EAiBAA,EAAW7N,KAAO,gD,iECjBlB,MAAqByL,UAAwB7F,MAK3CzI,WAAAA,CAAY2N,GACVmD,MAAM,qBACNxD,KAAKK,OAASA,EACdL,KAAKyD,IAAMzD,KAAK0D,YAAa,CAC/B,EATF1R,EAAAA,QAAAgP,C,oIC0BA,IAAA2C,EAAAhQ,EAAA,OAAQP,OAAAA,eAAAA,EAAAA,aAAAA,CAAAwQ,YAAA,EAAAC,IAAA,kBAAAF,EAAAG,UAAU,IAKlB,IAAApQ,EAAAC,EAAA,OAAQP,OAAAA,eAAAA,EAAAA,IAAAA,CAAAwQ,YAAA,EAAAC,IAAA,kBAAAnQ,EAAAY,CAAC,IAAElB,OAAAA,eAAAA,EAAAA,MAAAA,CAAAwQ,YAAA,EAAAC,IAAA,kBAAAnQ,EAAA2F,GAAG,IAAEjG,OAAAA,eAAAA,EAAAA,YAAAA,CAAAwQ,YAAA,EAAAC,IAAA,kBAAAnQ,EAAAkB,SAAS,IAAExB,OAAAA,eAAAA,EAAAA,MAAAA,CAAAwQ,YAAA,EAAAC,IAAA,kBAAAnQ,EAAAiM,GAAG,IAAEvM,OAAAA,eAAAA,EAAAA,OAAAA,CAAAwQ,YAAA,EAAAC,IAAA,kBAAAnQ,EAAA2I,IAAI,IAAQjJ,OAAAA,eAAAA,EAAAA,UAAAA,CAAAwQ,YAAA,EAAAC,IAAA,kBAAAnQ,EAAAqQ,OAAO,IAsBnD,MAAAC,EAAArQ,EAAA,OACAwK,EAAAxK,EAAA,OACAsQ,EAAAtQ,EAAA,OACA0K,EAAA1K,EAAA,OACAuQ,EAAAvQ,EAAA,OACAwQ,EAAAxQ,EAAA,OACAyQ,EAAAzQ,EAAA,OACAC,EAAAD,EAAA,OACA0Q,EAAA1Q,EAAA,OAEA2Q,EAAA3Q,EAAA,OAEM4Q,EAA8BA,CAAClL,EAAKnG,IAAU,IAAIF,OAAOqG,EAAKnG,GACpEqR,EAAchP,KAAO,aAErB,MAAMiP,EAAyC,CAAC,mBAAoB,cAAe,eAC7EC,EAAkB,IAAIhI,IAAI,CAC9B,WACA,YACA,QACA,UACA,OACA,SACA,UACA,UACA,UACA,gBACA,OACA,MACA,UA0GIiI,EAA8C,CAClDC,cAAe,GACf7C,OAAQ,gDACR8C,SAAU,8CACVC,aAAc,mDACdC,WAAY,wDACZC,YAAa,sEACbC,YAAa,oEACbC,WAAY,oCACZC,eAAgB,0CAChBC,eAAgB,0CAChBC,YAAa,6CACbC,eAAgB,+EAChBC,MAAO,8CACPC,UAAW,8CACXC,UAAW,sBAGPC,EAAoD,CACxDC,sBAAuB,GACvBvJ,iBAAkB,GAClBwJ,QAAS,sEA6BX,SAASC,EAAgBC,G,sDACvB,MAAMzK,EAAIyK,EAAEC,OACNC,EAAc,QAANnU,EAAAiU,EAAEtQ,YAAI,IAAA3D,OAAA,EAAAA,EAAEoU,SAChBA,GAAqB,IAAVD,QAA4BrU,IAAVqU,EAAsB,EAAIA,GAAS,EAChEE,EAAuB,QAAdC,EAAM,QAANC,EAAAN,EAAEtQ,YAAI,IAAA4Q,OAAA,EAAAA,EAAEF,cAAM,IAAAC,EAAAA,EAAI3B,EAC3BnF,EAA2B,QAAbgH,EAAAP,EAAEzG,mBAAW,IAAAgH,EAAAA,EAAI9B,EAAAtP,QACrC,MAAO,CACLgN,aAAiC,QAAnBqE,EAAc,QAAdC,EAAAT,EAAE7D,oBAAY,IAAAsE,EAAAA,EAAIlL,SAAC,IAAAiL,GAAAA,EACjCE,cAAmC,QAApBC,EAAe,QAAfC,EAAAZ,EAAEU,qBAAa,IAAAE,EAAAA,EAAIrL,SAAC,IAAAoL,GAAAA,EACnCE,YAA+B,QAAlBC,EAAa,QAAbC,EAAAf,EAAEa,mBAAW,IAAAE,EAAAA,EAAIxL,SAAC,IAAAuL,EAAAA,EAAI,MACnCrQ,aAAiC,QAAnBuQ,EAAc,QAAdC,EAAAjB,EAAEvP,oBAAY,IAAAwQ,EAAAA,EAAI1L,SAAC,IAAAyL,EAAAA,EAAI,MACrCE,eAAqC,QAArBC,EAAgB,QAAhBC,EAAApB,EAAEkB,sBAAc,IAAAE,EAAAA,EAAI7L,SAAC,IAAA4L,GAAAA,EACrCzR,KAAMsQ,EAAEtQ,KAAO,IAAIsQ,EAAEtQ,KAAMyQ,WAAUC,UAAU,CAACD,WAAUC,UAC1DiB,aAA4B,QAAdC,EAAAtB,EAAEqB,oBAAY,IAAAC,EAAAA,EAhBT,IAiBnBC,SAAoB,QAAVC,EAAAxB,EAAEuB,gBAAQ,IAAAC,EAAAA,EAjBD,IAkBnBC,KAAY,QAANC,EAAA1B,EAAEyB,YAAI,IAAAC,GAAAA,EACZC,SAAoB,QAAVC,EAAA5B,EAAE2B,gBAAQ,IAAAC,GAAAA,EACpBC,WAAwB,QAAZC,EAAA9B,EAAE6B,kBAAU,IAAAC,GAAAA,EACxBC,SAAoB,QAAVC,EAAAhC,EAAE+B,gBAAQ,IAAAC,EAAAA,EAAI,MACxBC,cAA8B,QAAfC,EAAAlC,EAAEiC,qBAAa,IAAAC,GAAAA,EAC9BC,eAAgC,QAAhBC,EAAApC,EAAEmC,sBAAc,IAAAC,GAAAA,EAChCxG,gBAAkC,QAAjByG,EAAArC,EAAEpE,uBAAe,IAAAyG,GAAAA,EAClCC,cAA8B,QAAfC,EAAAvC,EAAEsC,qBAAa,IAAAC,GAAAA,EAC9BC,WAAwB,QAAZC,EAAAzC,EAAEwC,kBAAU,IAAAC,GAAAA,EACxBlJ,YAAaA,EAEjB,CAQA,MAAqBmJ,EAkBnB7V,WAAAA,GAA8B,IAAlB0B,EAAA2B,UAAApD,OAAA,QAAAjB,IAAAqE,UAAA,GAAAA,UAAA,GAAgB,CAAC,EAZpB,KAAAyS,QAAyC,CAAC,EAC1C,KAAAC,KAA+C,CAAC,EAChD,KAAA9G,QAA4C,CAAC,EAE7C,KAAA+G,cAAgC,IAAIjM,IAC5B,KAAAkM,SAAyD,CAAC,EAC1D,KAAAC,OAAoC,IAAIC,IAOvDzU,EAAO4L,KAAK5L,KAAO,IAAIA,KAASwR,EAAgBxR,IAChD,MAAM,IAAC0U,EAAG,MAAEC,GAAS/I,KAAK5L,KAAKmB,KAE/ByK,KAAKgJ,MAAQ,IAAI9E,EAAA+E,WAAW,CAACD,MAAO,CAAC,EAAGE,SAAUzE,EAAiBqE,MAAKC,UACxE/I,KAAKsC,OAsgBT,SAAmBA,GACjB,IAAe,IAAXA,EAAkB,OAAO6G,EAC7B,QAAezX,IAAX4Q,EAAsB,OAAO8G,QACjC,GAAI9G,EAAO+G,KAAO/G,EAAOC,MAAQD,EAAO/J,MAAO,OAAO+J,EACtD,MAAM,IAAInH,MAAM,oDAClB,CA3gBkBmO,CAAUlV,EAAKkO,QAC7B,MAAMiH,EAAYnV,EAAKqN,gBACvBrN,EAAKqN,iBAAkB,EAEvBzB,KAAK5N,OAAQ,EAAA6R,EAAAuF,YACbC,EAAajW,KAAKwM,KAAM0E,EAAgBtQ,EAAM,iBAC9CqV,EAAajW,KAAKwM,KAAMyF,EAAmBrR,EAAM,aAAc,QAC/D4L,KAAK0J,UAAYC,EAAqBnW,KAAKwM,MAEvC5L,EAAKuN,SAASiI,EAAkBpW,KAAKwM,MACzCA,KAAK6J,mBACL7J,KAAK8J,wBACD1V,EAAK2V,UAAUC,EAAmBxW,KAAKwM,KAAM5L,EAAK2V,UAC9B,iBAAb3V,EAAKkT,MAAkBtH,KAAKiK,cAAc7V,EAAKkT,MAC1D4C,EAAkB1W,KAAKwM,MACvB5L,EAAKqN,gBAAkB8H,CACzB,CAEAM,gBAAAA,GACE7J,KAAKmK,WAAW,SAClB,CAEAL,qBAAAA,GACE,MAAM,MAAC7L,EAAK,KAAEqJ,EAAI,SAAEM,GAAY5H,KAAK5L,KACrC,IAAIgW,EAA+B/F,EAClB,OAAbuD,IACFwC,EAAiB,IAAI/F,GACrB+F,EAAeC,GAAKD,EAAeE,WAC5BF,EAAeE,KAEpBhD,GAAQrJ,GAAO+B,KAAKiK,cAAcG,EAAgBA,EAAexC,IAAW,EAClF,CAEA2C,WAAAA,GACE,MAAM,KAACjD,EAAI,SAAEM,GAAY5H,KAAK5L,KAC9B,OAAQ4L,KAAK5L,KAAKmW,YAA6B,iBAARjD,EAAmBA,EAAKM,IAAaN,OAAO5V,CACrF,CAoBAmO,QAAAA,CACE2K,EAEArW,GAEA,IAAImL,EACJ,GAA2B,iBAAhBkL,GAET,GADAlL,EAAIU,KAAKyK,UAAaD,IACjBlL,EAAG,MAAM,IAAInE,MAAM,8BAA8BqP,WAEtDlL,EAAIU,KAAK0K,QAAWF,GAGtB,MAAM7T,EAAQ2I,EAAEnL,GAEhB,MADM,WAAYmL,IAAIU,KAAKK,OAASf,EAAEe,QAC/B1J,CACT,CAiBA+T,OAAAA,CAAqBtZ,EAAmBuZ,GACtC,MAAMzV,EAAM8K,KAAK4K,WAAWxZ,EAAQuZ,GACpC,OAAQzV,EAAI2K,UAAYG,KAAK6K,kBAAkB3V,EACjD,CAmBA4V,YAAAA,CACE1Z,EACAkW,GAEA,GAAmC,mBAAxBtH,KAAK5L,KAAK2W,WACnB,MAAM,IAAI5P,MAAM,2CAElB,MAAM,WAAC4P,GAAc/K,KAAK5L,KAC1B,OAAO4W,EAAgBxX,KAAKwM,KAAM5O,EAAQkW,GAE1CrE,eAAe+H,EAEbC,EACAN,SAEMO,EAAe1X,KAAKwM,KAAMiL,EAAQE,SACxC,MAAMjW,EAAM8K,KAAK4K,WAAWK,EAASN,GACrC,OAAOzV,EAAI2K,UAAYuL,EAAc5X,KAAKwM,KAAM9K,EAClD,CAEA+N,eAAeiI,EAA0B5M,GACnCA,IAAS0B,KAAKyK,UAAUnM,UACpB0M,EAAgBxX,KAAKwM,KAAM,CAAC1B,SAAO,EAE7C,CAEA2E,eAAemI,EAAyBlW,GACtC,IACE,OAAO8K,KAAK6K,kBAAkB3V,EAChC,CAAE,MAAO6L,GACP,KAAMA,aAAa5C,EAAAnJ,SAAkB,MAAM+L,EAG3C,OAFAsK,EAAY7X,KAAKwM,KAAMe,SACjBuK,EAAkB9X,KAAKwM,KAAMe,EAAEwK,eAC9BH,EAAc5X,KAAKwM,KAAM9K,EAClC,CACF,CAEA,SAASmW,EAAWpZ,GAA6D,IAAhDsZ,cAAevM,EAAG,WAAEwM,GAA4BvZ,EAC/E,GAAI+N,KAAKyI,KAAKzJ,GACZ,MAAM,IAAI7D,MAAM,aAAa6D,mBAAqBwM,uBAEtD,CAEAvI,eAAeqI,EAA6BtM,GAC1C,MAAMiM,QAAgBQ,EAAYjY,KAAKwM,KAAMhB,GACxCgB,KAAKyI,KAAKzJ,UAAYkM,EAAe1X,KAAKwM,KAAMiL,EAAQE,SACxDnL,KAAKyI,KAAKzJ,IAAMgB,KAAK0L,UAAUT,EAASjM,EAAKsI,EACpD,CAEArE,eAAewI,EAAuBzM,GACpC,MAAM2M,EAAI3L,KAAK2I,SAAS3J,GACxB,GAAI2M,EAAG,OAAOA,EACd,IACE,aAAc3L,KAAK2I,SAAS3J,GAAO+L,EAAW/L,GAChD,CAAE,eACOgB,KAAK2I,SAAS3J,EACvB,CACF,CACF,CAGA0M,SAAAA,CACEta,EACAqC,EACAkX,G,IAOIN,EANJuB,EAAe7V,UAAApD,OAAA,QAAAjB,IAAAqE,UAAA,GAAAA,UAAA,GAAGiK,KAAK5L,KAAK4T,eAE5B,GAAIlV,MAAMC,QAAQ3B,GAAS,CACzB,IAAK,MAAM8D,KAAO9D,EAAQ4O,KAAK0L,UAAUxW,OAAKxD,EAAWiZ,EAAOiB,GAChE,OAAO5L,IACT,CAEA,GAAsB,kBAAX5O,EAAqB,CAC9B,MAAM,SAACwW,GAAY5H,KAAK5L,KAExB,GADAiW,EAAKjZ,EAAOwW,QACDlW,IAAP2Y,GAAiC,iBAANA,EAC7B,MAAM,IAAIlP,MAAM,UAAUyM,mBAE9B,CAIA,OAHAnU,GAAM,EAAA0Q,EAAA0H,aAAYpY,GAAO4W,GACzBrK,KAAK8L,aAAarY,GAClBuM,KAAKwI,QAAQ/U,GAAOuM,KAAK4K,WAAWxZ,EAAQuZ,EAAOlX,EAAKmY,GAAiB,GAClE5L,IACT,CAIAiK,aAAAA,CACE7Y,EACAqC,G,IACAmY,EAAe7V,UAAApD,OAAA,QAAAjB,IAAAqE,UAAA,GAAAA,UAAA,GAAGiK,KAAK5L,KAAK4T,eAG5B,OADAhI,KAAK0L,UAAUta,EAAQqC,GAAK,EAAMmY,GAC3B5L,IACT,CAGAgI,cAAAA,CAAe5W,EAAmB2a,GAChC,GAAqB,kBAAV3a,EAAqB,OAAO,EACvC,IAAI+Z,EAEJ,GADAA,EAAU/Z,EAAO+Z,aACDzZ,IAAZyZ,GAA2C,iBAAXA,EAClC,MAAM,IAAIhQ,MAAM,4BAGlB,GADAgQ,EAAUA,GAAWnL,KAAK5L,KAAKmW,aAAevK,KAAKuK,eAC9CY,EAGH,OAFAnL,KAAKsC,OAAOC,KAAK,6BACjBvC,KAAKK,OAAS,MACP,EAET,MAAM1J,EAAQqJ,KAAKH,SAASsL,EAAS/Z,GACrC,IAAKuF,GAASoV,EAAiB,CAC7B,MAAMjO,EAAU,sBAAwBkC,KAAKgM,aAC7C,GAAiC,QAA7BhM,KAAK5L,KAAK4T,eACT,MAAM,IAAI7M,MAAM2C,GADmBkC,KAAKsC,OAAO/J,MAAMuF,EAE5D,CACA,OAAOnH,CACT,CAIA8T,SAAAA,CAAuBwB,GACrB,IAAI/W,EACJ,KAAsD,iBAAvCA,EAAMgX,EAAU1Y,KAAKwM,KAAMiM,KAAsBA,EAAS/W,EACzE,QAAYxD,IAARwD,EAAmB,CACrB,MAAM,SAAC0S,GAAY5H,KAAK5L,KAClBuK,EAAO,IAAIN,EAAAgB,UAAU,CAACjO,OAAQ,CAAC,EAAGwW,aAExC,GADA1S,EAAMmJ,EAAA8N,cAAc3Y,KAAKwM,KAAMrB,EAAMsN,IAChC/W,EAAK,OACV8K,KAAKyI,KAAKwD,GAAU/W,CACtB,CACA,OAAQA,EAAI2K,UAAYG,KAAK6K,kBAAkB3V,EACjD,CAMAkX,YAAAA,CAAa5B,GACX,GAAIA,aAAwBxX,OAG1B,OAFAgN,KAAKqM,kBAAkBrM,KAAKwI,QAASgC,GACrCxK,KAAKqM,kBAAkBrM,KAAKyI,KAAM+B,GAC3BxK,KAET,cAAewK,GACb,IAAK,YAIH,OAHAxK,KAAKqM,kBAAkBrM,KAAKwI,SAC5BxI,KAAKqM,kBAAkBrM,KAAKyI,MAC5BzI,KAAK4I,OAAO0D,QACLtM,KACT,IAAK,SAAU,CACb,MAAM9K,EAAMgX,EAAU1Y,KAAKwM,KAAMwK,GAIjC,MAHkB,iBAAPtV,GAAiB8K,KAAK4I,OAAO2D,OAAOrX,EAAI9D,eAC5C4O,KAAKwI,QAAQgC,UACbxK,KAAKyI,KAAK+B,GACVxK,IACT,CACA,IAAK,SAAU,CACb,MAAMwM,EAAWhC,EACjBxK,KAAK4I,OAAO2D,OAAOC,GACnB,IAAInC,EAAKG,EAAaxK,KAAK5L,KAAKwT,UAMhC,OALIyC,IACFA,GAAK,EAAAlG,EAAA0H,aAAYxB,UACVrK,KAAKwI,QAAQ6B,UACbrK,KAAKyI,KAAK4B,IAEZrK,IACT,CACA,QACE,MAAM,IAAI7E,MAAM,uCAEtB,CAGAsR,aAAAA,CAAcC,GACZ,IAAK,MAAMtX,KAAOsX,EAAa1M,KAAKmK,WAAW/U,GAC/C,OAAO4K,IACT,CAEAmK,UAAAA,CACEwC,EACAvX,GAEA,IAAIzD,EACJ,GAAuB,iBAAZgb,EACThb,EAAUgb,EACQ,iBAAPvX,IACT4K,KAAKsC,OAAOC,KAAK,4DACjBnN,EAAIzD,QAAUA,OAEX,IAAuB,iBAAZgb,QAAgCjb,IAAR0D,EAOxC,MAAM,IAAI+F,MAAM,kCAJhB,GADAxJ,GADAyD,EAAMuX,GACQhb,QACVmB,MAAMC,QAAQpB,KAAaA,EAAQgB,OACrC,MAAM,IAAIwI,MAAM,yDAIpB,CAGA,GADAyR,EAAapZ,KAAKwM,KAAMrO,EAASyD,IAC5BA,EAEH,OADA,EAAAxB,EAAAiZ,UAASlb,EAAUI,GAAQ+a,EAAQtZ,KAAKwM,KAAMjO,IACvCiO,KAET+M,EAAkBvZ,KAAKwM,KAAM5K,GAC7B,MAAMvD,EAAqC,IACtCuD,EACHlD,MAAM,EAAAkS,EAAA4I,cAAa5X,EAAIlD,MACvBmD,YAAY,EAAA+O,EAAA4I,cAAa5X,EAAIC,aAQ/B,OANA,EAAAzB,EAAAiZ,UACElb,EAC2B,IAA3BE,EAAWK,KAAKS,OACXsa,GAAMH,EAAQtZ,KAAKwM,KAAMiN,EAAGpb,GAC5Bob,GAAMpb,EAAWK,KAAK+C,QAASiY,GAAMJ,EAAQtZ,KAAKwM,KAAMiN,EAAGpb,EAAYqb,KAEvElN,IACT,CAEAmN,UAAAA,CAAWxb,GACT,MAAMH,EAAOwO,KAAK5N,MAAMgb,IAAIzb,GAC5B,MAAsB,iBAARH,EAAmBA,EAAKK,aAAeL,CACvD,CAGA6b,aAAAA,CAAc1b,GAEZ,MAAM,MAACS,GAAS4N,YACT5N,EAAM2X,SAASpY,UACfS,EAAMgb,IAAIzb,GACjB,IAAK,MAAMN,KAASe,EAAMd,MAAO,CAC/B,MAAMsB,EAAIvB,EAAMC,MAAMgc,UAAW9b,GAASA,EAAKG,UAAYA,GACvDiB,GAAK,GAAGvB,EAAMC,MAAMic,OAAO3a,EAAG,EACpC,CACA,OAAOoN,IACT,CAGAwN,SAAAA,CAAU5W,EAAckL,GAGtB,MAFqB,iBAAVA,IAAoBA,EAAS,IAAI9O,OAAO8O,IACnD9B,KAAK2B,QAAQ/K,GAAQkL,EACd9B,IACT,CAEAgM,UAAAA,G,IACE3L,EAAAtK,UAAApD,OAAA,QAAAjB,IAAAqE,UAAA,GAAAA,UAAA,GAA2CiK,KAAKK,QAChD,UAACoN,EAAY,KAAI,QAAEC,EAAU,QAAM3X,UAAApD,OAAA,QAAAjB,IAAAqE,UAAA,GAAAA,UAAA,GAAuB,CAAC,EAE3D,OAAKsK,GAA4B,IAAlBA,EAAO1N,OACf0N,EACJsN,IAAK5M,GAAM,GAAG2M,IAAU3M,EAAE6M,gBAAgB7M,EAAEjD,WAC5C+P,OAAO,CAACC,EAAMvX,IAAQuX,EAAOL,EAAYlX,GAHD,WAI7C,CAEAwX,eAAAA,CAAgBC,EAA6BC,GAC3C,MAAM3c,EAAQ0O,KAAK5N,MAAMgb,IACzBY,EAAaE,KAAKC,MAAMD,KAAKtZ,UAAUoZ,IACvC,IAAK,MAAMI,KAAeH,EAAsB,CAC9C,MAAMI,EAAWD,EAAYE,MAAM,KAAKjT,MAAM,GAC9C,IAAI0O,EAAWiE,EACf,IAAK,MAAMO,KAAOF,EAAUtE,EAAWA,EAASwE,GAEhD,IAAK,MAAM9a,KAAOnC,EAAO,CACvB,MAAME,EAAOF,EAAMmC,GACnB,GAAmB,iBAARjC,EAAkB,SAC7B,MAAM,MAACyM,GAASzM,EAAKK,WACfT,EAAS2Y,EAAStW,GACpBwK,GAAS7M,IAAQ2Y,EAAStW,GAAO+a,EAAapd,GACpD,CACF,CAEA,OAAO4c,CACT,CAEQ3B,iBAAAA,CAAkB7D,EAAiDiG,GACzE,IAAK,MAAMxC,KAAUzD,EAAS,CAC5B,MAAMtT,EAAMsT,EAAQyD,GACfwC,IAASA,EAAMC,KAAKzC,KACL,iBAAP/W,SACFsT,EAAQyD,GACN/W,IAAQA,EAAIoS,OACrBtH,KAAK4I,OAAO2D,OAAOrX,EAAI9D,eAChBoX,EAAQyD,IAGrB,CACF,CAEArB,UAAAA,CACExZ,EACAkW,EACA/I,GAEmC,IAE/B8L,EAHJrC,EAAcjS,UAAApD,OAAA,QAAAjB,IAAAqE,UAAA,GAAAA,UAAA,GAAGiK,KAAK5L,KAAK4T,eAC3B0D,EAAS3V,UAAApD,OAAA,QAAAjB,IAAAqE,UAAA,GAAAA,UAAA,GAAGiK,KAAK5L,KAAK0T,cAGtB,MAAM,SAACF,GAAY5H,KAAK5L,KACxB,GAAqB,iBAAVhD,EACTiZ,EAAKjZ,EAAOwW,OACP,CACL,GAAI5H,KAAK5L,KAAKua,IAAK,MAAM,IAAIxT,MAAM,yBAC9B,GAAqB,kBAAV/J,EAAqB,MAAM,IAAI+J,MAAM,mCACvD,CACA,IAAIjG,EAAM8K,KAAK4I,OAAO/E,IAAIzS,GAC1B,QAAYM,IAARwD,EAAmB,OAAOA,EAE9BqJ,GAAS,EAAA4F,EAAA0H,aAAYxB,GAAM9L,GAC3B,MAAMqQ,EAAYzK,EAAA0K,cAAcrb,KAAKwM,KAAM5O,EAAQmN,GASnD,OARArJ,EAAM,IAAImJ,EAAAgB,UAAU,CAACjO,SAAQwW,WAAUN,OAAM/I,SAAQqQ,cACrD5O,KAAK4I,OAAOkG,IAAI5Z,EAAI9D,OAAQ8D,GACxBwW,IAAcnN,EAAOwQ,WAAW,OAE9BxQ,GAAQyB,KAAK8L,aAAavN,GAC9ByB,KAAKyI,KAAKlK,GAAUrJ,GAElB8S,GAAgBhI,KAAKgI,eAAe5W,GAAQ,GACzC8D,CACT,CAEQ4W,YAAAA,CAAazB,GACnB,GAAIrK,KAAKwI,QAAQ6B,IAAOrK,KAAKyI,KAAK4B,GAChC,MAAM,IAAIlP,MAAM,0BAA0BkP,oBAE9C,CAEQQ,iBAAAA,CAAkB3V,GAKxB,GAJIA,EAAIoS,KAAMtH,KAAKgP,mBAAmB9Z,GACjCmJ,EAAA4Q,cAAczb,KAAKwM,KAAM9K,IAGzBA,EAAI2K,SAAU,MAAM,IAAI1E,MAAM,4BACnC,OAAOjG,EAAI2K,QACb,CAEQmP,kBAAAA,CAAmB9Z,GACzB,MAAMga,EAAclP,KAAK5L,KACzB4L,KAAK5L,KAAO4L,KAAK0J,UACjB,IACErL,EAAA4Q,cAAczb,KAAKwM,KAAM9K,EAC3B,CAAE,QACA8K,KAAK5L,KAAO8a,CACd,CACF,EAQF,SAASzF,EAEP0F,EACAC,EACA7Y,GAC+B,IAA/B8S,EAAAtT,UAAApD,OAAA,QAAAjB,IAAAqE,UAAA,GAAAA,UAAA,GAAwB,QAExB,IAAK,MAAMtC,KAAO0b,EAAW,CAC3B,MAAME,EAAM5b,EACR4b,KAAOD,GAASpP,KAAKsC,OAAO+G,GAAK,GAAG9S,aAAe9C,MAAQ0b,EAAUE,KAC3E,CACF,CAEA,SAASnD,EAAqBD,GAE5B,OADAA,GAAS,EAAA9H,EAAA0H,aAAYI,GACdjM,KAAKwI,QAAQyD,IAAWjM,KAAKyI,KAAKwD,EAC3C,CAEA,SAAS/B,IACP,MAAMoF,EAActP,KAAK5L,KAAKoU,QAC9B,GAAK8G,EACL,GAAIxc,MAAMC,QAAQuc,GAActP,KAAK0L,UAAU4D,QAC1C,IAAK,MAAM7b,KAAO6b,EAAatP,KAAK0L,UAAU4D,EAAY7b,GAAmBA,EACpF,CAEA,SAASmW,IACP,IAAK,MAAMhT,KAAQoJ,KAAK5L,KAAKuN,QAAS,CACpC,MAAMG,EAAS9B,KAAK5L,KAAKuN,QAAQ/K,GAC7BkL,GAAQ9B,KAAKwN,UAAU5W,EAAMkL,EACnC,CACF,CAEA,SAASkI,EAEPuF,GAEA,GAAIzc,MAAMC,QAAQwc,GAChBvP,KAAKyM,cAAc8C,OADrB,CAIAvP,KAAKsC,OAAOC,KAAK,oDACjB,IAAK,MAAM5Q,KAAW4d,EAAM,CAC1B,MAAMna,EAAMma,EAAK5d,GACZyD,EAAIzD,UAASyD,EAAIzD,QAAUA,GAChCqO,KAAKmK,WAAW/U,EAClB,CANA,CAOF,CAEA,SAASuU,IACP,MAAM6F,EAAW,IAAIxP,KAAK5L,MAC1B,IAAK,MAAMib,KAAO7K,SAA4BgL,EAASH,GACvD,OAAOG,CACT,CA1gBSjH,EAAAvH,gBAAkBgD,EAAAhP,QAClBuT,EAAAkH,gBAAkBtR,EAAAnJ,Q,UAhBNuT,EA2hBrB,MAAMY,EAAS,CAACE,GAAAA,GAAO,EAAG9G,IAAAA,GAAQ,EAAGhK,KAAAA,GAAS,GAS9C,MAAMmX,EAAe,0BAErB,SAAS9C,EAAwBjb,EAA4ByD,GAC3D,MAAM,MAAChD,GAAS4N,KAKhB,IAJA,EAAApM,EAAAiZ,UAASlb,EAAUI,IACjB,GAAIK,EAAM2X,SAAShY,GAAM,MAAM,IAAIoJ,MAAM,WAAWpJ,wBACpD,IAAK2d,EAAahB,KAAK3c,GAAM,MAAM,IAAIoJ,MAAM,WAAWpJ,wBAErDqD,GACDA,EAAI6I,SAAW,SAAU7I,MAAO,aAAcA,GAChD,MAAM,IAAI+F,MAAM,wDAEpB,CAEA,SAAS2R,EAEPnb,EACAE,EACA8d,G,MAEA,MAAMC,EAAiB,OAAV/d,QAAU,IAAVA,OAAU,EAAVA,EAAY+d,KACzB,GAAID,GAAYC,EAAM,MAAM,IAAIzU,MAAM,+CACtC,MAAM,MAAC/I,GAAS4N,KAChB,IAAI6P,EAAYD,EAAOxd,EAAMwd,KAAOxd,EAAMd,MAAMwe,KAAKrU,IAAA,IAAEvJ,KAAMgb,GAAEzR,EAAA,OAAKyR,IAAMyC,IAM1E,GALKE,IACHA,EAAY,CAAC3d,KAAMyd,EAAUre,MAAO,IACpCc,EAAMd,MAAMyH,KAAK8W,IAEnBzd,EAAM2X,SAASpY,IAAW,GACrBE,EAAY,OAEjB,MAAML,EAAa,CACjBG,UACAE,WAAY,IACPA,EACHK,MAAM,EAAAkS,EAAA4I,cAAanb,EAAWK,MAC9BmD,YAAY,EAAA+O,EAAA4I,cAAanb,EAAWwD,cAGpCxD,EAAWyD,OAAQya,EAAcvc,KAAKwM,KAAM6P,EAAWre,EAAMK,EAAWyD,QACvEua,EAAUve,MAAMyH,KAAKvH,GAC1BY,EAAMgb,IAAIzb,GAAWH,EACA,QAArBI,EAAAC,EAAWC,kBAAU,IAAAF,GAAAA,EAAEqD,QAASlD,GAAQiO,KAAKmK,WAAWpY,GAC1D,CAEA,SAASge,EAAyBF,EAAsBre,EAAY8D,GAClE,MAAM1C,EAAIid,EAAUve,MAAMgc,UAAW0C,GAAUA,EAAMre,UAAY2D,GAC7D1C,GAAK,EACPid,EAAUve,MAAMic,OAAO3a,EAAG,EAAGpB,IAE7Bqe,EAAUve,MAAMyH,KAAKvH,GACrBwO,KAAKsC,OAAOC,KAAK,QAAQjN,oBAE7B,CAEA,SAASyX,EAA6B3X,GACpC,IAAI,WAAC4Y,GAAc5Y,OACA1D,IAAfsc,IACA5Y,EAAI6I,OAAS+B,KAAK5L,KAAK6J,QAAO+P,EAAaQ,EAAaR,IAC5D5Y,EAAI4S,eAAiBhI,KAAK0K,QAAQsD,GAAY,GAChD,CAEA,MAAMiC,EAAW,CACf3R,KAAM,kFAGR,SAASkQ,EAAapd,GACpB,MAAO,CAAC8e,MAAO,CAAC9e,EAAQ6e,GAC1B,C,mECx3BA,MAAAvc,EAAAC,EAAA,OACAC,EAAAD,EAAA,OACAwc,EAAAxc,EAAA,OAUMyB,EAA6B,CACjCzD,QAAS,CAAC,YAAa,aACvBO,KAAM,SACNmD,WAAY,SACZ4I,OAAO,EACP1F,MAboC,CACpCuF,OAAAA,CAAO7L,GAAsB,IAArB,QAACN,EAAO,WAAEoM,GAAW9L,EAC3B,MAAMme,EAAmB,cAAZze,EAA0B,OAAS,QAChD,OAAO+B,EAAA2F,GAAG,iBAAiB+W,UAAarS,cAC1C,EACAC,OAAQvC,IAAA,IAAC,WAACsC,GAAWtC,EAAA,OAAK/H,EAAAY,CAAC,WAAWyJ,OAStCxI,IAAAA,CAAKC,GACH,MAAM,QAAC7D,EAAO,KAAEwC,EAAI,WAAE4J,EAAU,GAAEjK,GAAM0B,EAClC6a,EAAiB,cAAZ1e,EAA0B+B,EAAAwJ,UAAUM,GAAK9J,EAAAwJ,UAAUS,GACxD9G,GACgB,IAApB/C,EAAGM,KAAKuR,QAAoBjS,EAAAY,CAAC,GAAGH,WAAgBT,EAAAY,CAAC,IAAG,EAAAV,EAAA0c,SAAQ9a,EAAIvB,IAAKkc,EAAAnb,YAAeb,KACtFqB,EAAI0I,UAAUxK,EAAAY,CAAC,GAAGuC,KAAOwZ,KAAMtS,IACjC,GAGF/L,EAAAA,QAAeoD,C,wJCnBf,MAAA1B,EAAAC,EAAA,OACAqQ,EAAArQ,EAAA,OACAyK,EAAAzK,EAAA,OACAwQ,EAAAxQ,EAAA,OACAC,EAAAD,EAAA,OACAgQ,EAAAhQ,EAAA,OA0DA,MAAa0L,EAkBX3M,WAAAA,CAAY+L,G,MACV,IAAIrN,EAVG,KAAAqX,KAAmB,CAAC,EACpB,KAAA8H,eAA2C,CAAC,EAU1B,iBAAd9R,EAAIrN,SAAoBA,EAASqN,EAAIrN,QAChD4O,KAAK5O,OAASqN,EAAIrN,OAClB4O,KAAK4H,SAAWnJ,EAAImJ,SACpB5H,KAAKrB,KAAOF,EAAIE,MAAQqB,KACxBA,KAAKzB,OAAmB,QAAV3M,EAAA6M,EAAIF,cAAM,IAAA3M,EAAAA,GAAI,EAAAuS,EAAA0H,aAAkB,OAANza,QAAM,IAANA,OAAM,EAANA,EAASqN,EAAImJ,UAAY,QACjE5H,KAAK1E,WAAamD,EAAInD,WACtB0E,KAAK4O,UAAYnQ,EAAImQ,UACrB5O,KAAKsH,KAAO7I,EAAI6I,KAChBtH,KAAKnB,OAAe,OAANzN,QAAM,IAANA,OAAM,EAANA,EAAQyN,OACtBmB,KAAKyI,KAAO,CAAC,CACf,EAOF,SAAgBwG,EAAyB/Z,GAEvC,MAAMsb,EAAOC,EAAmBjd,KAAKwM,KAAM9K,GAC3C,GAAIsb,EAAM,OAAOA,EACjB,MAAME,GAAS,EAAAvM,EAAAwM,aAAY3Q,KAAK5L,KAAKgL,YAAalK,EAAIyJ,KAAKJ,SACrD,IAACuK,EAAG,MAAEC,GAAS/I,KAAK5L,KAAKmB,MACzB,cAACqb,GAAiB5Q,KAAK5L,KACvBH,EAAM,IAAIP,EAAAqQ,QAAQ/D,KAAKgJ,MAAO,CAACF,MAAKC,QAAO6H,kBACjD,IAAIC,EACA3b,EAAI2J,SACNgS,EAAmB5c,EAAI8K,WAAW,QAAS,CACzCC,IAAKgF,EAAAhP,QACLO,KAAM7B,EAAAY,CAAC,0DAIX,MAAMoK,EAAezK,EAAI6c,UAAU,YACnC5b,EAAIwJ,aAAeA,EAEnB,MAAMqS,EAAuB,CAC3B9c,MACA+I,UAAWgD,KAAK5L,KAAK4I,UACrB7I,KAAMiK,EAAApJ,QAAEb,KACRuI,WAAY0B,EAAApJ,QAAE0H,WACdN,mBAAoBgC,EAAApJ,QAAEoH,mBACtBO,UAAW,CAACyB,EAAApJ,QAAEb,MACd4H,YAAa,CAACrI,EAAAiM,KACdpD,UAAW,EACXX,UAAW,GACXY,kBAAmB,IAAIC,IACvBlB,aAActH,EAAI8K,WAChB,UAC0B,IAA1BiB,KAAK5L,KAAKmB,KAAKtC,OACX,CAAC+L,IAAK9J,EAAI9D,OAAQmE,MAAM,EAAA7B,EAAAkB,WAAUM,EAAI9D,SACtC,CAAC4N,IAAK9J,EAAI9D,SAEhBsN,eACAsC,gBAAiB6P,EACjBzf,OAAQ8D,EAAI9D,OACZoN,UAAWtJ,EACXwb,SACAnS,OAAQrJ,EAAIqJ,QAAUmS,EACtBpV,WAAY5H,EAAAiM,IACZ1J,cAAef,EAAIoG,aAAe0E,KAAK5L,KAAKua,IAAM,GAAK,KACvD7S,UAAWpI,EAAAY,CAAC,KACZF,KAAM4L,KAAK5L,KACXjC,KAAM6N,MAGR,IAAIiF,EACJ,IACEjF,KAAK0I,cAAcsI,IAAI9b,IACvB,EAAAyO,EAAAsN,sBAAqBF,GACrB9c,EAAI+R,SAAShG,KAAK5L,KAAKmB,KAAKyQ,UAE5B,MAAMkL,EAAejd,EAAIX,WACzB2R,EAAa,GAAGhR,EAAIkd,UAAU/S,EAAApJ,QAAEgU,gBAAgBkI,IAE5ClR,KAAK5L,KAAKmB,KAAK6b,UAASnM,EAAajF,KAAK5L,KAAKmB,KAAK6b,QAAQnM,EAAY/P,IAE5E,MACM2K,EADe,IAAIwR,SAAS,GAAGjT,EAAApJ,QAAE7C,OAAQ,GAAGiM,EAAApJ,QAAEgU,QAAS/D,EACvBqM,CAAatR,KAAMA,KAAKgJ,MAAMnF,OAUpE,GATA7D,KAAKgJ,MAAM3F,MAAM3E,EAAc,CAACM,IAAKa,IAErCA,EAASQ,OAAS,KAClBR,EAASzO,OAAS8D,EAAI9D,OACtByO,EAASrB,UAAYtJ,EACjBA,EAAI2J,SAASgB,EAAmChB,QAAS,IAC/B,IAA1BmB,KAAK5L,KAAKmB,KAAKtC,SACjB4M,EAAS5M,OAAS,CAACyL,eAAcwS,eAAcK,YAAatd,EAAIud,UAE9DxR,KAAK5L,KAAKqC,YAAa,CACzB,MAAM,MAACgK,EAAK,MAAE1L,GAASgc,EACvBlR,EAASW,UAAY,CACnBC,MAAOA,aAAiB/M,EAAA2I,UAAO3K,EAAY+O,EAC3C1L,MAAOA,aAAiBrB,EAAA2I,UAAO3K,EAAYqD,EAC3C2L,aAAcD,aAAiB/M,EAAA2I,KAC/BuE,aAAc7L,aAAiBrB,EAAA2I,MAE7BwD,EAAS5M,SAAQ4M,EAAS5M,OAAOuN,WAAY,EAAA9M,EAAAkB,WAAUiL,EAASW,WACtE,CAEA,OADAtL,EAAI2K,SAAWA,EACR3K,CACT,CAAE,MAAO6L,GAKP,aAJO7L,EAAI2K,gBACJ3K,EAAIwJ,aACPuG,GAAYjF,KAAKsC,OAAO/J,MAAM,yCAA0C0M,GAEtElE,CACR,CAAE,QACAf,KAAK0I,cAAc6D,OAAOrX,EAC5B,CACF,CAuBA,SAASuc,EAA2Bvc,GAClC,OAAI,EAAAiP,EAAAuN,WAAUxc,EAAI9D,OAAQ4O,KAAK5L,KAAKsT,YAAoBxS,EAAI9D,OACrD8D,EAAI2K,SAAW3K,EAAM+Z,EAAczb,KAAKwM,KAAM9K,EACvD,CAGA,SAAgBub,EAA8BkB,GAC5C,IAAK,MAAMzc,KAAO8K,KAAK0I,cACrB,GAAIkJ,EAAc1c,EAAKyc,GAAS,OAAOzc,CAE3C,CAEA,SAAS0c,EAAcC,EAAeC,GACpC,OAAOD,EAAGzgB,SAAW0gB,EAAG1gB,QAAUygB,EAAGlT,OAASmT,EAAGnT,MAAQkT,EAAGtT,SAAWuT,EAAGvT,MAC5E,CAIA,SAASwT,EAEPpT,EACAK,GAEA,IAAI9J,EACJ,KAAwC,iBAAzBA,EAAM8K,KAAKyI,KAAKzJ,KAAmBA,EAAM9J,EACxD,OAAOA,GAAO8K,KAAKwI,QAAQxJ,IAAQmN,EAAc3Y,KAAKwM,KAAMrB,EAAMK,EACpE,CAGA,SAAgBmN,EAEdxN,EACAK,GAEA,MAAM2M,EAAI3L,KAAK5L,KAAKgL,YAAY+O,MAAMnP,GAChCgT,GAAU,EAAA7N,EAAA8N,cAAajS,KAAK5L,KAAKgL,YAAauM,GACpD,IAAIpN,GAAS,EAAA4F,EAAAwM,aAAY3Q,KAAK5L,KAAKgL,YAAaT,EAAKJ,YAAQ7M,GAE7D,GAAI0B,OAAOP,KAAK8L,EAAKvN,QAAQuB,OAAS,GAAKqf,IAAYzT,EACrD,OAAO2T,EAAe1e,KAAKwM,KAAM2L,EAAGhN,GAGtC,MAAM0L,GAAK,EAAAlG,EAAA0H,aAAYmG,GACjBG,EAAWnS,KAAKyI,KAAK4B,IAAOrK,KAAKwI,QAAQ6B,GAC/C,GAAuB,iBAAZ8H,EAAsB,CAC/B,MAAMjd,EAAMiX,EAAc3Y,KAAKwM,KAAMrB,EAAMwT,GAC3C,GAA2B,kBAAb,OAAHjd,QAAG,IAAHA,OAAG,EAAHA,EAAK9D,QAAqB,OACrC,OAAO8gB,EAAe1e,KAAKwM,KAAM2L,EAAGzW,EACtC,CAEA,GAAgC,kBAAb,OAARid,QAAQ,IAARA,OAAQ,EAARA,EAAU/gB,QAArB,CAEA,GADK+gB,EAAStS,UAAUoP,EAAczb,KAAKwM,KAAMmS,GAC7C9H,KAAO,EAAAlG,EAAA0H,aAAY7M,GAAM,CAC3B,MAAM,OAAC5N,GAAU+gB,GACX,SAACvK,GAAY5H,KAAK5L,KAClBge,EAAQhhB,EAAOwW,GAErB,OADIwK,IAAO7T,GAAS,EAAA4F,EAAAkO,YAAWrS,KAAK5L,KAAKgL,YAAab,EAAQ6T,IACvD,IAAI/S,EAAU,CAACjO,SAAQwW,WAAUjJ,OAAMJ,UAChD,CACA,OAAO2T,EAAe1e,KAAKwM,KAAM2L,EAAGwG,EATY,CAUlD,CApNAngB,EAAAA,UAAAqN,EAqCArN,EAAAA,cAAAid,EA8FAjd,EAAAA,WAAA,SAEE2M,EACAJ,EACAS,G,MAEAA,GAAM,EAAAmF,EAAAkO,YAAWrS,KAAK5L,KAAKgL,YAAab,EAAQS,GAChD,MAAMsT,EAAY3T,EAAK8J,KAAKzJ,GAC5B,GAAIsT,EAAW,OAAOA,EAEtB,IAAI9B,EAAOuB,EAAQve,KAAKwM,KAAMrB,EAAMK,GACpC,QAAatN,IAAT8e,EAAoB,CACtB,MAAMpf,EAAuB,QAAdQ,EAAA+M,EAAKiQ,iBAAS,IAAAhd,OAAA,EAAAA,EAAGoN,IAC1B,SAAC4I,GAAY5H,KAAK5L,KACpBhD,IAAQof,EAAO,IAAInR,EAAU,CAACjO,SAAQwW,WAAUjJ,OAAMJ,WAC5D,CAEA,YAAa7M,IAAT8e,EACI7R,EAAK8J,KAAKzJ,GAAOyS,EAAgBje,KAAKwM,KAAMwQ,QADpD,CAEF,EAQAxe,EAAAA,mBAAAye,EAuBAze,EAAAA,cAAAma,EAiCA,MAAMoG,EAAuB,IAAI9V,IAAI,CACnC,aACA,oBACA,OACA,eACA,gBAGF,SAASyV,EAEPM,EAAuBvgB,GACU,IAAjC,OAACsM,EAAM,OAAEnN,EAAM,KAAEuN,GAAgB1M,E,MAEjC,GAAgC,OAAV,QAAlBL,EAAA4gB,EAAU1X,gBAAQ,IAAAlJ,OAAA,EAAAA,EAAG,IAAY,OACrC,IAAK,MAAM6gB,KAAQD,EAAU1X,SAASO,MAAM,GAAGiT,MAAM,KAAM,CACzD,GAAsB,mBAAXld,EAAsB,OACjC,MAAMshB,EAAathB,GAAO,EAAAwC,EAAA+e,kBAAiBF,IAC3C,QAAmB/gB,IAAfghB,EAA0B,OAC9BthB,EAASshB,EAET,MAAMN,EAA0B,kBAAXhhB,GAAuBA,EAAO4O,KAAK5L,KAAKwT,WACxD2K,EAAqBK,IAAIH,IAASL,IACrC7T,GAAS,EAAA4F,EAAAkO,YAAWrS,KAAK5L,KAAKgL,YAAab,EAAQ6T,GAEvD,CACA,IAAI3T,EACJ,GAAqB,kBAAVrN,GAAuBA,EAAOkN,QAAS,EAAA1K,EAAAif,sBAAqBzhB,EAAQ4O,KAAK5N,OAAQ,CAC1F,MAAMkM,GAAO,EAAA6F,EAAAkO,YAAWrS,KAAK5L,KAAKgL,YAAab,EAAQnN,EAAOkN,MAC9DG,EAAM0N,EAAc3Y,KAAKwM,KAAMrB,EAAML,EACvC,CAGA,MAAM,SAACsJ,GAAY5H,KAAK5L,KAExB,OADAqK,EAAMA,GAAO,IAAIY,EAAU,CAACjO,SAAQwW,WAAUjJ,OAAMJ,WAChDE,EAAIrN,SAAWqN,EAAIE,KAAKvN,OAAeqN,OAA3C,CAEF,C,gGCjUA,MAIMqU,EAAyB,IAAIrW,IAJhB,CAAC,SAAU,SAAU,UAAW,UAAW,OAAQ,SAAU,UAMhFzK,EAAAA,WAAA,SAA2B+gB,GACzB,MAAmB,iBAALA,GAAiBD,EAAUF,IAAIG,EAC/C,EAyBA/gB,EAAAA,SAAA,WACE,MAAMghB,EAAsE,CAC1EC,OAAQ,CAAC/gB,KAAM,SAAUZ,MAAO,IAChC4hB,OAAQ,CAAChhB,KAAM,SAAUZ,MAAO,IAChC6hB,MAAO,CAACjhB,KAAM,QAASZ,MAAO,IAC9B8hB,OAAQ,CAAClhB,KAAM,SAAUZ,MAAO,KAElC,MAAO,CACLe,MAAO,IAAI2gB,EAAQK,SAAS,EAAMC,SAAS,EAAMC,MAAM,GACvDjiB,MAAO,CAAC,CAACA,MAAO,IAAK0hB,EAAOC,OAAQD,EAAOE,OAAQF,EAAOG,MAAOH,EAAOI,QACxExD,KAAM,CAACte,MAAO,IACd8b,IAAK,CAAC,EACNrD,SAAU,CAAC,EAEf,C,4ICjDA,MAAA5U,EAAAxB,EAAA,OAeA,MAAM6f,UAAmBrY,MAEvBzI,WAAAA,CAAYkE,GACV4M,MAAM,uBAAuB5M,iBAC7BoJ,KAAKqD,MAAQzM,EAAKyM,KACpB,EAwBF,IAAYoQ,GAAZ,SAAYA,GACVA,EAAAA,EAAA,qBACAA,EAAAA,EAAA,wBACD,CAHD,CAAYA,IAAczhB,EAAAA,eAAdyhB,EAAc,KASbzhB,EAAAA,SAAW,CACtB8E,MAAO,IAAI3B,EAAAkH,KAAK,SAChBJ,IAAK,IAAI9G,EAAAkH,KAAK,OACdsE,IAAK,IAAIxL,EAAAkH,KAAK,QAGhB,MAAaqX,EAKXhhB,WAAAA,GAAiD,IAArC,SAACwW,EAAQ,OAAEyK,GAAM5d,UAAApD,OAAA,QAAAjB,IAAAqE,UAAA,GAAAA,UAAA,GAAkB,CAAC,EAJ7B,KAAA6d,OAA2C,CAAC,EAK7D5T,KAAK6T,UAAY3K,EACjBlJ,KAAK8T,QAAUH,CACjB,CAEAI,MAAAA,CAAOC,GACL,OAAOA,aAAwB7e,EAAAkH,KAAO2X,EAAehU,KAAKpJ,KAAKod,EACjE,CAEApd,IAAAA,CAAKqd,GACH,OAAO,IAAI9e,EAAAkH,KAAK2D,KAAKkU,SAASD,GAChC,CAEUC,QAAAA,CAASD,GAEjB,MAAO,GAAGA,KADCjU,KAAK4T,OAAOK,IAAWjU,KAAKmU,WAAWF,IAC5BG,SACxB,CAEQD,UAAAA,CAAWF,G,QACjB,IAA2B,QAAvB9N,EAAY,QAAZvU,EAAAoO,KAAK8T,eAAO,IAAAliB,OAAA,EAAAA,EAAEiiB,iBAAS,IAAA1N,OAAA,EAAAA,EAAEyM,IAAIqB,KAAYjU,KAAK6T,YAAc7T,KAAK6T,UAAUjB,IAAIqB,GACjF,MAAM,IAAI9Y,MAAM,oBAAoB8Y,mCAEtC,OAAQjU,KAAK4T,OAAOK,GAAU,CAACA,SAAQG,MAAO,EAChD,EA5BFpiB,EAAAA,MAAA0hB,EAoCA,MAAaW,UAAuBlf,EAAAkH,KAKlC3J,WAAAA,CAAYuhB,EAAgBK,GAC1B9Q,MAAM8Q,GACNtU,KAAKiU,OAASA,CAChB,CAEAM,QAAAA,CAASlR,EAAgBpR,GAAkC,IAAhC,SAACuiB,EAAQ,UAAEC,GAAqBxiB,EACzD+N,KAAKqD,MAAQA,EACbrD,KAAK0U,UAAYvf,EAAAb,CAAC,IAAI,IAAIa,EAAAkH,KAAKmY,MAAaC,IAC9C,EAbFziB,EAAAA,eAAAqiB,EAoBA,MAAMM,EAAOxf,EAAAb,CAAC,KAEdtC,EAAAA,WAAA,cAAgC0hB,EAK9BhhB,WAAAA,CAAY0B,GACVoP,MAAMpP,GALW,KAAAod,QAAuB,CAAC,EAMzCxR,KAAK4U,OAASxgB,EAAK4U,MACnBhJ,KAAK5L,KAAO,IAAIA,EAAMygB,GAAIzgB,EAAK2U,MAAQ4L,EAAOxf,EAAAwK,IAChD,CAEAkE,GAAAA,GACE,OAAO7D,KAAK4U,MACd,CAEAhe,IAAAA,CAAKqd,GACH,OAAO,IAAII,EAAeJ,EAAQjU,KAAKkU,SAASD,GAClD,CAEA5Q,KAAAA,CAAM2Q,EAAuC3Q,G,MAC3C,QAAkB3R,IAAd2R,EAAMrE,IAAmB,MAAM,IAAI7D,MAAM,wCAC7C,MAAMvE,EAAOoJ,KAAK+T,OAAOC,IACnB,OAACC,GAAUrd,EACXke,EAAoB,QAATljB,EAAAyR,EAAM5P,WAAG,IAAA7B,EAAAA,EAAIyR,EAAMrE,IACpC,IAAI+V,EAAK/U,KAAKwR,QAAQyC,GACtB,GAAIc,EAAI,CACN,MAAMC,EAAQD,EAAGlR,IAAIiR,GACrB,GAAIE,EAAO,OAAOA,CACpB,MACED,EAAK/U,KAAKwR,QAAQyC,GAAU,IAAIpL,IAElCkM,EAAGjG,IAAIgG,EAAUle,GAEjB,MAAMwE,EAAI4E,KAAK4U,OAAOX,KAAYjU,KAAK4U,OAAOX,GAAU,IAClDQ,EAAYrZ,EAAEzI,OAGpB,OAFAyI,EAAEqZ,GAAapR,EAAMrE,IACrBpI,EAAK2d,SAASlR,EAAO,CAACmR,SAAUP,EAAQQ,cACjC7d,CACT,CAEAqe,QAAAA,CAAShB,EAAgBiB,GACvB,MAAMH,EAAK/U,KAAKwR,QAAQyC,GACxB,GAAKc,EACL,OAAOA,EAAGlR,IAAIqR,EAChB,CAEA/D,SAAAA,CAAUL,GAAoE,IAAnDqE,EAAApf,UAAApD,OAAA,QAAAjB,IAAAqE,UAAA,GAAAA,UAAA,GAAuCiK,KAAKwR,QACrE,OAAOxR,KAAKoV,cAAcD,EAASve,IACjC,QAAuBlF,IAAnBkF,EAAK8d,UAAyB,MAAM,IAAIvZ,MAAM,kBAAkBvE,mBACpE,OAAOzB,EAAAb,CAAC,GAAGwc,IAAYla,EAAK8d,aAEhC,CAEAW,SAAAA,GAGmD,IAFjDF,EAAApf,UAAApD,OAAA,QAAAjB,IAAAqE,UAAA,GAAAA,UAAA,GAAuCiK,KAAKwR,QAC5C8D,EAA4Bvf,UAAApD,OAAA,EAAAoD,UAAA,QAAArE,EAC5B6jB,EAAiDxf,UAAApD,OAAA,EAAAoD,UAAA,QAAArE,EAEjD,OAAOsO,KAAKoV,cACVD,EACCve,IACC,QAAmBlF,IAAfkF,EAAKyM,MAAqB,MAAM,IAAIlI,MAAM,kBAAkBvE,mBAChE,OAAOA,EAAKyM,MAAM9N,MAEpB+f,EACAC,EAEJ,CAEQH,aAAAA,CACND,EACAK,GAEiD,IADjDF,EAAAvf,UAAApD,OAAA,QAAAjB,IAAAqE,UAAA,GAAAA,UAAA,GAA8B,CAAC,EAC/Bwf,EAAiDxf,UAAApD,OAAA,EAAAoD,UAAA,QAAArE,EAE7C6D,EAAaJ,EAAAwK,IACjB,IAAK,MAAMsU,KAAUkB,EAAQ,CAC3B,MAAMJ,EAAKI,EAAOlB,GAClB,IAAKc,EAAI,SACT,MAAMU,EAAWH,EAAWrB,GAAUqB,EAAWrB,IAAW,IAAIpL,IAChEkM,EAAG9f,QAAS2B,IACV,GAAI6e,EAAQ7C,IAAIhc,GAAO,OACvB6e,EAAQ3G,IAAIlY,EAAM6c,EAAeiC,SACjC,IAAIzd,EAAIud,EAAU5e,GAClB,GAAIqB,EAAG,CACL,MAAM7C,EAAM4K,KAAK5L,KAAK0U,IAAM9W,EAAA2jB,SAAShV,IAAM3O,EAAA2jB,SAAS7e,MACpDvB,EAAOJ,EAAAb,CAAC,GAAGiB,IAAOH,KAAOwB,OAAUqB,KAAK+H,KAAK5L,KAAKygB,IACpD,KAAO,MAAK5c,EAAW,OAAPsd,QAAO,IAAPA,OAAO,EAAPA,EAAU3e,IAGxB,MAAM,IAAI4c,EAAW5c,GAFrBrB,EAAOJ,EAAAb,CAAC,GAAGiB,IAAO0C,IAAI+H,KAAK5L,KAAKygB,IAGlC,CACAY,EAAQ3G,IAAIlY,EAAM6c,EAAemC,YAErC,CACA,OAAOrgB,CACT,E,4OCpNF,MAAAJ,EAAAxB,EAAA,OACAkiB,EAAAliB,EAAA,OAEA,IAAAmiB,EAAAniB,EAAA,OAAQP,OAAAA,eAAAA,EAAAA,IAAAA,CAAAwQ,YAAA,EAAAC,IAAA,kBAAAiS,EAAAxhB,CAAC,IAAElB,OAAAA,eAAAA,EAAAA,MAAAA,CAAAwQ,YAAA,EAAAC,IAAA,kBAAAiS,EAAAzc,GAAG,IAAEjG,OAAAA,eAAAA,EAAAA,YAAAA,CAAAwQ,YAAA,EAAAC,IAAA,kBAAAiS,EAAAC,SAAS,IAAE3iB,OAAAA,eAAAA,EAAAA,MAAAA,CAAAwQ,YAAA,EAAAC,IAAA,kBAAAiS,EAAAnW,GAAG,IAAEvM,OAAAA,eAAAA,EAAAA,cAAAA,CAAAwQ,YAAA,EAAAC,IAAA,kBAAAiS,EAAAvhB,WAAW,IAAEnB,OAAAA,eAAAA,EAAAA,YAAAA,CAAAwQ,YAAA,EAAAC,IAAA,kBAAAiS,EAAAlhB,SAAS,IAAExB,OAAAA,eAAAA,EAAAA,aAAAA,CAAAwQ,YAAA,EAAAC,IAAA,kBAAAiS,EAAAjT,UAAU,IAAEzP,OAAAA,eAAAA,EAAAA,OAAAA,CAAAwQ,YAAA,EAAAC,IAAA,kBAAAiS,EAAAzZ,IAAI,IACxE,IAAA2Z,EAAAriB,EAAA,OAAQP,OAAAA,eAAAA,EAAAA,QAAAA,CAAAwQ,YAAA,EAAAC,IAAA,kBAAAmS,EAAAtC,KAAK,IAActgB,OAAAA,eAAAA,EAAAA,aAAAA,CAAAwQ,YAAA,EAAAC,IAAA,kBAAAmS,EAAA/M,UAAU,IAAE7V,OAAAA,eAAAA,EAAAA,iBAAAA,CAAAwQ,YAAA,EAAAC,IAAA,kBAAAmS,EAAA3B,cAAc,IAAkBjhB,OAAAA,eAAAA,EAAAA,WAAAA,CAAAwQ,YAAA,EAAAC,IAAA,kBAAAmS,EAAAL,QAAQ,IAQlE3jB,EAAAA,UAAY,CACvBwL,GAAI,IAAIrI,EAAA8gB,MAAM,KACdvY,IAAK,IAAIvI,EAAA8gB,MAAM,MACftY,GAAI,IAAIxI,EAAA8gB,MAAM,KACd3Y,IAAK,IAAInI,EAAA8gB,MAAM,MACfC,GAAI,IAAI/gB,EAAA8gB,MAAM,OACdE,IAAK,IAAIhhB,EAAA8gB,MAAM,OACfG,IAAK,IAAIjhB,EAAA8gB,MAAM,KACfI,GAAI,IAAIlhB,EAAA8gB,MAAM,MACdK,IAAK,IAAInhB,EAAA8gB,MAAM,MACfM,IAAK,IAAIphB,EAAA8gB,MAAM,MAGjB,MAAeO,EAGbC,aAAAA,GACE,OAAOzW,IACT,CAEA0W,aAAAA,CAAc9C,EAAmB+C,GAC/B,OAAO3W,IACT,EAOF,MAAM4W,UAAYJ,EAChB9jB,WAAAA,CACmBmkB,EACAjgB,EACTkgB,GAERtT,QAJiB,KAAAqT,QAAAA,EACA,KAAAjgB,KAAAA,EACT,KAAAkgB,IAAAA,CAGV,CAEAC,MAAAA,CAAM9kB,GAAqB,IAApB,IAAC6W,EAAG,GAAE+L,GAAc5iB,EACzB,MAAM4kB,EAAU/N,EAAM+M,EAAAF,SAAShV,IAAMX,KAAK6W,QACpCC,OAAmBplB,IAAbsO,KAAK8W,IAAoB,GAAK,MAAM9W,KAAK8W,MACrD,MAAO,GAAGD,KAAW7W,KAAKpJ,OAAOkgB,KAASjC,CAC5C,CAEA6B,aAAAA,CAAcM,EAAkBC,GAC9B,GAAKD,EAAMhX,KAAKpJ,KAAKyC,KAErB,OADI2G,KAAK8W,MAAK9W,KAAK8W,IAAMI,EAAalX,KAAK8W,IAAKE,EAAOC,IAChDjX,IACT,CAEA,SAAIgX,GACF,OAAOhX,KAAK8W,eAAe3hB,EAAAgiB,YAAcnX,KAAK8W,IAAIE,MAAQ,CAAC,CAC7D,EAGF,MAAMI,UAAeZ,EACnB9jB,WAAAA,CACW2kB,EACFP,EACUQ,GAEjB9T,QAJS,KAAA6T,IAAAA,EACF,KAAAP,IAAAA,EACU,KAAAQ,YAAAA,CAGnB,CAEAP,MAAAA,CAAMtb,GAAgB,IAAf,GAACoZ,GAAcpZ,EACpB,MAAO,GAAGuE,KAAKqX,SAASrX,KAAK8W,OAASjC,CACxC,CAEA6B,aAAAA,CAAcM,EAAkBC,GAC9B,KAAIjX,KAAKqX,eAAeliB,EAAAkH,OAAS2a,EAAMhX,KAAKqX,IAAIhe,MAAS2G,KAAKsX,YAE9D,OADAtX,KAAK8W,IAAMI,EAAalX,KAAK8W,IAAKE,EAAOC,GAClCjX,IACT,CAEA,SAAIgX,GAEF,OAAOO,EADOvX,KAAKqX,eAAeliB,EAAAkH,KAAO,CAAC,EAAI,IAAI2D,KAAKqX,IAAIL,OAChChX,KAAK8W,IAClC,EAGF,MAAMU,UAAiBJ,EACrB1kB,WAAAA,CACE2kB,EACiBhH,EACjByG,EACAQ,GAEA9T,MAAM6T,EAAKP,EAAKQ,GAJC,KAAAjH,GAAAA,CAKnB,CAEA0G,MAAAA,CAAMna,GAAgB,IAAf,GAACiY,GAAcjY,EACpB,MAAO,GAAGoD,KAAKqX,OAAOrX,KAAKqQ,OAAOrQ,KAAK8W,OAASjC,CAClD,EAGF,MAAM4C,UAAcjB,EAElB9jB,WAAAA,CAAqBglB,GACnBlU,QADmB,KAAAkU,MAAAA,EADZ,KAAAV,MAAmB,CAAC,CAG7B,CAEAD,MAAAA,CAAMY,GAAgB,IAAf,GAAC9C,GAAc8C,EACpB,MAAO,GAAG3X,KAAK0X,SAAW7C,CAC5B,EAGF,MAAM+C,UAAcpB,EAElB9jB,WAAAA,CAAqBglB,GACnBlU,QADmB,KAAAkU,MAAAA,EADZ,KAAAV,MAAmB,CAAC,CAG7B,CAEAD,MAAAA,CAAMc,GAAgB,IAAf,GAAChD,GAAcgD,EAEpB,MAAO,QADO7X,KAAK0X,MAAQ,IAAI1X,KAAK0X,QAAU,MACpB7C,CAC5B,EAGF,MAAMiD,UAActB,EAClB9jB,WAAAA,CAAqB6F,GACnBiL,QADmB,KAAAjL,MAAAA,CAErB,CAEAwe,MAAAA,CAAMgB,GAAgB,IAAf,GAAClD,GAAckD,EACpB,MAAO,SAAS/X,KAAKzH,SAAWsc,CAClC,CAEA,SAAImC,GACF,OAAOhX,KAAKzH,MAAMye,KACpB,EAGF,MAAMgB,UAAgBxB,EACpB9jB,WAAAA,CAAoB6C,GAClBiO,QADkB,KAAAjO,KAAAA,CAEpB,CAEAwhB,MAAAA,CAAMkB,GAAgB,IAAf,GAACpD,GAAcoD,EACpB,MAAO,GAAGjY,KAAKzK,QAAUsf,CAC3B,CAEA4B,aAAAA,GACE,MAAO,GAAGzW,KAAKzK,OAASyK,UAAOtO,CACjC,CAEAglB,aAAAA,CAAcM,EAAkBC,GAE9B,OADAjX,KAAKzK,KAAO2hB,EAAalX,KAAKzK,KAAMyhB,EAAOC,GACpCjX,IACT,CAEA,SAAIgX,GACF,OAAOhX,KAAKzK,gBAAgBJ,EAAAgiB,YAAcnX,KAAKzK,KAAKyhB,MAAQ,CAAC,CAC/D,EAGF,MAAekB,UAAmB1B,EAChC9jB,WAAAA,GAA4C,IAAvBylB,EAAApiB,UAAApD,OAAA,QAAAjB,IAAAqE,UAAA,GAAAA,UAAA,GAAqB,GACxCyN,QADmB,KAAA2U,MAAAA,CAErB,CAEApB,MAAAA,CAAO3iB,GACL,OAAO4L,KAAKmY,MAAMtK,OAAO,CAACtY,EAAM6iB,IAAM7iB,EAAO6iB,EAAErB,OAAO3iB,GAAO,GAC/D,CAEAqiB,aAAAA,GACE,MAAM,MAAC0B,GAASnY,KAChB,IAAIpN,EAAIulB,EAAMxlB,OACd,KAAOC,KAAK,CACV,MAAMwlB,EAAID,EAAMvlB,GAAG6jB,gBACf3jB,MAAMC,QAAQqlB,GAAID,EAAM5K,OAAO3a,EAAG,KAAMwlB,GACnCA,EAAGD,EAAMvlB,GAAKwlB,EAClBD,EAAM5K,OAAO3a,EAAG,EACvB,CACA,OAAOulB,EAAMxlB,OAAS,EAAIqN,UAAOtO,CACnC,CAEAglB,aAAAA,CAAcM,EAAkBC,GAC9B,MAAM,MAACkB,GAASnY,KAChB,IAAIpN,EAAIulB,EAAMxlB,OACd,KAAOC,KAAK,CAEV,MAAMwlB,EAAID,EAAMvlB,GACZwlB,EAAE1B,cAAcM,EAAOC,KAC3BoB,EAAcrB,EAAOoB,EAAEpB,OACvBmB,EAAM5K,OAAO3a,EAAG,GAClB,CACA,OAAOulB,EAAMxlB,OAAS,EAAIqN,UAAOtO,CACnC,CAEA,SAAIslB,GACF,OAAOhX,KAAKmY,MAAMtK,OAAO,CAACmJ,EAAkBoB,IAAME,EAAStB,EAAOoB,EAAEpB,OAAQ,CAAC,EAC/E,EAOF,MAAeuB,UAAkBL,EAC/BnB,MAAAA,CAAO3iB,GACL,MAAO,IAAMA,EAAKygB,GAAKrR,MAAMuT,OAAO3iB,GAAQ,IAAMA,EAAKygB,EACzD,EAGF,MAAM2D,UAAaN,GAEnB,MAAMO,UAAaF,GACDE,EAAAC,KAAO,OAGzB,MAAMC,UAAWJ,EAGf7lB,WAAAA,CACU+B,EACR0jB,GAEA3U,MAAM2U,GAHE,KAAA1jB,UAAAA,CAIV,CAEAsiB,MAAAA,CAAO3iB,GACL,IAAImB,EAAO,MAAMyK,KAAKvL,aAAe+O,MAAMuT,OAAO3iB,GAElD,OADI4L,KAAK4Y,OAAMrjB,GAAQ,QAAUyK,KAAK4Y,KAAK7B,OAAO3iB,IAC3CmB,CACT,CAEAkhB,aAAAA,GACEjT,MAAMiT,gBACN,MAAMoC,EAAO7Y,KAAKvL,UAClB,IAAa,IAATokB,EAAe,OAAO7Y,KAAKmY,MAC/B,IAAIpX,EAAIf,KAAK4Y,KACb,GAAI7X,EAAG,CACL,MAAM+X,EAAK/X,EAAE0V,gBACb1V,EAAIf,KAAK4Y,KAAO9lB,MAAMC,QAAQ+lB,GAAM,IAAIL,EAAKK,GAAOA,CACtD,CACA,OAAI/X,GACW,IAAT8X,EAAuB9X,aAAa4X,EAAK5X,EAAIA,EAAEoX,MAC/CnY,KAAKmY,MAAMxlB,OAAeqN,KACvB,IAAI2Y,EAAGI,EAAIF,GAAO9X,aAAa4X,EAAK,CAAC5X,GAAKA,EAAEoX,QAExC,IAATU,GAAmB7Y,KAAKmY,MAAMxlB,OAC3BqN,UADP,CAEF,CAEA0W,aAAAA,CAAcM,EAAkBC,G,MAE9B,GADAjX,KAAK4Y,KAAgB,QAAThnB,EAAAoO,KAAK4Y,YAAI,IAAAhnB,OAAA,EAAAA,EAAE8kB,cAAcM,EAAOC,GACtCzT,MAAMkT,cAAcM,EAAOC,IAAcjX,KAAK4Y,KAEpD,OADA5Y,KAAKvL,UAAYyiB,EAAalX,KAAKvL,UAAWuiB,EAAOC,GAC9CjX,IACT,CAEA,SAAIgX,GACF,MAAMA,EAAQxT,MAAMwT,MAGpB,OAFAO,EAAaP,EAAOhX,KAAKvL,WACrBuL,KAAK4Y,MAAMN,EAAStB,EAAOhX,KAAK4Y,KAAK5B,OAClCA,CACT,EA7CgB2B,EAAAD,KAAO,KAoDzB,MAAeM,UAAYT,GACTS,EAAAN,KAAO,MAGzB,MAAMO,UAAgBD,EACpBtmB,WAAAA,CAAoBwmB,GAClB1V,QADkB,KAAA0V,UAAAA,CAEpB,CAEAnC,MAAAA,CAAO3iB,GACL,MAAO,OAAO4L,KAAKkZ,aAAe1V,MAAMuT,OAAO3iB,EACjD,CAEAsiB,aAAAA,CAAcM,EAAkBC,GAC9B,GAAKzT,MAAMkT,cAAcM,EAAOC,GAEhC,OADAjX,KAAKkZ,UAAYhC,EAAalX,KAAKkZ,UAAWlC,EAAOC,GAC9CjX,IACT,CAEA,SAAIgX,GACF,OAAOsB,EAAS9U,MAAMwT,MAAOhX,KAAKkZ,UAAUlC,MAC9C,EAGF,MAAMmC,UAAiBH,EACrBtmB,WAAAA,CACmBmkB,EACAjgB,EACAwiB,EACAC,GAEjB7V,QALiB,KAAAqT,QAAAA,EACA,KAAAjgB,KAAAA,EACA,KAAAwiB,KAAAA,EACA,KAAAC,GAAAA,CAGnB,CAEAtC,MAAAA,CAAO3iB,GACL,MAAMyiB,EAAUziB,EAAK0U,IAAM+M,EAAAF,SAAShV,IAAMX,KAAK6W,SACzC,KAACjgB,EAAI,KAAEwiB,EAAI,GAAEC,GAAMrZ,KACzB,MAAO,OAAO6W,KAAWjgB,KAAQwiB,MAASxiB,KAAQyiB,MAAOziB,OAAY4M,MAAMuT,OAAO3iB,EACpF,CAEA,SAAI4iB,GACF,MAAMA,EAAQO,EAAa/T,MAAMwT,MAAOhX,KAAKoZ,MAC7C,OAAO7B,EAAaP,EAAOhX,KAAKqZ,GAClC,EAGF,MAAMC,UAAgBN,EACpBtmB,WAAAA,CACmB6mB,EACA1C,EACAjgB,EACT4iB,GAERhW,QALiB,KAAA+V,KAAAA,EACA,KAAA1C,QAAAA,EACA,KAAAjgB,KAAAA,EACT,KAAA4iB,SAAAA,CAGV,CAEAzC,MAAAA,CAAO3iB,GACL,MAAO,OAAO4L,KAAK6W,WAAW7W,KAAKpJ,QAAQoJ,KAAKuZ,QAAQvZ,KAAKwZ,YAAchW,MAAMuT,OAAO3iB,EAC1F,CAEAsiB,aAAAA,CAAcM,EAAkBC,GAC9B,GAAKzT,MAAMkT,cAAcM,EAAOC,GAEhC,OADAjX,KAAKwZ,SAAWtC,EAAalX,KAAKwZ,SAAUxC,EAAOC,GAC5CjX,IACT,CAEA,SAAIgX,GACF,OAAOsB,EAAS9U,MAAMwT,MAAOhX,KAAKwZ,SAASxC,MAC7C,EAGF,MAAMyC,UAAalB,EAEjB7lB,WAAAA,CACSkE,EACA8iB,EACAzW,GAEPO,QAJO,KAAA5M,KAAAA,EACA,KAAA8iB,KAAAA,EACA,KAAAzW,MAAAA,CAGT,CAEA8T,MAAAA,CAAO3iB,GAEL,MAAO,GADQ4L,KAAKiD,MAAQ,SAAW,cACXjD,KAAKpJ,QAAQoJ,KAAK0Z,QAAUlW,MAAMuT,OAAO3iB,EACvE,EAZgBqlB,EAAAf,KAAO,OAezB,MAAMiB,UAAezB,EAGnBnB,MAAAA,CAAO3iB,GACL,MAAO,UAAYoP,MAAMuT,OAAO3iB,EAClC,EAJgBulB,EAAAjB,KAAO,SAOzB,MAAMkB,UAAYrB,EAIhBxB,MAAAA,CAAO3iB,GACL,IAAImB,EAAO,MAAQiO,MAAMuT,OAAO3iB,GAGhC,OAFI4L,KAAK6Z,QAAOtkB,GAAQyK,KAAK6Z,MAAM9C,OAAO3iB,IACtC4L,KAAK8Z,UAASvkB,GAAQyK,KAAK8Z,QAAQ/C,OAAO3iB,IACvCmB,CACT,CAEAkhB,aAAAA,G,QAIE,OAHAjT,MAAMiT,gBACI,QAAV7kB,EAAAoO,KAAK6Z,aAAK,IAAAjoB,GAAAA,EAAE6kB,gBACA,QAAZtQ,EAAAnG,KAAK8Z,eAAO,IAAA3T,GAAAA,EAAEsQ,gBACPzW,IACT,CAEA0W,aAAAA,CAAcM,EAAkBC,G,QAI9B,OAHAzT,MAAMkT,cAAcM,EAAOC,GACjB,QAAVrlB,EAAAoO,KAAK6Z,aAAK,IAAAjoB,GAAAA,EAAE8kB,cAAcM,EAAOC,GACrB,QAAZ9Q,EAAAnG,KAAK8Z,eAAO,IAAA3T,GAAAA,EAAEuQ,cAAcM,EAAOC,GAC5BjX,IACT,CAEA,SAAIgX,GACF,MAAMA,EAAQxT,MAAMwT,MAGpB,OAFIhX,KAAK6Z,OAAOvB,EAAStB,EAAOhX,KAAK6Z,MAAM7C,OACvChX,KAAK8Z,SAASxB,EAAStB,EAAOhX,KAAK8Z,QAAQ9C,OACxCA,CACT,EAOF,MAAM+C,UAAcxB,EAElB7lB,WAAAA,CAAqB6F,GACnBiL,QADmB,KAAAjL,MAAAA,CAErB,CAEAwe,MAAAA,CAAO3iB,GACL,MAAO,SAAS4L,KAAKzH,SAAWiL,MAAMuT,OAAO3iB,EAC/C,EAPgB2lB,EAAArB,KAAO,QAUzB,MAAMsB,UAAgBzB,EAEpBxB,MAAAA,CAAO3iB,GACL,MAAO,UAAYoP,MAAMuT,OAAO3iB,EAClC,EAHgB4lB,EAAAtB,KAAO,UAyWzB,SAASJ,EAAStB,EAAkBoC,GAClC,IAAK,MAAMhB,KAAKgB,EAAMpC,EAAMoB,IAAMpB,EAAMoB,IAAM,IAAMgB,EAAKhB,IAAM,GAC/D,OAAOpB,CACT,CAEA,SAASO,EAAaP,EAAkBoC,GACtC,OAAOA,aAAgBjkB,EAAAgiB,YAAcmB,EAAStB,EAAOoC,EAAKpC,OAASA,CACrE,CAGA,SAASE,EAAa+C,EAAgBjD,EAAkBC,GACtD,OAAIgD,aAAgB9kB,EAAAkH,KAAa6d,EAAYD,IAkBxBlZ,EAjBJkZ,aAmBA9kB,EAAA8gB,OACblV,EAAEoZ,OAAO5oB,KACN0G,GAAMA,aAAa9C,EAAAkH,MAAyB,IAAjB2a,EAAM/e,EAAEoB,WAAmC3H,IAArBulB,EAAUhf,EAAEoB,MApB7D,IAAIlE,EAAA8gB,MACTgE,EAAKE,OAAOtM,OAAO,CAAC9Y,EAAmBkD,KACjCA,aAAa9C,EAAAkH,OAAMpE,EAAIiiB,EAAYjiB,IACnCA,aAAa9C,EAAA8gB,MAAOlhB,EAAMgE,QAAQd,EAAEkiB,QACnCplB,EAAMgE,KAAKd,GACTlD,GACN,KAP0BklB,EAiB/B,IAAqBlZ,EAPrB,SAASmZ,EAAY9B,GACnB,MAAMngB,EAAIgf,EAAUmB,EAAE/e,KACtB,YAAU3H,IAANuG,GAAoC,IAAjB+e,EAAMoB,EAAE/e,KAAmB+e,UAC3CpB,EAAMoB,EAAE/e,KACRpB,EACT,CAUF,CAEA,SAASogB,EAAcrB,EAAkBoC,GACvC,IAAK,MAAMhB,KAAKgB,EAAMpC,EAAMoB,IAAMpB,EAAMoB,IAAM,IAAMgB,EAAKhB,IAAM,EACjE,CAGA,SAAgBW,EAAIhG,GAClB,MAAmB,kBAALA,GAA8B,iBAALA,GAAuB,OAANA,GAAcA,EAAI5d,EAAAb,CAAC,IAAI8lB,EAAIrH,IACrF,CAtXA/gB,EAAAA,QAAA,MASEU,WAAAA,CAAY2nB,GAA+C,IAAzBjmB,EAAA2B,UAAApD,OAAA,QAAAjB,IAAAqE,UAAA,GAAAA,UAAA,GAAuB,CAAC,EANjD,KAAAyb,QAA0B,CAAC,EAEnB,KAAA8I,aAAyB,GACzB,KAAA3D,WAAwB,CAAC,EAIxC3W,KAAK5L,KAAO,IAAIA,EAAMygB,GAAIzgB,EAAK2U,MAAQ,KAAO,IAC9C/I,KAAKua,UAAYF,EACjBra,KAAK4U,OAAS,IAAIiB,EAAAnC,MAAM,CAACC,OAAQ0G,IACjCra,KAAKwa,OAAS,CAAC,IAAIhC,EACrB,CAEAllB,QAAAA,GACE,OAAO0M,KAAKya,MAAM1D,OAAO/W,KAAK5L,KAChC,CAGAwC,IAAAA,CAAKqd,GACH,OAAOjU,KAAK4U,OAAOhe,KAAKqd,EAC1B,CAGAnD,SAAAA,CAAUmD,GACR,OAAOjU,KAAKua,UAAU3jB,KAAKqd,EAC7B,CAGAlV,UAAAA,CAAW2b,EAAuCrX,GAChD,MAAMzM,EAAOoJ,KAAKua,UAAUlX,MAAMqX,EAAcrX,GAGhD,OAFWrD,KAAKwR,QAAQ5a,EAAKqd,UAAYjU,KAAKwR,QAAQ5a,EAAKqd,QAAU,IAAIxX,MACtEuU,IAAIpa,GACAA,CACT,CAEA+jB,aAAAA,CAAc1G,EAAgBiB,GAC5B,OAAOlV,KAAKua,UAAUtF,SAAShB,EAAQiB,EACzC,CAIA/D,SAAAA,CAAUL,GACR,OAAO9Q,KAAKua,UAAUpJ,UAAUL,EAAW9Q,KAAKwR,QAClD,CAEA6D,SAAAA,GACE,OAAOrV,KAAKua,UAAUlF,UAAUrV,KAAKwR,QACvC,CAEQoJ,IAAAA,CACN/D,EACA7C,EACA8C,EACA+D,GAEA,MAAMjkB,EAAOoJ,KAAK4U,OAAOb,OAAOC,GAGhC,YAFYtiB,IAARolB,GAAqB+D,IAAU7a,KAAK2W,WAAW/f,EAAKyC,KAAOyd,GAC/D9W,KAAK8a,UAAU,IAAIlE,EAAIC,EAASjgB,EAAMkgB,IAC/BlgB,CACT,CAGAE,MAAMkd,EAA6B8C,EAAeiE,GAChD,OAAO/a,KAAK4a,KAAK/E,EAAAF,SAAS7e,MAAOkd,EAAc8C,EAAKiE,EACtD,CAGA9e,IAAI+X,EAA6B8C,EAAgBiE,GAC/C,OAAO/a,KAAK4a,KAAK/E,EAAAF,SAAS1Z,IAAK+X,EAAc8C,EAAKiE,EACpD,CAGApa,IAAIqT,EAA6B8C,EAAgBiE,GAC/C,OAAO/a,KAAK4a,KAAK/E,EAAAF,SAAShV,IAAKqT,EAAc8C,EAAKiE,EACpD,CAGA5a,MAAAA,CAAOkX,EAAWP,EAAeQ,GAC/B,OAAOtX,KAAK8a,UAAU,IAAI1D,EAAOC,EAAKP,EAAKQ,GAC7C,CAGAtG,GAAAA,CAAIqG,EAAWP,GACb,OAAO9W,KAAK8a,UAAU,IAAItD,EAASH,EAAKrlB,EAAAkL,UAAUqZ,IAAKO,GACzD,CAGAvhB,IAAAA,CAAK0C,GAGH,MAFgB,mBAALA,EAAiBA,IACnBA,IAAM9C,EAAAwK,KAAKK,KAAK8a,UAAU,IAAI9C,EAAQ/f,IACxC+H,IACT,CAGAoT,MAAAA,GACE,MAAM7d,EAAmB,CAAC,KAAI,QAAAylB,EAAAjlB,UAAApD,OADtBsoB,EAA+C,IAAAnoB,MAAAkoB,GAAAE,EAAA,EAAAA,EAAAF,EAAAE,IAA/CD,EAA+CC,GAAAnlB,UAAAmlB,GAEvD,IAAK,MAAOznB,EAAK4P,KAAU4X,EACrB1lB,EAAK5C,OAAS,GAAG4C,EAAKwD,KAAK,KAC/BxD,EAAKwD,KAAKtF,IACNA,IAAQ4P,GAASrD,KAAK5L,KAAK0U,OAC7BvT,EAAKwD,KAAK,MACV,EAAA5D,EAAAgmB,YAAW5lB,EAAM8N,IAIrB,OADA9N,EAAKwD,KAAK,KACH,IAAI5D,EAAA8gB,MAAM1gB,EACnB,CAGAZ,GAAGF,EAA2B2mB,EAAkBC,GAG9C,GAFArb,KAAKsb,WAAW,IAAI3C,EAAGlkB,IAEnB2mB,GAAYC,EACdrb,KAAKzK,KAAK6lB,GAAUxC,OAAOrjB,KAAK8lB,GAAUE,aACrC,GAAIH,EACTpb,KAAKzK,KAAK6lB,GAAUG,aACf,GAAIF,EACT,MAAM,IAAIlgB,MAAM,4CAElB,OAAO6E,IACT,CAGAwb,MAAAA,CAAO/mB,GACL,OAAOuL,KAAKyb,UAAU,IAAI9C,EAAGlkB,GAC/B,CAGAmkB,OACE,OAAO5Y,KAAKyb,UAAU,IAAIhD,EAC5B,CAGA8C,KAAAA,GACE,OAAOvb,KAAK0b,cAAc/C,EAAIF,EAChC,CAEQkD,IAAAA,CAAKC,EAAWC,GAGtB,OAFA7b,KAAKsb,WAAWM,GACZC,GAAS7b,KAAKzK,KAAKsmB,GAASC,SACzB9b,IACT,CAGA+b,IAAI7C,EAAiB2C,GACnB,OAAO7b,KAAK2b,KAAK,IAAI1C,EAAQC,GAAY2C,EAC3C,CAGAG,QAAAA,CACEhI,EACAoF,EACAC,EACAwC,GAC2D,IAA3DhF,EAAA9gB,UAAApD,OAAA,QAAAjB,IAAAqE,UAAA,GAAAA,UAAA,GAAgBiK,KAAK5L,KAAK0U,IAAM+M,EAAAF,SAAShV,IAAMkV,EAAAF,SAAS1Z,IAExD,MAAMrF,EAAOoJ,KAAK4U,OAAOb,OAAOC,GAChC,OAAOhU,KAAK2b,KAAK,IAAIxC,EAAStC,EAASjgB,EAAMwiB,EAAMC,GAAK,IAAMwC,EAAQjlB,GACxE,CAGAqlB,KAAAA,CACEjI,EACAwF,EACAqC,GAC8B,IAA9BhF,EAAA9gB,UAAApD,OAAA,QAAAjB,IAAAqE,UAAA,GAAAA,UAAA,GAAgB8f,EAAAF,SAAS7e,MAEzB,MAAMF,EAAOoJ,KAAK4U,OAAOb,OAAOC,GAChC,GAAIhU,KAAK5L,KAAK0U,IAAK,CACjB,MAAMoT,EAAM1C,aAAoBrkB,EAAAkH,KAAOmd,EAAWxZ,KAAKW,IAAI,OAAQ6Y,GACnE,OAAOxZ,KAAKgc,SAAS,KAAM,EAAG7mB,EAAAb,CAAC,GAAG4nB,WAAetpB,IAC/CoN,KAAKW,IAAI/J,EAAMzB,EAAAb,CAAC,GAAG4nB,KAAOtpB,MAC1BipB,EAAQjlB,IAEZ,CACA,OAAOoJ,KAAK2b,KAAK,IAAIrC,EAAQ,KAAMzC,EAASjgB,EAAM4iB,GAAW,IAAMqC,EAAQjlB,GAC7E,CAIAulB,KAAAA,CACEnI,EACAoI,EACAP,GAC6D,IAA7DhF,EAAA9gB,UAAApD,OAAA,QAAAjB,IAAAqE,UAAA,GAAAA,UAAA,GAAgBiK,KAAK5L,KAAK0U,IAAM+M,EAAAF,SAAShV,IAAMkV,EAAAF,SAAS7e,MAExD,GAAIkJ,KAAK5L,KAAKwc,cACZ,OAAO5Q,KAAKic,MAAMjI,EAAc7e,EAAAb,CAAC,eAAe8nB,KAAQP,GAE1D,MAAMjlB,EAAOoJ,KAAK4U,OAAOb,OAAOC,GAChC,OAAOhU,KAAK2b,KAAK,IAAIrC,EAAQ,KAAMzC,EAASjgB,EAAMwlB,GAAM,IAAMP,EAAQjlB,GACxE,CAGAklB,MAAAA,GACE,OAAO9b,KAAK0b,cAAc1C,EAC5B,CAGAtB,KAAAA,CAAMA,GACJ,OAAO1X,KAAK8a,UAAU,IAAIrD,EAAMC,GAClC,CAGA2E,MAAM3E,GACJ,OAAO1X,KAAK8a,UAAU,IAAIlD,EAAMF,GAClC,CAGA4E,OAAOjZ,GACL,MAAMuY,EAAO,IAAIjC,EAGjB,GAFA3Z,KAAKsb,WAAWM,GAChB5b,KAAKzK,KAAK8N,GACgB,IAAtBuY,EAAKzD,MAAMxlB,OAAc,MAAM,IAAIwI,MAAM,0CAC7C,OAAO6E,KAAK0b,cAAc/B,EAC5B,CAGA9Y,IAAI0b,EAAgBC,EAA+BC,GACjD,IAAKD,IAAcC,EAAa,MAAM,IAAIthB,MAAM,gDAChD,MAAMygB,EAAO,IAAIhC,EAGjB,GAFA5Z,KAAKsb,WAAWM,GAChB5b,KAAKzK,KAAKgnB,GACNC,EAAW,CACb,MAAMjkB,EAAQyH,KAAKpJ,KAAK,KACxBoJ,KAAK0c,UAAYd,EAAK/B,MAAQ,IAAIE,EAAMxhB,GACxCikB,EAAUjkB,EACZ,CAKA,OAJIkkB,IACFzc,KAAK0c,UAAYd,EAAK9B,QAAU,IAAIE,EACpCha,KAAKzK,KAAKknB,IAELzc,KAAK0b,cAAc3B,EAAOC,EACnC,CAGA/Y,MAAM1I,GACJ,OAAOyH,KAAK8a,UAAU,IAAIhD,EAAMvf,GAClC,CAGAokB,KAAAA,CAAMC,EAAcC,GAGlB,OAFA7c,KAAKsa,aAAavhB,KAAKiH,KAAKwa,OAAO7nB,QAC/BiqB,GAAM5c,KAAKzK,KAAKqnB,GAAME,SAASD,GAC5B7c,IACT,CAGA8c,QAAAA,CAASD,GACP,MAAMhmB,EAAMmJ,KAAKsa,aAAarf,MAC9B,QAAYvJ,IAARmF,EAAmB,MAAM,IAAIsE,MAAM,wCACvC,MAAM4hB,EAAU/c,KAAKwa,OAAO7nB,OAASkE,EACrC,GAAIkmB,EAAU,QAAoBrrB,IAAdmrB,GAA2BE,IAAYF,EACzD,MAAM,IAAI1hB,MAAM,mCAAmC4hB,QAAcF,cAGnE,OADA7c,KAAKwa,OAAO7nB,OAASkE,EACdmJ,IACT,CAGAvF,IAAAA,CAAK7D,GAA+D,IAAnD8iB,EAAA3jB,UAAApD,OAAA,QAAAjB,IAAAqE,UAAA,GAAAA,UAAA,GAAaZ,EAAAwK,IAAKsD,EAAelN,UAAApD,OAAA,EAAAoD,UAAA,QAAArE,EAAEsrB,EAAgBjnB,UAAApD,OAAA,EAAAoD,UAAA,QAAArE,EAGlE,OAFAsO,KAAKsb,WAAW,IAAI7B,EAAK7iB,EAAM8iB,EAAMzW,IACjC+Z,GAAUhd,KAAKzK,KAAKynB,GAAUC,UAC3Bjd,IACT,CAGAid,OAAAA,GACE,OAAOjd,KAAK0b,cAAcjC,EAC5B,CAEAzT,QAAAA,GAAc,IAALoS,EAACriB,UAAApD,OAAA,QAAAjB,IAAAqE,UAAA,GAAAA,UAAA,GAAG,EACX,KAAOqiB,KAAM,GACXpY,KAAKya,MAAMhE,gBACXzW,KAAKya,MAAM/D,cAAc1W,KAAKya,MAAMzD,MAAOhX,KAAK2W,WAEpD,CAEQmE,SAAAA,CAAUc,GAEhB,OADA5b,KAAK0c,UAAUvE,MAAMpf,KAAK6iB,GACnB5b,IACT,CAEQsb,UAAAA,CAAWM,GACjB5b,KAAK0c,UAAUvE,MAAMpf,KAAK6iB,GAC1B5b,KAAKwa,OAAOzhB,KAAK6iB,EACnB,CAEQF,aAAAA,CAAcwB,EAAsBC,GAC1C,MAAM/E,EAAIpY,KAAK0c,UACf,GAAItE,aAAa8E,GAAOC,GAAM/E,aAAa+E,EAEzC,OADAnd,KAAKwa,OAAOvf,MACL+E,KAET,MAAM,IAAI7E,MAAM,0BAA0BgiB,EAAK,GAAGD,EAAGxE,QAAQyE,EAAGzE,OAASwE,EAAGxE,QAC9E,CAEQ+C,SAAAA,CAAUG,GAChB,MAAMxD,EAAIpY,KAAK0c,UACf,KAAMtE,aAAaO,GACjB,MAAM,IAAIxd,MAAM,gCAGlB,OADA6E,KAAK0c,UAAYtE,EAAEQ,KAAOgD,EACnB5b,IACT,CAEA,SAAYya,GACV,OAAOza,KAAKwa,OAAO,EACrB,CAEA,aAAYkC,GACV,MAAM5D,EAAK9Y,KAAKwa,OAChB,OAAO1B,EAAGA,EAAGnmB,OAAS,EACxB,CAEA,aAAY+pB,CAAUd,GACpB,MAAM9C,EAAK9Y,KAAKwa,OAChB1B,EAAGA,EAAGnmB,OAAS,GAAKipB,CACtB,GAmDF5pB,EAAAA,IAAA+mB,EAIA,MAAMqE,EAAUC,EAAQrrB,EAAAkL,UAAUoZ,KAGlCtkB,EAAAA,IAAA,WAAmC,QAAAsrB,EAAAvnB,UAAApD,OAAZ+mB,EAAY,IAAA5mB,MAAAwqB,GAAAC,EAAA,EAAAA,EAAAD,EAAAC,IAAZ7D,EAAY6D,GAAAxnB,UAAAwnB,GACjC,OAAO7D,EAAK7L,OAAOuP,EACrB,EAEA,MAAMI,EAASH,EAAQrrB,EAAAkL,UAAUmZ,IASjC,SAASgH,EAAQhN,GACf,MAAO,CAAC0C,EAAG0K,IAAO1K,IAAM5d,EAAAwK,IAAM8d,EAAIA,IAAMtoB,EAAAwK,IAAMoT,EAAI5d,EAAAb,CAAC,GAAG8lB,EAAIrH,MAAM1C,KAAM+J,EAAIqD,IAC5E,CAEA,SAASrD,EAAIrH,GACX,OAAOA,aAAa5d,EAAAkH,KAAO0W,EAAI5d,EAAAb,CAAC,IAAIye,IACtC,CAZA/gB,EAAAA,GAAA,WAAkC,QAAA0rB,EAAA3nB,UAAApD,OAAZ+mB,EAAY,IAAA5mB,MAAA4qB,GAAAC,EAAA,EAAAA,EAAAD,EAAAC,IAAZjE,EAAYiE,GAAA5nB,UAAA4nB,GAChC,OAAOjE,EAAK7L,OAAO2P,EACrB,C,wJC/zBA,MAAA9pB,EAAAC,EAAA,OACAyK,EAAAzK,EAAA,OAEAwB,EAAAxB,EAAA,OACAiqB,EAAAjqB,EAAA,OAkFA,SAASkqB,EAAWroB,GAClB,MAAM,IAACvB,EAAG,KAAEE,EAAI,GAAEL,GAAM0B,EACxBvB,EAAIU,GAAGb,EAAG4I,WAAY,IAAMzI,EAAIkM,OAAOhM,EAAMT,EAAAY,CAAC,GAAGR,EAAG4I,cAAc5I,EAAGsI,uBACvE,CAoBA,SAAS0hB,EAAW7pB,EAActC,EAAiBwP,GACjD,QAAezP,IAAXyP,EAAsB,MAAM,IAAIhG,MAAM,YAAYxJ,wBACtD,OAAOsC,EAAI8K,WACT,UACiB,mBAAVoC,EAAuB,CAACnC,IAAKmC,GAAU,CAACnC,IAAKmC,EAAQ5L,MAAM,EAAA7B,EAAAkB,WAAUuM,IAEhF,CA3GAnP,EAAAA,iBAAA,SAAiCwD,EAAiBJ,GAChD,MAAM,IAACnB,EAAG,QAAEtC,EAAO,OAAEP,EAAM,aAAE4E,EAAY,GAAElC,GAAM0B,EAC3CuoB,EAAc3oB,EAAI4oB,MAAMxqB,KAAKM,EAAG3B,KAAMf,EAAQ4E,EAAclC,GAC5DmqB,EAAYH,EAAW7pB,EAAKtC,EAASosB,IACZ,IAA3BjqB,EAAGM,KAAK4T,gBAA0BlU,EAAG3B,KAAK6V,eAAe+V,GAAa,GAE1E,MAAMpnB,EAAQ1C,EAAI2C,KAAK,SACvBpB,EAAIuB,UACF,CACE3F,OAAQ2sB,EACRziB,WAAY5H,EAAAiM,IACZ1J,cAAe,GAAGnC,EAAGmC,iBAAiBtE,IACtC4J,aAAc0iB,EACd/pB,eAAe,GAEjByC,GAEFnB,EAAIwN,KAAKrM,EAAO,IAAMnB,EAAI+C,OAAM,GAClC,EAEAvG,EAAAA,gBAAA,SAAgCwD,EAAiBJ,G,MAC/C,MAAM,IAACnB,EAAG,QAAEtC,EAAO,OAAEP,EAAM,aAAE4E,EAAY,MAAEiI,EAAK,GAAEnK,GAAM0B,GA4E1D,SAA0BvD,EAA4BmD,GAA0B,IAArD,UAACoJ,GAAwBvM,EAClD,GAAImD,EAAI6N,QAAUzE,EAAUK,OAAQ,MAAM,IAAI1D,MAAM,+BACtD,CA7EE+iB,CAAkBpqB,EAAIsB,GACtB,MAAMyK,GACH5B,GAAS7I,EAAIsV,QAAUtV,EAAIsV,QAAQlX,KAAKM,EAAG3B,KAAMf,EAAQ4E,EAAclC,GAAMsB,EAAIyK,SAC9Ese,EAAcL,EAAW7pB,EAAKtC,EAASkO,GACvClJ,EAAQ1C,EAAIgI,IAAI,SAqCtB,SAASmiB,IAAsD,IAA1CC,EAAAtoB,UAAApD,OAAA,QAAAjB,IAAAqE,UAAA,GAAAA,UAAA,GAAeX,EAAI6N,MAAQvP,EAAAY,CAAC,SAAWZ,EAAAiM,IAC1D,MAAMG,EAAUhM,EAAGM,KAAK2L,YAAc3B,EAAApJ,QAAEgL,KAAO5B,EAAApJ,QAAE7C,KAC3CmsB,IAAgB,YAAalpB,IAAQ6I,IAAyB,IAAf7I,EAAIhE,QACzD6C,EAAIkM,OACFxJ,EACAjD,EAAAY,CAAC,GAAG+pB,KAAS,EAAAlpB,EAAA2L,kBAAiBtL,EAAK2oB,EAAare,EAASwe,KACzDlpB,EAAImpB,UAER,CAEA,SAASC,EAAWne,G,MAClBpM,EAAIU,IAAG,EAAAjB,EAAAqlB,KAAa,QAATnnB,EAAAwD,EAAIuB,aAAK,IAAA/E,EAAAA,EAAI+E,GAAQ0J,EAClC,CAhDA7K,EAAIipB,WAAW9nB,EAGf,WACE,IAAmB,IAAfvB,EAAIiL,OACN+d,IACIhpB,EAAImpB,WAAWV,EAAWroB,GAC9BgpB,EAAW,IAAMhpB,EAAI+C,aAChB,CACL,MAAMmmB,EAAWtpB,EAAI6N,MAMzB,WACE,MAAMyb,EAAWzqB,EAAIgI,IAAI,WAAY,MAUrC,OATAhI,EAAI4M,IACF,IAAMud,EAAY1qB,EAAAY,CAAC,UAClByM,GACC9M,EAAIkM,OAAOxJ,GAAO,GAAOhC,GACvBjB,EAAAY,CAAC,GAAGyM,gBAAgBjN,EAAGkN,kBACvB,IAAM/M,EAAIkM,OAAOue,EAAUhrB,EAAAY,CAAC,GAAGyM,YAC/B,IAAM9M,EAAIgN,MAAMF,KAGf2d,CACT,CAlBiCC,GAoBjC,WACE,MAAMC,EAAelrB,EAAAY,CAAC,GAAG6pB,WAGzB,OAFAlqB,EAAIkM,OAAOye,EAAc,MACzBR,EAAY1qB,EAAAiM,KACLif,CACT,CAzBmDC,GAC3CzpB,EAAImpB,WAAWV,EAAWroB,GAC9BgpB,EAAW,IA6CjB,SAAiBhpB,EAAiB0K,GAChC,MAAM,IAACjM,GAAOuB,EACdvB,EAAIU,GACFjB,EAAAY,CAAC,iBAAiB4L,KAClB,KACEjM,EACGkM,OAAO/B,EAAApJ,QAAEoL,QAAS1M,EAAAY,CAAC,GAAG8J,EAAApJ,QAAEoL,sBAAsBF,OAAU9B,EAAApJ,QAAEoL,kBAAkBF,MAC5EC,OAAO/B,EAAApJ,QAAEqL,OAAQ3M,EAAAY,CAAC,GAAG8J,EAAApJ,QAAEoL,mBAC1B,EAAAwd,EAAAkB,cAAatpB,IAEf,IAAMA,EAAI+C,QAEd,CAzDuBwmB,CAAQvpB,EAAKkpB,GAChC,CACF,GAZAlpB,EAAIG,GAAY,QAAT/D,EAAAwD,EAAIuB,aAAK,IAAA/E,EAAAA,EAAI+E,EAgDtB,EAiCA3E,EAAAA,gBAAA,SACEZ,EACAiE,GACsB,IAAtB2pB,EAAcjpB,UAAApD,OAAA,QAAAjB,IAAAqE,UAAA,IAAAA,UAAA,GAGd,OACGV,EAAW1C,QACZ0C,EAAW9D,KAAM0tB,GACR,UAAPA,EACInsB,MAAMC,QAAQ3B,GACP,WAAP6tB,EACA7tB,GAA2B,iBAAVA,IAAuB0B,MAAMC,QAAQ3B,UAC/CA,GAAU6tB,GAAOD,GAAmC,oBAAV5tB,EAG3D,EAEAY,EAAAA,qBAAA,SAAoCyJ,EAElCrG,EACAzD,GAAe,IAFf,OAACP,EAAM,KAAEgD,EAAI,KAAEjC,EAAI,cAAE8D,GAA4BwF,EAKjD,GAAI3I,MAAMC,QAAQqC,EAAIzD,UAAYyD,EAAIzD,QAAQutB,SAASvtB,GAAWyD,EAAIzD,UAAYA,EAChF,MAAM,IAAIwJ,MAAM,4BAGlB,MAAMgkB,EAAO/pB,EAAIgqB,aACjB,GAAQ,OAAJD,QAAI,IAAJA,OAAI,EAAJA,EAAM5tB,KAAMQ,IAASqB,OAAOC,UAAUE,eAAeC,KAAKpC,EAAQW,IACpE,MAAM,IAAIoJ,MAAM,2CAA2CxJ,MAAYwtB,EAAKlmB,KAAK,QAGnF,GAAI7D,EAAI4S,eAAgB,CAEtB,IADc5S,EAAI4S,eAAe5W,EAAOO,IAC5B,CACV,MAAM4E,EACJ,YAAY5E,gCAAsCsE,OAClD9D,EAAK6Z,WAAW5W,EAAI4S,eAAe3H,QACrC,GAA4B,QAAxBjM,EAAK4T,eACJ,MAAM,IAAI7M,MAAM5E,GADcpE,EAAKmQ,OAAO/J,MAAMhC,EAEvD,CACF,CACF,C,qTCvKA,MAAA7C,EAAAC,EAAA,OACAC,EAAAD,EAAA,OACAyK,EAAAzK,EAAA,OACA0rB,EAAA1rB,EAAA,OA0BA,SAAgB2rB,EAAYrrB,GAC1B,OAAOA,EAAI8K,WAAW,OAAQ,CAE5BC,IAAK5L,OAAOC,UAAUE,eACtBgC,KAAM7B,EAAAY,CAAC,mCAEX,CAEA,SAAgBirB,EAActrB,EAAcE,EAAYqgB,GACtD,OAAO9gB,EAAAY,CAAC,GAAGgrB,EAAYrrB,WAAaE,MAASqgB,IAC/C,CAYA,SAAgBgL,EACdvrB,EACAE,EACAqgB,EACA5D,GAEA,MAAMiI,EAAOnlB,EAAAY,CAAC,GAAGH,KAAO,EAAAT,EAAAa,aAAYigB,mBACpC,OAAO5D,GAAgB,EAAAld,EAAAqO,IAAG8W,GAAM,EAAAnlB,EAAAqlB,KAAIwG,EAActrB,EAAKE,EAAMqgB,KAAcqE,CAC7E,CAEA,SAAgB4G,EAAoBC,GAClC,OAAOA,EAAYtsB,OAAOP,KAAK6sB,GAAWC,OAAQhU,GAAY,cAANA,GAAqB,EAC/E,CA3DA3Z,EAAAA,uBAAA,SAAuCwD,EAAiBzB,GACtD,MAAM,IAACE,EAAG,KAAEE,EAAI,GAAEL,GAAM0B,EACxBvB,EAAIU,GAAG6qB,EAAiBvrB,EAAKE,EAAMJ,EAAMD,EAAGM,KAAKwc,eAAgB,KAC/Dpb,EAAIoqB,UAAU,CAACC,gBAAiBnsB,EAAAY,CAAC,GAAGP,MAAS,GAC7CyB,EAAI+C,SAER,EAEAvG,EAAAA,iBAAA,SAAgCC,EAE9B6C,EACAgrB,GAAa,IAFb,IAAC7rB,EAAG,KAAEE,EAAML,IAAI,KAACM,IAAkBnC,EAInC,OAAO,EAAAyB,EAAAqO,OACFjN,EAAW6Y,IAAK5Z,IACjB,EAAAL,EAAAqsB,KAAIP,EAAiBvrB,EAAKE,EAAMJ,EAAMK,EAAKwc,eAAgBld,EAAAY,CAAC,GAAGwrB,OAAa/rB,MAGlF,EAEA/B,EAAAA,kBAAA,SAAkCwD,EAAiBsqB,GACjDtqB,EAAIoqB,UAAU,CAACC,gBAAiBC,IAAU,GAC1CtqB,EAAI+C,OACN,EAEAvG,EAAAA,YAAAstB,EAQAttB,EAAAA,cAAAutB,EAIAvtB,EAAAA,eAAA,SACEiC,EACAE,EACAqgB,EACA5D,GAEA,MAAMiI,EAAOnlB,EAAAY,CAAC,GAAGH,KAAO,EAAAT,EAAAa,aAAYigB,mBACpC,OAAO5D,EAAgBld,EAAAY,CAAC,GAAGukB,QAAW0G,EAActrB,EAAKE,EAAMqgB,KAAcqE,CAC/E,EAEA7mB,EAAAA,iBAAAwtB,EAUAxtB,EAAAA,oBAAAytB,EAIAztB,EAAAA,iBAAA,SAAiC8B,EAAe4rB,GAC9C,OAAOD,EAAoBC,GAAWC,OACnChU,KAAO,EAAA/X,EAAA8B,mBAAkB5B,EAAI4rB,EAAU/T,IAE5C,EAEA3Z,EAAAA,iBAAA,SAAgCyJ,EAE9BhB,EACAulB,EACA1B,GAAoB,IAHpB,WAACvgB,EAAU,KAAE5J,EAAML,IAAI,IAACG,EAAG,aAAEsH,EAAY,WAAED,EAAU,UAAEQ,GAAU,GAAEhI,GAAe2H,EAKlF,MAAMwkB,EAAgB3B,EAAa5qB,EAAAY,CAAC,GAAGyJ,MAAe5J,MAASoH,IAAeD,IAAenH,EACvF+rB,EAAkC,CACtC,CAAC9hB,EAAApJ,QAAE4Y,cAAc,EAAAla,EAAAqiB,WAAU3X,EAAApJ,QAAE4Y,aAAc9R,IAC3C,CAACsC,EAAApJ,QAAE0H,WAAY5I,EAAG4I,YAClB,CAAC0B,EAAApJ,QAAEoH,mBAAoBtI,EAAGsI,oBAC1B,CAACgC,EAAApJ,QAAEmrB,SAAU/hB,EAAApJ,QAAEmrB,WAEbrsB,EAAGM,KAAKgsB,YAAYF,EAAOnnB,KAAK,CAACqF,EAAApJ,QAAEub,eAAgBnS,EAAApJ,QAAEub,iBACzD,MAAMmJ,EAAOhmB,EAAAY,CAAC,GAAG2rB,MAAkBhsB,EAAImf,UAAU8M,KACjD,OAAOF,IAAYtsB,EAAAiM,IAAMjM,EAAAY,CAAC,GAAGmG,UAAaulB,MAAYtG,KAAUhmB,EAAAY,CAAC,GAAGmG,KAAQif,IAC9E,EAEA,MAAM2G,EAAY3sB,EAAAY,CAAC,aAEnBtC,EAAAA,WAAA,SAA0B4K,EAAgC0jB,GAAe,IAA9C,IAACrsB,EAAKH,IAAI,KAACM,IAAkBwI,EACtD,MAAM2jB,EAAInsB,EAAK+T,cAAgB,IAAM,IAC/B,OAAClC,GAAU7R,EAAKmB,KAChBirB,EAAKva,EAAOqa,EAASC,GAE3B,OAAOtsB,EAAI8K,WAAW,UAAW,CAC/BtL,IAAK+sB,EAAGltB,WACR0L,IAAKwhB,EACLjrB,KAAM7B,EAAAY,CAAC,GAAmB,eAAhB2R,EAAO1Q,KAAwB8qB,GAAY,EAAAhB,EAAA/O,SAAQrc,EAAKgS,MAAWqa,MAAYC,MAE7F,EAEAvuB,EAAAA,cAAA,SAA8BwD,GAC5B,MAAM,IAACvB,EAAG,KAAEE,EAAI,QAAExC,EAAO,GAAEmC,GAAM0B,EAC3BmB,EAAQ1C,EAAI2C,KAAK,SACvB,GAAI9C,EAAGkJ,UAAW,CAChB,MAAMyjB,EAAWxsB,EAAIgI,IAAI,SAAS,GAElC,OADAykB,EAAc,IAAMzsB,EAAIkM,OAAOsgB,GAAU,IAClCA,CACT,CAGA,OAFAxsB,EAAI0M,IAAIhK,GAAO,GACf+pB,EAAc,IAAMzsB,EAAIooB,SACjB1lB,EAEP,SAAS+pB,EAAcC,GACrB,MAAM9pB,EAAM5C,EAAI6C,MAAM,MAAOpD,EAAAY,CAAC,GAAGH,YACjCF,EAAI+nB,SAAS,IAAK,EAAGnlB,EAAMjE,IACzB4C,EAAIuB,UACF,CACEpF,UACAsF,SAAUrE,EACV8I,aAAc9H,EAAAgtB,KAAKC,KAErBlqB,GAEF1C,EAAIU,IAAG,EAAAjB,EAAAqlB,KAAIpiB,GAAQgqB,IAEvB,CACF,EAEA3uB,EAAAA,cAAA,SAA8BwD,GAC5B,MAAM,IAACvB,EAAG,OAAE7C,EAAM,QAAEO,EAAO,GAAEmC,GAAM0B,EAEnC,IAAK1C,MAAMC,QAAQ3B,GAAS,MAAM,IAAI+J,MAAM,4BAE5C,GADoB/J,EAAOG,KAAM2D,IAAmB,EAAAtB,EAAA8B,mBAAkB5B,EAAIoB,MACtDpB,EAAGM,KAAKqC,YAAa,OAEzC,MAAME,EAAQ1C,EAAIgI,IAAI,SAAS,GACzB6kB,EAAW7sB,EAAI2C,KAAK,UAE1B3C,EAAI0oB,MAAM,IACRvrB,EAAO6D,QAAQ,CAACub,EAAiB5d,KAC/B,MAAM8M,EAASlK,EAAIuB,UACjB,CACEpF,UACAqF,WAAYpE,EACZsB,eAAe,GAEjB4sB,GAEF7sB,EAAIkM,OAAOxJ,EAAOjD,EAAAY,CAAC,GAAGqC,QAAYmqB,KACnBtrB,EAAIurB,oBAAoBrhB,EAAQohB,IAGlC7sB,EAAIU,IAAG,EAAAjB,EAAAqlB,KAAIpiB,OAI5BnB,EAAI2L,OACFxK,EACA,IAAMnB,EAAIwrB,QACV,IAAMxrB,EAAI+C,OAAM,GAEpB,C,oGChKA,MAAA7E,EAAAC,EAAA,OACAC,EAAAD,EAAA,OASMyB,EAA6B,CACjCzD,QAAS,kBACTO,KAAM,QACNmD,WAAY,CAAC,UAAW,UACxBC,OAAQ,cACRiD,MAVoC,CACpCuF,QAAS7L,IAAA,IAAE+L,QAAQ,IAACnH,IAAK5E,EAAA,OAAKyB,EAAA2F,GAAG,2BAA2BxC,WAC5DmH,OAAQvC,IAAA,IAAEuC,QAAQ,IAACnH,IAAK4E,EAAA,OAAK/H,EAAAY,CAAC,WAAWuC,OASzCtB,IAAAA,CAAKC,GACH,MAAM,aAACQ,EAAY,GAAElC,GAAM0B,GACrB,MAACT,GAASiB,EACXlD,MAAMC,QAAQgC,GAInBksB,EAAwBzrB,EAAKT,IAH3B,EAAAnB,EAAAY,iBAAgBV,EAAI,uEAIxB,GAGF,SAAgBmtB,EAAwBzrB,EAAiBT,GACvD,MAAM,IAACd,EAAG,OAAE7C,EAAM,KAAE+C,EAAI,QAAExC,EAAO,GAAEmC,GAAM0B,EACzC1B,EAAGiB,OAAQ,EACX,MAAM8B,EAAM5C,EAAI6C,MAAM,MAAOpD,EAAAY,CAAC,GAAGH,YACjC,IAAe,IAAX/C,EACFoE,EAAIoqB,UAAU,CAAC/oB,IAAK9B,EAAMpC,SAC1B6C,EAAIwN,KAAKtP,EAAAY,CAAC,GAAGuC,QAAU9B,EAAMpC,eACxB,GAAqB,iBAAVvB,KAAuB,EAAAwC,EAAA8B,mBAAkB5B,EAAI1C,GAAS,CACtE,MAAMuF,EAAQ1C,EAAI0M,IAAI,QAASjN,EAAAY,CAAC,GAAGuC,QAAU9B,EAAMpC,UACnDsB,EAAIU,IAAG,EAAAjB,EAAAqlB,KAAIpiB,GAAQ,IAIrB,SAAuBA,GACrB1C,EAAI+nB,SAAS,IAAKjnB,EAAMpC,OAAQkE,EAAMjE,IACpC4C,EAAIuB,UAAU,CAACpF,UAASsF,SAAUrE,EAAG8I,aAAc9H,EAAAgtB,KAAKC,KAAMlqB,GACzD7C,EAAGkJ,WAAW/I,EAAIU,IAAG,EAAAjB,EAAAqlB,KAAIpiB,GAAQ,IAAM1C,EAAIooB,UAEpD,CAT2BqE,CAAc/pB,IACvCnB,EAAIG,GAAGgB,EACT,CAQF,CAnBA3E,EAAAA,wBAAAivB,EAqBAjvB,EAAAA,QAAeoD,C,YCrDf,MAAM8rB,EAAW,8DACXC,EAAU,oEAEhB,SAASC,EAAUC,GACjB,MAAsC,mBAAxBA,EAAaC,OAAuBD,EAAaC,OAAuD,QAA9ChnB,OAAO+mB,EAAa1mB,QAAQ4mB,aACtG,CAEA,SAASC,EAAWznB,GAKlB,OAJKA,EAAW1C,OACd0C,EAAWxB,MAAQwB,EAAWxB,OAAS,+BAGlCwB,CACT,CAEA,SAAS0nB,EAAe1nB,GACtB,MAAMunB,EAAqD,UAA5ChnB,OAAOP,EAAWY,QAAQ4mB,cAgBzC,OAbIxnB,EAAWM,QAAUinB,EAAS,IAAM,KAA2B,KAApBvnB,EAAWM,OACxDN,EAAWM,UAAO3I,GAIfqI,EAAWa,OACdb,EAAWa,KAAO,KAObb,CACT,CAqGA,MAAM2nB,EAAO,CACX/mB,OAAQ,OACRgnB,YAAY,EACZxT,MAAOqT,EACPjc,UAAWkc,GAUPG,EAAK,CACTjnB,OAAQ,KACRgnB,YAAY,EACZxT,MApHF,SAAkBkT,GAShB,OAPAA,EAAaC,OAASF,EAASC,GAG/BA,EAAaQ,cAAgBR,EAAazmB,MAAQ,MAAQymB,EAAaxmB,MAAQ,IAAMwmB,EAAaxmB,MAAQ,IAC1GwmB,EAAazmB,UAAOlJ,EACpB2vB,EAAaxmB,WAAQnJ,EAEd2vB,CACT,EA2GE9b,UAzGF,SAAsB8b,GAapB,GAXIA,EAAahnB,QAAU+mB,EAASC,GAAgB,IAAM,KAA6B,KAAtBA,EAAahnB,OAC5EgnB,EAAahnB,UAAO3I,GAIa,mBAAxB2vB,EAAaC,SACtBD,EAAa1mB,OAAU0mB,EAAaC,OAAS,MAAQ,KACrDD,EAAaC,YAAS5vB,GAIpB2vB,EAAaQ,aAAc,CAC7B,MAAOjnB,EAAMC,GAASwmB,EAAaQ,aAAavT,MAAM,KACtD+S,EAAazmB,KAAQA,GAAiB,MAATA,EAAeA,OAAOlJ,EACnD2vB,EAAaxmB,MAAQA,EACrBwmB,EAAaQ,kBAAenwB,CAC9B,CAKA,OAFA2vB,EAAavmB,cAAWpJ,EAEjB2vB,CACT,GAyGMS,EAAU,CACdJ,OACAK,MArCY,CACZpnB,OAAQ,QACRgnB,WAAYD,EAAKC,WACjBxT,MAAOqT,EACPjc,UAAWkc,GAkCXG,KACAI,IAzBU,CACVrnB,OAAQ,MACRgnB,WAAYC,EAAGD,WACfxT,MAAOyT,EAAGzT,MACV5I,UAAWqc,EAAGrc,WAsBd0c,IAnBU,CACVtnB,OAAQ,MACRwT,MA3FF,SAAmB+T,EAAe9S,GAChC,IAAK8S,EAActnB,KAEjB,OADAsnB,EAAc3pB,MAAQ,wBACf2pB,EAET,MAAM1qB,EAAU0qB,EAActnB,KAAKnD,MAAM0pB,GACzC,GAAI3pB,EAAS,CACX,MAAMmD,EAASyU,EAAQzU,QAAUunB,EAAcvnB,QAAU,MACzDunB,EAAcC,IAAM3qB,EAAQ,GAAG+pB,cAC/BW,EAAcE,IAAM5qB,EAAQ,GAC5B,MAAM6qB,EAAY,GAAG1nB,KAAUyU,EAAQ+S,KAAOD,EAAcC,MACtDG,EAAgBR,EAAQO,GAC9BH,EAActnB,UAAOlJ,EAEjB4wB,IACFJ,EAAgBI,EAAcnU,MAAM+T,EAAe9S,GAEvD,MACE8S,EAAc3pB,MAAQ2pB,EAAc3pB,OAAS,yBAG/C,OAAO2pB,CACT,EAsEE3c,UApEF,SAAuB2c,EAAe9S,GACpC,MAAMzU,EAASyU,EAAQzU,QAAUunB,EAAcvnB,QAAU,MACnDwnB,EAAMD,EAAcC,IAAIZ,cACxBc,EAAY,GAAG1nB,KAAUyU,EAAQ+S,KAAOA,IACxCG,EAAgBR,EAAQO,GAE1BC,IACFJ,EAAgBI,EAAc/c,UAAU2c,EAAe9S,IAGzD,MAAMmT,EAAgBL,EAChBE,EAAMF,EAAcE,IAI1B,OAHAG,EAAc3nB,KAAO,GAAGunB,GAAO/S,EAAQ+S,OAAOC,IAE9ChT,EAAQoT,YAAa,EACdD,CACT,EAqDEE,eAAe,GAgBf,WAbc,CACd9nB,OAAQ,WACRwT,MAxDF,SAAuB+T,EAAe9S,GACpC,MAAMsT,EAAiBR,EAQvB,OAPAQ,EAAeC,KAAOD,EAAeN,IACrCM,EAAeN,SAAM1wB,EAEhB0d,EAAQwT,UAAcF,EAAeC,MAASzB,EAASxS,KAAKgU,EAAeC,QAC9ED,EAAenqB,MAAQmqB,EAAenqB,OAAS,sBAG1CmqB,CACT,EA+CEnd,UA7CF,SAA2Bmd,GACzB,MAAMR,EAAgBQ,EAGtB,OADAR,EAAcE,KAAOM,EAAeC,MAAQ,IAAIpB,cACzCW,CACT,EAyCEO,eAAe,IAYjBnwB,EAAON,QAAU8vB,C,8JCxLjB,MAAAluB,EAAAD,EAAA,OACApB,EAAAoB,EAAA,KACAkvB,EAAAlvB,EAAA,OAMMmvB,EAAiB,IAAIrmB,IAAI,CAC7B,OACA,SACA,UACA,YACA,YACA,gBACA,gBACA,WACA,WACA,UACA,UACA,cACA,aACA,WACA,OACA,UAGFzK,EAAAA,UAAA,SAA0BZ,GAAiD,IAA9B2xB,IAAAhtB,UAAApD,OAAA,QAAAjB,IAAAqE,UAAA,KAAAA,UAAA,GAC3C,MAAqB,kBAAV3E,KACG,IAAV2xB,GAAwBC,EAAO5xB,KAC9B2xB,GACEE,EAAU7xB,IAAW2xB,EAC9B,EAEA,MAAMG,EAAe,IAAIzmB,IAAI,CAC3B,OACA,gBACA,mBACA,cACA,mBAGF,SAASumB,EAAO5xB,GACd,IAAK,MAAMqC,KAAOrC,EAAQ,CACxB,GAAI8xB,EAAatQ,IAAInf,GAAM,OAAO,EAClC,MAAMyB,EAAM9D,EAAOqC,GACnB,GAAIX,MAAMC,QAAQmC,IAAQA,EAAI3D,KAAKyxB,GAAS,OAAO,EACnD,GAAkB,iBAAP9tB,GAAmB8tB,EAAO9tB,GAAM,OAAO,CACpD,CACA,OAAO,CACT,CAEA,SAAS+tB,EAAU7xB,GACjB,IAAI+xB,EAAQ,EACZ,IAAK,MAAM1vB,KAAOrC,EAAQ,CACxB,GAAY,SAARqC,EAAgB,OAAO2vB,IAE3B,GADAD,KACIL,EAAelQ,IAAInf,KACG,iBAAfrC,EAAOqC,KAChB,EAAAG,EAAAiZ,UAASzb,EAAOqC,GAAOyB,GAASiuB,GAASF,EAAU/tB,IAEjDiuB,IAAUC,KAAU,OAAOA,GACjC,CACA,OAAOD,CACT,CAEA,SAAgBxS,EAAY0S,GAAmD,IAA5BhZ,EAAEtU,UAAApD,OAAA,QAAAjB,IAAAqE,UAAA,GAAAA,UAAA,GAAG,IACpC,KAD2DA,UAAApD,OAAA,EAAAoD,UAAA,QAAArE,KACpD2Y,EAAKwB,EAAYxB,IAC1C,MAAMsB,EAAI0X,EAASlV,MAAM9D,GACzB,OAAO4H,EAAaoR,EAAU1X,EAChC,CAEA,SAAgBsG,EAAaoR,EAAuB1X,GAElD,OADmB0X,EAAS9d,UAAUoG,GACpB2C,MAAM,KAAK,GAAK,GACpC,CATAtc,EAAAA,YAAA2e,EAMA3e,EAAAA,aAAAigB,EAKA,MAAMqR,EAAsB,QAC5B,SAAgBzX,EAAYxB,GAC1B,OAAOA,EAAKA,EAAGrP,QAAQsoB,EAAqB,IAAM,EACpD,CAFAtxB,EAAAA,YAAA6Z,EAIA7Z,EAAAA,WAAA,SAA2BqxB,EAAuB9kB,EAAgB8L,GAEhE,OADAA,EAAKwB,EAAYxB,GACVgZ,EAAStR,QAAQxT,EAAQ8L,EAClC,EAEA,MAAMkZ,EAAS,wBAEfvxB,EAAAA,cAAA,SAAyCZ,EAAmBmN,GAC1D,GAAqB,kBAAVnN,EAAqB,MAAO,CAAC,EACxC,MAAM,SAACwW,EAAQ,YAAExI,GAAeY,KAAK5L,KAC/Bge,EAAQvG,EAAYza,EAAOwW,IAAarJ,GACxCilB,EAA0C,CAAC,GAAIpR,GAC/CqR,EAAa9S,EAAYvR,EAAagT,GAAO,GAC7CxD,EAAuB,CAAC,EACxB8U,EAA0B,IAAIjnB,IAwCpC,OAtCAomB,EAASzxB,EAAQ,CAACuyB,SAAS,GAAO,CAACzuB,EAAK0uB,EAAStvB,EAAGuvB,KAClD,QAAsBnyB,IAAlBmyB,EAA6B,OACjC,MAAMC,EAAWL,EAAaG,EAC9B,IAAIG,EAAcP,EAAQK,GAM1B,SAASG,EAAkBhlB,GAEzB,MAAMilB,EAAWjkB,KAAK5L,KAAKgL,YAAY2S,QAEvC,GADA/S,EAAM6M,EAAYkY,EAAcE,EAASF,EAAa/kB,GAAOA,GACzD0kB,EAAW9Q,IAAI5T,GAAM,MAAMklB,EAASllB,GACxC0kB,EAAW1S,IAAIhS,GACf,IAAImT,EAAWnS,KAAKyI,KAAKzJ,GAYzB,MAXuB,iBAAZmT,IAAsBA,EAAWnS,KAAKyI,KAAK0J,IAC/B,iBAAZA,EACTgS,EAAiBjvB,EAAKid,EAAS/gB,OAAQ4N,GAC9BA,IAAQ6M,EAAYiY,KACd,MAAX9kB,EAAI,IACNmlB,EAAiBjvB,EAAK0Z,EAAU5P,GAAMA,GACtC4P,EAAU5P,GAAO9J,GAEjB8K,KAAKyI,KAAKzJ,GAAO8kB,GAGd9kB,CACT,CAEA,SAASolB,EAAqBC,GAC5B,GAAqB,iBAAVA,EAAoB,CAC7B,IAAKd,EAAO7U,KAAK2V,GAAS,MAAM,IAAIlpB,MAAM,mBAAmBkpB,MAC7DL,EAAOxwB,KAAKwM,KAAM,IAAIqkB,IACxB,CACF,CA/B4B,iBAAjBnvB,EAAI0S,KAAuBmc,EAAcC,EAAOxwB,KAAKwM,KAAM9K,EAAI0S,KAC1Ewc,EAAU5wB,KAAKwM,KAAM9K,EAAIovB,SACzBF,EAAU5wB,KAAKwM,KAAM9K,EAAIqvB,gBACzBf,EAAQI,GAAWG,IA+BdnV,EAEP,SAASuV,EAAiBK,EAAiBC,EAA6BzlB,GACtE,QAAatN,IAAT+yB,IAAuBlyB,EAAMiyB,EAAMC,GAAO,MAAMP,EAASllB,EAC/D,CAEA,SAASklB,EAASllB,GAChB,OAAO,IAAI7D,MAAM,cAAc6D,sCACjC,CACF,C,iEClJA,MAAM5J,EAA6B,CACjCzD,QAAS,KACT4D,IAAAA,GACE,MAAM,IAAI4F,MAAM,uDAClB,GAGFnJ,EAAAA,QAAeoD,C,mECRf,MAAAsvB,EAAA/wB,EAAA,OACAgxB,EAAAhxB,EAAA,OACAixB,EAAAjxB,EAAA,MACAkxB,EAAAlxB,EAAA,OACAmxB,EAAAnxB,EAAA,OACAoxB,EAAApxB,EAAA,OACAqxB,EAAArxB,EAAA,OACAsxB,EAAAtxB,EAAA,OACAuxB,EAAAvxB,EAAA,OACAwxB,EAAAxxB,EAAA,OACAyxB,EAAAzxB,EAAA,OACA0xB,EAAA1xB,EAAA,OACA2xB,EAAA3xB,EAAA,OACA4xB,EAAA5xB,EAAA,OACA6xB,EAAA7xB,EAAA,OACA8xB,EAAA9xB,EAAA,OAEA3B,EAAAA,QAAA,WAAuD,IAAjB0zB,EAAS3vB,UAAApD,OAAA,QAAAjB,IAAAqE,UAAA,IAAAA,UAAA,GAC7C,MAAM4vB,EAAa,CAEjBP,EAAApwB,QACAqwB,EAAArwB,QACAswB,EAAAtwB,QACAuwB,EAAAvwB,QACAwwB,EAAAxwB,QACAywB,EAAAzwB,QAEAgwB,EAAAhwB,QACAiwB,EAAAjwB,QACA+vB,EAAA/vB,QACAkwB,EAAAlwB,QACAmwB,EAAAnwB,SAMF,OAHI0wB,EAAWC,EAAW5sB,KAAK4rB,EAAA3vB,QAAa6vB,EAAA7vB,SACvC2wB,EAAW5sB,KAAK2rB,EAAA1vB,QAAiB4vB,EAAA5vB,SACtC2wB,EAAW5sB,KAAK+rB,EAAA9vB,SACT2wB,CACT,C,gLCrCA,MAAAjyB,EAAAC,EAAA,OAEAC,EAAAD,EAAA,OACAyK,EAAAzK,EAAA,OAoFA,SAASiyB,EAAS3xB,EAAc4xB,GAC9B,MAAMC,EAAM7xB,EAAI6C,MAAM,MAAO+uB,GAC7B5xB,EAAIU,GACFjB,EAAAY,CAAC,GAAG8J,EAAApJ,QAAEoL,mBACN,IAAMnM,EAAIkM,OAAO/B,EAAApJ,QAAEoL,QAAS1M,EAAAY,CAAC,IAAIwxB,MACjCpyB,EAAAY,CAAC,GAAG8J,EAAApJ,QAAEoL,gBAAgB0lB,MAExB7xB,EAAIsB,KAAK7B,EAAAY,CAAC,GAAG8J,EAAApJ,QAAEqL,WACjB,CAEA,SAAS0lB,EAAajyB,EAAeoM,GACnC,MAAM,IAACjM,EAAG,aAAEyK,EAAY,UAAEF,GAAa1K,EACnC0K,EAAUK,OACZ5K,EAAIgN,MAAMvN,EAAAY,CAAC,OAAOR,EAAGkN,mBAA2Bd,OAEhDjM,EAAIkM,OAAOzM,EAAAY,CAAC,GAAGoK,WAAuBwB,GACtCjM,EAAIqoB,QAAO,GAEf,CApGatqB,EAAAA,aAAuC,CAClD8L,QAAS7L,IAAA,IAAC,QAACN,GAAQM,EAAA,OAAKyB,EAAA2F,GAAG,cAAc1H,0BAG9BK,EAAAA,kBAA4C,CACvD8L,QAASrC,IAAA,IAAC,QAAC9J,EAAO,WAAE0D,GAAWoG,EAAA,OAC7BpG,EACI3B,EAAA2F,GAAG,IAAI1H,sBAA4B0D,YACnC3B,EAAA2F,GAAG,IAAI1H,kCASfK,EAAAA,YAAA,SACEwD,GAG2B,IAF3B+C,EAAAxC,UAAApD,OAAA,QAAAjB,IAAAqE,UAAA,GAAAA,UAAA,GAAgC/D,EAAAg0B,aAChCC,EAAuBlwB,UAAApD,OAAA,EAAAoD,UAAA,QAAArE,EACvBw0B,EAA2BnwB,UAAApD,OAAA,EAAAoD,UAAA,QAAArE,EAE3B,MAAM,GAACoC,GAAM0B,GACP,IAACvB,EAAG,cAAEC,EAAa,UAAE8I,GAAalJ,EAClC+xB,EAASM,EAAgB3wB,EAAK+C,EAAO0tB,IACtB,OAAjBC,QAAiB,IAAjBA,EAAAA,EAAsBhyB,GAAiB8I,GACzC4oB,EAAS3xB,EAAK4xB,GAEdE,EAAajyB,EAAIJ,EAAAY,CAAC,IAAIuxB,KAE1B,EAEA7zB,EAAAA,iBAAA,SACEwD,GAEuB,IADvB+C,EAAAxC,UAAApD,OAAA,QAAAjB,IAAAqE,UAAA,GAAAA,UAAA,GAAgC/D,EAAAg0B,aAChCC,EAAuBlwB,UAAApD,OAAA,EAAAoD,UAAA,QAAArE,EAEvB,MAAM,GAACoC,GAAM0B,GACP,IAACvB,EAAG,cAAEC,EAAa,UAAE8I,GAAalJ,EAExC8xB,EAAS3xB,EADMkyB,EAAgB3wB,EAAK+C,EAAO0tB,IAErC/xB,GAAiB8I,GACrB+oB,EAAajyB,EAAIsK,EAAApJ,QAAEoL,QAEvB,EAEApO,EAAAA,iBAAA,SAAiCiC,EAAcmyB,GAC7CnyB,EAAIkM,OAAO/B,EAAApJ,QAAEqL,OAAQ+lB,GACrBnyB,EAAIU,GAAGjB,EAAAY,CAAC,GAAG8J,EAAApJ,QAAEoL,mBAAoB,IAC/BnM,EAAIU,GACFyxB,EACA,IAAMnyB,EAAIkM,OAAOzM,EAAAY,CAAC,GAAG8J,EAAApJ,QAAEoL,iBAAkBgmB,GACzC,IAAMnyB,EAAIkM,OAAO/B,EAAApJ,QAAEoL,QAAS,OAGlC,EAEApO,EAAAA,aAAA,SAA4B4K,GAOV,IAPW,IAC3B3I,EAAG,QACHtC,EAAO,YACP00B,EAAW,KACXlyB,EAAI,UACJiyB,EAAS,GACTtyB,GACgB8I,EAEhB,QAAkBlL,IAAd00B,EAAyB,MAAM,IAAIjrB,MAAM,4BAC7C,MAAM2qB,EAAM7xB,EAAI2C,KAAK,OACrB3C,EAAI+nB,SAAS,IAAKoK,EAAWhoB,EAAApJ,QAAEqL,OAASzN,IACtCqB,EAAI6C,MAAMgvB,EAAKpyB,EAAAY,CAAC,GAAG8J,EAAApJ,QAAEoL,WAAWxN,MAChCqB,EAAIU,GAAGjB,EAAAY,CAAC,GAAGwxB,+BAAkC,IAC3C7xB,EAAIkM,OAAOzM,EAAAY,CAAC,GAAGwxB,kBAAoB,EAAApyB,EAAAqiB,WAAU3X,EAAApJ,QAAE4Y,aAAc9Z,EAAGgI,aAElE7H,EAAIkM,OAAOzM,EAAAY,CAAC,GAAGwxB,eAAkBpyB,EAAA2F,GAAG,GAAGvF,EAAGmC,iBAAiBtE,KACvDmC,EAAGM,KAAKkyB,UACVryB,EAAIkM,OAAOzM,EAAAY,CAAC,GAAGwxB,WAAcO,GAC7BpyB,EAAIkM,OAAOzM,EAAAY,CAAC,GAAGwxB,SAAY3xB,KAGjC,EAsBA,MAAMoyB,EAAI,CACR50B,QAAS,IAAI+B,EAAA2I,KAAK,WAClBf,WAAY,IAAI5H,EAAA2I,KAAK,cACrB2B,OAAQ,IAAItK,EAAA2I,KAAK,UACjBR,aAAc,IAAInI,EAAA2I,KAAK,gBACvByB,QAAS,IAAIpK,EAAA2I,KAAK,WAClBjL,OAAQ,IAAIsC,EAAA2I,KAAK,UACjBrG,aAAc,IAAItC,EAAA2I,KAAK,iBAGzB,SAAS8pB,EACP3wB,EACA+C,EACA0tB,GAEA,MAAM,aAAClpB,GAAgBvH,EAAI1B,GAC3B,OAAqB,IAAjBiJ,EAA+BrJ,EAAAY,CAAC,KAItC,SACEkB,EACA+C,GAC2B,IAA3B0tB,EAAAlwB,UAAApD,OAAA,QAAAjB,IAAAqE,UAAA,GAAAA,UAAA,GAAyB,CAAC,EAE1B,MAAM,IAAC9B,EAAG,GAAEH,GAAM0B,EACZylB,EAAyC,CAC7CuL,EAAkB1yB,EAAImyB,GACtBQ,EAAgBjxB,EAAKywB,IAGvB,OAqBF,SACEzwB,EAAoBkxB,EAEpBzL,GAAsC,IADtC,OAACjd,EAAM,QAAEF,GAAgC4oB,EAGzC,MAAM,QAAC/0B,EAAO,KAAEwC,EAAI,YAAEkyB,EAAW,GAAEvyB,GAAM0B,GACnC,KAACpB,EAAI,aAAEyH,EAAY,aAAEN,EAAY,WAAED,GAAcxH,EACvDmnB,EAAUliB,KACR,CAACwtB,EAAE50B,QAASA,GACZ,CAAC40B,EAAEvoB,OAAyB,mBAAVA,EAAuBA,EAAOxI,GAAOwI,GAAUtK,EAAAY,CAAC,OAEhEF,EAAKoT,UACPyT,EAAUliB,KAAK,CAACwtB,EAAEzoB,QAA2B,mBAAXA,EAAwBA,EAAQtI,GAAOsI,IAEvE1J,EAAKkyB,SACPrL,EAAUliB,KACR,CAACwtB,EAAEn1B,OAAQi1B,GACX,CAACE,EAAEvwB,aAActC,EAAAY,CAAC,GAAGiH,IAAeD,KACpC,CAAC8C,EAAApJ,QAAEb,KAAMA,IAGT0H,GAAcof,EAAUliB,KAAK,CAACwtB,EAAE1qB,aAAcA,GACpD,CA5CE8qB,CAAgBnxB,EAAK+C,EAAO0iB,GACrBhnB,EAAImf,UAAU6H,EACvB,CAfS2L,CAAYpxB,EAAK+C,EAAO0tB,EACjC,CAgBA,SAASO,EAAiB7O,EAAAE,GAAmD,IAAlD,UAAC/b,GAAqB6b,GAAE,aAAC/J,GAAyBiK,EAC3E,MAAMgP,EAAWjZ,EACbla,EAAA2F,GAAG,GAAGyC,KAAY,EAAAlI,EAAAsI,cAAa0R,EAAcha,EAAAgtB,KAAKkG,OAClDhrB,EACJ,MAAO,CAACsC,EAAApJ,QAAE4Y,cAAc,EAAAla,EAAAqiB,WAAU3X,EAAApJ,QAAE4Y,aAAciZ,GACpD,CAEA,SAASJ,EAAe1O,EAAAE,GAEgB,IADtC,QAACtmB,EAASmC,IAAI,cAACmC,IAAgC8hB,GAC/C,WAACzc,EAAU,aAAEtF,GAAyBiiB,EAElC8O,EAAU/wB,EAAeC,EAAgBvC,EAAA2F,GAAG,GAAGpD,KAAiBtE,IAIpE,OAHI2J,IACFyrB,EAAUrzB,EAAA2F,GAAG,GAAG0tB,KAAU,EAAAnzB,EAAAsI,cAAaZ,EAAY1H,EAAAgtB,KAAKkG,QAEnD,CAACP,EAAEjrB,WAAYyrB,EACxB,C,mEC7JA,MAAArzB,EAAAC,EAAA,OAUMyB,EAA6B,CACjCzD,QAAS,CAAC,WAAY,YACtBO,KAAM,QACNmD,WAAY,SACZ4I,OAAO,EACP1F,MAboC,CACpCuF,OAAAA,CAAO7L,GAAsB,IAArB,QAACN,EAAO,WAAEoM,GAAW9L,EAC3B,MAAMme,EAAmB,aAAZze,EAAyB,OAAS,QAC/C,OAAO+B,EAAA2F,GAAG,iBAAiB+W,UAAarS,SAC1C,EACAC,OAAQvC,IAAA,IAAC,WAACsC,GAAWtC,EAAA,OAAK/H,EAAAY,CAAC,WAAWyJ,OAStCxI,IAAAA,CAAKC,GACH,MAAM,QAAC7D,EAAO,KAAEwC,EAAI,WAAE4J,GAAcvI,EAC9B6a,EAAiB,aAAZ1e,EAAyB+B,EAAAwJ,UAAUM,GAAK9J,EAAAwJ,UAAUS,GAC7DnI,EAAI0I,UAAUxK,EAAAY,CAAC,GAAGH,YAAekc,KAAMtS,IACzC,GAGF/L,EAAAA,QAAeoD,C,qHCvBf,MAAAwoB,EAAAjqB,EAAA,OACAD,EAAAC,EAAA,OACAyK,EAAAzK,EAAA,OAEMqzB,EAAoC,CACxClpB,QAAS,2BAyBX,SAASmpB,EAAiBnzB,EAAeoyB,GACvC,MAAM,IAACjyB,EAAG,KAAEE,GAAQL,EAEd0B,EAAuB,CAC3BvB,MACAtC,QAAS,eACTwC,OACA/C,QAAQ,EACR2M,YAAY,EACZsoB,aAAa,EACbroB,OAAQ,CAAC,EACTlK,OAEF,EAAA8pB,EAAAsJ,aAAY1xB,EAAKwxB,OAAWt1B,EAAWw0B,EACzC,CApCAl0B,EAAAA,qBAAA,SAAqC8B,GACnC,MAAM,IAACG,EAAG,OAAE7C,EAAM,aAAEsN,GAAgB5K,GACrB,IAAX1C,EACF61B,EAAiBnzB,GAAI,GACK,iBAAV1C,IAAwC,IAAlBA,EAAOyN,OAC7C5K,EAAIqoB,OAAOle,EAAApJ,QAAEb,OAEbF,EAAIkM,OAAOzM,EAAAY,CAAC,GAAGoK,WAAuB,MACtCzK,EAAIqoB,QAAO,GAEf,EAEAtqB,EAAAA,kBAAA,SAAkC8B,EAAe6C,GAC/C,MAAM,IAAC1C,EAAG,OAAE7C,GAAU0C,GACP,IAAX1C,GACF6C,EAAI0M,IAAIhK,GAAO,GACfswB,EAAiBnzB,IAEjBG,EAAI0M,IAAIhK,GAAO,EAEnB,C,mEC9BA,MAAAwN,EAAAxQ,EAAA,OAGA,MAAqB8b,UAAwBtU,MAI3CzI,WAAAA,CAAY2wB,EAAuB9kB,EAAgBS,EAAazI,GAC9DiN,MAAMjN,GAAO,2BAA2ByI,aAAeT,KACvDyB,KAAKwL,YAAa,EAAArH,EAAAkO,YAAWgR,EAAU9kB,EAAQS,GAC/CgB,KAAKuL,eAAgB,EAAApH,EAAA0H,cAAY,EAAA1H,EAAAwM,aAAY0S,EAAUrjB,KAAKwL,YAC9D,EARFxZ,EAAAA,QAAAyd,C,mECFA,MAAAld,EAAAoB,EAAA,KAGEpB,EAAgBgD,KAAO,4CAEzBvD,EAAAA,QAAeO,C,mECJf,MAAA6R,EAAAzQ,EAAA,OACAD,EAAAC,EAAA,OACAC,EAAAD,EAAA,OACAwzB,EAAAxzB,EAAA,OAcMyB,EAA6B,CACjCzD,QAAS,cACTO,KAAM,QACNmD,WAAY,UACZ4I,OAAO,EACP1F,MAXoC,CACpCuF,QAAS7L,IAAA,IAAE+L,QAAQ,EAACpL,EAAC,EAAEw0B,IAAGn1B,EAAA,OACxByB,EAAA2F,GAAG,2CAA2C+tB,SAASx0B,oBACzDoL,OAAQvC,IAAA,IAAEuC,QAAQ,EAACpL,EAAC,EAAEw0B,IAAG3rB,EAAA,OAAK/H,EAAAY,CAAC,OAAO1B,SAASw0B,OAS/C7xB,IAAAA,CAAKC,GACH,MAAM,IAACvB,EAAG,KAAEE,EAAI,MAAE8J,EAAK,OAAE7M,EAAM,aAAE4E,EAAY,WAAE+H,EAAU,GAAEjK,GAAM0B,EACjE,IAAKyI,IAAU7M,EAAQ,OACvB,MAAMuF,EAAQ1C,EAAIgI,IAAI,SAChBorB,EAAYrxB,EAAajB,OAAQ,EAAAqP,EAAAkjB,gBAAetxB,EAAajB,OAAS,GAgB5E,SAASwyB,EAAM30B,EAASw0B,GACtB,MAAMI,EAAOvzB,EAAI2C,KAAK,QAChB6wB,GAAY,EAAArjB,EAAAsjB,gBAAeL,EAAWG,EAAM1zB,EAAGM,KAAKmS,cAAenC,EAAAujB,SAASC,OAC5EC,EAAU5zB,EAAI6C,MAAM,UAAWpD,EAAAY,CAAC,MACtCL,EAAI8nB,IAAIroB,EAAAY,CAAC,IAAI1B,OAAQ,KACnBqB,EAAIgI,IAAIurB,EAAM9zB,EAAAY,CAAC,GAAGH,KAAQvB,MAC1BqB,EAAIU,GAAG8yB,EAAW/zB,EAAAY,CAAC,YACf+yB,EAAU10B,OAAS,GAAGsB,EAAIU,GAAGjB,EAAAY,CAAC,UAAUkzB,gBAAoB9zB,EAAAY,CAAC,GAAGkzB,YACpEvzB,EACGU,GAAGjB,EAAAY,CAAC,UAAUuzB,KAAWL,iBAAqB,KAC7CvzB,EAAIkM,OAAOinB,EAAG1zB,EAAAY,CAAC,GAAGuzB,KAAWL,MAC7BhyB,EAAI+C,QACJtE,EAAIkM,OAAOxJ,GAAO,GAAO0lB,UAE1B9mB,KAAK7B,EAAAY,CAAC,GAAGuzB,KAAWL,QAAW50B,MAEtC,CAEA,SAASk1B,EAAOl1B,EAASw0B,GACvB,MAAMW,GAAM,EAAAn0B,EAAA0c,SAAQrc,EAAKkzB,EAAAnyB,SACnBgzB,EAAQ/zB,EAAI2C,KAAK,SACvB3C,EAAIyjB,MAAMsQ,GAAOjM,IAAIroB,EAAAY,CAAC,IAAI1B,OAAQ,IAChCqB,EAAI8nB,IAAIroB,EAAAY,CAAC,GAAG8yB,OAAOx0B,MAAMw0B,OAAQ,IAC/BnzB,EAAIU,GAAGjB,EAAAY,CAAC,GAAGyzB,KAAO5zB,KAAQvB,OAAOuB,KAAQizB,MAAO,KAC9C5xB,EAAI+C,QACJtE,EAAIkM,OAAOxJ,GAAO,GAAO0lB,MAAM2L,MAIvC,CA5CAxyB,EAAIipB,WAAW9nB,EAGf,WACE,MAAM/D,EAAIqB,EAAIgI,IAAI,IAAKvI,EAAAY,CAAC,GAAGH,YACrBizB,EAAInzB,EAAIgI,IAAI,KAClBzG,EAAIoqB,UAAU,CAAChtB,IAAGw0B,MAClBnzB,EAAIkM,OAAOxJ,GAAO,GAClB1C,EAAIU,GAAGjB,EAAAY,CAAC,GAAG1B,QAAS,KAIby0B,EAAU10B,OAAS,IAAM00B,EAAU91B,KAAM2b,GAAY,WAANA,GAAwB,UAANA,GAJ7Bqa,EAAQO,GAAQl1B,EAAGw0B,GAChE,EAT2C1zB,EAAAY,CAAC,GAAGyJ,eAC/CvI,EAAIG,GAAGgB,EA4CT,GAGF3E,EAAAA,QAAeoD,C,YCnDf9C,EAAON,QAAU,CACfkF,IA1BU,CACV,EAAG,EACH,EAAG,EACH,EAAG,EACH,EAAG,EACH,EAAG,EACH,EAAG,EACH,EAAG,EACH,EAAG,EACH,EAAG,EACH,EAAG,EACH1E,EAAG,GACHy1B,EAAG,GACHx1B,EAAG,GACHy1B,EAAG,GACHjwB,EAAG,GACHkwB,EAAG,GACHC,EAAG,GACHC,EAAG,GACHtnB,EAAG,GACHwlB,EAAG,GACH+B,EAAG,GACHC,EAAG,I,gBCaL,SAAS3lB,EACP/C,EACA2oB,GAEA,MAAO,CAAC3oB,WAAU2oB,UACpB,C,kGAEax2B,EAAAA,YAA8B,CAEzCy2B,KAAM7lB,EAAO6lB,EAAMC,GAEnBC,KAAM/lB,EAAOgmB,GAAQ,GAAOC,GAC5B,YAAajmB,EAAOkmB,GAAY,GAAOC,GACvC,WAAYnmB,EAAOgmB,IAAWI,GAC9B,gBAAiBpmB,EAAOkmB,IAAeG,GAEvCC,SAAU,yEACVC,IAiLF,SAAa9vB,GAEX,OAAO+vB,EAAiB1a,KAAKrV,IAAQgwB,EAAI3a,KAAKrV,EAChD,EAnLE,gBACE,yoCAEF,eACE,oLAGFiwB,IAAK,qdACLC,MACE,2IACFC,SACE,wGAEFC,KAAM,oFACNrxB,KAAM,m/BACNqW,MA8LF,SAAepV,GACb,GAAIqwB,EAAShb,KAAKrV,GAAM,OAAO,EAC/B,IAEE,OADA,IAAIrG,OAAOqG,IACJ,C,CACP,MAAO0H,GACP,OAAO,C,CAEX,EApME4hB,KAAM,+DAGN,eAAgB,4BAChB,4BAA6B,+DAE7B,wBAAyB,mDAGzBgH,KA6JF,SAActwB,GAEZ,OADAuwB,EAAKC,UAAY,EACVD,EAAKlb,KAAKrV,EACnB,EA9JEywB,MAAO,CAAC53B,KAAM,SAAU2N,SAmK1B,SAAuBwD,GACrB,OAAO0mB,OAAOC,UAAU3mB,IAAUA,GAAS4mB,GAAa5mB,GAAS6mB,CACnE,GAnKEC,MAAO,CAACj4B,KAAM,SAAU2N,SAqK1B,SAAuBwD,GAErB,OAAO0mB,OAAOC,UAAU3mB,EAC1B,GAtKE+mB,MAAO,CAACl4B,KAAM,SAAU2N,SAAUwqB,GAElCC,OAAQ,CAACp4B,KAAM,SAAU2N,SAAUwqB,GAEnCE,UAAU,EAEVC,QAAQ,GAGGx4B,EAAAA,YAA8B,IACtCA,EAAAy4B,YACHhC,KAAM7lB,EAAO,6BAA8B8lB,GAC3CC,KAAM/lB,EACJ,6EACAimB,GAEF,YAAajmB,EACX,sGACAmmB,GAEF,WAAYnmB,EACV,8EACAomB,GAEF,gBAAiBpmB,EACf,2GACAqmB,GAGFE,IAAK,6CACL,gBAAiB,0EAIjBI,MACE,oHAGSv3B,EAAAA,YAAcoB,OAAOP,KAAKb,EAAAy4B,aAOvC,MAAMC,EAAO,6BACPC,EAAO,CAAC,EAAG,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,IAE7D,SAASlC,EAAKpvB,GAEZ,MAAM7B,EAA2BkzB,EAAKE,KAAKvxB,GAC3C,IAAK7B,EAAS,OAAO,EACrB,MAAMqzB,GAAgBrzB,EAAQ,GACxBszB,GAAiBtzB,EAAQ,GACzBuzB,GAAevzB,EAAQ,GAC7B,OACEszB,GAAS,GACTA,GAAS,IACTC,GAAO,GACPA,IAAkB,IAAVD,GAnBZ,SAAoBD,GAElB,OAAOA,EAAO,IAAM,IAAMA,EAAO,MAAQ,GAAKA,EAAO,MAAQ,EAC/D,CAgB2BG,CAAWH,GAAQ,GAAKF,EAAKG,GAExD,CAEA,SAASpC,EAAYuC,EAAYC,GAC/B,GAAMD,GAAMC,EACZ,OAAID,EAAKC,EAAW,EAChBD,EAAKC,GAAY,EACd,CACT,CAEA,MAAMC,EAAO,kEAEb,SAASvC,EAAQwC,GACf,OAAO,SAAc/xB,GACnB,MAAM7B,EAA2B2zB,EAAKP,KAAKvxB,GAC3C,IAAK7B,EAAS,OAAO,EACrB,MAAM6zB,GAAc7zB,EAAQ,GACtB8zB,GAAe9zB,EAAQ,GACvB+zB,GAAe/zB,EAAQ,GACvBg0B,EAAyBh0B,EAAQ,GACjCi0B,EAAgC,MAAfj0B,EAAQ,IAAc,EAAI,EAC3Ck0B,IAAgBl0B,EAAQ,IAAM,GAC9Bm0B,IAAgBn0B,EAAQ,IAAM,GACpC,GAAIk0B,EAAM,IAAMC,EAAM,IAAOP,IAAmBI,EAAK,OAAO,EAC5D,GAAIH,GAAM,IAAMC,GAAO,IAAMC,EAAM,GAAI,OAAO,EAE9C,MAAMK,EAASN,EAAMK,EAAMF,EACrBI,EAAQR,EAAKK,EAAMD,GAAUG,EAAS,EAAI,EAAI,GACpD,OAAkB,KAAVC,IAA2B,IAAXA,KAA6B,KAAXD,IAA6B,IAAZA,IAAkBL,EAAM,EACrF,CACF,CAEA,SAAS1C,EAAYhX,EAAYC,GAC/B,IAAMD,IAAMC,EAAK,OACjB,MAAMga,EAAK,IAAIC,KAAK,cAAgBla,GAAI1e,UAClC64B,EAAK,IAAID,KAAK,cAAgBja,GAAI3e,UACxC,OAAM24B,GAAME,EACLF,EAAKE,OADZ,CAEF,CAEA,SAAShD,EAAe8C,EAAYE,GAClC,IAAMF,IAAME,EAAK,OACjB,MAAMC,EAAKd,EAAKP,KAAKkB,GACfI,EAAKf,EAAKP,KAAKoB,GACrB,OAAMC,GAAMC,GACZJ,EAAKG,EAAG,GAAKA,EAAG,GAAKA,EAAG,KACxBD,EAAKE,EAAG,GAAKA,EAAG,GAAKA,EAAG,IACJ,EAChBJ,EAAKE,GAAY,EACd,OALP,CAMF,CAEA,MAAMG,EAAsB,QAC5B,SAASrD,EAAYsC,GACnB,MAAMzC,EAAOC,EAAQwC,GAErB,OAAO,SAAmB/xB,GAExB,MAAM+yB,EAAqB/yB,EAAIiV,MAAM6d,GACrC,OAA2B,IAApBC,EAASz5B,QAAgB81B,EAAK2D,EAAS,KAAOzD,EAAKyD,EAAS,GACrE,CACF,CAEA,SAASrD,EAAgBsD,EAAaC,GACpC,IAAMD,IAAOC,EAAM,OACnB,MAAMrB,EAAK,IAAIc,KAAKM,GAAKl5B,UACnB+3B,EAAK,IAAIa,KAAKO,GAAKn5B,UACzB,OAAM83B,GAAMC,EACLD,EAAKC,OADZ,CAEF,CAEA,SAASjC,EAAmBoD,EAAaC,GACvC,IAAMD,IAAOC,EAAM,OACnB,MAAOrB,EAAIa,GAAMO,EAAI/d,MAAM6d,IACpBjB,EAAIc,GAAMM,EAAIhe,MAAM6d,GACrBI,EAAM7D,EAAYuC,EAAIC,GAC5B,YAAYx5B,IAAR66B,EACGA,GAAO1D,EAAYiD,EAAIE,QAD9B,CAEF,CAEA,MAAM5C,EAAmB,OACnBC,EACJ,+nCAOF,MAAMO,EAAO,qEAOb,MAAMM,IAAc,GAAK,IACnBD,EAAY,GAAK,GAAK,EAW5B,SAASI,IACP,OAAO,CACT,CAEA,MAAMX,EAAW,U,mEC5PjB,MAAAh2B,EAAAC,EAAA,OACAC,EAAAD,EAAA,OACAwB,EAAAxB,EAAA,OACA+wB,EAAA/wB,EAAA,OASMyB,EAA6B,CACjCzD,QAAS,QACTO,KAAM,QACNmD,WAAY,CAAC,SAAU,WACvBC,OAAQ,cACRiD,MAVoC,CACpCuF,QAAS7L,IAAA,IAAE+L,QAAQ,IAACnH,IAAK5E,EAAA,OAAKyB,EAAA2F,GAAG,2BAA2BxC,WAC5DmH,OAAQvC,IAAA,IAAEuC,QAAQ,IAACnH,IAAK4E,EAAA,OAAK/H,EAAAY,CAAC,WAAWuC,OASzCtB,IAAAA,CAAKC,GACH,MAAM,OAACpE,EAAM,aAAE4E,EAAY,GAAElC,GAAM0B,GAC7B,YAACg3B,GAAex2B,EACtBlC,EAAGiB,OAAQ,GACP,EAAAnB,EAAA8B,mBAAkB5B,EAAI1C,KACtBo7B,GAAa,EAAA9H,EAAAzD,yBAAwBzrB,EAAKg3B,GACzCh3B,EAAIG,IAAG,EAAAR,EAAAS,eAAcJ,IAC5B,GAGFxD,EAAAA,QAAeoD,C,mEC5Bf,MAAA1B,EAAAC,EAAA,OACAC,EAAAD,EAAA,OAiBMyB,EAA6B,CACjCzD,QAAS,WACTO,KAAM,QACNmD,WAAY,CAAC,SAAU,WACvBC,OAAQ,cACRm3B,aAAa,EACbl0B,MAfoC,CACpCuF,QAAS7L,IAAA,IAAE+L,QAAQ,IAACstB,EAAG,IAAEoB,IAAKz6B,EAAA,YACpBP,IAARg7B,EACIh5B,EAAA2F,GAAG,yBAAyBiyB,kBAC5B53B,EAAA2F,GAAG,yBAAyBiyB,sBAAwBoB,mBAC1D1uB,OAAQvC,IAAA,IAAEuC,QAAQ,IAACstB,EAAG,IAAEoB,IAAKjxB,EAAA,YACnB/J,IAARg7B,EAAoBh5B,EAAAY,CAAC,iBAAiBg3B,KAAS53B,EAAAY,CAAC,iBAAiBg3B,mBAAqBoB,OAUxFn3B,IAAAA,CAAKC,GACH,MAAM,IAACvB,EAAG,OAAE7C,EAAM,aAAE4E,EAAY,KAAE7B,EAAI,GAAEL,GAAM0B,EAC9C,IAAI81B,EACAoB,EACJ,MAAM,YAACC,EAAW,YAAEC,GAAe52B,EAC/BlC,EAAGM,KAAKy4B,MACVvB,OAAsB55B,IAAhBi7B,EAA4B,EAAIA,EACtCD,EAAME,GAENtB,EAAM,EAER,MAAMz0B,EAAM5C,EAAI6C,MAAM,MAAOpD,EAAAY,CAAC,GAAGH,YAEjC,GADAqB,EAAIoqB,UAAU,CAAC0L,MAAKoB,aACRh7B,IAARg7B,GAA6B,IAARpB,EAEvB,YADA,EAAA13B,EAAAY,iBAAgBV,EAAI,wEAGtB,QAAYpC,IAARg7B,GAAqBpB,EAAMoB,EAG7B,OAFA,EAAA94B,EAAAY,iBAAgBV,EAAI,wDACpB0B,EAAI+H,OAGN,IAAI,EAAA3J,EAAA8B,mBAAkB5B,EAAI1C,GAAS,CACjC,IAAIynB,EAAOnlB,EAAAY,CAAC,GAAGuC,QAAUy0B,IAGzB,YAFY55B,IAARg7B,IAAmB7T,EAAOnlB,EAAAY,CAAC,GAAGukB,QAAWhiB,QAAU61B,UACvDl3B,EAAIwN,KAAK6V,EAEX,CAEA/kB,EAAGiB,OAAQ,EACX,MAAM4B,EAAQ1C,EAAI2C,KAAK,SAYvB,SAASk2B,IACP,MAAMhM,EAAW7sB,EAAI2C,KAAK,UACpBusB,EAAQlvB,EAAIgI,IAAI,QAAS,GAC/BykB,EAAcI,EAAU,IAAM7sB,EAAIU,GAAGmsB,EAAU,IAkBjD,SAAqBqC,GACnBlvB,EAAIsB,KAAK7B,EAAAY,CAAC,GAAG6uB,YACDzxB,IAARg7B,EACFz4B,EAAIU,GAAGjB,EAAAY,CAAC,GAAG6uB,QAAYmI,IAAO,IAAMr3B,EAAIkM,OAAOxJ,GAAO,GAAM0lB,UAE5DpoB,EAAIU,GAAGjB,EAAAY,CAAC,GAAG6uB,OAAWuJ,IAAO,IAAMz4B,EAAIkM,OAAOxJ,GAAO,GAAO0lB,SAChD,IAARiP,EAAWr3B,EAAIkM,OAAOxJ,GAAO,GAC5B1C,EAAIU,GAAGjB,EAAAY,CAAC,GAAG6uB,QAAYmI,IAAO,IAAMr3B,EAAIkM,OAAOxJ,GAAO,IAE/D,CA3BuDo2B,CAAY5J,IACnE,CAEA,SAASzC,EAAcsM,EAAcrQ,GACnC1oB,EAAI+nB,SAAS,IAAK,EAAGnlB,EAAMjE,IACzB4C,EAAIuB,UACF,CACEpF,QAAS,WACTsF,SAAUrE,EACV8I,aAAc9H,EAAAgtB,KAAKC,IACnB3sB,eAAe,GAEjB84B,GAEFrQ,KAEJ,MA9BYjrB,IAARg7B,GAA6B,IAARpB,EACvB5K,EAAc/pB,EAAO,IAAM1C,EAAIU,GAAGgC,EAAO,IAAM1C,EAAIooB,UAClC,IAARiP,GACTr3B,EAAIgI,IAAItF,GAAO,QACHjF,IAARg7B,GAAmBz4B,EAAIU,GAAGjB,EAAAY,CAAC,GAAGH,eAAmB24B,KAErD74B,EAAIgI,IAAItF,GAAO,GACfm2B,KAEFt3B,EAAI2L,OAAOxK,EAAO,IAAMnB,EAAIwrB,QAiC9B,GAGFhvB,EAAAA,QAAeoD,C,mEC1Gf,MAAA1B,EAAAC,EAAA,OAUMyB,EAA6B,CACjCzD,QAAS,CAAC,gBAAiB,iBAC3BO,KAAM,SACNmD,WAAY,SACZ4I,OAAO,EACP1F,MAboC,CACpCuF,OAAAA,CAAO7L,GAAsB,IAArB,QAACN,EAAO,WAAEoM,GAAW9L,EAC3B,MAAMme,EAAmB,kBAAZze,EAA8B,OAAS,QACpD,OAAO+B,EAAA2F,GAAG,iBAAiB+W,UAAarS,cAC1C,EACAC,OAAQvC,IAAA,IAAC,WAACsC,GAAWtC,EAAA,OAAK/H,EAAAY,CAAC,WAAWyJ,OAStCxI,IAAAA,CAAKC,GACH,MAAM,QAAC7D,EAAO,KAAEwC,EAAI,WAAE4J,GAAcvI,EAC9B6a,EAAiB,kBAAZ1e,EAA8B+B,EAAAwJ,UAAUM,GAAK9J,EAAAwJ,UAAUS,GAClEnI,EAAI0I,UAAUxK,EAAAY,CAAC,eAAeH,aAAgBkc,KAAMtS,IACtD,GAGF/L,EAAAA,QAAeoD,C,mECvBf,MAAA1B,EAAAC,EAAA,OACAC,EAAAD,EAAA,OACAwzB,EAAAxzB,EAAA,OASMyB,EAA6B,CACjCzD,QAAS,QACTsM,OAAO,EACP1F,MARoC,CACpCuF,QAAS,4BACTE,OAAQ/L,IAAA,IAAC,WAAC8L,GAAW9L,EAAA,OAAKyB,EAAAY,CAAC,kBAAkByJ,OAO7CxI,IAAAA,CAAKC,GACH,MAAM,IAACvB,EAAG,KAAEE,EAAI,MAAE8J,EAAK,WAAEF,EAAU,OAAE3M,GAAUoE,EAC3CyI,GAAU7M,GAA2B,iBAAVA,EAC7BoE,EAAI0I,UAAUxK,EAAAY,CAAC,KAAI,EAAAV,EAAA0c,SAAQrc,EAAKkzB,EAAAnyB,YAAUb,MAAS4J,MAEnDvI,EAAI+H,KAAK7J,EAAAY,CAAC,GAAGlD,SAAc+C,IAE/B,GAGFnC,EAAAA,QAAeoD,C,8HCnBf,MAAA1B,EAAAC,EAAA,OACAC,EAAAD,EAAA,OACAwB,EAAAxB,EAAA,OAmBa3B,EAAAA,MAAgC,CAC3C8L,QAAS7L,IAA0C,IAAxC+L,QAAQ,SAACwW,EAAQ,UAAEyY,EAAS,KAAE9N,IAAMltB,EAC7C,MAAMi7B,EAA6B,IAAdD,EAAkB,WAAa,aACpD,OAAOv5B,EAAA2F,GAAG,aAAa6zB,KAAgB/N,mBAAsB3K,gBAE/DxW,OAAQvC,IAAA,IAAEuC,QAAQ,SAACwW,EAAQ,UAAEyY,EAAS,KAAE9N,EAAI,gBAAEU,IAAiBpkB,EAAA,OAC7D/H,EAAAY,CAAC,cAAckgB;uBACIqL;iBACNoN;YACL9N,OAGZ,MAAM/pB,EAA6B,CACjCzD,QAAS,eACTO,KAAM,SACNmD,WAAY,SACZkD,MAAAvG,EAAAuG,MACAhD,IAAAA,CAAKC,GACH,MAAO23B,EAAUC,GAMrB,SAA0BxwB,GAAqB,IAApB,OAACxL,GAAmBwL,EAC7C,MAAMywB,EAAqC,CAAC,EACtCC,EAAiC,CAAC,EACxC,IAAK,MAAM75B,KAAOrC,EAAQ,CACxB,GAAY,cAARqC,EAAqB,UACZX,MAAMC,QAAQ3B,EAAOqC,IAAQ45B,EAAeC,GACpD75B,GAAOrC,EAAOqC,EACrB,CACA,MAAO,CAAC45B,EAAcC,EACxB,CAfgCC,CAAkB/3B,GAC9Cg4B,EAAqBh4B,EAAK23B,GAC1BM,EAAmBj4B,EAAK43B,EAC1B,GAcF,SAAgBI,EACdh4B,GACqD,IAArD63B,EAAAt3B,UAAApD,OAAA,QAAAjB,IAAAqE,UAAA,GAAAA,UAAA,GAA2CP,EAAIpE,OAE/C,MAAM,IAAC6C,EAAG,KAAEE,EAAI,GAAEL,GAAM0B,EACxB,GAAyC,IAArCpC,OAAOP,KAAKw6B,GAAc16B,OAAc,OAC5C,MAAMmtB,EAAU7rB,EAAIgI,IAAI,WACxB,IAAK,MAAMlI,KAAQs5B,EAAc,CAC/B,MAAMlO,EAAOkO,EAAat5B,GAC1B,GAAoB,IAAhBorB,EAAKxsB,OAAc,SACvB,MAAM+6B,GAAc,EAAAv4B,EAAAw4B,gBAAe15B,EAAKE,EAAMJ,EAAMD,EAAGM,KAAKwc,eAC5Dpb,EAAIoqB,UAAU,CACZpL,SAAUzgB,EACVk5B,UAAW9N,EAAKxsB,OAChBwsB,KAAMA,EAAKlmB,KAAK,QAEdnF,EAAGkJ,UACL/I,EAAIU,GAAG+4B,EAAa,KAClB,IAAK,MAAME,KAAWzO,GACpB,EAAAhqB,EAAA04B,wBAAuBr4B,EAAKo4B,MAIhC35B,EAAIU,GAAGjB,EAAAY,CAAC,GAAGo5B,UAAmB,EAAAv4B,EAAA24B,kBAAiBt4B,EAAK2pB,EAAMW,QAC1D,EAAA3qB,EAAA44B,mBAAkBv4B,EAAKsqB,GACvB7rB,EAAI2kB,OAER,CACF,CAEA,SAAgB6U,EAAmBj4B,GAAmD,IAAlC83B,EAAAv3B,UAAApD,OAAA,QAAAjB,IAAAqE,UAAA,GAAAA,UAAA,GAAwBP,EAAIpE,OAC9E,MAAM,IAAC6C,EAAG,KAAEE,EAAI,QAAExC,EAAO,GAAEmC,GAAM0B,EAC3BmB,EAAQ1C,EAAI2C,KAAK,SACvB,IAAK,MAAM7C,KAAQu5B,GACb,EAAA15B,EAAA8B,mBAAkB5B,EAAIw5B,EAAWv5B,MACrCE,EAAIU,IACF,EAAAQ,EAAAw4B,gBAAe15B,EAAKE,EAAMJ,EAAMD,EAAGM,KAAKwc,eACxC,KACE,MAAMlR,EAASlK,EAAIuB,UAAU,CAACpF,UAASqF,WAAYjD,GAAO4C,GAC1DnB,EAAIurB,oBAAoBrhB,EAAQ/I,IAElC,IAAM1C,EAAI0M,IAAIhK,GAAO,IAEvBnB,EAAIG,GAAGgB,GAEX,CA7CA3E,EAAAA,qBAAAw7B,EA8BAx7B,EAAAA,mBAAAy7B,EAiBAz7B,EAAAA,QAAeoD,C,mECxGf,MAAA1B,EAAAC,EAAA,OACAC,EAAAD,EAAA,OASMyB,EAA6B,CACjCzD,QAAS,gBACTO,KAAM,SACNmD,WAAY,CAAC,SAAU,WACvBkD,MAToC,CACpCuF,QAAS,8BACTE,OAAQ/L,IAAA,IAAC,OAAC+L,GAAO/L,EAAA,OAAKyB,EAAAY,CAAC,kBAAkB0J,EAAOnC,kBAQhDtG,IAAAA,CAAKC,GACH,MAAM,IAACvB,EAAG,OAAE7C,EAAM,KAAE+C,EAAI,GAAEL,GAAM0B,EAChC,IAAI,EAAA5B,EAAA8B,mBAAkB5B,EAAI1C,GAAS,OACnC,MAAMuF,EAAQ1C,EAAI2C,KAAK,SAEvB3C,EAAIkoB,MAAM,MAAOhoB,EAAOV,IACtB+B,EAAIoqB,UAAU,CAAC/jB,aAAcpI,IAC7B+B,EAAIuB,UACF,CACEpF,QAAS,gBACTwC,KAAMV,EACNmI,UAAW,CAAC,UACZC,aAAcpI,EACdS,eAAe,GAEjByC,GAEF1C,EAAIU,IAAG,EAAAjB,EAAAqlB,KAAIpiB,GAAQ,KACjBnB,EAAI+C,OAAM,GACLzE,EAAGkJ,WAAW/I,EAAIooB,YAI3B7mB,EAAIG,GAAGgB,EACT,GAGF3E,EAAAA,QAAeoD,C,0fCxCf,MAAA44B,EAAAr6B,EAAA,OACAyQ,EAAAzQ,EAAA,OACAs6B,EAAAt6B,EAAA,IACAu6B,EAAAv6B,EAAA,OACAw6B,EAAAx6B,EAAA,KACAy6B,EAAAz6B,EAAA,OACA06B,EAAA16B,EAAA,MACAD,EAAAC,EAAA,OACAyK,EAAAzK,EAAA,OACAwQ,EAAAxQ,EAAA,OACAC,EAAAD,EAAA,OASAiqB,EAAAjqB,EAAA,OAoBA,SAAS26B,EAAgBr8B,EAEvB2qB,GAAW,IADX,IAAC3oB,EAAG,aAAEyK,EAAY,OAAEtN,EAAM,UAAEoN,EAAS,KAAEpK,GAAgBnC,EAGnDmC,EAAKmB,KAAKuT,IACZ7U,EAAIwG,KAAKiE,EAAchL,EAAAY,CAAC,GAAG8J,EAAApJ,QAAEb,SAASiK,EAAApJ,QAAEkrB,SAAU1hB,EAAUK,OAAQ,KAClE5K,EAAIsB,KAAK7B,EAAAY,CAAC,iBAAiBi6B,EAAcn9B,EAAQgD,MAiBvD,SAA8BH,EAAcG,GAC1CH,EAAIU,GACFyJ,EAAApJ,QAAEkrB,OACF,KACEjsB,EAAI0M,IAAIvC,EAAApJ,QAAE4Y,aAAcla,EAAAY,CAAC,GAAG8J,EAAApJ,QAAEkrB,UAAU9hB,EAAApJ,QAAE4Y,gBAC1C3Z,EAAI0M,IAAIvC,EAAApJ,QAAE0H,WAAYhJ,EAAAY,CAAC,GAAG8J,EAAApJ,QAAEkrB,UAAU9hB,EAAApJ,QAAE0H,cACxCzI,EAAI0M,IAAIvC,EAAApJ,QAAEoH,mBAAoB1I,EAAAY,CAAC,GAAG8J,EAAApJ,QAAEkrB,UAAU9hB,EAAApJ,QAAEoH,sBAChDnI,EAAI0M,IAAIvC,EAAApJ,QAAEmrB,SAAUzsB,EAAAY,CAAC,GAAG8J,EAAApJ,QAAEkrB,UAAU9hB,EAAApJ,QAAEmrB,YAClC/rB,EAAKgsB,YAAYnsB,EAAI0M,IAAIvC,EAAApJ,QAAEub,eAAgB7c,EAAAY,CAAC,GAAG8J,EAAApJ,QAAEkrB,UAAU9hB,EAAApJ,QAAEub,mBAEnE,KACEtc,EAAI0M,IAAIvC,EAAApJ,QAAE4Y,aAAcla,EAAAY,CAAC,MACzBL,EAAI0M,IAAIvC,EAAApJ,QAAE0H,WAAYhJ,EAAAY,CAAC,aACvBL,EAAI0M,IAAIvC,EAAApJ,QAAEoH,mBAAoB1I,EAAAY,CAAC,aAC/BL,EAAI0M,IAAIvC,EAAApJ,QAAEmrB,SAAU/hB,EAAApJ,QAAEb,MAClBC,EAAKgsB,YAAYnsB,EAAI0M,IAAIvC,EAAApJ,QAAEub,eAAgB7c,EAAAY,CAAC,OAGtD,CAlCMk6B,CAAqBv6B,EAAKG,GAC1BH,EAAIsB,KAAKqnB,KAGX3oB,EAAIwG,KAAKiE,EAAchL,EAAAY,CAAC,GAAG8J,EAAApJ,QAAEb,SAMjC,SAA2BC,GACzB,OAAOV,EAAAY,CAAC,IAAI8J,EAAApJ,QAAE4Y,oBAAoBxP,EAAApJ,QAAE0H,eAAe0B,EAAApJ,QAAEoH,uBAAuBgC,EAAApJ,QAAEmrB,YAC5E/hB,EAAApJ,QAAEb,OACDC,EAAKgsB,WAAa1sB,EAAAY,CAAC,KAAK8J,EAAApJ,QAAEub,oBAAsB7c,EAAAiM,SACrD,CAV0C8uB,CAAkBr6B,KAASoK,EAAUK,OAAQ,IACjF5K,EAAIsB,KAAKg5B,EAAcn9B,EAAQgD,IAAOmB,KAAKqnB,GAGjD,CAkDA,SAAS2R,EAAcn9B,EAAmBgD,GACxC,MAAMge,EAAyB,iBAAVhhB,GAAsBA,EAAOgD,EAAKwT,UACvD,OAAOwK,IAAUhe,EAAKmB,KAAKtC,QAAUmB,EAAKmB,KAAK6b,SAAW1d,EAAAY,CAAC,iBAAiB8d,OAAa1e,EAAAiM,GAC3F,CAGA,SAAS+uB,EAAc56B,EAAe6C,GAChCg4B,EAAY76B,KACd86B,EAAc96B,GACV+6B,EAAkB/6B,IAkB1B,SAA0BA,EAAkB6C,GAC1C,MAAM,OAACvF,EAAM,IAAE6C,EAAG,KAAEG,GAAQN,EACxBM,EAAK06B,UAAY19B,EAAO09B,UAAUC,EAAej7B,IAmCvD,SAAuBA,GACrB,MAAMse,EAAQte,EAAG1C,OAAO0C,EAAGM,KAAKwT,UAC5BwK,IAAOte,EAAGyK,QAAS,EAAA4F,EAAAkO,YAAWve,EAAGM,KAAKgL,YAAatL,EAAGyK,OAAQ6T,GACpE,EArCE4c,CAAcl7B,GAuChB,SAA0BA,GACxB,GAAIA,EAAG1C,OAAOyN,SAAW/K,EAAG0K,UAAUK,OAAQ,MAAM,IAAI1D,MAAM,8BAChE,CAxCE8zB,CAAiBn7B,GACjB,MAAMsyB,EAAYnyB,EAAI6C,MAAM,QAASsH,EAAApJ,QAAEqL,QACvC6uB,EAAgBp7B,EAAIsyB,GAEpBnyB,EAAI0M,IAAIhK,EAAOjD,EAAAY,CAAC,GAAG8xB,SAAiBhoB,EAAApJ,QAAEqL,SACxC,CA1BM8uB,CAAiBr7B,EAAI6C,IAIzB,EAAAq3B,EAAAoB,mBAAkBt7B,EAAI6C,EACxB,CAEA,SAASk4B,EAAiBpzB,GAA0B,IAAzB,OAACrK,EAAM,KAAEe,GAAgBsJ,EAClD,GAAqB,kBAAVrK,EAAqB,OAAQA,EACxC,IAAK,MAAMqC,KAAOrC,EAAQ,GAAIe,EAAKC,MAAMgb,IAAI3Z,GAAM,OAAO,EAC1D,OAAO,CACT,CAEA,SAASk7B,EAAY76B,GACnB,MAA2B,kBAAbA,EAAG1C,MACnB,CAaA,SAASw9B,EAAc96B,IACrB,EAAAF,EAAAy7B,mBAAkBv7B,GAWpB,SAA8BA,GAC5B,MAAM,OAAC1C,EAAM,cAAE6E,EAAa,KAAE7B,EAAI,KAAEjC,GAAQ2B,EACxC1C,EAAOkN,MAAQlK,EAAKsR,wBAAyB,EAAA9R,EAAAif,sBAAqBzhB,EAAQe,EAAKC,QACjFD,EAAKmQ,OAAOC,KAAK,6CAA6CtM,KAElE,CAfEq5B,CAAqBx7B,EACvB,CAEA,SAASo7B,EAAgBp7B,EAAkBsyB,GACzC,GAAItyB,EAAGM,KAAKua,IAAK,OAAO4gB,EAAez7B,EAAI,IAAI,EAAOsyB,GACtD,MAAM/zB,GAAQ,EAAA+R,EAAAkjB,gBAAexzB,EAAG1C,QAEhCm+B,EAAez7B,EAAIzB,IADE,EAAA+R,EAAAorB,wBAAuB17B,EAAIzB,GACP+zB,EAC3C,CAyBA,SAAS2I,EAAcnyB,GAA4D,IAA3D,IAAC3I,EAAG,UAAEuK,EAAS,OAAEpN,EAAM,cAAE6E,EAAa,KAAE7B,GAAmBwI,EACjF,MAAMrG,EAAMnF,EAAO09B,SACnB,IAAsB,IAAlB16B,EAAK06B,SACP76B,EAAIsB,KAAK7B,EAAAY,CAAC,GAAG8J,EAAApJ,QAAE7C,mBAAmBoE,WAC7B,GAA4B,mBAAjBnC,EAAK06B,SAAwB,CAC7C,MAAMxzB,EAAa5H,EAAA2F,GAAG,GAAGpD,aACnB6I,EAAW7K,EAAI8K,WAAW,OAAQ,CAACC,IAAKR,EAAUG,OACxD1K,EAAIsB,KAAK7B,EAAAY,CAAC,GAAG8J,EAAApJ,QAAE7C,sBAAsBoE,MAAQ+E,MAAewD,YAC9D,CACF,CAuBA,SAASywB,EACPz7B,EACAzB,EACAo9B,EACArJ,GAEA,MAAM,IAACnyB,EAAG,OAAE7C,EAAM,KAAE+C,EAAI,UAAE6I,EAAS,KAAE5I,EAAI,KAAEjC,GAAQ2B,GAC7C,MAAC1B,GAASD,EAWhB,SAASu9B,EAAcr+B,IAChB,EAAA48B,EAAA98B,gBAAeC,EAAQC,KACxBA,EAAMa,MACR+B,EAAIU,IAAG,EAAAu5B,EAAAyB,eAAct+B,EAAMa,KAAMiC,EAAMC,EAAKmS,gBAC5CqpB,EAAgB97B,EAAIzC,GACC,IAAjBgB,EAAMM,QAAgBN,EAAM,KAAOhB,EAAMa,MAAQu9B,IACnDx7B,EAAI2kB,QACJ,EAAAsV,EAAA2B,iBAAgB/7B,IAElBG,EAAIsnB,SAEJqU,EAAgB97B,EAAIzC,GAGjB2L,GAAW/I,EAAIU,GAAGjB,EAAAY,CAAC,GAAG8J,EAAApJ,QAAEqL,cAAc+lB,GAAa,KAC1D,EAzBIh1B,EAAOkN,OAASlK,EAAKsR,wBAA0B,EAAA9R,EAAAif,sBAAqBzhB,EAAQgB,IAI3EgC,EAAKua,KAwCZ,SAA0B7a,EAAkBzB,GAC1C,GAAIyB,EAAG0K,UAAU8I,OAASxT,EAAGM,KAAKsS,YAAa,QAMjD,SAA2B5S,EAAkBzB,GAC3C,IAAKA,EAAMM,OAAQ,OACnB,IAAKmB,EAAG8H,UAAUjJ,OAEhB,YADAmB,EAAG8H,UAAYvJ,GAGjBA,EAAM4C,QAASiY,IACR4iB,EAAah8B,EAAG8H,UAAWsR,IAC9B6iB,EAAiBj8B,EAAI,SAASoZ,8BAA8BpZ,EAAG8H,UAAU3C,KAAK,WAiCpF,SAA2BnF,EAAkBk8B,GAC3C,MAAMC,EAAiB,GACvB,IAAK,MAAM/iB,KAAKpZ,EAAG8H,UACbk0B,EAAaE,EAAW9iB,GAAI+iB,EAAGl3B,KAAKmU,GAC/B8iB,EAAU9Q,SAAS,YAAoB,WAANhS,GAAgB+iB,EAAGl3B,KAAK,WAEpEjF,EAAG8H,UAAYq0B,CACjB,CArCEC,CAAkBp8B,EAAIzB,EACxB,EAjBE89B,CAAkBr8B,EAAIzB,GACjByB,EAAGM,KAAKg8B,iBAkBf,SAA4Bt8B,EAAkBm8B,GACxCA,EAAGt9B,OAAS,IAAqB,IAAds9B,EAAGt9B,SAAgBs9B,EAAG/Q,SAAS,UACpD6Q,EAAiBj8B,EAAI,kDAEzB,CAtBgCu8B,CAAmBv8B,EAAIzB,IAwBvD,SAA2ByB,EAAkBm8B,GAC3C,MAAM3+B,EAAQwC,EAAG3B,KAAKC,MAAMgb,IAC5B,IAAK,MAAMzb,KAAWL,EAAO,CAC3B,MAAME,EAAOF,EAAMK,GACnB,GAAmB,iBAARH,IAAoB,EAAAy8B,EAAAx8B,eAAcqC,EAAG1C,OAAQI,GAAO,CAC7D,MAAM,KAACU,GAAQV,EAAKK,WAChBK,EAAKS,SAAWT,EAAKX,KAAM2b,GAAMojB,EAAkBL,EAAI/iB,KACzD6iB,EAAiBj8B,EAAI,iBAAiB5B,EAAK+G,KAAK,sBAAsBtH,KAE1E,CACF,CACF,CAlCE4+B,CAAkBz8B,EAAIA,EAAG8H,UAC3B,CA7CiB40B,CAAiB18B,EAAIzB,GACpC4B,EAAI0oB,MAAM,KACR,IAAK,MAAMtrB,KAASe,EAAMd,MAAOo+B,EAAcr+B,GAC/Cq+B,EAAct9B,EAAMwd,SANpB3b,EAAI0oB,MAAM,IAAM8T,EAAY38B,EAAI,OAAS1B,EAAMgb,IAAI9O,KAAczM,YAyBrE,CAEA,SAAS+9B,EAAgB97B,EAAkBzC,GACzC,MAAM,IACJ4C,EAAG,OACH7C,EACAgD,MAAM,YAACM,IACLZ,EACAY,IAAa,EAAAy5B,EAAAuC,gBAAe58B,EAAIzC,EAAMa,MAC1C+B,EAAI0oB,MAAM,KACR,IAAK,MAAMnrB,KAAQH,EAAMC,OACnB,EAAA28B,EAAAx8B,eAAcL,EAAQI,IACxBi/B,EAAY38B,EAAItC,EAAKG,QAASH,EAAKK,WAAYR,EAAMa,OAI7D,CA0CA,SAASo+B,EAAkBK,EAAmBC,GAC5C,OAAOD,EAAMzR,SAAS0R,IAAmB,WAATA,GAAqBD,EAAMzR,SAAS,UACtE,CAEA,SAAS4Q,EAAaG,EAAgB/iB,GACpC,OAAO+iB,EAAG/Q,SAAShS,IAAa,YAANA,GAAmB+iB,EAAG/Q,SAAS,SAC3D,CAWA,SAAS6Q,EAAiBj8B,EAAkByC,GAE1CA,GAAO,QADYzC,EAAG0K,UAAUD,OAASzK,EAAGmC,gCAE5C,EAAArC,EAAAY,iBAAgBV,EAAIyC,EAAKzC,EAAGM,KAAKsS,YACnC,CAtSA1U,EAAAA,qBAAA,SAAqC8B,GAC/B66B,EAAY76B,KACd86B,EAAc96B,GACV+6B,EAAkB/6B,IAmD1B,SAA0BA,GACxB,MAAM,OAAC1C,EAAM,KAAEgD,EAAI,IAAEH,GAAOH,EAC5Bw6B,EAAiBx6B,EAAI,KACfM,EAAK06B,UAAY19B,EAAO09B,UAAUC,EAAej7B,GA4EzD,SAAwBA,GACtB,MAAM,OAAC1C,EAAM,KAAEgD,GAAQN,OACApC,IAAnBN,EAAO4D,SAAyBZ,EAAKM,aAAeN,EAAK4N,eAC3D,EAAApO,EAAAY,iBAAgBV,EAAI,wCAExB,CAhFI+8B,CAAe/8B,GACfG,EAAIgI,IAAImC,EAAApJ,QAAEoL,QAAS,MACnBnM,EAAIgI,IAAImC,EAAApJ,QAAEqL,OAAQ,GACdjM,EAAKqC,aAOb,SAAwB3C,GAEtB,MAAM,IAACG,EAAG,aAAEyK,GAAgB5K,EAC5BA,EAAG0M,UAAYvM,EAAI6C,MAAM,YAAapD,EAAAY,CAAC,GAAGoK,eAC1CzK,EAAIU,GAAGjB,EAAAY,CAAC,GAAGR,EAAG0M,yBAA0B,IAAMvM,EAAIkM,OAAOzM,EAAAY,CAAC,GAAGR,EAAG0M,kBAAmB9M,EAAAY,CAAC,cACpFL,EAAIU,GAAGjB,EAAAY,CAAC,GAAGR,EAAG0M,yBAA0B,IAAMvM,EAAIkM,OAAOzM,EAAAY,CAAC,GAAGR,EAAG0M,kBAAmB9M,EAAAY,CAAC,aACtF,CAb0Bw8B,CAAeh9B,GACrCo7B,EAAgBp7B,GAkGpB,SAAuBA,GACrB,MAAM,IAACG,EAAG,UAAEuK,EAAS,aAAEE,EAAY,gBAAEsC,EAAe,KAAE5M,GAAQN,EAC1D0K,EAAUK,OAEZ5K,EAAIU,GACFjB,EAAAY,CAAC,GAAG8J,EAAApJ,QAAEqL,eACN,IAAMpM,EAAIqoB,OAAOle,EAAApJ,QAAEb,MACnB,IAAMF,EAAIgN,MAAMvN,EAAAY,CAAC,OAAO0M,KAA2B5C,EAAApJ,QAAEoL,cAGvDnM,EAAIkM,OAAOzM,EAAAY,CAAC,GAAGoK,WAAuBN,EAAApJ,QAAEoL,SACpChM,EAAKqC,aAKb,SAAwBkhB,GAA0C,IAAzC,IAAC1jB,EAAG,UAAEuM,EAAS,MAAEC,EAAK,MAAE1L,GAAiB4iB,EAC5DlX,aAAiB/M,EAAA2I,MAAMpI,EAAIkM,OAAOzM,EAAAY,CAAC,GAAGkM,UAAmBC,GACzD1L,aAAiBrB,EAAA2I,MAAMpI,EAAIkM,OAAOzM,EAAAY,CAAC,GAAGkM,UAAmBzL,EAC/D,CAR0Bg8B,CAAgBj9B,GACtCG,EAAIqoB,OAAO5oB,EAAAY,CAAC,GAAG8J,EAAApJ,QAAEqL,gBAErB,CA/GI2wB,CAAcl9B,IAGlB,CA9DMm9B,CAAiBn9B,GAIrBw6B,EAAiBx6B,EAAI,KAAM,EAAAk6B,EAAAkD,sBAAqBp9B,GAClD,EA+RA,MAAagQ,EAiBXpR,WAAAA,CAAYoB,EAAkBsB,EAA6BzD,GAezD,IAdA,EAAAy8B,EAAA+C,sBAAqBr9B,EAAIsB,EAAKzD,GAC9BqO,KAAK/L,IAAMH,EAAGG,IACd+L,KAAKhD,UAAYlJ,EAAGkJ,UACpBgD,KAAKrO,QAAUA,EACfqO,KAAK7L,KAAOL,EAAGK,KACf6L,KAAK5O,OAAS0C,EAAG1C,OAAOO,GACxBqO,KAAK/B,MAAQ7I,EAAI6I,OAASnK,EAAGM,KAAK6J,OAAS+B,KAAK5O,QAAU4O,KAAK5O,OAAO6M,MACtE+B,KAAKqmB,aAAc,EAAAzyB,EAAAw9B,gBAAet9B,EAAIkM,KAAK5O,OAAQO,EAASqO,KAAK/B,OACjE+B,KAAK3K,WAAaD,EAAIC,WACtB2K,KAAKhK,aAAelC,EAAG1C,OACvB4O,KAAKhC,OAAS,CAAC,EACfgC,KAAKlM,GAAKA,EACVkM,KAAK5K,IAAMA,EAEP4K,KAAK/B,MACP+B,KAAKjC,WAAajK,EAAGG,IAAI6C,MAAM,UAAWu6B,EAAQrxB,KAAK/B,MAAOnK,SAG9D,GADAkM,KAAKjC,WAAaiC,KAAKqmB,cAClB,EAAA+H,EAAAkD,iBAAgBtxB,KAAK5O,OAAQgE,EAAIC,WAAYD,EAAI4pB,gBACpD,MAAM,IAAI7jB,MAAM,GAAGxJ,mBAAyBuc,KAAKtZ,UAAUQ,EAAIC,gBAI/D,SAAUD,EAAMA,EAAIq3B,aAA6B,IAAfr3B,EAAIiL,UACxCL,KAAKomB,UAAYtyB,EAAGG,IAAI6C,MAAM,QAASsH,EAAApJ,QAAEqL,QAE7C,CAEAc,MAAAA,CAAO1M,EAAiB88B,EAA4BC,GAClDxxB,KAAKyxB,YAAW,EAAA/9B,EAAAqlB,KAAItkB,GAAY88B,EAAeC,EACjD,CAEAC,UAAAA,CAAWh9B,EAAiB88B,EAA4BC,GACtDxxB,KAAK/L,IAAIU,GAAGF,GACR+8B,EAAYA,IACXxxB,KAAKzH,QACNg5B,GACFvxB,KAAK/L,IAAI2kB,OACT2Y,IACIvxB,KAAKhD,WAAWgD,KAAK/L,IAAIsnB,SAEzBvb,KAAKhD,UAAWgD,KAAK/L,IAAIsnB,QACxBvb,KAAK/L,IAAI2kB,MAElB,CAEA5V,IAAAA,CAAKvO,EAAiB+8B,GACpBxxB,KAAKyxB,YAAW,EAAA/9B,EAAAqlB,KAAItkB,QAAY/C,EAAW8/B,EAC7C,CAEAj0B,IAAAA,CAAK9I,GACH,QAAkB/C,IAAd+C,EAGF,OAFAuL,KAAKzH,aACAyH,KAAKhD,WAAWgD,KAAK/L,IAAIU,IAAG,IAGnCqL,KAAK/L,IAAIU,GAAGF,GACZuL,KAAKzH,QACDyH,KAAKhD,UAAWgD,KAAK/L,IAAIsnB,QACxBvb,KAAK/L,IAAI2kB,MAChB,CAEA1a,SAAAA,CAAUzJ,GACR,IAAKuL,KAAK/B,MAAO,OAAO+B,KAAKzC,KAAK9I,GAClC,MAAM,WAACsJ,GAAciC,KACrBA,KAAKzC,KAAK7J,EAAAY,CAAC,GAAGyJ,wBAAgC,EAAArK,EAAAqO,IAAG/B,KAAK0xB,eAAgBj9B,MACxE,CAEA8D,KAAAA,CAAMo5B,EAAkBC,EAAgC3L,GACtD,GAAI2L,EAIF,OAHA5xB,KAAK4f,UAAUgS,GACf5xB,KAAK6xB,OAAOF,EAAQ1L,QACpBjmB,KAAK4f,UAAU,CAAC,GAGlB5f,KAAK6xB,OAAOF,EAAQ1L,EACtB,CAEQ4L,MAAAA,CAAOF,EAAkB1L,IAC7B0L,EAAS/T,EAAAkU,iBAAmBlU,EAAAsJ,aAAalnB,KAAMA,KAAK5K,IAAImD,MAAO0tB,EACnE,CAEA8L,UAAAA,IACE,EAAAnU,EAAAsJ,aAAYlnB,KAAMA,KAAK5K,IAAI28B,YAAcnU,EAAAoU,kBAC3C,CAEAhR,KAAAA,GACE,QAAuBtvB,IAAnBsO,KAAKomB,UAAyB,MAAM,IAAIjrB,MAAM,4CAClD,EAAAyiB,EAAAqU,kBAAiBjyB,KAAK/L,IAAK+L,KAAKomB,UAClC,CAEAzwB,EAAAA,CAAGkjB,GACI7Y,KAAKhD,WAAWgD,KAAK/L,IAAIU,GAAGkkB,EACnC,CAEA+G,SAAAA,CAAUxD,EAAuBjc,GAC3BA,EAAQ/M,OAAO+M,OAAOH,KAAKhC,OAAQoe,GAClCpc,KAAKhC,OAASoe,CACrB,CAEAqC,UAAAA,CAAW9nB,EAAau7B,GAA6C,IAAtBC,EAAAp8B,UAAApD,OAAA,QAAAjB,IAAAqE,UAAA,GAAAA,UAAA,GAAmBrC,EAAAiM,IAChEK,KAAK/L,IAAI0oB,MAAM,KACb3c,KAAKoyB,WAAWz7B,EAAOw7B,GACvBD,KAEJ,CAEAE,UAAAA,GAAoD,IAAzCz7B,EAAAZ,UAAApD,OAAA,QAAAjB,IAAAqE,UAAA,GAAAA,UAAA,GAAcrC,EAAAiM,IAAKwyB,EAAAp8B,UAAApD,OAAA,QAAAjB,IAAAqE,UAAA,GAAAA,UAAA,GAAmBrC,EAAAiM,IAC/C,IAAKK,KAAK/B,MAAO,OACjB,MAAM,IAAChK,EAAG,WAAE8J,EAAU,WAAE1I,EAAU,IAAED,GAAO4K,KAC3C/L,EAAIU,IAAG,EAAAjB,EAAAqO,IAAGrO,EAAAY,CAAC,GAAGyJ,kBAA4Bo0B,IACtCx7B,IAAUjD,EAAAiM,KAAK1L,EAAIkM,OAAOxJ,GAAO,IACjCtB,EAAW1C,QAAUyC,EAAI4S,kBAC3B/T,EAAIunB,OAAOxb,KAAK0xB,gBAChB1xB,KAAK+xB,aACDp7B,IAAUjD,EAAAiM,KAAK1L,EAAIkM,OAAOxJ,GAAO,IAEvC1C,EAAI2kB,MACN,CAEA8Y,YAAAA,GACE,MAAM,IAACz9B,EAAG,WAAE8J,EAAU,WAAE1I,EAAU,IAAED,EAAG,GAAEtB,GAAMkM,KAC/C,OAAO,EAAAtM,EAAAqO,IAEP,WACE,GAAI1M,EAAW1C,OAAQ,CAErB,KAAMoL,aAAsBrK,EAAA2I,MAAO,MAAM,IAAIlB,MAAM,4BACnD,MAAM8jB,EAAKnsB,MAAMC,QAAQsC,GAAcA,EAAa,CAACA,GACrD,OAAO3B,EAAAY,CAAC,IAAG,EAAA45B,EAAAxG,gBAAezI,EAAIlhB,EAAYjK,EAAGM,KAAKmS,cAAe2nB,EAAAvG,SAASC,QAC5E,CACA,OAAOl0B,EAAAiM,GACT,CAVU0yB,GAYV,WACE,GAAIj9B,EAAI4S,eAAgB,CACtB,MAAMsqB,EAAoBr+B,EAAI8K,WAAW,gBAAiB,CAACC,IAAK5J,EAAI4S,iBACpE,OAAOtU,EAAAY,CAAC,IAAIg+B,KAAqBv0B,IACnC,CACA,OAAOrK,EAAAiM,GACT,CAlB4B4yB,GAmB9B,CAEAx7B,SAAAA,CAAUy7B,EAAqB77B,GAC7B,MAAMI,GAAY,EAAAs3B,EAAAoE,cAAazyB,KAAKlM,GAAI0+B,IACxC,EAAAnE,EAAAqE,qBAAoB37B,EAAWiJ,KAAKlM,GAAI0+B,IACxC,EAAAnE,EAAAsE,qBAAoB57B,EAAWy7B,GAC/B,MAAMI,EAAc,IAAI5yB,KAAKlM,MAAOiD,EAAWhC,WAAOrD,EAAW+O,WAAO/O,GAExE,OADAg9B,EAAckE,EAAaj8B,GACpBi8B,CACT,CAEAl8B,cAAAA,CAAeqa,EAAsBgD,GACnC,MAAM,GAACjgB,EAAE,IAAEG,GAAO+L,KACblM,EAAGM,KAAKqC,eACI,IAAb3C,EAAG2M,YAAsC/O,IAApBqf,EAAUtQ,QACjC3M,EAAG2M,MAAQ7M,EAAA8C,eAAe+J,MAAMxM,EAAK8c,EAAUtQ,MAAO3M,EAAG2M,MAAOsT,KAEjD,IAAbjgB,EAAGiB,YAAsCrD,IAApBqf,EAAUhc,QACjCjB,EAAGiB,MAAQnB,EAAA8C,eAAe3B,MAAMd,EAAK8c,EAAUhc,MAAOjB,EAAGiB,MAAOgf,IAEpE,CAEAgN,mBAAAA,CAAoBhQ,EAAsBpa,GACxC,MAAM,GAAC7C,EAAE,IAAEG,GAAO+L,KAClB,GAAIlM,EAAGM,KAAKqC,eAA6B,IAAb3C,EAAG2M,QAA+B,IAAb3M,EAAGiB,OAElD,OADAd,EAAIU,GAAGgC,EAAO,IAAMqJ,KAAKtJ,eAAeqa,EAAWrd,EAAA2I,QAC5C,CAEX,EAGF,SAASo0B,EACP38B,EACAnC,EACAyD,EACAoM,GAEA,MAAMhM,EAAM,IAAIsO,EAAWhQ,EAAIsB,EAAKzD,GAChC,SAAUyD,EACZA,EAAIG,KAAKC,EAAKgM,GACLhM,EAAIyI,OAAS7I,EAAIyK,UAC1B,EAAAuuB,EAAAyE,iBAAgBr9B,EAAKJ,GACZ,UAAWA,GACpB,EAAAg5B,EAAA0E,kBAAiBt9B,EAAKJ,IACbA,EAAIsV,SAAWtV,EAAIyK,YAC5B,EAAAuuB,EAAAyE,iBAAgBr9B,EAAKJ,EAEzB,CA9MApD,EAAAA,WAAA8R,EAgNA,MAAMivB,EAAe,sBACfC,EAAwB,mCAC9B,SAAgB3B,EACdpzB,EAAa4Z,GACiC,IAE1CzJ,EACAja,GAHJ,UAACoI,EAAS,UAAEI,EAAS,YAAEZ,GAAuB8b,EAI9C,GAAc,KAAV5Z,EAAc,OAAOG,EAAApJ,QAAEmrB,SAC3B,GAAiB,MAAbliB,EAAM,GAAY,CACpB,IAAK80B,EAAarkB,KAAKzQ,GAAQ,MAAM,IAAI9C,MAAM,yBAAyB8C,KACxEmQ,EAAcnQ,EACd9J,EAAOiK,EAAApJ,QAAEmrB,QACX,KAAO,CACL,MAAM3oB,EAAUw7B,EAAsBpI,KAAK3sB,GAC3C,IAAKzG,EAAS,MAAM,IAAI2D,MAAM,yBAAyB8C,KACvD,MAAMg1B,GAAcz7B,EAAQ,GAE5B,GADA4W,EAAc5W,EAAQ,GACF,MAAhB4W,EAAqB,CACvB,GAAI6kB,GAAM12B,EAAW,MAAM,IAAIpB,MAAM+3B,EAAS,iBAAkBD,IAChE,OAAOl3B,EAAYQ,EAAY02B,EACjC,CACA,GAAIA,EAAK12B,EAAW,MAAM,IAAIpB,MAAM+3B,EAAS,OAAQD,IAErD,GADA9+B,EAAOwI,EAAUJ,EAAY02B,IACxB7kB,EAAa,OAAOja,CAC3B,CAEA,IAAI8lB,EAAO9lB,EACX,MAAMka,EAAWD,EAAYE,MAAM,KACnC,IAAK,MAAM6kB,KAAW9kB,EAChB8kB,IACFh/B,EAAOT,EAAAY,CAAC,GAAGH,KAAO,EAAAT,EAAAa,cAAY,EAAAX,EAAAw/B,qBAAoBD,MAClDlZ,EAAOvmB,EAAAY,CAAC,GAAG2lB,QAAW9lB,KAG1B,OAAO8lB,EAEP,SAASiZ,EAASG,EAAqBJ,GACrC,MAAO,iBAAiBI,KAAeJ,iCAAkC12B,GAC3E,CACF,CAtCAvK,EAAAA,QAAAq/B,C,qOC9hBA,MAAsBla,GAAtBnlB,EAAAA,YAAAmlB,EAOanlB,EAAAA,WAAa,wBAE1B,MAAaqK,UAAa8a,EAExBzkB,WAAAA,CAAY0I,GAEV,GADAoI,SACKxR,EAAAshC,WAAW5kB,KAAKtT,GAAI,MAAM,IAAID,MAAM,4CACzC6E,KAAK3G,IAAM+B,CACb,CAEA9H,QAAAA,GACE,OAAO0M,KAAK3G,GACd,CAEAk6B,QAAAA,GACE,OAAO,CACT,CAEA,SAAIvc,GACF,MAAO,CAAC,CAAChX,KAAK3G,KAAM,EACtB,EAlBFrH,EAAAA,KAAAqK,EAqBA,MAAa4Z,UAAckB,EAKzBzkB,WAAAA,CAAY6C,GACViO,QACAxD,KAAKma,OAAyB,kBAAT5kB,EAAoB,CAACA,GAAQA,CACpD,CAEAjC,QAAAA,GACE,OAAO0M,KAAK3G,GACd,CAEAk6B,QAAAA,GACE,GAAIvzB,KAAKma,OAAOxnB,OAAS,EAAG,OAAO,EACnC,MAAM60B,EAAOxnB,KAAKma,OAAO,GACzB,MAAgB,KAATqN,GAAwB,OAATA,CACxB,CAEA,OAAInuB,G,MACF,OAAiB,QAAVzH,EAACoO,KAAKwzB,YAAI,IAAA5hC,EAAAA,EAAToO,KAAKwzB,KAASxzB,KAAKma,OAAOtM,OAAO,CAACzS,EAAWnD,IAAgB,GAAGmD,IAAInD,IAAK,GACnF,CAEA,SAAI+e,G,MACF,OAAmB,QAAZplB,EAACoO,KAAK4T,cAAM,IAAAhiB,EAAAA,EAAXoO,KAAK4T,OAAW5T,KAAKma,OAAOtM,OAAO,CAACmJ,EAAkB/e,KACxDA,aAAaoE,IAAM2a,EAAM/e,EAAEoB,MAAQ2d,EAAM/e,EAAEoB,MAAQ,GAAK,GACrD2d,GACN,CAAC,EACN,EAeF,SAAgB1iB,EAAEm/B,GAChB,MAAMl+B,EAAmB,CAACk+B,EAAK,IAC/B,IAAI7gC,EAAI,EAAC,QAAAooB,EAAAjlB,UAAApD,OAFsC+mB,EAAe,IAAA5mB,MAAAkoB,EAAA,EAAAA,EAAA,KAAAE,EAAA,EAAAA,EAAAF,EAAAE,IAAfxB,EAAewB,EAAA,GAAAnlB,UAAAmlB,GAG9D,KAAOtoB,EAAI8mB,EAAK/mB,QACdwoB,EAAW5lB,EAAMmkB,EAAK9mB,IACtB2C,EAAKwD,KAAK06B,IAAO7gC,IAEnB,OAAO,IAAIqjB,EAAM1gB,EACnB,CApDAvD,EAAAA,MAAAikB,EAwCajkB,EAAAA,IAAM,IAAIikB,EAAM,IAI7BjkB,EAAAA,EAAAsC,EAUA,MAAMo/B,EAAO,IAAIzd,EAAM,KAEvB,SAAgB5c,EAAIo6B,GAClB,MAAMxZ,EAAmB,CAAC0Z,EAAcF,EAAK,KAC7C,IAAI7gC,EAAI,EAAC,QAAA0qB,EAAAvnB,UAAApD,OAFwC+mB,EAA4B,IAAA5mB,MAAAwqB,EAAA,EAAAA,EAAA,KAAAC,EAAA,EAAAA,EAAAD,EAAAC,IAA5B7D,EAA4B6D,EAAA,GAAAxnB,UAAAwnB,GAG7E,KAAO3qB,EAAI8mB,EAAK/mB,QACdsnB,EAAKlhB,KAAK26B,GACVvY,EAAWlB,EAAMP,EAAK9mB,IACtBqnB,EAAKlhB,KAAK26B,EAAMC,EAAcF,IAAO7gC,KAGvC,OASF,SAAkBqnB,GAChB,IAAIrnB,EAAI,EACR,KAAOA,EAAIqnB,EAAKtnB,OAAS,GAAG,CAC1B,GAAIsnB,EAAKrnB,KAAO8gC,EAAM,CACpB,MAAMnH,EAAMqH,EAAe3Z,EAAKrnB,EAAI,GAAIqnB,EAAKrnB,EAAI,IACjD,QAAYlB,IAAR66B,EAAmB,CACrBtS,EAAK1M,OAAO3a,EAAI,EAAG,EAAG25B,GACtB,QACF,CACAtS,EAAKrnB,KAAO,GACd,CACAA,GACF,CACF,CAvBEoT,CAASiU,GACF,IAAIhE,EAAMgE,EACnB,CAEA,SAAgBkB,EAAW5lB,EAAkBs+B,GAuC7C,IAAqB9gB,EAtCf8gB,aAAe5d,EAAO1gB,EAAKwD,QAAQ86B,EAAI1Z,QAClC0Z,aAAex3B,EAAM9G,EAAKwD,KAAK86B,GACnCt+B,EAAKwD,KAqCS,iBADAga,EApCQ8gB,IAqCgB,kBAAL9gB,GAAwB,OAANA,EACpDA,EACA4gB,EAAc7gC,MAAMC,QAAQggB,GAAKA,EAAE9Z,KAAK,KAAO8Z,GAtCrD,CAiBA,SAAS6gB,EAAephC,EAAaC,GACnC,GAAU,OAANA,EAAY,OAAOD,EACvB,GAAU,OAANA,EAAY,OAAOC,EACvB,GAAgB,iBAALD,EAAe,CACxB,GAAIC,aAAa4J,GAA4B,MAApB7J,EAAEA,EAAEG,OAAS,GAAY,OAClD,MAAgB,iBAALF,EAAsB,GAAGD,EAAE6I,MAAM,GAAI,KAAK5I,KACxC,MAATA,EAAE,GAAmBD,EAAE6I,MAAM,GAAI,GAAK5I,EAAE4I,MAAM,QAClD,CACF,CACA,MAAgB,iBAAL5I,GAA0B,MAATA,EAAE,IAAgBD,aAAa6J,OAA3D,EAAyE,IAAI7J,IAAIC,EAAE4I,MAAM,IAE3F,CAiBA,SAAgBs4B,EAAc5gB,GAC5B,OAAO7E,KAAKtZ,UAAUme,GACnB/X,QAAQ,UAAW,WACnBA,QAAQ,UAAW,UACxB,CAjEAhJ,EAAAA,IAAAqH,EAYArH,EAAAA,WAAAmpB,EAkCAnpB,EAAAA,UAAA,SAA0B8hC,EAAUC,GAClC,OAAOA,EAAGR,WAAaO,EAAKA,EAAGP,WAAaQ,EAAK16B,CAAG,GAAGy6B,IAAKC,GAC9D,EASA/hC,EAAAA,UAAA,SAA0B+gB,GACxB,OAAO,IAAIkD,EAAM0d,EAAc5gB,GACjC,EAEA/gB,EAAAA,cAAA2hC,EAMA3hC,EAAAA,YAAA,SAA4ByB,GAC1B,MAAqB,iBAAPA,GAAmBzB,EAAAshC,WAAW5kB,KAAKjb,GAAO,IAAIwiB,EAAM,IAAIxiB,KAASa,CAAC,IAAIb,IACtF,EAGAzB,EAAAA,iBAAA,SAAiCyB,GAC/B,GAAkB,iBAAPA,GAAmBzB,EAAAshC,WAAW5kB,KAAKjb,GAC5C,OAAO,IAAIwiB,EAAM,GAAGxiB,KAEtB,MAAM,IAAI0H,MAAM,iCAAiC1H,mCACnD,EAEAzB,EAAAA,WAAA,SAA2BwuB,GACzB,OAAO,IAAIvK,EAAMuK,EAAGltB,WACtB,C,iHCtKatB,EAAAA,mBAAiC,CAC5C,QACA,cACA,UACA,aACA,WACA,YACA,YAGWA,EAAAA,kBAAgC,CAC3C,mBACA,kBACA,gB,mECbF,MAAA0B,EAAAC,EAAA,OACAC,EAAAD,EAAA,OACAwzB,EAAAxzB,EAAA,OASMyB,EAA6B,CACjCzD,QAAS,OACT0D,WAAY,QACZ4I,OAAO,EACP1F,MAToC,CACpCuF,QAAS,6CACTE,OAAQ/L,IAAA,IAAC,WAAC8L,GAAW9L,EAAA,OAAKyB,EAAAY,CAAC,mBAAmByJ,OAQ9CxI,IAAAA,CAAKC,GACH,MAAM,IAACvB,EAAG,KAAEE,EAAI,MAAE8J,EAAK,OAAE7M,EAAM,WAAE2M,EAAU,GAAEjK,GAAM0B,EACnD,IAAKyI,GAA2B,IAAlB7M,EAAOuB,OAAc,MAAM,IAAIwI,MAAM,kCACnD,MAAM64B,EAAU5iC,EAAOuB,QAAUmB,EAAGM,KAAKgT,SACzC,IAAI2gB,EACJ,MAAMkM,EAASA,IAAgB,OAAHlM,QAAG,IAAHA,EAAAA,EAAAA,GAAQ,EAAAn0B,EAAA0c,SAAQrc,EAAKkzB,EAAAnyB,SAEjD,IAAI2B,EACJ,GAAIq9B,GAAW/1B,EACbtH,EAAQ1C,EAAIgI,IAAI,SAChBzG,EAAIipB,WAAW9nB,EASjB,WACE1C,EAAIkM,OAAOxJ,GAAO,GAClB1C,EAAIgoB,MAAM,IAAKle,EAAqBuB,GAClCrL,EAAIU,GAAGjB,EAAAY,CAAC,GAAG2/B,OAAY9/B,MAASmL,KAAM,IAAMrL,EAAIkM,OAAOxJ,GAAO,GAAM0lB,SAExE,OAbO,CAEL,IAAKvpB,MAAMC,QAAQ3B,GAAS,MAAM,IAAI+J,MAAM,4BAC5C,MAAM+4B,EAAUjgC,EAAI6C,MAAM,UAAWiH,GACrCpH,GAAQ,EAAAjD,EAAAqO,OAAM3Q,EAAOuc,IAAI,CAAC1F,EAAarV,IAWzC,SAAmBshC,EAAethC,GAChC,MAAMsC,EAAM9D,EAAOwB,GACnB,MAAsB,kBAARsC,GAA4B,OAARA,EAC9BxB,EAAAY,CAAC,GAAG2/B,OAAY9/B,MAAS+/B,KAAWthC,MACpCc,EAAAY,CAAC,GAAGH,SAAYe,GACtB,CAhBuDi/B,CAAUD,EAASthC,IAC1E,CACA4C,EAAIwN,KAAKrM,EAeX,GAGF3E,EAAAA,QAAeoD,C,iMC9Cf,MAAA6O,EAAAtQ,EAAA,OACAs6B,EAAAt6B,EAAA,IACAiqB,EAAAjqB,EAAA,OACAD,EAAAC,EAAA,OACAC,EAAAD,EAAA,OAEA,IAAYg0B,EAoBZ,SAAgB3a,EAAaijB,GAC3B,MAAM59B,EAAmBS,MAAMC,QAAQk9B,GAAMA,EAAKA,EAAK,CAACA,GAAM,GAC9D,GAAI59B,EAAM+hC,MAAMnwB,EAAAowB,YAAa,OAAOhiC,EACpC,MAAM,IAAI8I,MAAM,wCAA0C9I,EAAM4G,KAAK,KACvE,EAxBA,SAAY0uB,GACVA,EAAAA,EAAA,qBACAA,EAAAA,EAAA,gBACD,CAHD,CAAYA,IAAQ31B,EAAAA,SAAR21B,EAAQ,KAKpB31B,EAAAA,eAAA,SAA+BZ,GAC7B,MAAMiB,EAAQ2a,EAAa5b,EAAOc,MAElC,GADgBG,EAAM6sB,SAAS,SAE7B,IAAwB,IAApB9tB,EAAOwT,SAAoB,MAAM,IAAIzJ,MAAM,8CAC1C,CACL,IAAK9I,EAAMM,aAA8BjB,IAApBN,EAAOwT,SAC1B,MAAM,IAAIzJ,MAAM,6CAEM,IAApB/J,EAAOwT,UAAmBvS,EAAM0G,KAAK,OAC3C,CACA,OAAO1G,CACT,EAGAL,EAAAA,aAAAgb,EAMAhb,EAAAA,uBAAA,SAAuC8B,EAAkBzB,GACvD,MAAM,IAAC4B,EAAG,KAAEE,EAAI,KAAEC,GAAQN,EACpBwgC,EAeR,SAAuBjiC,EAAmBkiC,GACxC,OAAOA,EACHliC,EAAMstB,OAAQzS,GAAMsnB,EAAU5hB,IAAI1F,IAAuB,UAAhBqnB,GAAiC,UAANrnB,GACpE,EACN,CAnBmBunB,CAAcpiC,EAAO+B,EAAKmgC,aACrCG,EACJriC,EAAMM,OAAS,KACO,IAApB2hC,EAAS3hC,QAAiC,IAAjBN,EAAMM,SAAgB,EAAAs7B,EAAA0G,uBAAsB7gC,EAAIzB,EAAM,KACnF,GAAIqiC,EAAY,CACd,MAAMjN,EAAYC,EAAer1B,EAAO8B,EAAMC,EAAKmS,cAAeohB,EAASC,OAC3E3zB,EAAIU,GAAG8yB,EAAW,KACZ6M,EAAS3hC,OAcnB,SAAoBmB,EAAkBzB,EAAmBiiC,GACvD,MAAM,IAACrgC,EAAG,KAAEE,EAAI,KAAEC,GAAQN,EACpB6b,EAAW1b,EAAIgI,IAAI,WAAYvI,EAAAY,CAAC,UAAUH,KAC1CygC,EAAU3gC,EAAIgI,IAAI,UAAWvI,EAAAY,CAAC,aACX,UAArBF,EAAKmgC,aACPtgC,EAAIU,GAAGjB,EAAAY,CAAC,GAAGqb,kCAAyCxb,SAAYA,gBAAoB,IAClFF,EACGkM,OAAOhM,EAAMT,EAAAY,CAAC,GAAGH,QACjBgM,OAAOwP,EAAUjc,EAAAY,CAAC,UAAUH,KAC5BQ,GAAG+yB,EAAer1B,EAAO8B,EAAMC,EAAKmS,eAAgB,IAAMtS,EAAIkM,OAAOy0B,EAASzgC,KAGrFF,EAAIU,GAAGjB,EAAAY,CAAC,GAAGsgC,mBACX,IAAK,MAAM1nB,KAAKonB,GACVE,EAAU5hB,IAAI1F,IAAa,UAANA,GAAsC,UAArB9Y,EAAKmgC,cAC7CM,EAAmB3nB,GAYvB,SAAS2nB,EAAmB3nB,GAC1B,OAAQA,GACN,IAAK,SAMH,YALAjZ,EACGunB,OAAO9nB,EAAAY,CAAC,GAAGqb,oBAA2BA,kBACtCxP,OAAOy0B,EAASlhC,EAAAY,CAAC,QAAQH,KACzBqnB,OAAO9nB,EAAAY,CAAC,GAAGH,cACXgM,OAAOy0B,EAASlhC,EAAAY,CAAC,MAEtB,IAAK,SAOH,YANAL,EACGunB,OACC9nB,EAAAY,CAAC,GAAGqb,qBAA4Bxb;oBACxBwb,oBAA2Bxb,QAAWA,SAAYA,MAE3DgM,OAAOy0B,EAASlhC,EAAAY,CAAC,IAAIH,KAE1B,IAAK,UAOH,YANAF,EACGunB,OACC9nB,EAAAY,CAAC,GAAGqb,sBAA6Bxb;oBACzBwb,qBAA4Bxb,QAAWA,SAAYA,UAAaA,WAEzEgM,OAAOy0B,EAASlhC,EAAAY,CAAC,IAAIH,KAE1B,IAAK,UAMH,YALAF,EACGunB,OAAO9nB,EAAAY,CAAC,GAAGH,oBAAuBA,cAAiBA,cACnDgM,OAAOy0B,GAAS,GAChBpZ,OAAO9nB,EAAAY,CAAC,GAAGH,mBAAsBA,WACjCgM,OAAOy0B,GAAS,GAErB,IAAK,OAGH,OAFA3gC,EAAIunB,OAAO9nB,EAAAY,CAAC,GAAGH,eAAkBA,cAAiBA,oBAClDF,EAAIkM,OAAOy0B,EAAS,MAGtB,IAAK,QACH3gC,EACGunB,OACC9nB,EAAAY,CAAC,GAAGqb,qBAA4BA;mBACzBA,sBAA6Bxb,cAErCgM,OAAOy0B,EAASlhC,EAAAY,CAAC,IAAIH,MAE9B,CAtDAF,EAAI2kB,OACJiX,EAAgB/7B,GAChBG,EAAIsnB,QAEJtnB,EAAIU,GAAGjB,EAAAY,CAAC,GAAGsgC,kBAAyB,KAClC3gC,EAAIkM,OAAOhM,EAAMygC,GAoDrB,SAAyB3iC,EAAsDgoB,GAAU,IAA/D,IAAChmB,EAAG,WAAEyI,EAAU,mBAAEN,GAAiCnK,EAE3EgC,EAAIU,GAAGjB,EAAAY,CAAC,GAAGoI,kBAA4B,IACrCzI,EAAIkM,OAAOzM,EAAAY,CAAC,GAAGoI,KAAcN,KAAuB6d,GAExD,CAxDI6a,CAAiBhhC,EAAI8gC,IAiDzB,CAvF2BG,CAAWjhC,EAAIzB,EAAOiiC,GACtCzE,EAAgB/7B,IAEzB,CACA,OAAO4gC,CACT,EAEA,MAAMF,EAA2B,IAAI/3B,IAAI,CAAC,SAAU,SAAU,UAAW,UAAW,SAyFpF,SAAgBkzB,EACdhgB,EACAxb,EACA6gC,GAC0B,IAA1BC,EAAOl/B,UAAApD,OAAA,QAAAjB,IAAAqE,UAAA,GAAAA,UAAA,GAAG4xB,EAASuN,QAEnB,MAAMhf,EAAK+e,IAAYtN,EAASuN,QAAUxhC,EAAAwJ,UAAUgZ,GAAKxiB,EAAAwJ,UAAUiZ,IACnE,IAAI0C,EACJ,OAAQlJ,GACN,IAAK,OACH,OAAOjc,EAAAY,CAAC,GAAGH,KAAQ+hB,SACrB,IAAK,QACH2C,EAAOnlB,EAAAY,CAAC,iBAAiBH,KACzB,MACF,IAAK,SACH0kB,EAAOnlB,EAAAY,CAAC,GAAGH,eAAkBA,mCAAsCA,KACnE,MACF,IAAK,UACH0kB,EAAOsc,EAAQzhC,EAAAY,CAAC,KAAKH,oBAAuBA,MAC5C,MACF,IAAK,SACH0kB,EAAOsc,IACP,MACF,QACE,OAAOzhC,EAAAY,CAAC,UAAUH,KAAQ+hB,KAAMvG,IAEpC,OAAOslB,IAAYtN,EAASuN,QAAUrc,GAAO,EAAAnlB,EAAAqlB,KAAIF,GAEjD,SAASsc,IAAyB,IAAjBC,EAAAr/B,UAAApD,OAAA,QAAAjB,IAAAqE,UAAA,GAAAA,UAAA,GAAcrC,EAAAiM,IAC7B,OAAO,EAAAjM,EAAAqsB,KAAIrsB,EAAAY,CAAC,UAAUH,gBAAoBihC,EAAOJ,EAAathC,EAAAY,CAAC,YAAYH,KAAUT,EAAAiM,IACvF,CACF,CAEA,SAAgB+nB,EACd9rB,EACAzH,EACA6gC,EACAC,GAEA,GAAyB,IAArBr5B,EAAUjJ,OACZ,OAAOg9B,EAAc/zB,EAAU,GAAIzH,EAAM6gC,EAAYC,GAEvD,IAAIpc,EACJ,MAAMxmB,GAAQ,EAAAuB,EAAAyhC,QAAOz5B,GACrB,GAAIvJ,EAAM8gB,OAAS9gB,EAAM+gB,OAAQ,CAC/B,MAAMkiB,EAAS5hC,EAAAY,CAAC,UAAUH,gBAC1B0kB,EAAOxmB,EAAMkhB,KAAO+hB,EAAS5hC,EAAAY,CAAC,IAAIH,QAAWmhC,WACtCjjC,EAAMkhB,YACNlhB,EAAM8gB,aACN9gB,EAAM+gB,MACf,MACEyF,EAAOnlB,EAAAiM,IAELtN,EAAM4gB,eAAe5gB,EAAMghB,QAC/B,IAAK,MAAMnG,KAAK7a,EAAOwmB,GAAO,EAAAnlB,EAAAqsB,KAAIlH,EAAM8W,EAAcziB,EAAe/Y,EAAM6gC,EAAYC,IACvF,OAAOpc,CACT,CAxDA7mB,EAAAA,cAAA29B,EAiCA39B,EAAAA,eAAA01B,EA2BA,MAAM6N,EAAoC,CACxCz3B,QAASrC,IAAA,IAAC,OAACrK,GAAOqK,EAAA,MAAK,WAAWrK,KAClC4M,OAAQpB,IAAA,IAAC,OAACxL,EAAM,YAAEi1B,GAAYzpB,EAAA,MACX,iBAAVxL,EAAqBsC,EAAAY,CAAC,UAAUlD,KAAYsC,EAAAY,CAAC,UAAU+xB,OAGlE,SAAgBwJ,EAAgB/7B,GAC9B,MAAM0B,EAIR,SAA6B1B,GAC3B,MAAM,IAACG,EAAG,KAAEE,EAAI,OAAE/C,GAAU0C,EACtBiK,GAAa,EAAAnK,EAAAw9B,gBAAet9B,EAAI1C,EAAQ,QAC9C,MAAO,CACL6C,MACAtC,QAAS,OACTwC,OACA/C,OAAQA,EAAOc,KACf6L,aACAsoB,YAAatoB,EACb/H,aAAc5E,EACd4M,OAAQ,CAAC,EACTlK,KAEJ,CAlBc0hC,CAAoB1hC,IAChC,EAAA8pB,EAAAsJ,aAAY1xB,EAAK+/B,EACnB,CAHAvjC,EAAAA,gBAAA69B,C,2zFCjNA,MAAAjL,EAAAjxB,EAAA,MAEMyB,EAA6B,CACjCzD,QAAS,cACTO,KAAM,QACNmD,WAAY,CAAC,SACbC,OAAQ,cACRC,KAAOC,IAAQ,EAAAovB,EAAAnvB,eAAcD,EAAK,UAGpCxD,EAAAA,QAAeoD,C,mECVf,MAAAuO,EAAAhQ,EAAA,OACAwB,EAAAxB,EAAA,OACAC,EAAAD,EAAA,OACAsxB,EAAAtxB,EAAA,OAEMyB,EAA6B,CACjCzD,QAAS,aACTO,KAAM,SACNmD,WAAY,SACZE,IAAAA,CAAKC,GACH,MAAM,IAACvB,EAAG,OAAE7C,EAAM,aAAE4E,EAAY,KAAE7B,EAAI,GAAEL,GAAM0B,EACb,QAA7B1B,EAAGM,KAAKqhC,uBAAoE/jC,IAAtCsE,EAAa0/B,sBACrDzQ,EAAAjwB,QAAMO,KAAK,IAAIoO,EAAAG,WAAWhQ,EAAImxB,EAAAjwB,QAAO,yBAEvC,MAAM2gC,GAAW,EAAAxgC,EAAAsqB,qBAAoBruB,GACrC,IAAK,MAAM2C,KAAQ4hC,EACjB7hC,EAAG0I,kBAAkBwU,IAAIjd,GAEvBD,EAAGM,KAAKqC,aAAek/B,EAAShjC,SAAuB,IAAbmB,EAAG2M,QAC/C3M,EAAG2M,MAAQ7M,EAAA8C,eAAe+J,MAAMxM,GAAK,EAAAL,EAAAyhC,QAAOM,GAAW7hC,EAAG2M,QAE5D,MAAM3L,EAAa6gC,EAAShW,OAAQhU,KAAO,EAAA/X,EAAA8B,mBAAkB5B,EAAI1C,EAAOua,KACxE,GAA0B,IAAtB7W,EAAWnC,OAAc,OAC7B,MAAMgE,EAAQ1C,EAAI2C,KAAK,SAEvB,IAAK,MAAM7C,KAAQe,EACb8gC,EAAW7hC,GACb8hC,EAAoB9hC,IAEpBE,EAAIU,IAAG,EAAAQ,EAAAw4B,gBAAe15B,EAAKE,EAAMJ,EAAMD,EAAGM,KAAKwc,gBAC/CilB,EAAoB9hC,GACfD,EAAGkJ,WAAW/I,EAAI2kB,OAAOjY,IAAIhK,GAAO,GACzC1C,EAAIsnB,SAEN/lB,EAAI1B,GAAG0I,kBAAkBwU,IAAIjd,GAC7ByB,EAAIG,GAAGgB,GAGT,SAASi/B,EAAW7hC,GAClB,OAAOD,EAAGM,KAAKM,cAAgBZ,EAAGI,oBAA0CxC,IAAzBN,EAAO2C,GAAMiB,OAClE,CAEA,SAAS6gC,EAAoB9hC,GAC3ByB,EAAIuB,UACF,CACEpF,QAAS,aACTqF,WAAYjD,EACZkD,SAAUlD,GAEZ4C,EAEJ,CACF,GAGF3E,EAAAA,QAAeoD,C,mECxDf,MAAA+zB,EAAAx1B,EAAA,OAGEw1B,EAAY5zB,KAAO,0CAErBvD,EAAAA,QAAem3B,C,8KCJf,MAAA2M,EAAAniC,EAAA,OACAoiC,EAAApiC,EAAA,OACAqiC,EAAAriC,EAAA,OACAsiC,EAAAtiC,EAAA,OAEMuiC,EAAoB,CAAC,eAErBC,EAAiB,yCAEvB,MAAa5tB,UAAYutB,EAAA9gC,QACvB6U,gBAAAA,GACErG,MAAMqG,mBACNksB,EAAA/gC,QAAmBC,QAASqK,GAAMU,KAAKyM,cAAcnN,IACjDU,KAAK5L,KAAKgiC,eAAep2B,KAAKmK,WAAW6rB,EAAAhhC,QAC/C,CAEA8U,qBAAAA,GAEE,GADAtG,MAAMsG,yBACD9J,KAAK5L,KAAKkT,KAAM,OACrB,MAAM0G,EAAahO,KAAK5L,KAAK6J,MACzB+B,KAAK+N,gBAAgBkoB,EAAkBC,GACvCD,EACJj2B,KAAKiK,cAAc+D,EAAYmoB,GAAgB,GAC/Cn2B,KAAKyI,KAAK,iCAAmC0tB,CAC/C,CAEA5rB,WAAAA,GACE,OAAQvK,KAAK5L,KAAKmW,YAChB/G,MAAM+G,gBAAkBvK,KAAKyK,UAAU0rB,GAAkBA,OAAiBzkC,EAC9E,EApBFM,EAAAA,IAAAuW,EAuBAjW,EAAON,QAAUA,EAAUuW,EAC3BjW,EAAON,QAAQuW,IAAMA,EACrBnV,OAAOijC,eAAerkC,EAAS,aAAc,CAACqR,OAAO,IAErDrR,EAAAA,QAAeuW,EA0Bf,IAAA5E,EAAAhQ,EAAA,OAAQP,OAAAA,eAAAA,EAAAA,aAAAA,CAAAwQ,YAAA,EAAAC,IAAA,kBAAAF,EAAAG,UAAU,IAIlB,IAAApQ,EAAAC,EAAA,OAAQP,OAAAA,eAAAA,EAAAA,IAAAA,CAAAwQ,YAAA,EAAAC,IAAA,kBAAAnQ,EAAAY,CAAC,IAAElB,OAAAA,eAAAA,EAAAA,MAAAA,CAAAwQ,YAAA,EAAAC,IAAA,kBAAAnQ,EAAA2F,GAAG,IAAEjG,OAAAA,eAAAA,EAAAA,YAAAA,CAAAwQ,YAAA,EAAAC,IAAA,kBAAAnQ,EAAAkB,SAAS,IAAExB,OAAAA,eAAAA,EAAAA,MAAAA,CAAAwQ,YAAA,EAAAC,IAAA,kBAAAnQ,EAAAiM,GAAG,IAAEvM,OAAAA,eAAAA,EAAAA,OAAAA,CAAAwQ,YAAA,EAAAC,IAAA,kBAAAnQ,EAAA2I,IAAI,IAAQjJ,OAAAA,eAAAA,EAAAA,UAAAA,CAAAwQ,YAAA,EAAAC,IAAA,kBAAAnQ,EAAAqQ,OAAO,IACnD,IAAAC,EAAArQ,EAAA,OAAQP,OAAAA,eAAAA,EAAAA,kBAAAA,CAAAwQ,YAAA,EAAAC,IAAA,kBAAAG,EAAAhP,OAAO,IACf,IAAAmJ,EAAAxK,EAAA,OAAQP,OAAAA,eAAAA,EAAAA,kBAAAA,CAAAwQ,YAAA,EAAAC,IAAA,kBAAA1F,EAAAnJ,OAAO,G,mECrEf,MAAAshC,EAAA3iC,EAAA,OAQA4iC,EAAA5iC,EAAA,OAGAD,EAAAC,EAAA,OAgBM6iC,EAAW,IAAI9iC,EAAA2I,KAAK,eACpBo6B,EAAW,IAAI/iC,EAAA2I,KAAK,eAEpBq6B,EAA+B,SACnCjzB,GAEO,IADPrP,EAAA2B,UAAApD,OAAA,QAAAjB,IAAAqE,UAAA,GAAAA,UAAA,GAA6B,CAACgU,UAAU,GAExC,GAAIjX,MAAMC,QAAQqB,GAEhB,OADAuiC,EAAWlzB,EAAKrP,EAAMkiC,EAAA7L,YAAa+L,GAC5B/yB,EAET,MAAO9B,EAASi1B,GACA,SAAdxiC,EAAKyiC,KAAkB,CAACP,EAAAQ,YAAaL,GAAY,CAACH,EAAA7L,YAAa+L,GAIjE,OAFAG,EAAWlzB,EADErP,EAAKuN,SAAW20B,EAAAS,YACPp1B,EAASi1B,GAC3BxiC,EAAK2V,WAAU,EAAAwsB,EAAAvhC,SAAYyO,GACxBA,CACT,EASA,SAASkzB,EAAWlzB,EAAUuzB,EAAoBC,EAAoBL,G,QAC/C,QAArBhlC,GAAAuU,EAAA1C,EAAIrP,KAAKmB,MAAKoM,eAAO,IAAA/P,IAAAuU,EAAPxE,QAAYjO,EAAAY,CAAC,uCAAuCsiC,KAClE,IAAK,MAAMtO,KAAK0O,EAAMvzB,EAAI+J,UAAU8a,EAAG2O,EAAG3O,GAC5C,CAVAoO,EAAc7yB,IAAM,SAACjN,GACnB,MACM0xB,GADmB,UADYvyB,UAAApD,OAAA,QAAAjB,IAAAqE,UAAA,GAAAA,UAAA,GAAmB,QACtBugC,EAAAQ,YAAcR,EAAA7L,aAC9B7zB,GAClB,IAAK0xB,EAAG,MAAM,IAAIntB,MAAM,mBAAmBvE,MAC3C,OAAO0xB,CACT,EAOAh2B,EAAON,QAAUA,EAAU0kC,EAC3BtjC,OAAOijC,eAAerkC,EAAS,aAAc,CAACqR,OAAO,IAErDrR,EAAAA,QAAe0kC,C,YC3Df,IAAI7T,EAAWvwB,EAAON,QAAU,SAAUZ,EAAQgD,EAAM8iC,GAEnC,mBAAR9iC,IACT8iC,EAAK9iC,EACLA,EAAO,CAAC,GAOV+iC,EAAU/iC,EAHc,mBADxB8iC,EAAK9iC,EAAK8iC,IAAMA,GACsBA,EAAKA,EAAGE,KAAO,WAAY,EACtDF,EAAGtnB,MAAQ,WAAY,EAEPxe,EAAQ,GAAIA,EACzC,EAoDA,SAAS+lC,EAAU/iC,EAAMgjC,EAAKxnB,EAAMxe,EAAQwyB,EAASyT,EAAYxT,EAAeyT,EAAethC,EAAcuhC,GAC3G,GAAInmC,GAA2B,iBAAVA,IAAuB0B,MAAMC,QAAQ3B,GAAS,CAEjE,IAAK,IAAIqC,KADT2jC,EAAIhmC,EAAQwyB,EAASyT,EAAYxT,EAAeyT,EAAethC,EAAcuhC,GAC7DnmC,EAAQ,CACtB,IAAI8D,EAAM9D,EAAOqC,GACjB,GAAIX,MAAMC,QAAQmC,IAChB,GAAIzB,KAAOovB,EAAS2U,cAClB,IAAK,IAAI5kC,EAAE,EAAGA,EAAEsC,EAAIvC,OAAQC,IAC1BukC,EAAU/iC,EAAMgjC,EAAKxnB,EAAM1a,EAAItC,GAAIgxB,EAAU,IAAMnwB,EAAM,IAAMb,EAAGykC,EAAYzT,EAASnwB,EAAKrC,EAAQwB,QAEnG,GAAIa,KAAOovB,EAAS4U,eACzB,GAAIviC,GAAqB,iBAAPA,EAChB,IAAK,IAAInB,KAAQmB,EACfiiC,EAAU/iC,EAAMgjC,EAAKxnB,EAAM1a,EAAInB,GAAO6vB,EAAU,IAAMnwB,EAAM,IAAMikC,EAAc3jC,GAAOsjC,EAAYzT,EAASnwB,EAAKrC,EAAQ2C,QAEpHN,KAAOovB,EAAS9Y,UAAa3V,EAAKuvB,WAAalwB,KAAOovB,EAAS8U,gBACxER,EAAU/iC,EAAMgjC,EAAKxnB,EAAM1a,EAAK0uB,EAAU,IAAMnwB,EAAK4jC,EAAYzT,EAASnwB,EAAKrC,EAEnF,CACAwe,EAAKxe,EAAQwyB,EAASyT,EAAYxT,EAAeyT,EAAethC,EAAcuhC,EAChF,CACF,CAGA,SAASG,EAAcr+B,GACrB,OAAOA,EAAI2B,QAAQ,KAAM,MAAMA,QAAQ,MAAO,KAChD,CA3EA6nB,EAAS9Y,SAAW,CAClB6tB,iBAAiB,EACjB7iC,OAAO,EACP8iC,UAAU,EACVnC,sBAAsB,EACtBoC,eAAe,EACf/e,KAAK,EACLpkB,IAAI,EACJojC,MAAM,EACNnf,MAAM,GAGRiK,EAAS2U,cAAgB,CACvBziC,OAAO,EACPijC,OAAO,EACP9nB,OAAO,EACP+nB,OAAO,GAGTpV,EAAS4U,cAAgB,CACvBS,OAAO,EACPxrB,aAAa,EACb5X,YAAY,EACZqjC,mBAAmB,EACnB/Y,cAAc,GAGhByD,EAAS8U,aAAe,CACtB3iC,SAAS,EACTojC,MAAM,EACNthC,OAAO,EACPuhC,UAAU,EACVj7B,SAAS,EACTK,SAAS,EACTG,kBAAkB,EAClBC,kBAAkB,EAClBy6B,YAAY,EACZC,WAAW,EACXC,WAAW,EACXlY,SAAS,EACTxe,QAAQ,EACRzL,UAAU,EACVD,UAAU,EACVgP,aAAa,EACbqzB,eAAe,EACfC,eAAe,E,mECvDjB,MAAAvjC,EAAAxB,EAAA,OACAD,EAAAC,EAAA,OACAyK,EAAAzK,EAAA,OAEAC,EAAAD,EAAA,OAaMyB,EAAsD,CAC1DzD,QAAS,uBACTO,KAAM,CAAC,UACPmD,WAAY,CAAC,UAAW,UACxB2pB,gBAAgB,EAChByN,aAAa,EACbl0B,MAXoC,CACpCuF,QAAS,sCACTE,OAAQ/L,IAAA,IAAC,OAAC+L,GAAO/L,EAAA,OAAKyB,EAAAY,CAAC,wBAAwB0J,EAAO26B,wBAUtDpjC,IAAAA,CAAKC,GACH,MAAM,IAACvB,EAAG,OAAE7C,EAAM,aAAE4E,EAAY,KAAE7B,EAAI,UAAEiyB,EAAS,GAAEtyB,GAAM0B,EAEzD,IAAK4wB,EAAW,MAAM,IAAIjrB,MAAM,4BAChC,MAAM,UAAC6B,EAAS,KAAE5I,GAAQN,EAE1B,GADAA,EAAG2M,OAAQ,EACmB,QAA1BrM,EAAKqhC,mBAA8B,EAAA7hC,EAAA8B,mBAAkB5B,EAAI1C,GAAS,OACtE,MAAMqP,GAAQ,EAAAtL,EAAAsqB,qBAAoBzpB,EAAalB,YACzC8jC,GAAW,EAAAzjC,EAAAsqB,qBAAoBzpB,EAAamiC,mBA4BlD,SAASU,EAAiBplC,GACxBQ,EAAIsB,KAAK7B,EAAAY,CAAC,UAAUH,KAAQV,KAC9B,CAEA,SAASqlC,EAAuBrlC,GAC9B,GAA8B,QAA1BW,EAAKqhC,kBAA+BrhC,EAAKqhC,mBAA+B,IAAXrkC,EAC/DynC,EAAiBplC,OADnB,CAKA,IAAe,IAAXrC,EAIF,OAHAoE,EAAIoqB,UAAU,CAAC+Y,mBAAoBllC,IACnC+B,EAAI+C,aACCyE,GAAW/I,EAAIooB,SAItB,GAAqB,iBAAVjrB,KAAuB,EAAAwC,EAAA8B,mBAAkB5B,EAAI1C,GAAS,CAC/D,MAAMuF,EAAQ1C,EAAI2C,KAAK,SACO,YAA1BxC,EAAKqhC,kBACPsD,EAAsBtlC,EAAKkD,GAAO,GAClC1C,EAAIU,IAAG,EAAAjB,EAAAqlB,KAAIpiB,GAAQ,KACjBnB,EAAIwrB,QACJ6X,EAAiBplC,OAGnBslC,EAAsBtlC,EAAKkD,GACtBqG,GAAW/I,EAAIU,IAAG,EAAAjB,EAAAqlB,KAAIpiB,GAAQ,IAAM1C,EAAIooB,SAEjD,CArBA,CAsBF,CAEA,SAAS0c,EAAsBtlC,EAAWkD,EAAa0J,GACrD,MAAMtJ,EAA2B,CAC/BpF,QAAS,uBACTsF,SAAUxD,EACViI,aAAc9H,EAAAgtB,KAAKkG,MAEN,IAAXzmB,GACFjN,OAAO+M,OAAOpJ,EAAW,CACvB7C,eAAe,EACf6I,cAAc,EACdC,WAAW,IAGfxH,EAAIuB,UAAUA,EAAWJ,EAC3B,CArEE1C,EAAIkoB,MAAM,MAAOhoB,EAAOV,IACjBgN,EAAM9N,QAAWimC,EAASjmC,OAC1BsB,EAAIU,GAIb,SAAsBlB,GACpB,IAAIulC,EACJ,GAAIv4B,EAAM9N,OAAS,EAAG,CAEpB,MAAMsmC,GAAc,EAAArlC,EAAAw9B,gBAAet9B,EAAIkC,EAAalB,WAAY,cAChEkkC,GAAc,EAAA7jC,EAAAoqB,eAActrB,EAAKglC,EAAqBxlC,EACxD,MACEulC,EADSv4B,EAAM9N,QACD,EAAAe,EAAAqO,OAAMtB,EAAMkN,IAAKhC,GAAMjY,EAAAY,CAAC,GAAGb,SAAWkY,MAEtCjY,EAAAiM,IAKhB,OAHIi5B,EAASjmC,SACXqmC,GAAc,EAAAtlC,EAAAqO,IAAGi3B,KAAgBJ,EAASjrB,IAAKhC,GAAMjY,EAAAY,CAAC,IAAG,EAAAa,EAAA+jC,YAAW1jC,EAAKmW,WAAWlY,SAE/E,EAAAC,EAAAqlB,KAAIigB,EACb,CAnBgBG,CAAa1lC,GAAM,IAAMqlC,EAAuBrlC,IADrBqlC,EAAuBrlC,KAJlE+B,EAAIG,GAAGjC,EAAAY,CAAC,GAAG8xB,SAAiBhoB,EAAApJ,QAAEqL,SAyEhC,GAGFrO,EAAAA,QAAeoD,C,mECnHf,MAAAxB,EAAAD,EAAA,OAEMyB,EAA6B,CACjCzD,QAAS,CAAC,OAAQ,QAClB0D,WAAY,CAAC,SAAU,WACvBE,IAAAA,CAAItD,GAAwC,IAAvC,QAACN,EAAO,aAAEqE,EAAY,GAAElC,GAAe7B,OAClBP,IAApBsE,EAAarB,KAAkB,EAAAf,EAAAY,iBAAgBV,EAAI,IAAInC,6BAC7D,GAGFK,EAAAA,QAAeoD,C,mECXf,MAIMA,EAA6B,CACjCzD,QAAS,QACT0D,WAAY,QACZo3B,aAAa,EACbl3B,KARF5B,EAAA,OAQQylC,cACN7gC,MAAO,CAACuF,QAAS,iCAGnB9L,EAAAA,QAAeoD,C,kBCXf,MAAM,cAAE8C,EAAa,cAAEd,EAAa,kBAAE2D,EAAiB,mBAAEjB,EAAkB,2BAAES,GAA+B5G,EAAQ,MAC9GmuB,EAAUnuB,EAAQ,OAiBxB,SAAS0lC,EAAmBC,EAAMC,EAAUnqB,EAASoqB,GACnD,MAAMC,EAAS,CAAC,EAwDhB,OAvDKD,IACHF,EAAOnrB,EAAM5I,EAAU+zB,EAAMlqB,GAAUA,GACvCmqB,EAAWprB,EAAM5I,EAAUg0B,EAAUnqB,GAAUA,MAEjDA,EAAUA,GAAW,CAAC,GAETwT,UAAY2W,EAAS5+B,QAChC8+B,EAAO9+B,OAAS4+B,EAAS5+B,OAEzB8+B,EAAOx/B,SAAWs/B,EAASt/B,SAC3Bw/B,EAAOpiC,KAAOkiC,EAASliC,KACvBoiC,EAAOp/B,KAAOk/B,EAASl/B,KACvBo/B,EAAO7+B,KAAOG,EAAkBw+B,EAAS3+B,MAAQ,IACjD6+B,EAAO5+B,MAAQ0+B,EAAS1+B,aAEEnJ,IAAtB6nC,EAASt/B,eAA4CvI,IAAlB6nC,EAASliC,WAAwC3F,IAAlB6nC,EAASl/B,MAE7Eo/B,EAAOx/B,SAAWs/B,EAASt/B,SAC3Bw/B,EAAOpiC,KAAOkiC,EAASliC,KACvBoiC,EAAOp/B,KAAOk/B,EAASl/B,KACvBo/B,EAAO7+B,KAAOG,EAAkBw+B,EAAS3+B,MAAQ,IACjD6+B,EAAO5+B,MAAQ0+B,EAAS1+B,QAEnB0+B,EAAS3+B,MAQoB,MAA5B2+B,EAAS3+B,KAAK8+B,OAAO,GACvBD,EAAO7+B,KAAOG,EAAkBw+B,EAAS3+B,YAElBlJ,IAAlB4nC,EAAKr/B,eAAwCvI,IAAd4nC,EAAKjiC,WAAoC3F,IAAd4nC,EAAKj/B,MAAwBi/B,EAAK1+B,KAErF0+B,EAAK1+B,KAGf6+B,EAAO7+B,KAAO0+B,EAAK1+B,KAAKS,MAAM,EAAGi+B,EAAK1+B,KAAK++B,YAAY,KAAO,GAAKJ,EAAS3+B,KAF5E6+B,EAAO7+B,KAAO2+B,EAAS3+B,KAFvB6+B,EAAO7+B,KAAO,IAAM2+B,EAAS3+B,KAM/B6+B,EAAO7+B,KAAOG,EAAkB0+B,EAAO7+B,OAEzC6+B,EAAO5+B,MAAQ0+B,EAAS1+B,QAnBxB4+B,EAAO7+B,KAAO0+B,EAAK1+B,UACIlJ,IAAnB6nC,EAAS1+B,MACX4+B,EAAO5+B,MAAQ0+B,EAAS1+B,MAExB4+B,EAAO5+B,MAAQy+B,EAAKz+B,OAkBxB4+B,EAAOx/B,SAAWq/B,EAAKr/B,SACvBw/B,EAAOpiC,KAAOiiC,EAAKjiC,KACnBoiC,EAAOp/B,KAAOi/B,EAAKj/B,MAErBo/B,EAAO9+B,OAAS2+B,EAAK3+B,QAGvB8+B,EAAO3+B,SAAWy+B,EAASz+B,SAEpB2+B,CACT,CAoBA,SAASl0B,EAAWq0B,EAAOxlC,GACzB,MAAM2F,EAAa,CACjB1C,KAAMuiC,EAAMviC,KACZsD,OAAQi/B,EAAMj/B,OACdV,SAAU2/B,EAAM3/B,SAChBI,KAAMu/B,EAAMv/B,KACZO,KAAMg/B,EAAMh/B,KACZC,MAAO++B,EAAM/+B,MACbsnB,IAAKyX,EAAMzX,IACXC,IAAKwX,EAAMxX,IACXO,KAAMiX,EAAMjX,KACZ7nB,SAAU8+B,EAAM9+B,SAChB++B,UAAWD,EAAMC,UACjBhY,aAAc+X,EAAM/X,aACpBP,OAAQsY,EAAMtY,OACd/oB,MAAO,IAEH6W,EAAUhc,OAAO+M,OAAO,CAAC,EAAG/L,GAC5B4F,EAAY,GAGZsoB,EAAgBR,GAAS1S,EAAQzU,QAAUZ,EAAWY,QAAU,IAAI4mB,eAGtEe,GAAiBA,EAAc/c,WAAW+c,EAAc/c,UAAUxL,EAAYqV,QAE1D1d,IAApBqI,EAAWa,OACRwU,EAAQoT,WAOXzoB,EAAWa,KAAOV,SAASH,EAAWa,OANtCb,EAAWa,KAAOF,OAAOX,EAAWa,WAEVlJ,IAAtBqI,EAAWY,SACbZ,EAAWa,KAAOb,EAAWa,KAAK0T,MAAM,OAAOrV,KAAK,QAOhC,WAAtBmW,EAAQyqB,WAA0B9/B,EAAWY,QAC/CX,EAAUjB,KAAKgB,EAAWY,OAAQ,KAGpC,MAAMm/B,EAAYhgC,EAAmBC,GAYrC,QAXkBrI,IAAdooC,IACwB,WAAtB1qB,EAAQyqB,WACV7/B,EAAUjB,KAAK,MAGjBiB,EAAUjB,KAAK+gC,GAEX//B,EAAWa,MAAsC,MAA9Bb,EAAWa,KAAK8+B,OAAO,IAC5C1/B,EAAUjB,KAAK,WAGKrH,IAApBqI,EAAWa,KAAoB,CACjC,IAAIQ,EAAIrB,EAAWa,KAEdwU,EAAQ2qB,cAAkBzX,GAAkBA,EAAcyX,eAC7D3+B,EAAIL,EAAkBK,SAGN1J,IAAdooC,IACF1+B,EAAIA,EAAEJ,QAAQ,SAAU,SAG1BhB,EAAUjB,KAAKqC,EACjB,CASA,YAPyB1J,IAArBqI,EAAWc,OACbb,EAAUjB,KAAK,IAAKgB,EAAWc,YAGLnJ,IAAxBqI,EAAWe,UACbd,EAAUjB,KAAK,IAAKgB,EAAWe,UAE1Bd,EAAUf,KAAK,GACxB,CAEA,MAAM+gC,EAAYlnC,MAAMsmB,KAAK,CAAEzmB,OAAQ,KAAO,CAACkV,EAAIoF,IAAM,8BAA8ByB,KAAKpU,OAAO2/B,aAAahtB,KAahH,MAAMitB,EAAY,8HAElB,SAAS/rB,EAAOgb,EAAK/0B,GACnB,MAAMgb,EAAUhc,OAAO+M,OAAO,CAAC,EAAG/L,GAC5B+lC,EAAS,CACbx/B,YAAQjJ,EACRuI,cAAUvI,EACV2F,KAAM,GACNgD,UAAM3I,EACNkJ,KAAM,GACNC,WAAOnJ,EACPoJ,cAAUpJ,GAEN0oC,GAAoC,IAAtBjR,EAAIkR,QAAQ,KAChC,IAAIC,GAAO,EACe,WAAtBlrB,EAAQyqB,YAAwB1Q,GAAO/Z,EAAQzU,OAASyU,EAAQzU,OAAS,IAAM,IAAM,KAAOwuB,GAEhG,MAAM3xB,EAAU2xB,EAAI1xB,MAAMyiC,GAE1B,GAAI1iC,EAAS,CAcX,GAZA2iC,EAAOx/B,OAASnD,EAAQ,GACxB2iC,EAAOlgC,SAAWzC,EAAQ,GAC1B2iC,EAAO9iC,KAAOG,EAAQ,GACtB2iC,EAAO9/B,KAAOkgC,SAAS/iC,EAAQ,GAAI,IACnC2iC,EAAOv/B,KAAOpD,EAAQ,IAAM,GAC5B2iC,EAAOt/B,MAAQrD,EAAQ,GACvB2iC,EAAOr/B,SAAWtD,EAAQ,GAGtBgjC,MAAML,EAAO9/B,QACf8/B,EAAO9/B,KAAO7C,EAAQ,IAEpB2iC,EAAO9iC,KAAM,CACf,MAAMojC,EAAarjC,EAAc+iC,EAAO9iC,MACxC,IAA0B,IAAtBojC,EAAWljC,OAAkB,CAC/B,MAAMmjC,EAAaxiC,EAAcuiC,EAAWpjC,MAC5C8iC,EAAO9iC,KAAOqjC,EAAWrjC,KAAKkqB,cAC9B+Y,EAAOI,EAAWviC,MACpB,MACEgiC,EAAO9iC,KAAOojC,EAAWpjC,KACzBijC,GAAO,CAEX,MACsB5oC,IAAlByoC,EAAOx/B,aAA4CjJ,IAApByoC,EAAOlgC,eAA0CvI,IAAhByoC,EAAO9iC,WAAsC3F,IAAhByoC,EAAO9/B,WAAuC3I,IAAjByoC,EAAOt/B,OAAwBs/B,EAAOv/B,UAEvIlJ,IAAlByoC,EAAOx/B,OAChBw/B,EAAON,UAAY,gBACUnoC,IAApByoC,EAAOr/B,SAChBq/B,EAAON,UAAY,WAEnBM,EAAON,UAAY,MANnBM,EAAON,UAAY,gBAUjBzqB,EAAQyqB,WAAmC,WAAtBzqB,EAAQyqB,WAA0BzqB,EAAQyqB,YAAcM,EAAON,YACtFM,EAAO5hC,MAAQ4hC,EAAO5hC,OAAS,gBAAkB6W,EAAQyqB,UAAY,eAIvE,MAAMvX,EAAgBR,GAAS1S,EAAQzU,QAAUw/B,EAAOx/B,QAAU,IAAI4mB,eAGtE,IAAKnS,EAAQurB,kBAAoBrY,IAAkBA,EAAcqY,iBAE3DR,EAAO9iC,OAAS+X,EAAQuS,YAAeW,GAAiBA,EAAcX,cAAyB,IAAT2Y,GA5EhG,SAA0Bj3B,GACxB,IAAI9N,EAAO,EACX,IAAK,IAAI3C,EAAI,EAAGiE,EAAMwM,EAAM1Q,OAAQC,EAAIiE,IAAOjE,EAE7C,GADA2C,EAAO8N,EAAME,WAAW3Q,GACpB2C,EAAO,KAAOykC,EAAUzkC,GAC1B,OAAO,EAGX,OAAO,CACT,CAmEkHqlC,CAAgBT,EAAO9iC,MAEjI,IACE8iC,EAAO9iC,KAAOwjC,IAAIC,cAAcX,EAAO9iC,KAAKkqB,cAC9C,CAAE,MAAOxgB,GACPo5B,EAAO5hC,MAAQ4hC,EAAO5hC,OAAS,qDAAuDwI,CACxF,GAKCuhB,GAAkBA,IAAkBA,EAAcG,iBACjD2X,QAAiC1oC,IAAlByoC,EAAOx/B,SACxBw/B,EAAOx/B,OAAST,SAASigC,EAAOx/B,SAE9By/B,QAA+B1oC,IAAhByoC,EAAO9iC,OACxB8iC,EAAO9iC,KAAO6C,SAASigC,EAAO9iC,OAE5B8iC,EAAOv/B,OACTu/B,EAAOv/B,KAAOF,OAAOR,SAASigC,EAAOv/B,QAEnCu/B,EAAOr/B,WACTq/B,EAAOr/B,SAAWigC,UAAUC,mBAAmBb,EAAOr/B,aAKtDwnB,GAAiBA,EAAcnU,OACjCmU,EAAcnU,MAAMgsB,EAAQ/qB,EAEhC,MACE+qB,EAAO5hC,MAAQ4hC,EAAO5hC,OAAS,yBAEjC,OAAO4hC,CACT,CAEA,MAAMc,EAAU,CACdnZ,UACAoZ,UA/RF,SAAoB/R,EAAK/Z,GAMvB,MALmB,kBAAR+Z,EACTA,EAAM5jB,EAAU4I,EAAMgb,EAAK/Z,GAAUA,GACb,kBAAR+Z,IAChBA,EAAMhb,EAAM5I,EAAU4jB,EAAK/Z,GAAUA,IAEhC+Z,CACT,EAyREpX,QAvRF,SAAkBopB,EAASC,EAAahsB,GACtC,MAAMisB,EAAoBjoC,OAAO+M,OAAO,CAAExF,OAAQ,QAAUyU,GAE5D,OAAO7J,EADU8zB,EAAkBlrB,EAAMgtB,EAASE,GAAoBltB,EAAMitB,EAAaC,GAAoBA,GAAmB,GACrG,IAAKA,EAAmB7Y,YAAY,GACjE,EAoRE6W,oBACA9mC,MAvNF,SAAgB+oC,EAAMC,EAAMnsB,GAe1B,MAdoB,kBAATksB,GACTA,EAAOphC,SAASohC,GAChBA,EAAO/1B,EAAUhL,EAA2B4T,EAAMmtB,EAAMlsB,IAAU,GAAO,IAAKA,EAASoT,YAAY,KAC1E,kBAAT8Y,IAChBA,EAAO/1B,EAAUhL,EAA2B+gC,GAAM,GAAO,IAAKlsB,EAASoT,YAAY,KAGjE,kBAAT+Y,GACTA,EAAOrhC,SAASqhC,GAChBA,EAAOh2B,EAAUhL,EAA2B4T,EAAMotB,EAAMnsB,IAAU,GAAO,IAAKA,EAASoT,YAAY,KAC1E,kBAAT+Y,IAChBA,EAAOh2B,EAAUhL,EAA2BghC,GAAM,GAAO,IAAKnsB,EAASoT,YAAY,KAG9E8Y,EAAK/Z,gBAAkBga,EAAKha,aACrC,EAwMEhc,YACA4I,SAGF7b,EAAON,QAAUipC,EACjB3oC,EAAON,QAAPM,QAAyB2oC,EACzB3oC,EAAON,QAAQipC,QAAUA,C,mEC5SzB,MAAA9lC,EAAAxB,EAAA,OAOAD,EAAAC,EAAA,OACAC,EAAAD,EAAA,OAaMyB,EAA6B,CACjCzD,QAAS,WACTO,KAAM,SACNmD,WAAY,QACZ4I,OAAO,EACP1F,MAVoC,CACpCuF,QAAS7L,IAAA,IAAE+L,QAAQ,gBAAC6hB,IAAiB5tB,EAAA,OAAKyB,EAAA2F,GAAG,gCAAgCwmB,MAC7E7hB,OAAQvC,IAAA,IAAEuC,QAAQ,gBAAC6hB,IAAiBpkB,EAAA,OAAK/H,EAAAY,CAAC,qBAAqBurB,OAS/DtqB,IAAAA,CAAKC,GACH,MAAM,IAACvB,EAAG,OAAE7C,EAAM,WAAE2M,EAAU,KAAE5J,EAAI,MAAE8J,EAAK,GAAEnK,GAAM0B,GAC7C,KAACpB,GAAQN,EACf,IAAKmK,GAA2B,IAAlB7M,EAAOuB,OAAc,OACnC,MAAMqhC,EAAU5iC,EAAOuB,QAAUyB,EAAK8S,aAItC,GAHIpT,EAAGkJ,UAeP,WACE,GAAIg3B,GAAW/1B,EACbzI,EAAIipB,WAAW/qB,EAAAiM,IAAK67B,QAEpB,IAAK,MAAMznC,KAAQ3C,GACjB,EAAA+D,EAAA04B,wBAAuBr4B,EAAKzB,EAGlC,CAvBkB0nC,GAyBlB,WACE,MAAM3b,EAAU7rB,EAAIgI,IAAI,WACxB,GAAI+3B,GAAW/1B,EAAO,CACpB,MAAMtH,EAAQ1C,EAAIgI,IAAI,SAAS,GAC/BzG,EAAIipB,WAAW9nB,EAAO,IAgB1B,SAA0BmpB,EAAenpB,GACvCnB,EAAIoqB,UAAU,CAACC,gBAAiBC,IAChC7rB,EAAIgoB,MACF6D,EACA/hB,EACA,KACE9J,EAAIkM,OAAOxJ,GAAO,EAAAxB,EAAAw4B,gBAAe15B,EAAKE,EAAM2rB,EAAS1rB,EAAKwc,gBAC1D3c,EAAIU,IAAG,EAAAjB,EAAAqlB,KAAIpiB,GAAQ,KACjBnB,EAAI+C,QACJtE,EAAIooB,WAGR3oB,EAAAiM,IAEJ,CA9BgC+7B,CAAiB5b,EAASnpB,IACtDnB,EAAIG,GAAGgB,EACT,MACE1C,EAAIU,IAAG,EAAAQ,EAAA24B,kBAAiBt4B,EAAKpE,EAAQ0uB,KACrC,EAAA3qB,EAAA44B,mBAAkBv4B,EAAKsqB,GACvB7rB,EAAI2kB,MAER,CAnCK+iB,GAEDvnC,EAAK2S,eAAgB,CACvB,MAAMtG,EAAQjL,EAAIQ,aAAalB,YACzB,kBAAC0H,GAAqBhH,EAAI1B,GAChC,IAAK,MAAM8nC,KAAexqC,EACxB,QAA6BM,KAApB,OAAL+O,QAAK,IAALA,OAAK,EAALA,EAAQm7B,MAA+Bp/B,EAAkBoW,IAAIgpB,GAAc,CAC7E,MACMrlC,EAAM,sBAAsBqlC,yBADf9nC,EAAG0K,UAAUD,OAASzK,EAAGmC,mCAE5C,EAAArC,EAAAY,iBAAgBV,EAAIyC,EAAKzC,EAAGM,KAAK2S,eACnC,CAEJ,CAyBA,SAASy0B,IACPvnC,EAAIgoB,MAAM,OAAQle,EAAqBhK,IACrCyB,EAAIoqB,UAAU,CAACC,gBAAiB9rB,IAChCE,EAAIU,IAAG,EAAAQ,EAAAqqB,kBAAiBvrB,EAAKE,EAAMJ,EAAMK,EAAKwc,eAAgB,IAAMpb,EAAI+C,UAE5E,CAiBF,GAGFvG,EAAAA,QAAeoD,C,mEC/Ff,MAAAD,EAAAxB,EAAA,OACAD,EAAAC,EAAA,OACAC,EAAAD,EAAA,OACA0rB,EAAA1rB,EAAA,OAGMyB,EAA6B,CACjCzD,QAAS,oBACTO,KAAM,SACNmD,WAAY,SACZE,IAAAA,CAAKC,GACH,MAAM,IAACvB,EAAG,OAAE7C,EAAM,KAAE+C,EAAI,aAAE6B,EAAY,GAAElC,GAAM0B,GACxC,KAACpB,GAAQN,EACT+nC,GAAW,EAAA1mC,EAAAsqB,qBAAoBruB,GAC/B0qC,EAAsBD,EAASlc,OAAQhU,IAC3C,EAAA/X,EAAA8B,mBAAkB5B,EAAI1C,EAAOua,KAG/B,GACsB,IAApBkwB,EAASlpC,QACRmpC,EAAoBnpC,SAAWkpC,EAASlpC,UACrCmB,EAAGM,KAAKqC,cAA4B,IAAb3C,EAAG2M,OAE9B,OAGF,MAAMs7B,EACJ3nC,EAAK4N,eAAiB5N,EAAK4nC,yBAA2BhmC,EAAalB,WAC/D6B,EAAQ1C,EAAI2C,KAAK,UACN,IAAb9C,EAAG2M,OAAoB3M,EAAG2M,iBAAiB/M,EAAA2I,OAC7CvI,EAAG2M,OAAQ,EAAA4e,EAAA4c,sBAAqBhoC,EAAKH,EAAG2M,QAE1C,MAAM,MAACA,GAAS3M,EAgBhB,SAASooC,EAAwBC,GAC/B,IAAK,MAAMpoC,KAAQgoC,EACb,IAAI/oC,OAAOmpC,GAAKztB,KAAK3a,KACvB,EAAAH,EAAAY,iBACEV,EACA,YAAYC,qBAAwBooC,kCAI5C,CAEA,SAASC,EAAmBD,GAC1BloC,EAAIkoB,MAAM,MAAOhoB,EAAOV,IACtBQ,EAAIU,GAAGjB,EAAAY,CAAC,IAAG,EAAAa,EAAA+jC,YAAW1jC,EAAK2mC,WAAa1oC,KAAQ,KAC9C,MAAM4oC,EAAcP,EAAoB5c,SAASid,GAC5CE,GACH7mC,EAAIuB,UACF,CACEpF,QAAS,oBACTqF,WAAYmlC,EACZllC,SAAUxD,EACViI,aAAc2jB,EAAAuB,KAAKkG,KAErBnwB,GAIA7C,EAAGM,KAAKqC,cAAyB,IAAVgK,EACzBxM,EAAIkM,OAAOzM,EAAAY,CAAC,GAAGmM,KAAShN,MAAQ,GACtB4oC,GAAgBvoC,EAAGkJ,WAG7B/I,EAAIU,IAAG,EAAAjB,EAAAqlB,KAAIpiB,GAAQ,IAAM1C,EAAIooB,YAIrC,EAjDA,WACE,IAAK,MAAM8f,KAAON,EACZE,GAAiBG,EAAwBC,GACzCroC,EAAGkJ,UACLo/B,EAAmBD,IAEnBloC,EAAI0M,IAAIhK,GAAO,GACfylC,EAAmBD,GACnBloC,EAAIU,GAAGgC,GAGb,CAbA2lC,EAoDF,GAGFtqC,EAAAA,QAAeoD,C,mECxFf,MAAAxB,EAAAD,EAAA,OAEMyB,EAA6B,CACjCzD,QAAS,QACT0D,WAAY,QACZE,IAAAA,CAAKC,GACH,MAAM,IAACvB,EAAG,OAAE7C,EAAM,GAAE0C,GAAM0B,EAE1B,IAAK1C,MAAMC,QAAQ3B,GAAS,MAAM,IAAI+J,MAAM,4BAC5C,MAAMxE,EAAQ1C,EAAI2C,KAAK,SACvBxF,EAAO6D,QAAQ,CAACC,EAAgBtC,KAC9B,IAAI,EAAAgB,EAAA8B,mBAAkB5B,EAAIoB,GAAM,OAChC,MAAMwK,EAASlK,EAAIuB,UAAU,CAACpF,QAAS,QAASqF,WAAYpE,GAAI+D,GAChEnB,EAAIG,GAAGgB,GACPnB,EAAIkB,eAAegJ,IAEvB,GAGF1N,EAAAA,QAAeoD,C,mECnBf,MAAA1B,EAAAC,EAAA,OAaMyB,EAA6B,CACjCzD,QAAS,aACTO,KAAM,SACNmD,WAAY,SACZ4I,OAAO,EACP1F,MAVoC,CACpCuF,QAAS7L,IAAA,IAAC,WAAC8L,GAAW9L,EAAA,OAAKyB,EAAA2F,GAAG,uBAAuB0E,KACrDC,OAAQvC,IAAA,IAAC,WAACsC,GAAWtC,EAAA,OAAK/H,EAAAY,CAAC,gBAAgByJ,OAS3CxI,IAAAA,CAAKC,GACH,MAAM,IAACvB,EAAG,KAAEE,EAAI,WAAE4J,EAAU,GAAEjK,GAAM0B,EAE9B+mC,EAAOzoC,EAAGM,KAAKooC,oBACfjQ,EAAMt4B,EAAIgI,IAAI,OACdwgC,EAAUF,EACZ7oC,EAAAY,CAAC,uBAAuBi4B,QAAUA,WAAagQ,IAC/C7oC,EAAAY,CAAC,GAAGi4B,kBAAoBA,KAC5B/2B,EAAI0I,UAAUxK,EAAAY,CAAC,IAAIyJ,eAAwBwuB,OAASp4B,KAAQ4J,MAAe0+B,MAC7E,GAGFzqC,EAAAA,QAAeoD,C,kGCtBf,MAAAsnC,EAAA/oC,EAAA,OACAD,EAAAC,EAAA,OAMMsJ,EAAMvJ,EAAAwJ,UAENC,EAAgE,CACpEw/B,cAAe,CAACt/B,MAAO,KAAM1H,GAAIsH,EAAIK,IAAKC,KAAMN,EAAIO,IACpDo/B,cAAe,CAACv/B,MAAO,KAAM1H,GAAIsH,EAAIS,IAAKH,KAAMN,EAAIU,IACpDk/B,uBAAwB,CAACx/B,MAAO,IAAK1H,GAAIsH,EAAIU,GAAIJ,KAAMN,EAAIS,KAC3Do/B,uBAAwB,CAACz/B,MAAO,IAAK1H,GAAIsH,EAAIO,GAAID,KAAMN,EAAIK,MAKvD/E,EAAgC,CACpCuF,QAAS7L,IAAA,IAAC,QAACN,EAAO,WAAEoM,GAAW9L,EAAA,OAAKyB,EAAA2F,GAAG,aAAa8D,EAAKxL,GAAgB0L,SAASU,KAClFC,OAAQvC,IAAA,IAAC,QAAC9J,EAAO,WAAEoM,GAAWtC,EAAA,OAC5B/H,EAAAY,CAAC,gBAAgB6I,EAAKxL,GAAgB0L,iBAAiBU,OAG9C/L,EAAAA,sBAA+C,CAC1DL,QAASyB,OAAOP,KAAKsK,GACrBjL,KAAM,SACNmD,WAAY,SACZ4I,OAAO,EACP1F,QACAhD,IAAAA,CAAKC,GACH,MAAM,IAACvB,EAAG,KAAEE,EAAI,WAAE4J,EAAU,QAAEpM,EAAO,GAAEmC,GAAM0B,GACvC,KAACpB,EAAI,KAAEjC,GAAQ2B,EACrB,IAAKM,EAAKqN,gBAAiB,OAE3B,MAAMs7B,EAAO,IAAIL,EAAA54B,WAAWhQ,EAAK3B,EAAKC,MAAMgb,IAAItL,OAAgBjQ,WAAY,UAwC5E,SAASmrC,EAAYl6B,GACnB,OAAOpP,EAAAY,CAAC,GAAGwO,aAAe3O,MAAS4J,MAAeZ,EAAKxL,GAAgB4L,QACzE,CAzCIw/B,EAAK9+B,MAGT,WACE,MAAMyD,EAAOzN,EAAI8K,WAAW,UAAW,CACrCC,IAAK7M,EAAKwP,QACVpM,KAAMnB,EAAKmB,KAAKoM,UAEZmB,EAAM7O,EAAI6C,MAAM,MAAOpD,EAAAY,CAAC,GAAGoN,KAAQq7B,EAAKh/B,eAC9CvI,EAAI0I,WACF,EAAAxK,EAAAqO,IACErO,EAAAY,CAAC,UAAUwO,gBACXpP,EAAAY,CAAC,GAAGwO,sBACJpP,EAAAY,CAAC,UAAUwO,0BACXk6B,EAAYl6B,IAGlB,CAjBgBV,GAmBhB,WACE,MAAMN,EAASi7B,EAAK3rC,OACdwR,EAAkCzQ,EAAKwP,QAAQG,GACrD,IAAKc,IAAqB,IAAXA,EAAiB,OAChC,GACmB,iBAAVA,GACPA,aAAkB5P,QACO,mBAAlB4P,EAAO4lB,QAEd,MAAM,IAAIrtB,MAAM,IAAIxJ,eAAqBmQ,yCAE3C,MAAMgB,EAAM7O,EAAI8K,WAAW,UAAW,CACpCtL,IAAKqO,EACL9C,IAAK4D,EACLrN,KAAMnB,EAAKmB,KAAKoM,QAAUjO,EAAAY,CAAC,GAAGF,EAAKmB,KAAKoM,WAAU,EAAAjO,EAAAa,aAAYuN,UAAYpQ,IAG5E8D,EAAI0I,UAAU8+B,EAAYl6B,GAC5B,CApCKK,EAyCP,EACAic,aAAc,CAAC,WAQjBptB,EAAAA,QAL8CyR,IAC5CA,EAAI0G,WAAWnY,EAAAirC,uBACRx5B,E,sXC7FT,MAAA/P,EAAAC,EAAA,OACAwB,EAAAxB,EAAA,OAiBA,SAAgB07B,EAAkBv7B,GAA4C,IAA7B1C,EAAA2E,UAAApD,OAAA,QAAAjB,IAAAqE,UAAA,GAAAA,UAAA,GAAoBjC,EAAG1C,OACtE,MAAM,KAACgD,EAAI,KAAEjC,GAAQ2B,EACrB,IAAKM,EAAK4N,aAAc,OACxB,GAAsB,mBAAX5Q,EAAsB,OACjC,MAAME,EAAQa,EAAKC,MAAM2X,SACzB,IAAK,MAAMtW,KAAOrC,EACXE,EAAMmC,IAAMe,EAAgBV,EAAI,qBAAqBL,KAE9D,CAEA,SAAgBypC,EACd9rC,EACAE,GAEA,GAAqB,kBAAVF,EAAqB,OAAQA,EACxC,IAAK,MAAMqC,KAAOrC,EAAQ,GAAIE,EAAMmC,GAAM,OAAO,EACjD,OAAO,CACT,CA6BA,SAAgB0pC,EAAkB9jC,GAChC,MAAkB,iBAAPA,EAAwB,GAAGA,IAC/BA,EAAI2B,QAAQ,KAAM,MAAMA,QAAQ,MAAO,KAChD,CAEA,SAAgBo4B,EAAoB/5B,GAClC,OAAOA,EAAI2B,QAAQ,MAAO,KAAKA,QAAQ,MAAO,IAChD,CA0BA,SAASoiC,EAAkB3hC,GAKJ,IAL8B,WACnD4hC,EAAU,YACVC,EAAW,YACXC,EAAW,aACXC,GACqB/hC,EACrB,MAAO,CAACxH,EAAKmlB,EAAMC,EAAItF,KACrB,MAAMwY,OACG76B,IAAP2nB,EACID,EACAC,aAAc3lB,EAAA2I,MACb+c,aAAgB1lB,EAAA2I,KAAOghC,EAAWppC,EAAKmlB,EAAMC,GAAMikB,EAAYrpC,EAAKmlB,EAAMC,GAAKA,GAChFD,aAAgB1lB,EAAA2I,MACfihC,EAAYrpC,EAAKolB,EAAID,GAAOA,GAC7BmkB,EAAYnkB,EAAMC,GACxB,OAAOtF,IAAWrgB,EAAA2I,MAAUkwB,aAAe74B,EAAA2I,KAAiCkwB,EAAzBiR,EAAavpC,EAAKs4B,GAEzE,CA2CA,SAAgB0P,EAAqBhoC,EAAcwpC,GACjD,IAAW,IAAPA,EAAa,OAAOxpC,EAAI0M,IAAI,SAAS,GACzC,MAAMF,EAAQxM,EAAI0M,IAAI,QAASjN,EAAAY,CAAC,MAEhC,YADW5C,IAAP+rC,GAAkBC,EAAazpC,EAAKwM,EAAOg9B,GACxCh9B,CACT,CAEA,SAAgBi9B,EAAazpC,EAAcwM,EAAag9B,GACtDrqC,OAAOP,KAAK4qC,GAAIxoC,QAAS0W,GAAM1X,EAAIkM,OAAOzM,EAAAY,CAAC,GAAGmM,KAAQ,EAAA/M,EAAAa,aAAYoX,MAAM,GAC1E,CAjKA3Z,EAAAA,OAAA,SAAkDkqB,GAChD,MAAMyhB,EAA0B,CAAC,EACjC,IAAK,MAAMnW,KAAQtL,EAAKyhB,EAAKnW,IAAQ,EACrC,OAAOmW,CACT,EAEA3rC,EAAAA,kBAAA,SAAkC8B,EAAe1C,GAC/C,MAAqB,kBAAVA,EAA4BA,EACJ,IAA/BgC,OAAOP,KAAKzB,GAAQuB,SACxB08B,EAAkBv7B,EAAI1C,IACd8rC,EAAe9rC,EAAQ0C,EAAG3B,KAAKC,MAAMgb,KAC/C,EAEApb,EAAAA,kBAAAq9B,EAUAr9B,EAAAA,eAAAkrC,EASAlrC,EAAAA,qBAAA,SAAqCZ,EAAmBgB,GACtD,GAAqB,kBAAVhB,EAAqB,OAAQA,EACxC,IAAK,MAAMqC,KAAOrC,EAAQ,GAAY,SAARqC,GAAkBrB,EAAMgb,IAAI3Z,GAAM,OAAO,EACvE,OAAO,CACT,EAEAzB,EAAAA,eAAA,SAA8BC,EAE5Bb,EACAO,EACAsM,GAAsB,IAHtB,aAAC1C,EAAY,WAAED,GAAyBrJ,EAKxC,IAAKgM,EAAO,CACV,GAAqB,iBAAV7M,GAAuC,kBAAVA,EAAqB,OAAOA,EACpE,GAAqB,iBAAVA,EAAoB,OAAOsC,EAAAY,CAAC,GAAGlD,GAC5C,CACA,OAAOsC,EAAAY,CAAC,GAAGiH,IAAeD,KAAa,EAAA5H,EAAAa,aAAY5C,IACrD,EAEAK,EAAAA,iBAAA,SAAiCqH,GAC/B,OAAO+5B,EAAoB4H,mBAAmB3hC,GAChD,EAEArH,EAAAA,eAAA,SAA+BqH,GAC7B,OAAOukC,mBAAmBT,EAAkB9jC,GAC9C,EAEArH,EAAAA,kBAAAmrC,EAKAnrC,EAAAA,oBAAAohC,EAIAphC,EAAAA,SAAA,SAA4B6rC,EAAavV,GACvC,GAAIx1B,MAAMC,QAAQ8qC,GAChB,IAAK,MAAM9qB,KAAK8qB,EAAIvV,EAAEvV,QAEtBuV,EAAEuV,EAEN,EA0Ca7rC,EAAAA,eAAiC,CAC5CyO,MAAO28B,EAAmB,CACxBC,WAAYA,CAACppC,EAAKmlB,EAAMC,IACtBplB,EAAIU,GAAGjB,EAAAY,CAAC,GAAG+kB,iBAAkBD,kBAAsB,KACjDnlB,EAAIU,GACFjB,EAAAY,CAAC,GAAG8kB,aACJ,IAAMnlB,EAAIkM,OAAOkZ,GAAI,GACrB,IAAMplB,EAAIkM,OAAOkZ,EAAI3lB,EAAAY,CAAC,GAAG+kB,WAAY9jB,KAAK7B,EAAAY,CAAC,iBAAiB+kB,MAAOD,SAGzEkkB,YAAaA,CAACrpC,EAAKmlB,EAAMC,IACvBplB,EAAIU,GAAGjB,EAAAY,CAAC,GAAG+kB,aAAe,MACX,IAATD,EACFnlB,EAAIkM,OAAOkZ,GAAI,IAEfplB,EAAIkM,OAAOkZ,EAAI3lB,EAAAY,CAAC,GAAG+kB,WACnBqkB,EAAazpC,EAAKolB,EAAID,MAG5BmkB,YAAaA,CAACnkB,EAAMC,KAAiB,IAATD,GAAuB,IAAIA,KAASC,GAChEmkB,aAAcvB,IAEhBlnC,MAAOqoC,EAAmB,CACxBC,WAAYA,CAACppC,EAAKmlB,EAAMC,IACtBplB,EAAIU,GAAGjB,EAAAY,CAAC,GAAG+kB,iBAAkBD,kBAAsB,IACjDnlB,EAAIkM,OAAOkZ,EAAI3lB,EAAAY,CAAC,GAAG8kB,uBAA0BC,OAAQD,OAAUC,OAAQD,MAE3EkkB,YAAaA,CAACrpC,EAAKmlB,EAAMC,IACvBplB,EAAIU,GAAGjB,EAAAY,CAAC,GAAG+kB,aAAe,IACxBplB,EAAIkM,OAAOkZ,GAAa,IAATD,GAAuB1lB,EAAAY,CAAC,GAAG+kB,OAAQD,OAAUC,OAAQD,MAExEmkB,YAAaA,CAACnkB,EAAMC,KAAiB,IAATD,GAAuB0kB,KAAKpR,IAAItT,EAAMC,GAClEmkB,aAAcA,CAACvpC,EAAKc,IAAUd,EAAI0M,IAAI,QAAS5L,MAInD/C,EAAAA,qBAAAiqC,EAOAjqC,EAAAA,aAAA0rC,EAIA,MAAMK,EAAoC,CAAC,EAS3C,IAAYnd,EAwBZ,SAAgBpsB,EACdV,EACAyC,GAC4C,IAA5CsgC,EAAA9gC,UAAApD,OAAA,QAAAjB,IAAAqE,UAAA,GAAAA,UAAA,GAAwBjC,EAAGM,KAAK4N,aAEhC,GAAK60B,EAAL,CAEA,GADAtgC,EAAM,gBAAgBA,KACT,IAATsgC,EAAe,MAAM,IAAI17B,MAAM5E,GACnCzC,EAAG3B,KAAKmQ,OAAOC,KAAKhM,EAHH,CAInB,CAxCAvE,EAAAA,QAAA,SAAwBiC,EAAcq0B,GACpC,OAAOr0B,EAAI8K,WAAW,OAAQ,CAC5BC,IAAKspB,EACL/yB,KAAMwoC,EAASzV,EAAE/yB,QAAUwoC,EAASzV,EAAE/yB,MAAQ,IAAIJ,EAAA8gB,MAAMqS,EAAE/yB,QAE9D,EAEA,SAAYqrB,GACVA,EAAAA,EAAA,aACAA,EAAAA,EAAA,YACD,CAHD,CAAYA,IAAI5uB,EAAAA,KAAJ4uB,EAAI,KAKhB5uB,EAAAA,aAAA,SACEiF,EACAyE,EACAS,GAGA,GAAIlF,aAAoBvD,EAAA2I,KAAM,CAC5B,MAAM2hC,EAAWtiC,IAAiBklB,EAAKC,IACvC,OAAO1kB,EACH6hC,EACEtqC,EAAAY,CAAC,SAAS2C,UACVvD,EAAAY,CAAC,UAAU2C,WACb+mC,EACAtqC,EAAAY,CAAC,SAAS2C,IACVvD,EAAAY,CAAC,SAAS2C,6CAChB,CACA,OAAOkF,GAAmB,EAAAzI,EAAAa,aAAY0C,GAAU3D,WAAa,IAAM6pC,EAAkBlmC,EACvF,EAEAjF,EAAAA,gBAAAwC,C,mECzMA,MAAAd,EAAAC,EAAA,OACAsqC,EAAAtqC,EAAA,MACA0K,EAAA1K,EAAA,OACAwK,EAAAxK,EAAA,OACAC,EAAAD,EAAA,OAaMyB,EAA6B,CACjCzD,QAAS,gBACTO,KAAM,SACNmD,WAAY,SACZkD,MAboC,CACpCuF,QAAS7L,IAAA,IAAE+L,QAAQ,WAACkgC,EAAU,QAAEC,IAASlsC,EAAA,OACvCisC,IAAeD,EAAA18B,WAAW68B,IACtB,QAAQD,oBACR,iBAAiBA,uBACvBngC,OAAQvC,IAAA,IAAEuC,QAAQ,WAACkgC,EAAU,IAAEG,EAAG,QAAEF,IAAS1iC,EAAA,OAC3C/H,EAAAY,CAAC,WAAW4pC,WAAoBC,gBAAsBE,OAQxD9oC,IAAAA,CAAKC,GACH,MAAM,IAACvB,EAAG,KAAEE,EAAI,OAAE/C,EAAM,aAAE4E,EAAY,GAAElC,GAAM0B,GACxC,MAACyiC,GAASjiC,EAChB,IAAKlC,EAAGM,KAAKgiC,cACX,MAAM,IAAIj7B,MAAM,gDAElB,MAAMgjC,EAAU/sC,EAAOyK,aACvB,GAAsB,iBAAXsiC,EAAqB,MAAM,IAAIhjC,MAAM,wCAChD,GAAI/J,EAAOktC,QAAS,MAAM,IAAInjC,MAAM,2CACpC,IAAK88B,EAAO,MAAM,IAAI98B,MAAM,yCAC5B,MAAMxE,EAAQ1C,EAAIgI,IAAI,SAAS,GACzBoiC,EAAMpqC,EAAI6C,MAAM,MAAOpD,EAAAY,CAAC,GAAGH,KAAO,EAAAT,EAAAa,aAAY4pC,MAoBpD,SAASI,EAAevnC,GACtB,MAAMg2B,EAAS/4B,EAAI2C,KAAK,SAClB8I,EAASlK,EAAIuB,UAAU,CAACpF,QAAS,QAASqF,cAAag2B,GAE7D,OADAx3B,EAAIkB,eAAegJ,EAAQhM,EAAA2I,MACpB2wB,CACT,CAxBA/4B,EAAIU,GACFjB,EAAAY,CAAC,UAAU+pC,gBACX,IAKF,WACE,MAAMC,EAkBR,W,MACE,MAAME,EAAyC,CAAC,EAC1CC,EAAcC,EAAY1oC,GAChC,IAAI2oC,GAAc,EAClB,IAAK,IAAI/rC,EAAI,EAAGA,EAAIqlC,EAAMtlC,OAAQC,IAAK,CACrC,IAAIsC,EAAM+iC,EAAMrlC,GAChB,IAAO,OAAHsC,QAAG,IAAHA,OAAG,EAAHA,EAAKoJ,SAAS,EAAA1K,EAAAif,sBAAqB3d,EAAKpB,EAAG3B,KAAKC,OAAQ,CAC1D,MAAM4M,EAAM9J,EAAIoJ,KAGhB,GAFApJ,EAAMmJ,EAAAc,WAAW3L,KAAKM,EAAG3B,KAAM2B,EAAG0K,UAAUG,KAAM7K,EAAGyK,OAAQS,GACzD9J,aAAemJ,EAAAgB,YAAWnK,EAAMA,EAAI9D,aAC5BM,IAARwD,EAAmB,MAAM,IAAIiJ,EAAAnJ,QAAgBlB,EAAGM,KAAKgL,YAAatL,EAAGyK,OAAQS,EACnF,CACA,MAAM4/B,EAAyB,QAAfhtC,EAAG,OAAHsD,QAAG,IAAHA,OAAG,EAAHA,EAAKJ,kBAAU,IAAAlD,OAAA,EAAAA,EAAGusC,GAClC,GAAsB,iBAAXS,EACT,MAAM,IAAIzjC,MACR,iFAAiFgjC,MAGrFQ,EAAcA,IAAgBF,GAAeC,EAAYxpC,IACzD2pC,EAAYD,EAAShsC,EACvB,CACA,IAAK+rC,EAAa,MAAM,IAAIxjC,MAAM,mBAAmBgjC,uBACrD,OAAOK,EAEP,SAASE,EAAW9hC,GAA4B,IAA3B,SAACy7B,GAA0Bz7B,EAC9C,OAAO9J,MAAMC,QAAQslC,IAAaA,EAASnZ,SAASif,EACtD,CAEA,SAASU,EAAY3pC,EAAsBtC,GACzC,GAAIsC,EAAI4B,MACNgoC,EAAW5pC,EAAI4B,MAAOlE,OACjB,KAAIsC,EAAIkjC,KAKb,MAAM,IAAIj9B,MAAM,8BAA8BgjC,kCAJ9C,IAAK,MAAMY,KAAY7pC,EAAIkjC,KACzB0G,EAAWC,EAAUnsC,EAIzB,CACF,CAEA,SAASksC,EAAWC,EAAmBnsC,GACrC,GAAuB,iBAAZmsC,GAAwBA,KAAYP,EAC7C,MAAM,IAAIrjC,MAAM,mBAAmBgjC,oCAErCK,EAAaO,GAAYnsC,CAC3B,CACF,CAhEkBosC,GAChB/qC,EAAIU,IAAG,GACP,IAAK,MAAMoqC,KAAYT,EACrBrqC,EAAIunB,OAAO9nB,EAAAY,CAAC,GAAG+pC,SAAWU,KAC1B9qC,EAAIkM,OAAOxJ,EAAO4nC,EAAeD,EAAQS,KAE3C9qC,EAAI2kB,OACJpjB,EAAI+C,OAAM,EAAO,CAAC2lC,WAAYD,EAAA18B,WAAW09B,QAASZ,MAAKF,YACvDlqC,EAAIsnB,OACN,CAfQ2jB,GACN,IAAM1pC,EAAI+C,OAAM,EAAO,CAAC2lC,WAAYD,EAAA18B,WAAW68B,IAAKC,MAAKF,aAE3D3oC,EAAIG,GAAGgB,EAoET,GAGF3E,EAAAA,QAAeoD,C,mEChHf,MAAA1B,EAAAC,EAAA,OAEMqjB,EAAQ,CAEZ7iB,KAAM,IAAIT,EAAA2I,KAAK,QAEf6jB,OAAQ,IAAIxsB,EAAA2I,KAAK,UACjBuR,aAAc,IAAIla,EAAA2I,KAAK,gBACvBK,WAAY,IAAIhJ,EAAA2I,KAAK,cACrBD,mBAAoB,IAAI1I,EAAA2I,KAAK,sBAC7B8jB,SAAU,IAAIzsB,EAAA2I,KAAK,YACnBkU,eAAgB,IAAI7c,EAAA2I,KAAK,kBAEzB+D,QAAS,IAAI1M,EAAA2I,KAAK,WAClBgE,OAAQ,IAAI3M,EAAA2I,KAAK,UACjB2D,KAAM,IAAItM,EAAA2I,KAAK,QAEflK,KAAM,IAAIuB,EAAA2I,KAAK,QACf2M,MAAO,IAAItV,EAAA2I,KAAK,SAEhB8iC,KAAM,IAAIzrC,EAAA2I,KAAK,QACf+iC,QAAS,IAAI1rC,EAAA2I,KAAK,WAClBgjC,QAAS,IAAI3rC,EAAA2I,KAAK,WAClBijC,SAAU,IAAI5rC,EAAA2I,KAAK,aAGrBrK,EAAAA,QAAeglB,C,mECxBf,MAAA7hB,EAAAxB,EAAA,OACAD,EAAAC,EAAA,OASMyB,EAA6B,CACjCzD,QAAS,UACTO,KAAM,SACNmD,WAAY,SACZ4I,OAAO,EACP1F,MAVoC,CACpCuF,QAAS7L,IAAA,IAAC,WAAC8L,GAAW9L,EAAA,OAAKyB,EAAA2F,GAAG,uBAAuB0E,MACrDC,OAAQvC,IAAA,IAAC,WAACsC,GAAWtC,EAAA,OAAK/H,EAAAY,CAAC,aAAayJ,OASxCxI,IAAAA,CAAKC,GACH,MAAM,KAACrB,EAAI,MAAE8J,EAAK,OAAE7M,EAAM,WAAE2M,EAAU,GAAEjK,GAAM0B,EAExC+qB,EAAIzsB,EAAGM,KAAK+T,cAAgB,IAAM,GAClClC,EAAShI,EAAQvK,EAAAY,CAAC,eAAeyJ,MAAewiB,OAAQ,EAAAprB,EAAA+jC,YAAW1jC,EAAKpE,GAC9EoE,EAAI0I,UAAUxK,EAAAY,CAAC,IAAI2R,UAAe9R,KACpC,GAGFnC,EAAAA,QAAeoD,C,mEC1Bf,MAAAmqC,EAAA5rC,EAAA,MACA6rC,EAAA7rC,EAAA,OACA8rC,EAAA9rC,EAAA,OACA+rC,EAAA/rC,EAAA,OACAgsC,EAAAhsC,EAAA,OACAisC,EAAAjsC,EAAA,OACAksC,EAAAlsC,EAAA,OACAmsC,EAAAnsC,EAAA,OACAosC,EAAApsC,EAAA,OACAqsC,EAAArsC,EAAA,OAEM+P,EAAyB,CAE7B67B,EAAAvqC,QACAwqC,EAAAxqC,QAEAyqC,EAAAzqC,QACA0qC,EAAA1qC,QAEA2qC,EAAA3qC,QACA4qC,EAAA5qC,QAEA6qC,EAAA7qC,QACA8qC,EAAA9qC,QAEA,CAACrD,QAAS,OAAQ0D,WAAY,CAAC,SAAU,UACzC,CAAC1D,QAAS,WAAY0D,WAAY,WAClC0qC,EAAA/qC,QACAgrC,EAAAhrC,SAGFhD,EAAAA,QAAe0R,C,mECxBf,MAAAhQ,EAAAC,EAAA,OACAC,EAAAD,EAAA,OASMyB,EAA6B,CACjCzD,QAAS,KACT0D,WAAY,CAAC,SAAU,WACvBo3B,aAAa,EACbl0B,MAToC,CACpCuF,QAAS7L,IAAA,IAAC,OAAC+L,GAAO/L,EAAA,OAAKyB,EAAA2F,GAAG,eAAe2E,EAAOiiC,oBAChDjiC,OAAQvC,IAAA,IAAC,OAACuC,GAAOvC,EAAA,OAAK/H,EAAAY,CAAC,oBAAoB0J,EAAOiiC,cAQlD1qC,IAAAA,CAAKC,GACH,MAAM,IAACvB,EAAG,aAAE+B,EAAY,GAAElC,GAAM0B,OACN9D,IAAtBsE,EAAa+hC,WAA4CrmC,IAAtBsE,EAAa4iB,OAClD,EAAAhlB,EAAAY,iBAAgBV,EAAI,6CAEtB,MAAMosC,EAAUC,EAAUrsC,EAAI,QACxBssC,EAAUD,EAAUrsC,EAAI,QAC9B,IAAKosC,IAAYE,EAAS,OAE1B,MAAMzpC,EAAQ1C,EAAIgI,IAAI,SAAS,GACzB6kB,EAAW7sB,EAAI2C,KAAK,UAI1B,GAYA,WACE,MAAM8I,EAASlK,EAAIuB,UACjB,CACEpF,QAAS,KACTuC,eAAe,EACf6I,cAAc,EACdC,WAAW,GAEb8jB,GAEFtrB,EAAIkB,eAAegJ,EACrB,CA1BA2gC,GACA7qC,EAAIwrB,QAEAkf,GAAWE,EAAS,CACtB,MAAMH,EAAWhsC,EAAIgI,IAAI,YACzBzG,EAAIoqB,UAAU,CAACqgB,aACfhsC,EAAIU,GAAGmsB,EAAUwf,EAAe,OAAQL,GAAWK,EAAe,OAAQL,GAC5E,MAAWC,EACTjsC,EAAIU,GAAGmsB,EAAUwf,EAAe,SAEhCrsC,EAAIU,IAAG,EAAAjB,EAAAqlB,KAAI+H,GAAWwf,EAAe,SAkBvC,SAASA,EAAe3uC,EAAiBsuC,GACvC,MAAO,KACL,MAAMvgC,EAASlK,EAAIuB,UAAU,CAACpF,WAAUmvB,GACxC7sB,EAAIkM,OAAOxJ,EAAOmqB,GAClBtrB,EAAIurB,oBAAoBrhB,EAAQ/I,GAC5BspC,EAAUhsC,EAAIkM,OAAO8/B,EAAUvsC,EAAAY,CAAC,GAAG3C,KAClC6D,EAAIoqB,UAAU,CAACqgB,SAAUtuC,IAElC,CAvBA6D,EAAIwN,KAAKrM,EAAO,IAAMnB,EAAI+C,OAAM,GAwBlC,GAGF,SAAS4nC,EAAUrsC,EAAkBnC,GACnC,MAAMP,EAAS0C,EAAG1C,OAAOO,GACzB,YAAkBD,IAAXN,KAAyB,EAAAwC,EAAA8B,mBAAkB5B,EAAI1C,EACxD,CAEAY,EAAAA,QAAeoD,C,mECxEf,MAAA1B,EAAAC,EAAA,OACAC,EAAAD,EAAA,OAcMyB,EAA6B,CACjCzD,QAAS,QACT0D,WAAY,QACZo3B,aAAa,EACbl0B,MAToC,CACpCuF,QAAS,yCACTE,OAAQ/L,IAAA,IAAC,OAAC+L,GAAO/L,EAAA,OAAKyB,EAAAY,CAAC,oBAAoB0J,EAAOuiC,aAQlDhrC,IAAAA,CAAKC,GACH,MAAM,IAACvB,EAAG,OAAE7C,EAAM,aAAE4E,EAAY,GAAElC,GAAM0B,EAExC,IAAK1C,MAAMC,QAAQ3B,GAAS,MAAM,IAAI+J,MAAM,4BAC5C,GAAIrH,EAAGM,KAAKgiC,eAAiBpgC,EAAaogC,cAAe,OACzD,MAAMtgC,EAAsB1E,EACtBuF,EAAQ1C,EAAIgI,IAAI,SAAS,GACzBskC,EAAUtsC,EAAIgI,IAAI,UAAW,MAC7B6kB,EAAW7sB,EAAI2C,KAAK,UAC1BpB,EAAIoqB,UAAU,CAAC2gB,YAGftsC,EAAI0oB,MAQJ,WACE7mB,EAAOb,QAAQ,CAACC,EAAgBtC,KAC9B,IAAI8M,GACA,EAAA9L,EAAA8B,mBAAkB5B,EAAIoB,GACxBjB,EAAI0M,IAAImgB,GAAU,GAElBphB,EAASlK,EAAIuB,UACX,CACEpF,QAAS,QACTqF,WAAYpE,EACZsB,eAAe,GAEjB4sB,GAIAluB,EAAI,GACNqB,EACGU,GAAGjB,EAAAY,CAAC,GAAGwsB,QAAenqB,KACtBwJ,OAAOxJ,GAAO,GACdwJ,OAAOogC,EAAS7sC,EAAAY,CAAC,IAAIisC,MAAY3tC,MACjCgmB,OAGL3kB,EAAIU,GAAGmsB,EAAU,KACf7sB,EAAIkM,OAAOxJ,GAAO,GAClB1C,EAAIkM,OAAOogC,EAAS3tC,GAChB8M,GAAQlK,EAAIkB,eAAegJ,EAAQhM,EAAA2I,SAG7C,GApCA7G,EAAI2L,OACFxK,EACA,IAAMnB,EAAIwrB,QACV,IAAMxrB,EAAI+C,OAAM,GAkCpB,GAGFvG,EAAAA,QAAeoD,C,mEChFf,MAEM0M,EAAqB,CAF3BnO,EAAA,OAE4BqB,SAE5BhD,EAAAA,QAAe8P,C,mECHf,MAAAlO,EAAAD,EAAA,OAIMyB,EAA6B,CACjCzD,QAAS,MACT0D,WAAY,CAAC,SAAU,WACvBo3B,aAAa,EACbl3B,IAAAA,CAAKC,GACH,MAAM,IAACvB,EAAG,OAAE7C,EAAM,GAAE0C,GAAM0B,EAC1B,IAAI,EAAA5B,EAAA8B,mBAAkB5B,EAAI1C,GAExB,YADAoE,EAAI+H,OAIN,MAAM5G,EAAQ1C,EAAI2C,KAAK,SACvBpB,EAAIuB,UACF,CACEpF,QAAS,MACTuC,eAAe,EACf6I,cAAc,EACdC,WAAW,GAEbrG,GAGFnB,EAAIi8B,WACF96B,EACA,IAAMnB,EAAIwrB,QACV,IAAMxrB,EAAI+C,QAEd,EACAA,MAAO,CAACuF,QAAS,sBAGnB9L,EAAAA,QAAeoD,C,mECpCf,MAAA0gC,EAAAniC,EAAA,MACA6sC,EAAA7sC,EAAA,OACA8sC,EAAA9sC,EAAA,OACA+sC,EAAA/sC,EAAA,OACAgtC,EAAAhtC,EAAA,OAEMitC,EAAmC,CACvC9K,EAAA9gC,QACAwrC,EAAAxrC,SACA,EAAAyrC,EAAAzrC,WACA0rC,EAAA1rC,QACA2rC,EAAAE,mBACAF,EAAAG,mBAGF9uC,EAAAA,QAAe4uC,C","sources":["../node_modules/ajv/lib/compile/validate/applicability.ts","../node_modules/fast-deep-equal/index.js","../node_modules/ajv/lib/compile/validate/defaults.ts","../node_modules/ajv/lib/vocabularies/applicator/items.ts","../node_modules/fast-uri/lib/utils.js","../node_modules/ajv/lib/compile/validate/subschema.ts","../node_modules/ajv/lib/vocabularies/validation/limitNumber.ts","../node_modules/ajv/lib/vocabularies/core/ref.ts","../node_modules/ajv/lib/vocabularies/core/index.ts","../node_modules/ajv/lib/vocabularies/discriminator/types.ts","../node_modules/ajv/lib/vocabularies/format/format.ts","../node_modules/ajv/lib/runtime/ucs2length.ts","../node_modules/ajv/lib/runtime/validation_error.ts","../node_modules/ajv/lib/core.ts","../node_modules/ajv/lib/vocabularies/validation/limitLength.ts","../node_modules/ajv/lib/compile/index.ts","../node_modules/ajv/lib/compile/rules.ts","../node_modules/ajv/lib/compile/codegen/scope.ts","../node_modules/ajv/lib/compile/codegen/index.ts","../node_modules/ajv/lib/compile/validate/keyword.ts","../node_modules/ajv/lib/vocabularies/code.ts","../node_modules/ajv/lib/vocabularies/applicator/additionalItems.ts","../node_modules/fast-uri/lib/schemes.js","../node_modules/ajv/lib/compile/resolve.ts","../node_modules/ajv/lib/vocabularies/core/id.ts","../node_modules/ajv/lib/vocabularies/applicator/index.ts","../node_modules/ajv/lib/compile/errors.ts","../node_modules/ajv/lib/vocabularies/validation/limitItems.ts","../node_modules/ajv/lib/compile/validate/boolSchema.ts","../node_modules/ajv/lib/compile/ref_error.ts","../node_modules/ajv/lib/runtime/equal.ts","../node_modules/ajv/lib/vocabularies/validation/uniqueItems.ts","../node_modules/fast-uri/lib/scopedChars.js","../node_modules/ajv-formats/src/formats.ts","../node_modules/ajv/lib/vocabularies/applicator/items2020.ts","../node_modules/ajv/lib/vocabularies/applicator/contains.ts","../node_modules/ajv/lib/vocabularies/validation/limitProperties.ts","../node_modules/ajv/lib/vocabularies/validation/const.ts","../node_modules/ajv/lib/vocabularies/applicator/dependencies.ts","../node_modules/ajv/lib/vocabularies/applicator/propertyNames.ts","../node_modules/ajv/lib/compile/validate/index.ts","../node_modules/ajv/lib/compile/codegen/code.ts","../node_modules/ajv/lib/vocabularies/metadata.ts","../node_modules/ajv/lib/vocabularies/validation/enum.ts","../node_modules/ajv/lib/compile/validate/dataType.ts","../node_modules/ajv/lib/vocabularies/applicator/prefixItems.ts","../node_modules/ajv/lib/vocabularies/applicator/properties.ts","../node_modules/ajv/lib/runtime/uri.ts","../node_modules/ajv/lib/ajv.ts","../node_modules/ajv-formats/src/index.ts","../node_modules/json-schema-traverse/index.js","../node_modules/ajv/lib/vocabularies/applicator/additionalProperties.ts","../node_modules/ajv/lib/vocabularies/applicator/thenElse.ts","../node_modules/ajv/lib/vocabularies/applicator/anyOf.ts","../node_modules/fast-uri/index.js","../node_modules/ajv/lib/vocabularies/validation/required.ts","../node_modules/ajv/lib/vocabularies/applicator/patternProperties.ts","../node_modules/ajv/lib/vocabularies/applicator/allOf.ts","../node_modules/ajv/lib/vocabularies/validation/multipleOf.ts","../node_modules/ajv-formats/src/limit.ts","../node_modules/ajv/lib/compile/util.ts","../node_modules/ajv/lib/vocabularies/discriminator/index.ts","../node_modules/ajv/lib/compile/names.ts","../node_modules/ajv/lib/vocabularies/validation/pattern.ts","../node_modules/ajv/lib/vocabularies/validation/index.ts","../node_modules/ajv/lib/vocabularies/applicator/if.ts","../node_modules/ajv/lib/vocabularies/applicator/oneOf.ts","../node_modules/ajv/lib/vocabularies/format/index.ts","../node_modules/ajv/lib/vocabularies/applicator/not.ts","../node_modules/ajv/lib/vocabularies/draft7.ts"],"sourcesContent":["import type {AnySchemaObject} from \"../../types\"\nimport type {SchemaObjCxt} from \"..\"\nimport type {JSONType, RuleGroup, Rule} from \"../rules\"\n\nexport function schemaHasRulesForType(\n  {schema, self}: SchemaObjCxt,\n  type: JSONType\n): boolean | undefined {\n  const group = self.RULES.types[type]\n  return group && group !== true && shouldUseGroup(schema, group)\n}\n\nexport function shouldUseGroup(schema: AnySchemaObject, group: RuleGroup): boolean {\n  return group.rules.some((rule) => shouldUseRule(schema, rule))\n}\n\nexport function shouldUseRule(schema: AnySchemaObject, rule: Rule): boolean | undefined {\n  return (\n    schema[rule.keyword] !== undefined ||\n    rule.definition.implements?.some((kwd) => schema[kwd] !== undefined)\n  )\n}\n","'use strict';\n\n// do not edit .js files directly - edit src/index.jst\n\n\n\nmodule.exports = function equal(a, b) {\n  if (a === b) return true;\n\n  if (a && b && typeof a == 'object' && typeof b == 'object') {\n    if (a.constructor !== b.constructor) return false;\n\n    var length, i, keys;\n    if (Array.isArray(a)) {\n      length = a.length;\n      if (length != b.length) return false;\n      for (i = length; i-- !== 0;)\n        if (!equal(a[i], b[i])) return false;\n      return true;\n    }\n\n\n\n    if (a.constructor === RegExp) return a.source === b.source && a.flags === b.flags;\n    if (a.valueOf !== Object.prototype.valueOf) return a.valueOf() === b.valueOf();\n    if (a.toString !== Object.prototype.toString) return a.toString() === b.toString();\n\n    keys = Object.keys(a);\n    length = keys.length;\n    if (length !== Object.keys(b).length) return false;\n\n    for (i = length; i-- !== 0;)\n      if (!Object.prototype.hasOwnProperty.call(b, keys[i])) return false;\n\n    for (i = length; i-- !== 0;) {\n      var key = keys[i];\n\n      if (!equal(a[key], b[key])) return false;\n    }\n\n    return true;\n  }\n\n  // true if both NaN, false otherwise\n  return a!==a && b!==b;\n};\n","import type {SchemaObjCxt} from \"..\"\nimport {_, getProperty, stringify} from \"../codegen\"\nimport {checkStrictMode} from \"../util\"\n\nexport function assignDefaults(it: SchemaObjCxt, ty?: string): void {\n  const {properties, items} = it.schema\n  if (ty === \"object\" && properties) {\n    for (const key in properties) {\n      assignDefault(it, key, properties[key].default)\n    }\n  } else if (ty === \"array\" && Array.isArray(items)) {\n    items.forEach((sch, i: number) => assignDefault(it, i, sch.default))\n  }\n}\n\nfunction assignDefault(it: SchemaObjCxt, prop: string | number, defaultValue: unknown): void {\n  const {gen, compositeRule, data, opts} = it\n  if (defaultValue === undefined) return\n  const childData = _`${data}${getProperty(prop)}`\n  if (compositeRule) {\n    checkStrictMode(it, `default is ignored for: ${childData}`)\n    return\n  }\n\n  let condition = _`${childData} === undefined`\n  if (opts.useDefaults === \"empty\") {\n    condition = _`${condition} || ${childData} === null || ${childData} === \"\"`\n  }\n  // `${childData} === undefined` +\n  // (opts.useDefaults === \"empty\" ? ` || ${childData} === null || ${childData} === \"\"` : \"\")\n  gen.if(condition, _`${childData} = ${stringify(defaultValue)}`)\n}\n","import type {CodeKeywordDefinition, AnySchema, AnySchemaObject} from \"../../types\"\nimport type {KeywordCxt} from \"../../compile/validate\"\nimport {_} from \"../../compile/codegen\"\nimport {alwaysValidSchema, mergeEvaluated, checkStrictMode} from \"../../compile/util\"\nimport {validateArray} from \"../code\"\n\nconst def: CodeKeywordDefinition = {\n  keyword: \"items\",\n  type: \"array\",\n  schemaType: [\"object\", \"array\", \"boolean\"],\n  before: \"uniqueItems\",\n  code(cxt: KeywordCxt) {\n    const {schema, it} = cxt\n    if (Array.isArray(schema)) return validateTuple(cxt, \"additionalItems\", schema)\n    it.items = true\n    if (alwaysValidSchema(it, schema)) return\n    cxt.ok(validateArray(cxt))\n  },\n}\n\nexport function validateTuple(\n  cxt: KeywordCxt,\n  extraItems: string,\n  schArr: AnySchema[] = cxt.schema\n): void {\n  const {gen, parentSchema, data, keyword, it} = cxt\n  checkStrictTuple(parentSchema)\n  if (it.opts.unevaluated && schArr.length && it.items !== true) {\n    it.items = mergeEvaluated.items(gen, schArr.length, it.items)\n  }\n  const valid = gen.name(\"valid\")\n  const len = gen.const(\"len\", _`${data}.length`)\n  schArr.forEach((sch: AnySchema, i: number) => {\n    if (alwaysValidSchema(it, sch)) return\n    gen.if(_`${len} > ${i}`, () =>\n      cxt.subschema(\n        {\n          keyword,\n          schemaProp: i,\n          dataProp: i,\n        },\n        valid\n      )\n    )\n    cxt.ok(valid)\n  })\n\n  function checkStrictTuple(sch: AnySchemaObject): void {\n    const {opts, errSchemaPath} = it\n    const l = schArr.length\n    const fullTuple = l === sch.minItems && (l === sch.maxItems || sch[extraItems] === false)\n    if (opts.strictTuples && !fullTuple) {\n      const msg = `\"${keyword}\" is ${l}-tuple, but minItems or maxItems/${extraItems} are not specified or different at path \"${errSchemaPath}\"`\n      checkStrictMode(it, msg, opts.strictTuples)\n    }\n  }\n}\n\nexport default def\n","'use strict'\n\nconst { HEX } = require('./scopedChars')\n\nconst IPV4_REG = /^(?:(?:25[0-5]|2[0-4]\\d|1\\d{2}|[1-9]\\d|\\d)\\.){3}(?:25[0-5]|2[0-4]\\d|1\\d{2}|[1-9]\\d|\\d)$/u\n\nfunction normalizeIPv4 (host) {\n  if (findToken(host, '.') < 3) { return { host, isIPV4: false } }\n  const matches = host.match(IPV4_REG) || []\n  const [address] = matches\n  if (address) {\n    return { host: stripLeadingZeros(address, '.'), isIPV4: true }\n  } else {\n    return { host, isIPV4: false }\n  }\n}\n\n/**\n * @param {string[]} input\n * @param {boolean} [keepZero=false]\n * @returns {string|undefined}\n */\nfunction stringArrayToHexStripped (input, keepZero = false) {\n  let acc = ''\n  let strip = true\n  for (const c of input) {\n    if (HEX[c] === undefined) return undefined\n    if (c !== '0' && strip === true) strip = false\n    if (!strip) acc += c\n  }\n  if (keepZero && acc.length === 0) acc = '0'\n  return acc\n}\n\nfunction getIPV6 (input) {\n  let tokenCount = 0\n  const output = { error: false, address: '', zone: '' }\n  const address = []\n  const buffer = []\n  let isZone = false\n  let endipv6Encountered = false\n  let endIpv6 = false\n\n  function consume () {\n    if (buffer.length) {\n      if (isZone === false) {\n        const hex = stringArrayToHexStripped(buffer)\n        if (hex !== undefined) {\n          address.push(hex)\n        } else {\n          output.error = true\n          return false\n        }\n      }\n      buffer.length = 0\n    }\n    return true\n  }\n\n  for (let i = 0; i < input.length; i++) {\n    const cursor = input[i]\n    if (cursor === '[' || cursor === ']') { continue }\n    if (cursor === ':') {\n      if (endipv6Encountered === true) {\n        endIpv6 = true\n      }\n      if (!consume()) { break }\n      tokenCount++\n      address.push(':')\n      if (tokenCount > 7) {\n        // not valid\n        output.error = true\n        break\n      }\n      if (i - 1 >= 0 && input[i - 1] === ':') {\n        endipv6Encountered = true\n      }\n      continue\n    } else if (cursor === '%') {\n      if (!consume()) { break }\n      // switch to zone detection\n      isZone = true\n    } else {\n      buffer.push(cursor)\n      continue\n    }\n  }\n  if (buffer.length) {\n    if (isZone) {\n      output.zone = buffer.join('')\n    } else if (endIpv6) {\n      address.push(buffer.join(''))\n    } else {\n      address.push(stringArrayToHexStripped(buffer))\n    }\n  }\n  output.address = address.join('')\n  return output\n}\n\nfunction normalizeIPv6 (host) {\n  if (findToken(host, ':') < 2) { return { host, isIPV6: false } }\n  const ipv6 = getIPV6(host)\n\n  if (!ipv6.error) {\n    let newHost = ipv6.address\n    let escapedHost = ipv6.address\n    if (ipv6.zone) {\n      newHost += '%' + ipv6.zone\n      escapedHost += '%25' + ipv6.zone\n    }\n    return { host: newHost, escapedHost, isIPV6: true }\n  } else {\n    return { host, isIPV6: false }\n  }\n}\n\nfunction stripLeadingZeros (str, token) {\n  let out = ''\n  let skip = true\n  const l = str.length\n  for (let i = 0; i < l; i++) {\n    const c = str[i]\n    if (c === '0' && skip) {\n      if ((i + 1 <= l && str[i + 1] === token) || i + 1 === l) {\n        out += c\n        skip = false\n      }\n    } else {\n      if (c === token) {\n        skip = true\n      } else {\n        skip = false\n      }\n      out += c\n    }\n  }\n  return out\n}\n\nfunction findToken (str, token) {\n  let ind = 0\n  for (let i = 0; i < str.length; i++) {\n    if (str[i] === token) ind++\n  }\n  return ind\n}\n\nconst RDS1 = /^\\.\\.?\\//u\nconst RDS2 = /^\\/\\.(?:\\/|$)/u\nconst RDS3 = /^\\/\\.\\.(?:\\/|$)/u\nconst RDS5 = /^\\/?(?:.|\\n)*?(?=\\/|$)/u\n\nfunction removeDotSegments (input) {\n  const output = []\n\n  while (input.length) {\n    if (input.match(RDS1)) {\n      input = input.replace(RDS1, '')\n    } else if (input.match(RDS2)) {\n      input = input.replace(RDS2, '/')\n    } else if (input.match(RDS3)) {\n      input = input.replace(RDS3, '/')\n      output.pop()\n    } else if (input === '.' || input === '..') {\n      input = ''\n    } else {\n      const im = input.match(RDS5)\n      if (im) {\n        const s = im[0]\n        input = input.slice(s.length)\n        output.push(s)\n      } else {\n        throw new Error('Unexpected dot segment condition')\n      }\n    }\n  }\n  return output.join('')\n}\n\nfunction normalizeComponentEncoding (components, esc) {\n  const func = esc !== true ? escape : unescape\n  if (components.scheme !== undefined) {\n    components.scheme = func(components.scheme)\n  }\n  if (components.userinfo !== undefined) {\n    components.userinfo = func(components.userinfo)\n  }\n  if (components.host !== undefined) {\n    components.host = func(components.host)\n  }\n  if (components.path !== undefined) {\n    components.path = func(components.path)\n  }\n  if (components.query !== undefined) {\n    components.query = func(components.query)\n  }\n  if (components.fragment !== undefined) {\n    components.fragment = func(components.fragment)\n  }\n  return components\n}\n\nfunction recomposeAuthority (components) {\n  const uriTokens = []\n\n  if (components.userinfo !== undefined) {\n    uriTokens.push(components.userinfo)\n    uriTokens.push('@')\n  }\n\n  if (components.host !== undefined) {\n    let host = unescape(components.host)\n    const ipV4res = normalizeIPv4(host)\n\n    if (ipV4res.isIPV4) {\n      host = ipV4res.host\n    } else {\n      const ipV6res = normalizeIPv6(ipV4res.host)\n      if (ipV6res.isIPV6 === true) {\n        host = `[${ipV6res.escapedHost}]`\n      } else {\n        host = components.host\n      }\n    }\n    uriTokens.push(host)\n  }\n\n  if (typeof components.port === 'number' || typeof components.port === 'string') {\n    uriTokens.push(':')\n    uriTokens.push(String(components.port))\n  }\n\n  return uriTokens.length ? uriTokens.join('') : undefined\n};\n\nmodule.exports = {\n  recomposeAuthority,\n  normalizeComponentEncoding,\n  removeDotSegments,\n  normalizeIPv4,\n  normalizeIPv6,\n  stringArrayToHexStripped\n}\n","import type {AnySchema} from \"../../types\"\nimport type {SchemaObjCxt} from \"..\"\nimport {_, str, getProperty, Code, Name} from \"../codegen\"\nimport {escapeFragment, getErrorPath, Type} from \"../util\"\nimport type {JSONType} from \"../rules\"\n\nexport interface SubschemaContext {\n  // TODO use Optional? align with SchemCxt property types\n  schema: AnySchema\n  schemaPath: Code\n  errSchemaPath: string\n  topSchemaRef?: Code\n  errorPath?: Code\n  dataLevel?: number\n  dataTypes?: JSONType[]\n  data?: Name\n  parentData?: Name\n  parentDataProperty?: Code | number\n  dataNames?: Name[]\n  dataPathArr?: (Code | number)[]\n  propertyName?: Name\n  jtdDiscriminator?: string\n  jtdMetadata?: boolean\n  compositeRule?: true\n  createErrors?: boolean\n  allErrors?: boolean\n}\n\nexport type SubschemaArgs = Partial<{\n  keyword: string\n  schemaProp: string | number\n  schema: AnySchema\n  schemaPath: Code\n  errSchemaPath: string\n  topSchemaRef: Code\n  data: Name | Code\n  dataProp: Code | string | number\n  dataTypes: JSONType[]\n  definedProperties: Set<string>\n  propertyName: Name\n  dataPropType: Type\n  jtdDiscriminator: string\n  jtdMetadata: boolean\n  compositeRule: true\n  createErrors: boolean\n  allErrors: boolean\n}>\n\nexport function getSubschema(\n  it: SchemaObjCxt,\n  {keyword, schemaProp, schema, schemaPath, errSchemaPath, topSchemaRef}: SubschemaArgs\n): SubschemaContext {\n  if (keyword !== undefined && schema !== undefined) {\n    throw new Error('both \"keyword\" and \"schema\" passed, only one allowed')\n  }\n\n  if (keyword !== undefined) {\n    const sch = it.schema[keyword]\n    return schemaProp === undefined\n      ? {\n          schema: sch,\n          schemaPath: _`${it.schemaPath}${getProperty(keyword)}`,\n          errSchemaPath: `${it.errSchemaPath}/${keyword}`,\n        }\n      : {\n          schema: sch[schemaProp],\n          schemaPath: _`${it.schemaPath}${getProperty(keyword)}${getProperty(schemaProp)}`,\n          errSchemaPath: `${it.errSchemaPath}/${keyword}/${escapeFragment(schemaProp)}`,\n        }\n  }\n\n  if (schema !== undefined) {\n    if (schemaPath === undefined || errSchemaPath === undefined || topSchemaRef === undefined) {\n      throw new Error('\"schemaPath\", \"errSchemaPath\" and \"topSchemaRef\" are required with \"schema\"')\n    }\n    return {\n      schema,\n      schemaPath,\n      topSchemaRef,\n      errSchemaPath,\n    }\n  }\n\n  throw new Error('either \"keyword\" or \"schema\" must be passed')\n}\n\nexport function extendSubschemaData(\n  subschema: SubschemaContext,\n  it: SchemaObjCxt,\n  {dataProp, dataPropType: dpType, data, dataTypes, propertyName}: SubschemaArgs\n): void {\n  if (data !== undefined && dataProp !== undefined) {\n    throw new Error('both \"data\" and \"dataProp\" passed, only one allowed')\n  }\n\n  const {gen} = it\n\n  if (dataProp !== undefined) {\n    const {errorPath, dataPathArr, opts} = it\n    const nextData = gen.let(\"data\", _`${it.data}${getProperty(dataProp)}`, true)\n    dataContextProps(nextData)\n    subschema.errorPath = str`${errorPath}${getErrorPath(dataProp, dpType, opts.jsPropertySyntax)}`\n    subschema.parentDataProperty = _`${dataProp}`\n    subschema.dataPathArr = [...dataPathArr, subschema.parentDataProperty]\n  }\n\n  if (data !== undefined) {\n    const nextData = data instanceof Name ? data : gen.let(\"data\", data, true) // replaceable if used once?\n    dataContextProps(nextData)\n    if (propertyName !== undefined) subschema.propertyName = propertyName\n    // TODO something is possibly wrong here with not changing parentDataProperty and not appending dataPathArr\n  }\n\n  if (dataTypes) subschema.dataTypes = dataTypes\n\n  function dataContextProps(_nextData: Name): void {\n    subschema.data = _nextData\n    subschema.dataLevel = it.dataLevel + 1\n    subschema.dataTypes = []\n    it.definedProperties = new Set<string>()\n    subschema.parentData = it.data\n    subschema.dataNames = [...it.dataNames, _nextData]\n  }\n}\n\nexport function extendSubschemaMode(\n  subschema: SubschemaContext,\n  {jtdDiscriminator, jtdMetadata, compositeRule, createErrors, allErrors}: SubschemaArgs\n): void {\n  if (compositeRule !== undefined) subschema.compositeRule = compositeRule\n  if (createErrors !== undefined) subschema.createErrors = createErrors\n  if (allErrors !== undefined) subschema.allErrors = allErrors\n  subschema.jtdDiscriminator = jtdDiscriminator // not inherited\n  subschema.jtdMetadata = jtdMetadata // not inherited\n}\n","import type {CodeKeywordDefinition, ErrorObject, KeywordErrorDefinition} from \"../../types\"\nimport type {KeywordCxt} from \"../../compile/validate\"\nimport {_, str, operators, Code} from \"../../compile/codegen\"\n\nconst ops = operators\n\ntype Kwd = \"maximum\" | \"minimum\" | \"exclusiveMaximum\" | \"exclusiveMinimum\"\n\ntype Comparison = \"<=\" | \">=\" | \"<\" | \">\"\n\nconst KWDs: {[K in Kwd]: {okStr: Comparison; ok: Code; fail: Code}} = {\n  maximum: {okStr: \"<=\", ok: ops.LTE, fail: ops.GT},\n  minimum: {okStr: \">=\", ok: ops.GTE, fail: ops.LT},\n  exclusiveMaximum: {okStr: \"<\", ok: ops.LT, fail: ops.GTE},\n  exclusiveMinimum: {okStr: \">\", ok: ops.GT, fail: ops.LTE},\n}\n\nexport type LimitNumberError = ErrorObject<\n  Kwd,\n  {limit: number; comparison: Comparison},\n  number | {$data: string}\n>\n\nconst error: KeywordErrorDefinition = {\n  message: ({keyword, schemaCode}) => str`must be ${KWDs[keyword as Kwd].okStr} ${schemaCode}`,\n  params: ({keyword, schemaCode}) =>\n    _`{comparison: ${KWDs[keyword as Kwd].okStr}, limit: ${schemaCode}}`,\n}\n\nconst def: CodeKeywordDefinition = {\n  keyword: Object.keys(KWDs),\n  type: \"number\",\n  schemaType: \"number\",\n  $data: true,\n  error,\n  code(cxt: KeywordCxt) {\n    const {keyword, data, schemaCode} = cxt\n    cxt.fail$data(_`${data} ${KWDs[keyword as Kwd].fail} ${schemaCode} || isNaN(${data})`)\n  },\n}\n\nexport default def\n","import type {CodeKeywordDefinition, AnySchema} from \"../../types\"\nimport type {KeywordCxt} from \"../../compile/validate\"\nimport MissingRefError from \"../../compile/ref_error\"\nimport {callValidateCode} from \"../code\"\nimport {_, nil, stringify, Code, Name} from \"../../compile/codegen\"\nimport N from \"../../compile/names\"\nimport {SchemaEnv, resolveRef} from \"../../compile\"\nimport {mergeEvaluated} from \"../../compile/util\"\n\nconst def: CodeKeywordDefinition = {\n  keyword: \"$ref\",\n  schemaType: \"string\",\n  code(cxt: KeywordCxt): void {\n    const {gen, schema: $ref, it} = cxt\n    const {baseId, schemaEnv: env, validateName, opts, self} = it\n    const {root} = env\n    if (($ref === \"#\" || $ref === \"#/\") && baseId === root.baseId) return callRootRef()\n    const schOrEnv = resolveRef.call(self, root, baseId, $ref)\n    if (schOrEnv === undefined) throw new MissingRefError(it.opts.uriResolver, baseId, $ref)\n    if (schOrEnv instanceof SchemaEnv) return callValidate(schOrEnv)\n    return inlineRefSchema(schOrEnv)\n\n    function callRootRef(): void {\n      if (env === root) return callRef(cxt, validateName, env, env.$async)\n      const rootName = gen.scopeValue(\"root\", {ref: root})\n      return callRef(cxt, _`${rootName}.validate`, root, root.$async)\n    }\n\n    function callValidate(sch: SchemaEnv): void {\n      const v = getValidate(cxt, sch)\n      callRef(cxt, v, sch, sch.$async)\n    }\n\n    function inlineRefSchema(sch: AnySchema): void {\n      const schName = gen.scopeValue(\n        \"schema\",\n        opts.code.source === true ? {ref: sch, code: stringify(sch)} : {ref: sch}\n      )\n      const valid = gen.name(\"valid\")\n      const schCxt = cxt.subschema(\n        {\n          schema: sch,\n          dataTypes: [],\n          schemaPath: nil,\n          topSchemaRef: schName,\n          errSchemaPath: $ref,\n        },\n        valid\n      )\n      cxt.mergeEvaluated(schCxt)\n      cxt.ok(valid)\n    }\n  },\n}\n\nexport function getValidate(cxt: KeywordCxt, sch: SchemaEnv): Code {\n  const {gen} = cxt\n  return sch.validate\n    ? gen.scopeValue(\"validate\", {ref: sch.validate})\n    : _`${gen.scopeValue(\"wrapper\", {ref: sch})}.validate`\n}\n\nexport function callRef(cxt: KeywordCxt, v: Code, sch?: SchemaEnv, $async?: boolean): void {\n  const {gen, it} = cxt\n  const {allErrors, schemaEnv: env, opts} = it\n  const passCxt = opts.passContext ? N.this : nil\n  if ($async) callAsyncRef()\n  else callSyncRef()\n\n  function callAsyncRef(): void {\n    if (!env.$async) throw new Error(\"async schema referenced by sync schema\")\n    const valid = gen.let(\"valid\")\n    gen.try(\n      () => {\n        gen.code(_`await ${callValidateCode(cxt, v, passCxt)}`)\n        addEvaluatedFrom(v) // TODO will not work with async, it has to be returned with the result\n        if (!allErrors) gen.assign(valid, true)\n      },\n      (e) => {\n        gen.if(_`!(${e} instanceof ${it.ValidationError as Name})`, () => gen.throw(e))\n        addErrorsFrom(e)\n        if (!allErrors) gen.assign(valid, false)\n      }\n    )\n    cxt.ok(valid)\n  }\n\n  function callSyncRef(): void {\n    cxt.result(\n      callValidateCode(cxt, v, passCxt),\n      () => addEvaluatedFrom(v),\n      () => addErrorsFrom(v)\n    )\n  }\n\n  function addErrorsFrom(source: Code): void {\n    const errs = _`${source}.errors`\n    gen.assign(N.vErrors, _`${N.vErrors} === null ? ${errs} : ${N.vErrors}.concat(${errs})`) // TODO tagged\n    gen.assign(N.errors, _`${N.vErrors}.length`)\n  }\n\n  function addEvaluatedFrom(source: Code): void {\n    if (!it.opts.unevaluated) return\n    const schEvaluated = sch?.validate?.evaluated\n    // TODO refactor\n    if (it.props !== true) {\n      if (schEvaluated && !schEvaluated.dynamicProps) {\n        if (schEvaluated.props !== undefined) {\n          it.props = mergeEvaluated.props(gen, schEvaluated.props, it.props)\n        }\n      } else {\n        const props = gen.var(\"props\", _`${source}.evaluated.props`)\n        it.props = mergeEvaluated.props(gen, props, it.props, Name)\n      }\n    }\n    if (it.items !== true) {\n      if (schEvaluated && !schEvaluated.dynamicItems) {\n        if (schEvaluated.items !== undefined) {\n          it.items = mergeEvaluated.items(gen, schEvaluated.items, it.items)\n        }\n      } else {\n        const items = gen.var(\"items\", _`${source}.evaluated.items`)\n        it.items = mergeEvaluated.items(gen, items, it.items, Name)\n      }\n    }\n  }\n}\n\nexport default def\n","import type {Vocabulary} from \"../../types\"\nimport idKeyword from \"./id\"\nimport refKeyword from \"./ref\"\n\nconst core: Vocabulary = [\n  \"$schema\",\n  \"$id\",\n  \"$defs\",\n  \"$vocabulary\",\n  {keyword: \"$comment\"},\n  \"definitions\",\n  idKeyword,\n  refKeyword,\n]\n\nexport default core\n","import type {ErrorObject} from \"../../types\"\n\nexport enum DiscrError {\n  Tag = \"tag\",\n  Mapping = \"mapping\",\n}\n\nexport type DiscrErrorObj<E extends DiscrError> = ErrorObject<\n  \"discriminator\",\n  {error: E; tag: string; tagValue: unknown},\n  string\n>\n","import type {\n  AddedFormat,\n  FormatValidator,\n  AsyncFormatValidator,\n  CodeKeywordDefinition,\n  KeywordErrorDefinition,\n  ErrorObject,\n} from \"../../types\"\nimport type {KeywordCxt} from \"../../compile/validate\"\nimport {_, str, nil, or, Code, getProperty, regexpCode} from \"../../compile/codegen\"\n\ntype FormatValidate =\n  | FormatValidator<string>\n  | FormatValidator<number>\n  | AsyncFormatValidator<string>\n  | AsyncFormatValidator<number>\n  | RegExp\n  | string\n  | true\n\nexport type FormatError = ErrorObject<\"format\", {format: string}, string | {$data: string}>\n\nconst error: KeywordErrorDefinition = {\n  message: ({schemaCode}) => str`must match format \"${schemaCode}\"`,\n  params: ({schemaCode}) => _`{format: ${schemaCode}}`,\n}\n\nconst def: CodeKeywordDefinition = {\n  keyword: \"format\",\n  type: [\"number\", \"string\"],\n  schemaType: \"string\",\n  $data: true,\n  error,\n  code(cxt: KeywordCxt, ruleType?: string) {\n    const {gen, data, $data, schema, schemaCode, it} = cxt\n    const {opts, errSchemaPath, schemaEnv, self} = it\n    if (!opts.validateFormats) return\n\n    if ($data) validate$DataFormat()\n    else validateFormat()\n\n    function validate$DataFormat(): void {\n      const fmts = gen.scopeValue(\"formats\", {\n        ref: self.formats,\n        code: opts.code.formats,\n      })\n      const fDef = gen.const(\"fDef\", _`${fmts}[${schemaCode}]`)\n      const fType = gen.let(\"fType\")\n      const format = gen.let(\"format\")\n      // TODO simplify\n      gen.if(\n        _`typeof ${fDef} == \"object\" && !(${fDef} instanceof RegExp)`,\n        () => gen.assign(fType, _`${fDef}.type || \"string\"`).assign(format, _`${fDef}.validate`),\n        () => gen.assign(fType, _`\"string\"`).assign(format, fDef)\n      )\n      cxt.fail$data(or(unknownFmt(), invalidFmt()))\n\n      function unknownFmt(): Code {\n        if (opts.strictSchema === false) return nil\n        return _`${schemaCode} && !${format}`\n      }\n\n      function invalidFmt(): Code {\n        const callFormat = schemaEnv.$async\n          ? _`(${fDef}.async ? await ${format}(${data}) : ${format}(${data}))`\n          : _`${format}(${data})`\n        const validData = _`(typeof ${format} == \"function\" ? ${callFormat} : ${format}.test(${data}))`\n        return _`${format} && ${format} !== true && ${fType} === ${ruleType} && !${validData}`\n      }\n    }\n\n    function validateFormat(): void {\n      const formatDef: AddedFormat | undefined = self.formats[schema]\n      if (!formatDef) {\n        unknownFormat()\n        return\n      }\n      if (formatDef === true) return\n      const [fmtType, format, fmtRef] = getFormat(formatDef)\n      if (fmtType === ruleType) cxt.pass(validCondition())\n\n      function unknownFormat(): void {\n        if (opts.strictSchema === false) {\n          self.logger.warn(unknownMsg())\n          return\n        }\n        throw new Error(unknownMsg())\n\n        function unknownMsg(): string {\n          return `unknown format \"${schema as string}\" ignored in schema at path \"${errSchemaPath}\"`\n        }\n      }\n\n      function getFormat(fmtDef: AddedFormat): [string, FormatValidate, Code] {\n        const code =\n          fmtDef instanceof RegExp\n            ? regexpCode(fmtDef)\n            : opts.code.formats\n            ? _`${opts.code.formats}${getProperty(schema)}`\n            : undefined\n        const fmt = gen.scopeValue(\"formats\", {key: schema, ref: fmtDef, code})\n        if (typeof fmtDef == \"object\" && !(fmtDef instanceof RegExp)) {\n          return [fmtDef.type || \"string\", fmtDef.validate, _`${fmt}.validate`]\n        }\n\n        return [\"string\", fmtDef, fmt]\n      }\n\n      function validCondition(): Code {\n        if (typeof formatDef == \"object\" && !(formatDef instanceof RegExp) && formatDef.async) {\n          if (!schemaEnv.$async) throw new Error(\"async format in sync schema\")\n          return _`await ${fmtRef}(${data})`\n        }\n        return typeof format == \"function\" ? _`${fmtRef}(${data})` : _`${fmtRef}.test(${data})`\n      }\n    }\n  },\n}\n\nexport default def\n","// https://mathiasbynens.be/notes/javascript-encoding\n// https://github.com/bestiejs/punycode.js - punycode.ucs2.decode\nexport default function ucs2length(str: string): number {\n  const len = str.length\n  let length = 0\n  let pos = 0\n  let value: number\n  while (pos < len) {\n    length++\n    value = str.charCodeAt(pos++)\n    if (value >= 0xd800 && value <= 0xdbff && pos < len) {\n      // high surrogate, and there is a next character\n      value = str.charCodeAt(pos)\n      if ((value & 0xfc00) === 0xdc00) pos++ // low surrogate\n    }\n  }\n  return length\n}\n\nucs2length.code = 'require(\"ajv/dist/runtime/ucs2length\").default'\n","import type {ErrorObject} from \"../types\"\n\nexport default class ValidationError extends Error {\n  readonly errors: Partial<ErrorObject>[]\n  readonly ajv: true\n  readonly validation: true\n\n  constructor(errors: Partial<ErrorObject>[]) {\n    super(\"validation failed\")\n    this.errors = errors\n    this.ajv = this.validation = true\n  }\n}\n","export {\n  Format,\n  FormatDefinition,\n  AsyncFormatDefinition,\n  KeywordDefinition,\n  KeywordErrorDefinition,\n  CodeKeywordDefinition,\n  MacroKeywordDefinition,\n  FuncKeywordDefinition,\n  Vocabulary,\n  Schema,\n  SchemaObject,\n  AnySchemaObject,\n  AsyncSchema,\n  AnySchema,\n  ValidateFunction,\n  AsyncValidateFunction,\n  AnyValidateFunction,\n  ErrorObject,\n  ErrorNoParams,\n} from \"./types\"\n\nexport {SchemaCxt, SchemaObjCxt} from \"./compile\"\nexport interface Plugin<Opts> {\n  (ajv: Ajv, options?: Opts): Ajv\n  [prop: string]: any\n}\n\nexport {KeywordCxt} from \"./compile/validate\"\nexport {DefinedError} from \"./vocabularies/errors\"\nexport {JSONType} from \"./compile/rules\"\nexport {JSONSchemaType} from \"./types/json-schema\"\nexport {JTDSchemaType, SomeJTDSchemaType, JTDDataType} from \"./types/jtd-schema\"\nexport {_, str, stringify, nil, Name, Code, CodeGen, CodeGenOptions} from \"./compile/codegen\"\n\nimport type {\n  Schema,\n  AnySchema,\n  AnySchemaObject,\n  SchemaObject,\n  AsyncSchema,\n  Vocabulary,\n  KeywordDefinition,\n  AddedKeywordDefinition,\n  AnyValidateFunction,\n  ValidateFunction,\n  AsyncValidateFunction,\n  ErrorObject,\n  Format,\n  AddedFormat,\n  RegExpEngine,\n  UriResolver,\n} from \"./types\"\nimport type {JSONSchemaType} from \"./types/json-schema\"\nimport type {JTDSchemaType, SomeJTDSchemaType, JTDDataType} from \"./types/jtd-schema\"\nimport ValidationError from \"./runtime/validation_error\"\nimport MissingRefError from \"./compile/ref_error\"\nimport {getRules, ValidationRules, Rule, RuleGroup, JSONType} from \"./compile/rules\"\nimport {SchemaEnv, compileSchema, resolveSchema} from \"./compile\"\nimport {Code, ValueScope} from \"./compile/codegen\"\nimport {normalizeId, getSchemaRefs} from \"./compile/resolve\"\nimport {getJSONTypes} from \"./compile/validate/dataType\"\nimport {eachItem} from \"./compile/util\"\nimport * as $dataRefSchema from \"./refs/data.json\"\n\nimport DefaultUriResolver from \"./runtime/uri\"\n\nconst defaultRegExp: RegExpEngine = (str, flags) => new RegExp(str, flags)\ndefaultRegExp.code = \"new RegExp\"\n\nconst META_IGNORE_OPTIONS: (keyof Options)[] = [\"removeAdditional\", \"useDefaults\", \"coerceTypes\"]\nconst EXT_SCOPE_NAMES = new Set([\n  \"validate\",\n  \"serialize\",\n  \"parse\",\n  \"wrapper\",\n  \"root\",\n  \"schema\",\n  \"keyword\",\n  \"pattern\",\n  \"formats\",\n  \"validate$data\",\n  \"func\",\n  \"obj\",\n  \"Error\",\n])\n\nexport type Options = CurrentOptions & DeprecatedOptions\n\nexport interface CurrentOptions {\n  // strict mode options (NEW)\n  strict?: boolean | \"log\"\n  strictSchema?: boolean | \"log\"\n  strictNumbers?: boolean | \"log\"\n  strictTypes?: boolean | \"log\"\n  strictTuples?: boolean | \"log\"\n  strictRequired?: boolean | \"log\"\n  allowMatchingProperties?: boolean // disables a strict mode restriction\n  allowUnionTypes?: boolean\n  validateFormats?: boolean\n  // validation and reporting options:\n  $data?: boolean\n  allErrors?: boolean\n  verbose?: boolean\n  discriminator?: boolean\n  unicodeRegExp?: boolean\n  timestamp?: \"string\" | \"date\" // JTD only\n  parseDate?: boolean // JTD only\n  allowDate?: boolean // JTD only\n  $comment?:\n    | true\n    | ((comment: string, schemaPath?: string, rootSchema?: AnySchemaObject) => unknown)\n  formats?: {[Name in string]?: Format}\n  keywords?: Vocabulary\n  schemas?: AnySchema[] | {[Key in string]?: AnySchema}\n  logger?: Logger | false\n  loadSchema?: (uri: string) => Promise<AnySchemaObject>\n  // options to modify validated data:\n  removeAdditional?: boolean | \"all\" | \"failing\"\n  useDefaults?: boolean | \"empty\"\n  coerceTypes?: boolean | \"array\"\n  // advanced options:\n  next?: boolean // NEW\n  unevaluated?: boolean // NEW\n  dynamicRef?: boolean // NEW\n  schemaId?: \"id\" | \"$id\"\n  jtd?: boolean // NEW\n  meta?: SchemaObject | boolean\n  defaultMeta?: string | AnySchemaObject\n  validateSchema?: boolean | \"log\"\n  addUsedSchema?: boolean\n  inlineRefs?: boolean | number\n  passContext?: boolean\n  loopRequired?: number\n  loopEnum?: number // NEW\n  ownProperties?: boolean\n  multipleOfPrecision?: number\n  int32range?: boolean // JTD only\n  messages?: boolean\n  code?: CodeOptions // NEW\n  uriResolver?: UriResolver\n}\n\nexport interface CodeOptions {\n  es5?: boolean\n  esm?: boolean\n  lines?: boolean\n  optimize?: boolean | number\n  formats?: Code // code to require (or construct) map of available formats - for standalone code\n  source?: boolean\n  process?: (code: string, schema?: SchemaEnv) => string\n  regExp?: RegExpEngine\n}\n\ninterface InstanceCodeOptions extends CodeOptions {\n  regExp: RegExpEngine\n  optimize: number\n}\n\ninterface DeprecatedOptions {\n  /** @deprecated */\n  ignoreKeywordsWithRef?: boolean\n  /** @deprecated */\n  jsPropertySyntax?: boolean // added instead of jsonPointers\n  /** @deprecated */\n  unicode?: boolean\n}\n\ninterface RemovedOptions {\n  format?: boolean\n  errorDataPath?: \"object\" | \"property\"\n  nullable?: boolean // \"nullable\" keyword is supported by default\n  jsonPointers?: boolean\n  extendRefs?: true | \"ignore\" | \"fail\"\n  missingRefs?: true | \"ignore\" | \"fail\"\n  processCode?: (code: string, schema?: SchemaEnv) => string\n  sourceCode?: boolean\n  strictDefaults?: boolean\n  strictKeywords?: boolean\n  uniqueItems?: boolean\n  unknownFormats?: true | string[] | \"ignore\"\n  cache?: any\n  serialize?: (schema: AnySchema) => unknown\n  ajvErrors?: boolean\n}\n\ntype OptionsInfo<T extends RemovedOptions | DeprecatedOptions> = {\n  [K in keyof T]-?: string | undefined\n}\n\nconst removedOptions: OptionsInfo<RemovedOptions> = {\n  errorDataPath: \"\",\n  format: \"`validateFormats: false` can be used instead.\",\n  nullable: '\"nullable\" keyword is supported by default.',\n  jsonPointers: \"Deprecated jsPropertySyntax can be used instead.\",\n  extendRefs: \"Deprecated ignoreKeywordsWithRef can be used instead.\",\n  missingRefs: \"Pass empty schema with $id that should be ignored to ajv.addSchema.\",\n  processCode: \"Use option `code: {process: (code, schemaEnv: object) => string}`\",\n  sourceCode: \"Use option `code: {source: true}`\",\n  strictDefaults: \"It is default now, see option `strict`.\",\n  strictKeywords: \"It is default now, see option `strict`.\",\n  uniqueItems: '\"uniqueItems\" keyword is always validated.',\n  unknownFormats: \"Disable strict mode or pass `true` to `ajv.addFormat` (or `formats` option).\",\n  cache: \"Map is used as cache, schema object as key.\",\n  serialize: \"Map is used as cache, schema object as key.\",\n  ajvErrors: \"It is default now.\",\n}\n\nconst deprecatedOptions: OptionsInfo<DeprecatedOptions> = {\n  ignoreKeywordsWithRef: \"\",\n  jsPropertySyntax: \"\",\n  unicode: '\"minLength\"/\"maxLength\" account for unicode characters by default.',\n}\n\ntype RequiredInstanceOptions = {\n  [K in\n    | \"strictSchema\"\n    | \"strictNumbers\"\n    | \"strictTypes\"\n    | \"strictTuples\"\n    | \"strictRequired\"\n    | \"inlineRefs\"\n    | \"loopRequired\"\n    | \"loopEnum\"\n    | \"meta\"\n    | \"messages\"\n    | \"schemaId\"\n    | \"addUsedSchema\"\n    | \"validateSchema\"\n    | \"validateFormats\"\n    | \"int32range\"\n    | \"unicodeRegExp\"\n    | \"uriResolver\"]: NonNullable<Options[K]>\n} & {code: InstanceCodeOptions}\n\nexport type InstanceOptions = Options & RequiredInstanceOptions\n\nconst MAX_EXPRESSION = 200\n\n// eslint-disable-next-line complexity\nfunction requiredOptions(o: Options): RequiredInstanceOptions {\n  const s = o.strict\n  const _optz = o.code?.optimize\n  const optimize = _optz === true || _optz === undefined ? 1 : _optz || 0\n  const regExp = o.code?.regExp ?? defaultRegExp\n  const uriResolver = o.uriResolver ?? DefaultUriResolver\n  return {\n    strictSchema: o.strictSchema ?? s ?? true,\n    strictNumbers: o.strictNumbers ?? s ?? true,\n    strictTypes: o.strictTypes ?? s ?? \"log\",\n    strictTuples: o.strictTuples ?? s ?? \"log\",\n    strictRequired: o.strictRequired ?? s ?? false,\n    code: o.code ? {...o.code, optimize, regExp} : {optimize, regExp},\n    loopRequired: o.loopRequired ?? MAX_EXPRESSION,\n    loopEnum: o.loopEnum ?? MAX_EXPRESSION,\n    meta: o.meta ?? true,\n    messages: o.messages ?? true,\n    inlineRefs: o.inlineRefs ?? true,\n    schemaId: o.schemaId ?? \"$id\",\n    addUsedSchema: o.addUsedSchema ?? true,\n    validateSchema: o.validateSchema ?? true,\n    validateFormats: o.validateFormats ?? true,\n    unicodeRegExp: o.unicodeRegExp ?? true,\n    int32range: o.int32range ?? true,\n    uriResolver: uriResolver,\n  }\n}\n\nexport interface Logger {\n  log(...args: unknown[]): unknown\n  warn(...args: unknown[]): unknown\n  error(...args: unknown[]): unknown\n}\n\nexport default class Ajv {\n  opts: InstanceOptions\n  errors?: ErrorObject[] | null // errors from the last validation\n  logger: Logger\n  // shared external scope values for compiled functions\n  readonly scope: ValueScope\n  readonly schemas: {[Key in string]?: SchemaEnv} = {}\n  readonly refs: {[Ref in string]?: SchemaEnv | string} = {}\n  readonly formats: {[Name in string]?: AddedFormat} = {}\n  readonly RULES: ValidationRules\n  readonly _compilations: Set<SchemaEnv> = new Set()\n  private readonly _loading: {[Ref in string]?: Promise<AnySchemaObject>} = {}\n  private readonly _cache: Map<AnySchema, SchemaEnv> = new Map()\n  private readonly _metaOpts: InstanceOptions\n\n  static ValidationError = ValidationError\n  static MissingRefError = MissingRefError\n\n  constructor(opts: Options = {}) {\n    opts = this.opts = {...opts, ...requiredOptions(opts)}\n    const {es5, lines} = this.opts.code\n\n    this.scope = new ValueScope({scope: {}, prefixes: EXT_SCOPE_NAMES, es5, lines})\n    this.logger = getLogger(opts.logger)\n    const formatOpt = opts.validateFormats\n    opts.validateFormats = false\n\n    this.RULES = getRules()\n    checkOptions.call(this, removedOptions, opts, \"NOT SUPPORTED\")\n    checkOptions.call(this, deprecatedOptions, opts, \"DEPRECATED\", \"warn\")\n    this._metaOpts = getMetaSchemaOptions.call(this)\n\n    if (opts.formats) addInitialFormats.call(this)\n    this._addVocabularies()\n    this._addDefaultMetaSchema()\n    if (opts.keywords) addInitialKeywords.call(this, opts.keywords)\n    if (typeof opts.meta == \"object\") this.addMetaSchema(opts.meta)\n    addInitialSchemas.call(this)\n    opts.validateFormats = formatOpt\n  }\n\n  _addVocabularies(): void {\n    this.addKeyword(\"$async\")\n  }\n\n  _addDefaultMetaSchema(): void {\n    const {$data, meta, schemaId} = this.opts\n    let _dataRefSchema: SchemaObject = $dataRefSchema\n    if (schemaId === \"id\") {\n      _dataRefSchema = {...$dataRefSchema}\n      _dataRefSchema.id = _dataRefSchema.$id\n      delete _dataRefSchema.$id\n    }\n    if (meta && $data) this.addMetaSchema(_dataRefSchema, _dataRefSchema[schemaId], false)\n  }\n\n  defaultMeta(): string | AnySchemaObject | undefined {\n    const {meta, schemaId} = this.opts\n    return (this.opts.defaultMeta = typeof meta == \"object\" ? meta[schemaId] || meta : undefined)\n  }\n\n  // Validate data using schema\n  // AnySchema will be compiled and cached using schema itself as a key for Map\n  validate(schema: Schema | string, data: unknown): boolean\n  validate(schemaKeyRef: AnySchema | string, data: unknown): boolean | Promise<unknown>\n  validate<T>(schema: Schema | JSONSchemaType<T> | string, data: unknown): data is T\n  // Separated for type inference to work\n  // eslint-disable-next-line @typescript-eslint/unified-signatures\n  validate<T>(schema: JTDSchemaType<T>, data: unknown): data is T\n  // This overload is only intended for typescript inference, the first\n  // argument prevents manual type annotation from matching this overload\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  validate<N extends never, T extends SomeJTDSchemaType>(\n    schema: T,\n    data: unknown\n  ): data is JTDDataType<T>\n  // eslint-disable-next-line @typescript-eslint/no-redundant-type-constituents\n  validate<T>(schema: AsyncSchema, data: unknown | T): Promise<T>\n  validate<T>(schemaKeyRef: AnySchema | string, data: unknown): data is T | Promise<T>\n  validate<T>(\n    schemaKeyRef: AnySchema | string, // key, ref or schema object\n    // eslint-disable-next-line @typescript-eslint/no-redundant-type-constituents\n    data: unknown | T // to be validated\n  ): boolean | Promise<T> {\n    let v: AnyValidateFunction | undefined\n    if (typeof schemaKeyRef == \"string\") {\n      v = this.getSchema<T>(schemaKeyRef)\n      if (!v) throw new Error(`no schema with key or ref \"${schemaKeyRef}\"`)\n    } else {\n      v = this.compile<T>(schemaKeyRef)\n    }\n\n    const valid = v(data)\n    if (!(\"$async\" in v)) this.errors = v.errors\n    return valid\n  }\n\n  // Create validation function for passed schema\n  // _meta: true if schema is a meta-schema. Used internally to compile meta schemas of user-defined keywords.\n  compile<T = unknown>(schema: Schema | JSONSchemaType<T>, _meta?: boolean): ValidateFunction<T>\n  // Separated for type inference to work\n  // eslint-disable-next-line @typescript-eslint/unified-signatures\n  compile<T = unknown>(schema: JTDSchemaType<T>, _meta?: boolean): ValidateFunction<T>\n  // This overload is only intended for typescript inference, the first\n  // argument prevents manual type annotation from matching this overload\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  compile<N extends never, T extends SomeJTDSchemaType>(\n    schema: T,\n    _meta?: boolean\n  ): ValidateFunction<JTDDataType<T>>\n  compile<T = unknown>(schema: AsyncSchema, _meta?: boolean): AsyncValidateFunction<T>\n  compile<T = unknown>(schema: AnySchema, _meta?: boolean): AnyValidateFunction<T>\n  compile<T = unknown>(schema: AnySchema, _meta?: boolean): AnyValidateFunction<T> {\n    const sch = this._addSchema(schema, _meta)\n    return (sch.validate || this._compileSchemaEnv(sch)) as AnyValidateFunction<T>\n  }\n\n  // Creates validating function for passed schema with asynchronous loading of missing schemas.\n  // `loadSchema` option should be a function that accepts schema uri and returns promise that resolves with the schema.\n  // TODO allow passing schema URI\n  // meta - optional true to compile meta-schema\n  compileAsync<T = unknown>(\n    schema: SchemaObject | JSONSchemaType<T>,\n    _meta?: boolean\n  ): Promise<ValidateFunction<T>>\n  // Separated for type inference to work\n  // eslint-disable-next-line @typescript-eslint/unified-signatures\n  compileAsync<T = unknown>(schema: JTDSchemaType<T>, _meta?: boolean): Promise<ValidateFunction<T>>\n  compileAsync<T = unknown>(schema: AsyncSchema, meta?: boolean): Promise<AsyncValidateFunction<T>>\n  // eslint-disable-next-line @typescript-eslint/unified-signatures\n  compileAsync<T = unknown>(\n    schema: AnySchemaObject,\n    meta?: boolean\n  ): Promise<AnyValidateFunction<T>>\n  compileAsync<T = unknown>(\n    schema: AnySchemaObject,\n    meta?: boolean\n  ): Promise<AnyValidateFunction<T>> {\n    if (typeof this.opts.loadSchema != \"function\") {\n      throw new Error(\"options.loadSchema should be a function\")\n    }\n    const {loadSchema} = this.opts\n    return runCompileAsync.call(this, schema, meta)\n\n    async function runCompileAsync(\n      this: Ajv,\n      _schema: AnySchemaObject,\n      _meta?: boolean\n    ): Promise<AnyValidateFunction> {\n      await loadMetaSchema.call(this, _schema.$schema)\n      const sch = this._addSchema(_schema, _meta)\n      return sch.validate || _compileAsync.call(this, sch)\n    }\n\n    async function loadMetaSchema(this: Ajv, $ref?: string): Promise<void> {\n      if ($ref && !this.getSchema($ref)) {\n        await runCompileAsync.call(this, {$ref}, true)\n      }\n    }\n\n    async function _compileAsync(this: Ajv, sch: SchemaEnv): Promise<AnyValidateFunction> {\n      try {\n        return this._compileSchemaEnv(sch)\n      } catch (e) {\n        if (!(e instanceof MissingRefError)) throw e\n        checkLoaded.call(this, e)\n        await loadMissingSchema.call(this, e.missingSchema)\n        return _compileAsync.call(this, sch)\n      }\n    }\n\n    function checkLoaded(this: Ajv, {missingSchema: ref, missingRef}: MissingRefError): void {\n      if (this.refs[ref]) {\n        throw new Error(`AnySchema ${ref} is loaded but ${missingRef} cannot be resolved`)\n      }\n    }\n\n    async function loadMissingSchema(this: Ajv, ref: string): Promise<void> {\n      const _schema = await _loadSchema.call(this, ref)\n      if (!this.refs[ref]) await loadMetaSchema.call(this, _schema.$schema)\n      if (!this.refs[ref]) this.addSchema(_schema, ref, meta)\n    }\n\n    async function _loadSchema(this: Ajv, ref: string): Promise<AnySchemaObject> {\n      const p = this._loading[ref]\n      if (p) return p\n      try {\n        return await (this._loading[ref] = loadSchema(ref))\n      } finally {\n        delete this._loading[ref]\n      }\n    }\n  }\n\n  // Adds schema to the instance\n  addSchema(\n    schema: AnySchema | AnySchema[], // If array is passed, `key` will be ignored\n    key?: string, // Optional schema key. Can be passed to `validate` method instead of schema object or id/ref. One schema per instance can have empty `id` and `key`.\n    _meta?: boolean, // true if schema is a meta-schema. Used internally, addMetaSchema should be used instead.\n    _validateSchema = this.opts.validateSchema // false to skip schema validation. Used internally, option validateSchema should be used instead.\n  ): Ajv {\n    if (Array.isArray(schema)) {\n      for (const sch of schema) this.addSchema(sch, undefined, _meta, _validateSchema)\n      return this\n    }\n    let id: string | undefined\n    if (typeof schema === \"object\") {\n      const {schemaId} = this.opts\n      id = schema[schemaId]\n      if (id !== undefined && typeof id != \"string\") {\n        throw new Error(`schema ${schemaId} must be string`)\n      }\n    }\n    key = normalizeId(key || id)\n    this._checkUnique(key)\n    this.schemas[key] = this._addSchema(schema, _meta, key, _validateSchema, true)\n    return this\n  }\n\n  // Add schema that will be used to validate other schemas\n  // options in META_IGNORE_OPTIONS are alway set to false\n  addMetaSchema(\n    schema: AnySchemaObject,\n    key?: string, // schema key\n    _validateSchema = this.opts.validateSchema // false to skip schema validation, can be used to override validateSchema option for meta-schema\n  ): Ajv {\n    this.addSchema(schema, key, true, _validateSchema)\n    return this\n  }\n\n  //  Validate schema against its meta-schema\n  validateSchema(schema: AnySchema, throwOrLogError?: boolean): boolean | Promise<unknown> {\n    if (typeof schema == \"boolean\") return true\n    let $schema: string | AnySchemaObject | undefined\n    $schema = schema.$schema\n    if ($schema !== undefined && typeof $schema != \"string\") {\n      throw new Error(\"$schema must be a string\")\n    }\n    $schema = $schema || this.opts.defaultMeta || this.defaultMeta()\n    if (!$schema) {\n      this.logger.warn(\"meta-schema not available\")\n      this.errors = null\n      return true\n    }\n    const valid = this.validate($schema, schema)\n    if (!valid && throwOrLogError) {\n      const message = \"schema is invalid: \" + this.errorsText()\n      if (this.opts.validateSchema === \"log\") this.logger.error(message)\n      else throw new Error(message)\n    }\n    return valid\n  }\n\n  // Get compiled schema by `key` or `ref`.\n  // (`key` that was passed to `addSchema` or full schema reference - `schema.$id` or resolved id)\n  getSchema<T = unknown>(keyRef: string): AnyValidateFunction<T> | undefined {\n    let sch\n    while (typeof (sch = getSchEnv.call(this, keyRef)) == \"string\") keyRef = sch\n    if (sch === undefined) {\n      const {schemaId} = this.opts\n      const root = new SchemaEnv({schema: {}, schemaId})\n      sch = resolveSchema.call(this, root, keyRef)\n      if (!sch) return\n      this.refs[keyRef] = sch\n    }\n    return (sch.validate || this._compileSchemaEnv(sch)) as AnyValidateFunction<T> | undefined\n  }\n\n  // Remove cached schema(s).\n  // If no parameter is passed all schemas but meta-schemas are removed.\n  // If RegExp is passed all schemas with key/id matching pattern but meta-schemas are removed.\n  // Even if schema is referenced by other schemas it still can be removed as other schemas have local references.\n  removeSchema(schemaKeyRef?: AnySchema | string | RegExp): Ajv {\n    if (schemaKeyRef instanceof RegExp) {\n      this._removeAllSchemas(this.schemas, schemaKeyRef)\n      this._removeAllSchemas(this.refs, schemaKeyRef)\n      return this\n    }\n    switch (typeof schemaKeyRef) {\n      case \"undefined\":\n        this._removeAllSchemas(this.schemas)\n        this._removeAllSchemas(this.refs)\n        this._cache.clear()\n        return this\n      case \"string\": {\n        const sch = getSchEnv.call(this, schemaKeyRef)\n        if (typeof sch == \"object\") this._cache.delete(sch.schema)\n        delete this.schemas[schemaKeyRef]\n        delete this.refs[schemaKeyRef]\n        return this\n      }\n      case \"object\": {\n        const cacheKey = schemaKeyRef\n        this._cache.delete(cacheKey)\n        let id = schemaKeyRef[this.opts.schemaId]\n        if (id) {\n          id = normalizeId(id)\n          delete this.schemas[id]\n          delete this.refs[id]\n        }\n        return this\n      }\n      default:\n        throw new Error(\"ajv.removeSchema: invalid parameter\")\n    }\n  }\n\n  // add \"vocabulary\" - a collection of keywords\n  addVocabulary(definitions: Vocabulary): Ajv {\n    for (const def of definitions) this.addKeyword(def)\n    return this\n  }\n\n  addKeyword(\n    kwdOrDef: string | KeywordDefinition,\n    def?: KeywordDefinition // deprecated\n  ): Ajv {\n    let keyword: string | string[]\n    if (typeof kwdOrDef == \"string\") {\n      keyword = kwdOrDef\n      if (typeof def == \"object\") {\n        this.logger.warn(\"these parameters are deprecated, see docs for addKeyword\")\n        def.keyword = keyword\n      }\n    } else if (typeof kwdOrDef == \"object\" && def === undefined) {\n      def = kwdOrDef\n      keyword = def.keyword\n      if (Array.isArray(keyword) && !keyword.length) {\n        throw new Error(\"addKeywords: keyword must be string or non-empty array\")\n      }\n    } else {\n      throw new Error(\"invalid addKeywords parameters\")\n    }\n\n    checkKeyword.call(this, keyword, def)\n    if (!def) {\n      eachItem(keyword, (kwd) => addRule.call(this, kwd))\n      return this\n    }\n    keywordMetaschema.call(this, def)\n    const definition: AddedKeywordDefinition = {\n      ...def,\n      type: getJSONTypes(def.type),\n      schemaType: getJSONTypes(def.schemaType),\n    }\n    eachItem(\n      keyword,\n      definition.type.length === 0\n        ? (k) => addRule.call(this, k, definition)\n        : (k) => definition.type.forEach((t) => addRule.call(this, k, definition, t))\n    )\n    return this\n  }\n\n  getKeyword(keyword: string): AddedKeywordDefinition | boolean {\n    const rule = this.RULES.all[keyword]\n    return typeof rule == \"object\" ? rule.definition : !!rule\n  }\n\n  // Remove keyword\n  removeKeyword(keyword: string): Ajv {\n    // TODO return type should be Ajv\n    const {RULES} = this\n    delete RULES.keywords[keyword]\n    delete RULES.all[keyword]\n    for (const group of RULES.rules) {\n      const i = group.rules.findIndex((rule) => rule.keyword === keyword)\n      if (i >= 0) group.rules.splice(i, 1)\n    }\n    return this\n  }\n\n  // Add format\n  addFormat(name: string, format: Format): Ajv {\n    if (typeof format == \"string\") format = new RegExp(format)\n    this.formats[name] = format\n    return this\n  }\n\n  errorsText(\n    errors: ErrorObject[] | null | undefined = this.errors, // optional array of validation errors\n    {separator = \", \", dataVar = \"data\"}: ErrorsTextOptions = {} // optional options with properties `separator` and `dataVar`\n  ): string {\n    if (!errors || errors.length === 0) return \"No errors\"\n    return errors\n      .map((e) => `${dataVar}${e.instancePath} ${e.message}`)\n      .reduce((text, msg) => text + separator + msg)\n  }\n\n  $dataMetaSchema(metaSchema: AnySchemaObject, keywordsJsonPointers: string[]): AnySchemaObject {\n    const rules = this.RULES.all\n    metaSchema = JSON.parse(JSON.stringify(metaSchema))\n    for (const jsonPointer of keywordsJsonPointers) {\n      const segments = jsonPointer.split(\"/\").slice(1) // first segment is an empty string\n      let keywords = metaSchema\n      for (const seg of segments) keywords = keywords[seg] as AnySchemaObject\n\n      for (const key in rules) {\n        const rule = rules[key]\n        if (typeof rule != \"object\") continue\n        const {$data} = rule.definition\n        const schema = keywords[key] as AnySchemaObject | undefined\n        if ($data && schema) keywords[key] = schemaOrData(schema)\n      }\n    }\n\n    return metaSchema\n  }\n\n  private _removeAllSchemas(schemas: {[Ref in string]?: SchemaEnv | string}, regex?: RegExp): void {\n    for (const keyRef in schemas) {\n      const sch = schemas[keyRef]\n      if (!regex || regex.test(keyRef)) {\n        if (typeof sch == \"string\") {\n          delete schemas[keyRef]\n        } else if (sch && !sch.meta) {\n          this._cache.delete(sch.schema)\n          delete schemas[keyRef]\n        }\n      }\n    }\n  }\n\n  _addSchema(\n    schema: AnySchema,\n    meta?: boolean,\n    baseId?: string,\n    validateSchema = this.opts.validateSchema,\n    addSchema = this.opts.addUsedSchema\n  ): SchemaEnv {\n    let id: string | undefined\n    const {schemaId} = this.opts\n    if (typeof schema == \"object\") {\n      id = schema[schemaId]\n    } else {\n      if (this.opts.jtd) throw new Error(\"schema must be object\")\n      else if (typeof schema != \"boolean\") throw new Error(\"schema must be object or boolean\")\n    }\n    let sch = this._cache.get(schema)\n    if (sch !== undefined) return sch\n\n    baseId = normalizeId(id || baseId)\n    const localRefs = getSchemaRefs.call(this, schema, baseId)\n    sch = new SchemaEnv({schema, schemaId, meta, baseId, localRefs})\n    this._cache.set(sch.schema, sch)\n    if (addSchema && !baseId.startsWith(\"#\")) {\n      // TODO atm it is allowed to overwrite schemas without id (instead of not adding them)\n      if (baseId) this._checkUnique(baseId)\n      this.refs[baseId] = sch\n    }\n    if (validateSchema) this.validateSchema(schema, true)\n    return sch\n  }\n\n  private _checkUnique(id: string): void {\n    if (this.schemas[id] || this.refs[id]) {\n      throw new Error(`schema with key or id \"${id}\" already exists`)\n    }\n  }\n\n  private _compileSchemaEnv(sch: SchemaEnv): AnyValidateFunction {\n    if (sch.meta) this._compileMetaSchema(sch)\n    else compileSchema.call(this, sch)\n\n    /* istanbul ignore if */\n    if (!sch.validate) throw new Error(\"ajv implementation error\")\n    return sch.validate\n  }\n\n  private _compileMetaSchema(sch: SchemaEnv): void {\n    const currentOpts = this.opts\n    this.opts = this._metaOpts\n    try {\n      compileSchema.call(this, sch)\n    } finally {\n      this.opts = currentOpts\n    }\n  }\n}\n\nexport interface ErrorsTextOptions {\n  separator?: string\n  dataVar?: string\n}\n\nfunction checkOptions(\n  this: Ajv,\n  checkOpts: OptionsInfo<RemovedOptions | DeprecatedOptions>,\n  options: Options & RemovedOptions,\n  msg: string,\n  log: \"warn\" | \"error\" = \"error\"\n): void {\n  for (const key in checkOpts) {\n    const opt = key as keyof typeof checkOpts\n    if (opt in options) this.logger[log](`${msg}: option ${key}. ${checkOpts[opt]}`)\n  }\n}\n\nfunction getSchEnv(this: Ajv, keyRef: string): SchemaEnv | string | undefined {\n  keyRef = normalizeId(keyRef) // TODO tests fail without this line\n  return this.schemas[keyRef] || this.refs[keyRef]\n}\n\nfunction addInitialSchemas(this: Ajv): void {\n  const optsSchemas = this.opts.schemas\n  if (!optsSchemas) return\n  if (Array.isArray(optsSchemas)) this.addSchema(optsSchemas)\n  else for (const key in optsSchemas) this.addSchema(optsSchemas[key] as AnySchema, key)\n}\n\nfunction addInitialFormats(this: Ajv): void {\n  for (const name in this.opts.formats) {\n    const format = this.opts.formats[name]\n    if (format) this.addFormat(name, format)\n  }\n}\n\nfunction addInitialKeywords(\n  this: Ajv,\n  defs: Vocabulary | {[K in string]?: KeywordDefinition}\n): void {\n  if (Array.isArray(defs)) {\n    this.addVocabulary(defs)\n    return\n  }\n  this.logger.warn(\"keywords option as map is deprecated, pass array\")\n  for (const keyword in defs) {\n    const def = defs[keyword] as KeywordDefinition\n    if (!def.keyword) def.keyword = keyword\n    this.addKeyword(def)\n  }\n}\n\nfunction getMetaSchemaOptions(this: Ajv): InstanceOptions {\n  const metaOpts = {...this.opts}\n  for (const opt of META_IGNORE_OPTIONS) delete metaOpts[opt]\n  return metaOpts\n}\n\nconst noLogs = {log() {}, warn() {}, error() {}}\n\nfunction getLogger(logger?: Partial<Logger> | false): Logger {\n  if (logger === false) return noLogs\n  if (logger === undefined) return console\n  if (logger.log && logger.warn && logger.error) return logger as Logger\n  throw new Error(\"logger must implement log, warn and error methods\")\n}\n\nconst KEYWORD_NAME = /^[a-z_$][a-z0-9_$:-]*$/i\n\nfunction checkKeyword(this: Ajv, keyword: string | string[], def?: KeywordDefinition): void {\n  const {RULES} = this\n  eachItem(keyword, (kwd) => {\n    if (RULES.keywords[kwd]) throw new Error(`Keyword ${kwd} is already defined`)\n    if (!KEYWORD_NAME.test(kwd)) throw new Error(`Keyword ${kwd} has invalid name`)\n  })\n  if (!def) return\n  if (def.$data && !(\"code\" in def || \"validate\" in def)) {\n    throw new Error('$data keyword must have \"code\" or \"validate\" function')\n  }\n}\n\nfunction addRule(\n  this: Ajv,\n  keyword: string,\n  definition?: AddedKeywordDefinition,\n  dataType?: JSONType\n): void {\n  const post = definition?.post\n  if (dataType && post) throw new Error('keyword with \"post\" flag cannot have \"type\"')\n  const {RULES} = this\n  let ruleGroup = post ? RULES.post : RULES.rules.find(({type: t}) => t === dataType)\n  if (!ruleGroup) {\n    ruleGroup = {type: dataType, rules: []}\n    RULES.rules.push(ruleGroup)\n  }\n  RULES.keywords[keyword] = true\n  if (!definition) return\n\n  const rule: Rule = {\n    keyword,\n    definition: {\n      ...definition,\n      type: getJSONTypes(definition.type),\n      schemaType: getJSONTypes(definition.schemaType),\n    },\n  }\n  if (definition.before) addBeforeRule.call(this, ruleGroup, rule, definition.before)\n  else ruleGroup.rules.push(rule)\n  RULES.all[keyword] = rule\n  definition.implements?.forEach((kwd) => this.addKeyword(kwd))\n}\n\nfunction addBeforeRule(this: Ajv, ruleGroup: RuleGroup, rule: Rule, before: string): void {\n  const i = ruleGroup.rules.findIndex((_rule) => _rule.keyword === before)\n  if (i >= 0) {\n    ruleGroup.rules.splice(i, 0, rule)\n  } else {\n    ruleGroup.rules.push(rule)\n    this.logger.warn(`rule ${before} is not defined`)\n  }\n}\n\nfunction keywordMetaschema(this: Ajv, def: KeywordDefinition): void {\n  let {metaSchema} = def\n  if (metaSchema === undefined) return\n  if (def.$data && this.opts.$data) metaSchema = schemaOrData(metaSchema)\n  def.validateSchema = this.compile(metaSchema, true)\n}\n\nconst $dataRef = {\n  $ref: \"https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#\",\n}\n\nfunction schemaOrData(schema: AnySchema): AnySchemaObject {\n  return {anyOf: [schema, $dataRef]}\n}\n","import type {CodeKeywordDefinition, KeywordErrorDefinition} from \"../../types\"\nimport type {KeywordCxt} from \"../../compile/validate\"\nimport {_, str, operators} from \"../../compile/codegen\"\nimport {useFunc} from \"../../compile/util\"\nimport ucs2length from \"../../runtime/ucs2length\"\n\nconst error: KeywordErrorDefinition = {\n  message({keyword, schemaCode}) {\n    const comp = keyword === \"maxLength\" ? \"more\" : \"fewer\"\n    return str`must NOT have ${comp} than ${schemaCode} characters`\n  },\n  params: ({schemaCode}) => _`{limit: ${schemaCode}}`,\n}\n\nconst def: CodeKeywordDefinition = {\n  keyword: [\"maxLength\", \"minLength\"],\n  type: \"string\",\n  schemaType: \"number\",\n  $data: true,\n  error,\n  code(cxt: KeywordCxt) {\n    const {keyword, data, schemaCode, it} = cxt\n    const op = keyword === \"maxLength\" ? operators.GT : operators.LT\n    const len =\n      it.opts.unicode === false ? _`${data}.length` : _`${useFunc(cxt.gen, ucs2length)}(${data})`\n    cxt.fail$data(_`${len} ${op} ${schemaCode}`)\n  },\n}\n\nexport default def\n","import type {\n  AnySchema,\n  AnySchemaObject,\n  AnyValidateFunction,\n  AsyncValidateFunction,\n  EvaluatedProperties,\n  EvaluatedItems,\n} from \"../types\"\nimport type Ajv from \"../core\"\nimport type {InstanceOptions} from \"../core\"\nimport {CodeGen, _, nil, stringify, Name, Code, ValueScopeName} from \"./codegen\"\nimport ValidationError from \"../runtime/validation_error\"\nimport N from \"./names\"\nimport {LocalRefs, getFullPath, _getFullPath, inlineRef, normalizeId, resolveUrl} from \"./resolve\"\nimport {schemaHasRulesButRef, unescapeFragment} from \"./util\"\nimport {validateFunctionCode} from \"./validate\"\nimport {URIComponent} from \"fast-uri\"\nimport {JSONType} from \"./rules\"\n\nexport type SchemaRefs = {\n  [Ref in string]?: SchemaEnv | AnySchema\n}\n\nexport interface SchemaCxt {\n  readonly gen: CodeGen\n  readonly allErrors?: boolean // validation mode - whether to collect all errors or break on error\n  readonly data: Name // Name with reference to the current part of data instance\n  readonly parentData: Name // should be used in keywords modifying data\n  readonly parentDataProperty: Code | number // should be used in keywords modifying data\n  readonly dataNames: Name[]\n  readonly dataPathArr: (Code | number)[]\n  readonly dataLevel: number // the level of the currently validated data,\n  // it can be used to access both the property names and the data on all levels from the top.\n  dataTypes: JSONType[] // data types applied to the current part of data instance\n  definedProperties: Set<string> // set of properties to keep track of for required checks\n  readonly topSchemaRef: Code\n  readonly validateName: Name\n  evaluated?: Name\n  readonly ValidationError?: Name\n  readonly schema: AnySchema // current schema object - equal to parentSchema passed via KeywordCxt\n  readonly schemaEnv: SchemaEnv\n  readonly rootId: string\n  baseId: string // the current schema base URI that should be used as the base for resolving URIs in references (\\$ref)\n  readonly schemaPath: Code // the run-time expression that evaluates to the property name of the current schema\n  readonly errSchemaPath: string // this is actual string, should not be changed to Code\n  readonly errorPath: Code\n  readonly propertyName?: Name\n  readonly compositeRule?: boolean // true indicates that the current schema is inside the compound keyword,\n  // where failing some rule doesn't mean validation failure (`anyOf`, `oneOf`, `not`, `if`).\n  // This flag is used to determine whether you can return validation result immediately after any error in case the option `allErrors` is not `true.\n  // You only need to use it if you have many steps in your keywords and potentially can define multiple errors.\n  props?: EvaluatedProperties | Name // properties evaluated by this schema - used by parent schema or assigned to validation function\n  items?: EvaluatedItems | Name // last item evaluated by this schema - used by parent schema or assigned to validation function\n  jtdDiscriminator?: string\n  jtdMetadata?: boolean\n  readonly createErrors?: boolean\n  readonly opts: InstanceOptions // Ajv instance option.\n  readonly self: Ajv // current Ajv instance\n}\n\nexport interface SchemaObjCxt extends SchemaCxt {\n  readonly schema: AnySchemaObject\n}\ninterface SchemaEnvArgs {\n  readonly schema: AnySchema\n  readonly schemaId?: \"$id\" | \"id\"\n  readonly root?: SchemaEnv\n  readonly baseId?: string\n  readonly schemaPath?: string\n  readonly localRefs?: LocalRefs\n  readonly meta?: boolean\n}\n\nexport class SchemaEnv implements SchemaEnvArgs {\n  readonly schema: AnySchema\n  readonly schemaId?: \"$id\" | \"id\"\n  readonly root: SchemaEnv\n  baseId: string // TODO possibly, it should be readonly\n  schemaPath?: string\n  localRefs?: LocalRefs\n  readonly meta?: boolean\n  readonly $async?: boolean // true if the current schema is asynchronous.\n  readonly refs: SchemaRefs = {}\n  readonly dynamicAnchors: {[Ref in string]?: true} = {}\n  validate?: AnyValidateFunction\n  validateName?: ValueScopeName\n  serialize?: (data: unknown) => string\n  serializeName?: ValueScopeName\n  parse?: (data: string) => unknown\n  parseName?: ValueScopeName\n\n  constructor(env: SchemaEnvArgs) {\n    let schema: AnySchemaObject | undefined\n    if (typeof env.schema == \"object\") schema = env.schema\n    this.schema = env.schema\n    this.schemaId = env.schemaId\n    this.root = env.root || this\n    this.baseId = env.baseId ?? normalizeId(schema?.[env.schemaId || \"$id\"])\n    this.schemaPath = env.schemaPath\n    this.localRefs = env.localRefs\n    this.meta = env.meta\n    this.$async = schema?.$async\n    this.refs = {}\n  }\n}\n\n// let codeSize = 0\n// let nodeCount = 0\n\n// Compiles schema in SchemaEnv\nexport function compileSchema(this: Ajv, sch: SchemaEnv): SchemaEnv {\n  // TODO refactor - remove compilations\n  const _sch = getCompilingSchema.call(this, sch)\n  if (_sch) return _sch\n  const rootId = getFullPath(this.opts.uriResolver, sch.root.baseId) // TODO if getFullPath removed 1 tests fails\n  const {es5, lines} = this.opts.code\n  const {ownProperties} = this.opts\n  const gen = new CodeGen(this.scope, {es5, lines, ownProperties})\n  let _ValidationError\n  if (sch.$async) {\n    _ValidationError = gen.scopeValue(\"Error\", {\n      ref: ValidationError,\n      code: _`require(\"ajv/dist/runtime/validation_error\").default`,\n    })\n  }\n\n  const validateName = gen.scopeName(\"validate\")\n  sch.validateName = validateName\n\n  const schemaCxt: SchemaCxt = {\n    gen,\n    allErrors: this.opts.allErrors,\n    data: N.data,\n    parentData: N.parentData,\n    parentDataProperty: N.parentDataProperty,\n    dataNames: [N.data],\n    dataPathArr: [nil], // TODO can its length be used as dataLevel if nil is removed?\n    dataLevel: 0,\n    dataTypes: [],\n    definedProperties: new Set<string>(),\n    topSchemaRef: gen.scopeValue(\n      \"schema\",\n      this.opts.code.source === true\n        ? {ref: sch.schema, code: stringify(sch.schema)}\n        : {ref: sch.schema}\n    ),\n    validateName,\n    ValidationError: _ValidationError,\n    schema: sch.schema,\n    schemaEnv: sch,\n    rootId,\n    baseId: sch.baseId || rootId,\n    schemaPath: nil,\n    errSchemaPath: sch.schemaPath || (this.opts.jtd ? \"\" : \"#\"),\n    errorPath: _`\"\"`,\n    opts: this.opts,\n    self: this,\n  }\n\n  let sourceCode: string | undefined\n  try {\n    this._compilations.add(sch)\n    validateFunctionCode(schemaCxt)\n    gen.optimize(this.opts.code.optimize)\n    // gen.optimize(1)\n    const validateCode = gen.toString()\n    sourceCode = `${gen.scopeRefs(N.scope)}return ${validateCode}`\n    // console.log((codeSize += sourceCode.length), (nodeCount += gen.nodeCount))\n    if (this.opts.code.process) sourceCode = this.opts.code.process(sourceCode, sch)\n    // console.log(\"\\n\\n\\n *** \\n\", sourceCode)\n    const makeValidate = new Function(`${N.self}`, `${N.scope}`, sourceCode)\n    const validate: AnyValidateFunction = makeValidate(this, this.scope.get())\n    this.scope.value(validateName, {ref: validate})\n\n    validate.errors = null\n    validate.schema = sch.schema\n    validate.schemaEnv = sch\n    if (sch.$async) (validate as AsyncValidateFunction).$async = true\n    if (this.opts.code.source === true) {\n      validate.source = {validateName, validateCode, scopeValues: gen._values}\n    }\n    if (this.opts.unevaluated) {\n      const {props, items} = schemaCxt\n      validate.evaluated = {\n        props: props instanceof Name ? undefined : props,\n        items: items instanceof Name ? undefined : items,\n        dynamicProps: props instanceof Name,\n        dynamicItems: items instanceof Name,\n      }\n      if (validate.source) validate.source.evaluated = stringify(validate.evaluated)\n    }\n    sch.validate = validate\n    return sch\n  } catch (e) {\n    delete sch.validate\n    delete sch.validateName\n    if (sourceCode) this.logger.error(\"Error compiling schema, function code:\", sourceCode)\n    // console.log(\"\\n\\n\\n *** \\n\", sourceCode, this.opts)\n    throw e\n  } finally {\n    this._compilations.delete(sch)\n  }\n}\n\nexport function resolveRef(\n  this: Ajv,\n  root: SchemaEnv,\n  baseId: string,\n  ref: string\n): AnySchema | SchemaEnv | undefined {\n  ref = resolveUrl(this.opts.uriResolver, baseId, ref)\n  const schOrFunc = root.refs[ref]\n  if (schOrFunc) return schOrFunc\n\n  let _sch = resolve.call(this, root, ref)\n  if (_sch === undefined) {\n    const schema = root.localRefs?.[ref] // TODO maybe localRefs should hold SchemaEnv\n    const {schemaId} = this.opts\n    if (schema) _sch = new SchemaEnv({schema, schemaId, root, baseId})\n  }\n\n  if (_sch === undefined) return\n  return (root.refs[ref] = inlineOrCompile.call(this, _sch))\n}\n\nfunction inlineOrCompile(this: Ajv, sch: SchemaEnv): AnySchema | SchemaEnv {\n  if (inlineRef(sch.schema, this.opts.inlineRefs)) return sch.schema\n  return sch.validate ? sch : compileSchema.call(this, sch)\n}\n\n// Index of schema compilation in the currently compiled list\nexport function getCompilingSchema(this: Ajv, schEnv: SchemaEnv): SchemaEnv | void {\n  for (const sch of this._compilations) {\n    if (sameSchemaEnv(sch, schEnv)) return sch\n  }\n}\n\nfunction sameSchemaEnv(s1: SchemaEnv, s2: SchemaEnv): boolean {\n  return s1.schema === s2.schema && s1.root === s2.root && s1.baseId === s2.baseId\n}\n\n// resolve and compile the references ($ref)\n// TODO returns AnySchemaObject (if the schema can be inlined) or validation function\nfunction resolve(\n  this: Ajv,\n  root: SchemaEnv, // information about the root schema for the current schema\n  ref: string // reference to resolve\n): SchemaEnv | undefined {\n  let sch\n  while (typeof (sch = this.refs[ref]) == \"string\") ref = sch\n  return sch || this.schemas[ref] || resolveSchema.call(this, root, ref)\n}\n\n// Resolve schema, its root and baseId\nexport function resolveSchema(\n  this: Ajv,\n  root: SchemaEnv, // root object with properties schema, refs TODO below SchemaEnv is assigned to it\n  ref: string // reference to resolve\n): SchemaEnv | undefined {\n  const p = this.opts.uriResolver.parse(ref)\n  const refPath = _getFullPath(this.opts.uriResolver, p)\n  let baseId = getFullPath(this.opts.uriResolver, root.baseId, undefined)\n  // TODO `Object.keys(root.schema).length > 0` should not be needed - but removing breaks 2 tests\n  if (Object.keys(root.schema).length > 0 && refPath === baseId) {\n    return getJsonPointer.call(this, p, root)\n  }\n\n  const id = normalizeId(refPath)\n  const schOrRef = this.refs[id] || this.schemas[id]\n  if (typeof schOrRef == \"string\") {\n    const sch = resolveSchema.call(this, root, schOrRef)\n    if (typeof sch?.schema !== \"object\") return\n    return getJsonPointer.call(this, p, sch)\n  }\n\n  if (typeof schOrRef?.schema !== \"object\") return\n  if (!schOrRef.validate) compileSchema.call(this, schOrRef)\n  if (id === normalizeId(ref)) {\n    const {schema} = schOrRef\n    const {schemaId} = this.opts\n    const schId = schema[schemaId]\n    if (schId) baseId = resolveUrl(this.opts.uriResolver, baseId, schId)\n    return new SchemaEnv({schema, schemaId, root, baseId})\n  }\n  return getJsonPointer.call(this, p, schOrRef)\n}\n\nconst PREVENT_SCOPE_CHANGE = new Set([\n  \"properties\",\n  \"patternProperties\",\n  \"enum\",\n  \"dependencies\",\n  \"definitions\",\n])\n\nfunction getJsonPointer(\n  this: Ajv,\n  parsedRef: URIComponent,\n  {baseId, schema, root}: SchemaEnv\n): SchemaEnv | undefined {\n  if (parsedRef.fragment?.[0] !== \"/\") return\n  for (const part of parsedRef.fragment.slice(1).split(\"/\")) {\n    if (typeof schema === \"boolean\") return\n    const partSchema = schema[unescapeFragment(part)]\n    if (partSchema === undefined) return\n    schema = partSchema\n    // TODO PREVENT_SCOPE_CHANGE could be defined in keyword def?\n    const schId = typeof schema === \"object\" && schema[this.opts.schemaId]\n    if (!PREVENT_SCOPE_CHANGE.has(part) && schId) {\n      baseId = resolveUrl(this.opts.uriResolver, baseId, schId)\n    }\n  }\n  let env: SchemaEnv | undefined\n  if (typeof schema != \"boolean\" && schema.$ref && !schemaHasRulesButRef(schema, this.RULES)) {\n    const $ref = resolveUrl(this.opts.uriResolver, baseId, schema.$ref)\n    env = resolveSchema.call(this, root, $ref)\n  }\n  // even though resolution failed we need to return SchemaEnv to throw exception\n  // so that compileAsync loads missing schema.\n  const {schemaId} = this.opts\n  env = env || new SchemaEnv({schema, schemaId, root, baseId})\n  if (env.schema !== env.root.schema) return env\n  return undefined\n}\n","import type {AddedKeywordDefinition} from \"../types\"\n\nconst _jsonTypes = [\"string\", \"number\", \"integer\", \"boolean\", \"null\", \"object\", \"array\"] as const\n\nexport type JSONType = (typeof _jsonTypes)[number]\n\nconst jsonTypes: Set<string> = new Set(_jsonTypes)\n\nexport function isJSONType(x: unknown): x is JSONType {\n  return typeof x == \"string\" && jsonTypes.has(x)\n}\n\ntype ValidationTypes = {\n  [K in JSONType]: boolean | RuleGroup | undefined\n}\n\nexport interface ValidationRules {\n  rules: RuleGroup[]\n  post: RuleGroup\n  all: {[Key in string]?: boolean | Rule} // rules that have to be validated\n  keywords: {[Key in string]?: boolean} // all known keywords (superset of \"all\")\n  types: ValidationTypes\n}\n\nexport interface RuleGroup {\n  type?: JSONType\n  rules: Rule[]\n}\n\n// This interface wraps KeywordDefinition because definition can have multiple keywords\nexport interface Rule {\n  keyword: string\n  definition: AddedKeywordDefinition\n}\n\nexport function getRules(): ValidationRules {\n  const groups: Record<\"number\" | \"string\" | \"array\" | \"object\", RuleGroup> = {\n    number: {type: \"number\", rules: []},\n    string: {type: \"string\", rules: []},\n    array: {type: \"array\", rules: []},\n    object: {type: \"object\", rules: []},\n  }\n  return {\n    types: {...groups, integer: true, boolean: true, null: true},\n    rules: [{rules: []}, groups.number, groups.string, groups.array, groups.object],\n    post: {rules: []},\n    all: {},\n    keywords: {},\n  }\n}\n","import {_, nil, Code, Name} from \"./code\"\n\ninterface NameGroup {\n  prefix: string\n  index: number\n}\n\nexport interface NameValue {\n  ref: ValueReference // this is the reference to any value that can be referred to from generated code via `globals` var in the closure\n  key?: unknown // any key to identify a global to avoid duplicates, if not passed ref is used\n  code?: Code // this is the code creating the value needed for standalone code wit_out closure - can be a primitive value, function or import (`require`)\n}\n\nexport type ValueReference = unknown // possibly make CodeGen parameterized type on this type\n\nclass ValueError extends Error {\n  readonly value?: NameValue\n  constructor(name: ValueScopeName) {\n    super(`CodeGen: \"code\" for ${name} not defined`)\n    this.value = name.value\n  }\n}\n\ninterface ScopeOptions {\n  prefixes?: Set<string>\n  parent?: Scope\n}\n\ninterface ValueScopeOptions extends ScopeOptions {\n  scope: ScopeStore\n  es5?: boolean\n  lines?: boolean\n}\n\nexport type ScopeStore = Record<string, ValueReference[] | undefined>\n\ntype ScopeValues = {\n  [Prefix in string]?: Map<unknown, ValueScopeName>\n}\n\nexport type ScopeValueSets = {\n  [Prefix in string]?: Set<ValueScopeName>\n}\n\nexport enum UsedValueState {\n  Started,\n  Completed,\n}\n\nexport type UsedScopeValues = {\n  [Prefix in string]?: Map<ValueScopeName, UsedValueState | undefined>\n}\n\nexport const varKinds = {\n  const: new Name(\"const\"),\n  let: new Name(\"let\"),\n  var: new Name(\"var\"),\n}\n\nexport class Scope {\n  protected readonly _names: {[Prefix in string]?: NameGroup} = {}\n  protected readonly _prefixes?: Set<string>\n  protected readonly _parent?: Scope\n\n  constructor({prefixes, parent}: ScopeOptions = {}) {\n    this._prefixes = prefixes\n    this._parent = parent\n  }\n\n  toName(nameOrPrefix: Name | string): Name {\n    return nameOrPrefix instanceof Name ? nameOrPrefix : this.name(nameOrPrefix)\n  }\n\n  name(prefix: string): Name {\n    return new Name(this._newName(prefix))\n  }\n\n  protected _newName(prefix: string): string {\n    const ng = this._names[prefix] || this._nameGroup(prefix)\n    return `${prefix}${ng.index++}`\n  }\n\n  private _nameGroup(prefix: string): NameGroup {\n    if (this._parent?._prefixes?.has(prefix) || (this._prefixes && !this._prefixes.has(prefix))) {\n      throw new Error(`CodeGen: prefix \"${prefix}\" is not allowed in this scope`)\n    }\n    return (this._names[prefix] = {prefix, index: 0})\n  }\n}\n\ninterface ScopePath {\n  property: string\n  itemIndex: number\n}\n\nexport class ValueScopeName extends Name {\n  readonly prefix: string\n  value?: NameValue\n  scopePath?: Code\n\n  constructor(prefix: string, nameStr: string) {\n    super(nameStr)\n    this.prefix = prefix\n  }\n\n  setValue(value: NameValue, {property, itemIndex}: ScopePath): void {\n    this.value = value\n    this.scopePath = _`.${new Name(property)}[${itemIndex}]`\n  }\n}\n\ninterface VSOptions extends ValueScopeOptions {\n  _n: Code\n}\n\nconst line = _`\\n`\n\nexport class ValueScope extends Scope {\n  protected readonly _values: ScopeValues = {}\n  protected readonly _scope: ScopeStore\n  readonly opts: VSOptions\n\n  constructor(opts: ValueScopeOptions) {\n    super(opts)\n    this._scope = opts.scope\n    this.opts = {...opts, _n: opts.lines ? line : nil}\n  }\n\n  get(): ScopeStore {\n    return this._scope\n  }\n\n  name(prefix: string): ValueScopeName {\n    return new ValueScopeName(prefix, this._newName(prefix))\n  }\n\n  value(nameOrPrefix: ValueScopeName | string, value: NameValue): ValueScopeName {\n    if (value.ref === undefined) throw new Error(\"CodeGen: ref must be passed in value\")\n    const name = this.toName(nameOrPrefix) as ValueScopeName\n    const {prefix} = name\n    const valueKey = value.key ?? value.ref\n    let vs = this._values[prefix]\n    if (vs) {\n      const _name = vs.get(valueKey)\n      if (_name) return _name\n    } else {\n      vs = this._values[prefix] = new Map()\n    }\n    vs.set(valueKey, name)\n\n    const s = this._scope[prefix] || (this._scope[prefix] = [])\n    const itemIndex = s.length\n    s[itemIndex] = value.ref\n    name.setValue(value, {property: prefix, itemIndex})\n    return name\n  }\n\n  getValue(prefix: string, keyOrRef: unknown): ValueScopeName | undefined {\n    const vs = this._values[prefix]\n    if (!vs) return\n    return vs.get(keyOrRef)\n  }\n\n  scopeRefs(scopeName: Name, values: ScopeValues | ScopeValueSets = this._values): Code {\n    return this._reduceValues(values, (name: ValueScopeName) => {\n      if (name.scopePath === undefined) throw new Error(`CodeGen: name \"${name}\" has no value`)\n      return _`${scopeName}${name.scopePath}`\n    })\n  }\n\n  scopeCode(\n    values: ScopeValues | ScopeValueSets = this._values,\n    usedValues?: UsedScopeValues,\n    getCode?: (n: ValueScopeName) => Code | undefined\n  ): Code {\n    return this._reduceValues(\n      values,\n      (name: ValueScopeName) => {\n        if (name.value === undefined) throw new Error(`CodeGen: name \"${name}\" has no value`)\n        return name.value.code\n      },\n      usedValues,\n      getCode\n    )\n  }\n\n  private _reduceValues(\n    values: ScopeValues | ScopeValueSets,\n    valueCode: (n: ValueScopeName) => Code | undefined,\n    usedValues: UsedScopeValues = {},\n    getCode?: (n: ValueScopeName) => Code | undefined\n  ): Code {\n    let code: Code = nil\n    for (const prefix in values) {\n      const vs = values[prefix]\n      if (!vs) continue\n      const nameSet = (usedValues[prefix] = usedValues[prefix] || new Map())\n      vs.forEach((name: ValueScopeName) => {\n        if (nameSet.has(name)) return\n        nameSet.set(name, UsedValueState.Started)\n        let c = valueCode(name)\n        if (c) {\n          const def = this.opts.es5 ? varKinds.var : varKinds.const\n          code = _`${code}${def} ${name} = ${c};${this.opts._n}`\n        } else if ((c = getCode?.(name))) {\n          code = _`${code}${c}${this.opts._n}`\n        } else {\n          throw new ValueError(name)\n        }\n        nameSet.set(name, UsedValueState.Completed)\n      })\n    }\n    return code\n  }\n}\n","import type {ScopeValueSets, NameValue, ValueScope, ValueScopeName} from \"./scope\"\nimport {_, nil, _Code, Code, Name, UsedNames, CodeItem, addCodeArg, _CodeOrName} from \"./code\"\nimport {Scope, varKinds} from \"./scope\"\n\nexport {_, str, strConcat, nil, getProperty, stringify, regexpCode, Name, Code} from \"./code\"\nexport {Scope, ScopeStore, ValueScope, ValueScopeName, ScopeValueSets, varKinds} from \"./scope\"\n\n// type for expressions that can be safely inserted in code without quotes\nexport type SafeExpr = Code | number | boolean | null\n\n// type that is either Code of function that adds code to CodeGen instance using its methods\nexport type Block = Code | (() => void)\n\nexport const operators = {\n  GT: new _Code(\">\"),\n  GTE: new _Code(\">=\"),\n  LT: new _Code(\"<\"),\n  LTE: new _Code(\"<=\"),\n  EQ: new _Code(\"===\"),\n  NEQ: new _Code(\"!==\"),\n  NOT: new _Code(\"!\"),\n  OR: new _Code(\"||\"),\n  AND: new _Code(\"&&\"),\n  ADD: new _Code(\"+\"),\n}\n\nabstract class Node {\n  abstract readonly names: UsedNames\n\n  optimizeNodes(): this | ChildNode | ChildNode[] | undefined {\n    return this\n  }\n\n  optimizeNames(_names: UsedNames, _constants: Constants): this | undefined {\n    return this\n  }\n\n  // get count(): number {\n  //   return 1\n  // }\n}\n\nclass Def extends Node {\n  constructor(\n    private readonly varKind: Name,\n    private readonly name: Name,\n    private rhs?: SafeExpr\n  ) {\n    super()\n  }\n\n  render({es5, _n}: CGOptions): string {\n    const varKind = es5 ? varKinds.var : this.varKind\n    const rhs = this.rhs === undefined ? \"\" : ` = ${this.rhs}`\n    return `${varKind} ${this.name}${rhs};` + _n\n  }\n\n  optimizeNames(names: UsedNames, constants: Constants): this | undefined {\n    if (!names[this.name.str]) return\n    if (this.rhs) this.rhs = optimizeExpr(this.rhs, names, constants)\n    return this\n  }\n\n  get names(): UsedNames {\n    return this.rhs instanceof _CodeOrName ? this.rhs.names : {}\n  }\n}\n\nclass Assign extends Node {\n  constructor(\n    readonly lhs: Code,\n    public rhs: SafeExpr,\n    private readonly sideEffects?: boolean\n  ) {\n    super()\n  }\n\n  render({_n}: CGOptions): string {\n    return `${this.lhs} = ${this.rhs};` + _n\n  }\n\n  optimizeNames(names: UsedNames, constants: Constants): this | undefined {\n    if (this.lhs instanceof Name && !names[this.lhs.str] && !this.sideEffects) return\n    this.rhs = optimizeExpr(this.rhs, names, constants)\n    return this\n  }\n\n  get names(): UsedNames {\n    const names = this.lhs instanceof Name ? {} : {...this.lhs.names}\n    return addExprNames(names, this.rhs)\n  }\n}\n\nclass AssignOp extends Assign {\n  constructor(\n    lhs: Code,\n    private readonly op: Code,\n    rhs: SafeExpr,\n    sideEffects?: boolean\n  ) {\n    super(lhs, rhs, sideEffects)\n  }\n\n  render({_n}: CGOptions): string {\n    return `${this.lhs} ${this.op}= ${this.rhs};` + _n\n  }\n}\n\nclass Label extends Node {\n  readonly names: UsedNames = {}\n  constructor(readonly label: Name) {\n    super()\n  }\n\n  render({_n}: CGOptions): string {\n    return `${this.label}:` + _n\n  }\n}\n\nclass Break extends Node {\n  readonly names: UsedNames = {}\n  constructor(readonly label?: Code) {\n    super()\n  }\n\n  render({_n}: CGOptions): string {\n    const label = this.label ? ` ${this.label}` : \"\"\n    return `break${label};` + _n\n  }\n}\n\nclass Throw extends Node {\n  constructor(readonly error: Code) {\n    super()\n  }\n\n  render({_n}: CGOptions): string {\n    return `throw ${this.error};` + _n\n  }\n\n  get names(): UsedNames {\n    return this.error.names\n  }\n}\n\nclass AnyCode extends Node {\n  constructor(private code: SafeExpr) {\n    super()\n  }\n\n  render({_n}: CGOptions): string {\n    return `${this.code};` + _n\n  }\n\n  optimizeNodes(): this | undefined {\n    return `${this.code}` ? this : undefined\n  }\n\n  optimizeNames(names: UsedNames, constants: Constants): this {\n    this.code = optimizeExpr(this.code, names, constants)\n    return this\n  }\n\n  get names(): UsedNames {\n    return this.code instanceof _CodeOrName ? this.code.names : {}\n  }\n}\n\nabstract class ParentNode extends Node {\n  constructor(readonly nodes: ChildNode[] = []) {\n    super()\n  }\n\n  render(opts: CGOptions): string {\n    return this.nodes.reduce((code, n) => code + n.render(opts), \"\")\n  }\n\n  optimizeNodes(): this | ChildNode | ChildNode[] | undefined {\n    const {nodes} = this\n    let i = nodes.length\n    while (i--) {\n      const n = nodes[i].optimizeNodes()\n      if (Array.isArray(n)) nodes.splice(i, 1, ...n)\n      else if (n) nodes[i] = n\n      else nodes.splice(i, 1)\n    }\n    return nodes.length > 0 ? this : undefined\n  }\n\n  optimizeNames(names: UsedNames, constants: Constants): this | undefined {\n    const {nodes} = this\n    let i = nodes.length\n    while (i--) {\n      // iterating backwards improves 1-pass optimization\n      const n = nodes[i]\n      if (n.optimizeNames(names, constants)) continue\n      subtractNames(names, n.names)\n      nodes.splice(i, 1)\n    }\n    return nodes.length > 0 ? this : undefined\n  }\n\n  get names(): UsedNames {\n    return this.nodes.reduce((names: UsedNames, n) => addNames(names, n.names), {})\n  }\n\n  // get count(): number {\n  //   return this.nodes.reduce((c, n) => c + n.count, 1)\n  // }\n}\n\nabstract class BlockNode extends ParentNode {\n  render(opts: CGOptions): string {\n    return \"{\" + opts._n + super.render(opts) + \"}\" + opts._n\n  }\n}\n\nclass Root extends ParentNode {}\n\nclass Else extends BlockNode {\n  static readonly kind = \"else\"\n}\n\nclass If extends BlockNode {\n  static readonly kind = \"if\"\n  else?: If | Else\n  constructor(\n    private condition: Code | boolean,\n    nodes?: ChildNode[]\n  ) {\n    super(nodes)\n  }\n\n  render(opts: CGOptions): string {\n    let code = `if(${this.condition})` + super.render(opts)\n    if (this.else) code += \"else \" + this.else.render(opts)\n    return code\n  }\n\n  optimizeNodes(): If | ChildNode[] | undefined {\n    super.optimizeNodes()\n    const cond = this.condition\n    if (cond === true) return this.nodes // else is ignored here\n    let e = this.else\n    if (e) {\n      const ns = e.optimizeNodes()\n      e = this.else = Array.isArray(ns) ? new Else(ns) : (ns as Else | undefined)\n    }\n    if (e) {\n      if (cond === false) return e instanceof If ? e : e.nodes\n      if (this.nodes.length) return this\n      return new If(not(cond), e instanceof If ? [e] : e.nodes)\n    }\n    if (cond === false || !this.nodes.length) return undefined\n    return this\n  }\n\n  optimizeNames(names: UsedNames, constants: Constants): this | undefined {\n    this.else = this.else?.optimizeNames(names, constants)\n    if (!(super.optimizeNames(names, constants) || this.else)) return\n    this.condition = optimizeExpr(this.condition, names, constants)\n    return this\n  }\n\n  get names(): UsedNames {\n    const names = super.names\n    addExprNames(names, this.condition)\n    if (this.else) addNames(names, this.else.names)\n    return names\n  }\n\n  // get count(): number {\n  //   return super.count + (this.else?.count || 0)\n  // }\n}\n\nabstract class For extends BlockNode {\n  static readonly kind = \"for\"\n}\n\nclass ForLoop extends For {\n  constructor(private iteration: Code) {\n    super()\n  }\n\n  render(opts: CGOptions): string {\n    return `for(${this.iteration})` + super.render(opts)\n  }\n\n  optimizeNames(names: UsedNames, constants: Constants): this | undefined {\n    if (!super.optimizeNames(names, constants)) return\n    this.iteration = optimizeExpr(this.iteration, names, constants)\n    return this\n  }\n\n  get names(): UsedNames {\n    return addNames(super.names, this.iteration.names)\n  }\n}\n\nclass ForRange extends For {\n  constructor(\n    private readonly varKind: Name,\n    private readonly name: Name,\n    private readonly from: SafeExpr,\n    private readonly to: SafeExpr\n  ) {\n    super()\n  }\n\n  render(opts: CGOptions): string {\n    const varKind = opts.es5 ? varKinds.var : this.varKind\n    const {name, from, to} = this\n    return `for(${varKind} ${name}=${from}; ${name}<${to}; ${name}++)` + super.render(opts)\n  }\n\n  get names(): UsedNames {\n    const names = addExprNames(super.names, this.from)\n    return addExprNames(names, this.to)\n  }\n}\n\nclass ForIter extends For {\n  constructor(\n    private readonly loop: \"of\" | \"in\",\n    private readonly varKind: Name,\n    private readonly name: Name,\n    private iterable: Code\n  ) {\n    super()\n  }\n\n  render(opts: CGOptions): string {\n    return `for(${this.varKind} ${this.name} ${this.loop} ${this.iterable})` + super.render(opts)\n  }\n\n  optimizeNames(names: UsedNames, constants: Constants): this | undefined {\n    if (!super.optimizeNames(names, constants)) return\n    this.iterable = optimizeExpr(this.iterable, names, constants)\n    return this\n  }\n\n  get names(): UsedNames {\n    return addNames(super.names, this.iterable.names)\n  }\n}\n\nclass Func extends BlockNode {\n  static readonly kind = \"func\"\n  constructor(\n    public name: Name,\n    public args: Code,\n    public async?: boolean\n  ) {\n    super()\n  }\n\n  render(opts: CGOptions): string {\n    const _async = this.async ? \"async \" : \"\"\n    return `${_async}function ${this.name}(${this.args})` + super.render(opts)\n  }\n}\n\nclass Return extends ParentNode {\n  static readonly kind = \"return\"\n\n  render(opts: CGOptions): string {\n    return \"return \" + super.render(opts)\n  }\n}\n\nclass Try extends BlockNode {\n  catch?: Catch\n  finally?: Finally\n\n  render(opts: CGOptions): string {\n    let code = \"try\" + super.render(opts)\n    if (this.catch) code += this.catch.render(opts)\n    if (this.finally) code += this.finally.render(opts)\n    return code\n  }\n\n  optimizeNodes(): this {\n    super.optimizeNodes()\n    this.catch?.optimizeNodes() as Catch | undefined\n    this.finally?.optimizeNodes() as Finally | undefined\n    return this\n  }\n\n  optimizeNames(names: UsedNames, constants: Constants): this {\n    super.optimizeNames(names, constants)\n    this.catch?.optimizeNames(names, constants)\n    this.finally?.optimizeNames(names, constants)\n    return this\n  }\n\n  get names(): UsedNames {\n    const names = super.names\n    if (this.catch) addNames(names, this.catch.names)\n    if (this.finally) addNames(names, this.finally.names)\n    return names\n  }\n\n  // get count(): number {\n  //   return super.count + (this.catch?.count || 0) + (this.finally?.count || 0)\n  // }\n}\n\nclass Catch extends BlockNode {\n  static readonly kind = \"catch\"\n  constructor(readonly error: Name) {\n    super()\n  }\n\n  render(opts: CGOptions): string {\n    return `catch(${this.error})` + super.render(opts)\n  }\n}\n\nclass Finally extends BlockNode {\n  static readonly kind = \"finally\"\n  render(opts: CGOptions): string {\n    return \"finally\" + super.render(opts)\n  }\n}\n\ntype StartBlockNode = If | For | Func | Return | Try\n\ntype LeafNode = Def | Assign | Label | Break | Throw | AnyCode\n\ntype ChildNode = StartBlockNode | LeafNode\n\ntype EndBlockNodeType =\n  | typeof If\n  | typeof Else\n  | typeof For\n  | typeof Func\n  | typeof Return\n  | typeof Catch\n  | typeof Finally\n\ntype Constants = Record<string, SafeExpr | undefined>\n\nexport interface CodeGenOptions {\n  es5?: boolean\n  lines?: boolean\n  ownProperties?: boolean\n}\n\ninterface CGOptions extends CodeGenOptions {\n  _n: \"\\n\" | \"\"\n}\n\nexport class CodeGen {\n  readonly _scope: Scope\n  readonly _extScope: ValueScope\n  readonly _values: ScopeValueSets = {}\n  private readonly _nodes: ParentNode[]\n  private readonly _blockStarts: number[] = []\n  private readonly _constants: Constants = {}\n  private readonly opts: CGOptions\n\n  constructor(extScope: ValueScope, opts: CodeGenOptions = {}) {\n    this.opts = {...opts, _n: opts.lines ? \"\\n\" : \"\"}\n    this._extScope = extScope\n    this._scope = new Scope({parent: extScope})\n    this._nodes = [new Root()]\n  }\n\n  toString(): string {\n    return this._root.render(this.opts)\n  }\n\n  // returns unique name in the internal scope\n  name(prefix: string): Name {\n    return this._scope.name(prefix)\n  }\n\n  // reserves unique name in the external scope\n  scopeName(prefix: string): ValueScopeName {\n    return this._extScope.name(prefix)\n  }\n\n  // reserves unique name in the external scope and assigns value to it\n  scopeValue(prefixOrName: ValueScopeName | string, value: NameValue): Name {\n    const name = this._extScope.value(prefixOrName, value)\n    const vs = this._values[name.prefix] || (this._values[name.prefix] = new Set())\n    vs.add(name)\n    return name\n  }\n\n  getScopeValue(prefix: string, keyOrRef: unknown): ValueScopeName | undefined {\n    return this._extScope.getValue(prefix, keyOrRef)\n  }\n\n  // return code that assigns values in the external scope to the names that are used internally\n  // (same names that were returned by gen.scopeName or gen.scopeValue)\n  scopeRefs(scopeName: Name): Code {\n    return this._extScope.scopeRefs(scopeName, this._values)\n  }\n\n  scopeCode(): Code {\n    return this._extScope.scopeCode(this._values)\n  }\n\n  private _def(\n    varKind: Name,\n    nameOrPrefix: Name | string,\n    rhs?: SafeExpr,\n    constant?: boolean\n  ): Name {\n    const name = this._scope.toName(nameOrPrefix)\n    if (rhs !== undefined && constant) this._constants[name.str] = rhs\n    this._leafNode(new Def(varKind, name, rhs))\n    return name\n  }\n\n  // `const` declaration (`var` in es5 mode)\n  const(nameOrPrefix: Name | string, rhs: SafeExpr, _constant?: boolean): Name {\n    return this._def(varKinds.const, nameOrPrefix, rhs, _constant)\n  }\n\n  // `let` declaration with optional assignment (`var` in es5 mode)\n  let(nameOrPrefix: Name | string, rhs?: SafeExpr, _constant?: boolean): Name {\n    return this._def(varKinds.let, nameOrPrefix, rhs, _constant)\n  }\n\n  // `var` declaration with optional assignment\n  var(nameOrPrefix: Name | string, rhs?: SafeExpr, _constant?: boolean): Name {\n    return this._def(varKinds.var, nameOrPrefix, rhs, _constant)\n  }\n\n  // assignment code\n  assign(lhs: Code, rhs: SafeExpr, sideEffects?: boolean): CodeGen {\n    return this._leafNode(new Assign(lhs, rhs, sideEffects))\n  }\n\n  // `+=` code\n  add(lhs: Code, rhs: SafeExpr): CodeGen {\n    return this._leafNode(new AssignOp(lhs, operators.ADD, rhs))\n  }\n\n  // appends passed SafeExpr to code or executes Block\n  code(c: Block | SafeExpr): CodeGen {\n    if (typeof c == \"function\") c()\n    else if (c !== nil) this._leafNode(new AnyCode(c))\n    return this\n  }\n\n  // returns code for object literal for the passed argument list of key-value pairs\n  object(...keyValues: [Name | string, SafeExpr | string][]): _Code {\n    const code: CodeItem[] = [\"{\"]\n    for (const [key, value] of keyValues) {\n      if (code.length > 1) code.push(\",\")\n      code.push(key)\n      if (key !== value || this.opts.es5) {\n        code.push(\":\")\n        addCodeArg(code, value)\n      }\n    }\n    code.push(\"}\")\n    return new _Code(code)\n  }\n\n  // `if` clause (or statement if `thenBody` and, optionally, `elseBody` are passed)\n  if(condition: Code | boolean, thenBody?: Block, elseBody?: Block): CodeGen {\n    this._blockNode(new If(condition))\n\n    if (thenBody && elseBody) {\n      this.code(thenBody).else().code(elseBody).endIf()\n    } else if (thenBody) {\n      this.code(thenBody).endIf()\n    } else if (elseBody) {\n      throw new Error('CodeGen: \"else\" body without \"then\" body')\n    }\n    return this\n  }\n\n  // `else if` clause - invalid without `if` or after `else` clauses\n  elseIf(condition: Code | boolean): CodeGen {\n    return this._elseNode(new If(condition))\n  }\n\n  // `else` clause - only valid after `if` or `else if` clauses\n  else(): CodeGen {\n    return this._elseNode(new Else())\n  }\n\n  // end `if` statement (needed if gen.if was used only with condition)\n  endIf(): CodeGen {\n    return this._endBlockNode(If, Else)\n  }\n\n  private _for(node: For, forBody?: Block): CodeGen {\n    this._blockNode(node)\n    if (forBody) this.code(forBody).endFor()\n    return this\n  }\n\n  // a generic `for` clause (or statement if `forBody` is passed)\n  for(iteration: Code, forBody?: Block): CodeGen {\n    return this._for(new ForLoop(iteration), forBody)\n  }\n\n  // `for` statement for a range of values\n  forRange(\n    nameOrPrefix: Name | string,\n    from: SafeExpr,\n    to: SafeExpr,\n    forBody: (index: Name) => void,\n    varKind: Code = this.opts.es5 ? varKinds.var : varKinds.let\n  ): CodeGen {\n    const name = this._scope.toName(nameOrPrefix)\n    return this._for(new ForRange(varKind, name, from, to), () => forBody(name))\n  }\n\n  // `for-of` statement (in es5 mode replace with a normal for loop)\n  forOf(\n    nameOrPrefix: Name | string,\n    iterable: Code,\n    forBody: (item: Name) => void,\n    varKind: Code = varKinds.const\n  ): CodeGen {\n    const name = this._scope.toName(nameOrPrefix)\n    if (this.opts.es5) {\n      const arr = iterable instanceof Name ? iterable : this.var(\"_arr\", iterable)\n      return this.forRange(\"_i\", 0, _`${arr}.length`, (i) => {\n        this.var(name, _`${arr}[${i}]`)\n        forBody(name)\n      })\n    }\n    return this._for(new ForIter(\"of\", varKind, name, iterable), () => forBody(name))\n  }\n\n  // `for-in` statement.\n  // With option `ownProperties` replaced with a `for-of` loop for object keys\n  forIn(\n    nameOrPrefix: Name | string,\n    obj: Code,\n    forBody: (item: Name) => void,\n    varKind: Code = this.opts.es5 ? varKinds.var : varKinds.const\n  ): CodeGen {\n    if (this.opts.ownProperties) {\n      return this.forOf(nameOrPrefix, _`Object.keys(${obj})`, forBody)\n    }\n    const name = this._scope.toName(nameOrPrefix)\n    return this._for(new ForIter(\"in\", varKind, name, obj), () => forBody(name))\n  }\n\n  // end `for` loop\n  endFor(): CodeGen {\n    return this._endBlockNode(For)\n  }\n\n  // `label` statement\n  label(label: Name): CodeGen {\n    return this._leafNode(new Label(label))\n  }\n\n  // `break` statement\n  break(label?: Code): CodeGen {\n    return this._leafNode(new Break(label))\n  }\n\n  // `return` statement\n  return(value: Block | SafeExpr): CodeGen {\n    const node = new Return()\n    this._blockNode(node)\n    this.code(value)\n    if (node.nodes.length !== 1) throw new Error('CodeGen: \"return\" should have one node')\n    return this._endBlockNode(Return)\n  }\n\n  // `try` statement\n  try(tryBody: Block, catchCode?: (e: Name) => void, finallyCode?: Block): CodeGen {\n    if (!catchCode && !finallyCode) throw new Error('CodeGen: \"try\" without \"catch\" and \"finally\"')\n    const node = new Try()\n    this._blockNode(node)\n    this.code(tryBody)\n    if (catchCode) {\n      const error = this.name(\"e\")\n      this._currNode = node.catch = new Catch(error)\n      catchCode(error)\n    }\n    if (finallyCode) {\n      this._currNode = node.finally = new Finally()\n      this.code(finallyCode)\n    }\n    return this._endBlockNode(Catch, Finally)\n  }\n\n  // `throw` statement\n  throw(error: Code): CodeGen {\n    return this._leafNode(new Throw(error))\n  }\n\n  // start self-balancing block\n  block(body?: Block, nodeCount?: number): CodeGen {\n    this._blockStarts.push(this._nodes.length)\n    if (body) this.code(body).endBlock(nodeCount)\n    return this\n  }\n\n  // end the current self-balancing block\n  endBlock(nodeCount?: number): CodeGen {\n    const len = this._blockStarts.pop()\n    if (len === undefined) throw new Error(\"CodeGen: not in self-balancing block\")\n    const toClose = this._nodes.length - len\n    if (toClose < 0 || (nodeCount !== undefined && toClose !== nodeCount)) {\n      throw new Error(`CodeGen: wrong number of nodes: ${toClose} vs ${nodeCount} expected`)\n    }\n    this._nodes.length = len\n    return this\n  }\n\n  // `function` heading (or definition if funcBody is passed)\n  func(name: Name, args: Code = nil, async?: boolean, funcBody?: Block): CodeGen {\n    this._blockNode(new Func(name, args, async))\n    if (funcBody) this.code(funcBody).endFunc()\n    return this\n  }\n\n  // end function definition\n  endFunc(): CodeGen {\n    return this._endBlockNode(Func)\n  }\n\n  optimize(n = 1): void {\n    while (n-- > 0) {\n      this._root.optimizeNodes()\n      this._root.optimizeNames(this._root.names, this._constants)\n    }\n  }\n\n  private _leafNode(node: LeafNode): CodeGen {\n    this._currNode.nodes.push(node)\n    return this\n  }\n\n  private _blockNode(node: StartBlockNode): void {\n    this._currNode.nodes.push(node)\n    this._nodes.push(node)\n  }\n\n  private _endBlockNode(N1: EndBlockNodeType, N2?: EndBlockNodeType): CodeGen {\n    const n = this._currNode\n    if (n instanceof N1 || (N2 && n instanceof N2)) {\n      this._nodes.pop()\n      return this\n    }\n    throw new Error(`CodeGen: not in block \"${N2 ? `${N1.kind}/${N2.kind}` : N1.kind}\"`)\n  }\n\n  private _elseNode(node: If | Else): CodeGen {\n    const n = this._currNode\n    if (!(n instanceof If)) {\n      throw new Error('CodeGen: \"else\" without \"if\"')\n    }\n    this._currNode = n.else = node\n    return this\n  }\n\n  private get _root(): Root {\n    return this._nodes[0] as Root\n  }\n\n  private get _currNode(): ParentNode {\n    const ns = this._nodes\n    return ns[ns.length - 1]\n  }\n\n  private set _currNode(node: ParentNode) {\n    const ns = this._nodes\n    ns[ns.length - 1] = node\n  }\n\n  // get nodeCount(): number {\n  //   return this._root.count\n  // }\n}\n\nfunction addNames(names: UsedNames, from: UsedNames): UsedNames {\n  for (const n in from) names[n] = (names[n] || 0) + (from[n] || 0)\n  return names\n}\n\nfunction addExprNames(names: UsedNames, from: SafeExpr): UsedNames {\n  return from instanceof _CodeOrName ? addNames(names, from.names) : names\n}\n\nfunction optimizeExpr<T extends SafeExpr | Code>(expr: T, names: UsedNames, constants: Constants): T\nfunction optimizeExpr(expr: SafeExpr, names: UsedNames, constants: Constants): SafeExpr {\n  if (expr instanceof Name) return replaceName(expr)\n  if (!canOptimize(expr)) return expr\n  return new _Code(\n    expr._items.reduce((items: CodeItem[], c: SafeExpr | string) => {\n      if (c instanceof Name) c = replaceName(c)\n      if (c instanceof _Code) items.push(...c._items)\n      else items.push(c)\n      return items\n    }, [])\n  )\n\n  function replaceName(n: Name): SafeExpr {\n    const c = constants[n.str]\n    if (c === undefined || names[n.str] !== 1) return n\n    delete names[n.str]\n    return c\n  }\n\n  function canOptimize(e: SafeExpr): e is _Code {\n    return (\n      e instanceof _Code &&\n      e._items.some(\n        (c) => c instanceof Name && names[c.str] === 1 && constants[c.str] !== undefined\n      )\n    )\n  }\n}\n\nfunction subtractNames(names: UsedNames, from: UsedNames): void {\n  for (const n in from) names[n] = (names[n] || 0) - (from[n] || 0)\n}\n\nexport function not<T extends Code | SafeExpr>(x: T): T\nexport function not(x: Code | SafeExpr): Code | SafeExpr {\n  return typeof x == \"boolean\" || typeof x == \"number\" || x === null ? !x : _`!${par(x)}`\n}\n\nconst andCode = mappend(operators.AND)\n\n// boolean AND (&&) expression with the passed arguments\nexport function and(...args: Code[]): Code {\n  return args.reduce(andCode)\n}\n\nconst orCode = mappend(operators.OR)\n\n// boolean OR (||) expression with the passed arguments\nexport function or(...args: Code[]): Code {\n  return args.reduce(orCode)\n}\n\ntype MAppend = (x: Code, y: Code) => Code\n\nfunction mappend(op: Code): MAppend {\n  return (x, y) => (x === nil ? y : y === nil ? x : _`${par(x)} ${op} ${par(y)}`)\n}\n\nfunction par(x: Code): Code {\n  return x instanceof Name ? x : _`(${x})`\n}\n","import type {KeywordCxt} from \".\"\nimport type {\n  AnySchema,\n  SchemaValidateFunction,\n  AnyValidateFunction,\n  AddedKeywordDefinition,\n  MacroKeywordDefinition,\n  FuncKeywordDefinition,\n} from \"../../types\"\nimport type {SchemaObjCxt} from \"..\"\nimport {_, nil, not, stringify, Code, Name, CodeGen} from \"../codegen\"\nimport N from \"../names\"\nimport type {JSONType} from \"../rules\"\nimport {callValidateCode} from \"../../vocabularies/code\"\nimport {extendErrors} from \"../errors\"\n\ntype KeywordCompilationResult = AnySchema | SchemaValidateFunction | AnyValidateFunction\n\nexport function macroKeywordCode(cxt: KeywordCxt, def: MacroKeywordDefinition): void {\n  const {gen, keyword, schema, parentSchema, it} = cxt\n  const macroSchema = def.macro.call(it.self, schema, parentSchema, it)\n  const schemaRef = useKeyword(gen, keyword, macroSchema)\n  if (it.opts.validateSchema !== false) it.self.validateSchema(macroSchema, true)\n\n  const valid = gen.name(\"valid\")\n  cxt.subschema(\n    {\n      schema: macroSchema,\n      schemaPath: nil,\n      errSchemaPath: `${it.errSchemaPath}/${keyword}`,\n      topSchemaRef: schemaRef,\n      compositeRule: true,\n    },\n    valid\n  )\n  cxt.pass(valid, () => cxt.error(true))\n}\n\nexport function funcKeywordCode(cxt: KeywordCxt, def: FuncKeywordDefinition): void {\n  const {gen, keyword, schema, parentSchema, $data, it} = cxt\n  checkAsyncKeyword(it, def)\n  const validate =\n    !$data && def.compile ? def.compile.call(it.self, schema, parentSchema, it) : def.validate\n  const validateRef = useKeyword(gen, keyword, validate)\n  const valid = gen.let(\"valid\")\n  cxt.block$data(valid, validateKeyword)\n  cxt.ok(def.valid ?? valid)\n\n  function validateKeyword(): void {\n    if (def.errors === false) {\n      assignValid()\n      if (def.modifying) modifyData(cxt)\n      reportErrs(() => cxt.error())\n    } else {\n      const ruleErrs = def.async ? validateAsync() : validateSync()\n      if (def.modifying) modifyData(cxt)\n      reportErrs(() => addErrs(cxt, ruleErrs))\n    }\n  }\n\n  function validateAsync(): Name {\n    const ruleErrs = gen.let(\"ruleErrs\", null)\n    gen.try(\n      () => assignValid(_`await `),\n      (e) =>\n        gen.assign(valid, false).if(\n          _`${e} instanceof ${it.ValidationError as Name}`,\n          () => gen.assign(ruleErrs, _`${e}.errors`),\n          () => gen.throw(e)\n        )\n    )\n    return ruleErrs\n  }\n\n  function validateSync(): Code {\n    const validateErrs = _`${validateRef}.errors`\n    gen.assign(validateErrs, null)\n    assignValid(nil)\n    return validateErrs\n  }\n\n  function assignValid(_await: Code = def.async ? _`await ` : nil): void {\n    const passCxt = it.opts.passContext ? N.this : N.self\n    const passSchema = !((\"compile\" in def && !$data) || def.schema === false)\n    gen.assign(\n      valid,\n      _`${_await}${callValidateCode(cxt, validateRef, passCxt, passSchema)}`,\n      def.modifying\n    )\n  }\n\n  function reportErrs(errors: () => void): void {\n    gen.if(not(def.valid ?? valid), errors)\n  }\n}\n\nfunction modifyData(cxt: KeywordCxt): void {\n  const {gen, data, it} = cxt\n  gen.if(it.parentData, () => gen.assign(data, _`${it.parentData}[${it.parentDataProperty}]`))\n}\n\nfunction addErrs(cxt: KeywordCxt, errs: Code): void {\n  const {gen} = cxt\n  gen.if(\n    _`Array.isArray(${errs})`,\n    () => {\n      gen\n        .assign(N.vErrors, _`${N.vErrors} === null ? ${errs} : ${N.vErrors}.concat(${errs})`)\n        .assign(N.errors, _`${N.vErrors}.length`)\n      extendErrors(cxt)\n    },\n    () => cxt.error()\n  )\n}\n\nfunction checkAsyncKeyword({schemaEnv}: SchemaObjCxt, def: FuncKeywordDefinition): void {\n  if (def.async && !schemaEnv.$async) throw new Error(\"async keyword in sync schema\")\n}\n\nfunction useKeyword(gen: CodeGen, keyword: string, result?: KeywordCompilationResult): Name {\n  if (result === undefined) throw new Error(`keyword \"${keyword}\" failed to compile`)\n  return gen.scopeValue(\n    \"keyword\",\n    typeof result == \"function\" ? {ref: result} : {ref: result, code: stringify(result)}\n  )\n}\n\nexport function validSchemaType(\n  schema: unknown,\n  schemaType: JSONType[],\n  allowUndefined = false\n): boolean {\n  // TODO add tests\n  return (\n    !schemaType.length ||\n    schemaType.some((st) =>\n      st === \"array\"\n        ? Array.isArray(schema)\n        : st === \"object\"\n        ? schema && typeof schema == \"object\" && !Array.isArray(schema)\n        : typeof schema == st || (allowUndefined && typeof schema == \"undefined\")\n    )\n  )\n}\n\nexport function validateKeywordUsage(\n  {schema, opts, self, errSchemaPath}: SchemaObjCxt,\n  def: AddedKeywordDefinition,\n  keyword: string\n): void {\n  /* istanbul ignore if */\n  if (Array.isArray(def.keyword) ? !def.keyword.includes(keyword) : def.keyword !== keyword) {\n    throw new Error(\"ajv implementation error\")\n  }\n\n  const deps = def.dependencies\n  if (deps?.some((kwd) => !Object.prototype.hasOwnProperty.call(schema, kwd))) {\n    throw new Error(`parent schema must have dependencies of ${keyword}: ${deps.join(\",\")}`)\n  }\n\n  if (def.validateSchema) {\n    const valid = def.validateSchema(schema[keyword])\n    if (!valid) {\n      const msg =\n        `keyword \"${keyword}\" value is invalid at path \"${errSchemaPath}\": ` +\n        self.errorsText(def.validateSchema.errors)\n      if (opts.validateSchema === \"log\") self.logger.error(msg)\n      else throw new Error(msg)\n    }\n  }\n}\n","import type {AnySchema, SchemaMap} from \"../types\"\nimport type {SchemaCxt} from \"../compile\"\nimport type {KeywordCxt} from \"../compile/validate\"\nimport {CodeGen, _, and, or, not, nil, strConcat, getProperty, Code, Name} from \"../compile/codegen\"\nimport {alwaysValidSchema, Type} from \"../compile/util\"\nimport N from \"../compile/names\"\nimport {useFunc} from \"../compile/util\"\nexport function checkReportMissingProp(cxt: KeywordCxt, prop: string): void {\n  const {gen, data, it} = cxt\n  gen.if(noPropertyInData(gen, data, prop, it.opts.ownProperties), () => {\n    cxt.setParams({missingProperty: _`${prop}`}, true)\n    cxt.error()\n  })\n}\n\nexport function checkMissingProp(\n  {gen, data, it: {opts}}: KeywordCxt,\n  properties: string[],\n  missing: Name\n): Code {\n  return or(\n    ...properties.map((prop) =>\n      and(noPropertyInData(gen, data, prop, opts.ownProperties), _`${missing} = ${prop}`)\n    )\n  )\n}\n\nexport function reportMissingProp(cxt: KeywordCxt, missing: Name): void {\n  cxt.setParams({missingProperty: missing}, true)\n  cxt.error()\n}\n\nexport function hasPropFunc(gen: CodeGen): Name {\n  return gen.scopeValue(\"func\", {\n    // eslint-disable-next-line @typescript-eslint/unbound-method\n    ref: Object.prototype.hasOwnProperty,\n    code: _`Object.prototype.hasOwnProperty`,\n  })\n}\n\nexport function isOwnProperty(gen: CodeGen, data: Name, property: Name | string): Code {\n  return _`${hasPropFunc(gen)}.call(${data}, ${property})`\n}\n\nexport function propertyInData(\n  gen: CodeGen,\n  data: Name,\n  property: Name | string,\n  ownProperties?: boolean\n): Code {\n  const cond = _`${data}${getProperty(property)} !== undefined`\n  return ownProperties ? _`${cond} && ${isOwnProperty(gen, data, property)}` : cond\n}\n\nexport function noPropertyInData(\n  gen: CodeGen,\n  data: Name,\n  property: Name | string,\n  ownProperties?: boolean\n): Code {\n  const cond = _`${data}${getProperty(property)} === undefined`\n  return ownProperties ? or(cond, not(isOwnProperty(gen, data, property))) : cond\n}\n\nexport function allSchemaProperties(schemaMap?: SchemaMap): string[] {\n  return schemaMap ? Object.keys(schemaMap).filter((p) => p !== \"__proto__\") : []\n}\n\nexport function schemaProperties(it: SchemaCxt, schemaMap: SchemaMap): string[] {\n  return allSchemaProperties(schemaMap).filter(\n    (p) => !alwaysValidSchema(it, schemaMap[p] as AnySchema)\n  )\n}\n\nexport function callValidateCode(\n  {schemaCode, data, it: {gen, topSchemaRef, schemaPath, errorPath}, it}: KeywordCxt,\n  func: Code,\n  context: Code,\n  passSchema?: boolean\n): Code {\n  const dataAndSchema = passSchema ? _`${schemaCode}, ${data}, ${topSchemaRef}${schemaPath}` : data\n  const valCxt: [Name, Code | number][] = [\n    [N.instancePath, strConcat(N.instancePath, errorPath)],\n    [N.parentData, it.parentData],\n    [N.parentDataProperty, it.parentDataProperty],\n    [N.rootData, N.rootData],\n  ]\n  if (it.opts.dynamicRef) valCxt.push([N.dynamicAnchors, N.dynamicAnchors])\n  const args = _`${dataAndSchema}, ${gen.object(...valCxt)}`\n  return context !== nil ? _`${func}.call(${context}, ${args})` : _`${func}(${args})`\n}\n\nconst newRegExp = _`new RegExp`\n\nexport function usePattern({gen, it: {opts}}: KeywordCxt, pattern: string): Name {\n  const u = opts.unicodeRegExp ? \"u\" : \"\"\n  const {regExp} = opts.code\n  const rx = regExp(pattern, u)\n\n  return gen.scopeValue(\"pattern\", {\n    key: rx.toString(),\n    ref: rx,\n    code: _`${regExp.code === \"new RegExp\" ? newRegExp : useFunc(gen, regExp)}(${pattern}, ${u})`,\n  })\n}\n\nexport function validateArray(cxt: KeywordCxt): Name {\n  const {gen, data, keyword, it} = cxt\n  const valid = gen.name(\"valid\")\n  if (it.allErrors) {\n    const validArr = gen.let(\"valid\", true)\n    validateItems(() => gen.assign(validArr, false))\n    return validArr\n  }\n  gen.var(valid, true)\n  validateItems(() => gen.break())\n  return valid\n\n  function validateItems(notValid: () => void): void {\n    const len = gen.const(\"len\", _`${data}.length`)\n    gen.forRange(\"i\", 0, len, (i) => {\n      cxt.subschema(\n        {\n          keyword,\n          dataProp: i,\n          dataPropType: Type.Num,\n        },\n        valid\n      )\n      gen.if(not(valid), notValid)\n    })\n  }\n}\n\nexport function validateUnion(cxt: KeywordCxt): void {\n  const {gen, schema, keyword, it} = cxt\n  /* istanbul ignore if */\n  if (!Array.isArray(schema)) throw new Error(\"ajv implementation error\")\n  const alwaysValid = schema.some((sch: AnySchema) => alwaysValidSchema(it, sch))\n  if (alwaysValid && !it.opts.unevaluated) return\n\n  const valid = gen.let(\"valid\", false)\n  const schValid = gen.name(\"_valid\")\n\n  gen.block(() =>\n    schema.forEach((_sch: AnySchema, i: number) => {\n      const schCxt = cxt.subschema(\n        {\n          keyword,\n          schemaProp: i,\n          compositeRule: true,\n        },\n        schValid\n      )\n      gen.assign(valid, _`${valid} || ${schValid}`)\n      const merged = cxt.mergeValidEvaluated(schCxt, schValid)\n      // can short-circuit if `unevaluatedProperties/Items` not supported (opts.unevaluated !== true)\n      // or if all properties and items were evaluated (it.props === true && it.items === true)\n      if (!merged) gen.if(not(valid))\n    })\n  )\n\n  cxt.result(\n    valid,\n    () => cxt.reset(),\n    () => cxt.error(true)\n  )\n}\n","import type {\n  CodeKeywordDefinition,\n  ErrorObject,\n  KeywordErrorDefinition,\n  AnySchema,\n} from \"../../types\"\nimport type {KeywordCxt} from \"../../compile/validate\"\nimport {_, str, not, Name} from \"../../compile/codegen\"\nimport {alwaysValidSchema, checkStrictMode, Type} from \"../../compile/util\"\n\nexport type AdditionalItemsError = ErrorObject<\"additionalItems\", {limit: number}, AnySchema>\n\nconst error: KeywordErrorDefinition = {\n  message: ({params: {len}}) => str`must NOT have more than ${len} items`,\n  params: ({params: {len}}) => _`{limit: ${len}}`,\n}\n\nconst def: CodeKeywordDefinition = {\n  keyword: \"additionalItems\" as const,\n  type: \"array\",\n  schemaType: [\"boolean\", \"object\"],\n  before: \"uniqueItems\",\n  error,\n  code(cxt: KeywordCxt) {\n    const {parentSchema, it} = cxt\n    const {items} = parentSchema\n    if (!Array.isArray(items)) {\n      checkStrictMode(it, '\"additionalItems\" is ignored when \"items\" is not an array of schemas')\n      return\n    }\n    validateAdditionalItems(cxt, items)\n  },\n}\n\nexport function validateAdditionalItems(cxt: KeywordCxt, items: AnySchema[]): void {\n  const {gen, schema, data, keyword, it} = cxt\n  it.items = true\n  const len = gen.const(\"len\", _`${data}.length`)\n  if (schema === false) {\n    cxt.setParams({len: items.length})\n    cxt.pass(_`${len} <= ${items.length}`)\n  } else if (typeof schema == \"object\" && !alwaysValidSchema(it, schema)) {\n    const valid = gen.var(\"valid\", _`${len} <= ${items.length}`) // TODO var\n    gen.if(not(valid), () => validateItems(valid))\n    cxt.ok(valid)\n  }\n\n  function validateItems(valid: Name): void {\n    gen.forRange(\"i\", items.length, len, (i) => {\n      cxt.subschema({keyword, dataProp: i, dataPropType: Type.Num}, valid)\n      if (!it.allErrors) gen.if(not(valid), () => gen.break())\n    })\n  }\n}\n\nexport default def\n","'use strict'\n\nconst UUID_REG = /^[\\da-f]{8}-[\\da-f]{4}-[\\da-f]{4}-[\\da-f]{4}-[\\da-f]{12}$/iu\nconst URN_REG = /([\\da-z][\\d\\-a-z]{0,31}):((?:[\\w!$'()*+,\\-.:;=@]|%[\\da-f]{2})+)/iu\n\nfunction isSecure (wsComponents) {\n  return typeof wsComponents.secure === 'boolean' ? wsComponents.secure : String(wsComponents.scheme).toLowerCase() === 'wss'\n}\n\nfunction httpParse (components) {\n  if (!components.host) {\n    components.error = components.error || 'HTTP URIs must have a host.'\n  }\n\n  return components\n}\n\nfunction httpSerialize (components) {\n  const secure = String(components.scheme).toLowerCase() === 'https'\n\n  // normalize the default port\n  if (components.port === (secure ? 443 : 80) || components.port === '') {\n    components.port = undefined\n  }\n\n  // normalize the empty path\n  if (!components.path) {\n    components.path = '/'\n  }\n\n  // NOTE: We do not parse query strings for HTTP URIs\n  // as WWW Form Url Encoded query strings are part of the HTML4+ spec,\n  // and not the HTTP spec.\n\n  return components\n}\n\nfunction wsParse (wsComponents) {\n// indicate if the secure flag is set\n  wsComponents.secure = isSecure(wsComponents)\n\n  // construct resouce name\n  wsComponents.resourceName = (wsComponents.path || '/') + (wsComponents.query ? '?' + wsComponents.query : '')\n  wsComponents.path = undefined\n  wsComponents.query = undefined\n\n  return wsComponents\n}\n\nfunction wsSerialize (wsComponents) {\n// normalize the default port\n  if (wsComponents.port === (isSecure(wsComponents) ? 443 : 80) || wsComponents.port === '') {\n    wsComponents.port = undefined\n  }\n\n  // ensure scheme matches secure flag\n  if (typeof wsComponents.secure === 'boolean') {\n    wsComponents.scheme = (wsComponents.secure ? 'wss' : 'ws')\n    wsComponents.secure = undefined\n  }\n\n  // reconstruct path from resource name\n  if (wsComponents.resourceName) {\n    const [path, query] = wsComponents.resourceName.split('?')\n    wsComponents.path = (path && path !== '/' ? path : undefined)\n    wsComponents.query = query\n    wsComponents.resourceName = undefined\n  }\n\n  // forbid fragment component\n  wsComponents.fragment = undefined\n\n  return wsComponents\n}\n\nfunction urnParse (urnComponents, options) {\n  if (!urnComponents.path) {\n    urnComponents.error = 'URN can not be parsed'\n    return urnComponents\n  }\n  const matches = urnComponents.path.match(URN_REG)\n  if (matches) {\n    const scheme = options.scheme || urnComponents.scheme || 'urn'\n    urnComponents.nid = matches[1].toLowerCase()\n    urnComponents.nss = matches[2]\n    const urnScheme = `${scheme}:${options.nid || urnComponents.nid}`\n    const schemeHandler = SCHEMES[urnScheme]\n    urnComponents.path = undefined\n\n    if (schemeHandler) {\n      urnComponents = schemeHandler.parse(urnComponents, options)\n    }\n  } else {\n    urnComponents.error = urnComponents.error || 'URN can not be parsed.'\n  }\n\n  return urnComponents\n}\n\nfunction urnSerialize (urnComponents, options) {\n  const scheme = options.scheme || urnComponents.scheme || 'urn'\n  const nid = urnComponents.nid.toLowerCase()\n  const urnScheme = `${scheme}:${options.nid || nid}`\n  const schemeHandler = SCHEMES[urnScheme]\n\n  if (schemeHandler) {\n    urnComponents = schemeHandler.serialize(urnComponents, options)\n  }\n\n  const uriComponents = urnComponents\n  const nss = urnComponents.nss\n  uriComponents.path = `${nid || options.nid}:${nss}`\n\n  options.skipEscape = true\n  return uriComponents\n}\n\nfunction urnuuidParse (urnComponents, options) {\n  const uuidComponents = urnComponents\n  uuidComponents.uuid = uuidComponents.nss\n  uuidComponents.nss = undefined\n\n  if (!options.tolerant && (!uuidComponents.uuid || !UUID_REG.test(uuidComponents.uuid))) {\n    uuidComponents.error = uuidComponents.error || 'UUID is not valid.'\n  }\n\n  return uuidComponents\n}\n\nfunction urnuuidSerialize (uuidComponents) {\n  const urnComponents = uuidComponents\n  // normalize UUID\n  urnComponents.nss = (uuidComponents.uuid || '').toLowerCase()\n  return urnComponents\n}\n\nconst http = {\n  scheme: 'http',\n  domainHost: true,\n  parse: httpParse,\n  serialize: httpSerialize\n}\n\nconst https = {\n  scheme: 'https',\n  domainHost: http.domainHost,\n  parse: httpParse,\n  serialize: httpSerialize\n}\n\nconst ws = {\n  scheme: 'ws',\n  domainHost: true,\n  parse: wsParse,\n  serialize: wsSerialize\n}\n\nconst wss = {\n  scheme: 'wss',\n  domainHost: ws.domainHost,\n  parse: ws.parse,\n  serialize: ws.serialize\n}\n\nconst urn = {\n  scheme: 'urn',\n  parse: urnParse,\n  serialize: urnSerialize,\n  skipNormalize: true\n}\n\nconst urnuuid = {\n  scheme: 'urn:uuid',\n  parse: urnuuidParse,\n  serialize: urnuuidSerialize,\n  skipNormalize: true\n}\n\nconst SCHEMES = {\n  http,\n  https,\n  ws,\n  wss,\n  urn,\n  'urn:uuid': urnuuid\n}\n\nmodule.exports = SCHEMES\n","import type {AnySchema, AnySchemaObject, UriResolver} from \"../types\"\nimport type Ajv from \"../ajv\"\nimport type {URIComponent} from \"fast-uri\"\nimport {eachItem} from \"./util\"\nimport * as equal from \"fast-deep-equal\"\nimport * as traverse from \"json-schema-traverse\"\n\n// the hash of local references inside the schema (created by getSchemaRefs), used for inline resolution\nexport type LocalRefs = {[Ref in string]?: AnySchemaObject}\n\n// TODO refactor to use keyword definitions\nconst SIMPLE_INLINED = new Set([\n  \"type\",\n  \"format\",\n  \"pattern\",\n  \"maxLength\",\n  \"minLength\",\n  \"maxProperties\",\n  \"minProperties\",\n  \"maxItems\",\n  \"minItems\",\n  \"maximum\",\n  \"minimum\",\n  \"uniqueItems\",\n  \"multipleOf\",\n  \"required\",\n  \"enum\",\n  \"const\",\n])\n\nexport function inlineRef(schema: AnySchema, limit: boolean | number = true): boolean {\n  if (typeof schema == \"boolean\") return true\n  if (limit === true) return !hasRef(schema)\n  if (!limit) return false\n  return countKeys(schema) <= limit\n}\n\nconst REF_KEYWORDS = new Set([\n  \"$ref\",\n  \"$recursiveRef\",\n  \"$recursiveAnchor\",\n  \"$dynamicRef\",\n  \"$dynamicAnchor\",\n])\n\nfunction hasRef(schema: AnySchemaObject): boolean {\n  for (const key in schema) {\n    if (REF_KEYWORDS.has(key)) return true\n    const sch = schema[key]\n    if (Array.isArray(sch) && sch.some(hasRef)) return true\n    if (typeof sch == \"object\" && hasRef(sch)) return true\n  }\n  return false\n}\n\nfunction countKeys(schema: AnySchemaObject): number {\n  let count = 0\n  for (const key in schema) {\n    if (key === \"$ref\") return Infinity\n    count++\n    if (SIMPLE_INLINED.has(key)) continue\n    if (typeof schema[key] == \"object\") {\n      eachItem(schema[key], (sch) => (count += countKeys(sch)))\n    }\n    if (count === Infinity) return Infinity\n  }\n  return count\n}\n\nexport function getFullPath(resolver: UriResolver, id = \"\", normalize?: boolean): string {\n  if (normalize !== false) id = normalizeId(id)\n  const p = resolver.parse(id)\n  return _getFullPath(resolver, p)\n}\n\nexport function _getFullPath(resolver: UriResolver, p: URIComponent): string {\n  const serialized = resolver.serialize(p)\n  return serialized.split(\"#\")[0] + \"#\"\n}\n\nconst TRAILING_SLASH_HASH = /#\\/?$/\nexport function normalizeId(id: string | undefined): string {\n  return id ? id.replace(TRAILING_SLASH_HASH, \"\") : \"\"\n}\n\nexport function resolveUrl(resolver: UriResolver, baseId: string, id: string): string {\n  id = normalizeId(id)\n  return resolver.resolve(baseId, id)\n}\n\nconst ANCHOR = /^[a-z_][-a-z0-9._]*$/i\n\nexport function getSchemaRefs(this: Ajv, schema: AnySchema, baseId: string): LocalRefs {\n  if (typeof schema == \"boolean\") return {}\n  const {schemaId, uriResolver} = this.opts\n  const schId = normalizeId(schema[schemaId] || baseId)\n  const baseIds: {[JsonPtr in string]?: string} = {\"\": schId}\n  const pathPrefix = getFullPath(uriResolver, schId, false)\n  const localRefs: LocalRefs = {}\n  const schemaRefs: Set<string> = new Set()\n\n  traverse(schema, {allKeys: true}, (sch, jsonPtr, _, parentJsonPtr) => {\n    if (parentJsonPtr === undefined) return\n    const fullPath = pathPrefix + jsonPtr\n    let innerBaseId = baseIds[parentJsonPtr]\n    if (typeof sch[schemaId] == \"string\") innerBaseId = addRef.call(this, sch[schemaId])\n    addAnchor.call(this, sch.$anchor)\n    addAnchor.call(this, sch.$dynamicAnchor)\n    baseIds[jsonPtr] = innerBaseId\n\n    function addRef(this: Ajv, ref: string): string {\n      // eslint-disable-next-line @typescript-eslint/unbound-method\n      const _resolve = this.opts.uriResolver.resolve\n      ref = normalizeId(innerBaseId ? _resolve(innerBaseId, ref) : ref)\n      if (schemaRefs.has(ref)) throw ambiguos(ref)\n      schemaRefs.add(ref)\n      let schOrRef = this.refs[ref]\n      if (typeof schOrRef == \"string\") schOrRef = this.refs[schOrRef]\n      if (typeof schOrRef == \"object\") {\n        checkAmbiguosRef(sch, schOrRef.schema, ref)\n      } else if (ref !== normalizeId(fullPath)) {\n        if (ref[0] === \"#\") {\n          checkAmbiguosRef(sch, localRefs[ref], ref)\n          localRefs[ref] = sch\n        } else {\n          this.refs[ref] = fullPath\n        }\n      }\n      return ref\n    }\n\n    function addAnchor(this: Ajv, anchor: unknown): void {\n      if (typeof anchor == \"string\") {\n        if (!ANCHOR.test(anchor)) throw new Error(`invalid anchor \"${anchor}\"`)\n        addRef.call(this, `#${anchor}`)\n      }\n    }\n  })\n\n  return localRefs\n\n  function checkAmbiguosRef(sch1: AnySchema, sch2: AnySchema | undefined, ref: string): void {\n    if (sch2 !== undefined && !equal(sch1, sch2)) throw ambiguos(ref)\n  }\n\n  function ambiguos(ref: string): Error {\n    return new Error(`reference \"${ref}\" resolves to more than one schema`)\n  }\n}\n","import type {CodeKeywordDefinition} from \"../../types\"\n\nconst def: CodeKeywordDefinition = {\n  keyword: \"id\",\n  code() {\n    throw new Error('NOT SUPPORTED: keyword \"id\", use \"$id\" for schema ID')\n  },\n}\n\nexport default def\n","import type {ErrorNoParams, Vocabulary} from \"../../types\"\nimport additionalItems, {AdditionalItemsError} from \"./additionalItems\"\nimport prefixItems from \"./prefixItems\"\nimport items from \"./items\"\nimport items2020, {ItemsError} from \"./items2020\"\nimport contains, {ContainsError} from \"./contains\"\nimport dependencies, {DependenciesError} from \"./dependencies\"\nimport propertyNames, {PropertyNamesError} from \"./propertyNames\"\nimport additionalProperties, {AdditionalPropertiesError} from \"./additionalProperties\"\nimport properties from \"./properties\"\nimport patternProperties from \"./patternProperties\"\nimport notKeyword, {NotKeywordError} from \"./not\"\nimport anyOf, {AnyOfError} from \"./anyOf\"\nimport oneOf, {OneOfError} from \"./oneOf\"\nimport allOf from \"./allOf\"\nimport ifKeyword, {IfKeywordError} from \"./if\"\nimport thenElse from \"./thenElse\"\n\nexport default function getApplicator(draft2020 = false): Vocabulary {\n  const applicator = [\n    // any\n    notKeyword,\n    anyOf,\n    oneOf,\n    allOf,\n    ifKeyword,\n    thenElse,\n    // object\n    propertyNames,\n    additionalProperties,\n    dependencies,\n    properties,\n    patternProperties,\n  ]\n  // array\n  if (draft2020) applicator.push(prefixItems, items2020)\n  else applicator.push(additionalItems, items)\n  applicator.push(contains)\n  return applicator\n}\n\nexport type ApplicatorKeywordError =\n  | ErrorNoParams<\"false schema\">\n  | AdditionalItemsError\n  | ItemsError\n  | ContainsError\n  | AdditionalPropertiesError\n  | DependenciesError\n  | IfKeywordError\n  | AnyOfError\n  | OneOfError\n  | NotKeywordError\n  | PropertyNamesError\n","import type {KeywordErrorCxt, KeywordErrorDefinition} from \"../types\"\nimport type {SchemaCxt} from \"./index\"\nimport {CodeGen, _, str, strConcat, Code, Name} from \"./codegen\"\nimport {SafeExpr} from \"./codegen/code\"\nimport {getErrorPath, Type} from \"./util\"\nimport N from \"./names\"\n\nexport const keywordError: KeywordErrorDefinition = {\n  message: ({keyword}) => str`must pass \"${keyword}\" keyword validation`,\n}\n\nexport const keyword$DataError: KeywordErrorDefinition = {\n  message: ({keyword, schemaType}) =>\n    schemaType\n      ? str`\"${keyword}\" keyword must be ${schemaType} ($data)`\n      : str`\"${keyword}\" keyword is invalid ($data)`,\n}\n\nexport interface ErrorPaths {\n  instancePath?: Code\n  schemaPath?: string\n  parentSchema?: boolean\n}\n\nexport function reportError(\n  cxt: KeywordErrorCxt,\n  error: KeywordErrorDefinition = keywordError,\n  errorPaths?: ErrorPaths,\n  overrideAllErrors?: boolean\n): void {\n  const {it} = cxt\n  const {gen, compositeRule, allErrors} = it\n  const errObj = errorObjectCode(cxt, error, errorPaths)\n  if (overrideAllErrors ?? (compositeRule || allErrors)) {\n    addError(gen, errObj)\n  } else {\n    returnErrors(it, _`[${errObj}]`)\n  }\n}\n\nexport function reportExtraError(\n  cxt: KeywordErrorCxt,\n  error: KeywordErrorDefinition = keywordError,\n  errorPaths?: ErrorPaths\n): void {\n  const {it} = cxt\n  const {gen, compositeRule, allErrors} = it\n  const errObj = errorObjectCode(cxt, error, errorPaths)\n  addError(gen, errObj)\n  if (!(compositeRule || allErrors)) {\n    returnErrors(it, N.vErrors)\n  }\n}\n\nexport function resetErrorsCount(gen: CodeGen, errsCount: Name): void {\n  gen.assign(N.errors, errsCount)\n  gen.if(_`${N.vErrors} !== null`, () =>\n    gen.if(\n      errsCount,\n      () => gen.assign(_`${N.vErrors}.length`, errsCount),\n      () => gen.assign(N.vErrors, null)\n    )\n  )\n}\n\nexport function extendErrors({\n  gen,\n  keyword,\n  schemaValue,\n  data,\n  errsCount,\n  it,\n}: KeywordErrorCxt): void {\n  /* istanbul ignore if */\n  if (errsCount === undefined) throw new Error(\"ajv implementation error\")\n  const err = gen.name(\"err\")\n  gen.forRange(\"i\", errsCount, N.errors, (i) => {\n    gen.const(err, _`${N.vErrors}[${i}]`)\n    gen.if(_`${err}.instancePath === undefined`, () =>\n      gen.assign(_`${err}.instancePath`, strConcat(N.instancePath, it.errorPath))\n    )\n    gen.assign(_`${err}.schemaPath`, str`${it.errSchemaPath}/${keyword}`)\n    if (it.opts.verbose) {\n      gen.assign(_`${err}.schema`, schemaValue)\n      gen.assign(_`${err}.data`, data)\n    }\n  })\n}\n\nfunction addError(gen: CodeGen, errObj: Code): void {\n  const err = gen.const(\"err\", errObj)\n  gen.if(\n    _`${N.vErrors} === null`,\n    () => gen.assign(N.vErrors, _`[${err}]`),\n    _`${N.vErrors}.push(${err})`\n  )\n  gen.code(_`${N.errors}++`)\n}\n\nfunction returnErrors(it: SchemaCxt, errs: Code): void {\n  const {gen, validateName, schemaEnv} = it\n  if (schemaEnv.$async) {\n    gen.throw(_`new ${it.ValidationError as Name}(${errs})`)\n  } else {\n    gen.assign(_`${validateName}.errors`, errs)\n    gen.return(false)\n  }\n}\n\nconst E = {\n  keyword: new Name(\"keyword\"),\n  schemaPath: new Name(\"schemaPath\"), // also used in JTD errors\n  params: new Name(\"params\"),\n  propertyName: new Name(\"propertyName\"),\n  message: new Name(\"message\"),\n  schema: new Name(\"schema\"),\n  parentSchema: new Name(\"parentSchema\"),\n}\n\nfunction errorObjectCode(\n  cxt: KeywordErrorCxt,\n  error: KeywordErrorDefinition,\n  errorPaths?: ErrorPaths\n): Code {\n  const {createErrors} = cxt.it\n  if (createErrors === false) return _`{}`\n  return errorObject(cxt, error, errorPaths)\n}\n\nfunction errorObject(\n  cxt: KeywordErrorCxt,\n  error: KeywordErrorDefinition,\n  errorPaths: ErrorPaths = {}\n): Code {\n  const {gen, it} = cxt\n  const keyValues: [Name, SafeExpr | string][] = [\n    errorInstancePath(it, errorPaths),\n    errorSchemaPath(cxt, errorPaths),\n  ]\n  extraErrorProps(cxt, error, keyValues)\n  return gen.object(...keyValues)\n}\n\nfunction errorInstancePath({errorPath}: SchemaCxt, {instancePath}: ErrorPaths): [Name, Code] {\n  const instPath = instancePath\n    ? str`${errorPath}${getErrorPath(instancePath, Type.Str)}`\n    : errorPath\n  return [N.instancePath, strConcat(N.instancePath, instPath)]\n}\n\nfunction errorSchemaPath(\n  {keyword, it: {errSchemaPath}}: KeywordErrorCxt,\n  {schemaPath, parentSchema}: ErrorPaths\n): [Name, string | Code] {\n  let schPath = parentSchema ? errSchemaPath : str`${errSchemaPath}/${keyword}`\n  if (schemaPath) {\n    schPath = str`${schPath}${getErrorPath(schemaPath, Type.Str)}`\n  }\n  return [E.schemaPath, schPath]\n}\n\nfunction extraErrorProps(\n  cxt: KeywordErrorCxt,\n  {params, message}: KeywordErrorDefinition,\n  keyValues: [Name, SafeExpr | string][]\n): void {\n  const {keyword, data, schemaValue, it} = cxt\n  const {opts, propertyName, topSchemaRef, schemaPath} = it\n  keyValues.push(\n    [E.keyword, keyword],\n    [E.params, typeof params == \"function\" ? params(cxt) : params || _`{}`]\n  )\n  if (opts.messages) {\n    keyValues.push([E.message, typeof message == \"function\" ? message(cxt) : message])\n  }\n  if (opts.verbose) {\n    keyValues.push(\n      [E.schema, schemaValue],\n      [E.parentSchema, _`${topSchemaRef}${schemaPath}`],\n      [N.data, data]\n    )\n  }\n  if (propertyName) keyValues.push([E.propertyName, propertyName])\n}\n","import type {CodeKeywordDefinition, KeywordErrorDefinition} from \"../../types\"\nimport type {KeywordCxt} from \"../../compile/validate\"\nimport {_, str, operators} from \"../../compile/codegen\"\n\nconst error: KeywordErrorDefinition = {\n  message({keyword, schemaCode}) {\n    const comp = keyword === \"maxItems\" ? \"more\" : \"fewer\"\n    return str`must NOT have ${comp} than ${schemaCode} items`\n  },\n  params: ({schemaCode}) => _`{limit: ${schemaCode}}`,\n}\n\nconst def: CodeKeywordDefinition = {\n  keyword: [\"maxItems\", \"minItems\"],\n  type: \"array\",\n  schemaType: \"number\",\n  $data: true,\n  error,\n  code(cxt: KeywordCxt) {\n    const {keyword, data, schemaCode} = cxt\n    const op = keyword === \"maxItems\" ? operators.GT : operators.LT\n    cxt.fail$data(_`${data}.length ${op} ${schemaCode}`)\n  },\n}\n\nexport default def\n","import type {KeywordErrorDefinition, KeywordErrorCxt} from \"../../types\"\nimport type {SchemaCxt} from \"..\"\nimport {reportError} from \"../errors\"\nimport {_, Name} from \"../codegen\"\nimport N from \"../names\"\n\nconst boolError: KeywordErrorDefinition = {\n  message: \"boolean schema is false\",\n}\n\nexport function topBoolOrEmptySchema(it: SchemaCxt): void {\n  const {gen, schema, validateName} = it\n  if (schema === false) {\n    falseSchemaError(it, false)\n  } else if (typeof schema == \"object\" && schema.$async === true) {\n    gen.return(N.data)\n  } else {\n    gen.assign(_`${validateName}.errors`, null)\n    gen.return(true)\n  }\n}\n\nexport function boolOrEmptySchema(it: SchemaCxt, valid: Name): void {\n  const {gen, schema} = it\n  if (schema === false) {\n    gen.var(valid, false) // TODO var\n    falseSchemaError(it)\n  } else {\n    gen.var(valid, true) // TODO var\n  }\n}\n\nfunction falseSchemaError(it: SchemaCxt, overrideAllErrors?: boolean): void {\n  const {gen, data} = it\n  // TODO maybe some other interface should be used for non-keyword validation errors...\n  const cxt: KeywordErrorCxt = {\n    gen,\n    keyword: \"false schema\",\n    data,\n    schema: false,\n    schemaCode: false,\n    schemaValue: false,\n    params: {},\n    it,\n  }\n  reportError(cxt, boolError, undefined, overrideAllErrors)\n}\n","import {resolveUrl, normalizeId, getFullPath} from \"./resolve\"\nimport type {UriResolver} from \"../types\"\n\nexport default class MissingRefError extends Error {\n  readonly missingRef: string\n  readonly missingSchema: string\n\n  constructor(resolver: UriResolver, baseId: string, ref: string, msg?: string) {\n    super(msg || `can't resolve reference ${ref} from id ${baseId}`)\n    this.missingRef = resolveUrl(resolver, baseId, ref)\n    this.missingSchema = normalizeId(getFullPath(resolver, this.missingRef))\n  }\n}\n","// https://github.com/ajv-validator/ajv/issues/889\nimport * as equal from \"fast-deep-equal\"\n\ntype Equal = typeof equal & {code: string}\n;(equal as Equal).code = 'require(\"ajv/dist/runtime/equal\").default'\n\nexport default equal as Equal\n","import type {CodeKeywordDefinition, ErrorObject, KeywordErrorDefinition} from \"../../types\"\nimport type {KeywordCxt} from \"../../compile/validate\"\nimport {checkDataTypes, getSchemaTypes, DataType} from \"../../compile/validate/dataType\"\nimport {_, str, Name} from \"../../compile/codegen\"\nimport {useFunc} from \"../../compile/util\"\nimport equal from \"../../runtime/equal\"\n\nexport type UniqueItemsError = ErrorObject<\n  \"uniqueItems\",\n  {i: number; j: number},\n  boolean | {$data: string}\n>\n\nconst error: KeywordErrorDefinition = {\n  message: ({params: {i, j}}) =>\n    str`must NOT have duplicate items (items ## ${j} and ${i} are identical)`,\n  params: ({params: {i, j}}) => _`{i: ${i}, j: ${j}}`,\n}\n\nconst def: CodeKeywordDefinition = {\n  keyword: \"uniqueItems\",\n  type: \"array\",\n  schemaType: \"boolean\",\n  $data: true,\n  error,\n  code(cxt: KeywordCxt) {\n    const {gen, data, $data, schema, parentSchema, schemaCode, it} = cxt\n    if (!$data && !schema) return\n    const valid = gen.let(\"valid\")\n    const itemTypes = parentSchema.items ? getSchemaTypes(parentSchema.items) : []\n    cxt.block$data(valid, validateUniqueItems, _`${schemaCode} === false`)\n    cxt.ok(valid)\n\n    function validateUniqueItems(): void {\n      const i = gen.let(\"i\", _`${data}.length`)\n      const j = gen.let(\"j\")\n      cxt.setParams({i, j})\n      gen.assign(valid, true)\n      gen.if(_`${i} > 1`, () => (canOptimize() ? loopN : loopN2)(i, j))\n    }\n\n    function canOptimize(): boolean {\n      return itemTypes.length > 0 && !itemTypes.some((t) => t === \"object\" || t === \"array\")\n    }\n\n    function loopN(i: Name, j: Name): void {\n      const item = gen.name(\"item\")\n      const wrongType = checkDataTypes(itemTypes, item, it.opts.strictNumbers, DataType.Wrong)\n      const indices = gen.const(\"indices\", _`{}`)\n      gen.for(_`;${i}--;`, () => {\n        gen.let(item, _`${data}[${i}]`)\n        gen.if(wrongType, _`continue`)\n        if (itemTypes.length > 1) gen.if(_`typeof ${item} == \"string\"`, _`${item} += \"_\"`)\n        gen\n          .if(_`typeof ${indices}[${item}] == \"number\"`, () => {\n            gen.assign(j, _`${indices}[${item}]`)\n            cxt.error()\n            gen.assign(valid, false).break()\n          })\n          .code(_`${indices}[${item}] = ${i}`)\n      })\n    }\n\n    function loopN2(i: Name, j: Name): void {\n      const eql = useFunc(gen, equal)\n      const outer = gen.name(\"outer\")\n      gen.label(outer).for(_`;${i}--;`, () =>\n        gen.for(_`${j} = ${i}; ${j}--;`, () =>\n          gen.if(_`${eql}(${data}[${i}], ${data}[${j}])`, () => {\n            cxt.error()\n            gen.assign(valid, false).break(outer)\n          })\n        )\n      )\n    }\n  },\n}\n\nexport default def\n","'use strict'\n\nconst HEX = {\n  0: 0,\n  1: 1,\n  2: 2,\n  3: 3,\n  4: 4,\n  5: 5,\n  6: 6,\n  7: 7,\n  8: 8,\n  9: 9,\n  a: 10,\n  A: 10,\n  b: 11,\n  B: 11,\n  c: 12,\n  C: 12,\n  d: 13,\n  D: 13,\n  e: 14,\n  E: 14,\n  f: 15,\n  F: 15\n}\n\nmodule.exports = {\n  HEX\n}\n","import type {Format, FormatDefinition} from \"ajv\"\nimport type {FormatValidator, FormatCompare} from \"ajv/dist/types\"\n\nexport type FormatMode = \"fast\" | \"full\"\n\nexport type FormatName =\n  | \"date\"\n  | \"time\"\n  | \"date-time\"\n  | \"iso-time\"\n  | \"iso-date-time\"\n  | \"duration\"\n  | \"uri\"\n  | \"uri-reference\"\n  | \"uri-template\"\n  | \"url\"\n  | \"email\"\n  | \"hostname\"\n  | \"ipv4\"\n  | \"ipv6\"\n  | \"regex\"\n  | \"uuid\"\n  | \"json-pointer\"\n  | \"json-pointer-uri-fragment\"\n  | \"relative-json-pointer\"\n  | \"byte\"\n  | \"int32\"\n  | \"int64\"\n  | \"float\"\n  | \"double\"\n  | \"password\"\n  | \"binary\"\n\nexport type DefinedFormats = {\n  [key in FormatName]: Format\n}\n\nfunction fmtDef(\n  validate: RegExp | FormatValidator<string>,\n  compare: FormatCompare<string>\n): FormatDefinition<string> {\n  return {validate, compare}\n}\n\nexport const fullFormats: DefinedFormats = {\n  // date: http://tools.ietf.org/html/rfc3339#section-5.6\n  date: fmtDef(date, compareDate),\n  // date-time: http://tools.ietf.org/html/rfc3339#section-5.6\n  time: fmtDef(getTime(true), compareTime),\n  \"date-time\": fmtDef(getDateTime(true), compareDateTime),\n  \"iso-time\": fmtDef(getTime(), compareIsoTime),\n  \"iso-date-time\": fmtDef(getDateTime(), compareIsoDateTime),\n  // duration: https://tools.ietf.org/html/rfc3339#appendix-A\n  duration: /^P(?!$)((\\d+Y)?(\\d+M)?(\\d+D)?(T(?=\\d)(\\d+H)?(\\d+M)?(\\d+S)?)?|(\\d+W)?)$/,\n  uri,\n  \"uri-reference\":\n    /^(?:[a-z][a-z0-9+\\-.]*:)?(?:\\/?\\/(?:(?:[a-z0-9\\-._~!$&'()*+,;=:]|%[0-9a-f]{2})*@)?(?:\\[(?:(?:(?:(?:[0-9a-f]{1,4}:){6}|::(?:[0-9a-f]{1,4}:){5}|(?:[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){4}|(?:(?:[0-9a-f]{1,4}:){0,1}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){3}|(?:(?:[0-9a-f]{1,4}:){0,2}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){2}|(?:(?:[0-9a-f]{1,4}:){0,3}[0-9a-f]{1,4})?::[0-9a-f]{1,4}:|(?:(?:[0-9a-f]{1,4}:){0,4}[0-9a-f]{1,4})?::)(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\\d|[01]?\\d\\d?)\\.){3}(?:25[0-5]|2[0-4]\\d|[01]?\\d\\d?))|(?:(?:[0-9a-f]{1,4}:){0,5}[0-9a-f]{1,4})?::[0-9a-f]{1,4}|(?:(?:[0-9a-f]{1,4}:){0,6}[0-9a-f]{1,4})?::)|[Vv][0-9a-f]+\\.[a-z0-9\\-._~!$&'()*+,;=:]+)\\]|(?:(?:25[0-5]|2[0-4]\\d|[01]?\\d\\d?)\\.){3}(?:25[0-5]|2[0-4]\\d|[01]?\\d\\d?)|(?:[a-z0-9\\-._~!$&'\"()*+,;=]|%[0-9a-f]{2})*)(?::\\d*)?(?:\\/(?:[a-z0-9\\-._~!$&'\"()*+,;=:@]|%[0-9a-f]{2})*)*|\\/(?:(?:[a-z0-9\\-._~!$&'\"()*+,;=:@]|%[0-9a-f]{2})+(?:\\/(?:[a-z0-9\\-._~!$&'\"()*+,;=:@]|%[0-9a-f]{2})*)*)?|(?:[a-z0-9\\-._~!$&'\"()*+,;=:@]|%[0-9a-f]{2})+(?:\\/(?:[a-z0-9\\-._~!$&'\"()*+,;=:@]|%[0-9a-f]{2})*)*)?(?:\\?(?:[a-z0-9\\-._~!$&'\"()*+,;=:@/?]|%[0-9a-f]{2})*)?(?:#(?:[a-z0-9\\-._~!$&'\"()*+,;=:@/?]|%[0-9a-f]{2})*)?$/i,\n  // uri-template: https://tools.ietf.org/html/rfc6570\n  \"uri-template\":\n    /^(?:(?:[^\\x00-\\x20\"'<>%\\\\^`{|}]|%[0-9a-f]{2})|\\{[+#./;?&=,!@|]?(?:[a-z0-9_]|%[0-9a-f]{2})+(?::[1-9][0-9]{0,3}|\\*)?(?:,(?:[a-z0-9_]|%[0-9a-f]{2})+(?::[1-9][0-9]{0,3}|\\*)?)*\\})*$/i,\n  // For the source: https://gist.github.com/dperini/729294\n  // For test cases: https://mathiasbynens.be/demo/url-regex\n  url: /^(?:https?|ftp):\\/\\/(?:\\S+(?::\\S*)?@)?(?:(?!(?:10|127)(?:\\.\\d{1,3}){3})(?!(?:169\\.254|192\\.168)(?:\\.\\d{1,3}){2})(?!172\\.(?:1[6-9]|2\\d|3[0-1])(?:\\.\\d{1,3}){2})(?:[1-9]\\d?|1\\d\\d|2[01]\\d|22[0-3])(?:\\.(?:1?\\d{1,2}|2[0-4]\\d|25[0-5])){2}(?:\\.(?:[1-9]\\d?|1\\d\\d|2[0-4]\\d|25[0-4]))|(?:(?:[a-z0-9\\u{00a1}-\\u{ffff}]+-)*[a-z0-9\\u{00a1}-\\u{ffff}]+)(?:\\.(?:[a-z0-9\\u{00a1}-\\u{ffff}]+-)*[a-z0-9\\u{00a1}-\\u{ffff}]+)*(?:\\.(?:[a-z\\u{00a1}-\\u{ffff}]{2,})))(?::\\d{2,5})?(?:\\/[^\\s]*)?$/iu,\n  email:\n    /^[a-z0-9!#$%&'*+/=?^_`{|}~-]+(?:\\.[a-z0-9!#$%&'*+/=?^_`{|}~-]+)*@(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\\.)+[a-z0-9](?:[a-z0-9-]*[a-z0-9])?$/i,\n  hostname:\n    /^(?=.{1,253}\\.?$)[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?(?:\\.[a-z0-9](?:[-0-9a-z]{0,61}[0-9a-z])?)*\\.?$/i,\n  // optimized https://www.safaribooksonline.com/library/view/regular-expressions-cookbook/9780596802837/ch07s16.html\n  ipv4: /^(?:(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)\\.){3}(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)$/,\n  ipv6: /^((([0-9a-f]{1,4}:){7}([0-9a-f]{1,4}|:))|(([0-9a-f]{1,4}:){6}(:[0-9a-f]{1,4}|((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3})|:))|(([0-9a-f]{1,4}:){5}(((:[0-9a-f]{1,4}){1,2})|:((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3})|:))|(([0-9a-f]{1,4}:){4}(((:[0-9a-f]{1,4}){1,3})|((:[0-9a-f]{1,4})?:((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:))|(([0-9a-f]{1,4}:){3}(((:[0-9a-f]{1,4}){1,4})|((:[0-9a-f]{1,4}){0,2}:((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:))|(([0-9a-f]{1,4}:){2}(((:[0-9a-f]{1,4}){1,5})|((:[0-9a-f]{1,4}){0,3}:((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:))|(([0-9a-f]{1,4}:){1}(((:[0-9a-f]{1,4}){1,6})|((:[0-9a-f]{1,4}){0,4}:((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:))|(:(((:[0-9a-f]{1,4}){1,7})|((:[0-9a-f]{1,4}){0,5}:((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:)))$/i,\n  regex,\n  // uuid: http://tools.ietf.org/html/rfc4122\n  uuid: /^(?:urn:uuid:)?[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12}$/i,\n  // JSON-pointer: https://tools.ietf.org/html/rfc6901\n  // uri fragment: https://tools.ietf.org/html/rfc3986#appendix-A\n  \"json-pointer\": /^(?:\\/(?:[^~/]|~0|~1)*)*$/,\n  \"json-pointer-uri-fragment\": /^#(?:\\/(?:[a-z0-9_\\-.!$&'()*+,;:=@]|%[0-9a-f]{2}|~0|~1)*)*$/i,\n  // relative JSON-pointer: http://tools.ietf.org/html/draft-luff-relative-json-pointer-00\n  \"relative-json-pointer\": /^(?:0|[1-9][0-9]*)(?:#|(?:\\/(?:[^~/]|~0|~1)*)*)$/,\n  // the following formats are used by the openapi specification: https://spec.openapis.org/oas/v3.0.0#data-types\n  // byte: https://github.com/miguelmota/is-base64\n  byte,\n  // signed 32 bit integer\n  int32: {type: \"number\", validate: validateInt32},\n  // signed 64 bit integer\n  int64: {type: \"number\", validate: validateInt64},\n  // C-type float\n  float: {type: \"number\", validate: validateNumber},\n  // C-type double\n  double: {type: \"number\", validate: validateNumber},\n  // hint to the UI to hide input strings\n  password: true,\n  // unchecked string payload\n  binary: true,\n}\n\nexport const fastFormats: DefinedFormats = {\n  ...fullFormats,\n  date: fmtDef(/^\\d\\d\\d\\d-[0-1]\\d-[0-3]\\d$/, compareDate),\n  time: fmtDef(\n    /^(?:[0-2]\\d:[0-5]\\d:[0-5]\\d|23:59:60)(?:\\.\\d+)?(?:z|[+-]\\d\\d(?::?\\d\\d)?)$/i,\n    compareTime\n  ),\n  \"date-time\": fmtDef(\n    /^\\d\\d\\d\\d-[0-1]\\d-[0-3]\\dt(?:[0-2]\\d:[0-5]\\d:[0-5]\\d|23:59:60)(?:\\.\\d+)?(?:z|[+-]\\d\\d(?::?\\d\\d)?)$/i,\n    compareDateTime\n  ),\n  \"iso-time\": fmtDef(\n    /^(?:[0-2]\\d:[0-5]\\d:[0-5]\\d|23:59:60)(?:\\.\\d+)?(?:z|[+-]\\d\\d(?::?\\d\\d)?)?$/i,\n    compareIsoTime\n  ),\n  \"iso-date-time\": fmtDef(\n    /^\\d\\d\\d\\d-[0-1]\\d-[0-3]\\d[t\\s](?:[0-2]\\d:[0-5]\\d:[0-5]\\d|23:59:60)(?:\\.\\d+)?(?:z|[+-]\\d\\d(?::?\\d\\d)?)?$/i,\n    compareIsoDateTime\n  ),\n  // uri: https://github.com/mafintosh/is-my-json-valid/blob/master/formats.js\n  uri: /^(?:[a-z][a-z0-9+\\-.]*:)(?:\\/?\\/)?[^\\s]*$/i,\n  \"uri-reference\": /^(?:(?:[a-z][a-z0-9+\\-.]*:)?\\/?\\/)?(?:[^\\\\\\s#][^\\s#]*)?(?:#[^\\\\\\s]*)?$/i,\n  // email (sources from jsen validator):\n  // http://stackoverflow.com/questions/201323/using-a-regular-expression-to-validate-an-email-address#answer-8829363\n  // http://www.w3.org/TR/html5/forms.html#valid-e-mail-address (search for 'wilful violation')\n  email:\n    /^[a-z0-9.!#$%&'*+/=?^_`{|}~-]+@[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?(?:\\.[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?)*$/i,\n}\n\nexport const formatNames = Object.keys(fullFormats) as FormatName[]\n\nfunction isLeapYear(year: number): boolean {\n  // https://tools.ietf.org/html/rfc3339#appendix-C\n  return year % 4 === 0 && (year % 100 !== 0 || year % 400 === 0)\n}\n\nconst DATE = /^(\\d\\d\\d\\d)-(\\d\\d)-(\\d\\d)$/\nconst DAYS = [0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]\n\nfunction date(str: string): boolean {\n  // full-date from http://tools.ietf.org/html/rfc3339#section-5.6\n  const matches: string[] | null = DATE.exec(str)\n  if (!matches) return false\n  const year: number = +matches[1]\n  const month: number = +matches[2]\n  const day: number = +matches[3]\n  return (\n    month >= 1 &&\n    month <= 12 &&\n    day >= 1 &&\n    day <= (month === 2 && isLeapYear(year) ? 29 : DAYS[month])\n  )\n}\n\nfunction compareDate(d1: string, d2: string): number | undefined {\n  if (!(d1 && d2)) return undefined\n  if (d1 > d2) return 1\n  if (d1 < d2) return -1\n  return 0\n}\n\nconst TIME = /^(\\d\\d):(\\d\\d):(\\d\\d(?:\\.\\d+)?)(z|([+-])(\\d\\d)(?::?(\\d\\d))?)?$/i\n\nfunction getTime(strictTimeZone?: boolean): (str: string) => boolean {\n  return function time(str: string): boolean {\n    const matches: string[] | null = TIME.exec(str)\n    if (!matches) return false\n    const hr: number = +matches[1]\n    const min: number = +matches[2]\n    const sec: number = +matches[3]\n    const tz: string | undefined = matches[4]\n    const tzSign: number = matches[5] === \"-\" ? -1 : 1\n    const tzH: number = +(matches[6] || 0)\n    const tzM: number = +(matches[7] || 0)\n    if (tzH > 23 || tzM > 59 || (strictTimeZone && !tz)) return false\n    if (hr <= 23 && min <= 59 && sec < 60) return true\n    // leap second\n    const utcMin = min - tzM * tzSign\n    const utcHr = hr - tzH * tzSign - (utcMin < 0 ? 1 : 0)\n    return (utcHr === 23 || utcHr === -1) && (utcMin === 59 || utcMin === -1) && sec < 61\n  }\n}\n\nfunction compareTime(s1: string, s2: string): number | undefined {\n  if (!(s1 && s2)) return undefined\n  const t1 = new Date(\"2020-01-01T\" + s1).valueOf()\n  const t2 = new Date(\"2020-01-01T\" + s2).valueOf()\n  if (!(t1 && t2)) return undefined\n  return t1 - t2\n}\n\nfunction compareIsoTime(t1: string, t2: string): number | undefined {\n  if (!(t1 && t2)) return undefined\n  const a1 = TIME.exec(t1)\n  const a2 = TIME.exec(t2)\n  if (!(a1 && a2)) return undefined\n  t1 = a1[1] + a1[2] + a1[3]\n  t2 = a2[1] + a2[2] + a2[3]\n  if (t1 > t2) return 1\n  if (t1 < t2) return -1\n  return 0\n}\n\nconst DATE_TIME_SEPARATOR = /t|\\s/i\nfunction getDateTime(strictTimeZone?: boolean): (str: string) => boolean {\n  const time = getTime(strictTimeZone)\n\n  return function date_time(str: string): boolean {\n    // http://tools.ietf.org/html/rfc3339#section-5.6\n    const dateTime: string[] = str.split(DATE_TIME_SEPARATOR)\n    return dateTime.length === 2 && date(dateTime[0]) && time(dateTime[1])\n  }\n}\n\nfunction compareDateTime(dt1: string, dt2: string): number | undefined {\n  if (!(dt1 && dt2)) return undefined\n  const d1 = new Date(dt1).valueOf()\n  const d2 = new Date(dt2).valueOf()\n  if (!(d1 && d2)) return undefined\n  return d1 - d2\n}\n\nfunction compareIsoDateTime(dt1: string, dt2: string): number | undefined {\n  if (!(dt1 && dt2)) return undefined\n  const [d1, t1] = dt1.split(DATE_TIME_SEPARATOR)\n  const [d2, t2] = dt2.split(DATE_TIME_SEPARATOR)\n  const res = compareDate(d1, d2)\n  if (res === undefined) return undefined\n  return res || compareTime(t1, t2)\n}\n\nconst NOT_URI_FRAGMENT = /\\/|:/\nconst URI =\n  /^(?:[a-z][a-z0-9+\\-.]*:)(?:\\/?\\/(?:(?:[a-z0-9\\-._~!$&'()*+,;=:]|%[0-9a-f]{2})*@)?(?:\\[(?:(?:(?:(?:[0-9a-f]{1,4}:){6}|::(?:[0-9a-f]{1,4}:){5}|(?:[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){4}|(?:(?:[0-9a-f]{1,4}:){0,1}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){3}|(?:(?:[0-9a-f]{1,4}:){0,2}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){2}|(?:(?:[0-9a-f]{1,4}:){0,3}[0-9a-f]{1,4})?::[0-9a-f]{1,4}:|(?:(?:[0-9a-f]{1,4}:){0,4}[0-9a-f]{1,4})?::)(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\\d|[01]?\\d\\d?)\\.){3}(?:25[0-5]|2[0-4]\\d|[01]?\\d\\d?))|(?:(?:[0-9a-f]{1,4}:){0,5}[0-9a-f]{1,4})?::[0-9a-f]{1,4}|(?:(?:[0-9a-f]{1,4}:){0,6}[0-9a-f]{1,4})?::)|[Vv][0-9a-f]+\\.[a-z0-9\\-._~!$&'()*+,;=:]+)\\]|(?:(?:25[0-5]|2[0-4]\\d|[01]?\\d\\d?)\\.){3}(?:25[0-5]|2[0-4]\\d|[01]?\\d\\d?)|(?:[a-z0-9\\-._~!$&'()*+,;=]|%[0-9a-f]{2})*)(?::\\d*)?(?:\\/(?:[a-z0-9\\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*|\\/(?:(?:[a-z0-9\\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})+(?:\\/(?:[a-z0-9\\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*)?|(?:[a-z0-9\\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})+(?:\\/(?:[a-z0-9\\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*)(?:\\?(?:[a-z0-9\\-._~!$&'()*+,;=:@/?]|%[0-9a-f]{2})*)?(?:#(?:[a-z0-9\\-._~!$&'()*+,;=:@/?]|%[0-9a-f]{2})*)?$/i\n\nfunction uri(str: string): boolean {\n  // http://jmrware.com/articles/2009/uri_regexp/URI_regex.html + optional protocol + required \".\"\n  return NOT_URI_FRAGMENT.test(str) && URI.test(str)\n}\n\nconst BYTE = /^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/gm\n\nfunction byte(str: string): boolean {\n  BYTE.lastIndex = 0\n  return BYTE.test(str)\n}\n\nconst MIN_INT32 = -(2 ** 31)\nconst MAX_INT32 = 2 ** 31 - 1\n\nfunction validateInt32(value: number): boolean {\n  return Number.isInteger(value) && value <= MAX_INT32 && value >= MIN_INT32\n}\n\nfunction validateInt64(value: number): boolean {\n  // JSON and javascript max Int is 2**53, so any int that passes isInteger is valid for Int64\n  return Number.isInteger(value)\n}\n\nfunction validateNumber(): boolean {\n  return true\n}\n\nconst Z_ANCHOR = /[^\\\\]\\\\Z/\nfunction regex(str: string): boolean {\n  if (Z_ANCHOR.test(str)) return false\n  try {\n    new RegExp(str)\n    return true\n  } catch (e) {\n    return false\n  }\n}\n","import type {\n  CodeKeywordDefinition,\n  KeywordErrorDefinition,\n  ErrorObject,\n  AnySchema,\n} from \"../../types\"\nimport type {KeywordCxt} from \"../../compile/validate\"\nimport {_, str} from \"../../compile/codegen\"\nimport {alwaysValidSchema} from \"../../compile/util\"\nimport {validateArray} from \"../code\"\nimport {validateAdditionalItems} from \"./additionalItems\"\n\nexport type ItemsError = ErrorObject<\"items\", {limit: number}, AnySchema>\n\nconst error: KeywordErrorDefinition = {\n  message: ({params: {len}}) => str`must NOT have more than ${len} items`,\n  params: ({params: {len}}) => _`{limit: ${len}}`,\n}\n\nconst def: CodeKeywordDefinition = {\n  keyword: \"items\",\n  type: \"array\",\n  schemaType: [\"object\", \"boolean\"],\n  before: \"uniqueItems\",\n  error,\n  code(cxt: KeywordCxt) {\n    const {schema, parentSchema, it} = cxt\n    const {prefixItems} = parentSchema\n    it.items = true\n    if (alwaysValidSchema(it, schema)) return\n    if (prefixItems) validateAdditionalItems(cxt, prefixItems)\n    else cxt.ok(validateArray(cxt))\n  },\n}\n\nexport default def\n","import type {\n  CodeKeywordDefinition,\n  KeywordErrorDefinition,\n  ErrorObject,\n  AnySchema,\n} from \"../../types\"\nimport type {KeywordCxt} from \"../../compile/validate\"\nimport {_, str, Name} from \"../../compile/codegen\"\nimport {alwaysValidSchema, checkStrictMode, Type} from \"../../compile/util\"\n\nexport type ContainsError = ErrorObject<\n  \"contains\",\n  {minContains: number; maxContains?: number},\n  AnySchema\n>\n\nconst error: KeywordErrorDefinition = {\n  message: ({params: {min, max}}) =>\n    max === undefined\n      ? str`must contain at least ${min} valid item(s)`\n      : str`must contain at least ${min} and no more than ${max} valid item(s)`,\n  params: ({params: {min, max}}) =>\n    max === undefined ? _`{minContains: ${min}}` : _`{minContains: ${min}, maxContains: ${max}}`,\n}\n\nconst def: CodeKeywordDefinition = {\n  keyword: \"contains\",\n  type: \"array\",\n  schemaType: [\"object\", \"boolean\"],\n  before: \"uniqueItems\",\n  trackErrors: true,\n  error,\n  code(cxt: KeywordCxt) {\n    const {gen, schema, parentSchema, data, it} = cxt\n    let min: number\n    let max: number | undefined\n    const {minContains, maxContains} = parentSchema\n    if (it.opts.next) {\n      min = minContains === undefined ? 1 : minContains\n      max = maxContains\n    } else {\n      min = 1\n    }\n    const len = gen.const(\"len\", _`${data}.length`)\n    cxt.setParams({min, max})\n    if (max === undefined && min === 0) {\n      checkStrictMode(it, `\"minContains\" == 0 without \"maxContains\": \"contains\" keyword ignored`)\n      return\n    }\n    if (max !== undefined && min > max) {\n      checkStrictMode(it, `\"minContains\" > \"maxContains\" is always invalid`)\n      cxt.fail()\n      return\n    }\n    if (alwaysValidSchema(it, schema)) {\n      let cond = _`${len} >= ${min}`\n      if (max !== undefined) cond = _`${cond} && ${len} <= ${max}`\n      cxt.pass(cond)\n      return\n    }\n\n    it.items = true\n    const valid = gen.name(\"valid\")\n    if (max === undefined && min === 1) {\n      validateItems(valid, () => gen.if(valid, () => gen.break()))\n    } else if (min === 0) {\n      gen.let(valid, true)\n      if (max !== undefined) gen.if(_`${data}.length > 0`, validateItemsWithCount)\n    } else {\n      gen.let(valid, false)\n      validateItemsWithCount()\n    }\n    cxt.result(valid, () => cxt.reset())\n\n    function validateItemsWithCount(): void {\n      const schValid = gen.name(\"_valid\")\n      const count = gen.let(\"count\", 0)\n      validateItems(schValid, () => gen.if(schValid, () => checkLimits(count)))\n    }\n\n    function validateItems(_valid: Name, block: () => void): void {\n      gen.forRange(\"i\", 0, len, (i) => {\n        cxt.subschema(\n          {\n            keyword: \"contains\",\n            dataProp: i,\n            dataPropType: Type.Num,\n            compositeRule: true,\n          },\n          _valid\n        )\n        block()\n      })\n    }\n\n    function checkLimits(count: Name): void {\n      gen.code(_`${count}++`)\n      if (max === undefined) {\n        gen.if(_`${count} >= ${min}`, () => gen.assign(valid, true).break())\n      } else {\n        gen.if(_`${count} > ${max}`, () => gen.assign(valid, false).break())\n        if (min === 1) gen.assign(valid, true)\n        else gen.if(_`${count} >= ${min}`, () => gen.assign(valid, true))\n      }\n    }\n  },\n}\n\nexport default def\n","import type {CodeKeywordDefinition, KeywordErrorDefinition} from \"../../types\"\nimport type {KeywordCxt} from \"../../compile/validate\"\nimport {_, str, operators} from \"../../compile/codegen\"\n\nconst error: KeywordErrorDefinition = {\n  message({keyword, schemaCode}) {\n    const comp = keyword === \"maxProperties\" ? \"more\" : \"fewer\"\n    return str`must NOT have ${comp} than ${schemaCode} properties`\n  },\n  params: ({schemaCode}) => _`{limit: ${schemaCode}}`,\n}\n\nconst def: CodeKeywordDefinition = {\n  keyword: [\"maxProperties\", \"minProperties\"],\n  type: \"object\",\n  schemaType: \"number\",\n  $data: true,\n  error,\n  code(cxt: KeywordCxt) {\n    const {keyword, data, schemaCode} = cxt\n    const op = keyword === \"maxProperties\" ? operators.GT : operators.LT\n    cxt.fail$data(_`Object.keys(${data}).length ${op} ${schemaCode}`)\n  },\n}\n\nexport default def\n","import type {CodeKeywordDefinition, ErrorObject, KeywordErrorDefinition} from \"../../types\"\nimport type {KeywordCxt} from \"../../compile/validate\"\nimport {_} from \"../../compile/codegen\"\nimport {useFunc} from \"../../compile/util\"\nimport equal from \"../../runtime/equal\"\n\nexport type ConstError = ErrorObject<\"const\", {allowedValue: any}>\n\nconst error: KeywordErrorDefinition = {\n  message: \"must be equal to constant\",\n  params: ({schemaCode}) => _`{allowedValue: ${schemaCode}}`,\n}\n\nconst def: CodeKeywordDefinition = {\n  keyword: \"const\",\n  $data: true,\n  error,\n  code(cxt: KeywordCxt) {\n    const {gen, data, $data, schemaCode, schema} = cxt\n    if ($data || (schema && typeof schema == \"object\")) {\n      cxt.fail$data(_`!${useFunc(gen, equal)}(${data}, ${schemaCode})`)\n    } else {\n      cxt.fail(_`${schema} !== ${data}`)\n    }\n  },\n}\n\nexport default def\n","import type {\n  CodeKeywordDefinition,\n  ErrorObject,\n  KeywordErrorDefinition,\n  SchemaMap,\n  AnySchema,\n} from \"../../types\"\nimport type {KeywordCxt} from \"../../compile/validate\"\nimport {_, str} from \"../../compile/codegen\"\nimport {alwaysValidSchema} from \"../../compile/util\"\nimport {checkReportMissingProp, checkMissingProp, reportMissingProp, propertyInData} from \"../code\"\n\nexport type PropertyDependencies = {[K in string]?: string[]}\n\nexport interface DependenciesErrorParams {\n  property: string\n  missingProperty: string\n  depsCount: number\n  deps: string // TODO change to string[]\n}\n\ntype SchemaDependencies = SchemaMap\n\nexport type DependenciesError = ErrorObject<\n  \"dependencies\",\n  DependenciesErrorParams,\n  {[K in string]?: string[] | AnySchema}\n>\n\nexport const error: KeywordErrorDefinition = {\n  message: ({params: {property, depsCount, deps}}) => {\n    const property_ies = depsCount === 1 ? \"property\" : \"properties\"\n    return str`must have ${property_ies} ${deps} when property ${property} is present`\n  },\n  params: ({params: {property, depsCount, deps, missingProperty}}) =>\n    _`{property: ${property},\n    missingProperty: ${missingProperty},\n    depsCount: ${depsCount},\n    deps: ${deps}}`, // TODO change to reference\n}\n\nconst def: CodeKeywordDefinition = {\n  keyword: \"dependencies\",\n  type: \"object\",\n  schemaType: \"object\",\n  error,\n  code(cxt: KeywordCxt) {\n    const [propDeps, schDeps] = splitDependencies(cxt)\n    validatePropertyDeps(cxt, propDeps)\n    validateSchemaDeps(cxt, schDeps)\n  },\n}\n\nfunction splitDependencies({schema}: KeywordCxt): [PropertyDependencies, SchemaDependencies] {\n  const propertyDeps: PropertyDependencies = {}\n  const schemaDeps: SchemaDependencies = {}\n  for (const key in schema) {\n    if (key === \"__proto__\") continue\n    const deps = Array.isArray(schema[key]) ? propertyDeps : schemaDeps\n    deps[key] = schema[key]\n  }\n  return [propertyDeps, schemaDeps]\n}\n\nexport function validatePropertyDeps(\n  cxt: KeywordCxt,\n  propertyDeps: {[K in string]?: string[]} = cxt.schema\n): void {\n  const {gen, data, it} = cxt\n  if (Object.keys(propertyDeps).length === 0) return\n  const missing = gen.let(\"missing\")\n  for (const prop in propertyDeps) {\n    const deps = propertyDeps[prop] as string[]\n    if (deps.length === 0) continue\n    const hasProperty = propertyInData(gen, data, prop, it.opts.ownProperties)\n    cxt.setParams({\n      property: prop,\n      depsCount: deps.length,\n      deps: deps.join(\", \"),\n    })\n    if (it.allErrors) {\n      gen.if(hasProperty, () => {\n        for (const depProp of deps) {\n          checkReportMissingProp(cxt, depProp)\n        }\n      })\n    } else {\n      gen.if(_`${hasProperty} && (${checkMissingProp(cxt, deps, missing)})`)\n      reportMissingProp(cxt, missing)\n      gen.else()\n    }\n  }\n}\n\nexport function validateSchemaDeps(cxt: KeywordCxt, schemaDeps: SchemaMap = cxt.schema): void {\n  const {gen, data, keyword, it} = cxt\n  const valid = gen.name(\"valid\")\n  for (const prop in schemaDeps) {\n    if (alwaysValidSchema(it, schemaDeps[prop] as AnySchema)) continue\n    gen.if(\n      propertyInData(gen, data, prop, it.opts.ownProperties),\n      () => {\n        const schCxt = cxt.subschema({keyword, schemaProp: prop}, valid)\n        cxt.mergeValidEvaluated(schCxt, valid)\n      },\n      () => gen.var(valid, true) // TODO var\n    )\n    cxt.ok(valid)\n  }\n}\n\nexport default def\n","import type {\n  CodeKeywordDefinition,\n  ErrorObject,\n  KeywordErrorDefinition,\n  AnySchema,\n} from \"../../types\"\nimport type {KeywordCxt} from \"../../compile/validate\"\nimport {_, not} from \"../../compile/codegen\"\nimport {alwaysValidSchema} from \"../../compile/util\"\n\nexport type PropertyNamesError = ErrorObject<\"propertyNames\", {propertyName: string}, AnySchema>\n\nconst error: KeywordErrorDefinition = {\n  message: \"property name must be valid\",\n  params: ({params}) => _`{propertyName: ${params.propertyName}}`,\n}\n\nconst def: CodeKeywordDefinition = {\n  keyword: \"propertyNames\",\n  type: \"object\",\n  schemaType: [\"object\", \"boolean\"],\n  error,\n  code(cxt: KeywordCxt) {\n    const {gen, schema, data, it} = cxt\n    if (alwaysValidSchema(it, schema)) return\n    const valid = gen.name(\"valid\")\n\n    gen.forIn(\"key\", data, (key) => {\n      cxt.setParams({propertyName: key})\n      cxt.subschema(\n        {\n          keyword: \"propertyNames\",\n          data: key,\n          dataTypes: [\"string\"],\n          propertyName: key,\n          compositeRule: true,\n        },\n        valid\n      )\n      gen.if(not(valid), () => {\n        cxt.error(true)\n        if (!it.allErrors) gen.break()\n      })\n    })\n\n    cxt.ok(valid)\n  },\n}\n\nexport default def\n","import type {\n  AddedKeywordDefinition,\n  AnySchema,\n  AnySchemaObject,\n  KeywordErrorCxt,\n  KeywordCxtParams,\n} from \"../../types\"\nimport type {SchemaCxt, SchemaObjCxt} from \"..\"\nimport type {InstanceOptions} from \"../../core\"\nimport {boolOrEmptySchema, topBoolOrEmptySchema} from \"./boolSchema\"\nimport {coerceAndCheckDataType, getSchemaTypes} from \"./dataType\"\nimport {shouldUseGroup, shouldUseRule} from \"./applicability\"\nimport {checkDataType, checkDataTypes, reportTypeError, DataType} from \"./dataType\"\nimport {assignDefaults} from \"./defaults\"\nimport {funcKeywordCode, macroKeywordCode, validateKeywordUsage, validSchemaType} from \"./keyword\"\nimport {getSubschema, extendSubschemaData, SubschemaArgs, extendSubschemaMode} from \"./subschema\"\nimport {_, nil, str, or, not, getProperty, Block, Code, Name, CodeGen} from \"../codegen\"\nimport N from \"../names\"\nimport {resolveUrl} from \"../resolve\"\nimport {\n  schemaRefOrVal,\n  schemaHasRulesButRef,\n  checkUnknownRules,\n  checkStrictMode,\n  unescapeJsonPointer,\n  mergeEvaluated,\n} from \"../util\"\nimport type {JSONType, Rule, RuleGroup} from \"../rules\"\nimport {\n  ErrorPaths,\n  reportError,\n  reportExtraError,\n  resetErrorsCount,\n  keyword$DataError,\n} from \"../errors\"\n\n// schema compilation - generates validation function, subschemaCode (below) is used for subschemas\nexport function validateFunctionCode(it: SchemaCxt): void {\n  if (isSchemaObj(it)) {\n    checkKeywords(it)\n    if (schemaCxtHasRules(it)) {\n      topSchemaObjCode(it)\n      return\n    }\n  }\n  validateFunction(it, () => topBoolOrEmptySchema(it))\n}\n\nfunction validateFunction(\n  {gen, validateName, schema, schemaEnv, opts}: SchemaCxt,\n  body: Block\n): void {\n  if (opts.code.es5) {\n    gen.func(validateName, _`${N.data}, ${N.valCxt}`, schemaEnv.$async, () => {\n      gen.code(_`\"use strict\"; ${funcSourceUrl(schema, opts)}`)\n      destructureValCxtES5(gen, opts)\n      gen.code(body)\n    })\n  } else {\n    gen.func(validateName, _`${N.data}, ${destructureValCxt(opts)}`, schemaEnv.$async, () =>\n      gen.code(funcSourceUrl(schema, opts)).code(body)\n    )\n  }\n}\n\nfunction destructureValCxt(opts: InstanceOptions): Code {\n  return _`{${N.instancePath}=\"\", ${N.parentData}, ${N.parentDataProperty}, ${N.rootData}=${\n    N.data\n  }${opts.dynamicRef ? _`, ${N.dynamicAnchors}={}` : nil}}={}`\n}\n\nfunction destructureValCxtES5(gen: CodeGen, opts: InstanceOptions): void {\n  gen.if(\n    N.valCxt,\n    () => {\n      gen.var(N.instancePath, _`${N.valCxt}.${N.instancePath}`)\n      gen.var(N.parentData, _`${N.valCxt}.${N.parentData}`)\n      gen.var(N.parentDataProperty, _`${N.valCxt}.${N.parentDataProperty}`)\n      gen.var(N.rootData, _`${N.valCxt}.${N.rootData}`)\n      if (opts.dynamicRef) gen.var(N.dynamicAnchors, _`${N.valCxt}.${N.dynamicAnchors}`)\n    },\n    () => {\n      gen.var(N.instancePath, _`\"\"`)\n      gen.var(N.parentData, _`undefined`)\n      gen.var(N.parentDataProperty, _`undefined`)\n      gen.var(N.rootData, N.data)\n      if (opts.dynamicRef) gen.var(N.dynamicAnchors, _`{}`)\n    }\n  )\n}\n\nfunction topSchemaObjCode(it: SchemaObjCxt): void {\n  const {schema, opts, gen} = it\n  validateFunction(it, () => {\n    if (opts.$comment && schema.$comment) commentKeyword(it)\n    checkNoDefault(it)\n    gen.let(N.vErrors, null)\n    gen.let(N.errors, 0)\n    if (opts.unevaluated) resetEvaluated(it)\n    typeAndKeywords(it)\n    returnResults(it)\n  })\n  return\n}\n\nfunction resetEvaluated(it: SchemaObjCxt): void {\n  // TODO maybe some hook to execute it in the end to check whether props/items are Name, as in assignEvaluated\n  const {gen, validateName} = it\n  it.evaluated = gen.const(\"evaluated\", _`${validateName}.evaluated`)\n  gen.if(_`${it.evaluated}.dynamicProps`, () => gen.assign(_`${it.evaluated}.props`, _`undefined`))\n  gen.if(_`${it.evaluated}.dynamicItems`, () => gen.assign(_`${it.evaluated}.items`, _`undefined`))\n}\n\nfunction funcSourceUrl(schema: AnySchema, opts: InstanceOptions): Code {\n  const schId = typeof schema == \"object\" && schema[opts.schemaId]\n  return schId && (opts.code.source || opts.code.process) ? _`/*# sourceURL=${schId} */` : nil\n}\n\n// schema compilation - this function is used recursively to generate code for sub-schemas\nfunction subschemaCode(it: SchemaCxt, valid: Name): void {\n  if (isSchemaObj(it)) {\n    checkKeywords(it)\n    if (schemaCxtHasRules(it)) {\n      subSchemaObjCode(it, valid)\n      return\n    }\n  }\n  boolOrEmptySchema(it, valid)\n}\n\nfunction schemaCxtHasRules({schema, self}: SchemaCxt): boolean {\n  if (typeof schema == \"boolean\") return !schema\n  for (const key in schema) if (self.RULES.all[key]) return true\n  return false\n}\n\nfunction isSchemaObj(it: SchemaCxt): it is SchemaObjCxt {\n  return typeof it.schema != \"boolean\"\n}\n\nfunction subSchemaObjCode(it: SchemaObjCxt, valid: Name): void {\n  const {schema, gen, opts} = it\n  if (opts.$comment && schema.$comment) commentKeyword(it)\n  updateContext(it)\n  checkAsyncSchema(it)\n  const errsCount = gen.const(\"_errs\", N.errors)\n  typeAndKeywords(it, errsCount)\n  // TODO var\n  gen.var(valid, _`${errsCount} === ${N.errors}`)\n}\n\nfunction checkKeywords(it: SchemaObjCxt): void {\n  checkUnknownRules(it)\n  checkRefsAndKeywords(it)\n}\n\nfunction typeAndKeywords(it: SchemaObjCxt, errsCount?: Name): void {\n  if (it.opts.jtd) return schemaKeywords(it, [], false, errsCount)\n  const types = getSchemaTypes(it.schema)\n  const checkedTypes = coerceAndCheckDataType(it, types)\n  schemaKeywords(it, types, !checkedTypes, errsCount)\n}\n\nfunction checkRefsAndKeywords(it: SchemaObjCxt): void {\n  const {schema, errSchemaPath, opts, self} = it\n  if (schema.$ref && opts.ignoreKeywordsWithRef && schemaHasRulesButRef(schema, self.RULES)) {\n    self.logger.warn(`$ref: keywords ignored in schema at path \"${errSchemaPath}\"`)\n  }\n}\n\nfunction checkNoDefault(it: SchemaObjCxt): void {\n  const {schema, opts} = it\n  if (schema.default !== undefined && opts.useDefaults && opts.strictSchema) {\n    checkStrictMode(it, \"default is ignored in the schema root\")\n  }\n}\n\nfunction updateContext(it: SchemaObjCxt): void {\n  const schId = it.schema[it.opts.schemaId]\n  if (schId) it.baseId = resolveUrl(it.opts.uriResolver, it.baseId, schId)\n}\n\nfunction checkAsyncSchema(it: SchemaObjCxt): void {\n  if (it.schema.$async && !it.schemaEnv.$async) throw new Error(\"async schema in sync schema\")\n}\n\nfunction commentKeyword({gen, schemaEnv, schema, errSchemaPath, opts}: SchemaObjCxt): void {\n  const msg = schema.$comment\n  if (opts.$comment === true) {\n    gen.code(_`${N.self}.logger.log(${msg})`)\n  } else if (typeof opts.$comment == \"function\") {\n    const schemaPath = str`${errSchemaPath}/$comment`\n    const rootName = gen.scopeValue(\"root\", {ref: schemaEnv.root})\n    gen.code(_`${N.self}.opts.$comment(${msg}, ${schemaPath}, ${rootName}.schema)`)\n  }\n}\n\nfunction returnResults(it: SchemaCxt): void {\n  const {gen, schemaEnv, validateName, ValidationError, opts} = it\n  if (schemaEnv.$async) {\n    // TODO assign unevaluated\n    gen.if(\n      _`${N.errors} === 0`,\n      () => gen.return(N.data),\n      () => gen.throw(_`new ${ValidationError as Name}(${N.vErrors})`)\n    )\n  } else {\n    gen.assign(_`${validateName}.errors`, N.vErrors)\n    if (opts.unevaluated) assignEvaluated(it)\n    gen.return(_`${N.errors} === 0`)\n  }\n}\n\nfunction assignEvaluated({gen, evaluated, props, items}: SchemaCxt): void {\n  if (props instanceof Name) gen.assign(_`${evaluated}.props`, props)\n  if (items instanceof Name) gen.assign(_`${evaluated}.items`, items)\n}\n\nfunction schemaKeywords(\n  it: SchemaObjCxt,\n  types: JSONType[],\n  typeErrors: boolean,\n  errsCount?: Name\n): void {\n  const {gen, schema, data, allErrors, opts, self} = it\n  const {RULES} = self\n  if (schema.$ref && (opts.ignoreKeywordsWithRef || !schemaHasRulesButRef(schema, RULES))) {\n    gen.block(() => keywordCode(it, \"$ref\", (RULES.all.$ref as Rule).definition)) // TODO typecast\n    return\n  }\n  if (!opts.jtd) checkStrictTypes(it, types)\n  gen.block(() => {\n    for (const group of RULES.rules) groupKeywords(group)\n    groupKeywords(RULES.post)\n  })\n\n  function groupKeywords(group: RuleGroup): void {\n    if (!shouldUseGroup(schema, group)) return\n    if (group.type) {\n      gen.if(checkDataType(group.type, data, opts.strictNumbers))\n      iterateKeywords(it, group)\n      if (types.length === 1 && types[0] === group.type && typeErrors) {\n        gen.else()\n        reportTypeError(it)\n      }\n      gen.endIf()\n    } else {\n      iterateKeywords(it, group)\n    }\n    // TODO make it \"ok\" call?\n    if (!allErrors) gen.if(_`${N.errors} === ${errsCount || 0}`)\n  }\n}\n\nfunction iterateKeywords(it: SchemaObjCxt, group: RuleGroup): void {\n  const {\n    gen,\n    schema,\n    opts: {useDefaults},\n  } = it\n  if (useDefaults) assignDefaults(it, group.type)\n  gen.block(() => {\n    for (const rule of group.rules) {\n      if (shouldUseRule(schema, rule)) {\n        keywordCode(it, rule.keyword, rule.definition, group.type)\n      }\n    }\n  })\n}\n\nfunction checkStrictTypes(it: SchemaObjCxt, types: JSONType[]): void {\n  if (it.schemaEnv.meta || !it.opts.strictTypes) return\n  checkContextTypes(it, types)\n  if (!it.opts.allowUnionTypes) checkMultipleTypes(it, types)\n  checkKeywordTypes(it, it.dataTypes)\n}\n\nfunction checkContextTypes(it: SchemaObjCxt, types: JSONType[]): void {\n  if (!types.length) return\n  if (!it.dataTypes.length) {\n    it.dataTypes = types\n    return\n  }\n  types.forEach((t) => {\n    if (!includesType(it.dataTypes, t)) {\n      strictTypesError(it, `type \"${t}\" not allowed by context \"${it.dataTypes.join(\",\")}\"`)\n    }\n  })\n  narrowSchemaTypes(it, types)\n}\n\nfunction checkMultipleTypes(it: SchemaObjCxt, ts: JSONType[]): void {\n  if (ts.length > 1 && !(ts.length === 2 && ts.includes(\"null\"))) {\n    strictTypesError(it, \"use allowUnionTypes to allow union type keyword\")\n  }\n}\n\nfunction checkKeywordTypes(it: SchemaObjCxt, ts: JSONType[]): void {\n  const rules = it.self.RULES.all\n  for (const keyword in rules) {\n    const rule = rules[keyword]\n    if (typeof rule == \"object\" && shouldUseRule(it.schema, rule)) {\n      const {type} = rule.definition\n      if (type.length && !type.some((t) => hasApplicableType(ts, t))) {\n        strictTypesError(it, `missing type \"${type.join(\",\")}\" for keyword \"${keyword}\"`)\n      }\n    }\n  }\n}\n\nfunction hasApplicableType(schTs: JSONType[], kwdT: JSONType): boolean {\n  return schTs.includes(kwdT) || (kwdT === \"number\" && schTs.includes(\"integer\"))\n}\n\nfunction includesType(ts: JSONType[], t: JSONType): boolean {\n  return ts.includes(t) || (t === \"integer\" && ts.includes(\"number\"))\n}\n\nfunction narrowSchemaTypes(it: SchemaObjCxt, withTypes: JSONType[]): void {\n  const ts: JSONType[] = []\n  for (const t of it.dataTypes) {\n    if (includesType(withTypes, t)) ts.push(t)\n    else if (withTypes.includes(\"integer\") && t === \"number\") ts.push(\"integer\")\n  }\n  it.dataTypes = ts\n}\n\nfunction strictTypesError(it: SchemaObjCxt, msg: string): void {\n  const schemaPath = it.schemaEnv.baseId + it.errSchemaPath\n  msg += ` at \"${schemaPath}\" (strictTypes)`\n  checkStrictMode(it, msg, it.opts.strictTypes)\n}\n\nexport class KeywordCxt implements KeywordErrorCxt {\n  readonly gen: CodeGen\n  readonly allErrors?: boolean\n  readonly keyword: string\n  readonly data: Name // Name referencing the current level of the data instance\n  readonly $data?: string | false\n  schema: any // keyword value in the schema\n  readonly schemaValue: Code | number | boolean // Code reference to keyword schema value or primitive value\n  readonly schemaCode: Code | number | boolean // Code reference to resolved schema value (different if schema is $data)\n  readonly schemaType: JSONType[] // allowed type(s) of keyword value in the schema\n  readonly parentSchema: AnySchemaObject\n  readonly errsCount?: Name // Name reference to the number of validation errors collected before this keyword,\n  // requires option trackErrors in keyword definition\n  params: KeywordCxtParams // object to pass parameters to error messages from keyword code\n  readonly it: SchemaObjCxt // schema compilation context (schema is guaranteed to be an object, not boolean)\n  readonly def: AddedKeywordDefinition\n\n  constructor(it: SchemaObjCxt, def: AddedKeywordDefinition, keyword: string) {\n    validateKeywordUsage(it, def, keyword)\n    this.gen = it.gen\n    this.allErrors = it.allErrors\n    this.keyword = keyword\n    this.data = it.data\n    this.schema = it.schema[keyword]\n    this.$data = def.$data && it.opts.$data && this.schema && this.schema.$data\n    this.schemaValue = schemaRefOrVal(it, this.schema, keyword, this.$data)\n    this.schemaType = def.schemaType\n    this.parentSchema = it.schema\n    this.params = {}\n    this.it = it\n    this.def = def\n\n    if (this.$data) {\n      this.schemaCode = it.gen.const(\"vSchema\", getData(this.$data, it))\n    } else {\n      this.schemaCode = this.schemaValue\n      if (!validSchemaType(this.schema, def.schemaType, def.allowUndefined)) {\n        throw new Error(`${keyword} value must be ${JSON.stringify(def.schemaType)}`)\n      }\n    }\n\n    if (\"code\" in def ? def.trackErrors : def.errors !== false) {\n      this.errsCount = it.gen.const(\"_errs\", N.errors)\n    }\n  }\n\n  result(condition: Code, successAction?: () => void, failAction?: () => void): void {\n    this.failResult(not(condition), successAction, failAction)\n  }\n\n  failResult(condition: Code, successAction?: () => void, failAction?: () => void): void {\n    this.gen.if(condition)\n    if (failAction) failAction()\n    else this.error()\n    if (successAction) {\n      this.gen.else()\n      successAction()\n      if (this.allErrors) this.gen.endIf()\n    } else {\n      if (this.allErrors) this.gen.endIf()\n      else this.gen.else()\n    }\n  }\n\n  pass(condition: Code, failAction?: () => void): void {\n    this.failResult(not(condition), undefined, failAction)\n  }\n\n  fail(condition?: Code): void {\n    if (condition === undefined) {\n      this.error()\n      if (!this.allErrors) this.gen.if(false) // this branch will be removed by gen.optimize\n      return\n    }\n    this.gen.if(condition)\n    this.error()\n    if (this.allErrors) this.gen.endIf()\n    else this.gen.else()\n  }\n\n  fail$data(condition: Code): void {\n    if (!this.$data) return this.fail(condition)\n    const {schemaCode} = this\n    this.fail(_`${schemaCode} !== undefined && (${or(this.invalid$data(), condition)})`)\n  }\n\n  error(append?: boolean, errorParams?: KeywordCxtParams, errorPaths?: ErrorPaths): void {\n    if (errorParams) {\n      this.setParams(errorParams)\n      this._error(append, errorPaths)\n      this.setParams({})\n      return\n    }\n    this._error(append, errorPaths)\n  }\n\n  private _error(append?: boolean, errorPaths?: ErrorPaths): void {\n    ;(append ? reportExtraError : reportError)(this, this.def.error, errorPaths)\n  }\n\n  $dataError(): void {\n    reportError(this, this.def.$dataError || keyword$DataError)\n  }\n\n  reset(): void {\n    if (this.errsCount === undefined) throw new Error('add \"trackErrors\" to keyword definition')\n    resetErrorsCount(this.gen, this.errsCount)\n  }\n\n  ok(cond: Code | boolean): void {\n    if (!this.allErrors) this.gen.if(cond)\n  }\n\n  setParams(obj: KeywordCxtParams, assign?: true): void {\n    if (assign) Object.assign(this.params, obj)\n    else this.params = obj\n  }\n\n  block$data(valid: Name, codeBlock: () => void, $dataValid: Code = nil): void {\n    this.gen.block(() => {\n      this.check$data(valid, $dataValid)\n      codeBlock()\n    })\n  }\n\n  check$data(valid: Name = nil, $dataValid: Code = nil): void {\n    if (!this.$data) return\n    const {gen, schemaCode, schemaType, def} = this\n    gen.if(or(_`${schemaCode} === undefined`, $dataValid))\n    if (valid !== nil) gen.assign(valid, true)\n    if (schemaType.length || def.validateSchema) {\n      gen.elseIf(this.invalid$data())\n      this.$dataError()\n      if (valid !== nil) gen.assign(valid, false)\n    }\n    gen.else()\n  }\n\n  invalid$data(): Code {\n    const {gen, schemaCode, schemaType, def, it} = this\n    return or(wrong$DataType(), invalid$DataSchema())\n\n    function wrong$DataType(): Code {\n      if (schemaType.length) {\n        /* istanbul ignore if */\n        if (!(schemaCode instanceof Name)) throw new Error(\"ajv implementation error\")\n        const st = Array.isArray(schemaType) ? schemaType : [schemaType]\n        return _`${checkDataTypes(st, schemaCode, it.opts.strictNumbers, DataType.Wrong)}`\n      }\n      return nil\n    }\n\n    function invalid$DataSchema(): Code {\n      if (def.validateSchema) {\n        const validateSchemaRef = gen.scopeValue(\"validate$data\", {ref: def.validateSchema}) // TODO value.code for standalone\n        return _`!${validateSchemaRef}(${schemaCode})`\n      }\n      return nil\n    }\n  }\n\n  subschema(appl: SubschemaArgs, valid: Name): SchemaCxt {\n    const subschema = getSubschema(this.it, appl)\n    extendSubschemaData(subschema, this.it, appl)\n    extendSubschemaMode(subschema, appl)\n    const nextContext = {...this.it, ...subschema, items: undefined, props: undefined}\n    subschemaCode(nextContext, valid)\n    return nextContext\n  }\n\n  mergeEvaluated(schemaCxt: SchemaCxt, toName?: typeof Name): void {\n    const {it, gen} = this\n    if (!it.opts.unevaluated) return\n    if (it.props !== true && schemaCxt.props !== undefined) {\n      it.props = mergeEvaluated.props(gen, schemaCxt.props, it.props, toName)\n    }\n    if (it.items !== true && schemaCxt.items !== undefined) {\n      it.items = mergeEvaluated.items(gen, schemaCxt.items, it.items, toName)\n    }\n  }\n\n  mergeValidEvaluated(schemaCxt: SchemaCxt, valid: Name): boolean | void {\n    const {it, gen} = this\n    if (it.opts.unevaluated && (it.props !== true || it.items !== true)) {\n      gen.if(valid, () => this.mergeEvaluated(schemaCxt, Name))\n      return true\n    }\n  }\n}\n\nfunction keywordCode(\n  it: SchemaObjCxt,\n  keyword: string,\n  def: AddedKeywordDefinition,\n  ruleType?: JSONType\n): void {\n  const cxt = new KeywordCxt(it, def, keyword)\n  if (\"code\" in def) {\n    def.code(cxt, ruleType)\n  } else if (cxt.$data && def.validate) {\n    funcKeywordCode(cxt, def)\n  } else if (\"macro\" in def) {\n    macroKeywordCode(cxt, def)\n  } else if (def.compile || def.validate) {\n    funcKeywordCode(cxt, def)\n  }\n}\n\nconst JSON_POINTER = /^\\/(?:[^~]|~0|~1)*$/\nconst RELATIVE_JSON_POINTER = /^([0-9]+)(#|\\/(?:[^~]|~0|~1)*)?$/\nexport function getData(\n  $data: string,\n  {dataLevel, dataNames, dataPathArr}: SchemaCxt\n): Code | number {\n  let jsonPointer\n  let data: Code\n  if ($data === \"\") return N.rootData\n  if ($data[0] === \"/\") {\n    if (!JSON_POINTER.test($data)) throw new Error(`Invalid JSON-pointer: ${$data}`)\n    jsonPointer = $data\n    data = N.rootData\n  } else {\n    const matches = RELATIVE_JSON_POINTER.exec($data)\n    if (!matches) throw new Error(`Invalid JSON-pointer: ${$data}`)\n    const up: number = +matches[1]\n    jsonPointer = matches[2]\n    if (jsonPointer === \"#\") {\n      if (up >= dataLevel) throw new Error(errorMsg(\"property/index\", up))\n      return dataPathArr[dataLevel - up]\n    }\n    if (up > dataLevel) throw new Error(errorMsg(\"data\", up))\n    data = dataNames[dataLevel - up]\n    if (!jsonPointer) return data\n  }\n\n  let expr = data\n  const segments = jsonPointer.split(\"/\")\n  for (const segment of segments) {\n    if (segment) {\n      data = _`${data}${getProperty(unescapeJsonPointer(segment))}`\n      expr = _`${expr} && ${data}`\n    }\n  }\n  return expr\n\n  function errorMsg(pointerType: string, up: number): string {\n    return `Cannot access ${pointerType} ${up} levels up, current level is ${dataLevel}`\n  }\n}\n","// eslint-disable-next-line @typescript-eslint/no-extraneous-class\nexport abstract class _CodeOrName {\n  abstract readonly str: string\n  abstract readonly names: UsedNames\n  abstract toString(): string\n  abstract emptyStr(): boolean\n}\n\nexport const IDENTIFIER = /^[a-z$_][a-z$_0-9]*$/i\n\nexport class Name extends _CodeOrName {\n  readonly str: string\n  constructor(s: string) {\n    super()\n    if (!IDENTIFIER.test(s)) throw new Error(\"CodeGen: name must be a valid identifier\")\n    this.str = s\n  }\n\n  toString(): string {\n    return this.str\n  }\n\n  emptyStr(): boolean {\n    return false\n  }\n\n  get names(): UsedNames {\n    return {[this.str]: 1}\n  }\n}\n\nexport class _Code extends _CodeOrName {\n  readonly _items: readonly CodeItem[]\n  private _str?: string\n  private _names?: UsedNames\n\n  constructor(code: string | readonly CodeItem[]) {\n    super()\n    this._items = typeof code === \"string\" ? [code] : code\n  }\n\n  toString(): string {\n    return this.str\n  }\n\n  emptyStr(): boolean {\n    if (this._items.length > 1) return false\n    const item = this._items[0]\n    return item === \"\" || item === '\"\"'\n  }\n\n  get str(): string {\n    return (this._str ??= this._items.reduce((s: string, c: CodeItem) => `${s}${c}`, \"\"))\n  }\n\n  get names(): UsedNames {\n    return (this._names ??= this._items.reduce((names: UsedNames, c) => {\n      if (c instanceof Name) names[c.str] = (names[c.str] || 0) + 1\n      return names\n    }, {}))\n  }\n}\n\nexport type CodeItem = Name | string | number | boolean | null\n\nexport type UsedNames = Record<string, number | undefined>\n\nexport type Code = _Code | Name\n\nexport type SafeExpr = Code | number | boolean | null\n\nexport const nil = new _Code(\"\")\n\ntype CodeArg = SafeExpr | string | undefined\n\nexport function _(strs: TemplateStringsArray, ...args: CodeArg[]): _Code {\n  const code: CodeItem[] = [strs[0]]\n  let i = 0\n  while (i < args.length) {\n    addCodeArg(code, args[i])\n    code.push(strs[++i])\n  }\n  return new _Code(code)\n}\n\nconst plus = new _Code(\"+\")\n\nexport function str(strs: TemplateStringsArray, ...args: (CodeArg | string[])[]): _Code {\n  const expr: CodeItem[] = [safeStringify(strs[0])]\n  let i = 0\n  while (i < args.length) {\n    expr.push(plus)\n    addCodeArg(expr, args[i])\n    expr.push(plus, safeStringify(strs[++i]))\n  }\n  optimize(expr)\n  return new _Code(expr)\n}\n\nexport function addCodeArg(code: CodeItem[], arg: CodeArg | string[]): void {\n  if (arg instanceof _Code) code.push(...arg._items)\n  else if (arg instanceof Name) code.push(arg)\n  else code.push(interpolate(arg))\n}\n\nfunction optimize(expr: CodeItem[]): void {\n  let i = 1\n  while (i < expr.length - 1) {\n    if (expr[i] === plus) {\n      const res = mergeExprItems(expr[i - 1], expr[i + 1])\n      if (res !== undefined) {\n        expr.splice(i - 1, 3, res)\n        continue\n      }\n      expr[i++] = \"+\"\n    }\n    i++\n  }\n}\n\nfunction mergeExprItems(a: CodeItem, b: CodeItem): CodeItem | undefined {\n  if (b === '\"\"') return a\n  if (a === '\"\"') return b\n  if (typeof a == \"string\") {\n    if (b instanceof Name || a[a.length - 1] !== '\"') return\n    if (typeof b != \"string\") return `${a.slice(0, -1)}${b}\"`\n    if (b[0] === '\"') return a.slice(0, -1) + b.slice(1)\n    return\n  }\n  if (typeof b == \"string\" && b[0] === '\"' && !(a instanceof Name)) return `\"${a}${b.slice(1)}`\n  return\n}\n\nexport function strConcat(c1: Code, c2: Code): Code {\n  return c2.emptyStr() ? c1 : c1.emptyStr() ? c2 : str`${c1}${c2}`\n}\n\n// TODO do not allow arrays here\nfunction interpolate(x?: string | string[] | number | boolean | null): SafeExpr | string {\n  return typeof x == \"number\" || typeof x == \"boolean\" || x === null\n    ? x\n    : safeStringify(Array.isArray(x) ? x.join(\",\") : x)\n}\n\nexport function stringify(x: unknown): Code {\n  return new _Code(safeStringify(x))\n}\n\nexport function safeStringify(x: unknown): string {\n  return JSON.stringify(x)\n    .replace(/\\u2028/g, \"\\\\u2028\")\n    .replace(/\\u2029/g, \"\\\\u2029\")\n}\n\nexport function getProperty(key: Code | string | number): Code {\n  return typeof key == \"string\" && IDENTIFIER.test(key) ? new _Code(`.${key}`) : _`[${key}]`\n}\n\n//Does best effort to format the name properly\nexport function getEsmExportName(key: Code | string | number): Code {\n  if (typeof key == \"string\" && IDENTIFIER.test(key)) {\n    return new _Code(`${key}`)\n  }\n  throw new Error(`CodeGen: invalid export name: ${key}, use explicit $id name mapping`)\n}\n\nexport function regexpCode(rx: RegExp): Code {\n  return new _Code(rx.toString())\n}\n","import type {Vocabulary} from \"../types\"\n\nexport const metadataVocabulary: Vocabulary = [\n  \"title\",\n  \"description\",\n  \"default\",\n  \"deprecated\",\n  \"readOnly\",\n  \"writeOnly\",\n  \"examples\",\n]\n\nexport const contentVocabulary: Vocabulary = [\n  \"contentMediaType\",\n  \"contentEncoding\",\n  \"contentSchema\",\n]\n","import type {CodeKeywordDefinition, ErrorObject, KeywordErrorDefinition} from \"../../types\"\nimport type {KeywordCxt} from \"../../compile/validate\"\nimport {_, or, Name, Code} from \"../../compile/codegen\"\nimport {useFunc} from \"../../compile/util\"\nimport equal from \"../../runtime/equal\"\n\nexport type EnumError = ErrorObject<\"enum\", {allowedValues: any[]}, any[] | {$data: string}>\n\nconst error: KeywordErrorDefinition = {\n  message: \"must be equal to one of the allowed values\",\n  params: ({schemaCode}) => _`{allowedValues: ${schemaCode}}`,\n}\n\nconst def: CodeKeywordDefinition = {\n  keyword: \"enum\",\n  schemaType: \"array\",\n  $data: true,\n  error,\n  code(cxt: KeywordCxt) {\n    const {gen, data, $data, schema, schemaCode, it} = cxt\n    if (!$data && schema.length === 0) throw new Error(\"enum must have non-empty array\")\n    const useLoop = schema.length >= it.opts.loopEnum\n    let eql: Name | undefined\n    const getEql = (): Name => (eql ??= useFunc(gen, equal))\n\n    let valid: Code\n    if (useLoop || $data) {\n      valid = gen.let(\"valid\")\n      cxt.block$data(valid, loopEnum)\n    } else {\n      /* istanbul ignore if */\n      if (!Array.isArray(schema)) throw new Error(\"ajv implementation error\")\n      const vSchema = gen.const(\"vSchema\", schemaCode)\n      valid = or(...schema.map((_x: unknown, i: number) => equalCode(vSchema, i)))\n    }\n    cxt.pass(valid)\n\n    function loopEnum(): void {\n      gen.assign(valid, false)\n      gen.forOf(\"v\", schemaCode as Code, (v) =>\n        gen.if(_`${getEql()}(${data}, ${v})`, () => gen.assign(valid, true).break())\n      )\n    }\n\n    function equalCode(vSchema: Name, i: number): Code {\n      const sch = schema[i]\n      return typeof sch === \"object\" && sch !== null\n        ? _`${getEql()}(${data}, ${vSchema}[${i}])`\n        : _`${data} === ${sch}`\n    }\n  },\n}\n\nexport default def\n","import type {\n  KeywordErrorDefinition,\n  KeywordErrorCxt,\n  ErrorObject,\n  AnySchemaObject,\n} from \"../../types\"\nimport type {SchemaObjCxt} from \"..\"\nimport {isJSONType, JSONType} from \"../rules\"\nimport {schemaHasRulesForType} from \"./applicability\"\nimport {reportError} from \"../errors\"\nimport {_, nil, and, not, operators, Code, Name} from \"../codegen\"\nimport {toHash, schemaRefOrVal} from \"../util\"\n\nexport enum DataType {\n  Correct,\n  Wrong,\n}\n\nexport function getSchemaTypes(schema: AnySchemaObject): JSONType[] {\n  const types = getJSONTypes(schema.type)\n  const hasNull = types.includes(\"null\")\n  if (hasNull) {\n    if (schema.nullable === false) throw new Error(\"type: null contradicts nullable: false\")\n  } else {\n    if (!types.length && schema.nullable !== undefined) {\n      throw new Error('\"nullable\" cannot be used without \"type\"')\n    }\n    if (schema.nullable === true) types.push(\"null\")\n  }\n  return types\n}\n\n// eslint-disable-next-line @typescript-eslint/no-redundant-type-constituents\nexport function getJSONTypes(ts: unknown | unknown[]): JSONType[] {\n  const types: unknown[] = Array.isArray(ts) ? ts : ts ? [ts] : []\n  if (types.every(isJSONType)) return types\n  throw new Error(\"type must be JSONType or JSONType[]: \" + types.join(\",\"))\n}\n\nexport function coerceAndCheckDataType(it: SchemaObjCxt, types: JSONType[]): boolean {\n  const {gen, data, opts} = it\n  const coerceTo = coerceToTypes(types, opts.coerceTypes)\n  const checkTypes =\n    types.length > 0 &&\n    !(coerceTo.length === 0 && types.length === 1 && schemaHasRulesForType(it, types[0]))\n  if (checkTypes) {\n    const wrongType = checkDataTypes(types, data, opts.strictNumbers, DataType.Wrong)\n    gen.if(wrongType, () => {\n      if (coerceTo.length) coerceData(it, types, coerceTo)\n      else reportTypeError(it)\n    })\n  }\n  return checkTypes\n}\n\nconst COERCIBLE: Set<JSONType> = new Set([\"string\", \"number\", \"integer\", \"boolean\", \"null\"])\nfunction coerceToTypes(types: JSONType[], coerceTypes?: boolean | \"array\"): JSONType[] {\n  return coerceTypes\n    ? types.filter((t) => COERCIBLE.has(t) || (coerceTypes === \"array\" && t === \"array\"))\n    : []\n}\n\nfunction coerceData(it: SchemaObjCxt, types: JSONType[], coerceTo: JSONType[]): void {\n  const {gen, data, opts} = it\n  const dataType = gen.let(\"dataType\", _`typeof ${data}`)\n  const coerced = gen.let(\"coerced\", _`undefined`)\n  if (opts.coerceTypes === \"array\") {\n    gen.if(_`${dataType} == 'object' && Array.isArray(${data}) && ${data}.length == 1`, () =>\n      gen\n        .assign(data, _`${data}[0]`)\n        .assign(dataType, _`typeof ${data}`)\n        .if(checkDataTypes(types, data, opts.strictNumbers), () => gen.assign(coerced, data))\n    )\n  }\n  gen.if(_`${coerced} !== undefined`)\n  for (const t of coerceTo) {\n    if (COERCIBLE.has(t) || (t === \"array\" && opts.coerceTypes === \"array\")) {\n      coerceSpecificType(t)\n    }\n  }\n  gen.else()\n  reportTypeError(it)\n  gen.endIf()\n\n  gen.if(_`${coerced} !== undefined`, () => {\n    gen.assign(data, coerced)\n    assignParentData(it, coerced)\n  })\n\n  function coerceSpecificType(t: string): void {\n    switch (t) {\n      case \"string\":\n        gen\n          .elseIf(_`${dataType} == \"number\" || ${dataType} == \"boolean\"`)\n          .assign(coerced, _`\"\" + ${data}`)\n          .elseIf(_`${data} === null`)\n          .assign(coerced, _`\"\"`)\n        return\n      case \"number\":\n        gen\n          .elseIf(\n            _`${dataType} == \"boolean\" || ${data} === null\n              || (${dataType} == \"string\" && ${data} && ${data} == +${data})`\n          )\n          .assign(coerced, _`+${data}`)\n        return\n      case \"integer\":\n        gen\n          .elseIf(\n            _`${dataType} === \"boolean\" || ${data} === null\n              || (${dataType} === \"string\" && ${data} && ${data} == +${data} && !(${data} % 1))`\n          )\n          .assign(coerced, _`+${data}`)\n        return\n      case \"boolean\":\n        gen\n          .elseIf(_`${data} === \"false\" || ${data} === 0 || ${data} === null`)\n          .assign(coerced, false)\n          .elseIf(_`${data} === \"true\" || ${data} === 1`)\n          .assign(coerced, true)\n        return\n      case \"null\":\n        gen.elseIf(_`${data} === \"\" || ${data} === 0 || ${data} === false`)\n        gen.assign(coerced, null)\n        return\n\n      case \"array\":\n        gen\n          .elseIf(\n            _`${dataType} === \"string\" || ${dataType} === \"number\"\n              || ${dataType} === \"boolean\" || ${data} === null`\n          )\n          .assign(coerced, _`[${data}]`)\n    }\n  }\n}\n\nfunction assignParentData({gen, parentData, parentDataProperty}: SchemaObjCxt, expr: Name): void {\n  // TODO use gen.property\n  gen.if(_`${parentData} !== undefined`, () =>\n    gen.assign(_`${parentData}[${parentDataProperty}]`, expr)\n  )\n}\n\nexport function checkDataType(\n  dataType: JSONType,\n  data: Name,\n  strictNums?: boolean | \"log\",\n  correct = DataType.Correct\n): Code {\n  const EQ = correct === DataType.Correct ? operators.EQ : operators.NEQ\n  let cond: Code\n  switch (dataType) {\n    case \"null\":\n      return _`${data} ${EQ} null`\n    case \"array\":\n      cond = _`Array.isArray(${data})`\n      break\n    case \"object\":\n      cond = _`${data} && typeof ${data} == \"object\" && !Array.isArray(${data})`\n      break\n    case \"integer\":\n      cond = numCond(_`!(${data} % 1) && !isNaN(${data})`)\n      break\n    case \"number\":\n      cond = numCond()\n      break\n    default:\n      return _`typeof ${data} ${EQ} ${dataType}`\n  }\n  return correct === DataType.Correct ? cond : not(cond)\n\n  function numCond(_cond: Code = nil): Code {\n    return and(_`typeof ${data} == \"number\"`, _cond, strictNums ? _`isFinite(${data})` : nil)\n  }\n}\n\nexport function checkDataTypes(\n  dataTypes: JSONType[],\n  data: Name,\n  strictNums?: boolean | \"log\",\n  correct?: DataType\n): Code {\n  if (dataTypes.length === 1) {\n    return checkDataType(dataTypes[0], data, strictNums, correct)\n  }\n  let cond: Code\n  const types = toHash(dataTypes)\n  if (types.array && types.object) {\n    const notObj = _`typeof ${data} != \"object\"`\n    cond = types.null ? notObj : _`!${data} || ${notObj}`\n    delete types.null\n    delete types.array\n    delete types.object\n  } else {\n    cond = nil\n  }\n  if (types.number) delete types.integer\n  for (const t in types) cond = and(cond, checkDataType(t as JSONType, data, strictNums, correct))\n  return cond\n}\n\nexport type TypeError = ErrorObject<\"type\", {type: string}>\n\nconst typeError: KeywordErrorDefinition = {\n  message: ({schema}) => `must be ${schema}`,\n  params: ({schema, schemaValue}) =>\n    typeof schema == \"string\" ? _`{type: ${schema}}` : _`{type: ${schemaValue}}`,\n}\n\nexport function reportTypeError(it: SchemaObjCxt): void {\n  const cxt = getTypeErrorContext(it)\n  reportError(cxt, typeError)\n}\n\nfunction getTypeErrorContext(it: SchemaObjCxt): KeywordErrorCxt {\n  const {gen, data, schema} = it\n  const schemaCode = schemaRefOrVal(it, schema, \"type\")\n  return {\n    gen,\n    keyword: \"type\",\n    data,\n    schema: schema.type,\n    schemaCode,\n    schemaValue: schemaCode,\n    parentSchema: schema,\n    params: {},\n    it,\n  }\n}\n","import type {CodeKeywordDefinition} from \"../../types\"\nimport {validateTuple} from \"./items\"\n\nconst def: CodeKeywordDefinition = {\n  keyword: \"prefixItems\",\n  type: \"array\",\n  schemaType: [\"array\"],\n  before: \"uniqueItems\",\n  code: (cxt) => validateTuple(cxt, \"items\"),\n}\n\nexport default def\n","import type {CodeKeywordDefinition} from \"../../types\"\nimport {KeywordCxt} from \"../../compile/validate\"\nimport {propertyInData, allSchemaProperties} from \"../code\"\nimport {alwaysValidSchema, toHash, mergeEvaluated} from \"../../compile/util\"\nimport apDef from \"./additionalProperties\"\n\nconst def: CodeKeywordDefinition = {\n  keyword: \"properties\",\n  type: \"object\",\n  schemaType: \"object\",\n  code(cxt: KeywordCxt) {\n    const {gen, schema, parentSchema, data, it} = cxt\n    if (it.opts.removeAdditional === \"all\" && parentSchema.additionalProperties === undefined) {\n      apDef.code(new KeywordCxt(it, apDef, \"additionalProperties\"))\n    }\n    const allProps = allSchemaProperties(schema)\n    for (const prop of allProps) {\n      it.definedProperties.add(prop)\n    }\n    if (it.opts.unevaluated && allProps.length && it.props !== true) {\n      it.props = mergeEvaluated.props(gen, toHash(allProps), it.props)\n    }\n    const properties = allProps.filter((p) => !alwaysValidSchema(it, schema[p]))\n    if (properties.length === 0) return\n    const valid = gen.name(\"valid\")\n\n    for (const prop of properties) {\n      if (hasDefault(prop)) {\n        applyPropertySchema(prop)\n      } else {\n        gen.if(propertyInData(gen, data, prop, it.opts.ownProperties))\n        applyPropertySchema(prop)\n        if (!it.allErrors) gen.else().var(valid, true)\n        gen.endIf()\n      }\n      cxt.it.definedProperties.add(prop)\n      cxt.ok(valid)\n    }\n\n    function hasDefault(prop: string): boolean | undefined {\n      return it.opts.useDefaults && !it.compositeRule && schema[prop].default !== undefined\n    }\n\n    function applyPropertySchema(prop: string): void {\n      cxt.subschema(\n        {\n          keyword: \"properties\",\n          schemaProp: prop,\n          dataProp: prop,\n        },\n        valid\n      )\n    }\n  },\n}\n\nexport default def\n","import * as uri from \"fast-uri\"\n\ntype URI = typeof uri & {code: string}\n;(uri as URI).code = 'require(\"ajv/dist/runtime/uri\").default'\n\nexport default uri as URI\n","import type {AnySchemaObject} from \"./types\"\nimport AjvCore from \"./core\"\nimport draft7Vocabularies from \"./vocabularies/draft7\"\nimport discriminator from \"./vocabularies/discriminator\"\nimport * as draft7MetaSchema from \"./refs/json-schema-draft-07.json\"\n\nconst META_SUPPORT_DATA = [\"/properties\"]\n\nconst META_SCHEMA_ID = \"http://json-schema.org/draft-07/schema\"\n\nexport class Ajv extends AjvCore {\n  _addVocabularies(): void {\n    super._addVocabularies()\n    draft7Vocabularies.forEach((v) => this.addVocabulary(v))\n    if (this.opts.discriminator) this.addKeyword(discriminator)\n  }\n\n  _addDefaultMetaSchema(): void {\n    super._addDefaultMetaSchema()\n    if (!this.opts.meta) return\n    const metaSchema = this.opts.$data\n      ? this.$dataMetaSchema(draft7MetaSchema, META_SUPPORT_DATA)\n      : draft7MetaSchema\n    this.addMetaSchema(metaSchema, META_SCHEMA_ID, false)\n    this.refs[\"http://json-schema.org/schema\"] = META_SCHEMA_ID\n  }\n\n  defaultMeta(): string | AnySchemaObject | undefined {\n    return (this.opts.defaultMeta =\n      super.defaultMeta() || (this.getSchema(META_SCHEMA_ID) ? META_SCHEMA_ID : undefined))\n  }\n}\n\nmodule.exports = exports = Ajv\nmodule.exports.Ajv = Ajv\nObject.defineProperty(exports, \"__esModule\", {value: true})\n\nexport default Ajv\n\nexport {\n  Format,\n  FormatDefinition,\n  AsyncFormatDefinition,\n  KeywordDefinition,\n  KeywordErrorDefinition,\n  CodeKeywordDefinition,\n  MacroKeywordDefinition,\n  FuncKeywordDefinition,\n  Vocabulary,\n  Schema,\n  SchemaObject,\n  AnySchemaObject,\n  AsyncSchema,\n  AnySchema,\n  ValidateFunction,\n  AsyncValidateFunction,\n  SchemaValidateFunction,\n  ErrorObject,\n  ErrorNoParams,\n} from \"./types\"\n\nexport {Plugin, Options, CodeOptions, InstanceOptions, Logger, ErrorsTextOptions} from \"./core\"\nexport {SchemaCxt, SchemaObjCxt} from \"./compile\"\nexport {KeywordCxt} from \"./compile/validate\"\nexport {DefinedError} from \"./vocabularies/errors\"\nexport {JSONType} from \"./compile/rules\"\nexport {JSONSchemaType} from \"./types/json-schema\"\nexport {_, str, stringify, nil, Name, Code, CodeGen, CodeGenOptions} from \"./compile/codegen\"\nexport {default as ValidationError} from \"./runtime/validation_error\"\nexport {default as MissingRefError} from \"./compile/ref_error\"\n","import {\n  DefinedFormats,\n  FormatMode,\n  FormatName,\n  formatNames,\n  fastFormats,\n  fullFormats,\n} from \"./formats\"\nimport formatLimit from \"./limit\"\nimport type Ajv from \"ajv\"\nimport type {Plugin, Format} from \"ajv\"\nimport {_, Name} from \"ajv/dist/compile/codegen\"\n\nexport {FormatMode, FormatName} from \"./formats\"\nexport {LimitFormatError} from \"./limit\"\nexport interface FormatOptions {\n  mode?: FormatMode\n  formats?: FormatName[]\n  keywords?: boolean\n}\n\nexport type FormatsPluginOptions = FormatName[] | FormatOptions\n\nexport interface FormatsPlugin extends Plugin<FormatsPluginOptions> {\n  get: (format: FormatName, mode?: FormatMode) => Format\n}\n\nconst fullName = new Name(\"fullFormats\")\nconst fastName = new Name(\"fastFormats\")\n\nconst formatsPlugin: FormatsPlugin = (\n  ajv: Ajv,\n  opts: FormatsPluginOptions = {keywords: true}\n): Ajv => {\n  if (Array.isArray(opts)) {\n    addFormats(ajv, opts, fullFormats, fullName)\n    return ajv\n  }\n  const [formats, exportName] =\n    opts.mode === \"fast\" ? [fastFormats, fastName] : [fullFormats, fullName]\n  const list = opts.formats || formatNames\n  addFormats(ajv, list, formats, exportName)\n  if (opts.keywords) formatLimit(ajv)\n  return ajv\n}\n\nformatsPlugin.get = (name: FormatName, mode: FormatMode = \"full\"): Format => {\n  const formats = mode === \"fast\" ? fastFormats : fullFormats\n  const f = formats[name]\n  if (!f) throw new Error(`Unknown format \"${name}\"`)\n  return f\n}\n\nfunction addFormats(ajv: Ajv, list: FormatName[], fs: DefinedFormats, exportName: Name): void {\n  ajv.opts.code.formats ??= _`require(\"ajv-formats/dist/formats\").${exportName}`\n  for (const f of list) ajv.addFormat(f, fs[f])\n}\n\nmodule.exports = exports = formatsPlugin\nObject.defineProperty(exports, \"__esModule\", {value: true})\n\nexport default formatsPlugin\n","'use strict';\n\nvar traverse = module.exports = function (schema, opts, cb) {\n  // Legacy support for v0.3.1 and earlier.\n  if (typeof opts == 'function') {\n    cb = opts;\n    opts = {};\n  }\n\n  cb = opts.cb || cb;\n  var pre = (typeof cb == 'function') ? cb : cb.pre || function() {};\n  var post = cb.post || function() {};\n\n  _traverse(opts, pre, post, schema, '', schema);\n};\n\n\ntraverse.keywords = {\n  additionalItems: true,\n  items: true,\n  contains: true,\n  additionalProperties: true,\n  propertyNames: true,\n  not: true,\n  if: true,\n  then: true,\n  else: true\n};\n\ntraverse.arrayKeywords = {\n  items: true,\n  allOf: true,\n  anyOf: true,\n  oneOf: true\n};\n\ntraverse.propsKeywords = {\n  $defs: true,\n  definitions: true,\n  properties: true,\n  patternProperties: true,\n  dependencies: true\n};\n\ntraverse.skipKeywords = {\n  default: true,\n  enum: true,\n  const: true,\n  required: true,\n  maximum: true,\n  minimum: true,\n  exclusiveMaximum: true,\n  exclusiveMinimum: true,\n  multipleOf: true,\n  maxLength: true,\n  minLength: true,\n  pattern: true,\n  format: true,\n  maxItems: true,\n  minItems: true,\n  uniqueItems: true,\n  maxProperties: true,\n  minProperties: true\n};\n\n\nfunction _traverse(opts, pre, post, schema, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex) {\n  if (schema && typeof schema == 'object' && !Array.isArray(schema)) {\n    pre(schema, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex);\n    for (var key in schema) {\n      var sch = schema[key];\n      if (Array.isArray(sch)) {\n        if (key in traverse.arrayKeywords) {\n          for (var i=0; i<sch.length; i++)\n            _traverse(opts, pre, post, sch[i], jsonPtr + '/' + key + '/' + i, rootSchema, jsonPtr, key, schema, i);\n        }\n      } else if (key in traverse.propsKeywords) {\n        if (sch && typeof sch == 'object') {\n          for (var prop in sch)\n            _traverse(opts, pre, post, sch[prop], jsonPtr + '/' + key + '/' + escapeJsonPtr(prop), rootSchema, jsonPtr, key, schema, prop);\n        }\n      } else if (key in traverse.keywords || (opts.allKeys && !(key in traverse.skipKeywords))) {\n        _traverse(opts, pre, post, sch, jsonPtr + '/' + key, rootSchema, jsonPtr, key, schema);\n      }\n    }\n    post(schema, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex);\n  }\n}\n\n\nfunction escapeJsonPtr(str) {\n  return str.replace(/~/g, '~0').replace(/\\//g, '~1');\n}\n","import type {\n  CodeKeywordDefinition,\n  AddedKeywordDefinition,\n  ErrorObject,\n  KeywordErrorDefinition,\n  AnySchema,\n} from \"../../types\"\nimport {allSchemaProperties, usePattern, isOwnProperty} from \"../code\"\nimport {_, nil, or, not, Code, Name} from \"../../compile/codegen\"\nimport N from \"../../compile/names\"\nimport type {SubschemaArgs} from \"../../compile/validate/subschema\"\nimport {alwaysValidSchema, schemaRefOrVal, Type} from \"../../compile/util\"\n\nexport type AdditionalPropertiesError = ErrorObject<\n  \"additionalProperties\",\n  {additionalProperty: string},\n  AnySchema\n>\n\nconst error: KeywordErrorDefinition = {\n  message: \"must NOT have additional properties\",\n  params: ({params}) => _`{additionalProperty: ${params.additionalProperty}}`,\n}\n\nconst def: CodeKeywordDefinition & AddedKeywordDefinition = {\n  keyword: \"additionalProperties\",\n  type: [\"object\"],\n  schemaType: [\"boolean\", \"object\"],\n  allowUndefined: true,\n  trackErrors: true,\n  error,\n  code(cxt) {\n    const {gen, schema, parentSchema, data, errsCount, it} = cxt\n    /* istanbul ignore if */\n    if (!errsCount) throw new Error(\"ajv implementation error\")\n    const {allErrors, opts} = it\n    it.props = true\n    if (opts.removeAdditional !== \"all\" && alwaysValidSchema(it, schema)) return\n    const props = allSchemaProperties(parentSchema.properties)\n    const patProps = allSchemaProperties(parentSchema.patternProperties)\n    checkAdditionalProperties()\n    cxt.ok(_`${errsCount} === ${N.errors}`)\n\n    function checkAdditionalProperties(): void {\n      gen.forIn(\"key\", data, (key: Name) => {\n        if (!props.length && !patProps.length) additionalPropertyCode(key)\n        else gen.if(isAdditional(key), () => additionalPropertyCode(key))\n      })\n    }\n\n    function isAdditional(key: Name): Code {\n      let definedProp: Code\n      if (props.length > 8) {\n        // TODO maybe an option instead of hard-coded 8?\n        const propsSchema = schemaRefOrVal(it, parentSchema.properties, \"properties\")\n        definedProp = isOwnProperty(gen, propsSchema as Code, key)\n      } else if (props.length) {\n        definedProp = or(...props.map((p) => _`${key} === ${p}`))\n      } else {\n        definedProp = nil\n      }\n      if (patProps.length) {\n        definedProp = or(definedProp, ...patProps.map((p) => _`${usePattern(cxt, p)}.test(${key})`))\n      }\n      return not(definedProp)\n    }\n\n    function deleteAdditional(key: Name): void {\n      gen.code(_`delete ${data}[${key}]`)\n    }\n\n    function additionalPropertyCode(key: Name): void {\n      if (opts.removeAdditional === \"all\" || (opts.removeAdditional && schema === false)) {\n        deleteAdditional(key)\n        return\n      }\n\n      if (schema === false) {\n        cxt.setParams({additionalProperty: key})\n        cxt.error()\n        if (!allErrors) gen.break()\n        return\n      }\n\n      if (typeof schema == \"object\" && !alwaysValidSchema(it, schema)) {\n        const valid = gen.name(\"valid\")\n        if (opts.removeAdditional === \"failing\") {\n          applyAdditionalSchema(key, valid, false)\n          gen.if(not(valid), () => {\n            cxt.reset()\n            deleteAdditional(key)\n          })\n        } else {\n          applyAdditionalSchema(key, valid)\n          if (!allErrors) gen.if(not(valid), () => gen.break())\n        }\n      }\n    }\n\n    function applyAdditionalSchema(key: Name, valid: Name, errors?: false): void {\n      const subschema: SubschemaArgs = {\n        keyword: \"additionalProperties\",\n        dataProp: key,\n        dataPropType: Type.Str,\n      }\n      if (errors === false) {\n        Object.assign(subschema, {\n          compositeRule: true,\n          createErrors: false,\n          allErrors: false,\n        })\n      }\n      cxt.subschema(subschema, valid)\n    }\n  },\n}\n\nexport default def\n","import type {CodeKeywordDefinition} from \"../../types\"\nimport type {KeywordCxt} from \"../../compile/validate\"\nimport {checkStrictMode} from \"../../compile/util\"\n\nconst def: CodeKeywordDefinition = {\n  keyword: [\"then\", \"else\"],\n  schemaType: [\"object\", \"boolean\"],\n  code({keyword, parentSchema, it}: KeywordCxt) {\n    if (parentSchema.if === undefined) checkStrictMode(it, `\"${keyword}\" without \"if\" is ignored`)\n  },\n}\n\nexport default def\n","import type {CodeKeywordDefinition, ErrorNoParams, AnySchema} from \"../../types\"\nimport {validateUnion} from \"../code\"\n\nexport type AnyOfError = ErrorNoParams<\"anyOf\", AnySchema[]>\n\nconst def: CodeKeywordDefinition = {\n  keyword: \"anyOf\",\n  schemaType: \"array\",\n  trackErrors: true,\n  code: validateUnion,\n  error: {message: \"must match a schema in anyOf\"},\n}\n\nexport default def\n","'use strict'\n\nconst { normalizeIPv6, normalizeIPv4, removeDotSegments, recomposeAuthority, normalizeComponentEncoding } = require('./lib/utils')\nconst SCHEMES = require('./lib/schemes')\n\nfunction normalize (uri, options) {\n  if (typeof uri === 'string') {\n    uri = serialize(parse(uri, options), options)\n  } else if (typeof uri === 'object') {\n    uri = parse(serialize(uri, options), options)\n  }\n  return uri\n}\n\nfunction resolve (baseURI, relativeURI, options) {\n  const schemelessOptions = Object.assign({ scheme: 'null' }, options)\n  const resolved = resolveComponents(parse(baseURI, schemelessOptions), parse(relativeURI, schemelessOptions), schemelessOptions, true)\n  return serialize(resolved, { ...schemelessOptions, skipEscape: true })\n}\n\nfunction resolveComponents (base, relative, options, skipNormalization) {\n  const target = {}\n  if (!skipNormalization) {\n    base = parse(serialize(base, options), options) // normalize base components\n    relative = parse(serialize(relative, options), options) // normalize relative components\n  }\n  options = options || {}\n\n  if (!options.tolerant && relative.scheme) {\n    target.scheme = relative.scheme\n    // target.authority = relative.authority;\n    target.userinfo = relative.userinfo\n    target.host = relative.host\n    target.port = relative.port\n    target.path = removeDotSegments(relative.path || '')\n    target.query = relative.query\n  } else {\n    if (relative.userinfo !== undefined || relative.host !== undefined || relative.port !== undefined) {\n      // target.authority = relative.authority;\n      target.userinfo = relative.userinfo\n      target.host = relative.host\n      target.port = relative.port\n      target.path = removeDotSegments(relative.path || '')\n      target.query = relative.query\n    } else {\n      if (!relative.path) {\n        target.path = base.path\n        if (relative.query !== undefined) {\n          target.query = relative.query\n        } else {\n          target.query = base.query\n        }\n      } else {\n        if (relative.path.charAt(0) === '/') {\n          target.path = removeDotSegments(relative.path)\n        } else {\n          if ((base.userinfo !== undefined || base.host !== undefined || base.port !== undefined) && !base.path) {\n            target.path = '/' + relative.path\n          } else if (!base.path) {\n            target.path = relative.path\n          } else {\n            target.path = base.path.slice(0, base.path.lastIndexOf('/') + 1) + relative.path\n          }\n          target.path = removeDotSegments(target.path)\n        }\n        target.query = relative.query\n      }\n      // target.authority = base.authority;\n      target.userinfo = base.userinfo\n      target.host = base.host\n      target.port = base.port\n    }\n    target.scheme = base.scheme\n  }\n\n  target.fragment = relative.fragment\n\n  return target\n}\n\nfunction equal (uriA, uriB, options) {\n  if (typeof uriA === 'string') {\n    uriA = unescape(uriA)\n    uriA = serialize(normalizeComponentEncoding(parse(uriA, options), true), { ...options, skipEscape: true })\n  } else if (typeof uriA === 'object') {\n    uriA = serialize(normalizeComponentEncoding(uriA, true), { ...options, skipEscape: true })\n  }\n\n  if (typeof uriB === 'string') {\n    uriB = unescape(uriB)\n    uriB = serialize(normalizeComponentEncoding(parse(uriB, options), true), { ...options, skipEscape: true })\n  } else if (typeof uriB === 'object') {\n    uriB = serialize(normalizeComponentEncoding(uriB, true), { ...options, skipEscape: true })\n  }\n\n  return uriA.toLowerCase() === uriB.toLowerCase()\n}\n\nfunction serialize (cmpts, opts) {\n  const components = {\n    host: cmpts.host,\n    scheme: cmpts.scheme,\n    userinfo: cmpts.userinfo,\n    port: cmpts.port,\n    path: cmpts.path,\n    query: cmpts.query,\n    nid: cmpts.nid,\n    nss: cmpts.nss,\n    uuid: cmpts.uuid,\n    fragment: cmpts.fragment,\n    reference: cmpts.reference,\n    resourceName: cmpts.resourceName,\n    secure: cmpts.secure,\n    error: ''\n  }\n  const options = Object.assign({}, opts)\n  const uriTokens = []\n\n  // find scheme handler\n  const schemeHandler = SCHEMES[(options.scheme || components.scheme || '').toLowerCase()]\n\n  // perform scheme specific serialization\n  if (schemeHandler && schemeHandler.serialize) schemeHandler.serialize(components, options)\n\n  if (components.path !== undefined) {\n    if (!options.skipEscape) {\n      components.path = escape(components.path)\n\n      if (components.scheme !== undefined) {\n        components.path = components.path.split('%3A').join(':')\n      }\n    } else {\n      components.path = unescape(components.path)\n    }\n  }\n\n  if (options.reference !== 'suffix' && components.scheme) {\n    uriTokens.push(components.scheme, ':')\n  }\n\n  const authority = recomposeAuthority(components)\n  if (authority !== undefined) {\n    if (options.reference !== 'suffix') {\n      uriTokens.push('//')\n    }\n\n    uriTokens.push(authority)\n\n    if (components.path && components.path.charAt(0) !== '/') {\n      uriTokens.push('/')\n    }\n  }\n  if (components.path !== undefined) {\n    let s = components.path\n\n    if (!options.absolutePath && (!schemeHandler || !schemeHandler.absolutePath)) {\n      s = removeDotSegments(s)\n    }\n\n    if (authority === undefined) {\n      s = s.replace(/^\\/\\//u, '/%2F') // don't allow the path to start with \"//\"\n    }\n\n    uriTokens.push(s)\n  }\n\n  if (components.query !== undefined) {\n    uriTokens.push('?', components.query)\n  }\n\n  if (components.fragment !== undefined) {\n    uriTokens.push('#', components.fragment)\n  }\n  return uriTokens.join('')\n}\n\nconst hexLookUp = Array.from({ length: 127 }, (_v, k) => /[^!\"$&'()*+,\\-.;=_`a-z{}~]/u.test(String.fromCharCode(k)))\n\nfunction nonSimpleDomain (value) {\n  let code = 0\n  for (let i = 0, len = value.length; i < len; ++i) {\n    code = value.charCodeAt(i)\n    if (code > 126 || hexLookUp[code]) {\n      return true\n    }\n  }\n  return false\n}\n\nconst URI_PARSE = /^(?:([^#/:?]+):)?(?:\\/\\/((?:([^#/?@]*)@)?(\\[[^#/?\\]]+\\]|[^#/:?]*)(?::(\\d*))?))?([^#?]*)(?:\\?([^#]*))?(?:#((?:.|[\\n\\r])*))?/u\n\nfunction parse (uri, opts) {\n  const options = Object.assign({}, opts)\n  const parsed = {\n    scheme: undefined,\n    userinfo: undefined,\n    host: '',\n    port: undefined,\n    path: '',\n    query: undefined,\n    fragment: undefined\n  }\n  const gotEncoding = uri.indexOf('%') !== -1\n  let isIP = false\n  if (options.reference === 'suffix') uri = (options.scheme ? options.scheme + ':' : '') + '//' + uri\n\n  const matches = uri.match(URI_PARSE)\n\n  if (matches) {\n    // store each component\n    parsed.scheme = matches[1]\n    parsed.userinfo = matches[3]\n    parsed.host = matches[4]\n    parsed.port = parseInt(matches[5], 10)\n    parsed.path = matches[6] || ''\n    parsed.query = matches[7]\n    parsed.fragment = matches[8]\n\n    // fix port number\n    if (isNaN(parsed.port)) {\n      parsed.port = matches[5]\n    }\n    if (parsed.host) {\n      const ipv4result = normalizeIPv4(parsed.host)\n      if (ipv4result.isIPV4 === false) {\n        const ipv6result = normalizeIPv6(ipv4result.host)\n        parsed.host = ipv6result.host.toLowerCase()\n        isIP = ipv6result.isIPV6\n      } else {\n        parsed.host = ipv4result.host\n        isIP = true\n      }\n    }\n    if (parsed.scheme === undefined && parsed.userinfo === undefined && parsed.host === undefined && parsed.port === undefined && parsed.query === undefined && !parsed.path) {\n      parsed.reference = 'same-document'\n    } else if (parsed.scheme === undefined) {\n      parsed.reference = 'relative'\n    } else if (parsed.fragment === undefined) {\n      parsed.reference = 'absolute'\n    } else {\n      parsed.reference = 'uri'\n    }\n\n    // check for reference errors\n    if (options.reference && options.reference !== 'suffix' && options.reference !== parsed.reference) {\n      parsed.error = parsed.error || 'URI is not a ' + options.reference + ' reference.'\n    }\n\n    // find scheme handler\n    const schemeHandler = SCHEMES[(options.scheme || parsed.scheme || '').toLowerCase()]\n\n    // check if scheme can't handle IRIs\n    if (!options.unicodeSupport && (!schemeHandler || !schemeHandler.unicodeSupport)) {\n      // if host component is a domain name\n      if (parsed.host && (options.domainHost || (schemeHandler && schemeHandler.domainHost)) && isIP === false && nonSimpleDomain(parsed.host)) {\n        // convert Unicode IDN -> ASCII IDN\n        try {\n          parsed.host = URL.domainToASCII(parsed.host.toLowerCase())\n        } catch (e) {\n          parsed.error = parsed.error || \"Host's domain name can not be converted to ASCII: \" + e\n        }\n      }\n      // convert IRI -> URI\n    }\n\n    if (!schemeHandler || (schemeHandler && !schemeHandler.skipNormalize)) {\n      if (gotEncoding && parsed.scheme !== undefined) {\n        parsed.scheme = unescape(parsed.scheme)\n      }\n      if (gotEncoding && parsed.host !== undefined) {\n        parsed.host = unescape(parsed.host)\n      }\n      if (parsed.path) {\n        parsed.path = escape(unescape(parsed.path))\n      }\n      if (parsed.fragment) {\n        parsed.fragment = encodeURI(decodeURIComponent(parsed.fragment))\n      }\n    }\n\n    // perform scheme specific parsing\n    if (schemeHandler && schemeHandler.parse) {\n      schemeHandler.parse(parsed, options)\n    }\n  } else {\n    parsed.error = parsed.error || 'URI can not be parsed.'\n  }\n  return parsed\n}\n\nconst fastUri = {\n  SCHEMES,\n  normalize,\n  resolve,\n  resolveComponents,\n  equal,\n  serialize,\n  parse\n}\n\nmodule.exports = fastUri\nmodule.exports.default = fastUri\nmodule.exports.fastUri = fastUri\n","import type {CodeKeywordDefinition, ErrorObject, KeywordErrorDefinition} from \"../../types\"\nimport type {KeywordCxt} from \"../../compile/validate\"\nimport {\n  checkReportMissingProp,\n  checkMissingProp,\n  reportMissingProp,\n  propertyInData,\n  noPropertyInData,\n} from \"../code\"\nimport {_, str, nil, not, Name, Code} from \"../../compile/codegen\"\nimport {checkStrictMode} from \"../../compile/util\"\n\nexport type RequiredError = ErrorObject<\n  \"required\",\n  {missingProperty: string},\n  string[] | {$data: string}\n>\n\nconst error: KeywordErrorDefinition = {\n  message: ({params: {missingProperty}}) => str`must have required property '${missingProperty}'`,\n  params: ({params: {missingProperty}}) => _`{missingProperty: ${missingProperty}}`,\n}\n\nconst def: CodeKeywordDefinition = {\n  keyword: \"required\",\n  type: \"object\",\n  schemaType: \"array\",\n  $data: true,\n  error,\n  code(cxt: KeywordCxt) {\n    const {gen, schema, schemaCode, data, $data, it} = cxt\n    const {opts} = it\n    if (!$data && schema.length === 0) return\n    const useLoop = schema.length >= opts.loopRequired\n    if (it.allErrors) allErrorsMode()\n    else exitOnErrorMode()\n\n    if (opts.strictRequired) {\n      const props = cxt.parentSchema.properties\n      const {definedProperties} = cxt.it\n      for (const requiredKey of schema) {\n        if (props?.[requiredKey] === undefined && !definedProperties.has(requiredKey)) {\n          const schemaPath = it.schemaEnv.baseId + it.errSchemaPath\n          const msg = `required property \"${requiredKey}\" is not defined at \"${schemaPath}\" (strictRequired)`\n          checkStrictMode(it, msg, it.opts.strictRequired)\n        }\n      }\n    }\n\n    function allErrorsMode(): void {\n      if (useLoop || $data) {\n        cxt.block$data(nil, loopAllRequired)\n      } else {\n        for (const prop of schema) {\n          checkReportMissingProp(cxt, prop)\n        }\n      }\n    }\n\n    function exitOnErrorMode(): void {\n      const missing = gen.let(\"missing\")\n      if (useLoop || $data) {\n        const valid = gen.let(\"valid\", true)\n        cxt.block$data(valid, () => loopUntilMissing(missing, valid))\n        cxt.ok(valid)\n      } else {\n        gen.if(checkMissingProp(cxt, schema, missing))\n        reportMissingProp(cxt, missing)\n        gen.else()\n      }\n    }\n\n    function loopAllRequired(): void {\n      gen.forOf(\"prop\", schemaCode as Code, (prop) => {\n        cxt.setParams({missingProperty: prop})\n        gen.if(noPropertyInData(gen, data, prop, opts.ownProperties), () => cxt.error())\n      })\n    }\n\n    function loopUntilMissing(missing: Name, valid: Name): void {\n      cxt.setParams({missingProperty: missing})\n      gen.forOf(\n        missing,\n        schemaCode as Code,\n        () => {\n          gen.assign(valid, propertyInData(gen, data, missing, opts.ownProperties))\n          gen.if(not(valid), () => {\n            cxt.error()\n            gen.break()\n          })\n        },\n        nil\n      )\n    }\n  },\n}\n\nexport default def\n","import type {CodeKeywordDefinition} from \"../../types\"\nimport type {KeywordCxt} from \"../../compile/validate\"\nimport {allSchemaProperties, usePattern} from \"../code\"\nimport {_, not, Name} from \"../../compile/codegen\"\nimport {alwaysValidSchema, checkStrictMode} from \"../../compile/util\"\nimport {evaluatedPropsToName, Type} from \"../../compile/util\"\nimport {AnySchema} from \"../../types\"\n\nconst def: CodeKeywordDefinition = {\n  keyword: \"patternProperties\",\n  type: \"object\",\n  schemaType: \"object\",\n  code(cxt: KeywordCxt) {\n    const {gen, schema, data, parentSchema, it} = cxt\n    const {opts} = it\n    const patterns = allSchemaProperties(schema)\n    const alwaysValidPatterns = patterns.filter((p) =>\n      alwaysValidSchema(it, schema[p] as AnySchema)\n    )\n\n    if (\n      patterns.length === 0 ||\n      (alwaysValidPatterns.length === patterns.length &&\n        (!it.opts.unevaluated || it.props === true))\n    ) {\n      return\n    }\n\n    const checkProperties =\n      opts.strictSchema && !opts.allowMatchingProperties && parentSchema.properties\n    const valid = gen.name(\"valid\")\n    if (it.props !== true && !(it.props instanceof Name)) {\n      it.props = evaluatedPropsToName(gen, it.props)\n    }\n    const {props} = it\n    validatePatternProperties()\n\n    function validatePatternProperties(): void {\n      for (const pat of patterns) {\n        if (checkProperties) checkMatchingProperties(pat)\n        if (it.allErrors) {\n          validateProperties(pat)\n        } else {\n          gen.var(valid, true) // TODO var\n          validateProperties(pat)\n          gen.if(valid)\n        }\n      }\n    }\n\n    function checkMatchingProperties(pat: string): void {\n      for (const prop in checkProperties) {\n        if (new RegExp(pat).test(prop)) {\n          checkStrictMode(\n            it,\n            `property ${prop} matches pattern ${pat} (use allowMatchingProperties)`\n          )\n        }\n      }\n    }\n\n    function validateProperties(pat: string): void {\n      gen.forIn(\"key\", data, (key) => {\n        gen.if(_`${usePattern(cxt, pat)}.test(${key})`, () => {\n          const alwaysValid = alwaysValidPatterns.includes(pat)\n          if (!alwaysValid) {\n            cxt.subschema(\n              {\n                keyword: \"patternProperties\",\n                schemaProp: pat,\n                dataProp: key,\n                dataPropType: Type.Str,\n              },\n              valid\n            )\n          }\n\n          if (it.opts.unevaluated && props !== true) {\n            gen.assign(_`${props}[${key}]`, true)\n          } else if (!alwaysValid && !it.allErrors) {\n            // can short-circuit if `unevaluatedProperties` is not supported (opts.next === false)\n            // or if all properties were evaluated (props === true)\n            gen.if(not(valid), () => gen.break())\n          }\n        })\n      })\n    }\n  },\n}\n\nexport default def\n","import type {CodeKeywordDefinition, AnySchema} from \"../../types\"\nimport type {KeywordCxt} from \"../../compile/validate\"\nimport {alwaysValidSchema} from \"../../compile/util\"\n\nconst def: CodeKeywordDefinition = {\n  keyword: \"allOf\",\n  schemaType: \"array\",\n  code(cxt: KeywordCxt) {\n    const {gen, schema, it} = cxt\n    /* istanbul ignore if */\n    if (!Array.isArray(schema)) throw new Error(\"ajv implementation error\")\n    const valid = gen.name(\"valid\")\n    schema.forEach((sch: AnySchema, i: number) => {\n      if (alwaysValidSchema(it, sch)) return\n      const schCxt = cxt.subschema({keyword: \"allOf\", schemaProp: i}, valid)\n      cxt.ok(valid)\n      cxt.mergeEvaluated(schCxt)\n    })\n  },\n}\n\nexport default def\n","import type {CodeKeywordDefinition, ErrorObject, KeywordErrorDefinition} from \"../../types\"\nimport type {KeywordCxt} from \"../../compile/validate\"\nimport {_, str} from \"../../compile/codegen\"\n\nexport type MultipleOfError = ErrorObject<\n  \"multipleOf\",\n  {multipleOf: number},\n  number | {$data: string}\n>\n\nconst error: KeywordErrorDefinition = {\n  message: ({schemaCode}) => str`must be multiple of ${schemaCode}`,\n  params: ({schemaCode}) => _`{multipleOf: ${schemaCode}}`,\n}\n\nconst def: CodeKeywordDefinition = {\n  keyword: \"multipleOf\",\n  type: \"number\",\n  schemaType: \"number\",\n  $data: true,\n  error,\n  code(cxt: KeywordCxt) {\n    const {gen, data, schemaCode, it} = cxt\n    // const bdt = bad$DataType(schemaCode, <string>def.schemaType, $data)\n    const prec = it.opts.multipleOfPrecision\n    const res = gen.let(\"res\")\n    const invalid = prec\n      ? _`Math.abs(Math.round(${res}) - ${res}) > 1e-${prec}`\n      : _`${res} !== parseInt(${res})`\n    cxt.fail$data(_`(${schemaCode} === 0 || (${res} = ${data}/${schemaCode}, ${invalid}))`)\n  },\n}\n\nexport default def\n","import type Ajv from \"ajv\"\nimport type {\n  Plugin,\n  CodeKeywordDefinition,\n  KeywordErrorDefinition,\n  Code,\n  Name,\n  ErrorObject,\n} from \"ajv\"\nimport type {AddedFormat} from \"ajv/dist/types\"\nimport type {Rule} from \"ajv/dist/compile/rules\"\nimport {KeywordCxt} from \"ajv\"\nimport {_, str, or, getProperty, operators} from \"ajv/dist/compile/codegen\"\n\ntype Kwd = \"formatMaximum\" | \"formatMinimum\" | \"formatExclusiveMaximum\" | \"formatExclusiveMinimum\"\n\ntype Comparison = \"<=\" | \">=\" | \"<\" | \">\"\n\nconst ops = operators\n\nconst KWDs: {[K in Kwd]: {okStr: Comparison; ok: Code; fail: Code}} = {\n  formatMaximum: {okStr: \"<=\", ok: ops.LTE, fail: ops.GT},\n  formatMinimum: {okStr: \">=\", ok: ops.GTE, fail: ops.LT},\n  formatExclusiveMaximum: {okStr: \"<\", ok: ops.LT, fail: ops.GTE},\n  formatExclusiveMinimum: {okStr: \">\", ok: ops.GT, fail: ops.LTE},\n}\n\nexport type LimitFormatError = ErrorObject<Kwd, {limit: string; comparison: Comparison}>\n\nconst error: KeywordErrorDefinition = {\n  message: ({keyword, schemaCode}) => str`should be ${KWDs[keyword as Kwd].okStr} ${schemaCode}`,\n  params: ({keyword, schemaCode}) =>\n    _`{comparison: ${KWDs[keyword as Kwd].okStr}, limit: ${schemaCode}}`,\n}\n\nexport const formatLimitDefinition: CodeKeywordDefinition = {\n  keyword: Object.keys(KWDs),\n  type: \"string\",\n  schemaType: \"string\",\n  $data: true,\n  error,\n  code(cxt) {\n    const {gen, data, schemaCode, keyword, it} = cxt\n    const {opts, self} = it\n    if (!opts.validateFormats) return\n\n    const fCxt = new KeywordCxt(it, (self.RULES.all.format as Rule).definition, \"format\")\n    if (fCxt.$data) validate$DataFormat()\n    else validateFormat()\n\n    function validate$DataFormat(): void {\n      const fmts = gen.scopeValue(\"formats\", {\n        ref: self.formats,\n        code: opts.code.formats,\n      })\n      const fmt = gen.const(\"fmt\", _`${fmts}[${fCxt.schemaCode}]`)\n      cxt.fail$data(\n        or(\n          _`typeof ${fmt} != \"object\"`,\n          _`${fmt} instanceof RegExp`,\n          _`typeof ${fmt}.compare != \"function\"`,\n          compareCode(fmt)\n        )\n      )\n    }\n\n    function validateFormat(): void {\n      const format = fCxt.schema as string\n      const fmtDef: AddedFormat | undefined = self.formats[format]\n      if (!fmtDef || fmtDef === true) return\n      if (\n        typeof fmtDef != \"object\" ||\n        fmtDef instanceof RegExp ||\n        typeof fmtDef.compare != \"function\"\n      ) {\n        throw new Error(`\"${keyword}\": format \"${format}\" does not define \"compare\" function`)\n      }\n      const fmt = gen.scopeValue(\"formats\", {\n        key: format,\n        ref: fmtDef,\n        code: opts.code.formats ? _`${opts.code.formats}${getProperty(format)}` : undefined,\n      })\n\n      cxt.fail$data(compareCode(fmt))\n    }\n\n    function compareCode(fmt: Name): Code {\n      return _`${fmt}.compare(${data}, ${schemaCode}) ${KWDs[keyword as Kwd].fail} 0`\n    }\n  },\n  dependencies: [\"format\"],\n}\n\nconst formatLimitPlugin: Plugin<undefined> = (ajv: Ajv): Ajv => {\n  ajv.addKeyword(formatLimitDefinition)\n  return ajv\n}\n\nexport default formatLimitPlugin\n","import type {AnySchema, EvaluatedProperties, EvaluatedItems} from \"../types\"\nimport type {SchemaCxt, SchemaObjCxt} from \".\"\nimport {_, getProperty, Code, Name, CodeGen} from \"./codegen\"\nimport {_Code} from \"./codegen/code\"\nimport type {Rule, ValidationRules} from \"./rules\"\n\n// TODO refactor to use Set\nexport function toHash<T extends string = string>(arr: T[]): {[K in T]?: true} {\n  const hash: {[K in T]?: true} = {}\n  for (const item of arr) hash[item] = true\n  return hash\n}\n\nexport function alwaysValidSchema(it: SchemaCxt, schema: AnySchema): boolean | void {\n  if (typeof schema == \"boolean\") return schema\n  if (Object.keys(schema).length === 0) return true\n  checkUnknownRules(it, schema)\n  return !schemaHasRules(schema, it.self.RULES.all)\n}\n\nexport function checkUnknownRules(it: SchemaCxt, schema: AnySchema = it.schema): void {\n  const {opts, self} = it\n  if (!opts.strictSchema) return\n  if (typeof schema === \"boolean\") return\n  const rules = self.RULES.keywords\n  for (const key in schema) {\n    if (!rules[key]) checkStrictMode(it, `unknown keyword: \"${key}\"`)\n  }\n}\n\nexport function schemaHasRules(\n  schema: AnySchema,\n  rules: {[Key in string]?: boolean | Rule}\n): boolean {\n  if (typeof schema == \"boolean\") return !schema\n  for (const key in schema) if (rules[key]) return true\n  return false\n}\n\nexport function schemaHasRulesButRef(schema: AnySchema, RULES: ValidationRules): boolean {\n  if (typeof schema == \"boolean\") return !schema\n  for (const key in schema) if (key !== \"$ref\" && RULES.all[key]) return true\n  return false\n}\n\nexport function schemaRefOrVal(\n  {topSchemaRef, schemaPath}: SchemaObjCxt,\n  schema: unknown,\n  keyword: string,\n  $data?: string | false\n): Code | number | boolean {\n  if (!$data) {\n    if (typeof schema == \"number\" || typeof schema == \"boolean\") return schema\n    if (typeof schema == \"string\") return _`${schema}`\n  }\n  return _`${topSchemaRef}${schemaPath}${getProperty(keyword)}`\n}\n\nexport function unescapeFragment(str: string): string {\n  return unescapeJsonPointer(decodeURIComponent(str))\n}\n\nexport function escapeFragment(str: string | number): string {\n  return encodeURIComponent(escapeJsonPointer(str))\n}\n\nexport function escapeJsonPointer(str: string | number): string {\n  if (typeof str == \"number\") return `${str}`\n  return str.replace(/~/g, \"~0\").replace(/\\//g, \"~1\")\n}\n\nexport function unescapeJsonPointer(str: string): string {\n  return str.replace(/~1/g, \"/\").replace(/~0/g, \"~\")\n}\n\nexport function eachItem<T>(xs: T | T[], f: (x: T) => void): void {\n  if (Array.isArray(xs)) {\n    for (const x of xs) f(x)\n  } else {\n    f(xs)\n  }\n}\n\ntype SomeEvaluated = EvaluatedProperties | EvaluatedItems\n\ntype MergeEvaluatedFunc<T extends SomeEvaluated> = (\n  gen: CodeGen,\n  from: Name | T,\n  to: Name | Exclude<T, true> | undefined,\n  toName?: typeof Name\n) => Name | T\n\ninterface MakeMergeFuncArgs<T extends SomeEvaluated> {\n  mergeNames: (gen: CodeGen, from: Name, to: Name) => void\n  mergeToName: (gen: CodeGen, from: T, to: Name) => void\n  mergeValues: (from: T, to: Exclude<T, true>) => T\n  resultToName: (gen: CodeGen, res?: T) => Name\n}\n\nfunction makeMergeEvaluated<T extends SomeEvaluated>({\n  mergeNames,\n  mergeToName,\n  mergeValues,\n  resultToName,\n}: MakeMergeFuncArgs<T>): MergeEvaluatedFunc<T> {\n  return (gen, from, to, toName) => {\n    const res =\n      to === undefined\n        ? from\n        : to instanceof Name\n        ? (from instanceof Name ? mergeNames(gen, from, to) : mergeToName(gen, from, to), to)\n        : from instanceof Name\n        ? (mergeToName(gen, to, from), from)\n        : mergeValues(from, to)\n    return toName === Name && !(res instanceof Name) ? resultToName(gen, res) : res\n  }\n}\n\ninterface MergeEvaluated {\n  props: MergeEvaluatedFunc<EvaluatedProperties>\n  items: MergeEvaluatedFunc<EvaluatedItems>\n}\n\nexport const mergeEvaluated: MergeEvaluated = {\n  props: makeMergeEvaluated({\n    mergeNames: (gen, from, to) =>\n      gen.if(_`${to} !== true && ${from} !== undefined`, () => {\n        gen.if(\n          _`${from} === true`,\n          () => gen.assign(to, true),\n          () => gen.assign(to, _`${to} || {}`).code(_`Object.assign(${to}, ${from})`)\n        )\n      }),\n    mergeToName: (gen, from, to) =>\n      gen.if(_`${to} !== true`, () => {\n        if (from === true) {\n          gen.assign(to, true)\n        } else {\n          gen.assign(to, _`${to} || {}`)\n          setEvaluated(gen, to, from)\n        }\n      }),\n    mergeValues: (from, to) => (from === true ? true : {...from, ...to}),\n    resultToName: evaluatedPropsToName,\n  }),\n  items: makeMergeEvaluated({\n    mergeNames: (gen, from, to) =>\n      gen.if(_`${to} !== true && ${from} !== undefined`, () =>\n        gen.assign(to, _`${from} === true ? true : ${to} > ${from} ? ${to} : ${from}`)\n      ),\n    mergeToName: (gen, from, to) =>\n      gen.if(_`${to} !== true`, () =>\n        gen.assign(to, from === true ? true : _`${to} > ${from} ? ${to} : ${from}`)\n      ),\n    mergeValues: (from, to) => (from === true ? true : Math.max(from, to)),\n    resultToName: (gen, items) => gen.var(\"items\", items),\n  }),\n}\n\nexport function evaluatedPropsToName(gen: CodeGen, ps?: EvaluatedProperties): Name {\n  if (ps === true) return gen.var(\"props\", true)\n  const props = gen.var(\"props\", _`{}`)\n  if (ps !== undefined) setEvaluated(gen, props, ps)\n  return props\n}\n\nexport function setEvaluated(gen: CodeGen, props: Name, ps: {[K in string]?: true}): void {\n  Object.keys(ps).forEach((p) => gen.assign(_`${props}${getProperty(p)}`, true))\n}\n\nconst snippets: {[S in string]?: _Code} = {}\n\nexport function useFunc(gen: CodeGen, f: {code: string}): Name {\n  return gen.scopeValue(\"func\", {\n    ref: f,\n    code: snippets[f.code] || (snippets[f.code] = new _Code(f.code)),\n  })\n}\n\nexport enum Type {\n  Num,\n  Str,\n}\n\nexport function getErrorPath(\n  dataProp: Name | string | number,\n  dataPropType?: Type,\n  jsPropertySyntax?: boolean\n): Code | string {\n  // let path\n  if (dataProp instanceof Name) {\n    const isNumber = dataPropType === Type.Num\n    return jsPropertySyntax\n      ? isNumber\n        ? _`\"[\" + ${dataProp} + \"]\"`\n        : _`\"['\" + ${dataProp} + \"']\"`\n      : isNumber\n      ? _`\"/\" + ${dataProp}`\n      : _`\"/\" + ${dataProp}.replace(/~/g, \"~0\").replace(/\\\\//g, \"~1\")` // TODO maybe use global escapePointer\n  }\n  return jsPropertySyntax ? getProperty(dataProp).toString() : \"/\" + escapeJsonPointer(dataProp)\n}\n\nexport function checkStrictMode(\n  it: SchemaCxt,\n  msg: string,\n  mode: boolean | \"log\" = it.opts.strictSchema\n): void {\n  if (!mode) return\n  msg = `strict mode: ${msg}`\n  if (mode === true) throw new Error(msg)\n  it.self.logger.warn(msg)\n}\n","import type {CodeKeywordDefinition, AnySchemaObject, KeywordErrorDefinition} from \"../../types\"\nimport type {KeywordCxt} from \"../../compile/validate\"\nimport {_, getProperty, Name} from \"../../compile/codegen\"\nimport {DiscrError, DiscrErrorObj} from \"../discriminator/types\"\nimport {resolveRef, SchemaEnv} from \"../../compile\"\nimport MissingRefError from \"../../compile/ref_error\"\nimport {schemaHasRulesButRef} from \"../../compile/util\"\n\nexport type DiscriminatorError = DiscrErrorObj<DiscrError.Tag> | DiscrErrorObj<DiscrError.Mapping>\n\nconst error: KeywordErrorDefinition = {\n  message: ({params: {discrError, tagName}}) =>\n    discrError === DiscrError.Tag\n      ? `tag \"${tagName}\" must be string`\n      : `value of tag \"${tagName}\" must be in oneOf`,\n  params: ({params: {discrError, tag, tagName}}) =>\n    _`{error: ${discrError}, tag: ${tagName}, tagValue: ${tag}}`,\n}\n\nconst def: CodeKeywordDefinition = {\n  keyword: \"discriminator\",\n  type: \"object\",\n  schemaType: \"object\",\n  error,\n  code(cxt: KeywordCxt) {\n    const {gen, data, schema, parentSchema, it} = cxt\n    const {oneOf} = parentSchema\n    if (!it.opts.discriminator) {\n      throw new Error(\"discriminator: requires discriminator option\")\n    }\n    const tagName = schema.propertyName\n    if (typeof tagName != \"string\") throw new Error(\"discriminator: requires propertyName\")\n    if (schema.mapping) throw new Error(\"discriminator: mapping is not supported\")\n    if (!oneOf) throw new Error(\"discriminator: requires oneOf keyword\")\n    const valid = gen.let(\"valid\", false)\n    const tag = gen.const(\"tag\", _`${data}${getProperty(tagName)}`)\n    gen.if(\n      _`typeof ${tag} == \"string\"`,\n      () => validateMapping(),\n      () => cxt.error(false, {discrError: DiscrError.Tag, tag, tagName})\n    )\n    cxt.ok(valid)\n\n    function validateMapping(): void {\n      const mapping = getMapping()\n      gen.if(false)\n      for (const tagValue in mapping) {\n        gen.elseIf(_`${tag} === ${tagValue}`)\n        gen.assign(valid, applyTagSchema(mapping[tagValue]))\n      }\n      gen.else()\n      cxt.error(false, {discrError: DiscrError.Mapping, tag, tagName})\n      gen.endIf()\n    }\n\n    function applyTagSchema(schemaProp?: number): Name {\n      const _valid = gen.name(\"valid\")\n      const schCxt = cxt.subschema({keyword: \"oneOf\", schemaProp}, _valid)\n      cxt.mergeEvaluated(schCxt, Name)\n      return _valid\n    }\n\n    function getMapping(): {[T in string]?: number} {\n      const oneOfMapping: {[T in string]?: number} = {}\n      const topRequired = hasRequired(parentSchema)\n      let tagRequired = true\n      for (let i = 0; i < oneOf.length; i++) {\n        let sch = oneOf[i]\n        if (sch?.$ref && !schemaHasRulesButRef(sch, it.self.RULES)) {\n          const ref = sch.$ref\n          sch = resolveRef.call(it.self, it.schemaEnv.root, it.baseId, ref)\n          if (sch instanceof SchemaEnv) sch = sch.schema\n          if (sch === undefined) throw new MissingRefError(it.opts.uriResolver, it.baseId, ref)\n        }\n        const propSch = sch?.properties?.[tagName]\n        if (typeof propSch != \"object\") {\n          throw new Error(\n            `discriminator: oneOf subschemas (or referenced schemas) must have \"properties/${tagName}\"`\n          )\n        }\n        tagRequired = tagRequired && (topRequired || hasRequired(sch))\n        addMappings(propSch, i)\n      }\n      if (!tagRequired) throw new Error(`discriminator: \"${tagName}\" must be required`)\n      return oneOfMapping\n\n      function hasRequired({required}: AnySchemaObject): boolean {\n        return Array.isArray(required) && required.includes(tagName)\n      }\n\n      function addMappings(sch: AnySchemaObject, i: number): void {\n        if (sch.const) {\n          addMapping(sch.const, i)\n        } else if (sch.enum) {\n          for (const tagValue of sch.enum) {\n            addMapping(tagValue, i)\n          }\n        } else {\n          throw new Error(`discriminator: \"properties/${tagName}\" must have \"const\" or \"enum\"`)\n        }\n      }\n\n      function addMapping(tagValue: unknown, i: number): void {\n        if (typeof tagValue != \"string\" || tagValue in oneOfMapping) {\n          throw new Error(`discriminator: \"${tagName}\" values must be unique strings`)\n        }\n        oneOfMapping[tagValue] = i\n      }\n    }\n  },\n}\n\nexport default def\n","import {Name} from \"./codegen\"\n\nconst names = {\n  // validation function arguments\n  data: new Name(\"data\"), // data passed to validation function\n  // args passed from referencing schema\n  valCxt: new Name(\"valCxt\"), // validation/data context - should not be used directly, it is destructured to the names below\n  instancePath: new Name(\"instancePath\"),\n  parentData: new Name(\"parentData\"),\n  parentDataProperty: new Name(\"parentDataProperty\"),\n  rootData: new Name(\"rootData\"), // root data - same as the data passed to the first/top validation function\n  dynamicAnchors: new Name(\"dynamicAnchors\"), // used to support recursiveRef and dynamicRef\n  // function scoped variables\n  vErrors: new Name(\"vErrors\"), // null or array of validation errors\n  errors: new Name(\"errors\"), // counter of validation errors\n  this: new Name(\"this\"),\n  // \"globals\"\n  self: new Name(\"self\"),\n  scope: new Name(\"scope\"),\n  // JTD serialize/parse name for JSON string and position\n  json: new Name(\"json\"),\n  jsonPos: new Name(\"jsonPos\"),\n  jsonLen: new Name(\"jsonLen\"),\n  jsonPart: new Name(\"jsonPart\"),\n}\n\nexport default names\n","import type {CodeKeywordDefinition, ErrorObject, KeywordErrorDefinition} from \"../../types\"\nimport type {KeywordCxt} from \"../../compile/validate\"\nimport {usePattern} from \"../code\"\nimport {_, str} from \"../../compile/codegen\"\n\nexport type PatternError = ErrorObject<\"pattern\", {pattern: string}, string | {$data: string}>\n\nconst error: KeywordErrorDefinition = {\n  message: ({schemaCode}) => str`must match pattern \"${schemaCode}\"`,\n  params: ({schemaCode}) => _`{pattern: ${schemaCode}}`,\n}\n\nconst def: CodeKeywordDefinition = {\n  keyword: \"pattern\",\n  type: \"string\",\n  schemaType: \"string\",\n  $data: true,\n  error,\n  code(cxt: KeywordCxt) {\n    const {data, $data, schema, schemaCode, it} = cxt\n    // TODO regexp should be wrapped in try/catchs\n    const u = it.opts.unicodeRegExp ? \"u\" : \"\"\n    const regExp = $data ? _`(new RegExp(${schemaCode}, ${u}))` : usePattern(cxt, schema)\n    cxt.fail$data(_`!${regExp}.test(${data})`)\n  },\n}\n\nexport default def\n","import type {ErrorObject, Vocabulary} from \"../../types\"\nimport limitNumber, {LimitNumberError} from \"./limitNumber\"\nimport multipleOf, {MultipleOfError} from \"./multipleOf\"\nimport limitLength from \"./limitLength\"\nimport pattern, {PatternError} from \"./pattern\"\nimport limitProperties from \"./limitProperties\"\nimport required, {RequiredError} from \"./required\"\nimport limitItems from \"./limitItems\"\nimport uniqueItems, {UniqueItemsError} from \"./uniqueItems\"\nimport constKeyword, {ConstError} from \"./const\"\nimport enumKeyword, {EnumError} from \"./enum\"\n\nconst validation: Vocabulary = [\n  // number\n  limitNumber,\n  multipleOf,\n  // string\n  limitLength,\n  pattern,\n  // object\n  limitProperties,\n  required,\n  // array\n  limitItems,\n  uniqueItems,\n  // any\n  {keyword: \"type\", schemaType: [\"string\", \"array\"]},\n  {keyword: \"nullable\", schemaType: \"boolean\"},\n  constKeyword,\n  enumKeyword,\n]\n\nexport default validation\n\ntype LimitError = ErrorObject<\n  \"maxItems\" | \"minItems\" | \"minProperties\" | \"maxProperties\" | \"minLength\" | \"maxLength\",\n  {limit: number},\n  number | {$data: string}\n>\n\nexport type ValidationKeywordError =\n  | LimitError\n  | LimitNumberError\n  | MultipleOfError\n  | PatternError\n  | RequiredError\n  | UniqueItemsError\n  | ConstError\n  | EnumError\n","import type {\n  CodeKeywordDefinition,\n  ErrorObject,\n  KeywordErrorDefinition,\n  AnySchema,\n} from \"../../types\"\nimport type {SchemaObjCxt} from \"../../compile\"\nimport type {KeywordCxt} from \"../../compile/validate\"\nimport {_, str, not, Name} from \"../../compile/codegen\"\nimport {alwaysValidSchema, checkStrictMode} from \"../../compile/util\"\n\nexport type IfKeywordError = ErrorObject<\"if\", {failingKeyword: string}, AnySchema>\n\nconst error: KeywordErrorDefinition = {\n  message: ({params}) => str`must match \"${params.ifClause}\" schema`,\n  params: ({params}) => _`{failingKeyword: ${params.ifClause}}`,\n}\n\nconst def: CodeKeywordDefinition = {\n  keyword: \"if\",\n  schemaType: [\"object\", \"boolean\"],\n  trackErrors: true,\n  error,\n  code(cxt: KeywordCxt) {\n    const {gen, parentSchema, it} = cxt\n    if (parentSchema.then === undefined && parentSchema.else === undefined) {\n      checkStrictMode(it, '\"if\" without \"then\" and \"else\" is ignored')\n    }\n    const hasThen = hasSchema(it, \"then\")\n    const hasElse = hasSchema(it, \"else\")\n    if (!hasThen && !hasElse) return\n\n    const valid = gen.let(\"valid\", true)\n    const schValid = gen.name(\"_valid\")\n    validateIf()\n    cxt.reset()\n\n    if (hasThen && hasElse) {\n      const ifClause = gen.let(\"ifClause\")\n      cxt.setParams({ifClause})\n      gen.if(schValid, validateClause(\"then\", ifClause), validateClause(\"else\", ifClause))\n    } else if (hasThen) {\n      gen.if(schValid, validateClause(\"then\"))\n    } else {\n      gen.if(not(schValid), validateClause(\"else\"))\n    }\n\n    cxt.pass(valid, () => cxt.error(true))\n\n    function validateIf(): void {\n      const schCxt = cxt.subschema(\n        {\n          keyword: \"if\",\n          compositeRule: true,\n          createErrors: false,\n          allErrors: false,\n        },\n        schValid\n      )\n      cxt.mergeEvaluated(schCxt)\n    }\n\n    function validateClause(keyword: string, ifClause?: Name): () => void {\n      return () => {\n        const schCxt = cxt.subschema({keyword}, schValid)\n        gen.assign(valid, schValid)\n        cxt.mergeValidEvaluated(schCxt, valid)\n        if (ifClause) gen.assign(ifClause, _`${keyword}`)\n        else cxt.setParams({ifClause: keyword})\n      }\n    }\n  },\n}\n\nfunction hasSchema(it: SchemaObjCxt, keyword: string): boolean {\n  const schema = it.schema[keyword]\n  return schema !== undefined && !alwaysValidSchema(it, schema)\n}\n\nexport default def\n","import type {\n  CodeKeywordDefinition,\n  ErrorObject,\n  KeywordErrorDefinition,\n  AnySchema,\n} from \"../../types\"\nimport type {KeywordCxt} from \"../../compile/validate\"\nimport {_, Name} from \"../../compile/codegen\"\nimport {alwaysValidSchema} from \"../../compile/util\"\nimport {SchemaCxt} from \"../../compile\"\n\nexport type OneOfError = ErrorObject<\n  \"oneOf\",\n  {passingSchemas: [number, number] | null},\n  AnySchema[]\n>\n\nconst error: KeywordErrorDefinition = {\n  message: \"must match exactly one schema in oneOf\",\n  params: ({params}) => _`{passingSchemas: ${params.passing}}`,\n}\n\nconst def: CodeKeywordDefinition = {\n  keyword: \"oneOf\",\n  schemaType: \"array\",\n  trackErrors: true,\n  error,\n  code(cxt: KeywordCxt) {\n    const {gen, schema, parentSchema, it} = cxt\n    /* istanbul ignore if */\n    if (!Array.isArray(schema)) throw new Error(\"ajv implementation error\")\n    if (it.opts.discriminator && parentSchema.discriminator) return\n    const schArr: AnySchema[] = schema\n    const valid = gen.let(\"valid\", false)\n    const passing = gen.let(\"passing\", null)\n    const schValid = gen.name(\"_valid\")\n    cxt.setParams({passing})\n    // TODO possibly fail straight away (with warning or exception) if there are two empty always valid schemas\n\n    gen.block(validateOneOf)\n\n    cxt.result(\n      valid,\n      () => cxt.reset(),\n      () => cxt.error(true)\n    )\n\n    function validateOneOf(): void {\n      schArr.forEach((sch: AnySchema, i: number) => {\n        let schCxt: SchemaCxt | undefined\n        if (alwaysValidSchema(it, sch)) {\n          gen.var(schValid, true)\n        } else {\n          schCxt = cxt.subschema(\n            {\n              keyword: \"oneOf\",\n              schemaProp: i,\n              compositeRule: true,\n            },\n            schValid\n          )\n        }\n\n        if (i > 0) {\n          gen\n            .if(_`${schValid} && ${valid}`)\n            .assign(valid, false)\n            .assign(passing, _`[${passing}, ${i}]`)\n            .else()\n        }\n\n        gen.if(schValid, () => {\n          gen.assign(valid, true)\n          gen.assign(passing, i)\n          if (schCxt) cxt.mergeEvaluated(schCxt, Name)\n        })\n      })\n    }\n  },\n}\n\nexport default def\n","import type {Vocabulary} from \"../../types\"\nimport formatKeyword from \"./format\"\n\nconst format: Vocabulary = [formatKeyword]\n\nexport default format\n","import type {CodeKeywordDefinition, ErrorNoParams, AnySchema} from \"../../types\"\nimport type {KeywordCxt} from \"../../compile/validate\"\nimport {alwaysValidSchema} from \"../../compile/util\"\n\nexport type NotKeywordError = ErrorNoParams<\"not\", AnySchema>\n\nconst def: CodeKeywordDefinition = {\n  keyword: \"not\",\n  schemaType: [\"object\", \"boolean\"],\n  trackErrors: true,\n  code(cxt: KeywordCxt) {\n    const {gen, schema, it} = cxt\n    if (alwaysValidSchema(it, schema)) {\n      cxt.fail()\n      return\n    }\n\n    const valid = gen.name(\"valid\")\n    cxt.subschema(\n      {\n        keyword: \"not\",\n        compositeRule: true,\n        createErrors: false,\n        allErrors: false,\n      },\n      valid\n    )\n\n    cxt.failResult(\n      valid,\n      () => cxt.reset(),\n      () => cxt.error()\n    )\n  },\n  error: {message: \"must NOT be valid\"},\n}\n\nexport default def\n","import type {Vocabulary} from \"../types\"\nimport coreVocabulary from \"./core\"\nimport validationVocabulary from \"./validation\"\nimport getApplicatorVocabulary from \"./applicator\"\nimport formatVocabulary from \"./format\"\nimport {metadataVocabulary, contentVocabulary} from \"./metadata\"\n\nconst draft7Vocabularies: Vocabulary[] = [\n  coreVocabulary,\n  validationVocabulary,\n  getApplicatorVocabulary(),\n  formatVocabulary,\n  metadataVocabulary,\n  contentVocabulary,\n]\n\nexport default draft7Vocabularies\n"],"names":["shouldUseGroup","schema","group","rules","some","rule","shouldUseRule","undefined","keyword","_a","definition","implements","kwd","exports","_ref","type","self","RULES","types","module","equal","a","b","constructor","length","i","keys","Array","isArray","RegExp","source","flags","valueOf","Object","prototype","toString","hasOwnProperty","call","key","codegen_1","require","util_1","assignDefault","it","prop","defaultValue","gen","compositeRule","data","opts","childData","_","getProperty","checkStrictMode","condition","useDefaults","if","stringify","ty","properties","items","default","forEach","sch","code_1","def","schemaType","before","code","cxt","validateTuple","alwaysValidSchema","ok","validateArray","extraItems","schArr","arguments","parentSchema","errSchemaPath","l","fullTuple","minItems","maxItems","strictTuples","msg","checkStrictTuple","unevaluated","mergeEvaluated","valid","name","len","const","subschema","schemaProp","dataProp","HEX","IPV4_REG","normalizeIPv4","host","findToken","isIPV4","matches","match","address","stripLeadingZeros","stringArrayToHexStripped","input","keepZero","acc","strip","c","normalizeIPv6","isIPV6","ipv6","tokenCount","output","error","zone","buffer","isZone","endipv6Encountered","endIpv6","consume","hex","push","cursor","join","getIPV6","newHost","escapedHost","str","token","out","skip","ind","RDS1","RDS2","RDS3","RDS5","recomposeAuthority","components","uriTokens","userinfo","unescape","ipV4res","ipV6res","port","String","normalizeComponentEncoding","esc","func","escape","scheme","path","query","fragment","removeDotSegments","replace","pop","im","Error","s","slice","schemaPath","topSchemaRef","escapeFragment","_ref2","dataPropType","dpType","dataTypes","propertyName","errorPath","dataPathArr","dataContextProps","let","getErrorPath","jsPropertySyntax","parentDataProperty","Name","_nextData","dataLevel","definedProperties","Set","parentData","dataNames","_ref3","jtdDiscriminator","jtdMetadata","createErrors","allErrors","ops","operators","KWDs","maximum","okStr","LTE","fail","GT","minimum","GTE","LT","exclusiveMaximum","exclusiveMinimum","message","schemaCode","params","$data","fail$data","ref_error_1","names_1","compile_1","$ref","baseId","schemaEnv","env","validateName","root","callRef","$async","rootName","scopeValue","ref","callRootRef","schOrEnv","resolveRef","uriResolver","SchemaEnv","v","getValidate","callValidate","schName","schCxt","nil","inlineRefSchema","validate","passCxt","passContext","this","addErrorsFrom","errs","assign","vErrors","errors","addEvaluatedFrom","schEvaluated","evaluated","props","dynamicProps","var","dynamicItems","try","callValidateCode","e","ValidationError","throw","callAsyncRef","result","id_1","ref_1","core","DiscrError","ruleType","validateFormats","fmts","formats","fDef","fType","format","or","strictSchema","callFormat","validData","invalidFmt","validate$DataFormat","formatDef","logger","warn","unknownMsg","unknownFormat","fmtType","fmtRef","fmtDef","regexpCode","fmt","getFormat","pass","async","validCondition","validateFormat","ucs2length","value","pos","charCodeAt","super","ajv","validation","validate_1","enumerable","get","KeywordCxt","CodeGen","validation_error_1","rules_1","codegen_2","resolve_1","dataType_1","$dataRefSchema","uri_1","defaultRegExp","META_IGNORE_OPTIONS","EXT_SCOPE_NAMES","removedOptions","errorDataPath","nullable","jsonPointers","extendRefs","missingRefs","processCode","sourceCode","strictDefaults","strictKeywords","uniqueItems","unknownFormats","cache","serialize","ajvErrors","deprecatedOptions","ignoreKeywordsWithRef","unicode","requiredOptions","o","strict","_optz","optimize","regExp","_c","_b","_d","_f","_e","strictNumbers","_h","_g","strictTypes","_k","_j","_m","_l","strictRequired","_p","_o","loopRequired","_q","loopEnum","_r","meta","_s","messages","_t","inlineRefs","_u","schemaId","_v","addUsedSchema","_w","validateSchema","_x","_y","unicodeRegExp","_z","int32range","_0","Ajv","schemas","refs","_compilations","_loading","_cache","Map","es5","lines","scope","ValueScope","prefixes","noLogs","console","log","getLogger","formatOpt","getRules","checkOptions","_metaOpts","getMetaSchemaOptions","addInitialFormats","_addVocabularies","_addDefaultMetaSchema","keywords","addInitialKeywords","addMetaSchema","addInitialSchemas","addKeyword","_dataRefSchema","id","$id","defaultMeta","schemaKeyRef","getSchema","compile","_meta","_addSchema","_compileSchemaEnv","compileAsync","loadSchema","runCompileAsync","_schema","loadMetaSchema","$schema","_compileAsync","checkLoaded","loadMissingSchema","missingSchema","missingRef","_loadSchema","addSchema","p","_validateSchema","normalizeId","_checkUnique","throwOrLogError","errorsText","keyRef","getSchEnv","resolveSchema","removeSchema","_removeAllSchemas","clear","delete","cacheKey","addVocabulary","definitions","kwdOrDef","checkKeyword","eachItem","addRule","keywordMetaschema","getJSONTypes","k","t","getKeyword","all","removeKeyword","findIndex","splice","addFormat","separator","dataVar","map","instancePath","reduce","text","$dataMetaSchema","metaSchema","keywordsJsonPointers","JSON","parse","jsonPointer","segments","split","seg","schemaOrData","regex","test","jtd","localRefs","getSchemaRefs","set","startsWith","_compileMetaSchema","compileSchema","currentOpts","checkOpts","options","opt","optsSchemas","defs","metaOpts","MissingRefError","KEYWORD_NAME","dataType","post","ruleGroup","find","addBeforeRule","_rule","$dataRef","anyOf","ucs2length_1","comp","op","useFunc","dynamicAnchors","_sch","getCompilingSchema","rootId","getFullPath","ownProperties","_ValidationError","scopeName","schemaCxt","add","validateFunctionCode","validateCode","scopeRefs","process","Function","makeValidate","scopeValues","_values","inlineOrCompile","inlineRef","schEnv","sameSchemaEnv","s1","s2","resolve","refPath","_getFullPath","getJsonPointer","schOrRef","schId","resolveUrl","schOrFunc","PREVENT_SCOPE_CHANGE","parsedRef","part","partSchema","unescapeFragment","has","schemaHasRulesButRef","jsonTypes","x","groups","number","string","array","object","integer","boolean","null","ValueError","UsedValueState","Scope","parent","_names","_prefixes","_parent","toName","nameOrPrefix","prefix","_newName","_nameGroup","index","ValueScopeName","nameStr","setValue","property","itemIndex","scopePath","line","_scope","_n","valueKey","vs","_name","getValue","keyOrRef","values","_reduceValues","scopeCode","usedValues","getCode","valueCode","nameSet","Started","varKinds","Completed","scope_1","code_2","strConcat","scope_2","_Code","EQ","NEQ","NOT","OR","AND","ADD","Node","optimizeNodes","optimizeNames","_constants","Def","varKind","rhs","render","names","constants","optimizeExpr","_CodeOrName","Assign","lhs","sideEffects","addExprNames","AssignOp","Label","label","_ref4","Break","_ref5","Throw","_ref6","AnyCode","_ref7","ParentNode","nodes","n","subtractNames","addNames","BlockNode","Root","Else","kind","If","else","cond","ns","not","For","ForLoop","iteration","ForRange","from","to","ForIter","loop","iterable","Func","args","Return","Try","catch","finally","Catch","Finally","expr","replaceName","_items","par","extScope","_blockStarts","_extScope","_nodes","_root","prefixOrName","getScopeValue","_def","constant","_leafNode","_constant","_len","keyValues","_key","addCodeArg","thenBody","elseBody","_blockNode","endIf","elseIf","_elseNode","_endBlockNode","_for","node","forBody","endFor","for","forRange","forOf","arr","forIn","obj","break","return","tryBody","catchCode","finallyCode","_currNode","block","body","nodeCount","endBlock","toClose","funcBody","endFunc","N1","N2","andCode","mappend","_len2","_key2","orCode","y","_len3","_key3","errors_1","modifyData","useKeyword","macroSchema","macro","schemaRef","checkAsyncKeyword","validateRef","assignValid","_await","passSchema","modifying","reportErrs","block$data","ruleErrs","validateAsync","validateErrs","validateSync","extendErrors","addErrs","allowUndefined","st","includes","deps","dependencies","util_2","hasPropFunc","isOwnProperty","noPropertyInData","allSchemaProperties","schemaMap","filter","setParams","missingProperty","missing","and","context","dataAndSchema","valCxt","rootData","dynamicRef","newRegExp","pattern","u","rx","validArr","validateItems","notValid","Type","Num","schValid","mergeValidEvaluated","reset","validateAdditionalItems","UUID_REG","URN_REG","isSecure","wsComponents","secure","toLowerCase","httpParse","httpSerialize","http","domainHost","ws","resourceName","SCHEMES","https","wss","urn","urnComponents","nid","nss","urnScheme","schemeHandler","uriComponents","skipEscape","skipNormalize","uuidComponents","uuid","tolerant","traverse","SIMPLE_INLINED","limit","hasRef","countKeys","REF_KEYWORDS","count","Infinity","resolver","TRAILING_SLASH_HASH","ANCHOR","baseIds","pathPrefix","schemaRefs","allKeys","jsonPtr","parentJsonPtr","fullPath","innerBaseId","addRef","_resolve","ambiguos","checkAmbiguosRef","addAnchor","anchor","$anchor","$dynamicAnchor","sch1","sch2","additionalItems_1","prefixItems_1","items_1","items2020_1","contains_1","dependencies_1","propertyNames_1","additionalProperties_1","properties_1","patternProperties_1","not_1","anyOf_1","oneOf_1","allOf_1","if_1","thenElse_1","draft2020","applicator","addError","errObj","err","returnErrors","keywordError","errorPaths","overrideAllErrors","errorObjectCode","errsCount","schemaValue","verbose","E","errorInstancePath","errorSchemaPath","_ref8","extraErrorProps","errorObject","instPath","Str","schPath","boolError","falseSchemaError","reportError","equal_1","j","itemTypes","getSchemaTypes","loopN","item","wrongType","checkDataTypes","DataType","Wrong","indices","loopN2","eql","outer","A","B","C","d","D","f","F","compare","date","compareDate","time","getTime","compareTime","getDateTime","compareDateTime","compareIsoTime","compareIsoDateTime","duration","uri","NOT_URI_FRAGMENT","URI","url","email","hostname","ipv4","Z_ANCHOR","byte","BYTE","lastIndex","int32","Number","isInteger","MAX_INT32","MIN_INT32","int64","float","validateNumber","double","password","binary","fullFormats","DATE","DAYS","exec","year","month","day","isLeapYear","d1","d2","TIME","strictTimeZone","hr","min","sec","tz","tzSign","tzH","tzM","utcMin","utcHr","t1","Date","t2","a1","a2","DATE_TIME_SEPARATOR","dateTime","dt1","dt2","res","prefixItems","trackErrors","max","minContains","maxContains","next","validateItemsWithCount","checkLimits","_valid","depsCount","property_ies","propDeps","schDeps","propertyDeps","schemaDeps","splitDependencies","validatePropertyDeps","validateSchemaDeps","hasProperty","propertyInData","depProp","checkReportMissingProp","checkMissingProp","reportMissingProp","boolSchema_1","applicability_1","dataType_2","defaults_1","keyword_1","subschema_1","validateFunction","funcSourceUrl","destructureValCxtES5","destructureValCxt","subschemaCode","isSchemaObj","checkKeywords","schemaCxtHasRules","$comment","commentKeyword","updateContext","checkAsyncSchema","typeAndKeywords","subSchemaObjCode","boolOrEmptySchema","checkUnknownRules","checkRefsAndKeywords","schemaKeywords","coerceAndCheckDataType","typeErrors","groupKeywords","checkDataType","iterateKeywords","reportTypeError","includesType","strictTypesError","withTypes","ts","narrowSchemaTypes","checkContextTypes","allowUnionTypes","checkMultipleTypes","hasApplicableType","checkKeywordTypes","checkStrictTypes","keywordCode","assignDefaults","schTs","kwdT","checkNoDefault","resetEvaluated","assignEvaluated","returnResults","topSchemaObjCode","topBoolOrEmptySchema","validateKeywordUsage","schemaRefOrVal","getData","validSchemaType","successAction","failAction","failResult","invalid$data","append","errorParams","_error","reportExtraError","$dataError","keyword$DataError","resetErrorsCount","codeBlock","$dataValid","check$data","wrong$DataType","validateSchemaRef","invalid$DataSchema","appl","getSubschema","extendSubschemaData","extendSubschemaMode","nextContext","funcKeywordCode","macroKeywordCode","JSON_POINTER","RELATIVE_JSON_POINTER","up","errorMsg","segment","unescapeJsonPointer","pointerType","IDENTIFIER","emptyStr","_str","strs","plus","safeStringify","mergeExprItems","arg","c1","c2","useLoop","getEql","vSchema","equalCode","every","isJSONType","coerceTo","coerceTypes","COERCIBLE","coerceToTypes","checkTypes","schemaHasRulesForType","coerced","coerceSpecificType","assignParentData","coerceData","strictNums","correct","Correct","numCond","_cond","toHash","notObj","typeError","getTypeErrorContext","removeAdditional","additionalProperties","allProps","hasDefault","applyPropertySchema","core_1","draft7_1","discriminator_1","draft7MetaSchema","META_SUPPORT_DATA","META_SCHEMA_ID","discriminator","defineProperty","formats_1","limit_1","fullName","fastName","formatsPlugin","addFormats","exportName","mode","fastFormats","formatNames","list","fs","cb","_traverse","pre","rootSchema","parentKeyword","keyIndex","arrayKeywords","propsKeywords","escapeJsonPtr","skipKeywords","additionalItems","contains","propertyNames","then","allOf","oneOf","$defs","patternProperties","enum","required","multipleOf","maxLength","minLength","maxProperties","minProperties","additionalProperty","patProps","deleteAdditional","additionalPropertyCode","applyAdditionalSchema","definedProp","propsSchema","usePattern","isAdditional","validateUnion","resolveComponents","base","relative","skipNormalization","target","charAt","lastIndexOf","cmpts","reference","authority","absolutePath","hexLookUp","fromCharCode","URI_PARSE","parsed","gotEncoding","indexOf","isIP","parseInt","isNaN","ipv4result","ipv6result","unicodeSupport","nonSimpleDomain","URL","domainToASCII","encodeURI","decodeURIComponent","fastUri","normalize","baseURI","relativeURI","schemelessOptions","uriA","uriB","loopAllRequired","allErrorsMode","loopUntilMissing","exitOnErrorMode","requiredKey","patterns","alwaysValidPatterns","checkProperties","allowMatchingProperties","evaluatedPropsToName","checkMatchingProperties","pat","validateProperties","alwaysValid","validatePatternProperties","prec","multipleOfPrecision","invalid","ajv_1","formatMaximum","formatMinimum","formatExclusiveMaximum","formatExclusiveMinimum","fCxt","compareCode","formatLimitDefinition","schemaHasRules","escapeJsonPointer","makeMergeEvaluated","mergeNames","mergeToName","mergeValues","resultToName","ps","setEvaluated","hash","encodeURIComponent","xs","Math","snippets","isNumber","types_1","discrError","tagName","Tag","tag","mapping","applyTagSchema","oneOfMapping","topRequired","hasRequired","tagRequired","propSch","addMappings","addMapping","tagValue","getMapping","Mapping","validateMapping","json","jsonPos","jsonLen","jsonPart","limitNumber_1","multipleOf_1","limitLength_1","pattern_1","limitProperties_1","required_1","limitItems_1","uniqueItems_1","const_1","enum_1","ifClause","hasThen","hasSchema","hasElse","validateIf","validateClause","passing","validation_1","applicator_1","format_1","metadata_1","draft7Vocabularies","metadataVocabulary","contentVocabulary"],"sourceRoot":""}