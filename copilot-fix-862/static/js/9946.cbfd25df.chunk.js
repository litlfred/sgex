"use strict";(self.webpackChunksgex_workbench=self.webpackChunksgex_workbench||[]).push([[9946],{18354:(t,e,o)=>{o.r(e),o.d(e,{default:()=>r});const r=new class{constructor(){this.storageKey="sgex_branch_context"}getRepositoryKey(t){var e,o;if(!t||!t.name)return null;const r=(null===(e=t.owner)||void 0===e?void 0:e.login)||(null===(o=t.full_name)||void 0===o?void 0:o.split("/")[0]);return r?"".concat(r,"/").concat(t.name):null}getSelectedBranch(t){if(!t)return null;try{const e=this.getBranchContext();return e[this.getRepositoryKey(t)]||null}catch(e){return console.warn("Failed to get branch context:",e),null}}setSelectedBranch(t,e){if(t&&e)try{const o=this.getBranchContext();o[this.getRepositoryKey(t)]=e,this.setBranchContext(o)}catch(o){console.warn("Failed to set branch context:",o)}}clearRepositoryBranch(t){if(t)try{const e=this.getBranchContext();delete e[this.getRepositoryKey(t)],this.setBranchContext(e)}catch(e){console.warn("Failed to clear repository branch context:",e)}}clearAllBranchContext(){try{sessionStorage.removeItem(this.storageKey)}catch(t){console.warn("Failed to clear branch context:",t)}}getBranchContext(){try{const t=sessionStorage.getItem(this.storageKey);return t?JSON.parse(t):{}}catch(t){return console.warn("Failed to parse branch context from storage:",t),{}}}setBranchContext(t){try{sessionStorage.setItem(this.storageKey,JSON.stringify(t))}catch(e){console.warn("Failed to save branch context to storage:",e)}}getDefaultBranchName(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:[];return t?e.some(t=>"main"===t.name)?"main":t.default_branch&&e.some(e=>e.name===t.default_branch)?t.default_branch:e.length>0?e[0].name:"main":"main"}hasBranchContext(t){return null!==this.getSelectedBranch(t)}getBranchDisplayInfo(t){const e=this.getSelectedBranch(t);if(!e)return null;const o=e===((null===t||void 0===t?void 0:t.default_branch)||"main");return{branch:e,isDefault:o,displayText:o?"".concat(e," (default)"):e}}}},29946:(t,e,o)=>{o.d(e,{A:()=>l});var r=o(89379),s=o(38659);async function a(t,e){let o=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};const{concurrency:r=5,onProgress:s=null,onItemComplete:a=null,onItemStart:n=null}=o;if(!t||0===t.length)return[];const i=new Array(t.length),c=t.length;let l=0;const h=t.map((t,e)=>({item:t,index:e})),u=Array(Math.min(r,t.length)).fill().map(()=>(async()=>{for(;h.length>0;){const{item:o,index:r}=h.shift();n&&n(o,r);try{const t=await e(o,r);i[r]=t,l++,s&&s(l,c,o,t),a&&a(o,t,null)}catch(t){i[r]={error:t,item:o},l++,s&&s(l,c,o,null),a&&a(o,null,t)}}})());return await Promise.all(u),i}const n=new class{constructor(){let t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:30;this.cache=new Map,this.ttl=60*t*1e3}_getCacheKey(t,e){return"".concat(t,"/").concat(e)}_isValid(t){return Date.now()-t.timestamp<this.ttl}get(t,e){const o=this._getCacheKey(t,e),r=this.cache.get(o);return r?this._isValid(r)?r.compatible:(this.cache.delete(o),null):null}set(t,e,o){const r=this._getCacheKey(t,e);this.cache.set(r,{compatible:o,timestamp:Date.now()})}clear(){this.cache.clear()}cleanup(){const t=Date.now();for(const[e,o]of this.cache.entries())t-o.timestamp>=this.ttl&&this.cache.delete(e)}getStats(){return this.cleanup(),{size:this.cache.size,ttlMinutes:this.ttl/6e4,entries:Array.from(this.cache.entries()).map(t=>{let[e,o]=t;return{repository:e,compatible:o.compatible,ageMinutes:Math.round((Date.now()-o.timestamp)/6e4)}})}}};var i=o(85571);const c=new class{constructor(){this.logger=i.A.getLogger("SecureTokenStorage"),this.storageKey="sgex_secure_token",this.expirationHours=24,this.logger.debug("SecureTokenStorage instance created")}generateBrowserFingerprint(){const t=document.createElement("canvas"),e=t.getContext("2d");e.textBaseline="top",e.font="14px Arial",e.fillText("Browser fingerprint",2,2);const o=[navigator.userAgent,navigator.language,window.screen.width+"x"+window.screen.height,window.screen.colorDepth,(new Date).getTimezoneOffset(),t.toDataURL()].join("|");let r=0;for(let s=0;s<o.length;s++){r=(r<<5)-r+o.charCodeAt(s),r&=r}return Math.abs(r).toString(36)}xorCipher(t,e){let o="";for(let r=0;r<t.length;r++)o+=String.fromCharCode(t.charCodeAt(r)^e.charCodeAt(r%e.length));return o}validateTokenFormat(t){if(!t||"string"!==typeof t)return{isValid:!1,type:"invalid",reason:"Token is empty or not a string"};const e=t.trim();return e.match(/^ghp_[A-Za-z0-9]{36}$/)?{isValid:!0,type:"classic",token:e}:e.match(/^github_pat_[A-Za-z0-9]{22}_[A-Za-z0-9]{59}$/)?{isValid:!0,type:"fine-grained",token:e}:e.match(/^gho_[A-Za-z0-9]{36}$/)?{isValid:!0,type:"oauth",token:e}:e.match(/^[a-fA-F0-9]{40}$/)?{isValid:!0,type:"legacy",token:e}:{isValid:!1,type:"invalid",reason:"Token does not match expected GitHub PAT format"}}maskToken(t){if(!t||"string"!==typeof t)return"[INVALID_TOKEN]";const e=t.trim();return e.length<8?"[INVALID_TOKEN]":"".concat(e.substring(0,4)).concat("*".repeat(e.length-8)).concat(e.substring(e.length-4))}storeToken(t){try{this.logger.debug("Starting secure token storage");const e=this.validateTokenFormat(t);if(!e.isValid)return this.logger.warn("Token validation failed",{reason:e.reason,tokenMask:this.maskToken(t)}),!1;this.logger.debug("Token validation successful",{type:e.type,tokenMask:this.maskToken(t)});const o=this.generateBrowserFingerprint(),r="sgex_".concat(o,"_").concat(Date.now().toString(36)),s=this.xorCipher(e.token,r),a={token:btoa(s),key:btoa(r),type:e.type,created:Date.now(),expires:Date.now()+60*this.expirationHours*60*1e3,fingerprint:o};return sessionStorage.setItem(this.storageKey,JSON.stringify(a)),localStorage.removeItem("github_token"),sessionStorage.removeItem("github_token"),this.logger.debug("Token stored securely",{type:e.type,expires:new Date(a.expires).toISOString(),tokenMask:this.maskToken(t)}),!0}catch(e){return this.logger.error("Failed to store token securely",{error:e.message,tokenMask:this.maskToken(t)}),!1}}retrieveToken(){try{this.logger.debug("Attempting to retrieve secure token");const t=sessionStorage.getItem(this.storageKey);if(!t)return this.logger.debug("No secure token found in storage"),null;const e=JSON.parse(t);if(Date.now()>e.expires)return this.logger.warn("Stored token has expired"),this.clearToken(),null;const o=this.generateBrowserFingerprint();if(e.fingerprint!==o)return this.logger.warn("Browser fingerprint mismatch - possible security issue"),this.clearToken(),null;const r=atob(e.key),s=atob(e.token),a=this.xorCipher(s,r),n=this.validateTokenFormat(a);return n.isValid?(this.logger.debug("Token retrieved and decrypted successfully",{type:e.type,expires:new Date(e.expires).toISOString(),tokenMask:this.maskToken(a)}),{token:n.token,type:e.type,created:e.created,expires:e.expires}):(this.logger.error("Decrypted token failed validation"),this.clearToken(),null)}catch(t){return this.logger.error("Failed to retrieve secure token",{error:t.message}),this.clearToken(),null}}hasValidToken(){try{const t=sessionStorage.getItem(this.storageKey);if(!t)return!1;const e=JSON.parse(t);if(Date.now()>e.expires)return this.clearToken(),!1;const o=this.generateBrowserFingerprint();return e.fingerprint===o||(this.clearToken(),!1)}catch(t){return this.logger.error("Error checking token validity",{error:t.message}),this.clearToken(),!1}}clearToken(){this.logger.debug("Clearing secure token storage"),sessionStorage.removeItem(this.storageKey),sessionStorage.removeItem("github_token"),localStorage.removeItem("github_token")}getTokenInfo(){try{const t=sessionStorage.getItem(this.storageKey);if(!t)return null;const e=JSON.parse(t),o=e.expires-Date.now();return{type:e.type,created:new Date(e.created),expires:new Date(e.expires),timeRemaining:Math.max(0,o),isExpired:o<=0,isValid:this.hasValidToken()}}catch(t){return this.logger.error("Error getting token info",{error:t.message}),null}}migrateLegacyToken(){try{const t=sessionStorage.getItem("github_token")||localStorage.getItem("github_token");if(!t)return this.logger.debug("No legacy token found for migration"),!1;this.logger.debug("Migrating legacy token to secure storage");return this.storeToken(t)?(sessionStorage.removeItem("github_token"),localStorage.removeItem("github_token"),this.logger.debug("Legacy token migration completed successfully"),!0):(this.logger.error("Failed to migrate legacy token"),!1)}catch(t){return this.logger.error("Error during legacy token migration",{error:t.message}),!1}}};const l=new class{constructor(){this.octokit=null,this.isAuthenticated=!1,this.permissions=null,this.tokenType=null,this.logger=i.A.getLogger("GitHubService"),this.logger.debug("GitHubService instance created")}async createOctokitInstance(){let t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:null;return new(await(0,s.sN)())(t?{auth:t}:{})}async authenticate(t){const e=Date.now();this.logger.auth("Starting authentication",{tokenProvided:!!t,tokenMask:t?c.maskToken(t):"none"});try{const o=c.validateTokenFormat(t);if(!o.isValid)return this.logger.warn("Token validation failed during authentication",{reason:o.reason,tokenMask:c.maskToken(t)}),this.isAuthenticated=!1,!1;this.octokit=await this.createOctokitInstance(o.token),this.isAuthenticated=!0,this.tokenType=o.type;const r=c.storeToken(o.token);r||this.logger.warn("Failed to store token securely, authentication will not persist");const s=Date.now()-e;return this.logger.auth("Authentication successful",{duration:s,tokenType:this.tokenType,tokenMask:c.maskToken(t),securelyStored:r}),this.logger.performance("GitHub authentication",s),!0}catch(o){const r=Date.now()-e;return this.logger.auth("Authentication failed",{error:o.message,duration:r,tokenMask:c.maskToken(t)}),console.error("Failed to authenticate with GitHub:",o),this.isAuthenticated=!1,c.clearToken(),!1}}authenticateWithOctokit(t){this.logger.auth("Starting OAuth authentication with Octokit instance");try{return this.octokit=t,this.isAuthenticated=!0,this.tokenType="oauth",this.logger.auth("OAuth authentication successful",{tokenType:this.tokenType}),!0}catch(e){return this.logger.auth("OAuth authentication failed",{error:e.message}),console.error("Failed to authenticate with Octokit instance:",e),this.isAuthenticated=!1,!1}}async initializeFromStoredToken(){this.logger.auth("Attempting to initialize from stored token");try{c.migrateLegacyToken()&&this.logger.debug("Successfully migrated legacy token to secure storage");const t=c.retrieveToken();return t?(this.octokit=await this.createOctokitInstance(t.token),this.isAuthenticated=!0,this.tokenType=t.type,this.logger.auth("Successfully initialized from stored token",{tokenType:this.tokenType,tokenMask:c.maskToken(t.token),expires:new Date(t.expires).toISOString()}),!0):(this.logger.debug("No valid stored token found"),!1)}catch(t){return this.logger.auth("Failed to initialize from stored token",{error:t.message}),this.isAuthenticated=!1,c.clearToken(),!1}}hasStoredToken(){return c.hasValidToken()}getStoredTokenInfo(){return c.getTokenInfo()}async checkTokenPermissions(){if(!this.isAuth()){const t=new Error("Not authenticated with GitHub");throw this.logger.error("Token permission check failed - not authenticated"),t}const t=Date.now();this.logger.apiCall("GET","/user",null);try{const o=await this.octokit.request("GET /user");this.logger.apiResponse("GET","/user",o.status,Date.now()-t);try{const t=Date.now();this.logger.apiCall("GET","/rate_limit",null);const e=await this.octokit.rest.rateLimit.get();this.logger.apiResponse("GET","/rate_limit",e.status,Date.now()-t),this.tokenType=e.data.resources.core?"classic":"fine-grained",this.logger.debug("Token type determined",{tokenType:this.tokenType,hasCore:!!e.data.resources.core})}catch(e){this.tokenType="unknown",this.logger.warn("Could not determine token type from rate limit",{error:e.message})}const r={type:this.tokenType,user:o.data};return this.permissions=r,this.logger.debug("Token permissions checked successfully",{tokenType:this.tokenType,username:o.data.login}),r}catch(o){const e=Date.now()-t;throw this.logger.apiError("GET","/user",o),this.logger.performance("Token permission check (failed)",e),console.error("Failed to check token permissions:",o),o}}async checkRepositoryWritePermissions(t,e){if(!this.isAuth())return this.logger.warn("Cannot check repository write permissions - not authenticated",{owner:t,repo:e}),!1;const o=Date.now();this.logger.debug("Checking write permissions for repository",{owner:t,repo:e});try{const r=(await this.getCurrentUser()).login;this.logger.apiCall("GET","/repos/".concat(t,"/").concat(e,"/collaborators/").concat(r,"/permission"),null);const{data:s}=await this.octokit.rest.repos.getCollaboratorPermissionLevel({owner:t,repo:e,username:r}),a=Date.now()-o;this.logger.apiResponse("GET","/repos/".concat(t,"/").concat(e,"/collaborators/").concat(r,"/permission"),200,a);const n=["write","maintain","admin"].includes(s.permission);return this.logger.debug("Repository write permissions checked",{owner:t,repo:e,permission:s.permission,hasWriteAccess:n,supportedLevels:["write","maintain","admin"]}),n}catch(a){var r,s;const n=Date.now()-o;return this.logger.apiError("GET","/repos/".concat(t,"/").concat(e,"/collaborators/*/permission"),a),this.logger.performance("Repository write permission check (failed)",n),console.warn("Could not check repository write permissions for ".concat(t,"/").concat(e,":"),{error:a.message,status:a.status,statusText:null===(r=a.response)||void 0===r?void 0:r.statusText,headers:null===(s=a.response)||void 0===s?void 0:s.headers}),this.logger.warn("Assuming no write access due to permission check failure",{owner:t,repo:e,error:a.message,status:a.status,userGuidance:"Check if your Personal Access Token has the required scopes: repo (classic) or Contents+Pull requests (fine-grained)"}),!1}}async checkRepositoryPermissions(t,e){return this.checkRepositoryWritePermissions(t,e)}async checkCommentPermissions(t,e){if(!this.isAuth())return this.logger.warn("Cannot check comment permissions - not authenticated",{owner:t,repo:e}),!1;const o=Date.now();this.logger.debug("Checking comment permissions for repository",{owner:t,repo:e});try{this.logger.apiCall("GET","/repos/".concat(t,"/").concat(e,"/issues"),{per_page:1}),await this.octokit.rest.issues.listForRepo({owner:t,repo:e,per_page:1,state:"all"});const r=Date.now()-o;return this.logger.apiResponse("GET","/repos/".concat(t,"/").concat(e,"/issues"),200,r),this.logger.debug("Issues endpoint accessible - comment permissions likely available",{owner:t,repo:e}),!0}catch(r){const s=Date.now()-o;return this.logger.apiError("GET","/repos/".concat(t,"/").concat(e,"/issues"),r),this.logger.performance("Comment permission check (failed)",s),403===r.status||401===r.status?(this.logger.warn("Token does not have permission to access issues/comments",{owner:t,repo:e,error:r.message,status:r.status}),!1):(this.logger.warn("Could not determine comment permissions, assuming available",{owner:t,repo:e,error:r.message}),!0)}}isAuth(){return this.isAuthenticated&&null!==this.octokit}async getCurrentUser(){if(!this.isAuth())throw new Error("Not authenticated with GitHub");try{const{data:t}=await this.octokit.rest.users.getAuthenticated();return t}catch(t){throw console.error("Failed to fetch user data:",t),t}}async getUserOrganizations(){if(!this.isAuth())throw new Error("Not authenticated with GitHub");try{const{data:t}=await this.octokit.rest.orgs.listForAuthenticatedUser();return t}catch(t){throw console.error("Failed to fetch organizations:",t),t}}async getOrganization(t){try{const e=this.octokit||await this.createOctokitInstance(),{data:o}=await e.rest.orgs.get({org:t});return o}catch(e){if(403===e.status&&e.message.includes("SAML enforcement")){const o=new Error("SAML authorization required for organization ".concat(t));throw o.isSAMLError=!0,o.organization=t,o.originalError=e,o.status=e.status,o}throw console.error("Failed to fetch organization ".concat(t,":"),e),e}}async getUser(t){try{const e=this.octokit||await this.createOctokitInstance(),{data:o}=await e.rest.users.getByUsername({username:t});return o}catch(e){throw console.error("Failed to fetch user ".concat(t,":"),e),e}}async getPublicRepositories(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"user";try{const o=this.octokit||await this.createOctokitInstance();let r=[],s=1,a=!0;for(;a;){let n;n="user"===e?await o.rest.repos.listForUser({username:t,sort:"updated",per_page:100,page:s}):await o.rest.repos.listForOrg({org:t,sort:"updated",per_page:100,page:s}),r=r.concat(n.data),a=100===n.data.length,s++}return r}catch(o){throw console.error("Failed to fetch public repositories for ".concat(t,":"),o),o}}async getWHOOrganization(){try{const t=await this.getOrganization("WorldHealthOrganization");return{id:t.id,login:t.login,display_name:t.name||"World Health Organization",description:t.description||"The World Health Organization is a specialized agency of the United Nations responsible for international public health.",avatar_url:t.avatar_url,html_url:t.html_url,type:"Organization",permissions:{can_create_repositories:!0,can_create_private_repositories:!0},plan:{name:"Organization",private_repos:"unlimited"},isWHO:!0}}catch(t){return console.warn("Could not fetch WHO organization data from API, using fallback:",t),{id:"who-organization",login:"WorldHealthOrganization",display_name:"World Health Organization",description:"The World Health Organization is a specialized agency of the United Nations responsible for international public health.",avatar_url:"https://avatars.githubusercontent.com/u/12261302?s=200&v=4",html_url:"https://github.com/WorldHealthOrganization",type:"Organization",permissions:{can_create_repositories:!0,can_create_private_repositories:!0},plan:{name:"Organization",private_repos:"unlimited"},isWHO:!0}}}async checkRateLimit(){try{const t=this.octokit||await this.createOctokitInstance(),{data:e}=await t.rest.rateLimit.get();return{core:{limit:e.rate.limit,remaining:e.rate.remaining,reset:e.rate.reset,used:e.rate.used},search:{limit:e.search.limit,remaining:e.search.remaining,reset:e.search.reset,used:e.search.used},isAuthenticated:this.isAuthenticated}}catch(t){return console.warn("Could not check rate limit:",t),{core:{limit:this.isAuthenticated?5e3:60,remaining:0,reset:Date.now()+36e5,used:this.isAuthenticated?5e3:60},search:{limit:this.isAuthenticated?30:10,remaining:0,reset:Date.now()+6e4,used:this.isAuthenticated?30:10},isAuthenticated:this.isAuthenticated}}}async shouldSkipApiCalls(){if(this.isAuthenticated)return!1;try{const t=(await this.checkRateLimit()).core.remaining;return t<10&&(console.warn("\ud83d\udeab Rate limit protection: Only ".concat(t," API calls remaining, skipping compatibility checks")),!0)}catch(t){return console.warn("\u26a0\ufe0f Cannot check rate limits, enabling conservative mode"),!this.isAuthenticated}}async getRepositories(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"user";return this.getSmartGuidelinesRepositories(t,e)}async checkSmartGuidelinesCompatibility(t,e){let o=arguments.length>2&&void 0!==arguments[2]?arguments[2]:2;const r=n.get(t,e);if(null!==r)return{compatible:r,cached:!0};if(!this.isAuthenticated)try{if(await this.shouldSkipApiCalls())return console.warn("\u26a1 Skipping compatibility check for ".concat(t,"/").concat(e," due to rate limit protection")),{compatible:!1,skipped:!0,reason:"Rate limit protection - API call skipped"}}catch(s){console.warn("Could not check rate limits, proceeding with API call:",s)}try{const o=this.octokit||await this.createOctokitInstance(),{data:r}=await o.rest.repos.getContent({owner:t,repo:e,path:"sushi-config.yaml"});if("file"===r.type&&r.content){const o=decodeURIComponent(escape(atob(r.content))).includes("smart.who.int.base");return n.set(t,e,o),{compatible:o}}return n.set(t,e,!1),{compatible:!1,reason:"No sushi-config.yaml file found"}}catch(a){if(404===a.status&&o>0){console.warn("File not found for ".concat(t,"/").concat(e,", retrying... (").concat(o," attempts left)"));const r=1e3;return await new Promise(t=>setTimeout(t,r)),this.checkSmartGuidelinesCompatibility(t,e,o-1)}if(403===a.status&&a.message.includes("SAML enforcement")&&this.octokit){console.log("SAML-protected repository ".concat(t,"/").concat(e,", trying public API fallback"));try{const o=await this.createOctokitInstance(),{data:r}=await o.rest.repos.getContent({owner:t,repo:e,path:"sushi-config.yaml"});if("file"===r.type&&r.content){const o=decodeURIComponent(escape(atob(r.content)));return o.includes("smart.who.int.base")?(console.log("Repository ".concat(t,"/").concat(e," is compatible via public API despite SAML protection")),n.set(t,e,!0),{compatible:!0,reason:"SMART Guidelines DAK (SAML-protected, verified via public API)",requiresAuthentication:!0}):(n.set(t,e,!1),{compatible:!1,reason:"No smart.who.int.base dependency found (via public API)"})}}catch(i){console.warn("Public API fallback also failed for ".concat(t,"/").concat(e,":"),i.message)}}const r={compatible:!1,error:a.message,errorType:this._categorizeError(a),status:a.status,retryable:this._isRetryableError(a)};return console.warn("Failed to check ".concat(t,"/").concat(e," for sushi-config.yaml with smart.who.int.base dependency:"),a.message),n.set(t,e,!1),r}}_categorizeError(t){return 403===t.status?t.message.includes("rate limit")?"rate_limit":"permission_denied":404===t.status?"not_found":401===t.status?"authentication_failed":"ENOTFOUND"===t.code||"ECONNRESET"===t.code?"network_error":"unknown_error"}_isRetryableError(t){return["rate_limit","network_error"].includes(this._categorizeError(t))}async getSmartGuidelinesRepositories(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"user",o=arguments.length>2&&void 0!==arguments[2]&&arguments[2];try{let s=[];if(this.isAuth()){let o=1,r=!0;for(;r;){let a;a="user"===e?await this.octokit.rest.repos.listForUser({username:t,sort:"updated",per_page:100,page:o}):await this.octokit.rest.repos.listForOrg({org:t,sort:"updated",per_page:100,page:o}),s=s.concat(a.data),r=100===a.data.length,o++}}else s=await this.getPublicRepositories(t,e);if(o)return console.log("\u26a1 Skipping compatibility checks for ".concat(s.length," repositories to avoid rate limiting")),s.map(t=>(0,r.A)((0,r.A)({},t),{},{smart_guidelines_compatible:!0}));const a=[];for(const t of s){(await this.checkSmartGuidelinesCompatibility(t.owner.login,t.name)).compatible&&a.push((0,r.A)((0,r.A)({},t),{},{smart_guidelines_compatible:!0}))}return a}catch(s){throw console.error("Failed to fetch SMART guidelines repositories:",s),s}}async getSmartGuidelinesRepositoriesProgressive(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"user",o=arguments.length>2&&void 0!==arguments[2]?arguments[2]:null,s=arguments.length>3&&void 0!==arguments[3]?arguments[3]:null,n=arguments.length>4&&void 0!==arguments[4]?arguments[4]:null;try{let i=[],c=1,l=!0;if(this.isAuth())for(;l;){let o;o="user"===e?await this.octokit.rest.repos.listForUser({username:t,sort:"updated",per_page:100,page:c}):await this.octokit.rest.repos.listForOrg({org:t,sort:"updated",per_page:100,page:c}),i=i.concat(o.data),l=100===o.data.length,c++}else i=await this.getPublicRepositories(t,e);if(0===i.length)return console.log("\ud83d\udcca No repositories found for user, completing scan immediately"),s&&s({current:0,total:0,currentRepo:"none",progress:100,completed:!0}),[];const h={rateLimited:[],networkErrors:[],permissionDenied:[],otherErrors:[],totalErrors:0,totalScanned:0},u=async(t,e)=>{await new Promise(t=>setTimeout(t,100+200*Math.random()));const s=await this.checkSmartGuidelinesCompatibility(t.owner.login,t.name);if(h.totalScanned++,s.compatible){const e=(0,r.A)((0,r.A)({},t),{},{smart_guidelines_compatible:!0});return o&&o(e),e}if(s.error){h.totalErrors++;const e={repo:t.name,error:s.error,errorType:s.errorType,retryable:s.retryable};switch(s.errorType){case"rate_limit":h.rateLimited.push(e);break;case"network_error":h.networkErrors.push(e);break;case"permission_denied":h.permissionDenied.push(e);break;default:h.otherErrors.push(e)}n&&n(e)}return null},g=(await a(i,u,{concurrency:5,onProgress:(t,e,o,r)=>{if(s){const r={current:t,total:e,currentRepo:o.name,progress:Math.round(t/e*100),completed:!0,scanningErrors:h.totalErrors>0?{totalErrors:h.totalErrors,rateLimitedCount:h.rateLimited.length,networkErrorCount:h.networkErrors.length,hasRetryableErrors:[...h.rateLimited,...h.networkErrors].some(t=>t.retryable)}:null};s(r)}},onItemStart:(t,e)=>{s&&s({current:e+1,total:i.length,currentRepo:t.name,progress:Math.round((e+1)/i.length*100),completed:!1,started:!0})}})).filter(t=>null!==t&&!t.error);return h.totalErrors>0&&(console.warn("Repository scanning completed with ".concat(h.totalErrors," errors out of ").concat(h.totalScanned," repositories checked:")),h.rateLimited.length>0&&console.warn("- Rate limited: ".concat(h.rateLimited.length," repositories")),h.networkErrors.length>0&&console.warn("- Network errors: ".concat(h.networkErrors.length," repositories")),h.permissionDenied.length>0&&console.warn("- Permission denied: ".concat(h.permissionDenied.length," repositories")),h.otherErrors.length>0&&console.warn("- Other errors: ".concat(h.otherErrors.length," repositories"))),{repositories:g,scanningErrors:h.totalErrors>0?h:null}}catch(i){throw console.error("Failed to fetch SMART guidelines repositories:",i),i}}async getRepository(t,e){try{const o=this.isAuth()?this.octokit:await this.createOctokitInstance(),{data:r}=await o.rest.repos.get({owner:t,repo:e});return r}catch(o){throw console.error("Failed to fetch repository:",o),o}}async getBranches(t,e){try{console.log("githubService.getBranches: Fetching branches for ".concat(t,"/").concat(e)),console.log("githubService.getBranches: Authentication status:",this.isAuth());const o=this.isAuth()?this.octokit:await this.createOctokitInstance();console.log("githubService.getBranches: Using",this.isAuth()?"authenticated":"public","octokit instance");const{data:r}=await o.rest.repos.listBranches({owner:t,repo:e,per_page:100});return console.log("githubService.getBranches: Successfully fetched ".concat(r.length," branches")),r}catch(o){throw console.error("githubService.getBranches: Failed to fetch branches:",o),console.error("githubService.getBranches: Error details:",{status:o.status,message:o.message,owner:t,repo:e}),o}}async createBranch(t,e,o){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:"main";if(!this.isAuth())throw new Error("Not authenticated with GitHub");try{const{data:s}=await this.octokit.rest.git.getRef({owner:t,repo:e,ref:"heads/".concat(r)}),{data:a}=await this.octokit.rest.git.createRef({owner:t,repo:e,ref:"refs/heads/".concat(o),sha:s.object.sha});return a}catch(s){throw console.error("Failed to create branch:",s),s}}async getBranch(t,e,o){try{const r=this.isAuth()?this.octokit:await this.createOctokitInstance(),{data:s}=await r.rest.repos.getBranch({owner:t,repo:e,branch:o});return s}catch(r){throw console.error("Failed to fetch branch:",r),r}}async getWorkflows(t,e){if(!this.isAuth())throw new Error("Not authenticated with GitHub");try{const{data:o}=await this.octokit.rest.actions.listRepoWorkflows({owner:t,repo:e});return o.workflows.map(t=>({id:t.id,name:t.name,filename:t.path.split("/").pop(),path:t.path,state:t.state,created_at:t.created_at,updated_at:t.updated_at,url:t.html_url,triggers:["unknown"],lastModified:t.updated_at}))}catch(o){if(404===o.status)return[];throw console.error("Failed to fetch workflows:",o),o}}async getWorkflowRuns(t,e){let o=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};if(!this.isAuth())throw new Error("Not authenticated with GitHub");try{const r={owner:t,repo:e,per_page:o.per_page||10,page:o.page||1};o.branch&&(r.branch=o.branch),o.workflow_id&&(r.workflow_id=o.workflow_id);const{data:s}=await this.octokit.rest.actions.listWorkflowRunsForRepo(r);return s}catch(r){throw console.error("Failed to fetch workflow runs:",r),r}}async getWorkflowRunsForWorkflow(t,e,o){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:{};if(!this.isAuth())throw new Error("Not authenticated with GitHub");try{const s={owner:t,repo:e,workflow_id:o,per_page:r.per_page||10,page:r.page||1};r.branch&&(s.branch=r.branch);const{data:a}=await this.octokit.rest.actions.listWorkflowRuns(s);return a}catch(s){throw console.error("Failed to fetch workflow runs for workflow:",s),s}}async triggerWorkflow(t,e,o){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:"main",s=arguments.length>4&&void 0!==arguments[4]?arguments[4]:{};if(!this.isAuth())throw new Error("Not authenticated with GitHub");try{const{data:a}=await this.octokit.rest.actions.createWorkflowDispatch({owner:t,repo:e,workflow_id:o,ref:r,inputs:s});return a}catch(a){throw console.error("Failed to trigger workflow:",a),a}}async rerunWorkflow(t,e,o){if(!this.isAuth())throw new Error("Not authenticated with GitHub");try{const{data:r}=await this.octokit.rest.actions.reRunWorkflow({owner:t,repo:e,run_id:o});return r}catch(r){throw console.error("Failed to re-run workflow:",r),r}}async getWorkflowRunLogs(t,e,o){if(!this.isAuth())throw new Error("Not authenticated with GitHub");try{const{data:r}=await this.octokit.rest.actions.downloadWorkflowRunLogs({owner:t,repo:e,run_id:o});return r}catch(r){throw console.error("Failed to get workflow run logs:",r),r}}async approveWorkflowRun(t,e,o){if(!this.isAuth())throw new Error("Not authenticated with GitHub");try{const{data:r}=await this.octokit.rest.actions.approveWorkflowRun({owner:t,repo:e,run_id:o});return r}catch(r){throw console.error("Failed to approve workflow run:",r),r}}async getCommitDiff(t,e,o,r){if(!this.isAuth())throw new Error("Not authenticated with GitHub");try{const{data:s}=await this.octokit.rest.repos.compareCommits({owner:t,repo:e,base:o,head:r});return s}catch(s){throw console.error("Failed to get commit diff:",s),s}}async getCommit(t,e,o){if(!this.isAuth())throw new Error("Not authenticated with GitHub");try{const{data:r}=await this.octokit.rest.repos.getCommit({owner:t,repo:e,ref:o});return r}catch(r){throw console.error("Failed to get commit details:",r),r}}async getReleases(t,e){let o=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};if(!this.isAuth())throw new Error("Not authenticated with GitHub");try{const{data:r}=await this.octokit.rest.repos.listReleases({owner:t,repo:e,per_page:o.per_page||10,page:o.page||1});return r}catch(r){throw console.error("Failed to fetch releases:",r),r}}async getLatestRelease(t,e){if(!this.isAuth())throw new Error("Not authenticated with GitHub");try{const{data:o}=await this.octokit.rest.repos.getLatestRelease({owner:t,repo:e});return o}catch(o){throw console.error("Failed to fetch latest release:",o),o}}async getBpmnFilesRecursive(t,e,o){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:"main",s=arguments.length>4&&void 0!==arguments[4]?arguments[4]:[];try{console.log("\ud83d\udd0e githubService.getBpmnFilesRecursive: Searching ".concat(t,"/").concat(e,"/").concat(o," (ref: ").concat(r,")"));const a=this.isAuth()?this.octokit:await this.createOctokitInstance();console.log("\ud83d\udd10 githubService.getBpmnFilesRecursive: Using ".concat(this.isAuth()?"authenticated":"public"," octokit"));const{data:n}=await a.rest.repos.getContent({owner:t,repo:e,path:o,ref:r});if(console.log("\ud83d\udce6 githubService.getBpmnFilesRecursive: Received data type: ".concat(Array.isArray(n)?"array":"single file",", length: ").concat(Array.isArray(n)?n.length:1)),!Array.isArray(n))return n.name.endsWith(".bpmn")&&(console.log("\ud83d\udcc4 githubService.getBpmnFilesRecursive: Found single BPMN file: ".concat(n.name)),s.push(n)),s;for(const o of n)"file"===o.type&&o.name.endsWith(".bpmn")?(console.log("\ud83d\udcc4 githubService.getBpmnFilesRecursive: Found BPMN file: ".concat(o.name)),s.push(o)):"dir"===o.type&&(console.log("\ud83d\udcc1 githubService.getBpmnFilesRecursive: Found subdirectory: ".concat(o.name,", recursing...")),await this.getBpmnFilesRecursive(t,e,o.path,r,s));return console.log("\u2705 githubService.getBpmnFilesRecursive: Completed search of ".concat(o,", found ").concat(s.length," total files so far")),s}catch(a){if(console.log("\u274c githubService.getBpmnFilesRecursive: Error searching ".concat(o,":"),a.status,a.message),404===a.status)return s;throw a}}async getBpmnFiles(t,e){let o=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"main";console.log("\ud83d\udd0d githubService.getBpmnFiles: Starting search for ".concat(t,"/").concat(e," (ref: ").concat(o,")"));const r=[],s=["input/business-processes","input/business-process"];for(const i of s)try{console.log("\ud83d\udcc1 githubService.getBpmnFiles: Searching in directory: ".concat(i));const s=await this.getBpmnFilesRecursive(t,e,i,o);console.log("\u2705 githubService.getBpmnFiles: Found ".concat(s.length," BPMN files in ").concat(i)),r.push(...s)}catch(n){404!==n.status?console.warn("\u274c Could not fetch BPMN files from ".concat(i,":"),n.message):console.log("\ud83d\udcc2 githubService.getBpmnFiles: Directory ".concat(i," not found (404) - this is expected if the directory doesn't exist"))}const a=r.filter((t,e,o)=>e===o.findIndex(e=>e.path===t.path));return console.log("\ud83c\udfaf githubService.getBpmnFiles: Final result - ".concat(a.length," unique BPMN files found")),console.log("\ud83d\udccb githubService.getBpmnFiles: File list:",a.map(t=>t.name)),a}async getFileContent(t,e,o){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:"main";const s=15e3;try{console.log("\ud83d\ude80 githubService.getFileContent: Starting request for ".concat(t,"/").concat(e,"/").concat(o," (ref: ").concat(r,")")),console.log("\ud83d\udd10 githubService.getFileContent: Authentication status:",this.isAuth()),console.log("\ud83d\udccb githubService.getFileContent: Request parameters:",{owner:t,repo:e,path:o,ref:r});const a=this.isAuth()?this.octokit:await this.createOctokitInstance();console.log("\ud83d\udd27 githubService.getFileContent: Using",this.isAuth()?"authenticated":"public","octokit instance");const i=new Promise((t,e)=>{console.log("\u23f0 githubService.getFileContent: Setting up ".concat(s,"ms timeout")),setTimeout(()=>{console.error("\u23f0 githubService.getFileContent: Request timed out after ".concat(s,"ms")),e(new Error("Request timeout after ".concat(s,"ms")))},s)});console.log("\ud83c\udf10 githubService.getFileContent: Creating GitHub API promise...");const c=a.rest.repos.getContent({owner:t,repo:e,path:o,ref:r});console.log("\ud83d\udce1 githubService.getFileContent: API request initiated, waiting for response...");const l=Date.now(),{data:h}=await Promise.race([c,i]),u=Date.now()-l;if(console.log("\u2705 githubService.getFileContent: API response received in ".concat(u,"ms")),console.log("\ud83d\udcc2 githubService.getFileContent: Response data type:",h.type),console.log("\ud83d\udcca githubService.getFileContent: Response details:",{type:h.type,name:h.name,size:h.size,encoding:h.encoding,hasContent:!!h.content}),"file"!==h.type||!h.content)throw console.error("\u274c githubService.getFileContent: Invalid response - not a file or no content"),console.error("\ud83d\udd0d githubService.getFileContent: Full response data:",JSON.stringify(h,null,2)),new Error("File not found or is not a file");console.log("\ud83d\udd27 githubService.getFileContent: Decoding base64 content..."),console.log("\ud83d\udcca githubService.getFileContent: Base64 content length:",h.content.length);try{const t=Buffer.from(h.content,"base64").toString("utf-8");return console.log("\u2705 githubService.getFileContent: Successfully fetched and decoded file content"),console.log("\ud83d\udccf githubService.getFileContent: Final content length:",t.length,"characters"),console.log("\ud83d\udc40 githubService.getFileContent: Content preview (first 200 chars):",t.substring(0,200)),t}catch(n){throw console.error("\u274c githubService.getFileContent: Base64 decoding failed:",n),console.error("\ud83d\udd0d githubService.getFileContent: Raw base64 content preview:",h.content.substring(0,100)),new Error("Failed to decode file content: ".concat(n.message))}}catch(i){var a;if(console.error("\ud83d\udca5 githubService.getFileContent: Failed to fetch file content from ".concat(t,"/").concat(e,"/").concat(o,":"),i),console.error("\ud83d\udd0d githubService.getFileContent: Error analysis:",{type:typeof i,status:i.status,message:i.message,name:i.name,stack:(null===(a=i.stack)||void 0===a?void 0:a.substring(0,500))+"..."}),i.message.includes("timeout"))throw console.error("\u23f0 githubService.getFileContent: Timeout error detected"),new Error("GitHub API request timed out after ".concat(15," seconds. Please try again."));if(403===i.status)throw console.error("\ud83d\udd12 githubService.getFileContent: 403 Forbidden error detected"),new Error("Access denied. This repository may be private or you may have hit rate limits.");if(404===i.status)throw console.error("\ud83d\udd0d githubService.getFileContent: 404 Not Found error detected"),new Error("File not found in the repository.");if(i.message.includes("rate limit"))throw console.error("\ud83d\udea6 githubService.getFileContent: Rate limit error detected"),new Error("GitHub API rate limit exceeded. Please try again later.");if(i.message.includes("Network Error")||i.message.includes("Failed to fetch"))throw console.error("\ud83c\udf10 githubService.getFileContent: Network error detected"),new Error("Network error occurred. Please check your internet connection and try again.");throw console.error("\u2753 githubService.getFileContent: Unknown error type, re-throwing original error"),i}}async createCommit(t,e,o,r,s){if(!this.isAuth())throw new Error("Not authenticated with GitHub");try{const{data:a}=await this.octokit.rest.git.getRef({owner:t,repo:e,ref:"heads/".concat(o)}),n=a.object.sha,{data:i}=await this.octokit.rest.git.getCommit({owner:t,repo:e,commit_sha:n}),c=i.tree.sha,l=await Promise.all(s.map(async o=>{const{data:r}=await this.octokit.rest.git.createBlob({owner:t,repo:e,content:o.content,encoding:"utf-8"});return{path:o.path,mode:"100644",type:"blob",sha:r.sha}})),{data:h}=await this.octokit.rest.git.createTree({owner:t,repo:e,base_tree:c,tree:l}),{data:u}=await this.octokit.rest.git.createCommit({owner:t,repo:e,message:r,tree:h.sha,parents:[n]});return await this.octokit.rest.git.updateRef({owner:t,repo:e,ref:"heads/".concat(o),sha:u.sha}),{sha:u.sha,html_url:"https://github.com/".concat(t,"/").concat(e,"/commit/").concat(u.sha),message:u.message,author:u.author,committer:u.committer}}catch(a){throw console.error("Failed to create commit:",a),a}}async getRecentCommits(t,e){let o=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"main",r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:5;if(!this.isAuth())throw new Error("Not authenticated with GitHub");const s=Date.now();this.logger.apiCall("GET","/repos/".concat(t,"/").concat(e,"/commits"),{sha:o,per_page:r});try{const a=await this.octokit.rest.repos.listCommits({owner:t,repo:e,sha:o,per_page:r});return this.logger.apiResponse("GET","/repos/".concat(t,"/").concat(e,"/commits"),a.status,Date.now()-s),a.data.map(t=>({sha:t.sha,message:t.commit.message,author:{name:t.commit.author.name,email:t.commit.author.email,date:t.commit.author.date},committer:{name:t.commit.committer.name,email:t.commit.committer.email,date:t.commit.committer.date},html_url:t.html_url,stats:t.stats}))}catch(a){throw this.logger.apiResponse("GET","/repos/".concat(t,"/").concat(e,"/commits"),a.status||"error",Date.now()-s),console.error("Failed to fetch recent commits:",a),a}}async getOpenPullRequestsCount(t,e){if(!this.isAuth())throw new Error("Not authenticated with GitHub");const o=Date.now();this.logger.apiCall("GET","/repos/".concat(t,"/").concat(e,"/pulls"),{state:"open",per_page:1});try{const r=await this.octokit.rest.pulls.list({owner:t,repo:e,state:"open",per_page:1});this.logger.apiResponse("GET","/repos/".concat(t,"/").concat(e,"/pulls"),r.status,Date.now()-o);const s=r.headers.link;if(s&&s.includes('rel="last"')){const t=s.match(/page=(\d+)>; rel="last"/);if(t)return parseInt(t[1],10)}return r.data.length}catch(r){throw this.logger.apiResponse("GET","/repos/".concat(t,"/").concat(e,"/pulls"),r.status||"error",Date.now()-o),console.error("Failed to fetch pull requests count:",r),r}}async getPullRequestForBranch(t,e,o){const r=await this.getPullRequestsForBranch(t,e,o);return r&&r.length>0?r[0]:null}async getPullRequestsForBranch(t,e,o){const r=this.isAuth()?this.octokit:await this.createOctokitInstance(),s=Date.now();this.logger.apiCall("GET","/repos/".concat(t,"/").concat(e,"/pulls"),{state:"open",head:"".concat(t,":").concat(o)});try{const a=await r.rest.pulls.list({owner:t,repo:e,state:"open",head:"".concat(t,":").concat(o),per_page:100});return this.logger.apiResponse("GET","/repos/".concat(t,"/").concat(e,"/pulls"),a.status,Date.now()-s),a.data||[]}catch(a){return this.logger.apiResponse("GET","/repos/".concat(t,"/").concat(e,"/pulls"),a.status||"error",Date.now()-s),console.error("Failed to fetch pull requests for branch:",a),[]}}async getPullRequestComments(t,e,o){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1,s=arguments.length>4&&void 0!==arguments[4]?arguments[4]:100;const a=this.isAuth()?this.octokit:await this.createOctokitInstance(),n=Date.now();this.logger.apiCall("GET","/repos/".concat(t,"/").concat(e,"/pulls/").concat(o,"/comments"),{page:r,per_page:s});try{const i=await a.rest.pulls.listReviewComments({owner:t,repo:e,pull_number:o,page:r,per_page:s});return this.logger.apiResponse("GET","/repos/".concat(t,"/").concat(e,"/pulls/").concat(o,"/comments"),i.status,Date.now()-n),i.data}catch(i){throw this.logger.apiResponse("GET","/repos/".concat(t,"/").concat(e,"/pulls/").concat(o,"/comments"),i.status||"error",Date.now()-n),console.error("Failed to fetch pull request comments:",i),i}}async getPullRequestIssueComments(t,e,o){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1,s=arguments.length>4&&void 0!==arguments[4]?arguments[4]:100;const a=this.isAuth()?this.octokit:await this.createOctokitInstance(),n=Date.now();this.logger.apiCall("GET","/repos/".concat(t,"/").concat(e,"/issues/").concat(o,"/comments"),{page:r,per_page:s});try{const i=await a.rest.issues.listComments({owner:t,repo:e,issue_number:o,page:r,per_page:s});return this.logger.apiResponse("GET","/repos/".concat(t,"/").concat(e,"/issues/").concat(o,"/comments"),i.status,Date.now()-n),i.data}catch(i){throw this.logger.apiResponse("GET","/repos/".concat(t,"/").concat(e,"/issues/").concat(o,"/comments"),i.status||"error",Date.now()-n),console.error("Failed to fetch pull request issue comments:",i),i}}async createPullRequestComment(t,e,o,r){if(!this.isAuth())throw new Error("Not authenticated with GitHub");const s=Date.now();this.logger.apiCall("POST","/repos/".concat(t,"/").concat(e,"/issues/").concat(o,"/comments"),{body:r});try{const a=await this.octokit.rest.issues.createComment({owner:t,repo:e,issue_number:o,body:r});return this.logger.apiResponse("POST","/repos/".concat(t,"/").concat(e,"/issues/").concat(o,"/comments"),a.status,Date.now()-s),a.data}catch(a){throw this.logger.apiResponse("POST","/repos/".concat(t,"/").concat(e,"/issues/").concat(o,"/comments"),a.status||"error",Date.now()-s),console.error("Failed to create pull request comment:",a),a}}async getPullRequestTimeline(t,e,o){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1,s=arguments.length>4&&void 0!==arguments[4]?arguments[4]:100;const a=this.isAuth()?this.octokit:await this.createOctokitInstance(),n=Date.now();this.logger.apiCall("GET","/repos/".concat(t,"/").concat(e,"/issues/").concat(o,"/timeline"),{page:r,per_page:s});try{const i=await a.rest.issues.listEventsForTimeline({owner:t,repo:e,issue_number:o,page:r,per_page:s});return this.logger.apiResponse("GET","/repos/".concat(t,"/").concat(e,"/issues/").concat(o,"/timeline"),i.status,Date.now()-n),i.data}catch(i){return this.logger.apiResponse("GET","/repos/".concat(t,"/").concat(e,"/issues/").concat(o,"/timeline"),i.status||"error",Date.now()-n),console.debug("Failed to fetch pull request timeline:",i),[]}}async mergePullRequest(t,e,o){let s=arguments.length>3&&void 0!==arguments[3]?arguments[3]:{};if(!this.isAuth())throw new Error("Not authenticated with GitHub");const a=Date.now();this.logger.apiCall("PUT","/repos/".concat(t,"/").concat(e,"/pulls/").concat(o,"/merge"),s);try{const n=(0,r.A)({owner:t,repo:e,pull_number:o,commit_title:s.commit_title,commit_message:s.commit_message,merge_method:s.merge_method||"merge"},s),i=await this.octokit.rest.pulls.merge(n);return this.logger.apiResponse("PUT","/repos/".concat(t,"/").concat(e,"/pulls/").concat(o,"/merge"),i.status,Date.now()-a),i.data}catch(n){throw this.logger.apiResponse("PUT","/repos/".concat(t,"/").concat(e,"/pulls/").concat(o,"/merge"),n.status||"error",Date.now()-a),console.error("Failed to merge pull request:",n),n}}async checkPullRequestMergePermissions(t,e,o){if(!this.isAuth())return this.logger.warn("Cannot check PR merge permissions - not authenticated",{owner:t,repo:e,pullNumber:o}),!1;try{const r=Date.now();this.logger.apiCall("GET","/repos/".concat(t,"/").concat(e,"/pulls/").concat(o),{});const s=await this.octokit.rest.pulls.get({owner:t,repo:e,pull_number:o});this.logger.apiResponse("GET","/repos/".concat(t,"/").concat(e,"/pulls/").concat(o),s.status,Date.now()-r);const a=s.data;if("open"!==a.state)return this.logger.debug("PR not mergeable - not open",{owner:t,repo:e,pullNumber:o,state:a.state}),!1;if(a.draft)return this.logger.debug("PR not mergeable - is draft",{owner:t,repo:e,pullNumber:o}),!1;return!!await this.checkRepositoryWritePermissions(t,e)||(this.logger.debug("PR not mergeable - no write access",{owner:t,repo:e,pullNumber:o}),!1)}catch(r){return this.logger.warn("Error checking PR merge permissions",{owner:t,repo:e,pullNumber:o,error:r.message}),!1}}async getOpenIssuesCount(t,e){if(!this.isAuth())throw new Error("Not authenticated with GitHub");const o=Date.now();this.logger.apiCall("GET","/repos/".concat(t,"/").concat(e,"/issues"),{state:"open",per_page:1});try{const r=await this.octokit.rest.issues.listForRepo({owner:t,repo:e,state:"open",per_page:1});this.logger.apiResponse("GET","/repos/".concat(t,"/").concat(e,"/issues"),r.status,Date.now()-o);const s=r.headers.link;if(s&&s.includes('rel="last"')){const t=s.match(/page=(\d+)>; rel="last"/);if(t)return parseInt(t[1],10)}return r.data.length}catch(r){throw this.logger.apiResponse("GET","/repos/".concat(t,"/").concat(e,"/issues"),r.status||"error",Date.now()-o),console.error("Failed to fetch issues count:",r),r}}async getRepositoryStats(t,e){let o=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"main";if(!this.isAuth())throw new Error("Not authenticated with GitHub");try{const[r,s,a]=await Promise.allSettled([this.getRecentCommits(t,e,o,1),this.getOpenPullRequestsCount(t,e),this.getOpenIssuesCount(t,e)]);return{recentCommits:"fulfilled"===r.status?r.value:[],openPullRequestsCount:"fulfilled"===s.status?s.value:0,openIssuesCount:"fulfilled"===a.status?a.value:0,errors:{recentCommits:"rejected"===r.status?r.reason:null,openPullRequestsCount:"rejected"===s.status?s.reason:null,openIssuesCount:"rejected"===a.status?a.reason:null}}}catch(r){throw console.error("Failed to fetch repository stats:",r),r}}async getDirectoryContents(t,e){let o=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"",r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:"main";try{const s=this.isAuth()?this.octokit:await this.createOctokitInstance(),{data:a}=await s.rest.repos.getContent({owner:t,repo:e,path:o,ref:r});if(Array.isArray(a))return a;throw new Error("Not a directory")}catch(s){throw console.error("Failed to get directory contents for ".concat(o,":"),s),s}}async updateFile(t,e,o,r,s){let a=arguments.length>5&&void 0!==arguments[5]?arguments[5]:"main";if(!this.isAuth())throw new Error("Authentication required to update files");try{const{data:n}=await this.octokit.rest.repos.getContent({owner:t,repo:e,path:o,ref:a});if(Array.isArray(n))throw new Error("Path is a directory, not a file");const{data:i}=await this.octokit.rest.repos.createOrUpdateFileContents({owner:t,repo:e,path:o,message:s,content:btoa(unescape(encodeURIComponent(r))),sha:n.sha,branch:a});return i}catch(n){throw console.error("Failed to update file ".concat(o,":"),n),n}}async getCommits(t,e){let o=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};try{const r=this.isAuth()?this.octokit:await this.createOctokitInstance(),s={owner:t,repo:e,per_page:o.per_page||10,page:o.page||1};o.sha&&(s.sha=o.sha),o.since&&(s.since=o.since),o.until&&(s.until=o.until);const{data:a}=await r.rest.repos.listCommits(s);return a}catch(r){throw console.error("Failed to fetch commits:",r),r}}async getIssues(t,e){let o=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};try{const r=this.isAuth()?this.octokit:await this.createOctokitInstance(),s={owner:t,repo:e,state:o.state||"all",per_page:o.per_page||30,page:o.page||1};o.labels&&(s.labels=o.labels),o.milestone&&(s.milestone=o.milestone);const{data:a}=await r.rest.issues.listForRepo(s);return a}catch(r){throw console.error("Failed to fetch issues:",r),r}}async getRepositoryIssues(t,e){let o=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};return this.getIssues(t,e,o)}async getForks(t,e){let o=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};const r=Date.now();this.logger.apiCall("GET","/repos/".concat(t,"/").concat(e,"/forks"),o);try{const s=this.isAuth()?this.octokit:await this.createOctokitInstance(),a={owner:t,repo:e,sort:o.sort||"newest",per_page:o.per_page||100,page:o.page||1},{data:n}=await s.rest.repos.listForks(a);return this.logger.apiResponse("GET","/repos/".concat(t,"/").concat(e,"/forks"),200,Date.now()-r),n.map(t=>({id:t.id,name:t.name,full_name:t.full_name,owner:{login:t.owner.login,avatar_url:t.owner.avatar_url,html_url:t.owner.html_url,type:t.owner.type},description:t.description,html_url:t.html_url,clone_url:t.clone_url,created_at:t.created_at,updated_at:t.updated_at,pushed_at:t.pushed_at,stargazers_count:t.stargazers_count,forks_count:t.forks_count,open_issues_count:t.open_issues_count,default_branch:t.default_branch,private:t.private,fork:t.fork,parent:t.parent?{full_name:t.parent.full_name,html_url:t.parent.html_url}:null}))}catch(s){throw this.logger.apiResponse("GET","/repos/".concat(t,"/").concat(e,"/forks"),s.status||"error",Date.now()-r),console.error("Failed to fetch repository forks:",s),s}}async getPullRequests(t,e){let o=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};const r=Date.now();this.logger.apiCall("GET","/repos/".concat(t,"/").concat(e,"/pulls"),o);try{const s=this.isAuth()?this.octokit:await this.createOctokitInstance(),a={owner:t,repo:e,state:o.state||"open",sort:o.sort||"updated",direction:o.direction||"desc",per_page:o.per_page||30,page:o.page||1};o.head&&(a.head=o.head),o.base&&(a.base=o.base);const{data:n}=await s.rest.pulls.list(a);return this.logger.apiResponse("GET","/repos/".concat(t,"/").concat(e,"/pulls"),200,Date.now()-r),n.map(t=>({id:t.id,number:t.number,title:t.title,body:t.body,state:t.state,locked:t.locked,user:{login:t.user.login,avatar_url:t.user.avatar_url,html_url:t.user.html_url,type:t.user.type},created_at:t.created_at,updated_at:t.updated_at,closed_at:t.closed_at,merged_at:t.merged_at,html_url:t.html_url,diff_url:t.diff_url,patch_url:t.patch_url,head:{ref:t.head.ref,sha:t.head.sha,repo:t.head.repo?{name:t.head.repo.name,full_name:t.head.repo.full_name,owner:{login:t.head.repo.owner.login,avatar_url:t.head.repo.owner.avatar_url},html_url:t.head.repo.html_url}:null},base:{ref:t.base.ref,sha:t.base.sha,repo:{name:t.base.repo.name,full_name:t.base.repo.full_name,owner:{login:t.base.repo.owner.login,avatar_url:t.base.repo.owner.avatar_url},html_url:t.base.repo.html_url}},draft:t.draft,mergeable:t.mergeable,mergeable_state:t.mergeable_state,comments:t.comments,review_comments:t.review_comments,commits:t.commits,additions:t.additions,deletions:t.deletions,changed_files:t.changed_files}))}catch(s){throw this.logger.apiResponse("GET","/repos/".concat(t,"/").concat(e,"/pulls"),s.status||"error",Date.now()-r),console.error("Failed to fetch pull requests:",s),s}}async createIssue(t,e,o,r){let s=arguments.length>4&&void 0!==arguments[4]?arguments[4]:[],a=arguments.length>5&&void 0!==arguments[5]?arguments[5]:[];if(!this.isAuth())throw new Error("Authentication required to create issues");const n=Date.now();this.logger.apiCall("POST","/repos/".concat(t,"/").concat(e,"/issues"),{title:o,bodyLength:null===r||void 0===r?void 0:r.length,labels:s,assignees:a});try{const i={owner:t,repo:e,title:o,body:r};s.length>0&&(i.labels=s),a.length>0&&(i.assignees=a);const c=await this.octokit.rest.issues.create(i);return this.logger.apiResponse("POST","/repos/".concat(t,"/").concat(e,"/issues"),c.status,Date.now()-n),{success:!0,issue:{id:c.data.id,number:c.data.number,title:c.data.title,body:c.data.body,html_url:c.data.html_url,state:c.data.state,created_at:c.data.created_at,user:{login:c.data.user.login,avatar_url:c.data.user.avatar_url},labels:c.data.labels.map(t=>({name:t.name,color:t.color}))}}}catch(i){return this.logger.apiResponse("POST","/repos/".concat(t,"/").concat(e,"/issues"),i.status||"error",Date.now()-n),console.error("Failed to create issue:",i),{success:!1,error:{message:i.message,status:i.status,type:403===i.status?"permission_denied":422===i.status?"validation_error":404===i.status?"repository_not_found":"unknown_error"}}}}async getIssue(t,e,o){if(!this.isAuth())throw new Error("Authentication required to get issue details");const r=Date.now();this.logger.apiCall("GET","/repos/".concat(t,"/").concat(e,"/issues/").concat(o));try{const s=await this.octokit.rest.issues.get({owner:t,repo:e,issue_number:o});return this.logger.apiResponse("GET","/repos/".concat(t,"/").concat(e,"/issues/").concat(o),s.status,Date.now()-r),{id:s.data.id,number:s.data.number,title:s.data.title,body:s.data.body,html_url:s.data.html_url,state:s.data.state,created_at:s.data.created_at,updated_at:s.data.updated_at,closed_at:s.data.closed_at,user:{login:s.data.user.login,avatar_url:s.data.user.avatar_url},labels:s.data.labels.map(t=>({name:t.name,color:t.color}))}}catch(s){throw this.logger.apiResponse("GET","/repos/".concat(t,"/").concat(e,"/issues/").concat(o),s.status||"error",Date.now()-r),console.error("Failed to get issue:",s),s}}async getPullRequest(t,e,o){if(!this.isAuth())throw new Error("Authentication required to get pull request details");const r=Date.now();this.logger.apiCall("GET","/repos/".concat(t,"/").concat(e,"/pulls/").concat(o));try{const s=await this.octokit.rest.pulls.get({owner:t,repo:e,pull_number:o});return this.logger.apiResponse("GET","/repos/".concat(t,"/").concat(e,"/pulls/").concat(o),s.status,Date.now()-r),{id:s.data.id,number:s.data.number,title:s.data.title,body:s.data.body,html_url:s.data.html_url,state:s.data.state,created_at:s.data.created_at,updated_at:s.data.updated_at,closed_at:s.data.closed_at,merged_at:s.data.merged_at,user:{login:s.data.user.login,avatar_url:s.data.user.avatar_url},head:{ref:s.data.head.ref,sha:s.data.head.sha},base:{ref:s.data.base.ref,sha:s.data.base.sha}}}catch(s){throw this.logger.apiResponse("GET","/repos/".concat(t,"/").concat(e,"/pulls/").concat(o),s.status||"error",Date.now()-r),console.error("Failed to get pull request:",s),s}}async searchIssues(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};if(!this.isAuth())throw new Error("Authentication required to search issues");const o=Date.now();this.logger.apiCall("GET","/search/issues",{query:t,type:"issue"});try{const r=await this.octokit.rest.search.issuesAndPullRequests({q:t,sort:e.sort||"created",order:e.order||"desc",per_page:e.per_page||30,page:e.page||1});return this.logger.apiResponse("GET","/search/issues",r.status,Date.now()-o),{total_count:r.data.total_count,incomplete_results:r.data.incomplete_results,items:r.data.items.map(t=>({id:t.id,number:t.number,title:t.title,body:t.body,html_url:t.html_url,state:t.state,created_at:t.created_at,updated_at:t.updated_at,closed_at:t.closed_at,labels:t.labels||[],user:{login:t.user.login,avatar_url:t.user.avatar_url},repository:t.repository_url?{name:t.repository_url.split("/").slice(-1)[0],full_name:t.repository_url.split("/").slice(-2).join("/")}:null}))}}catch(r){throw this.logger.apiResponse("GET","/search/issues",r.status||"error",Date.now()-o),console.error("Failed to search issues:",r),r}}async searchPullRequests(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};if(!this.isAuth())throw new Error("Authentication required to search pull requests");const o=Date.now();this.logger.apiCall("GET","/search/issues",{query:t,type:"pr"});try{const r=await this.octokit.rest.search.issuesAndPullRequests({q:t,sort:e.sort||"created",order:e.order||"desc",per_page:e.per_page||30,page:e.page||1});return this.logger.apiResponse("GET","/search/issues",r.status,Date.now()-o),{total_count:r.data.total_count,incomplete_results:r.data.incomplete_results,items:r.data.items.map(t=>({id:t.id,number:t.number,title:t.title,body:t.body,html_url:t.html_url,state:t.state,created_at:t.created_at,updated_at:t.updated_at,closed_at:t.closed_at,user:{login:t.user.login,avatar_url:t.user.avatar_url},repository:t.repository_url?{name:t.repository_url.split("/").slice(-1)[0],full_name:t.repository_url.split("/").slice(-2).join("/")}:null}))}}catch(r){throw this.logger.apiResponse("GET","/search/issues",r.status||"error",Date.now()-o),console.error("Failed to search pull requests:",r),r}}logout(){this.logger.auth("Logging out and clearing stored token"),this.octokit=null,this.isAuthenticated=!1,this.tokenType=null,this.permissions=null,c.clearToken();try{const{default:t}=o(18354);t.clearAllBranchContext()}catch(t){sessionStorage.removeItem("sgex_branch_context")}}async getRepositoryForks(t,e){let o=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};const r=Date.now();this.logger.debug("Fetching repository forks",{owner:t,repo:e,options:o});try{const s=this.isAuth()?this.octokit:await this.createOctokitInstance();this.logger.apiCall("GET","/repos/".concat(t,"/").concat(e,"/forks"),o);const{data:a}=await s.rest.repos.listForks({owner:t,repo:e,sort:"newest",per_page:o.per_page||100,page:o.page||1}),n=Date.now()-r;return this.logger.apiResponse("GET","/repos/".concat(t,"/").concat(e,"/forks"),200,n,{forkCount:a.length}),this.logger.performance("Repository forks fetch",n),a}catch(s){const o=Date.now()-r;throw this.logger.apiError("GET","/repos/".concat(t,"/").concat(e,"/forks"),s),this.logger.performance("Repository forks fetch (failed)",o),console.error("Failed to fetch forks for ".concat(t,"/").concat(e,":"),s),s}}}}}]);