# üö® COPILOT PROHIBITION WARNING üö®
# 
# THIS FILE IS ABSOLUTELY CRITICAL TO GITHUB PAGES DEPLOYMENT INFRASTRUCTURE
# 
# ‚õî COPILOT AGENTS ARE STRICTLY PROHIBITED FROM MAKING ANY CHANGES TO THIS FILE
# ‚õî WITHOUT EXPLICIT WRITTEN CONSENT FROM THE REPOSITORY OWNER (@litlfred)
# 
# This workflow controls branch deployment to GitHub Pages. Any unauthorized 
# changes can break the entire deployment system for all users and branches.
# 
# üîí REQUIRED PROCESS FOR CHANGES:
# 1. Request explicit consent from @litlfred in a GitHub comment
# 2. Wait for written approval before making ANY changes  
# 3. Document the explicit consent in the commit message
# 4. Test extensively in a separate environment before merging
# 
# Violation of this prohibition will result in immediate reversion and 
# potential blocking of copilot access to this repository.
# 
# üö® END PROHIBITION WARNING üö®

name: Deploy Feature Branch

on:
  # Manual trigger - primary way to deploy branches
  workflow_dispatch:
    inputs:
      branch:
        description: 'Branch to build and deploy (defaults to current branch)'
        required: false
        default: ''
      force_deployment:
        description: 'Force deployment even if no changes detected'
        required: false
        type: boolean
        default: false
  # Workflow call - allows other workflows to trigger this deployment
  workflow_call:
    inputs:
      branch:
        description: 'Branch to build and deploy (defaults to current branch)'
        required: false
        type: string
        default: ''
      force_deployment:
        description: 'Force deployment even if no changes detected'
        required: false
        type: boolean
        default: false
  # Trigger for pull request events to ensure copilot and external contributions trigger workflows
  pull_request:
    types: [opened, synchronize, reopened]
    branches: [main]  # Only for PRs targeting main branch
    paths:
      - 'src/**'
      - 'public/**'
      - 'package.json'
      - 'package-lock.json'
      - '.github/workflows/branch-deployment.yml'

permissions:
  contents: write
  pages: write
  id-token: write
  pull-requests: write

concurrency:
  group: "branch-deployment-${{ github.event.inputs.branch || github.head_ref || github.ref_name }}"
  cancel-in-progress: false

jobs:
  deploy-branch:
    runs-on: ubuntu-latest
    environment: 
      name: ${{ (github.event_name == 'workflow_dispatch' && (github.event.inputs.branch == 'main' || github.ref_name == 'main')) && 'production-pages' || 'branch-preview' }}
    outputs:
      branch_name: ${{ steps.deployment_info.outputs.branch_name }}
      target_directory: ${{ steps.deployment_info.outputs.target_directory }}
      branch_url: ${{ steps.deployment_info.outputs.branch_url }}
      commit_sha: ${{ steps.deployment_info.outputs.commit_sha }}
      deployment_status: ${{ steps.deployment_info.outputs.deployment_status }}
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v5
        with:
          ref: ${{ github.event.inputs.branch || github.head_ref || github.ref }}
          fetch-depth: 0

      - name: Find associated PR
        id: find_pr
        uses: actions/github-script@v8
        continue-on-error: true
        with:
          result-encoding: string
          script: |
            const branchName = '${{ github.event.inputs.branch || github.head_ref || github.ref_name }}';
            try {
              const { data: prs } = await github.rest.pulls.list({
                owner: context.repo.owner,
                repo: context.repo.repo,
                state: 'open',
                head: `${context.repo.owner}:${branchName}`
              });
              if (prs.length > 0) {
                console.log(`Found PR #${prs[0].number}`);
                return prs[0].number.toString();
              }
              console.log('No PR found');
              return '';
            } catch (error) {
              console.error('Error finding PR:', error);
              return '';
            }

      - name: Update PR comment - Build Started
        if: steps.find_pr.outputs.result != ''
        continue-on-error: true
        run: |
          # Calculate branch URL for PR comment
          branch_name="${{ github.event.inputs.branch || github.head_ref || github.ref_name }}"
          if [[ "$branch_name" == "main" ]]; then
            public_url="/sgex/main/"
          else
            safe_branch_name=$(echo "$branch_name" | tr '/' '-')
            public_url="/sgex/${safe_branch_name}/"
          fi
          branch_url="https://${{ github.repository_owner }}.github.io${public_url}"
          
          python3 scripts/manage-pr-comment.py \
            --token "${{ secrets.GITHUB_TOKEN }}" \
            --repo "${{ github.repository }}" \
            --pr "${{ steps.find_pr.outputs.result }}" \
            --action-id "${{ github.run_id }}" \
            --stage "started" \
            --data "{\"commit_sha\":\"${{ github.sha }}\",\"branch_name\":\"$branch_name\",\"commit_url\":\"https://github.com/${{ github.repository }}/commit/${{ github.sha }}\",\"workflow_url\":\"https://github.com/${{ github.repository }}/actions/runs/${{ github.run_id }}\",\"branch_url\":\"$branch_url\"}"

      - name: Determine branch information
        id: branch_info
        shell: bash
        run: |
          set -e
          
          # Determine the branch being deployed
          if [[ -n "${{ github.event.inputs.branch }}" ]]; then
            branch_name="${{ github.event.inputs.branch }}"
            echo "Using manual input branch: $branch_name"
          elif [[ -n "${{ github.head_ref }}" ]]; then
            branch_name="${{ github.head_ref }}"
            echo "Using pull request branch: $branch_name"
          else
            branch_name="${{ github.ref_name }}"
            echo "Using current branch: $branch_name"
          fi
          
          echo "branch_name=$branch_name" >> $GITHUB_OUTPUT
          echo "Building and deploying branch: $branch_name"

      - name: Determine PUBLIC_URL and branch URL
        id: public_url
        run: |
          branch_name="${{ steps.branch_info.outputs.branch_name }}"
          if [[ "$branch_name" == "main" ]]; then
            public_url="/sgex/main/"
          else
            safe_branch_name=$(echo "$branch_name" | tr '/' '-')
            public_url="/sgex/${safe_branch_name}/"
          fi
          export PUBLIC_URL="$public_url"
          echo "public_url=$public_url" >> $GITHUB_OUTPUT
          echo "Determined PUBLIC_URL: $public_url"
          
          # Also calculate the full branch URL for PR comments
          branch_url="https://${{ github.repository_owner }}.github.io${public_url}"
          echo "branch_url=$branch_url" >> $GITHUB_OUTPUT
          echo "Branch URL: $branch_url"

      - name: Configure git user
        shell: bash
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
        
      - name: Setup Node.js
        uses: actions/setup-node@v5
        with:
          node-version: '20'
          cache: 'npm'
          
      - name: Install dependencies
        run: npm ci --legacy-peer-deps
        continue-on-error: false

      - name: Update PR comment - Environment Setup Complete
        if: steps.find_pr.outputs.result != ''
        continue-on-error: true
        run: |
          python3 scripts/manage-pr-comment.py \
            --token "${{ secrets.GITHUB_TOKEN }}" \
            --repo "${{ github.repository }}" \
            --pr "${{ steps.find_pr.outputs.result }}" \
            --action-id "${{ github.run_id }}" \
            --stage "setup" \
            --data "{\"commit_sha\":\"${{ github.sha }}\",\"branch_name\":\"${{ steps.branch_info.outputs.branch_name }}\",\"commit_url\":\"https://github.com/${{ github.repository }}/commit/${{ github.sha }}\",\"workflow_url\":\"https://github.com/${{ github.repository }}/actions/runs/${{ github.run_id }}\",\"branch_url\":\"${{ steps.public_url.outputs.branch_url }}\"}"

      - name: Skip QA Generation for Branch Deployment
        run: |
          echo "‚ÑπÔ∏è  Skipping QA report and issues analysis generation for branch deployment"
          echo "These reports are generated during main branch CI/CD and are not needed for preview deployments"
          echo "This prevents merge conflicts when multiple branches deploy simultaneously to gh-pages"


      - name: Update PR comment - Building Application
        if: steps.find_pr.outputs.result != ''
        continue-on-error: true
        run: |
          # Calculate the full branch URL based on PUBLIC_URL
          public_url="${{ steps.public_url.outputs.public_url }}"
          branch_url="https://${{ github.repository_owner }}.github.io${public_url}"
          
          python3 scripts/manage-pr-comment.py \
            --token "${{ secrets.GITHUB_TOKEN }}" \
            --repo "${{ github.repository }}" \
            --pr "${{ steps.find_pr.outputs.result }}" \
            --action-id "${{ github.run_id }}" \
            --stage "building" \
            --data "{\"commit_sha\":\"${{ github.sha }}\",\"branch_name\":\"${{ steps.branch_info.outputs.branch_name }}\",\"commit_url\":\"https://github.com/${{ github.repository }}/commit/${{ github.sha }}\",\"workflow_url\":\"https://github.com/${{ github.repository }}/actions/runs/${{ github.run_id }}\",\"branch_url\":\"$branch_url\"}"

      - name: Build branch-specific React app
        continue-on-error: false
        run: |
          echo "Building with PUBLIC_URL: ${{ steps.public_url.outputs.public_url }}"
          echo "Building with REACT_APP_GITHUB_REF_NAME: ${{ steps.branch_info.outputs.branch_name }}"
          
          # Build the React app
          npm run build
        env:
          CI: false
          ESLINT_NO_DEV_ERRORS: true
          GENERATE_SOURCEMAP: false
          PUBLIC_URL: ${{ steps.public_url.outputs.public_url }}
          GITHUB_REF_NAME: ${{ steps.branch_info.outputs.branch_name }}
          REACT_APP_GITHUB_REF_NAME: ${{ steps.branch_info.outputs.branch_name }}

      - name: Validate branch directory safety
        id: validate_branch
        shell: bash
        run: |
          set -e
          
          # Get and sanitize branch name
          branch="${{ steps.branch_info.outputs.branch_name }}"
          echo "Processing branch: $branch"
          
          # Critical validation: reject empty or whitespace-only branch names
          if [[ -z "$branch" ]] || [[ "$branch" =~ ^[[:space:]]*$ ]]; then
            echo "ERROR: Branch name is empty or contains only whitespace"
            exit 1
          fi
          
          # Validate branch name (no dangerous characters)
          if [[ "$branch" =~ [^a-zA-Z0-9._/-] ]]; then
            echo "ERROR: Branch name contains unsafe characters: $branch"
            exit 1
          fi
          
          # Replace slashes with dashes for safe directory names
          safe_branch_name=$(echo "$branch" | tr '/' '-')
          echo "Safe branch name: $safe_branch_name"
          
          # Critical validation: reject problematic directory names
          if [[ -z "$safe_branch_name" ]] || [[ "$safe_branch_name" == "." ]] || [[ "$safe_branch_name" == ".." ]]; then
            echo "ERROR: Branch name resolves to unsafe directory name: '$safe_branch_name'"
            exit 1
          fi
          
          # Reject names that could conflict with git or system directories
          if [[ "$safe_branch_name" =~ ^\.(git|github)$ ]]; then
            echo "ERROR: Branch name conflicts with reserved directory: $safe_branch_name"
            exit 1
          fi
          
          # Use simplified path structure: main goes to /main/, others to /safe-branch-name/
          if [[ "$branch" == "main" ]]; then
            target_subdir="main"
          else
            target_subdir="$safe_branch_name"
          fi
          
          # Calculate target directory path
          repo_root="$(pwd)"
          target_dir="$repo_root/$target_subdir"
          
          echo "Target directory: $target_dir"
          
          # Critical safety validation
          if [[ "$target_dir" != "$repo_root"* ]]; then
            echo "ERROR: Target directory is outside repository root"
            exit 1
          fi
          
          if [[ ${#target_dir} -le ${#repo_root} ]]; then
            echo "ERROR: Target directory path is not longer than repository root"
            exit 1
          fi
          
          # Additional safety: ensure target is exactly one level deeper
          expected_path="$repo_root/$target_subdir"
          if [[ "$target_dir" != "$expected_path" ]]; then
            echo "ERROR: Target directory does not match expected path"
            exit 1
          fi
          
          # Critical safety: ensure target subdirectory doesn't resolve to root
          if [[ "$target_subdir" == "." ]] || [[ -z "$target_subdir" ]]; then
            echo "ERROR: Target subdirectory would resolve to repository root"
            echo "This would overwrite the landing page - deployment aborted"
            exit 1
          fi
          
          echo "‚úÖ Branch directory validation passed"
          echo "branch_dir=$target_dir" >> "$GITHUB_OUTPUT"
          echo "branch_name=$branch" >> "$GITHUB_OUTPUT"
          echo "safe_branch_name=$safe_branch_name" >> "$GITHUB_OUTPUT"
          echo "target_subdir=$target_subdir" >> "$GITHUB_OUTPUT"

      - name: Checkout gh-pages branch
        shell: bash
        run: |
          set -e
          
          # Save the Python script before switching branches
          mkdir -p /tmp/sgex-scripts
          cp scripts/manage-pr-comment.py /tmp/sgex-scripts/manage-pr-comment.py
          
          # Check if gh-pages branch exists
          if git show-ref --verify --quiet refs/remotes/origin/gh-pages; then
            echo "Checking out existing gh-pages branch"
            git stash -u -m "Stash before gh-pages checkout" || echo "Nothing to stash"
            git clean -fd -e node_modules
            git checkout gh-pages
          else
            echo "Creating new gh-pages branch"
            git checkout --orphan gh-pages
            git rm -rf .
            echo "# GitHub Pages" > README.md
            git add README.md
            git commit -m "Initial gh-pages branch"
            git push origin gh-pages
          fi

      - name: Update PR comment - Deploying to GitHub Pages
        if: steps.find_pr.outputs.result != ''
        continue-on-error: true
        run: |
          python3 /tmp/sgex-scripts/manage-pr-comment.py \
            --token "${{ secrets.GITHUB_TOKEN }}" \
            --repo "${{ github.repository }}" \
            --pr "${{ steps.find_pr.outputs.result }}" \
            --action-id "${{ github.run_id }}" \
            --stage "deploying" \
            --data "{\"commit_sha\":\"${{ github.sha }}\",\"branch_name\":\"${{ steps.branch_info.outputs.branch_name }}\",\"commit_url\":\"https://github.com/${{ github.repository }}/commit/${{ github.sha }}\",\"workflow_url\":\"https://github.com/${{ github.repository }}/actions/runs/${{ github.run_id }}\",\"branch_url\":\"${{ steps.public_url.outputs.branch_url }}\"}"

      - name: Clean old deployment for this branch
        shell: bash
        run: |
          set -e
          
          target_subdir="${{ steps.validate_branch.outputs.target_subdir }}"
          
          echo "Cleaning old deployment for: $target_subdir"
          
          # Additional safety: ensure we're only removing the specific branch directory
          if [[ "$target_subdir" == "." || "$target_subdir" == ".." || -z "$target_subdir" ]]; then
            echo "ERROR: Invalid target subdirectory: '$target_subdir'"
            exit 1
          fi
          
          # Use git to safely remove the specific branch directory only
          if [[ -d "$target_subdir" ]]; then
            echo "Removing existing deployment: $target_subdir"
            git rm -rf "$target_subdir" 2>/dev/null || echo "Directory didn't exist in git"
          else
            echo "No existing deployment to clean"
          fi

      - name: Copy new build to branch directory
        shell: bash
        run: |
          set -e
          
          target_subdir="${{ steps.validate_branch.outputs.target_subdir }}"
          
          echo "Copying new build to branch directory: $target_subdir"
          
          # Create branch directory and copy build (excluding 404.html - not needed for branch deployments)
          mkdir -p "$target_subdir"
          cp -a build/. "$target_subdir/"
          
          # Remove 404.html from branch deployment - root 404.html handles all routing
          if [[ -f "$target_subdir/404.html" ]]; then
            echo "Removing redundant 404.html from branch deployment (root 404.html handles routing)"
            rm "$target_subdir/404.html"
          fi
          
          # Ensure .nojekyll file exists in root to disable Jekyll processing for entire gh-pages
          if [[ ! -f ".nojekyll" ]]; then
            echo "Creating .nojekyll file to disable Jekyll processing"
            touch .nojekyll
          fi
          
          # Verify index.html exists
          if [[ ! -f "$target_subdir/index.html" ]]; then
            echo "ERROR: index.html not found in build output"
            exit 1
          fi
          
          echo "‚úÖ Build copied successfully to $target_subdir"

      - name: Stage and commit changes
        shell: bash
        run: |
          set -e
          
          # Critical safety check: ensure we're on gh-pages branch
          current_branch=$(git branch --show-current)
          echo "Current branch: $current_branch"
          
          if [[ "$current_branch" != "gh-pages" ]]; then
            echo "ERROR: Not on gh-pages branch! Current branch: $current_branch"
            exit 1
          fi
          
          echo "Staging changes for commit"
          
          # Clean up any build directory and node_modules that shouldn't be in gh-pages root
          if [[ -d "build" ]]; then
            echo "Removing build directory from gh-pages..."
            rm -rf build
          fi
          
          if [[ -d "node_modules" ]]; then
            echo "Removing node_modules directory from gh-pages..."
            rm -rf node_modules
          fi
          
          # Add all changes initially
          git add -A
          
          # Check if there are changes to commit
          has_changes=false
          if git diff --cached --quiet; then
            if [[ "${{ github.event.inputs.force_deployment }}" == "true" ]]; then
              echo "No changes detected, but force deployment requested - will create empty commit"
              has_changes=true
            else
              echo "No changes to commit and force deployment not requested"
              exit 0
            fi
          else
            echo "Changes detected for commit"
            has_changes=true
          fi
          
          # Enhanced commit and push with robust git operations
          if [[ "$has_changes" == "true" ]]; then
            max_retries=3
            retry_count=0
            success=false
            
            # Function to clean git state
            clean_git_state() {
              echo "üßπ Cleaning git state..."
              # Abort any ongoing rebase or merge
              git rebase --abort 2>/dev/null || true
              git merge --abort 2>/dev/null || true
              # Reset to clean state while preserving staged changes
              git reset --mixed HEAD 2>/dev/null || true
              # Re-stage our changes
              git add -A
              echo "‚úÖ Git state cleaned"
            }
            
            # Function to perform robust pull with rebase
            robust_pull_rebase() {
              echo "üîÑ Performing robust pull with rebase..."
              
              # Fetch latest changes
              if ! git fetch origin gh-pages; then
                echo "‚ùå Failed to fetch from origin"
                return 1
              fi
              
              # Check if we're behind remote
              local_commit=$(git rev-parse HEAD)
              remote_commit=$(git rev-parse origin/gh-pages)
              
              if [[ "$local_commit" == "$remote_commit" ]]; then
                echo "‚úÖ Already up to date with remote"
                return 0
              fi
              
              echo "üìä Local: $local_commit"
              echo "üìä Remote: $remote_commit"
              
              # Perform rebase with conflict handling
              if git rebase origin/gh-pages; then
                echo "‚úÖ Rebase successful"
                return 0
              else
                echo "‚ö†Ô∏è Rebase conflicts detected, analyzing..."
                
                # Check for conflicts
                if git status --porcelain | grep -q "^UU\|^AA\|^DD"; then
                  echo "üîç Found unresolved conflicts:"
                  git status --porcelain | grep "^UU\|^AA\|^DD" || true
                  
                  # For branch deployments, try to auto-resolve by accepting our version
                  # since each branch deploys to its own directory
                  echo "üîß Attempting automatic conflict resolution..."
                  
                  # Get list of conflicted files
                  conflicted_files=$(git diff --name-only --diff-filter=U 2>/dev/null || true)
                  
                  if [[ -n "$conflicted_files" ]]; then
                    echo "üìù Conflicted files:"
                    echo "$conflicted_files"
                    
                    # For deployment conflicts, use our version (--ours)
                    echo "üîß Resolving conflicts by accepting our changes..."
                    git checkout --ours . 2>/dev/null || true
                    git add -A
                    
                    # Continue rebase
                    if git rebase --continue; then
                      echo "‚úÖ Automatic conflict resolution successful"
                      return 0
                    else
                      echo "‚ùå Failed to continue rebase after conflict resolution"
                      git rebase --abort
                      return 1
                    fi
                  else
                    echo "‚ùå No conflicted files found but rebase failed"
                    git rebase --abort
                    return 1
                  fi
                else
                  echo "‚ùå Rebase failed but no conflicts detected"
                  git rebase --abort
                  return 1
                fi
              fi
            }
            
            # Function to perform robust push
            robust_push() {
              echo "üöÄ Performing robust push..."
              
              # Try push with lease for safety
              if git push --force-with-lease origin gh-pages; then
                echo "‚úÖ Push successful with lease protection"
                return 0
              else
                echo "‚ö†Ô∏è Force-with-lease push failed, trying regular push..."
                if git push origin gh-pages; then
                  echo "‚úÖ Regular push successful"
                  return 0
                else
                  echo "‚ùå Push failed"
                  return 1
                fi
              fi
            }
            
            while [[ $retry_count -lt $max_retries ]] && [[ "$success" == "false" ]]; do
              retry_count=$((retry_count + 1))
              echo "üîÑ Deployment attempt $retry_count of $max_retries"
              
              # Clean git state if this is a retry
              if [[ $retry_count -gt 1 ]]; then
                clean_git_state
              fi
              
              # Commit changes first
              commit_created=false
              if git diff --cached --quiet; then
                if [[ "${{ github.event.inputs.force_deployment }}" == "true" ]]; then
                  echo "Creating empty commit for force deployment"
                  git commit --allow-empty -m "üöÄ Force deploy ${{ steps.branch_info.outputs.branch_name }} branch preview
                  
                  - Force deployment requested by user
                  - Deployed at $(date -u '+%Y-%m-%d %H:%M:%S UTC')
                  - Commit: ${{ github.sha }}
                  - Attempt: $retry_count/$max_retries"
                  commit_created=true
                else
                  echo "No changes to commit after sync"
                  success=true
                  break
                fi
              else
                echo "Committing changes..."
                git commit -m "üöÄ Deploy ${{ steps.branch_info.outputs.branch_name }} branch preview
                
                - Updated branch preview for ${{ steps.branch_info.outputs.branch_name }}
                - Deployed at $(date -u '+%Y-%m-%d %H:%M:%S UTC')
                - Commit: ${{ github.sha }}
                - Attempt: $retry_count/$max_retries"
                commit_created=true
              fi
              
              # Only proceed with sync and push if we have changes to push
              if [[ "$commit_created" == "true" ]]; then
                # Perform robust pull with rebase
                if robust_pull_rebase; then
                  echo "‚úÖ Successfully synced with remote"
                  
                  # Perform robust push
                  if robust_push; then
                    echo "‚úÖ Push successful on attempt $retry_count"
                    success=true
                  else
                    echo "‚ö†Ô∏è Push failed on attempt $retry_count"
                    if [[ $retry_count -lt $max_retries ]]; then
                      # Brief delay before retry
                      sleep_time=$((retry_count * 2))
                      echo "üí§ Waiting ${sleep_time} seconds before next attempt..."
                      sleep $sleep_time
                    fi
                  fi
                else
                  echo "‚ö†Ô∏è Failed to sync with remote on attempt $retry_count"
                  if [[ $retry_count -lt $max_retries ]]; then
                    # Brief delay before retry
                    sleep_time=$((retry_count * 2))
                    echo "üí§ Waiting ${sleep_time} seconds before next attempt..."
                    sleep $sleep_time
                  fi
                fi
              fi
            done
            
            if [[ "$success" == "false" ]]; then
              echo "‚ùå Failed to deploy after $max_retries attempts"
              echo "This may indicate:"
              echo "  - Persistent network issues"
              echo "  - Repository access problems"
              echo "  - Concurrent deployment conflicts"
              echo "  - Git repository corruption"
              echo ""
              echo "üîç Final git status:"
              git status --porcelain || true
              echo ""
              echo "üìä Remote status:"
              git fetch origin gh-pages 2>/dev/null || true
              git log --oneline -5 origin/gh-pages 2>/dev/null || true
              exit 1
            fi
          fi
          
          echo "‚úÖ Deployment completed successfully"

      - name: Update PR comment - Verifying Deployment
        if: steps.find_pr.outputs.result != ''
        continue-on-error: true
        run: |
          target_subdir="${{ steps.validate_branch.outputs.target_subdir }}"
          branch_url="https://${{ github.repository_owner }}.github.io/sgex/$target_subdir/"
          python3 /tmp/sgex-scripts/manage-pr-comment.py \
            --token "${{ secrets.GITHUB_TOKEN }}" \
            --repo "${{ github.repository }}" \
            --pr "${{ steps.find_pr.outputs.result }}" \
            --action-id "${{ github.run_id }}" \
            --stage "verifying" \
            --data "{\"commit_sha\":\"${{ github.sha }}\",\"branch_name\":\"${{ steps.branch_info.outputs.branch_name }}\",\"commit_url\":\"https://github.com/${{ github.repository }}/commit/${{ github.sha }}\",\"workflow_url\":\"https://github.com/${{ github.repository }}/actions/runs/${{ github.run_id }}\",\"branch_url\":\"$branch_url\"}"

      - name: Verify deployment accessibility
        id: verify_deployment
        shell: bash
        run: |
          set -e
          
          target_subdir="${{ steps.validate_branch.outputs.target_subdir }}"
          branch_url="https://${{ github.repository_owner }}.github.io/sgex/$target_subdir/"
          max_wait_time=300  # 5 minutes maximum wait
          check_interval=15  # Check every 15 seconds
          elapsed_time=0
          
          echo "üîç Verifying deployment accessibility at: $branch_url"
          echo "‚è±Ô∏è  Will check every ${check_interval}s for up to ${max_wait_time}s"
          
          while [[ $elapsed_time -lt $max_wait_time ]]; do
            echo "üì° Checking deployment accessibility (${elapsed_time}s elapsed)..."
            
            # Use curl to check if the deployment is accessible
            if curl -f -s -I "$branch_url" >/dev/null 2>&1; then
              echo "‚úÖ Deployment is accessible at $branch_url"
              echo "‚è±Ô∏è  Total wait time: ${elapsed_time}s"
              echo "deployment_accessible=true" >> $GITHUB_OUTPUT
              echo "wait_time=$elapsed_time" >> $GITHUB_OUTPUT
              break
            else
              echo "‚è≥ Deployment not yet accessible, waiting..."
              sleep $check_interval
              elapsed_time=$((elapsed_time + check_interval))
            fi
          done
          
          # Final check
          if [[ $elapsed_time -ge $max_wait_time ]]; then
            echo "‚ö†Ô∏è Deployment verification timed out after ${max_wait_time}s"
            echo "üö® GitHub Pages content server may be experiencing delays"
            echo "üìù The deployment was uploaded successfully but may take additional time to be accessible"
            echo "deployment_accessible=timeout" >> $GITHUB_OUTPUT
            echo "wait_time=$max_wait_time" >> $GITHUB_OUTPUT
          fi

      - name: Output deployment info
        id: deployment_info
        shell: bash
        run: |
          target_subdir="${{ steps.validate_branch.outputs.target_subdir }}"
          branch_name="${{ steps.branch_info.outputs.branch_name }}"
          commit_sha="${{ github.sha }}"
          branch_url="https://${{ github.repository_owner }}.github.io/sgex/$target_subdir/"
          
          echo "üéâ Branch Deployment Summary:"
          echo "- Branch: $branch_name"
          echo "- Target Directory: $target_subdir"
          echo "- Branch Preview: $branch_url"
          echo "- Commit: $commit_sha"
          echo ""
          echo "‚ÑπÔ∏è  Note: Landing page deployment is handled separately"
          
          # GitHub Actions outputs
          echo "branch_name=$branch_name" >> $GITHUB_OUTPUT
          echo "target_directory=$target_subdir" >> $GITHUB_OUTPUT
          echo "branch_url=$branch_url" >> $GITHUB_OUTPUT
          echo "commit_sha=$commit_sha" >> $GITHUB_OUTPUT
          echo "deployment_status=success" >> $GITHUB_OUTPUT

      - name: Output deployment failure info
        id: deployment_failure_info
        if: always() && failure()
        shell: bash
        run: |
          branch_name="${{ github.event.inputs.branch || github.head_ref || github.ref_name }}"
          commit_sha="${{ github.sha }}"
          
          echo "üö® Branch Deployment Failed:"
          echo "- Branch: $branch_name"
          echo "- Commit: $commit_sha"
          echo "- Check build logs for details"
          
          # GitHub Actions outputs for failure case
          echo "branch_name=$branch_name" >> $GITHUB_OUTPUT
          echo "commit_sha=$commit_sha" >> $GITHUB_OUTPUT
          echo "deployment_status=failure" >> $GITHUB_OUTPUT

      - name: Comment on associated PR (Success)
        if: always() && steps.deployment_info.outputs.deployment_status == 'success' && steps.find_pr.outputs.result != ''
        continue-on-error: true
        run: |
          target_subdir="${{ steps.validate_branch.outputs.target_subdir }}"
          branch_url="https://${{ github.repository_owner }}.github.io/sgex/$target_subdir/"
          python3 /tmp/sgex-scripts/manage-pr-comment.py \
            --token "${{ secrets.GITHUB_TOKEN }}" \
            --repo "${{ github.repository }}" \
            --pr "${{ steps.find_pr.outputs.result }}" \
            --action-id "${{ github.run_id }}" \
            --stage "success" \
            --data "{\"commit_sha\":\"${{ github.sha }}\",\"branch_name\":\"${{ steps.branch_info.outputs.branch_name }}\",\"commit_url\":\"https://github.com/${{ github.repository }}/commit/${{ github.sha }}\",\"workflow_url\":\"https://github.com/${{ github.repository }}/actions/runs/${{ github.run_id }}\",\"branch_url\":\"$branch_url\"}"

      - name: Comment on associated PR (Failure)
        if: always() && failure() && steps.find_pr.outputs.result != ''
        continue-on-error: true
        run: |
          python3 /tmp/sgex-scripts/manage-pr-comment.py \
            --token "${{ secrets.GITHUB_TOKEN }}" \
            --repo "${{ github.repository }}" \
            --pr "${{ steps.find_pr.outputs.result }}" \
            --action-id "${{ github.run_id }}" \
            --stage "failure" \
            --data "{\"commit_sha\":\"${{ github.sha }}\",\"branch_name\":\"${{ github.event.inputs.branch || github.head_ref || github.ref_name }}\",\"commit_url\":\"https://github.com/${{ github.repository }}/commit/${{ github.sha }}\",\"workflow_url\":\"https://github.com/${{ github.repository }}/actions/runs/${{ github.run_id }}\",\"error_message\":\"Build or deployment failed. Check logs for details.\"}"