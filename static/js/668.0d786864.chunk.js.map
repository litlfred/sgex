{"version":3,"file":"static/js/668.0d786864.chunk.js","mappings":"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","sources":["dak/faq/types/QuestionDefinition.js","dak/faq/registry/ParameterRegistryService.js","dak/faq/storage/Storage.js","dak/faq/engine/FAQExecutionEngine.js"],"sourcesContent":["/**\n * Core types and interfaces for DAK FAQ system\n */\n\n/**\n * Question hierarchy levels\n */\nexport const QuestionLevel = {\n  DAK: 'dak',\n  COMPONENT: 'component', \n  ASSET: 'asset'\n};\n\n/**\n * Question metadata definition\n */\nexport class QuestionDefinition {\n  constructor({\n    id,\n    level,\n    title,\n    description,\n    parameters = [],\n    tags = [],\n    version = '1.0.0',\n    isTemplate = false,\n    componentTypes = [],\n    assetTypes = []\n  }) {\n    this.id = id;\n    this.level = level;\n    this.title = title;\n    this.description = description;\n    this.parameters = parameters;\n    this.tags = tags;\n    this.version = version;\n    this.isTemplate = isTemplate;\n    this.componentTypes = componentTypes;\n    this.assetTypes = assetTypes;\n  }\n}\n\n/**\n * Parameter definition for questions\n */\nexport class ParameterDefinition {\n  constructor({\n    name,\n    type = 'string',\n    required = false,\n    description = '',\n    defaultValue = null,\n    validation = {}\n  }) {\n    this.name = name;\n    this.type = type;\n    this.required = required;\n    this.description = description;\n    this.defaultValue = defaultValue;\n    this.validation = validation;\n  }\n}\n\n/**\n * Question execution context\n */\nexport class QuestionContext {\n  constructor({\n    repository,\n    locale = 'en_US',\n    branch = 'main',\n    user = null,\n    assetFile = null,\n    componentType = null,\n    storage = null\n  }) {\n    this.repository = repository;\n    this.locale = locale;\n    this.branch = branch;\n    this.user = user;\n    this.assetFile = assetFile;\n    this.componentType = componentType;\n    this.storage = storage;\n  }\n}\n\n/**\n * Question execution result\n */\nexport class QuestionResult {\n  constructor({\n    structured = {},\n    narrative = '',\n    warnings = [],\n    errors = [],\n    meta = {}\n  }) {\n    this.structured = structured;\n    this.narrative = narrative;\n    this.warnings = warnings;\n    this.errors = errors;\n    this.meta = meta;\n  }\n}\n\n/**\n * Cache hint for FAQ answers\n */\nexport class CacheHint {\n  constructor({\n    scope = 'repository',\n    key = '',\n    ttl = 3600, // 1 hour default\n    dependencies = []\n  }) {\n    this.scope = scope;\n    this.key = key;\n    this.ttl = ttl;\n    this.dependencies = dependencies;\n  }\n}","/**\n * Parameter registry service for DAK FAQ system\n * Manages parameter definitions and validation\n */\n\nimport yaml from 'js-yaml';\nimport { ParameterDefinition } from '../types/QuestionDefinition.js';\n\nclass ParameterRegistryService {\n  constructor() {\n    this.registry = null;\n    this.loaded = false;\n  }\n\n  /**\n   * Load parameter registry from YAML\n   * @param {string} yamlContent - YAML content as string\n   */\n  loadFromYaml(yamlContent) {\n    try {\n      this.registry = yaml.load(yamlContent);\n      this.loaded = true;\n    } catch (error) {\n      throw new Error(`Failed to parse parameter registry YAML: ${error.message}`);\n    }\n  }\n\n  /**\n   * Get parameters for a specific context\n   * @param {string} level - Question level (dak, component, asset)\n   * @param {string} type - Component or asset type\n   * @returns {ParameterDefinition[]} - Array of parameter definitions\n   */\n  getParameters(level, type = null) {\n    if (!this.loaded || !this.registry) {\n      throw new Error('Parameter registry not loaded');\n    }\n\n    const parameters = [];\n    \n    // Add global defaults\n    if (this.registry.defaults) {\n      for (const [name, config] of Object.entries(this.registry.defaults)) {\n        parameters.push(new ParameterDefinition({\n          name,\n          type: config.type,\n          required: config.required || false,\n          description: config.description || '',\n          defaultValue: config.default || null,\n          validation: config.validation || {}\n        }));\n      }\n    }\n\n    // Add level-specific parameters\n    if (this.registry[level]) {\n      if (type && this.registry[level][type]) {\n        // Type-specific parameters\n        for (const [name, config] of Object.entries(this.registry[level][type])) {\n          parameters.push(new ParameterDefinition({\n            name,\n            ...config\n          }));\n        }\n      } else if (!type) {\n        // All parameters for the level\n        for (const [paramName, config] of Object.entries(this.registry[level])) {\n          if (typeof config === 'object' && config.type) {\n            // Direct parameter definition\n            parameters.push(new ParameterDefinition({\n              name: paramName,\n              ...config\n            }));\n          }\n        }\n      }\n    }\n\n    // Remove duplicates (later definitions override earlier ones)\n    const uniqueParams = new Map();\n    parameters.forEach(param => {\n      uniqueParams.set(param.name, param);\n    });\n\n    return Array.from(uniqueParams.values());\n  }\n\n  /**\n   * Validate parameters against registry\n   * @param {Object} parameters - Parameters to validate\n   * @param {string} level - Question level\n   * @param {string} type - Component or asset type\n   * @returns {Object} - Validation result with normalized parameters and errors\n   */\n  validateParameters(parameters, level, type = null) {\n    const definitions = this.getParameters(level, type);\n    const normalized = {};\n    const errors = [];\n\n    // Check required parameters\n    for (const definition of definitions) {\n      const value = parameters[definition.name];\n      \n      if (definition.required && (value === undefined || value === null)) {\n        errors.push(`Required parameter '${definition.name}' is missing`);\n        continue;\n      }\n\n      // Use default value if not provided\n      const finalValue = value !== undefined ? value : definition.defaultValue;\n      \n      // Type validation\n      if (finalValue !== null && finalValue !== undefined) {\n        const typeError = this.validateParameterType(finalValue, definition);\n        if (typeError) {\n          errors.push(`Parameter '${definition.name}': ${typeError}`);\n          continue;\n        }\n\n        // Custom validation\n        const validationError = this.validateParameterCustom(finalValue, definition);\n        if (validationError) {\n          errors.push(`Parameter '${definition.name}': ${validationError}`);\n          continue;\n        }\n      }\n\n      normalized[definition.name] = finalValue;\n    }\n\n    // Check for unknown parameters\n    for (const paramName of Object.keys(parameters)) {\n      if (!definitions.find(def => def.name === paramName)) {\n        errors.push(`Unknown parameter '${paramName}'`);\n      }\n    }\n\n    return {\n      normalized,\n      errors,\n      isValid: errors.length === 0\n    };\n  }\n\n  /**\n   * Validate parameter type\n   * @param {any} value - Parameter value\n   * @param {ParameterDefinition} definition - Parameter definition\n   * @returns {string|null} - Error message or null if valid\n   */\n  validateParameterType(value, definition) {\n    const expectedType = definition.type;\n    const actualType = typeof value;\n\n    switch (expectedType) {\n      case 'string':\n        if (actualType !== 'string') {\n          return `Expected string, got ${actualType}`;\n        }\n        break;\n      case 'boolean':\n        if (actualType !== 'boolean') {\n          return `Expected boolean, got ${actualType}`;\n        }\n        break;\n      case 'number':\n        if (actualType !== 'number' || isNaN(value)) {\n          return `Expected number, got ${actualType}`;\n        }\n        break;\n      case 'array':\n        if (!Array.isArray(value)) {\n          return `Expected array, got ${actualType}`;\n        }\n        break;\n      case 'object':\n        if (actualType !== 'object' || Array.isArray(value)) {\n          return `Expected object, got ${actualType}`;\n        }\n        break;\n      default:\n        return `Unknown type: ${expectedType}`;\n    }\n\n    return null;\n  }\n\n  /**\n   * Validate parameter against custom rules\n   * @param {any} value - Parameter value\n   * @param {ParameterDefinition} definition - Parameter definition\n   * @returns {string|null} - Error message or null if valid\n   */\n  validateParameterCustom(value, definition) {\n    if (!definition.validation) {\n      return null;\n    }\n\n    const validation = definition.validation;\n\n    // Pattern validation\n    if (validation.pattern && typeof value === 'string') {\n      const regex = new RegExp(validation.pattern);\n      if (!regex.test(value)) {\n        return `Value does not match pattern ${validation.pattern}`;\n      }\n    }\n\n    // Enum validation\n    if (validation.enum && Array.isArray(validation.enum)) {\n      if (!validation.enum.includes(value)) {\n        return `Value must be one of: ${validation.enum.join(', ')}`;\n      }\n    }\n\n    // Length validation\n    if (validation.minLength !== undefined && typeof value === 'string') {\n      if (value.length < validation.minLength) {\n        return `String must be at least ${validation.minLength} characters`;\n      }\n    }\n\n    if (validation.maxLength !== undefined && typeof value === 'string') {\n      if (value.length > validation.maxLength) {\n        return `String must be at most ${validation.maxLength} characters`;\n      }\n    }\n\n    // Numeric range validation\n    if (validation.min !== undefined && typeof value === 'number') {\n      if (value < validation.min) {\n        return `Number must be at least ${validation.min}`;\n      }\n    }\n\n    if (validation.max !== undefined && typeof value === 'number') {\n      if (value > validation.max) {\n        return `Number must be at most ${validation.max}`;\n      }\n    }\n\n    return null;\n  }\n\n  /**\n   * Get parameter schema for OpenAPI/JSON Schema generation\n   * @param {string} level - Question level\n   * @param {string} type - Component or asset type\n   * @returns {Object} - JSON Schema object\n   */\n  getParameterSchema(level, type = null) {\n    const definitions = this.getParameters(level, type);\n    const properties = {};\n    const required = [];\n\n    for (const definition of definitions) {\n      const property = {\n        type: definition.type,\n        description: definition.description\n      };\n\n      if (definition.defaultValue !== null) {\n        property.default = definition.defaultValue;\n      }\n\n      if (definition.validation) {\n        Object.assign(property, definition.validation);\n      }\n\n      properties[definition.name] = property;\n\n      if (definition.required) {\n        required.push(definition.name);\n      }\n    }\n\n    return {\n      type: 'object',\n      properties,\n      required\n    };\n  }\n}\n\n// Default registry content\nconst DEFAULT_REGISTRY_YAML = `\ndefaults:\n  repository:\n    type: string\n    required: true\n    description: \"Repository context (always required)\"\n  locale:\n    type: string\n    required: false\n    default: \"en_US\"\n    description: \"Locale for responses\"\n  branch:\n    type: string\n    required: false\n    default: \"main\"\n    description: \"Git branch context\"\n\ndak:\n\ncomponent:\n  businessProcess:\n    componentType:\n      type: string\n      required: true\n      default: \"businessProcess\"\n      description: \"Type of component being analyzed\"\n\nasset:\n  lesson:\n    assetFile:\n      type: string\n      required: true\n      description: \"Relative path to the lesson file\"\n`;\n\n// Singleton instance\nconst parameterRegistryService = new ParameterRegistryService();\n\n// Load default registry\nparameterRegistryService.loadFromYaml(DEFAULT_REGISTRY_YAML);\n\nexport default parameterRegistryService;","/**\n * Storage abstraction interface for FAQ questions\n * Provides unified access to file system operations for local repositories\n */\n\nexport class Storage {\n  /**\n   * Read a file from the repository\n   * @param {string} path - Relative path to the file\n   * @returns {Promise<Buffer>} - File content as Buffer\n   */\n  async readFile(path) {\n    throw new Error('readFile must be implemented by subclass');\n  }\n\n  /**\n   * Check if a file exists\n   * @param {string} path - Relative path to the file\n   * @returns {Promise<boolean>} - Whether the file exists\n   */\n  async fileExists(path) {\n    throw new Error('fileExists must be implemented by subclass');\n  }\n\n  /**\n   * List files matching a pattern\n   * @param {string} pattern - Glob pattern or prefix\n   * @param {Object} options - Options for listing\n   * @returns {Promise<string[]>} - Array of matching file paths\n   */\n  async listFiles(pattern, options = {}) {\n    throw new Error('listFiles must be implemented by subclass');\n  }\n\n  /**\n   * Get file metadata\n   * @param {string} path - Relative path to the file\n   * @returns {Promise<Object>} - File metadata (size, modified, etc.)\n   */\n  async getFileInfo(path) {\n    throw new Error('getFileInfo must be implemented by subclass');\n  }\n}\n\n/**\n * GitHub-based storage implementation\n * Provides access to files in GitHub repositories\n */\nexport class GitHubStorage extends Storage {\n  constructor(githubService, repository, branch = 'main') {\n    super();\n    this.githubService = githubService;\n    this.repository = repository;\n    this.branch = branch;\n    this.cache = new Map();\n  }\n\n  /**\n   * Parse repository string into owner/repo\n   * @param {string} repository - Repository in format \"owner/repo\" or GitHub URL\n   * @returns {Object} - {owner, repo}\n   */\n  parseRepository(repository) {\n    if (typeof repository === 'string') {\n      // Handle GitHub URLs\n      if (repository.includes('github.com')) {\n        const match = repository.match(/github\\.com\\/([^/]+)\\/([^/?#]+)/);\n        if (match) {\n          return { owner: match[1], repo: match[2].replace(/\\.git$/, '') };\n        }\n      }\n      \n      // Handle owner/repo format\n      const parts = repository.split('/');\n      if (parts.length === 2) {\n        return { owner: parts[0], repo: parts[1] };\n      }\n    }\n    \n    throw new Error(`Invalid repository format: ${repository}`);\n  }\n\n  async readFile(path) {\n    const cacheKey = `${this.repository}:${this.branch}:${path}`;\n    if (this.cache.has(cacheKey)) {\n      console.log(`GitHubStorage.readFile: Cache hit for ${path}`);\n      return this.cache.get(cacheKey);\n    }\n\n    try {\n      const { owner, repo } = this.parseRepository(this.repository);\n      console.log(`GitHubStorage.readFile: Reading file ${path} from ${owner}/${repo} (branch: ${this.branch})`);\n      \n      console.log(`GitHubStorage.readFile: About to call githubService.getFileContent...`);\n      const contentString = await this.githubService.getFileContent(owner, repo, path, this.branch);\n      console.log(`GitHubStorage.readFile: ✅ GitHub service call completed successfully`);\n      console.log(`GitHubStorage.readFile: Received content - type: ${typeof contentString}, length: ${contentString?.length || 'undefined'}`);\n      \n      // Validate that we got a string\n      if (typeof contentString !== 'string') {\n        console.error(`GitHubStorage.readFile: ❌ Expected string but got ${typeof contentString}:`, contentString);\n        throw new Error(`GitHub service returned invalid content type: ${typeof contentString}`);\n      }\n      \n      if (contentString.length === 0) {\n        console.warn(`GitHubStorage.readFile: ⚠️ Content string is empty for ${path}`);\n      }\n      \n      // Convert the decoded string content to Buffer \n      // (githubService.getFileContent already decodes the base64 content to a string)\n      console.log(`GitHubStorage.readFile: Converting string to Buffer...`);\n      const content = Buffer.from(contentString, 'utf-8');\n      console.log(`GitHubStorage.readFile: ✅ Buffer created successfully, size: ${content.length} bytes`);\n      \n      this.cache.set(cacheKey, content);\n      console.log(`GitHubStorage.readFile: ✅ Successfully read file ${path}, cached and returning content`);\n      console.log(`GitHubStorage.readFile: Content preview (first 200 chars):`, contentString.substring(0, 200));\n      return content;\n    } catch (error) {\n      console.error(`GitHubStorage.readFile: ❌ Failed to read file ${path}:`, error);\n      console.error(`GitHubStorage.readFile: Error details:`, {\n        message: error.message,\n        name: error.name,\n        stack: error.stack?.substring(0, 500)\n      });\n      throw new Error(`Failed to read file ${path}: ${error.message}`);\n    }\n  }\n\n  async fileExists(path) {\n    try {\n      console.log(`GitHubStorage.fileExists: Checking if file exists: ${path}`);\n      console.log(`GitHubStorage.fileExists: Repository: ${this.repository}, Branch: ${this.branch}`);\n      \n      // Validate repository format before making API call\n      const { owner, repo } = this.parseRepository(this.repository);\n      console.log(`GitHubStorage.fileExists: Parsed repository - owner: ${owner}, repo: ${repo}`);\n      \n      // Check authentication status\n      if (this.githubService && this.githubService.isAuth) {\n        console.log(`GitHubStorage.fileExists: Authentication status: ${this.githubService.isAuth()}`);\n      } else {\n        console.log(`GitHubStorage.fileExists: GitHub service not available or no auth method`);\n      }\n      \n      console.log(`GitHubStorage.fileExists: About to call readFile...`);\n      const content = await this.readFile(path);\n      console.log(`GitHubStorage.fileExists: readFile completed successfully for ${path}, content size: ${content?.length || 'undefined'}`);\n      console.log(`GitHubStorage.fileExists: File ${path} exists - returning true`);\n      return true;\n    } catch (error) {\n      console.error(`GitHubStorage.fileExists: readFile failed for ${path}:`, error.message);\n      console.error(`GitHubStorage.fileExists: Full error details:`, {\n        name: error.name,\n        message: error.message,\n        stack: error.stack?.substring(0, 300)\n      });\n      console.log(`GitHubStorage.fileExists: File ${path} does not exist - returning false`);\n      return false;\n    }\n  }\n\n  async listFiles(pattern, options = {}) {\n    try {\n      const { owner, repo } = this.parseRepository(this.repository);\n      \n      // For GitHub API, we need to get the repository tree\n      const tree = await this.githubService.getRepositoryTree(owner, repo, this.branch, true);\n      \n      // Filter files based on pattern\n      const files = tree.tree\n        .filter(item => item.type === 'blob')\n        .map(item => item.path);\n\n      // Simple pattern matching (could be enhanced with proper glob support)\n      if (pattern.includes('*') || pattern.includes('?')) {\n        const regexPattern = pattern\n          .replace(/\\./g, '\\\\.')\n          .replace(/\\*/g, '.*')\n          .replace(/\\?/g, '.');\n        const regex = new RegExp(`^${regexPattern}$`);\n        return files.filter(file => regex.test(file));\n      } else {\n        // Prefix matching\n        return files.filter(file => file.startsWith(pattern));\n      }\n    } catch (error) {\n      throw new Error(`Failed to list files: ${error.message}`);\n    }\n  }\n\n  async getFileInfo(path) {\n    try {\n      const { owner, repo } = this.parseRepository(this.repository);\n      const response = await this.githubService.getFileContent(owner, repo, path, this.branch);\n      \n      return {\n        size: Buffer.from(response.content, 'base64').length,\n        sha: response.sha,\n        path: response.path,\n        type: response.type,\n        url: response.html_url\n      };\n    } catch (error) {\n      throw new Error(`Failed to get file info for ${path}: ${error.message}`);\n    }\n  }\n}\n\n/**\n * Mock storage implementation for browser testing\n * Can be used when no real storage is available\n */\nexport class MockStorage extends Storage {\n  constructor(mockFiles = {}) {\n    super();\n    this.mockFiles = mockFiles;\n  }\n\n  async readFile(path) {\n    if (this.mockFiles[path]) {\n      return Buffer.from(this.mockFiles[path], 'utf-8');\n    }\n    throw new Error(`File not found: ${path}`);\n  }\n\n  async fileExists(path) {\n    return this.mockFiles.hasOwnProperty(path);\n  }\n\n  async listFiles(pattern, options = {}) {\n    const files = Object.keys(this.mockFiles);\n    \n    if (pattern.includes('*') || pattern.includes('?')) {\n      const regexPattern = pattern\n        .replace(/\\./g, '\\\\.')\n        .replace(/\\*/g, '.*')\n        .replace(/\\?/g, '.');\n      const regex = new RegExp(`^${regexPattern}$`);\n      return files.filter(file => regex.test(file));\n    } else {\n      return files.filter(file => file.startsWith(pattern));\n    }\n  }\n\n  async getFileInfo(path) {\n    if (this.mockFiles[path]) {\n      return {\n        size: Buffer.from(this.mockFiles[path], 'utf-8').length,\n        path: path,\n        type: 'file'\n      };\n    }\n    throw new Error(`File not found: ${path}`);\n  }\n}","/**\n * FAQ Execution Engine\n * Manages the execution of FAQ questions and batch processing\n */\n\nimport { QuestionContext, QuestionResult } from '../types/QuestionDefinition.js';\nimport parameterRegistryService from '../registry/ParameterRegistryService.js';\nimport { GitHubStorage } from '../storage/Storage.js';\n\nclass FAQExecutionEngine {\n  constructor() {\n    this.questionRegistry = new Map();\n    this.initialized = false;\n  }\n\n  /**\n   * Initialize the engine with available questions\n   */\n  async initialize() {\n    if (this.initialized) return;\n\n    try {\n      // Import and register all question components\n      await this.loadQuestions();\n      this.initialized = true;\n    } catch (error) {\n      throw new Error(`Failed to initialize FAQ engine: ${error.message}`);\n    }\n  }\n\n  /**\n   * Load all question components from the questions directory\n   */\n  async loadQuestions() {\n    const questions = [\n      // DAK-level questions\n      {\n        id: 'dak-name',\n        module: () => import('../questions/dak/DakNameQuestion.js')\n      },\n      {\n        id: 'dak-version', \n        module: () => import('../questions/dak/DakVersionQuestion.js')\n      },\n      // Component-level questions\n      {\n        id: 'business-process-workflows',\n        module: () => import('../questions/component/businessProcess/BusinessProcessWorkflowsQuestion.js')\n      },\n      // Asset-level questions\n      {\n        id: 'decision-table-inputs',\n        module: () => import('../questions/asset/decisionSupportLogic/DecisionTableInputsQuestion.js')\n      }\n    ];\n\n    for (const questionConfig of questions) {\n      try {\n        const questionModule = await questionConfig.module();\n        \n        if (questionModule.metadata && questionModule.execute) {\n          this.questionRegistry.set(questionConfig.id, {\n            metadata: questionModule.metadata,\n            execute: questionModule.execute,\n            Render: questionModule.Render || null\n          });\n        } else {\n          console.warn(`Question ${questionConfig.id} is missing required exports (metadata, execute)`);\n        }\n      } catch (error) {\n        console.error(`Failed to load question ${questionConfig.id}:`, error);\n      }\n    }\n  }\n\n  /**\n   * Get catalog of all available questions\n   * @param {Object} filters - Optional filters (level, tags, etc.)\n   * @returns {Array} - Array of question metadata\n   */\n  getCatalog(filters = {}) {\n    if (!this.initialized) {\n      throw new Error('FAQ engine not initialized');\n    }\n\n    const questions = Array.from(this.questionRegistry.values()).map(q => q.metadata);\n\n    // Apply filters\n    let filteredQuestions = questions;\n\n    if (filters.level) {\n      filteredQuestions = filteredQuestions.filter(q => q.level === filters.level);\n    }\n\n    if (filters.tags && Array.isArray(filters.tags)) {\n      filteredQuestions = filteredQuestions.filter(q => \n        filters.tags.some(tag => q.tags.includes(tag))\n      );\n    }\n\n    if (filters.componentType) {\n      filteredQuestions = filteredQuestions.filter(q => \n        !q.componentTypes || q.componentTypes.length === 0 || q.componentTypes.includes(filters.componentType)\n      );\n    }\n\n    if (filters.assetType) {\n      filteredQuestions = filteredQuestions.filter(q => \n        !q.assetTypes || q.assetTypes.length === 0 || q.assetTypes.includes(filters.assetType)\n      );\n    }\n\n    return filteredQuestions;\n  }\n\n  /**\n   * Execute a batch of FAQ questions\n   * @param {Array} requests - Array of question requests\n   * @param {Object} context - Execution context (githubService, etc.)\n   * @returns {Promise<Array>} - Array of execution results\n   */\n  async executeBatch(requests, context = {}) {\n    if (!this.initialized) {\n      await this.initialize();\n    }\n\n    const results = [];\n\n    for (const request of requests) {\n      try {\n        const result = await this.executeQuestion(request, context);\n        results.push({\n          questionId: request.questionId,\n          success: true,\n          result\n        });\n      } catch (error) {\n        results.push({\n          questionId: request.questionId,\n          success: false,\n          error: error.message,\n          result: new QuestionResult({\n            structured: {},\n            narrative: this.getErrorNarrative(request.locale || 'en_US', error.message),\n            errors: [error.message],\n            meta: {}\n          })\n        });\n      }\n    }\n\n    return results;\n  }\n\n  /**\n   * Execute a single FAQ question\n   * @param {Object} request - Question request\n   * @param {Object} context - Execution context\n   * @returns {Promise<QuestionResult>} - Question result\n   */\n  async executeQuestion(request, context = {}) {\n    const { questionId, parameters = {}, assetFiles = [] } = request;\n\n    // Get question from registry\n    const question = this.questionRegistry.get(questionId);\n    if (!question) {\n      throw new Error(`Question not found: ${questionId}`);\n    }\n\n    // Handle template questions (asset-level questions that need to be instantiated per asset)\n    if (question.metadata.isTemplate && assetFiles.length > 0) {\n      return await this.executeTemplateQuestion(question, request, context);\n    }\n\n    // Validate and normalize parameters\n    const validation = parameterRegistryService.validateParameters(\n      parameters,\n      question.metadata.level,\n      this.getQuestionType(question.metadata)\n    );\n\n    if (!validation.isValid) {\n      throw new Error(`Parameter validation failed: ${validation.errors.join(', ')}`);\n    }\n\n    // Create storage interface\n    const storage = this.createStorage(validation.normalized, context);\n\n    // Create execution context\n    const executionContext = new QuestionContext({\n      repository: validation.normalized.repository,\n      locale: validation.normalized.locale || 'en_US',\n      branch: validation.normalized.branch || 'main',\n      user: context.user || null,\n      assetFile: validation.normalized.assetFile || null,\n      componentType: validation.normalized.componentType || null,\n      storage\n    });\n\n    // Execute the question\n    const input = {\n      ...validation.normalized,\n      storage,\n      context: executionContext\n    };\n\n    return await question.execute(input);\n  }\n\n  /**\n   * Execute template question for multiple assets\n   * @param {Object} question - Question definition\n   * @param {Object} request - Original request\n   * @param {Object} context - Execution context\n   * @returns {Promise<QuestionResult>} - Aggregated result\n   */\n  async executeTemplateQuestion(question, request, context) {\n    const { parameters = {}, assetFiles = [] } = request;\n    const results = [];\n    const allWarnings = [];\n    const allErrors = [];\n\n    for (const assetFile of assetFiles) {\n      try {\n        const assetParameters = { ...parameters, assetFile };\n        \n        // Validate parameters for this asset\n        const validation = parameterRegistryService.validateParameters(\n          assetParameters,\n          question.metadata.level,\n          this.getQuestionType(question.metadata)\n        );\n\n        if (!validation.isValid) {\n          allErrors.push(`Asset ${assetFile}: ${validation.errors.join(', ')}`);\n          continue;\n        }\n\n        // Create storage and context for this asset\n        const storage = this.createStorage(validation.normalized, context);\n        const executionContext = new QuestionContext({\n          repository: validation.normalized.repository,\n          locale: validation.normalized.locale || 'en_US',\n          branch: validation.normalized.branch || 'main',\n          user: context.user || null,\n          assetFile: assetFile,\n          componentType: validation.normalized.componentType || null,\n          storage\n        });\n\n        const input = {\n          ...validation.normalized,\n          storage,\n          context: executionContext\n        };\n\n        const result = await question.execute(input);\n        results.push({\n          assetFile,\n          result\n        });\n\n        // Collect warnings and errors\n        if (result.warnings) allWarnings.push(...result.warnings);\n        if (result.errors) allErrors.push(...result.errors);\n\n      } catch (error) {\n        allErrors.push(`Asset ${assetFile}: ${error.message}`);\n      }\n    }\n\n    // Aggregate results\n    const aggregatedStructured = {\n      assets: results.map(r => ({\n        assetFile: r.assetFile,\n        ...r.result.structured\n      })),\n      summary: {\n        totalAssets: assetFiles.length,\n        successfulAssets: results.length,\n        failedAssets: assetFiles.length - results.length\n      }\n    };\n\n    const aggregatedNarrative = this.aggregateNarratives(results, request.locale || 'en_US');\n\n    return new QuestionResult({\n      structured: aggregatedStructured,\n      narrative: aggregatedNarrative,\n      warnings: allWarnings,\n      errors: allErrors,\n      meta: {\n        isAggregated: true,\n        questionId: question.metadata.id,\n        assetCount: assetFiles.length\n      }\n    });\n  }\n\n  /**\n   * Create storage interface based on parameters and context\n   * @param {Object} parameters - Validated parameters\n   * @param {Object} context - Execution context\n   * @returns {Storage} - Storage interface\n   */\n  createStorage(parameters, context) {\n    if (context.githubService) {\n      // Use GitHub storage for web application\n      return new GitHubStorage(\n        context.githubService,\n        parameters.repository,\n        parameters.branch || 'main'\n      );\n    } else {\n      // This would be implemented for MCP server with local storage\n      throw new Error('Local storage not implemented in web context');\n    }\n  }\n\n  /**\n   * Get question type for parameter validation\n   * @param {Object} metadata - Question metadata\n   * @returns {string} - Question type\n   */\n  getQuestionType(metadata) {\n    if (metadata.componentTypes && metadata.componentTypes.length > 0) {\n      return metadata.componentTypes[0];\n    }\n    if (metadata.assetTypes && metadata.assetTypes.length > 0) {\n      return metadata.assetTypes[0];\n    }\n    return null;\n  }\n\n  /**\n   * Aggregate narratives from multiple results\n   * @param {Array} results - Array of asset results\n   * @param {string} locale - Locale for output\n   * @returns {string} - Aggregated narrative HTML\n   */\n  aggregateNarratives(results, locale) {\n    if (results.length === 0) {\n      return `<h4>No Results</h4><p>No assets were processed successfully.</p>`;\n    }\n\n    let html = `<h4>Asset Analysis Results</h4>`;\n    html += `<p>Processed ${results.length} asset(s):</p>`;\n    html += `<ul>`;\n\n    for (const { assetFile, result } of results) {\n      html += `<li><strong>${assetFile}</strong>`;\n      if (result.errors && result.errors.length > 0) {\n        html += ` <span class=\"error\">(${result.errors.length} error(s))</span>`;\n      } else if (result.warnings && result.warnings.length > 0) {\n        html += ` <span class=\"warning\">(${result.warnings.length} warning(s))</span>`;\n      } else {\n        html += ` <span class=\"success\">✓</span>`;\n      }\n      html += `</li>`;\n    }\n\n    html += `</ul>`;\n    return html;\n  }\n\n  /**\n   * Get error narrative\n   * @param {string} locale - Locale for error message\n   * @param {string} error - Error message\n   * @returns {string} - Error narrative HTML\n   */\n  getErrorNarrative(locale, error) {\n    const errorMessages = {\n      en_US: `<h4>Error</h4><p class=\"error\">An error occurred while executing the question: ${error}</p>`,\n      fr_FR: `<h4>Erreur</h4><p class=\"error\">Une erreur s'est produite lors de l'exécution de la question: ${error}</p>`,\n      es_ES: `<h4>Error</h4><p class=\"error\">Ocurrió un error al ejecutar la pregunta: ${error}</p>`\n    };\n\n    return errorMessages[locale] || errorMessages['en_US'];\n  }\n\n  /**\n   * Normalize locale string\n   * @param {string} locale - Input locale\n   * @returns {string} - Normalized locale\n   */\n  normalizeLocale(locale) {\n    if (!locale) return 'en_US';\n    \n    // Handle common locale formats\n    const normalized = locale.replace('-', '_');\n    \n    // Map to supported locales\n    const supportedLocales = ['en_US', 'fr_FR', 'es_ES', 'ar_AR', 'zh_CN', 'ru_RU'];\n    \n    if (supportedLocales.includes(normalized)) {\n      return normalized;\n    }\n    \n    // Try base language\n    const baseLanguage = normalized.split('_')[0];\n    const baseLocaleMap = {\n      'en': 'en_US',\n      'fr': 'fr_FR', \n      'es': 'es_ES',\n      'ar': 'ar_AR',\n      'zh': 'zh_CN',\n      'ru': 'ru_RU'\n    };\n    \n    return baseLocaleMap[baseLanguage] || 'en_US';\n  }\n}\n\n// Singleton instance\nconst faqExecutionEngine = new FAQExecutionEngine();\n\nexport default faqExecutionEngine;"],"names":["QuestionLevel","DAK","COMPONENT","ASSET","QuestionDefinition","constructor","_ref","id","level","title","description","parameters","tags","version","isTemplate","componentTypes","assetTypes","this","ParameterDefinition","_ref2","name","type","required","defaultValue","validation","QuestionContext","_ref3","repository","locale","branch","user","assetFile","componentType","storage","QuestionResult","_ref4","structured","narrative","warnings","errors","meta","CacheHint","_ref5","scope","key","ttl","dependencies","parameterRegistryService","registry","loaded","loadFromYaml","yamlContent","yaml","error","Error","concat","message","getParameters","arguments","length","undefined","defaults","config","Object","entries","push","default","_objectSpread","paramName","uniqueParams","Map","forEach","param","set","Array","from","values","validateParameters","definitions","normalized","definition","value","finalValue","typeError","validateParameterType","validationError","validateParameterCustom","keys","find","def","isValid","expectedType","actualType","isNaN","isArray","pattern","RegExp","test","enum","includes","join","minLength","maxLength","min","max","getParameterSchema","properties","property","assign","Storage","readFile","path","fileExists","listFiles","getFileInfo","GitHubStorage","githubService","super","cache","parseRepository","match","owner","repo","replace","parts","split","cacheKey","has","console","log","get","contentString","getFileContent","warn","content","Buffer","substring","_error$stack","stack","isAuth","_error$stack2","files","getRepositoryTree","tree","filter","item","map","regexPattern","regex","file","startsWith","response","size","sha","url","html_url","questionRegistry","initialized","initialize","loadQuestions","questions","module","questionConfig","questionModule","metadata","execute","Render","getCatalog","filters","filteredQuestions","q","some","tag","assetType","executeBatch","requests","context","results","request","result","executeQuestion","questionId","success","getErrorNarrative","assetFiles","question","executeTemplateQuestion","getQuestionType","createStorage","executionContext","input","allWarnings","allErrors","assetParameters","aggregatedStructured","assets","r","summary","totalAssets","successfulAssets","failedAssets","aggregatedNarrative","aggregateNarratives","isAggregated","assetCount","html","errorMessages","en_US","fr_FR","es_ES","normalizeLocale"],"sourceRoot":""}