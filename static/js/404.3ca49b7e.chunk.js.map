{"version":3,"file":"static/js/404.3ca49b7e.chunk.js","mappings":"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","sources":["utils/concurrency.js","utils/repositoryCompatibilityCache.js","services/secureTokenStorage.js","services/githubService.js","services/branchContextService.js"],"sourcesContent":["/**\n * Utility for managing concurrent async operations with rate limiting\n */\n\n/**\n * Processes items concurrently with a specified concurrency limit\n * @param {Array} items - Items to process\n * @param {Function} processor - Async function to process each item\n * @param {Object} options - Options for concurrency control\n * @param {number} options.concurrency - Maximum concurrent operations (default: 5)\n * @param {Function} options.onProgress - Progress callback (current, total, item, result)\n * @param {Function} options.onItemComplete - Callback when item completes (item, result, error)\n * @param {Function} options.onItemStart - Callback when item starts processing (item, index)\n * @returns {Promise<Array>} Array of results (in original order)\n */\nexport async function processConcurrently(items, processor, options = {}) {\n  const {\n    concurrency = 5,\n    onProgress = null,\n    onItemComplete = null,\n    onItemStart = null\n  } = options;\n\n  if (!items || items.length === 0) {\n    return [];\n  }\n\n  const results = new Array(items.length);\n  const total = items.length;\n  let completed = 0;\n\n  // Create a queue of work items\n  const queue = items.map((item, index) => ({ item, index }));\n  \n  // Worker function that processes items from the queue\n  const worker = async () => {\n    while (queue.length > 0) {\n      const { item, index } = queue.shift();\n      \n      // Notify that processing is starting\n      if (onItemStart) {\n        onItemStart(item, index);\n      }\n      \n      try {\n        const result = await processor(item, index);\n        results[index] = result;\n        \n        completed++;\n        \n        // Call callbacks\n        if (onProgress) {\n          onProgress(completed, total, item, result);\n        }\n        if (onItemComplete) {\n          onItemComplete(item, result, null);\n        }\n      } catch (error) {\n        // Store error as result\n        results[index] = { error, item };\n        \n        completed++;\n        \n        // Call callbacks\n        if (onProgress) {\n          onProgress(completed, total, item, null);\n        }\n        if (onItemComplete) {\n          onItemComplete(item, null, error);\n        }\n      }\n    }\n  };\n\n  // Start worker promises (limited by concurrency)\n  const workers = Array(Math.min(concurrency, items.length))\n    .fill()\n    .map(() => worker());\n\n  // Wait for all workers to complete\n  await Promise.all(workers);\n\n  return results;\n}\n\n/**\n * Rate-limited function executor\n * Useful for API calls that need to respect rate limits\n */\nexport class RateLimiter {\n  constructor(requestsPerSecond = 5) {\n    this.requestsPerSecond = requestsPerSecond;\n    this.requests = [];\n    this.interval = 1000 / requestsPerSecond; // ms between requests\n  }\n\n  /**\n   * Execute a function with rate limiting\n   * @param {Function} fn - Function to execute\n   * @returns {Promise} Result of the function\n   */\n  async execute(fn) {\n    const now = Date.now();\n    \n    // Remove requests older than 1 second\n    this.requests = this.requests.filter(time => now - time < 1000);\n    \n    // If we're at the limit, wait\n    if (this.requests.length >= this.requestsPerSecond) {\n      const oldestRequest = Math.min(...this.requests);\n      const waitTime = 1000 - (now - oldestRequest) + 10; // Add 10ms buffer\n      if (waitTime > 0) {\n        await new Promise(resolve => setTimeout(resolve, waitTime));\n      }\n    }\n    \n    // Record this request\n    this.requests.push(Date.now());\n    \n    // Execute the function\n    return await fn();\n  }\n}","/**\n * Simple in-memory cache for repository compatibility checks\n * Prevents redundant sushi-config.yaml downloads during scanning\n */\n\nclass RepositoryCompatibilityCache {\n  constructor(ttlMinutes = 30) {\n    this.cache = new Map();\n    this.ttl = ttlMinutes * 60 * 1000; // Convert to milliseconds\n  }\n\n  /**\n   * Generate cache key for a repository\n   * @param {string} owner - Repository owner\n   * @param {string} repo - Repository name\n   * @returns {string} Cache key\n   */\n  _getCacheKey(owner, repo) {\n    return `${owner}/${repo}`;\n  }\n\n  /**\n   * Check if cache entry is still valid\n   * @param {Object} entry - Cache entry\n   * @returns {boolean} True if valid\n   */\n  _isValid(entry) {\n    return Date.now() - entry.timestamp < this.ttl;\n  }\n\n  /**\n   * Get cached compatibility result\n   * @param {string} owner - Repository owner\n   * @param {string} repo - Repository name\n   * @returns {boolean|null} Cached result or null if not cached/expired\n   */\n  get(owner, repo) {\n    const key = this._getCacheKey(owner, repo);\n    const entry = this.cache.get(key);\n    \n    if (!entry) {\n      return null;\n    }\n    \n    if (!this._isValid(entry)) {\n      this.cache.delete(key);\n      return null;\n    }\n    \n    return entry.compatible;\n  }\n\n  /**\n   * Set cached compatibility result\n   * @param {string} owner - Repository owner\n   * @param {string} repo - Repository name\n   * @param {boolean} compatible - Whether repository is SMART guidelines compatible\n   */\n  set(owner, repo, compatible) {\n    const key = this._getCacheKey(owner, repo);\n    this.cache.set(key, {\n      compatible,\n      timestamp: Date.now()\n    });\n  }\n\n  /**\n   * Clear all cached entries\n   */\n  clear() {\n    this.cache.clear();\n  }\n\n  /**\n   * Clean up expired entries\n   */\n  cleanup() {\n    const now = Date.now();\n    for (const [key, entry] of this.cache.entries()) {\n      if (now - entry.timestamp >= this.ttl) {\n        this.cache.delete(key);\n      }\n    }\n  }\n\n  /**\n   * Get cache statistics\n   * @returns {Object} Cache stats\n   */\n  getStats() {\n    this.cleanup();\n    return {\n      size: this.cache.size,\n      ttlMinutes: this.ttl / (60 * 1000),\n      entries: Array.from(this.cache.entries()).map(([key, entry]) => ({\n        repository: key,\n        compatible: entry.compatible,\n        ageMinutes: Math.round((Date.now() - entry.timestamp) / (60 * 1000))\n      }))\n    };\n  }\n}\n\n// Create a singleton instance\nconst repositoryCompatibilityCache = new RepositoryCompatibilityCache();\n\nexport default repositoryCompatibilityCache;","/**\n * SecureTokenStorage - Secure storage for GitHub Personal Access Tokens\n * \n * Features:\n * - XOR encryption using browser fingerprint-based keys\n * - Token format validation (classic and fine-grained PATs)\n * - Automatic token expiration (24 hours)\n * - Secure token masking for logs and error messages\n */\n\nimport logger from '../utils/logger';\n\nclass SecureTokenStorage {\n  constructor() {\n    this.logger = logger.getLogger('SecureTokenStorage');\n    this.storageKey = 'sgex_secure_token';\n    this.expirationHours = 24;\n    this.logger.debug('SecureTokenStorage instance created');\n  }\n\n  /**\n   * Generate a browser fingerprint for encryption key\n   * @returns {string} Browser fingerprint\n   */\n  generateBrowserFingerprint() {\n    const canvas = document.createElement('canvas');\n    const ctx = canvas.getContext('2d');\n    ctx.textBaseline = 'top';\n    ctx.font = '14px Arial';\n    ctx.fillText('Browser fingerprint', 2, 2);\n    \n    const fingerprint = [\n      navigator.userAgent,\n      navigator.language,\n      window.screen.width + 'x' + window.screen.height,\n      window.screen.colorDepth,\n      new Date().getTimezoneOffset(),\n      canvas.toDataURL()\n    ].join('|');\n    \n    // Create a simple hash of the fingerprint\n    let hash = 0;\n    for (let i = 0; i < fingerprint.length; i++) {\n      const char = fingerprint.charCodeAt(i);\n      hash = ((hash << 5) - hash) + char;\n      hash = hash & hash; // Convert to 32-bit integer\n    }\n    \n    return Math.abs(hash).toString(36);\n  }\n\n  /**\n   * XOR encrypt/decrypt text using a key\n   * @param {string} text - Text to encrypt/decrypt\n   * @param {string} key - Encryption key\n   * @returns {string} Encrypted/decrypted text\n   */\n  xorCipher(text, key) {\n    let result = '';\n    for (let i = 0; i < text.length; i++) {\n      result += String.fromCharCode(\n        text.charCodeAt(i) ^ key.charCodeAt(i % key.length)\n      );\n    }\n    return result;\n  }\n\n  /**\n   * Validate GitHub Personal Access Token format\n   * @param {string} token - Token to validate\n   * @returns {object} Validation result with type and validity\n   */\n  validateTokenFormat(token) {\n    if (!token || typeof token !== 'string') {\n      return { isValid: false, type: 'invalid', reason: 'Token is empty or not a string' };\n    }\n\n    // Remove any whitespace\n    const cleanToken = token.trim();\n\n    // Classic Personal Access Token format: ghp_[36 characters A-Za-z0-9]\n    if (cleanToken.match(/^ghp_[A-Za-z0-9]{36}$/)) {\n      return { isValid: true, type: 'classic', token: cleanToken };\n    }\n\n    // Fine-grained Personal Access Token format: github_pat_[22 characters]_[59 characters]\n    if (cleanToken.match(/^github_pat_[A-Za-z0-9]{22}_[A-Za-z0-9]{59}$/)) {\n      return { isValid: true, type: 'fine-grained', token: cleanToken };\n    }\n\n    // OAuth token format: gho_[36 characters] (for completeness)\n    if (cleanToken.match(/^gho_[A-Za-z0-9]{36}$/)) {\n      return { isValid: true, type: 'oauth', token: cleanToken };\n    }\n\n    // Check for old-style tokens (40 hex characters) - deprecated but might still work\n    if (cleanToken.match(/^[a-fA-F0-9]{40}$/)) {\n      return { isValid: true, type: 'legacy', token: cleanToken };\n    }\n\n    return { \n      isValid: false, \n      type: 'invalid', \n      reason: 'Token does not match expected GitHub PAT format'\n    };\n  }\n\n  /**\n   * Mask token for safe logging\n   * @param {string} token - Token to mask\n   * @returns {string} Masked token\n   */\n  maskToken(token) {\n    if (!token || typeof token !== 'string') {\n      return '[INVALID_TOKEN]';\n    }\n\n    const cleanToken = token.trim();\n    if (cleanToken.length < 8) {\n      return '[INVALID_TOKEN]';\n    }\n\n    // Show first 4 and last 4 characters for debugging purposes\n    return `${cleanToken.substring(0, 4)}${'*'.repeat(cleanToken.length - 8)}${cleanToken.substring(cleanToken.length - 4)}`;\n  }\n\n  /**\n   * Store token securely with encryption and expiration\n   * @param {string} token - GitHub Personal Access Token\n   * @returns {boolean} Success status\n   */\n  storeToken(token) {\n    try {\n      this.logger.debug('Starting secure token storage');\n\n      // Validate token format\n      const validation = this.validateTokenFormat(token);\n      if (!validation.isValid) {\n        this.logger.warn('Token validation failed', { \n          reason: validation.reason,\n          tokenMask: this.maskToken(token)\n        });\n        return false;\n      }\n\n      this.logger.debug('Token validation successful', { \n        type: validation.type,\n        tokenMask: this.maskToken(token)\n      });\n\n      // Generate encryption key\n      const fingerprint = this.generateBrowserFingerprint();\n      const encryptionKey = `sgex_${fingerprint}_${Date.now().toString(36)}`;\n\n      // Encrypt token\n      const encryptedToken = this.xorCipher(validation.token, encryptionKey);\n      \n      // Create storage object with metadata\n      const storageData = {\n        token: btoa(encryptedToken), // Base64 encode for safe storage\n        key: btoa(encryptionKey), // Base64 encode the key\n        type: validation.type,\n        created: Date.now(),\n        expires: Date.now() + (this.expirationHours * 60 * 60 * 1000),\n        fingerprint: fingerprint\n      };\n\n      // Store in sessionStorage (more secure than localStorage for tokens)\n      sessionStorage.setItem(this.storageKey, JSON.stringify(storageData));\n      \n      // Clear any old tokens from localStorage\n      localStorage.removeItem('github_token');\n      sessionStorage.removeItem('github_token');\n\n      this.logger.debug('Token stored securely', { \n        type: validation.type,\n        expires: new Date(storageData.expires).toISOString(),\n        tokenMask: this.maskToken(token)\n      });\n\n      return true;\n    } catch (error) {\n      this.logger.error('Failed to store token securely', { \n        error: error.message,\n        tokenMask: this.maskToken(token)\n      });\n      return false;\n    }\n  }\n\n  /**\n   * Retrieve and decrypt stored token\n   * @returns {object|null} Token data or null if not found/expired\n   */\n  retrieveToken() {\n    try {\n      this.logger.debug('Attempting to retrieve secure token');\n\n      const storedData = sessionStorage.getItem(this.storageKey);\n      if (!storedData) {\n        this.logger.debug('No secure token found in storage');\n        return null;\n      }\n\n      const data = JSON.parse(storedData);\n      \n      // Check expiration\n      if (Date.now() > data.expires) {\n        this.logger.warn('Stored token has expired');\n        this.clearToken();\n        return null;\n      }\n\n      // Verify browser fingerprint\n      const currentFingerprint = this.generateBrowserFingerprint();\n      if (data.fingerprint !== currentFingerprint) {\n        this.logger.warn('Browser fingerprint mismatch - possible security issue');\n        this.clearToken();\n        return null;\n      }\n\n      // Decrypt token\n      const encryptionKey = atob(data.key);\n      const encryptedToken = atob(data.token);\n      const decryptedToken = this.xorCipher(encryptedToken, encryptionKey);\n\n      // Validate decrypted token\n      const validation = this.validateTokenFormat(decryptedToken);\n      if (!validation.isValid) {\n        this.logger.error('Decrypted token failed validation');\n        this.clearToken();\n        return null;\n      }\n\n      this.logger.debug('Token retrieved and decrypted successfully', { \n        type: data.type,\n        expires: new Date(data.expires).toISOString(),\n        tokenMask: this.maskToken(decryptedToken)\n      });\n\n      return {\n        token: validation.token,\n        type: data.type,\n        created: data.created,\n        expires: data.expires\n      };\n    } catch (error) {\n      this.logger.error('Failed to retrieve secure token', { error: error.message });\n      this.clearToken();\n      return null;\n    }\n  }\n\n  /**\n   * Check if a valid token exists without retrieving it\n   * @returns {boolean} True if valid token exists\n   */\n  hasValidToken() {\n    try {\n      const storedData = sessionStorage.getItem(this.storageKey);\n      if (!storedData) {\n        return false;\n      }\n\n      const data = JSON.parse(storedData);\n      \n      // Check expiration\n      if (Date.now() > data.expires) {\n        this.clearToken();\n        return false;\n      }\n\n      // Verify browser fingerprint\n      const currentFingerprint = this.generateBrowserFingerprint();\n      if (data.fingerprint !== currentFingerprint) {\n        this.clearToken();\n        return false;\n      }\n\n      return true;\n    } catch (error) {\n      this.logger.error('Error checking token validity', { error: error.message });\n      this.clearToken();\n      return false;\n    }\n  }\n\n  /**\n   * Clear stored token and cleanup\n   */\n  clearToken() {\n    this.logger.debug('Clearing secure token storage');\n    \n    sessionStorage.removeItem(this.storageKey);\n    \n    // Also clear legacy token storage\n    sessionStorage.removeItem('github_token');\n    localStorage.removeItem('github_token');\n  }\n\n  /**\n   * Get token expiration info\n   * @returns {object|null} Expiration info or null if no token\n   */\n  getTokenInfo() {\n    try {\n      const storedData = sessionStorage.getItem(this.storageKey);\n      if (!storedData) {\n        return null;\n      }\n\n      const data = JSON.parse(storedData);\n      const timeRemaining = data.expires - Date.now();\n      \n      return {\n        type: data.type,\n        created: new Date(data.created),\n        expires: new Date(data.expires),\n        timeRemaining: Math.max(0, timeRemaining),\n        isExpired: timeRemaining <= 0,\n        isValid: this.hasValidToken()\n      };\n    } catch (error) {\n      this.logger.error('Error getting token info', { error: error.message });\n      return null;\n    }\n  }\n\n  /**\n   * Migrate from legacy token storage\n   * @returns {boolean} True if migration was successful\n   */\n  migrateLegacyToken() {\n    try {\n      // Check for tokens in legacy storage\n      const legacyToken = sessionStorage.getItem('github_token') || localStorage.getItem('github_token');\n      \n      if (!legacyToken) {\n        this.logger.debug('No legacy token found for migration');\n        return false;\n      }\n\n      this.logger.debug('Migrating legacy token to secure storage');\n\n      // Store using new secure method\n      const success = this.storeToken(legacyToken);\n      \n      if (success) {\n        // Clear legacy storage\n        sessionStorage.removeItem('github_token');\n        localStorage.removeItem('github_token');\n        this.logger.debug('Legacy token migration completed successfully');\n        return true;\n      } else {\n        this.logger.error('Failed to migrate legacy token');\n        return false;\n      }\n    } catch (error) {\n      this.logger.error('Error during legacy token migration', { error: error.message });\n      return false;\n    }\n  }\n}\n\n// Create singleton instance\nconst secureTokenStorage = new SecureTokenStorage();\n\nexport default secureTokenStorage;","import { lazyLoadOctokit } from '../utils/lazyRouteUtils';\nimport { processConcurrently } from '../utils/concurrency';\nimport repositoryCompatibilityCache from '../utils/repositoryCompatibilityCache';\nimport secureTokenStorage from './secureTokenStorage';\nimport logger from '../utils/logger';\n\n\n\nclass GitHubService {\n  constructor() {\n    this.octokit = null;\n    this.isAuthenticated = false;\n    this.permissions = null;\n    this.tokenType = null; // 'classic', 'fine-grained', or 'oauth'\n    this.logger = logger.getLogger('GitHubService');\n    this.logger.debug('GitHubService instance created');\n  }\n\n  // Helper method to create Octokit instance with lazy loading\n  async createOctokitInstance(auth = null) {\n    const Octokit = await lazyLoadOctokit();\n    return new Octokit(auth ? { auth } : {});\n  }\n\n  // Initialize with a GitHub token (supports both OAuth and PAT tokens)\n  async authenticate(token) {\n    const startTime = Date.now();\n    this.logger.auth('Starting authentication', { \n      tokenProvided: !!token, \n      tokenMask: token ? secureTokenStorage.maskToken(token) : 'none'\n    });\n    \n    try {\n      // Validate token format using SecureTokenStorage\n      const validation = secureTokenStorage.validateTokenFormat(token);\n      if (!validation.isValid) {\n        this.logger.warn('Token validation failed during authentication', { \n          reason: validation.reason,\n          tokenMask: secureTokenStorage.maskToken(token)\n        });\n        this.isAuthenticated = false;\n        return false;\n      }\n\n      // Lazy load Octokit to reduce initial bundle size\n      this.octokit = await this.createOctokitInstance(validation.token);\n      this.isAuthenticated = true;\n      this.tokenType = validation.type;\n      \n      // Store token securely\n      const stored = secureTokenStorage.storeToken(validation.token);\n      if (!stored) {\n        this.logger.warn('Failed to store token securely, authentication will not persist');\n      }\n      \n      const duration = Date.now() - startTime;\n      this.logger.auth('Authentication successful', { \n        duration, \n        tokenType: this.tokenType,\n        tokenMask: secureTokenStorage.maskToken(token),\n        securelyStored: stored\n      });\n      this.logger.performance('GitHub authentication', duration);\n      \n      return true;\n    } catch (error) {\n      const duration = Date.now() - startTime;\n      this.logger.auth('Authentication failed', { \n        error: error.message, \n        duration,\n        tokenMask: secureTokenStorage.maskToken(token)\n      });\n      console.error('Failed to authenticate with GitHub:', error);\n      this.isAuthenticated = false;\n      secureTokenStorage.clearToken(); // Clear any partially stored data\n      return false;\n    }\n  }\n\n  // Initialize with an existing Octokit instance (for OAuth flow)\n  authenticateWithOctokit(octokitInstance) {\n    this.logger.auth('Starting OAuth authentication with Octokit instance');\n    \n    try {\n      this.octokit = octokitInstance;\n      this.isAuthenticated = true;\n      this.tokenType = 'oauth';\n      \n      this.logger.auth('OAuth authentication successful', { tokenType: this.tokenType });\n      return true;\n    } catch (error) {\n      this.logger.auth('OAuth authentication failed', { error: error.message });\n      console.error('Failed to authenticate with Octokit instance:', error);\n      this.isAuthenticated = false;\n      return false;\n    }\n  }\n\n  // Initialize authentication from securely stored token\n  async initializeFromStoredToken() {\n    this.logger.auth('Attempting to initialize from stored token');\n    \n    try {\n      // First try to migrate any legacy tokens\n      const migrated = secureTokenStorage.migrateLegacyToken();\n      if (migrated) {\n        this.logger.debug('Successfully migrated legacy token to secure storage');\n      }\n\n      // Retrieve token from secure storage\n      const tokenData = secureTokenStorage.retrieveToken();\n      if (!tokenData) {\n        this.logger.debug('No valid stored token found');\n        return false;\n      }\n\n      // Initialize Octokit with stored token using lazy loading\n      this.octokit = await this.createOctokitInstance(tokenData.token);\n      this.isAuthenticated = true;\n      this.tokenType = tokenData.type;\n      \n      this.logger.auth('Successfully initialized from stored token', {\n        tokenType: this.tokenType,\n        tokenMask: secureTokenStorage.maskToken(tokenData.token),\n        expires: new Date(tokenData.expires).toISOString()\n      });\n      \n      return true;\n    } catch (error) {\n      this.logger.auth('Failed to initialize from stored token', { error: error.message });\n      this.isAuthenticated = false;\n      secureTokenStorage.clearToken();\n      return false;\n    }\n  }\n\n  // Check if there's a valid stored token\n  hasStoredToken() {\n    return secureTokenStorage.hasValidToken();\n  }\n\n  // Get information about stored token\n  getStoredTokenInfo() {\n    return secureTokenStorage.getTokenInfo();\n  }\n\n  // Check token permissions and type\n  async checkTokenPermissions() {\n    if (!this.isAuth()) {\n      const error = new Error('Not authenticated with GitHub');\n      this.logger.error('Token permission check failed - not authenticated');\n      throw error;\n    }\n\n    const startTime = Date.now();\n    this.logger.apiCall('GET', '/user', null);\n\n    try {\n      // Try to get token info to determine type and permissions\n      const response = await this.octokit.request('GET /user');\n      this.logger.apiResponse('GET', '/user', response.status, Date.now() - startTime);\n      \n      // Check if this is a fine-grained token by trying to access rate limit info\n      try {\n        const rateLimitStart = Date.now();\n        this.logger.apiCall('GET', '/rate_limit', null);\n        const rateLimit = await this.octokit.rest.rateLimit.get();\n        this.logger.apiResponse('GET', '/rate_limit', rateLimit.status, Date.now() - rateLimitStart);\n        \n        // Fine-grained tokens have different rate limit structure\n        this.tokenType = rateLimit.data.resources.core ? 'classic' : 'fine-grained';\n        this.logger.debug('Token type determined', { tokenType: this.tokenType, hasCore: !!rateLimit.data.resources.core });\n      } catch (rateLimitError) {\n        this.tokenType = 'unknown';\n        this.logger.warn('Could not determine token type from rate limit', { error: rateLimitError.message });\n      }\n\n      const permissions = {\n        type: this.tokenType,\n        user: response.data\n      };\n      \n      this.permissions = permissions;\n      this.logger.debug('Token permissions checked successfully', { \n        tokenType: this.tokenType, \n        username: response.data.login \n      });\n      \n      return permissions;\n    } catch (error) {\n      const duration = Date.now() - startTime;\n      this.logger.apiError('GET', '/user', error);\n      this.logger.performance('Token permission check (failed)', duration);\n      console.error('Failed to check token permissions:', error);\n      throw error;\n    }\n  }\n\n  // Check if we have write permissions for a specific repository\n  async checkRepositoryWritePermissions(owner, repo) {\n    if (!this.isAuth()) {\n      this.logger.warn('Cannot check repository write permissions - not authenticated', { owner, repo });\n      return false;\n    }\n\n    const startTime = Date.now();\n    this.logger.debug('Checking write permissions for repository', { owner, repo });\n\n    try {\n      // Get current user first\n      const currentUser = await this.getCurrentUser();\n      const username = currentUser.login;\n      \n      this.logger.apiCall('GET', `/repos/${owner}/${repo}/collaborators/${username}/permission`, null);\n      \n      // Try to get repository collaborator permissions\n      const { data } = await this.octokit.rest.repos.getCollaboratorPermissionLevel({\n        owner,\n        repo,\n        username\n      });\n      \n      const duration = Date.now() - startTime;\n      this.logger.apiResponse('GET', `/repos/${owner}/${repo}/collaborators/${username}/permission`, 200, duration);\n      \n      // GitHub permission levels: read, triage, write, maintain, admin\n      // Users with write, maintain, or admin permissions can merge PRs\n      const hasWriteAccess = ['write', 'maintain', 'admin'].includes(data.permission);\n      this.logger.debug('Repository write permissions checked', { \n        owner, \n        repo, \n        permission: data.permission, \n        hasWriteAccess,\n        supportedLevels: ['write', 'maintain', 'admin']\n      });\n      \n      return hasWriteAccess;\n    } catch (error) {\n      const duration = Date.now() - startTime;\n      this.logger.apiError('GET', `/repos/${owner}/${repo}/collaborators/*/permission`, error);\n      this.logger.performance('Repository write permission check (failed)', duration);\n      \n      // Better error logging to help debug permission issues\n      console.warn(`Could not check repository write permissions for ${owner}/${repo}:`, {\n        error: error.message,\n        status: error.status,\n        statusText: error.response?.statusText,\n        headers: error.response?.headers\n      });\n      \n      this.logger.warn('Assuming no write access due to permission check failure', { \n        owner, \n        repo, \n        error: error.message,\n        status: error.status,\n        userGuidance: 'Check if your Personal Access Token has the required scopes: repo (classic) or Contents+Pull requests (fine-grained)'\n      });\n      return false;\n    }\n  }\n\n  // Alias method for backward compatibility - delegates to checkRepositoryWritePermissions\n  async checkRepositoryPermissions(owner, repo) {\n    return this.checkRepositoryWritePermissions(owner, repo);\n  }\n\n  // Check if the token has permission to create comments on issues/PRs\n  async checkCommentPermissions(owner, repo) {\n    if (!this.isAuth()) {\n      this.logger.warn('Cannot check comment permissions - not authenticated', { owner, repo });\n      return false;\n    }\n\n    const startTime = Date.now();\n    this.logger.debug('Checking comment permissions for repository', { owner, repo });\n\n    try {\n      // Try to access the issues endpoint, which is required for commenting on PRs\n      // This is a safe read operation that will fail gracefully if no permission\n      this.logger.apiCall('GET', `/repos/${owner}/${repo}/issues`, { per_page: 1 });\n      \n      await this.octokit.rest.issues.listForRepo({\n        owner,\n        repo,\n        per_page: 1,\n        state: 'all'\n      });\n      \n      const duration = Date.now() - startTime;\n      this.logger.apiResponse('GET', `/repos/${owner}/${repo}/issues`, 200, duration);\n      \n      // If we can read issues, we likely can comment on them\n      // But this is just a heuristic - the actual test is when we try to comment\n      this.logger.debug('Issues endpoint accessible - comment permissions likely available', { owner, repo });\n      return true;\n    } catch (error) {\n      const duration = Date.now() - startTime;\n      this.logger.apiError('GET', `/repos/${owner}/${repo}/issues`, error);\n      this.logger.performance('Comment permission check (failed)', duration);\n      \n      // Check if it's a permissions error\n      if (error.status === 403 || error.status === 401) {\n        this.logger.warn('Token does not have permission to access issues/comments', { \n          owner, \n          repo, \n          error: error.message,\n          status: error.status \n        });\n        return false;\n      }\n      \n      // For other errors, assume we have permission and let the actual comment attempt handle it\n      this.logger.warn('Could not determine comment permissions, assuming available', { \n        owner, \n        repo, \n        error: error.message \n      });\n      return true;\n    }\n  }\n\n  // Check if authenticated\n  isAuth() {\n    return this.isAuthenticated && this.octokit !== null;\n  }\n\n  // Get current user data\n  async getCurrentUser() {\n    if (!this.isAuth()) {\n      throw new Error('Not authenticated with GitHub');\n    }\n\n    try {\n      const { data } = await this.octokit.rest.users.getAuthenticated();\n      return data;\n    } catch (error) {\n      console.error('Failed to fetch user data:', error);\n      throw error;\n    }\n  }\n\n  // Get user's organizations\n  async getUserOrganizations() {\n    if (!this.isAuth()) {\n      throw new Error('Not authenticated with GitHub');\n    }\n\n    try {\n      const { data } = await this.octokit.rest.orgs.listForAuthenticatedUser();\n      return data;\n    } catch (error) {\n      console.error('Failed to fetch organizations:', error);\n      throw error;\n    }\n  }\n\n  // Get specific organization data (public data, no auth required)\n  async getOrganization(orgLogin) {\n    try {\n      // Create a temporary Octokit instance for public API calls if we don't have one\n      const octokit = this.octokit || await this.createOctokitInstance();\n      \n      const { data } = await octokit.rest.orgs.get({\n        org: orgLogin\n      });\n      return data;\n    } catch (error) {\n      console.error(`Failed to fetch organization ${orgLogin}:`, error);\n      throw error;\n    }\n  }\n\n  // Get specific user data (public data, no auth required)\n  async getUser(username) {\n    try {\n      // Create a temporary Octokit instance for public API calls if we don't have one\n      const octokit = this.octokit || await this.createOctokitInstance();\n      \n      const { data } = await octokit.rest.users.getByUsername({\n        username\n      });\n      return data;\n    } catch (error) {\n      console.error(`Failed to fetch user ${username}:`, error);\n      throw error;\n    }\n  }\n\n  // Get public repositories for a user or organization (no auth required)\n  async getPublicRepositories(owner, type = 'user') {\n    try {\n      // Create a temporary Octokit instance for public API calls if we don't have one\n      const octokit = this.octokit || await this.createOctokitInstance();\n      \n      let repositories = [];\n      let page = 1;\n      let hasMorePages = true;\n\n      // Fetch all public repositories using pagination\n      while (hasMorePages) {\n        let response;\n        if (type === 'user') {\n          response = await octokit.rest.repos.listForUser({\n            username: owner,\n            sort: 'updated',\n            per_page: 100,\n            page: page,\n          });\n        } else {\n          response = await octokit.rest.repos.listForOrg({\n            org: owner,\n            sort: 'updated',\n            per_page: 100,\n            page: page,\n          });\n        }\n\n        repositories = repositories.concat(response.data);\n        \n        // Check if there are more pages\n        hasMorePages = response.data.length === 100;\n        page++;\n      }\n\n      return repositories;\n    } catch (error) {\n      console.error(`Failed to fetch public repositories for ${owner}:`, error);\n      throw error;\n    }\n  }\n\n  // Get WHO organization data with fresh avatar\n  async getWHOOrganization() {\n    try {\n      const whoData = await this.getOrganization('WorldHealthOrganization');\n      return {\n        id: whoData.id,\n        login: whoData.login,\n        display_name: whoData.name || 'World Health Organization',\n        description: whoData.description || 'The World Health Organization is a specialized agency of the United Nations responsible for international public health.',\n        avatar_url: whoData.avatar_url,\n        html_url: whoData.html_url,\n        type: 'Organization',\n        permissions: {\n          can_create_repositories: true,\n          can_create_private_repositories: true\n        },\n        plan: {\n          name: 'Organization',\n          private_repos: 'unlimited'\n        },\n        isWHO: true\n      };\n    } catch (error) {\n      console.warn('Could not fetch WHO organization data from API, using fallback:', error);\n      // Return hardcoded fallback data\n      return {\n        id: 'who-organization',\n        login: 'WorldHealthOrganization',\n        display_name: 'World Health Organization',\n        description: 'The World Health Organization is a specialized agency of the United Nations responsible for international public health.',\n        avatar_url: 'https://avatars.githubusercontent.com/u/12261302?s=200&v=4',\n        html_url: 'https://github.com/WorldHealthOrganization',\n        type: 'Organization',\n        permissions: {\n          can_create_repositories: true,\n          can_create_private_repositories: true\n        },\n        plan: {\n          name: 'Organization',\n          private_repos: 'unlimited'\n        },\n        isWHO: true\n      };\n    }\n  }\n\n  // Rate limiting management methods\n  async checkRateLimit() {\n    try {\n      const octokit = this.octokit || await this.createOctokitInstance();\n      const { data } = await octokit.rest.rateLimit.get();\n      return {\n        core: {\n          limit: data.rate.limit,\n          remaining: data.rate.remaining,\n          reset: data.rate.reset,\n          used: data.rate.used\n        },\n        search: {\n          limit: data.search.limit,\n          remaining: data.search.remaining,\n          reset: data.search.reset,\n          used: data.search.used\n        },\n        isAuthenticated: this.isAuthenticated\n      };\n    } catch (error) {\n      console.warn('Could not check rate limit:', error);\n      return {\n        core: {\n          limit: this.isAuthenticated ? 5000 : 60,\n          remaining: 0,\n          reset: Date.now() + 3600000,\n          used: this.isAuthenticated ? 5000 : 60\n        },\n        search: {\n          limit: this.isAuthenticated ? 30 : 10,\n          remaining: 0,\n          reset: Date.now() + 60000,\n          used: this.isAuthenticated ? 30 : 10\n        },\n        isAuthenticated: this.isAuthenticated\n      };\n    }\n  }\n\n  // Check if we should skip API calls due to rate limiting\n  async shouldSkipApiCalls() {\n    if (this.isAuthenticated) {\n      return false; // Authenticated users have higher limits\n    }\n\n    try {\n      const rateLimit = await this.checkRateLimit();\n      const remaining = rateLimit.core.remaining;\n      \n      // For unauthenticated users, be conservative and stop making calls if less than 10 remaining\n      if (remaining < 10) {\n        console.warn(` Rate limit protection: Only ${remaining} API calls remaining, skipping compatibility checks`);\n        return true;\n      }\n      \n      return false;\n    } catch (error) {\n      // If we can't check rate limits, assume we should be conservative\n      console.warn(' Cannot check rate limits, enabling conservative mode');\n      return !this.isAuthenticated; // Skip for unauthenticated users when in doubt\n    }\n  }\n\n  // Get repositories for a user or organization (now filters by SMART Guidelines compatibility)\n  async getRepositories(owner, type = 'user') {\n    // Use the new SMART guidelines filtering method\n    return this.getSmartGuidelinesRepositories(owner, type);\n  }\n\n  // Check if a repository has sushi-config.yaml with smart.who.int.base dependency\n  async checkSmartGuidelinesCompatibility(owner, repo, retryCount = 2) {\n\n    // Check cache first to prevent redundant downloads\n    const cachedResult = repositoryCompatibilityCache.get(owner, repo);\n    if (cachedResult !== null) {\n      return { compatible: cachedResult, cached: true };\n    }\n\n    // Check if we should skip this API call due to rate limiting\n    if (!this.isAuthenticated) {\n      try {\n        const shouldSkip = await this.shouldSkipApiCalls();\n        if (shouldSkip) {\n          console.warn(` Skipping compatibility check for ${owner}/${repo} due to rate limit protection`);\n          // Return false but don't cache it since we didn't actually check\n          return { \n            compatible: false, \n            skipped: true, \n            reason: 'Rate limit protection - API call skipped' \n          };\n        }\n      } catch (rateLimitCheckError) {\n        console.warn('Could not check rate limits, proceeding with API call:', rateLimitCheckError);\n      }\n    }\n\n    try {\n      // Use authenticated or public API depending on authentication state\n      const octokit = this.octokit || await this.createOctokitInstance();\n      \n      // Try to get sushi-config.yaml from the repository root\n      const { data } = await octokit.rest.repos.getContent({\n        owner,\n        repo,\n        path: 'sushi-config.yaml',\n      });\n\n      if (data.type === 'file' && data.content) {\n        // Decode base64 content (browser-compatible)\n        const content = decodeURIComponent(escape(atob(data.content)));\n        \n        // Check if the content contains smart.who.int.base in dependencies\n        const isCompatible = content.includes('smart.who.int.base');\n        \n        // Cache the result\n        repositoryCompatibilityCache.set(owner, repo, isCompatible);\n        return { compatible: isCompatible };\n      }\n      \n      // Cache negative result\n      repositoryCompatibilityCache.set(owner, repo, false);\n      return { compatible: false, reason: 'No sushi-config.yaml file found' };\n    } catch (error) {\n      // If it's a 404 (file not found), retry once more in case of temporary issues\n      if (error.status === 404 && retryCount > 0) {\n        console.warn(`File not found for ${owner}/${repo}, retrying... (${retryCount} attempts left)`);\n        // Use shorter delay in test environment\n        const delay = process.env.NODE_ENV === 'test' ? 10 : 1000;\n        await new Promise(resolve => setTimeout(resolve, delay));\n        return this.checkSmartGuidelinesCompatibility(owner, repo, retryCount - 1);\n      }\n      \n      // Special handling for SAML-protected repositories - fallback to public API\n      if (error.status === 403 && error.message.includes('SAML enforcement') && this.octokit) {\n        console.log(`SAML-protected repository ${owner}/${repo}, trying public API fallback`);\n        \n        try {\n          // Try with public API (unauthenticated)\n          const publicOctokit = await this.createOctokitInstance();\n          const { data } = await publicOctokit.rest.repos.getContent({\n            owner,\n            repo,\n            path: 'sushi-config.yaml',\n          });\n\n          if (data.type === 'file' && data.content) {\n            // Decode base64 content (browser-compatible)\n            const content = decodeURIComponent(escape(atob(data.content)));\n            \n            // Check if the content contains smart.who.int.base in dependencies\n            const isCompatible = content.includes('smart.who.int.base');\n            \n            if (isCompatible) {\n              console.log(`Repository ${owner}/${repo} is compatible via public API despite SAML protection`);\n              \n              // Cache the result\n              repositoryCompatibilityCache.set(owner, repo, true);\n              return { \n                compatible: true, \n                reason: 'SMART Guidelines DAK (SAML-protected, verified via public API)',\n                requiresAuthentication: true\n              };\n            } else {\n              // Cache negative result\n              repositoryCompatibilityCache.set(owner, repo, false);\n              return { compatible: false, reason: 'No smart.who.int.base dependency found (via public API)' };\n            }\n          }\n        } catch (publicApiError) {\n          console.warn(`Public API fallback also failed for ${owner}/${repo}:`, publicApiError.message);\n          // Continue to normal error handling\n        }\n      }\n      \n      // For any other error (including rate limiting, network errors, or file not found after retries),\n      // return error information instead of just logging\n      const errorInfo = {\n        compatible: false,\n        error: error.message,\n        errorType: this._categorizeError(error),\n        status: error.status,\n        retryable: this._isRetryableError(error)\n      };\n\n      console.warn(`Failed to check ${owner}/${repo} for sushi-config.yaml with smart.who.int.base dependency:`, error.message);\n      \n      // Cache negative result\n      repositoryCompatibilityCache.set(owner, repo, false);\n      return errorInfo;\n    }\n  }\n\n  // Helper method to categorize errors\n  _categorizeError(error) {\n    if (error.status === 403) {\n      if (error.message.includes('rate limit')) {\n        return 'rate_limit';\n      }\n      return 'permission_denied';\n    }\n    if (error.status === 404) {\n      return 'not_found';\n    }\n    if (error.status === 401) {\n      return 'authentication_failed';\n    }\n    if (error.code === 'ENOTFOUND' || error.code === 'ECONNRESET') {\n      return 'network_error';\n    }\n    return 'unknown_error';\n  }\n\n  // Helper method to determine if error is retryable\n  _isRetryableError(error) {\n    return ['rate_limit', 'network_error'].includes(this._categorizeError(error));\n  }\n\n\n\n  // Get repositories that are SMART guidelines compatible\n  async getSmartGuidelinesRepositories(owner, type = 'user', skipCompatibilityCheck = false) {\n    try {\n      let repositories = [];\n      \n      if (this.isAuth()) {\n        // Use authenticated API for full access\n        let page = 1;\n        let hasMorePages = true;\n\n        // Fetch all repositories using pagination\n        while (hasMorePages) {\n          let response;\n          if (type === 'user') {\n            response = await this.octokit.rest.repos.listForUser({\n              username: owner,\n              sort: 'updated',\n              per_page: 100,\n              page: page,\n            });\n          } else {\n            response = await this.octokit.rest.repos.listForOrg({\n              org: owner,\n              sort: 'updated',\n              per_page: 100,\n              page: page,\n            });\n          }\n\n          repositories = repositories.concat(response.data);\n          \n          // Check if there are more pages\n          hasMorePages = response.data.length === 100;\n          page++;\n        }\n      } else {\n        // Use public API for unauthenticated access (only public repositories)\n        repositories = await this.getPublicRepositories(owner, type);\n      }\n\n      // Skip compatibility checks if requested (to avoid rate limiting for unauthenticated users)\n      if (skipCompatibilityCheck) {\n        console.log(` Skipping compatibility checks for ${repositories.length} repositories to avoid rate limiting`);\n        return repositories.map(repo => ({\n          ...repo,\n          smart_guidelines_compatible: true // Assume compatible when skipping checks\n        }));\n      }\n\n      // Check each repository for SMART guidelines compatibility\n      const smartGuidelinesRepos = [];\n      for (const repo of repositories) {\n        const compatibilityResult = await this.checkSmartGuidelinesCompatibility(repo.owner.login, repo.name);\n        if (compatibilityResult.compatible) {\n          smartGuidelinesRepos.push({\n            ...repo,\n            smart_guidelines_compatible: true\n          });\n        }\n      }\n\n      return smartGuidelinesRepos;\n    } catch (error) {\n      console.error('Failed to fetch SMART guidelines repositories:', error);\n      throw error;\n    }\n  }\n\n  // Get repositories with progressive scanning (for real-time updates)\n  async getSmartGuidelinesRepositoriesProgressive(owner, type = 'user', onRepositoryFound = null, onProgress = null, onError = null) {\n    try {\n      let repositories = [];\n      let page = 1;\n      let hasMorePages = true;\n\n      if (this.isAuth()) {\n        // Fetch all repositories using pagination when authenticated\n        while (hasMorePages) {\n          let response;\n          if (type === 'user') {\n            response = await this.octokit.rest.repos.listForUser({\n              username: owner,\n              sort: 'updated',\n              per_page: 100,\n              page: page,\n            });\n          } else {\n            response = await this.octokit.rest.repos.listForOrg({\n              org: owner,\n              sort: 'updated',\n              per_page: 100,\n              page: page,\n            });\n          }\n\n          repositories = repositories.concat(response.data);\n          \n          // Check if there are more pages\n          hasMorePages = response.data.length === 100;\n          page++;\n        }\n      } else {\n        // Use public API for unauthenticated access (only public repositories)\n        repositories = await this.getPublicRepositories(owner, type);\n      }\n\n      // Handle case where user has no repositories\n      if (repositories.length === 0) {\n        console.log(' No repositories found for user, completing scan immediately');\n        // Call progress callback to indicate completion\n        if (onProgress) {\n          onProgress({\n            current: 0,\n            total: 0,\n            currentRepo: 'none',\n            progress: 100,\n            completed: true\n          });\n        }\n        return [];\n      }\n\n      // Track scanning errors for reporting\n      const scanningErrors = {\n        rateLimited: [],\n        networkErrors: [],\n        permissionDenied: [],\n        otherErrors: [],\n        totalErrors: 0,\n        totalScanned: 0\n      };\n\n      // Process repositories concurrently with rate limiting and enhanced display\n      const processor = async (repo, index) => {\n        // Add a small delay to make scanning progress visible (similar to demo mode)\n        await new Promise(resolve => setTimeout(resolve, 100 + Math.random() * 200));\n        \n        const compatibilityResult = await this.checkSmartGuidelinesCompatibility(repo.owner.login, repo.name);\n        scanningErrors.totalScanned++;\n\n        // Handle the new return format\n        if (compatibilityResult.compatible) {\n          const smartRepo = {\n            ...repo,\n            smart_guidelines_compatible: true\n          };\n          \n          // Notify that a repository was found\n          if (onRepositoryFound) {\n            onRepositoryFound(smartRepo);\n          }\n          \n          return smartRepo;\n        } else if (compatibilityResult.error) {\n          // Track the error for reporting\n          scanningErrors.totalErrors++;\n          const errorInfo = {\n            repo: repo.name,\n            error: compatibilityResult.error,\n            errorType: compatibilityResult.errorType,\n            retryable: compatibilityResult.retryable\n          };\n\n          switch (compatibilityResult.errorType) {\n            case 'rate_limit':\n              scanningErrors.rateLimited.push(errorInfo);\n              break;\n            case 'network_error':\n              scanningErrors.networkErrors.push(errorInfo);\n              break;\n            case 'permission_denied':\n              scanningErrors.permissionDenied.push(errorInfo);\n              break;\n            default:\n              scanningErrors.otherErrors.push(errorInfo);\n          }\n\n          // Report error if callback provided\n          if (onError) {\n            onError(errorInfo);\n          }\n        }\n        \n        return null;\n      };\n\n      // Use concurrent processing with max 5 parallel requests\n      const results = await processConcurrently(repositories, processor, {\n        concurrency: 5,\n        onProgress: (completed, total, repo, result) => {\n          // Progress callback for completed items\n          if (onProgress) {\n            const progressData = {\n              current: completed,\n              total: total,\n              currentRepo: repo.name,\n              progress: Math.round((completed / total) * 100),\n              completed: true,\n              scanningErrors: scanningErrors.totalErrors > 0 ? {\n                totalErrors: scanningErrors.totalErrors,\n                rateLimitedCount: scanningErrors.rateLimited.length,\n                networkErrorCount: scanningErrors.networkErrors.length,\n                hasRetryableErrors: [...scanningErrors.rateLimited, ...scanningErrors.networkErrors].some(e => e.retryable)\n              } : null\n            };\n            onProgress(progressData);\n          }\n        },\n        onItemStart: (repo, index) => {\n          // Progress callback for started items\n          if (onProgress) {\n            onProgress({\n              current: index + 1,\n              total: repositories.length,\n              currentRepo: repo.name,\n              progress: Math.round(((index + 1) / repositories.length) * 100),\n              completed: false,\n              started: true\n            });\n          }\n        }\n      });\n\n      // Filter out null results and collect smart repositories\n      const validResults = results.filter(result => result !== null && !result.error);\n      \n      // Log summary of scanning results\n      if (scanningErrors.totalErrors > 0) {\n        console.warn(`Repository scanning completed with ${scanningErrors.totalErrors} errors out of ${scanningErrors.totalScanned} repositories checked:`);\n        if (scanningErrors.rateLimited.length > 0) {\n          console.warn(`- Rate limited: ${scanningErrors.rateLimited.length} repositories`);\n        }\n        if (scanningErrors.networkErrors.length > 0) {\n          console.warn(`- Network errors: ${scanningErrors.networkErrors.length} repositories`);\n        }\n        if (scanningErrors.permissionDenied.length > 0) {\n          console.warn(`- Permission denied: ${scanningErrors.permissionDenied.length} repositories`);\n        }\n        if (scanningErrors.otherErrors.length > 0) {\n          console.warn(`- Other errors: ${scanningErrors.otherErrors.length} repositories`);\n        }\n      }\n\n      // Return results along with error summary\n      return {\n        repositories: validResults,\n        scanningErrors: scanningErrors.totalErrors > 0 ? scanningErrors : null\n      };\n    } catch (error) {\n      console.error('Failed to fetch SMART guidelines repositories:', error);\n      throw error;\n    }\n  }\n\n  // Get a specific repository\n  async getRepository(owner, repo) {\n    try {\n      // Use authenticated octokit if available, otherwise create a public instance for public repos\n      const octokit = this.isAuth() ? this.octokit : await this.createOctokitInstance();\n      \n      const { data } = await octokit.rest.repos.get({\n        owner,\n        repo,\n      });\n      return data;\n    } catch (error) {\n      console.error('Failed to fetch repository:', error);\n      throw error;\n    }  \n  }\n\n  // Get repository branches\n  async getBranches(owner, repo) {\n    try {\n      console.log(`githubService.getBranches: Fetching branches for ${owner}/${repo}`);\n      console.log('githubService.getBranches: Authentication status:', this.isAuth());\n      \n      // Use authenticated octokit if available, otherwise create a public instance for public repos\n      const octokit = this.isAuth() ? this.octokit : await this.createOctokitInstance();\n      console.log('githubService.getBranches: Using', this.isAuth() ? 'authenticated' : 'public', 'octokit instance');\n      \n      const { data } = await octokit.rest.repos.listBranches({\n        owner,\n        repo,\n        per_page: 100\n      });\n      \n      console.log(`githubService.getBranches: Successfully fetched ${data.length} branches`);\n      return data;\n    } catch (error) {\n      console.error('githubService.getBranches: Failed to fetch branches:', error);\n      console.error('githubService.getBranches: Error details:', {\n        status: error.status,\n        message: error.message,\n        owner,\n        repo\n      });\n      throw error;\n    }\n  }\n\n  // Create a new branch\n  async createBranch(owner, repo, branchName, fromBranch = 'main') {\n    if (!this.isAuth()) {\n      throw new Error('Not authenticated with GitHub');\n    }\n\n    try {\n      // First get the SHA of the source branch\n      const { data: refData } = await this.octokit.rest.git.getRef({\n        owner,\n        repo,\n        ref: `heads/${fromBranch}`\n      });\n\n      // Create the new branch\n      const { data } = await this.octokit.rest.git.createRef({\n        owner,\n        repo,\n        ref: `refs/heads/${branchName}`,\n        sha: refData.object.sha\n      });\n\n      return data;\n    } catch (error) {\n      console.error('Failed to create branch:', error);\n      throw error;\n    }\n  }\n\n  // Get a specific branch\n  async getBranch(owner, repo, branch) {\n    try {\n      // Use authenticated octokit if available, otherwise create a public instance for public repos\n      const octokit = this.isAuth() ? this.octokit : await this.createOctokitInstance();\n      \n      const { data } = await octokit.rest.repos.getBranch({\n        owner,\n        repo,\n        branch\n      });\n      return data;\n    } catch (error) {\n      console.error('Failed to fetch branch:', error);\n      throw error;\n    }\n  }\n\n  // GitHub Actions API methods\n  \n  // Get workflows for a repository (using GitHub API to include workflow IDs)\n  async getWorkflows(owner, repo) {\n    if (!this.isAuth()) {\n      throw new Error('Not authenticated with GitHub');\n    }\n\n    try {\n      // Use GitHub Actions API to get workflows with their IDs\n      const { data } = await this.octokit.rest.actions.listRepoWorkflows({\n        owner,\n        repo\n      });\n\n      return data.workflows.map(workflow => ({\n        id: workflow.id, // This is the crucial missing piece!\n        name: workflow.name,\n        filename: workflow.path.split('/').pop(), // Extract filename from path\n        path: workflow.path,\n        state: workflow.state,\n        created_at: workflow.created_at,\n        updated_at: workflow.updated_at,\n        url: workflow.html_url,\n        triggers: ['unknown'], // GitHub API doesn't provide trigger info directly\n        lastModified: workflow.updated_at\n      }));\n    } catch (error) {\n      if (error.status === 404) {\n        // No workflows or repository not found\n        return [];\n      }\n      console.error('Failed to fetch workflows:', error);\n      throw error;\n    }\n  }\n\n  // Get workflow runs for a repository\n  async getWorkflowRuns(owner, repo, options = {}) {\n    if (!this.isAuth()) {\n      throw new Error('Not authenticated with GitHub');\n    }\n\n    try {\n      const params = {\n        owner,\n        repo,\n        per_page: options.per_page || 10,\n        page: options.page || 1\n      };\n\n      if (options.branch) {\n        params.branch = options.branch;\n      }\n\n      if (options.workflow_id) {\n        params.workflow_id = options.workflow_id;\n      }\n\n      const { data } = await this.octokit.rest.actions.listWorkflowRunsForRepo(params);\n      return data;\n    } catch (error) {\n      console.error('Failed to fetch workflow runs:', error);\n      throw error;\n    }\n  }\n\n  // Get workflow runs for a specific workflow\n  async getWorkflowRunsForWorkflow(owner, repo, workflow_id, options = {}) {\n    if (!this.isAuth()) {\n      throw new Error('Not authenticated with GitHub');\n    }\n\n    try {\n      const params = {\n        owner,\n        repo,\n        workflow_id,\n        per_page: options.per_page || 10,\n        page: options.page || 1\n      };\n\n      if (options.branch) {\n        params.branch = options.branch;\n      }\n\n      const { data } = await this.octokit.rest.actions.listWorkflowRuns(params);\n      return data;\n    } catch (error) {\n      console.error('Failed to fetch workflow runs for workflow:', error);\n      throw error;\n    }\n  }\n\n  // Trigger a workflow run\n  async triggerWorkflow(owner, repo, workflow_id, ref = 'main', inputs = {}) {\n    if (!this.isAuth()) {\n      throw new Error('Not authenticated with GitHub');\n    }\n\n    try {\n      const { data } = await this.octokit.rest.actions.createWorkflowDispatch({\n        owner,\n        repo,\n        workflow_id,\n        ref,\n        inputs\n      });\n      return data;\n    } catch (error) {\n      console.error('Failed to trigger workflow:', error);\n      throw error;\n    }\n  }\n\n  // Re-run a workflow\n  async rerunWorkflow(owner, repo, run_id) {\n    if (!this.isAuth()) {\n      throw new Error('Not authenticated with GitHub');\n    }\n\n    try {\n      const { data } = await this.octokit.rest.actions.reRunWorkflow({\n        owner,\n        repo,\n        run_id\n      });\n      return data;\n    } catch (error) {\n      console.error('Failed to re-run workflow:', error);\n      throw error;\n    }\n  }\n\n  // Get workflow run logs\n  async getWorkflowRunLogs(owner, repo, run_id) {\n    if (!this.isAuth()) {\n      throw new Error('Not authenticated with GitHub');\n    }\n\n    try {\n      const { data } = await this.octokit.rest.actions.downloadWorkflowRunLogs({\n        owner,\n        repo,\n        run_id\n      });\n      return data;\n    } catch (error) {\n      console.error('Failed to get workflow run logs:', error);\n      throw error;\n    }\n  }\n\n  // Approve a workflow run\n  async approveWorkflowRun(owner, repo, run_id) {\n    if (!this.isAuth()) {\n      throw new Error('Not authenticated with GitHub');\n    }\n\n    try {\n      const { data } = await this.octokit.rest.actions.approveWorkflowRun({\n        owner,\n        repo,\n        run_id\n      });\n      return data;\n    } catch (error) {\n      console.error('Failed to approve workflow run:', error);\n      throw error;\n    }\n  }\n\n  // Get commit comparison (diff)\n  async getCommitDiff(owner, repo, base, head) {\n    if (!this.isAuth()) {\n      throw new Error('Not authenticated with GitHub');\n    }\n\n    try {\n      const { data } = await this.octokit.rest.repos.compareCommits({\n        owner,\n        repo,\n        base,\n        head\n      });\n      return data;\n    } catch (error) {\n      console.error('Failed to get commit diff:', error);\n      throw error;\n    }\n  }\n\n  // Get commit details\n  async getCommit(owner, repo, sha) {\n    if (!this.isAuth()) {\n      throw new Error('Not authenticated with GitHub');\n    }\n\n    try {\n      const { data } = await this.octokit.rest.repos.getCommit({\n        owner,\n        repo,\n        ref: sha\n      });\n      return data;\n    } catch (error) {\n      console.error('Failed to get commit details:', error);\n      throw error;\n    }\n  }\n\n  // Releases API methods\n\n  // Get releases for a repository\n  async getReleases(owner, repo, options = {}) {\n    if (!this.isAuth()) {\n      throw new Error('Not authenticated with GitHub');\n    }\n\n    try {\n      const { data } = await this.octokit.rest.repos.listReleases({\n        owner,\n        repo,\n        per_page: options.per_page || 10,\n        page: options.page || 1\n      });\n      return data;\n    } catch (error) {\n      console.error('Failed to fetch releases:', error);\n      throw error;\n    }\n  }\n\n  // Get latest release\n  async getLatestRelease(owner, repo) {\n    if (!this.isAuth()) {\n      throw new Error('Not authenticated with GitHub');\n    }\n\n    try {\n      const { data } = await this.octokit.rest.repos.getLatestRelease({\n        owner,\n        repo\n      });\n      return data;\n    } catch (error) {\n      console.error('Failed to fetch latest release:', error);\n      throw error;\n    }\n  }\n\n  // Recursively fetch BPMN files from a directory and its subdirectories\n  async getBpmnFilesRecursive(owner, repo, path, ref = 'main', allFiles = []) {\n    try {\n      console.log(` githubService.getBpmnFilesRecursive: Searching ${owner}/${repo}/${path} (ref: ${ref})`);\n      // Use authenticated octokit if available, otherwise create a public instance\n      const octokit = this.isAuth() ? this.octokit : await this.createOctokitInstance();\n      console.log(` githubService.getBpmnFilesRecursive: Using ${this.isAuth() ? 'authenticated' : 'public'} octokit`);\n      \n      const { data } = await octokit.rest.repos.getContent({\n        owner,\n        repo,\n        path,\n        ref\n      });\n\n      console.log(` githubService.getBpmnFilesRecursive: Received data type: ${Array.isArray(data) ? 'array' : 'single file'}, length: ${Array.isArray(data) ? data.length : 1}`);\n\n      // Handle single file response\n      if (!Array.isArray(data)) {\n        if (data.name.endsWith('.bpmn')) {\n          console.log(` githubService.getBpmnFilesRecursive: Found single BPMN file: ${data.name}`);\n          allFiles.push(data);\n        }\n        return allFiles;\n      }\n\n      // Handle directory response\n      for (const item of data) {\n        if (item.type === 'file' && item.name.endsWith('.bpmn')) {\n          console.log(` githubService.getBpmnFilesRecursive: Found BPMN file: ${item.name}`);\n          allFiles.push(item);\n        } else if (item.type === 'dir') {\n          console.log(` githubService.getBpmnFilesRecursive: Found subdirectory: ${item.name}, recursing...`);\n          // Recursively search subdirectories\n          await this.getBpmnFilesRecursive(owner, repo, item.path, ref, allFiles);\n        }\n      }\n\n      console.log(` githubService.getBpmnFilesRecursive: Completed search of ${path}, found ${allFiles.length} total files so far`);\n      return allFiles;\n    } catch (error) {\n      console.log(` githubService.getBpmnFilesRecursive: Error searching ${path}:`, error.status, error.message);\n      // If directory doesn't exist, return empty array (not an error)\n      if (error.status === 404) {\n        return allFiles;\n      }\n      throw error;\n    }\n  }\n\n  // Get all BPMN files from a repository's business process directories\n  async getBpmnFiles(owner, repo, ref = 'main') {\n    console.log(` githubService.getBpmnFiles: Starting search for ${owner}/${repo} (ref: ${ref})`);\n    const allBpmnFiles = [];\n    \n    // Search for BPMN files in the specified business process directories\n    const possiblePaths = [\n      'input/business-processes',\n      'input/business-process'\n    ];\n\n    for (const path of possiblePaths) {\n      try {\n        console.log(` githubService.getBpmnFiles: Searching in directory: ${path}`);\n        const files = await this.getBpmnFilesRecursive(owner, repo, path, ref);\n        console.log(` githubService.getBpmnFiles: Found ${files.length} BPMN files in ${path}`);\n        allBpmnFiles.push(...files);\n      } catch (error) {\n        // Only log warnings for unexpected errors (not 404s which are expected when directories don't exist)\n        if (error.status !== 404) {\n          console.warn(` Could not fetch BPMN files from ${path}:`, error.message);\n        } else {\n          console.log(` githubService.getBpmnFiles: Directory ${path} not found (404) - this is expected if the directory doesn't exist`);\n        }\n        // Continue trying other paths\n      }\n    }\n\n    // Remove duplicates based on path (in case both directories exist and have overlapping files)\n    const uniqueFiles = allBpmnFiles.filter((file, index, self) => \n      index === self.findIndex(f => f.path === file.path)\n    );\n\n    console.log(` githubService.getBpmnFiles: Final result - ${uniqueFiles.length} unique BPMN files found`);\n    console.log(` githubService.getBpmnFiles: File list:`, uniqueFiles.map(f => f.name));\n    return uniqueFiles;\n  }\n\n  // Get file content from GitHub repository with timeout handling\n  async getFileContent(owner, repo, path, ref = 'main') {\n    const timeoutMs = 15000; // 15 second timeout\n    \n    try {\n      console.log(` githubService.getFileContent: Starting request for ${owner}/${repo}/${path} (ref: ${ref})`);\n      console.log(' githubService.getFileContent: Authentication status:', this.isAuth());\n      console.log(' githubService.getFileContent: Request parameters:', { owner, repo, path, ref });\n      \n      // Use authenticated octokit if available, otherwise create a public instance for public repos\n      const octokit = this.isAuth() ? this.octokit : await this.createOctokitInstance();\n      console.log(' githubService.getFileContent: Using', this.isAuth() ? 'authenticated' : 'public', 'octokit instance');\n      \n      // Create a promise that rejects after timeout\n      const timeoutPromise = new Promise((_, reject) => {\n        console.log(` githubService.getFileContent: Setting up ${timeoutMs}ms timeout`);\n        setTimeout(() => {\n          console.error(` githubService.getFileContent: Request timed out after ${timeoutMs}ms`);\n          reject(new Error(`Request timeout after ${timeoutMs}ms`));\n        }, timeoutMs);\n      });\n      \n      // Race the GitHub API call against the timeout\n      console.log(' githubService.getFileContent: Creating GitHub API promise...');\n      const apiPromise = octokit.rest.repos.getContent({\n        owner,\n        repo,\n        path,\n        ref\n      });\n      \n      console.log(' githubService.getFileContent: API request initiated, waiting for response...');\n      const startTime = Date.now();\n      \n      const { data } = await Promise.race([apiPromise, timeoutPromise]);\n      const responseTime = Date.now() - startTime;\n      \n      console.log(` githubService.getFileContent: API response received in ${responseTime}ms`);\n      console.log(' githubService.getFileContent: Response data type:', data.type);\n      console.log(' githubService.getFileContent: Response details:', {\n        type: data.type,\n        name: data.name,\n        size: data.size,\n        encoding: data.encoding,\n        hasContent: !!data.content\n      });\n\n      // Handle file content\n      if (data.type === 'file' && data.content) {\n        // Decode base64 content\n        console.log(' githubService.getFileContent: Decoding base64 content...');\n        console.log(' githubService.getFileContent: Base64 content length:', data.content.length);\n        \n        try {\n          // Use modern Buffer approach for reliable base64 decoding\n          const content = Buffer.from(data.content, 'base64').toString('utf-8');\n          console.log(` githubService.getFileContent: Successfully fetched and decoded file content`);\n          console.log(' githubService.getFileContent: Final content length:', content.length, 'characters');\n          console.log(' githubService.getFileContent: Content preview (first 200 chars):', content.substring(0, 200));\n          \n          return content;\n        } catch (decodeError) {\n          console.error(' githubService.getFileContent: Base64 decoding failed:', decodeError);\n          console.error(' githubService.getFileContent: Raw base64 content preview:', data.content.substring(0, 100));\n          throw new Error(`Failed to decode file content: ${decodeError.message}`);\n        }\n      } else {\n        console.error(' githubService.getFileContent: Invalid response - not a file or no content');\n        console.error(' githubService.getFileContent: Full response data:', JSON.stringify(data, null, 2));\n        throw new Error('File not found or is not a file');\n      }\n    } catch (error) {\n      console.error(` githubService.getFileContent: Failed to fetch file content from ${owner}/${repo}/${path}:`, error);\n      console.error(' githubService.getFileContent: Error analysis:', {\n        type: typeof error,\n        status: error.status,\n        message: error.message,\n        name: error.name,\n        stack: error.stack?.substring(0, 500) + '...'\n      });\n      \n      // Provide more specific error messages\n      if (error.message.includes('timeout')) {\n        console.error(' githubService.getFileContent: Timeout error detected');\n        throw new Error(`GitHub API request timed out after ${timeoutMs / 1000} seconds. Please try again.`);\n      } else if (error.status === 403) {\n        console.error(' githubService.getFileContent: 403 Forbidden error detected');\n        throw new Error('Access denied. This repository may be private or you may have hit rate limits.');\n      } else if (error.status === 404) {\n        console.error(' githubService.getFileContent: 404 Not Found error detected');\n        throw new Error('File not found in the repository.');\n      } else if (error.message.includes('rate limit')) {\n        console.error(' githubService.getFileContent: Rate limit error detected');\n        throw new Error('GitHub API rate limit exceeded. Please try again later.');\n      } else if (error.message.includes('Network Error') || error.message.includes('Failed to fetch')) {\n        console.error(' githubService.getFileContent: Network error detected');\n        throw new Error('Network error occurred. Please check your internet connection and try again.');\n      }\n      \n      console.error(' githubService.getFileContent: Unknown error type, re-throwing original error');\n      throw error;\n    }\n  }\n\n  // Create a commit with multiple files\n  async createCommit(owner, repo, branch, message, files) {\n    if (!this.isAuth()) {\n      throw new Error('Not authenticated with GitHub');\n    }\n\n    try {\n      // Get the latest commit SHA\n      const { data: refData } = await this.octokit.rest.git.getRef({\n        owner,\n        repo,\n        ref: `heads/${branch}`\n      });\n      const latestCommitSha = refData.object.sha;\n\n      // Get the tree SHA from the latest commit\n      const { data: commitData } = await this.octokit.rest.git.getCommit({\n        owner,\n        repo,\n        commit_sha: latestCommitSha\n      });\n      const baseTreeSha = commitData.tree.sha;\n\n      // Create blobs for all files\n      const blobs = await Promise.all(\n        files.map(async (file) => {\n          const { data: blobData } = await this.octokit.rest.git.createBlob({\n            owner,\n            repo,\n            content: file.content,\n            encoding: 'utf-8'\n          });\n          return {\n            path: file.path,\n            mode: '100644',\n            type: 'blob',\n            sha: blobData.sha\n          };\n        })\n      );\n\n      // Create a new tree with the blobs\n      const { data: treeData } = await this.octokit.rest.git.createTree({\n        owner,\n        repo,\n        base_tree: baseTreeSha,\n        tree: blobs\n      });\n\n      // Create the commit\n      const { data: newCommitData } = await this.octokit.rest.git.createCommit({\n        owner,\n        repo,\n        message,\n        tree: treeData.sha,\n        parents: [latestCommitSha]\n      });\n\n      // Update the branch reference\n      await this.octokit.rest.git.updateRef({\n        owner,\n        repo,\n        ref: `heads/${branch}`,\n        sha: newCommitData.sha\n      });\n\n      return {\n        sha: newCommitData.sha,\n        html_url: `https://github.com/${owner}/${repo}/commit/${newCommitData.sha}`,\n        message: newCommitData.message,\n        author: newCommitData.author,\n        committer: newCommitData.committer\n      };\n    } catch (error) {\n      console.error('Failed to create commit:', error);\n      throw error;\n    }\n  }\n\n  // Get recent commits for a repository branch\n  async getRecentCommits(owner, repo, branch = 'main', per_page = 5) {\n    if (!this.isAuth()) {\n      throw new Error('Not authenticated with GitHub');\n    }\n\n    const startTime = Date.now();\n    this.logger.apiCall('GET', `/repos/${owner}/${repo}/commits`, { sha: branch, per_page });\n\n    try {\n      const response = await this.octokit.rest.repos.listCommits({\n        owner,\n        repo,\n        sha: branch,\n        per_page\n      });\n\n      this.logger.apiResponse('GET', `/repos/${owner}/${repo}/commits`, response.status, Date.now() - startTime);\n      \n      return response.data.map(commit => ({\n        sha: commit.sha,\n        message: commit.commit.message,\n        author: {\n          name: commit.commit.author.name,\n          email: commit.commit.author.email,\n          date: commit.commit.author.date\n        },\n        committer: {\n          name: commit.commit.committer.name,\n          email: commit.commit.committer.email,\n          date: commit.commit.committer.date\n        },\n        html_url: commit.html_url,\n        stats: commit.stats\n      }));\n    } catch (error) {\n      this.logger.apiResponse('GET', `/repos/${owner}/${repo}/commits`, error.status || 'error', Date.now() - startTime);\n      console.error('Failed to fetch recent commits:', error);\n      throw error;\n    }\n  }\n\n  // Get open pull requests count\n  async getOpenPullRequestsCount(owner, repo) {\n    if (!this.isAuth()) {\n      throw new Error('Not authenticated with GitHub');\n    }\n\n    const startTime = Date.now();\n    this.logger.apiCall('GET', `/repos/${owner}/${repo}/pulls`, { state: 'open', per_page: 1 });\n\n    try {\n      const response = await this.octokit.rest.pulls.list({\n        owner,\n        repo,\n        state: 'open',\n        per_page: 1\n      });\n\n      this.logger.apiResponse('GET', `/repos/${owner}/${repo}/pulls`, response.status, Date.now() - startTime);\n      \n      // GitHub includes the total count in the response headers\n      const linkHeader = response.headers.link;\n      if (linkHeader && linkHeader.includes('rel=\"last\"')) {\n        const lastPageMatch = linkHeader.match(/page=(\\d+)>; rel=\"last\"/);\n        if (lastPageMatch) {\n          return parseInt(lastPageMatch[1], 10);\n        }\n      }\n      \n      // Fallback: use the length of returned items (may not be accurate for large counts)\n      return response.data.length;\n    } catch (error) {\n      this.logger.apiResponse('GET', `/repos/${owner}/${repo}/pulls`, error.status || 'error', Date.now() - startTime);\n      console.error('Failed to fetch pull requests count:', error);\n      throw error;\n    }\n  }\n\n  // Get pull request for a specific branch (returns first PR only for backward compatibility)\n  async getPullRequestForBranch(owner, repo, branchName) {\n    const prs = await this.getPullRequestsForBranch(owner, repo, branchName);\n    return prs && prs.length > 0 ? prs[0] : null;\n  }\n\n  // Get all pull requests for a specific branch\n  async getPullRequestsForBranch(owner, repo, branchName) {\n    // Use authenticated octokit if available, otherwise create a public instance for public repos\n    const octokit = this.isAuth() ? this.octokit : await this.createOctokitInstance();\n\n    const startTime = Date.now();\n    this.logger.apiCall('GET', `/repos/${owner}/${repo}/pulls`, { state: 'open', head: `${owner}:${branchName}` });\n\n    try {\n      const response = await octokit.rest.pulls.list({\n        owner,\n        repo,\n        state: 'open',\n        head: `${owner}:${branchName}`,\n        per_page: 100 // Get up to 100 PRs for a branch\n      });\n\n      this.logger.apiResponse('GET', `/repos/${owner}/${repo}/pulls`, response.status, Date.now() - startTime);\n      \n      // Return all matching PRs or empty array if none found\n      return response.data || [];\n    } catch (error) {\n      this.logger.apiResponse('GET', `/repos/${owner}/${repo}/pulls`, error.status || 'error', Date.now() - startTime);\n      console.error('Failed to fetch pull requests for branch:', error);\n      return []; // Return empty array instead of throwing to allow graceful fallback\n    }\n  }\n\n  // Get pull request comments\n  async getPullRequestComments(owner, repo, pullNumber, page = 1, per_page = 100) {\n    // Use authenticated octokit if available, otherwise create a public instance for public repos\n    const octokit = this.isAuth() ? this.octokit : await this.createOctokitInstance();\n\n    const startTime = Date.now();\n    this.logger.apiCall('GET', `/repos/${owner}/${repo}/pulls/${pullNumber}/comments`, { page, per_page });\n\n    try {\n      const response = await octokit.rest.pulls.listReviewComments({\n        owner,\n        repo,\n        pull_number: pullNumber,\n        page,\n        per_page\n      });\n\n      this.logger.apiResponse('GET', `/repos/${owner}/${repo}/pulls/${pullNumber}/comments`, response.status, Date.now() - startTime);\n      return response.data;\n    } catch (error) {\n      this.logger.apiResponse('GET', `/repos/${owner}/${repo}/pulls/${pullNumber}/comments`, error.status || 'error', Date.now() - startTime);\n      console.error('Failed to fetch pull request comments:', error);\n      throw error;\n    }\n  }\n\n  // Get pull request issue comments (general comments on the PR conversation)\n  async getPullRequestIssueComments(owner, repo, pullNumber, page = 1, per_page = 100) {\n    // Use authenticated octokit if available, otherwise create a public instance for public repos\n    const octokit = this.isAuth() ? this.octokit : await this.createOctokitInstance();\n\n    const startTime = Date.now();\n    this.logger.apiCall('GET', `/repos/${owner}/${repo}/issues/${pullNumber}/comments`, { page, per_page });\n\n    try {\n      const response = await octokit.rest.issues.listComments({\n        owner,\n        repo,\n        issue_number: pullNumber,\n        page,\n        per_page\n      });\n\n      this.logger.apiResponse('GET', `/repos/${owner}/${repo}/issues/${pullNumber}/comments`, response.status, Date.now() - startTime);\n      return response.data;\n    } catch (error) {\n      this.logger.apiResponse('GET', `/repos/${owner}/${repo}/issues/${pullNumber}/comments`, error.status || 'error', Date.now() - startTime);\n      console.error('Failed to fetch pull request issue comments:', error);\n      throw error;\n    }\n  }\n\n  // Create a comment on a pull request\n  async createPullRequestComment(owner, repo, pullNumber, body) {\n    if (!this.isAuth()) {\n      throw new Error('Not authenticated with GitHub');\n    }\n\n    const startTime = Date.now();\n    this.logger.apiCall('POST', `/repos/${owner}/${repo}/issues/${pullNumber}/comments`, { body });\n\n    try {\n      const response = await this.octokit.rest.issues.createComment({\n        owner,\n        repo,\n        issue_number: pullNumber,\n        body\n      });\n\n      this.logger.apiResponse('POST', `/repos/${owner}/${repo}/issues/${pullNumber}/comments`, response.status, Date.now() - startTime);\n      return response.data;\n    } catch (error) {\n      this.logger.apiResponse('POST', `/repos/${owner}/${repo}/issues/${pullNumber}/comments`, error.status || 'error', Date.now() - startTime);\n      console.error('Failed to create pull request comment:', error);\n      throw error;\n    }\n  }\n\n  // Get pull request timeline events (status updates, reviews, etc.)\n  async getPullRequestTimeline(owner, repo, pullNumber, page = 1, per_page = 100) {\n    // Use authenticated octokit if available, otherwise create a public instance for public repos\n    const octokit = this.isAuth() ? this.octokit : await this.createOctokitInstance();\n\n    const startTime = Date.now();\n    this.logger.apiCall('GET', `/repos/${owner}/${repo}/issues/${pullNumber}/timeline`, { page, per_page });\n\n    try {\n      const response = await octokit.rest.issues.listEventsForTimeline({\n        owner,\n        repo,\n        issue_number: pullNumber,\n        page,\n        per_page\n      });\n\n      this.logger.apiResponse('GET', `/repos/${owner}/${repo}/issues/${pullNumber}/timeline`, response.status, Date.now() - startTime);\n      return response.data;\n    } catch (error) {\n      this.logger.apiResponse('GET', `/repos/${owner}/${repo}/issues/${pullNumber}/timeline`, error.status || 'error', Date.now() - startTime);\n      console.debug('Failed to fetch pull request timeline:', error);\n      return []; // Return empty array for graceful fallback\n    }\n  }\n\n  // Merge a pull request\n  async mergePullRequest(owner, repo, pullNumber, options = {}) {\n    if (!this.isAuth()) {\n      throw new Error('Not authenticated with GitHub');\n    }\n\n    const startTime = Date.now();\n    this.logger.apiCall('PUT', `/repos/${owner}/${repo}/pulls/${pullNumber}/merge`, options);\n\n    try {\n      const mergeOptions = {\n        owner,\n        repo,\n        pull_number: pullNumber,\n        commit_title: options.commit_title,\n        commit_message: options.commit_message,\n        merge_method: options.merge_method || 'merge', // 'merge', 'squash', or 'rebase'\n        ...options\n      };\n\n      const response = await this.octokit.rest.pulls.merge(mergeOptions);\n\n      this.logger.apiResponse('PUT', `/repos/${owner}/${repo}/pulls/${pullNumber}/merge`, response.status, Date.now() - startTime);\n      return response.data;\n    } catch (error) {\n      this.logger.apiResponse('PUT', `/repos/${owner}/${repo}/pulls/${pullNumber}/merge`, error.status || 'error', Date.now() - startTime);\n      console.error('Failed to merge pull request:', error);\n      throw error;\n    }\n  }\n\n  // Check if the current user can merge a specific pull request\n  async checkPullRequestMergePermissions(owner, repo, pullNumber) {\n    if (!this.isAuth()) {\n      this.logger.warn('Cannot check PR merge permissions - not authenticated', { owner, repo, pullNumber });\n      return false;\n    }\n\n    try {\n      const startTime = Date.now();\n      this.logger.apiCall('GET', `/repos/${owner}/${repo}/pulls/${pullNumber}`, {});\n\n      // Get the pull request details to check mergeable state and permissions\n      const response = await this.octokit.rest.pulls.get({\n        owner,\n        repo,\n        pull_number: pullNumber\n      });\n\n      this.logger.apiResponse('GET', `/repos/${owner}/${repo}/pulls/${pullNumber}`, response.status, Date.now() - startTime);\n      \n      const pr = response.data;\n      \n      // Check if PR is in a mergeable state\n      if (pr.state !== 'open') {\n        this.logger.debug('PR not mergeable - not open', { owner, repo, pullNumber, state: pr.state });\n        return false;\n      }\n\n      if (pr.draft) {\n        this.logger.debug('PR not mergeable - is draft', { owner, repo, pullNumber });\n        return false;\n      }\n\n      // Check if the user has write permissions to the repository\n      const hasWriteAccess = await this.checkRepositoryWritePermissions(owner, repo);\n      if (!hasWriteAccess) {\n        this.logger.debug('PR not mergeable - no write access', { owner, repo, pullNumber });\n        return false;\n      }\n\n      // Additional checks could include:\n      // - Required status checks\n      // - Required reviews\n      // - Admin enforcement\n      // For now, we'll rely on the GitHub API to provide proper error messages when merge is attempted\n\n      return true;\n    } catch (error) {\n      this.logger.warn('Error checking PR merge permissions', { owner, repo, pullNumber, error: error.message });\n      return false;\n    }\n  }\n\n  // Get open issues count\n  async getOpenIssuesCount(owner, repo) {\n    if (!this.isAuth()) {\n      throw new Error('Not authenticated with GitHub');\n    }\n\n    const startTime = Date.now();\n    this.logger.apiCall('GET', `/repos/${owner}/${repo}/issues`, { state: 'open', per_page: 1 });\n\n    try {\n      const response = await this.octokit.rest.issues.listForRepo({\n        owner,\n        repo,\n        state: 'open',\n        per_page: 1\n      });\n\n      this.logger.apiResponse('GET', `/repos/${owner}/${repo}/issues`, response.status, Date.now() - startTime);\n      \n      // GitHub includes the total count in the response headers\n      const linkHeader = response.headers.link;\n      if (linkHeader && linkHeader.includes('rel=\"last\"')) {\n        const lastPageMatch = linkHeader.match(/page=(\\d+)>; rel=\"last\"/);\n        if (lastPageMatch) {\n          return parseInt(lastPageMatch[1], 10);\n        }\n      }\n      \n      // Fallback: use the length of returned items (may not be accurate for large counts)\n      return response.data.length;\n    } catch (error) {\n      this.logger.apiResponse('GET', `/repos/${owner}/${repo}/issues`, error.status || 'error', Date.now() - startTime);\n      console.error('Failed to fetch issues count:', error);\n      throw error;\n    }\n  }\n\n  // Get repository statistics (combined method for efficiency)\n  async getRepositoryStats(owner, repo, branch = 'main') {\n    if (!this.isAuth()) {\n      throw new Error('Not authenticated with GitHub');\n    }\n\n    try {\n      const [recentCommits, openPRsCount, openIssuesCount] = await Promise.allSettled([\n        this.getRecentCommits(owner, repo, branch, 1),\n        this.getOpenPullRequestsCount(owner, repo),\n        this.getOpenIssuesCount(owner, repo)\n      ]);\n\n      return {\n        recentCommits: recentCommits.status === 'fulfilled' ? recentCommits.value : [],\n        openPullRequestsCount: openPRsCount.status === 'fulfilled' ? openPRsCount.value : 0,\n        openIssuesCount: openIssuesCount.status === 'fulfilled' ? openIssuesCount.value : 0,\n        errors: {\n          recentCommits: recentCommits.status === 'rejected' ? recentCommits.reason : null,\n          openPullRequestsCount: openPRsCount.status === 'rejected' ? openPRsCount.reason : null,\n          openIssuesCount: openIssuesCount.status === 'rejected' ? openIssuesCount.reason : null\n        }\n      };\n    } catch (error) {\n      console.error('Failed to fetch repository stats:', error);\n      throw error;\n    }\n  }\n\n  // Get directory contents (supports both authenticated and unauthenticated access)\n  async getDirectoryContents(owner, repo, path = '', ref = 'main') {\n    try {\n      // Create temporary Octokit instance for unauthenticated access if needed\n      const octokit = this.isAuth() ? this.octokit : await this.createOctokitInstance();\n      \n      const { data } = await octokit.rest.repos.getContent({\n        owner,\n        repo,\n        path,\n        ref\n      });\n\n      if (Array.isArray(data)) {\n        return data;\n      } else {\n        throw new Error('Not a directory');\n      }\n    } catch (error) {\n      console.error(`Failed to get directory contents for ${path}:`, error);\n      throw error;\n    }\n  }\n\n  // Update file content (requires authentication)\n  async updateFile(owner, repo, path, content, message, branch = 'main') {\n    if (!this.isAuth()) {\n      throw new Error('Authentication required to update files');\n    }\n\n    try {\n      // First, get the current file to get its SHA\n      const { data: currentFile } = await this.octokit.rest.repos.getContent({\n        owner,\n        repo,\n        path,\n        ref: branch\n      });\n\n      if (Array.isArray(currentFile)) {\n        throw new Error('Path is a directory, not a file');\n      }\n\n      // Update the file\n      const { data } = await this.octokit.rest.repos.createOrUpdateFileContents({\n        owner,\n        repo,\n        path,\n        message,\n        content: btoa(unescape(encodeURIComponent(content))),\n        sha: currentFile.sha,\n        branch\n      });\n\n      return data;\n    } catch (error) {\n      console.error(`Failed to update file ${path}:`, error);\n      throw error;\n    }\n  }\n\n  // Get commits for a repository (supports unauthenticated access)\n  async getCommits(owner, repo, options = {}) {\n    try {\n      // Create temporary Octokit instance for unauthenticated access if needed\n      const octokit = this.isAuth() ? this.octokit : await this.createOctokitInstance();\n      \n      const params = {\n        owner,\n        repo,\n        per_page: options.per_page || 10,\n        page: options.page || 1\n      };\n\n      if (options.sha) {\n        params.sha = options.sha;\n      }\n\n      if (options.since) {\n        params.since = options.since;\n      }\n\n      if (options.until) {\n        params.until = options.until;\n      }\n\n      const { data } = await octokit.rest.repos.listCommits(params);\n      return data;\n    } catch (error) {\n      console.error('Failed to fetch commits:', error);\n      throw error;\n    }\n  }\n\n  // Get issues for a repository (supports unauthenticated access)\n  async getIssues(owner, repo, options = {}) {\n    try {\n      // Create temporary Octokit instance for unauthenticated access if needed\n      const octokit = this.isAuth() ? this.octokit : await this.createOctokitInstance();\n      \n      const params = {\n        owner,\n        repo,\n        state: options.state || 'all',\n        per_page: options.per_page || 30,\n        page: options.page || 1\n      };\n\n      if (options.labels) {\n        params.labels = options.labels;\n      }\n\n      if (options.milestone) {\n        params.milestone = options.milestone;\n      }\n\n      const { data } = await octokit.rest.issues.listForRepo(params);\n      return data;\n    } catch (error) {\n      console.error('Failed to fetch issues:', error);\n      throw error;\n    }\n  }\n\n  // Alias method for backward compatibility - delegates to getIssues\n  async getRepositoryIssues(owner, repo, options = {}) {\n    return this.getIssues(owner, repo, options);\n  }\n\n  // Get repository forks\n  async getForks(owner, repo, options = {}) {\n    const startTime = Date.now();\n    this.logger.apiCall('GET', `/repos/${owner}/${repo}/forks`, options);\n\n    try {\n      // Use the GitHub API to fetch forks, no authentication required for public repos\n      const octokit = this.isAuth() ? this.octokit : await this.createOctokitInstance();\n      \n      const params = {\n        owner,\n        repo,\n        sort: options.sort || 'newest',\n        per_page: options.per_page || 100,\n        page: options.page || 1\n      };\n\n      const { data } = await octokit.rest.repos.listForks(params);\n      \n      this.logger.apiResponse('GET', `/repos/${owner}/${repo}/forks`, 200, Date.now() - startTime);\n      \n      // Return formatted fork data\n      return data.map(fork => ({\n        id: fork.id,\n        name: fork.name,\n        full_name: fork.full_name,\n        owner: {\n          login: fork.owner.login,\n          avatar_url: fork.owner.avatar_url,\n          html_url: fork.owner.html_url,\n          type: fork.owner.type\n        },\n        description: fork.description,\n        html_url: fork.html_url,\n        clone_url: fork.clone_url,\n        created_at: fork.created_at,\n        updated_at: fork.updated_at,\n        pushed_at: fork.pushed_at,\n        stargazers_count: fork.stargazers_count,\n        forks_count: fork.forks_count,\n        open_issues_count: fork.open_issues_count,\n        default_branch: fork.default_branch,\n        private: fork.private,\n        fork: fork.fork,\n        parent: fork.parent ? {\n          full_name: fork.parent.full_name,\n          html_url: fork.parent.html_url\n        } : null\n      }));\n    } catch (error) {\n      this.logger.apiResponse('GET', `/repos/${owner}/${repo}/forks`, error.status || 'error', Date.now() - startTime);\n      console.error('Failed to fetch repository forks:', error);\n      throw error;\n    }\n  }\n\n  // Get pull requests for a specific repository\n  async getPullRequests(owner, repo, options = {}) {\n    const startTime = Date.now();\n    this.logger.apiCall('GET', `/repos/${owner}/${repo}/pulls`, options);\n\n    try {\n      // Use the GitHub API to fetch pull requests, no authentication required for public repos\n      const octokit = this.isAuth() ? this.octokit : await this.createOctokitInstance();\n      \n      const params = {\n        owner,\n        repo,\n        state: options.state || 'open',\n        sort: options.sort || 'updated',\n        direction: options.direction || 'desc',\n        per_page: options.per_page || 30,\n        page: options.page || 1\n      };\n\n      // Add optional filters\n      if (options.head) {\n        params.head = options.head;\n      }\n      if (options.base) {\n        params.base = options.base;\n      }\n\n      const { data } = await octokit.rest.pulls.list(params);\n      \n      this.logger.apiResponse('GET', `/repos/${owner}/${repo}/pulls`, 200, Date.now() - startTime);\n      \n      // Return formatted pull request data\n      return data.map(pr => ({\n        id: pr.id,\n        number: pr.number,\n        title: pr.title,\n        body: pr.body,\n        state: pr.state,\n        locked: pr.locked,\n        user: {\n          login: pr.user.login,\n          avatar_url: pr.user.avatar_url,\n          html_url: pr.user.html_url,\n          type: pr.user.type\n        },\n        created_at: pr.created_at,\n        updated_at: pr.updated_at,\n        closed_at: pr.closed_at,\n        merged_at: pr.merged_at,\n        html_url: pr.html_url,\n        diff_url: pr.diff_url,\n        patch_url: pr.patch_url,\n        head: {\n          ref: pr.head.ref,\n          sha: pr.head.sha,\n          repo: pr.head.repo ? {\n            name: pr.head.repo.name,\n            full_name: pr.head.repo.full_name,\n            owner: {\n              login: pr.head.repo.owner.login,\n              avatar_url: pr.head.repo.owner.avatar_url\n            },\n            html_url: pr.head.repo.html_url\n          } : null\n        },\n        base: {\n          ref: pr.base.ref,\n          sha: pr.base.sha,\n          repo: {\n            name: pr.base.repo.name,\n            full_name: pr.base.repo.full_name,\n            owner: {\n              login: pr.base.repo.owner.login,\n              avatar_url: pr.base.repo.owner.avatar_url\n            },\n            html_url: pr.base.repo.html_url\n          }\n        },\n        draft: pr.draft,\n        mergeable: pr.mergeable,\n        mergeable_state: pr.mergeable_state,\n        comments: pr.comments,\n        review_comments: pr.review_comments,\n        commits: pr.commits,\n        additions: pr.additions,\n        deletions: pr.deletions,\n        changed_files: pr.changed_files\n      }));\n    } catch (error) {\n      this.logger.apiResponse('GET', `/repos/${owner}/${repo}/pulls`, error.status || 'error', Date.now() - startTime);\n      console.error('Failed to fetch pull requests:', error);\n      throw error;\n    }\n  }\n\n  // Create an issue (requires authentication)\n  async createIssue(owner, repo, title, body, labels = [], assignees = []) {\n    if (!this.isAuth()) {\n      throw new Error('Authentication required to create issues');\n    }\n\n    const startTime = Date.now();\n    this.logger.apiCall('POST', `/repos/${owner}/${repo}/issues`, { title, bodyLength: body?.length, labels, assignees });\n\n    try {\n      const params = {\n        owner,\n        repo,\n        title,\n        body\n      };\n\n      // Add optional parameters if provided\n      if (labels.length > 0) {\n        params.labels = labels;\n      }\n      \n      if (assignees.length > 0) {\n        params.assignees = assignees;\n      }\n\n      const response = await this.octokit.rest.issues.create(params);\n      \n      this.logger.apiResponse('POST', `/repos/${owner}/${repo}/issues`, response.status, Date.now() - startTime);\n      \n      return {\n        success: true,\n        issue: {\n          id: response.data.id,\n          number: response.data.number,\n          title: response.data.title,\n          body: response.data.body,\n          html_url: response.data.html_url,\n          state: response.data.state,\n          created_at: response.data.created_at,\n          user: {\n            login: response.data.user.login,\n            avatar_url: response.data.user.avatar_url\n          },\n          labels: response.data.labels.map(label => ({\n            name: label.name,\n            color: label.color\n          }))\n        }\n      };\n    } catch (error) {\n      this.logger.apiResponse('POST', `/repos/${owner}/${repo}/issues`, error.status || 'error', Date.now() - startTime);\n      console.error('Failed to create issue:', error);\n      \n      // Return structured error response\n      return {\n        success: false,\n        error: {\n          message: error.message,\n          status: error.status,\n          type: error.status === 403 ? 'permission_denied' : \n                error.status === 422 ? 'validation_error' : \n                error.status === 404 ? 'repository_not_found' : 'unknown_error'\n        }\n      };\n    }\n  }\n\n  // Get a specific issue\n  async getIssue(owner, repo, issueNumber) {\n    if (!this.isAuth()) {\n      throw new Error('Authentication required to get issue details');\n    }\n\n    const startTime = Date.now();\n    this.logger.apiCall('GET', `/repos/${owner}/${repo}/issues/${issueNumber}`);\n\n    try {\n      const response = await this.octokit.rest.issues.get({\n        owner,\n        repo,\n        issue_number: issueNumber\n      });\n\n      this.logger.apiResponse('GET', `/repos/${owner}/${repo}/issues/${issueNumber}`, response.status, Date.now() - startTime);\n\n      return {\n        id: response.data.id,\n        number: response.data.number,\n        title: response.data.title,\n        body: response.data.body,\n        html_url: response.data.html_url,\n        state: response.data.state,\n        created_at: response.data.created_at,\n        updated_at: response.data.updated_at,\n        closed_at: response.data.closed_at,\n        user: {\n          login: response.data.user.login,\n          avatar_url: response.data.user.avatar_url\n        },\n        labels: response.data.labels.map(label => ({\n          name: label.name,\n          color: label.color\n        }))\n      };\n    } catch (error) {\n      this.logger.apiResponse('GET', `/repos/${owner}/${repo}/issues/${issueNumber}`, error.status || 'error', Date.now() - startTime);\n      console.error('Failed to get issue:', error);\n      throw error;\n    }\n  }\n\n  // Get a specific pull request\n  async getPullRequest(owner, repo, pullNumber) {\n    if (!this.isAuth()) {\n      throw new Error('Authentication required to get pull request details');\n    }\n\n    const startTime = Date.now();\n    this.logger.apiCall('GET', `/repos/${owner}/${repo}/pulls/${pullNumber}`);\n\n    try {\n      const response = await this.octokit.rest.pulls.get({\n        owner,\n        repo,\n        pull_number: pullNumber\n      });\n\n      this.logger.apiResponse('GET', `/repos/${owner}/${repo}/pulls/${pullNumber}`, response.status, Date.now() - startTime);\n\n      return {\n        id: response.data.id,\n        number: response.data.number,\n        title: response.data.title,\n        body: response.data.body,\n        html_url: response.data.html_url,\n        state: response.data.state,\n        created_at: response.data.created_at,\n        updated_at: response.data.updated_at,\n        closed_at: response.data.closed_at,\n        merged_at: response.data.merged_at,\n        user: {\n          login: response.data.user.login,\n          avatar_url: response.data.user.avatar_url\n        },\n        head: {\n          ref: response.data.head.ref,\n          sha: response.data.head.sha\n        },\n        base: {\n          ref: response.data.base.ref,\n          sha: response.data.base.sha\n        }\n      };\n    } catch (error) {\n      this.logger.apiResponse('GET', `/repos/${owner}/${repo}/pulls/${pullNumber}`, error.status || 'error', Date.now() - startTime);\n      console.error('Failed to get pull request:', error);\n      throw error;\n    }\n  }\n\n  // Search issues using GitHub search API\n  async searchIssues(query, options = {}) {\n    if (!this.isAuth()) {\n      throw new Error('Authentication required to search issues');\n    }\n\n    const startTime = Date.now();\n    this.logger.apiCall('GET', '/search/issues', { query, type: 'issue' });\n\n    try {\n      const response = await this.octokit.rest.search.issuesAndPullRequests({\n        q: query,\n        sort: options.sort || 'created',\n        order: options.order || 'desc',\n        per_page: options.per_page || 30,\n        page: options.page || 1\n      });\n\n      this.logger.apiResponse('GET', '/search/issues', response.status, Date.now() - startTime);\n\n      return {\n        total_count: response.data.total_count,\n        incomplete_results: response.data.incomplete_results,\n        items: response.data.items.map(item => ({\n          id: item.id,\n          number: item.number,\n          title: item.title,\n          body: item.body,\n          html_url: item.html_url,\n          state: item.state,\n          created_at: item.created_at,\n          updated_at: item.updated_at,\n          closed_at: item.closed_at,\n          labels: item.labels || [],\n          user: {\n            login: item.user.login,\n            avatar_url: item.user.avatar_url\n          },\n          repository: item.repository_url ? {\n            name: item.repository_url.split('/').slice(-1)[0],\n            full_name: item.repository_url.split('/').slice(-2).join('/')\n          } : null\n        }))\n      };\n    } catch (error) {\n      this.logger.apiResponse('GET', '/search/issues', error.status || 'error', Date.now() - startTime);\n      console.error('Failed to search issues:', error);\n      throw error;\n    }\n  }\n\n  // Search pull requests using GitHub search API\n  async searchPullRequests(query, options = {}) {\n    if (!this.isAuth()) {\n      throw new Error('Authentication required to search pull requests');\n    }\n\n    const startTime = Date.now();\n    this.logger.apiCall('GET', '/search/issues', { query, type: 'pr' });\n\n    try {\n      const response = await this.octokit.rest.search.issuesAndPullRequests({\n        q: query,\n        sort: options.sort || 'created',\n        order: options.order || 'desc',\n        per_page: options.per_page || 30,\n        page: options.page || 1\n      });\n\n      this.logger.apiResponse('GET', '/search/issues', response.status, Date.now() - startTime);\n\n      return {\n        total_count: response.data.total_count,\n        incomplete_results: response.data.incomplete_results,\n        items: response.data.items.map(item => ({\n          id: item.id,\n          number: item.number,\n          title: item.title,\n          body: item.body,\n          html_url: item.html_url,\n          state: item.state,\n          created_at: item.created_at,\n          updated_at: item.updated_at,\n          closed_at: item.closed_at,\n          user: {\n            login: item.user.login,\n            avatar_url: item.user.avatar_url\n          },\n          repository: item.repository_url ? {\n            name: item.repository_url.split('/').slice(-1)[0],\n            full_name: item.repository_url.split('/').slice(-2).join('/')\n          } : null\n        }))\n      };\n    } catch (error) {\n      this.logger.apiResponse('GET', '/search/issues', error.status || 'error', Date.now() - startTime);\n      console.error('Failed to search pull requests:', error);\n      throw error;\n    }\n  }\n\n  // Logout\n  logout() {\n    this.logger.auth('Logging out and clearing stored token');\n    \n    this.octokit = null;\n    this.isAuthenticated = false;\n    this.tokenType = null;\n    this.permissions = null;\n    \n    // Clear secure token storage\n    secureTokenStorage.clearToken();\n    \n    // Clear branch context on logout\n    try {\n      const { default: branchContextService } = require('../services/branchContextService');\n      branchContextService.clearAllBranchContext();\n    } catch (error) {\n      // Service might not be available during testing\n      sessionStorage.removeItem('sgex_branch_context');\n    }\n  }\n\n  // Get repository forks\n  async getRepositoryForks(owner, repo, options = {}) {\n    const startTime = Date.now();\n    this.logger.debug('Fetching repository forks', { owner, repo, options });\n\n    try {\n      // Create temporary Octokit instance for unauthenticated access if needed\n      const octokit = this.isAuth() ? this.octokit : await this.createOctokitInstance();\n      \n      this.logger.apiCall('GET', `/repos/${owner}/${repo}/forks`, options);\n      \n      const { data } = await octokit.rest.repos.listForks({\n        owner,\n        repo,\n        sort: 'newest', // Sort by newest first\n        per_page: options.per_page || 100,\n        page: options.page || 1\n      });\n\n      const duration = Date.now() - startTime;\n      this.logger.apiResponse('GET', `/repos/${owner}/${repo}/forks`, 200, duration, { forkCount: data.length });\n      this.logger.performance('Repository forks fetch', duration);\n\n      return data;\n    } catch (error) {\n      const duration = Date.now() - startTime;\n      this.logger.apiError('GET', `/repos/${owner}/${repo}/forks`, error);\n      this.logger.performance('Repository forks fetch (failed)', duration);\n      console.error(`Failed to fetch forks for ${owner}/${repo}:`, error);\n      throw error;\n    }\n  }\n\n  // Check if the current user can review pull requests\n  async checkPullRequestReviewPermissions(owner, repo, pullNumber) {\n    try {\n      if (!this.isAuth()) {\n        return false;\n      }\n\n      // Check if user has write access or is a collaborator\n      const hasWriteAccess = await this.checkRepositoryWritePermissions(owner, repo);\n      \n      if (hasWriteAccess) {\n        return true;\n      }\n\n      // For forks, check if user can review (they need read access at minimum)\n      const response = await this.octokit.rest.repos.get({\n        owner,\n        repo\n      });\n\n      return response.status === 200;\n    } catch (error) {\n      console.debug('Cannot check PR review permissions:', error);\n      return false;\n    }\n  }\n\n  // Create a pull request review (approve, request changes, or comment)\n  async createPullRequestReview(owner, repo, pullNumber, event, body = '') {\n    if (!this.isAuth()) {\n      throw new Error('Authentication required to review pull requests');\n    }\n\n    const startTime = Date.now();\n    this.logger.apiCall('POST', `/repos/${owner}/${repo}/pulls/${pullNumber}/reviews`, { event, bodyLength: body?.length });\n\n    try {\n      const params = {\n        owner,\n        repo,\n        pull_number: pullNumber,\n        event // 'APPROVE', 'REQUEST_CHANGES', or 'COMMENT'\n      };\n\n      if (body && body.trim()) {\n        params.body = body;\n      }\n\n      const response = await this.octokit.rest.pulls.createReview(params);\n      \n      this.logger.apiResponse('POST', `/repos/${owner}/${repo}/pulls/${pullNumber}/reviews`, response.status, Date.now() - startTime);\n      \n      return {\n        success: true,\n        review: {\n          id: response.data.id,\n          state: response.data.state,\n          body: response.data.body,\n          html_url: response.data.html_url,\n          submitted_at: response.data.submitted_at,\n          user: {\n            login: response.data.user.login,\n            avatar_url: response.data.user.avatar_url\n          }\n        }\n      };\n    } catch (error) {\n      this.logger.apiResponse('POST', `/repos/${owner}/${repo}/pulls/${pullNumber}/reviews`, error.status || 'error', Date.now() - startTime);\n      console.error('Failed to create pull request review:', error);\n      throw error;\n    }\n  }\n\n  // Approve a pull request\n  async approvePullRequest(owner, repo, pullNumber, body = '') {\n    return this.createPullRequestReview(owner, repo, pullNumber, 'APPROVE', body);\n  }\n\n  // Request changes on a pull request\n  async requestPullRequestChanges(owner, repo, pullNumber, body) {\n    if (!body || !body.trim()) {\n      throw new Error('A comment is required when requesting changes');\n    }\n    return this.createPullRequestReview(owner, repo, pullNumber, 'REQUEST_CHANGES', body);\n  }\n\n  // Dismiss a pull request review\n  async dismissPullRequestReview(owner, repo, pullNumber, reviewId, message) {\n    if (!this.isAuth()) {\n      throw new Error('Authentication required to dismiss reviews');\n    }\n\n    const startTime = Date.now();\n    this.logger.apiCall('PUT', `/repos/${owner}/${repo}/pulls/${pullNumber}/reviews/${reviewId}/dismissals`, { messageLength: message?.length });\n\n    try {\n      const response = await this.octokit.rest.pulls.dismissReview({\n        owner,\n        repo,\n        pull_number: pullNumber,\n        review_id: reviewId,\n        message: message || 'Review dismissed'\n      });\n      \n      this.logger.apiResponse('PUT', `/repos/${owner}/${repo}/pulls/${pullNumber}/reviews/${reviewId}/dismissals`, response.status, Date.now() - startTime);\n      \n      return {\n        success: true,\n        review: response.data\n      };\n    } catch (error) {\n      this.logger.apiResponse('PUT', `/repos/${owner}/${repo}/pulls/${pullNumber}/reviews/${reviewId}/dismissals`, error.status || 'error', Date.now() - startTime);\n      console.error('Failed to dismiss pull request review:', error);\n      throw error;\n    }\n  }\n\n  // Convert draft pull request to ready for review\n  async markPullRequestReadyForReview(owner, repo, pullNumber) {\n    if (!this.isAuth()) {\n      throw new Error('Authentication required to mark PR as ready for review');\n    }\n\n    const startTime = Date.now();\n    this.logger.apiCall('PATCH', `/repos/${owner}/${repo}/pulls/${pullNumber}`, { draft: false });\n\n    try {\n      const response = await this.octokit.rest.pulls.update({\n        owner,\n        repo,\n        pull_number: pullNumber,\n        draft: false\n      });\n      \n      this.logger.apiResponse('PATCH', `/repos/${owner}/${repo}/pulls/${pullNumber}`, response.status, Date.now() - startTime);\n      \n      return {\n        success: true,\n        pullRequest: {\n          id: response.data.id,\n          number: response.data.number,\n          draft: response.data.draft,\n          state: response.data.state,\n          title: response.data.title,\n          html_url: response.data.html_url\n        }\n      };\n    } catch (error) {\n      this.logger.apiResponse('PATCH', `/repos/${owner}/${repo}/pulls/${pullNumber}`, error.status || 'error', Date.now() - startTime);\n      console.error('Failed to mark pull request as ready for review:', error);\n      throw error;\n    }\n  }\n}\n\n// Create a singleton instance\nconst githubService = new GitHubService();\n\nexport default githubService;","/**\n * Service for managing DAK branch context in session storage\n * Stores selected branch per repository to maintain context during DAK editing\n */\n\nclass BranchContextService {\n  constructor() {\n    this.storageKey = 'sgex_branch_context';\n  }\n\n  // Get the storage key for a specific repository\n  getRepositoryKey(repository) {\n    if (!repository || !repository.name) return null;\n    const owner = repository.owner?.login || repository.full_name?.split('/')[0];\n    if (!owner) return null;\n    return `${owner}/${repository.name}`;\n  }\n\n  // Get the selected branch for a repository\n  getSelectedBranch(repository) {\n    if (!repository) return null;\n    \n    try {\n      const branchContext = this.getBranchContext();\n      const repoKey = this.getRepositoryKey(repository);\n      return branchContext[repoKey] || null;\n    } catch (error) {\n      console.warn('Failed to get branch context:', error);\n      return null;\n    }\n  }\n\n  // Set the selected branch for a repository\n  setSelectedBranch(repository, branch) {\n    if (!repository || !branch) return;\n\n    try {\n      const branchContext = this.getBranchContext();\n      const repoKey = this.getRepositoryKey(repository);\n      branchContext[repoKey] = branch;\n      this.setBranchContext(branchContext);\n    } catch (error) {\n      console.warn('Failed to set branch context:', error);\n    }\n  }\n\n  // Clear branch context for a specific repository\n  clearRepositoryBranch(repository) {\n    if (!repository) return;\n\n    try {\n      const branchContext = this.getBranchContext();\n      const repoKey = this.getRepositoryKey(repository);\n      delete branchContext[repoKey];\n      this.setBranchContext(branchContext);\n    } catch (error) {\n      console.warn('Failed to clear repository branch context:', error);\n    }\n  }\n\n  // Clear all branch context (e.g., on logout)\n  clearAllBranchContext() {\n    try {\n      sessionStorage.removeItem(this.storageKey);\n    } catch (error) {\n      console.warn('Failed to clear branch context:', error);\n    }\n  }\n\n  // Get all branch context from storage\n  getBranchContext() {\n    try {\n      const stored = sessionStorage.getItem(this.storageKey);\n      return stored ? JSON.parse(stored) : {};\n    } catch (error) {\n      console.warn('Failed to parse branch context from storage:', error);\n      return {};\n    }\n  }\n\n  // Set branch context to storage\n  setBranchContext(context) {\n    try {\n      sessionStorage.setItem(this.storageKey, JSON.stringify(context));\n    } catch (error) {\n      console.warn('Failed to save branch context to storage:', error);\n    }\n  }\n\n  // Get default branch name (prefer 'main' over 'master')\n  getDefaultBranchName(repository, availableBranches = []) {\n    if (!repository) return 'main';\n\n    // First try 'main'\n    if (availableBranches.some(b => b.name === 'main')) {\n      return 'main';\n    }\n\n    // Then try the repository's default branch\n    if (repository.default_branch && \n        availableBranches.some(b => b.name === repository.default_branch)) {\n      return repository.default_branch;\n    }\n\n    // Finally fall back to the first available branch or 'main'\n    return availableBranches.length > 0 ? availableBranches[0].name : 'main';\n  }\n\n  // Check if a branch context exists for a repository\n  hasBranchContext(repository) {\n    return this.getSelectedBranch(repository) !== null;\n  }\n\n  // Get a formatted display string for the current branch context\n  getBranchDisplayInfo(repository) {\n    const selectedBranch = this.getSelectedBranch(repository);\n    if (!selectedBranch) return null;\n\n    const isDefault = selectedBranch === (repository?.default_branch || 'main');\n    return {\n      branch: selectedBranch,\n      isDefault,\n      displayText: isDefault ? `${selectedBranch} (default)` : selectedBranch\n    };\n  }\n}\n\n// Create a singleton instance\nconst branchContextService = new BranchContextService();\n\nexport default branchContextService;"],"names":["async","processConcurrently","items","processor","options","arguments","length","undefined","concurrency","onProgress","onItemComplete","onItemStart","results","Array","total","completed","queue","map","item","index","workers","Math","min","fill","shift","result","error","worker","Promise","all","constructor","ttlMinutes","this","cache","Map","ttl","_getCacheKey","owner","repo","concat","_isValid","entry","Date","now","timestamp","get","key","compatible","delete","set","clear","cleanup","entries","getStats","size","from","_ref","repository","ageMinutes","round","logger","getLogger","storageKey","expirationHours","debug","generateBrowserFingerprint","canvas","document","createElement","ctx","getContext","textBaseline","font","fillText","fingerprint","navigator","userAgent","language","window","screen","width","height","colorDepth","getTimezoneOffset","toDataURL","join","hash","i","charCodeAt","abs","toString","xorCipher","text","String","fromCharCode","validateTokenFormat","token","isValid","type","reason","cleanToken","trim","match","maskToken","substring","repeat","storeToken","validation","warn","tokenMask","encryptionKey","encryptedToken","storageData","btoa","created","expires","sessionStorage","setItem","JSON","stringify","localStorage","removeItem","toISOString","message","retrieveToken","storedData","getItem","data","parse","clearToken","currentFingerprint","atob","decryptedToken","hasValidToken","getTokenInfo","timeRemaining","max","isExpired","migrateLegacyToken","legacyToken","octokit","isAuthenticated","permissions","tokenType","createOctokitInstance","auth","lazyLoadOctokit","authenticate","startTime","tokenProvided","secureTokenStorage","stored","duration","securelyStored","performance","console","authenticateWithOctokit","octokitInstance","initializeFromStoredToken","tokenData","hasStoredToken","getStoredTokenInfo","checkTokenPermissions","isAuth","Error","apiCall","response","request","apiResponse","status","rateLimitStart","rateLimit","rest","resources","core","hasCore","rateLimitError","user","username","login","apiError","checkRepositoryWritePermissions","getCurrentUser","repos","getCollaboratorPermissionLevel","hasWriteAccess","includes","permission","supportedLevels","_error$response","_error$response2","statusText","headers","userGuidance","checkRepositoryPermissions","checkCommentPermissions","per_page","issues","listForRepo","state","users","getAuthenticated","getUserOrganizations","orgs","listForAuthenticatedUser","getOrganization","orgLogin","org","getUser","getByUsername","getPublicRepositories","repositories","page","hasMorePages","listForUser","sort","listForOrg","getWHOOrganization","whoData","id","display_name","name","description","avatar_url","html_url","can_create_repositories","can_create_private_repositories","plan","private_repos","isWHO","checkRateLimit","limit","rate","remaining","reset","used","search","shouldSkipApiCalls","getRepositories","getSmartGuidelinesRepositories","checkSmartGuidelinesCompatibility","retryCount","cachedResult","repositoryCompatibilityCache","cached","skipped","rateLimitCheckError","getContent","path","content","isCompatible","decodeURIComponent","escape","delay","resolve","setTimeout","log","publicOctokit","requiresAuthentication","publicApiError","errorInfo","errorType","_categorizeError","retryable","_isRetryableError","code","skipCompatibilityCheck","_objectSpread","smart_guidelines_compatible","smartGuidelinesRepos","push","getSmartGuidelinesRepositoriesProgressive","onRepositoryFound","onError","current","currentRepo","progress","scanningErrors","rateLimited","networkErrors","permissionDenied","otherErrors","totalErrors","totalScanned","random","compatibilityResult","smartRepo","validResults","progressData","rateLimitedCount","networkErrorCount","hasRetryableErrors","some","e","started","filter","getRepository","getBranches","listBranches","createBranch","branchName","fromBranch","refData","git","getRef","ref","createRef","sha","object","getBranch","branch","getWorkflows","actions","listRepoWorkflows","workflows","workflow","filename","split","pop","created_at","updated_at","url","triggers","lastModified","getWorkflowRuns","params","workflow_id","listWorkflowRunsForRepo","getWorkflowRunsForWorkflow","listWorkflowRuns","triggerWorkflow","inputs","createWorkflowDispatch","rerunWorkflow","run_id","reRunWorkflow","getWorkflowRunLogs","downloadWorkflowRunLogs","approveWorkflowRun","getCommitDiff","base","head","compareCommits","getCommit","getReleases","listReleases","getLatestRelease","getBpmnFilesRecursive","allFiles","isArray","endsWith","getBpmnFiles","allBpmnFiles","possiblePaths","files","uniqueFiles","file","self","findIndex","f","getFileContent","timeoutMs","timeoutPromise","_","reject","apiPromise","race","responseTime","encoding","hasContent","Buffer","decodeError","_error$stack","stack","createCommit","latestCommitSha","commitData","commit_sha","baseTreeSha","tree","blobs","blobData","createBlob","mode","treeData","createTree","base_tree","newCommitData","parents","updateRef","author","committer","getRecentCommits","listCommits","commit","email","date","stats","getOpenPullRequestsCount","pulls","list","linkHeader","link","lastPageMatch","parseInt","getPullRequestForBranch","prs","getPullRequestsForBranch","getPullRequestComments","pullNumber","listReviewComments","pull_number","getPullRequestIssueComments","listComments","issue_number","createPullRequestComment","body","createComment","getPullRequestTimeline","listEventsForTimeline","mergePullRequest","mergeOptions","commit_title","commit_message","merge_method","merge","checkPullRequestMergePermissions","pr","draft","getOpenIssuesCount","getRepositoryStats","recentCommits","openPRsCount","openIssuesCount","allSettled","value","openPullRequestsCount","errors","getDirectoryContents","updateFile","currentFile","createOrUpdateFileContents","unescape","encodeURIComponent","getCommits","since","until","getIssues","labels","milestone","getRepositoryIssues","getForks","listForks","fork","full_name","clone_url","pushed_at","stargazers_count","forks_count","open_issues_count","default_branch","private","parent","getPullRequests","direction","number","title","locked","closed_at","merged_at","diff_url","patch_url","mergeable","mergeable_state","comments","review_comments","commits","additions","deletions","changed_files","createIssue","assignees","bodyLength","create","success","issue","label","color","getIssue","issueNumber","getPullRequest","searchIssues","query","issuesAndPullRequests","q","order","total_count","incomplete_results","repository_url","slice","searchPullRequests","logout","default","branchContextService","require","clearAllBranchContext","getRepositoryForks","forkCount","checkPullRequestReviewPermissions","createPullRequestReview","event","createReview","review","submitted_at","approvePullRequest","requestPullRequestChanges","dismissPullRequestReview","reviewId","messageLength","dismissReview","review_id","markPullRequestReadyForReview","update","pullRequest","getRepositoryKey","_repository$owner","_repository$full_name","getSelectedBranch","branchContext","getBranchContext","setSelectedBranch","setBranchContext","clearRepositoryBranch","context","getDefaultBranchName","availableBranches","b","hasBranchContext","getBranchDisplayInfo","selectedBranch","isDefault","displayText"],"sourceRoot":""}